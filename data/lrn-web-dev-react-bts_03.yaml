- en: Chapter 3. ReactJS-JSX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。ReactJS-JSX
- en: In the previous chapter, we went through the process of building responsive
    themes with the help of React-Bootstrap and React. We saw examples for it and
    the difference between Twitter Bootstrap and React-Bootstrap.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过使用React-Bootstrap和React来构建响应式主题的过程。我们看到了它的示例以及Twitter Bootstrap和React-Bootstrap之间的区别。
- en: I'm very excited now as we are going to look into the core of ReactJS, which
    is JSX. So, are you ready folks? Let's dive deep into learning about ReactJS-JSX.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在非常兴奋，因为我们将深入了解ReactJS的核心，即JSX。那么，你们准备好了吗？让我们深入学习ReactJS-JSX。
- en: What is JSX in React
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中的JSX是什么
- en: JSX is an extension of JavaScript syntax, and if you observe the syntax or structure
    of JSX, you will find it similar to XML coding.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是JavaScript语法的扩展，如果您观察JSX的语法或结构，您会发现它类似于XML编码。
- en: With JSX, you can carry out preprocessor footsteps that add XML syntax to JavaScript.
    Though you can certainly use React without JSX, JSX makes React a lot more neat
    and elegant. Similar to XML, JSX tags have tag names, attributes, and children,
    and in that, if an attribute value is enclosed in quotes, that value becomes a
    string.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSX，您可以执行预处理步骤，将XML语法添加到JavaScript中。虽然您当然可以在没有JSX的情况下使用React，但JSX使React变得更加整洁和优雅。与XML类似，JSX标记具有标记名称、属性和子级，如果属性值被引号括起来，该值就成为一个字符串。
- en: XML works with balanced opening and closing tags. JSX works similarly, and it
    also helps to read and understand a huge amount of structures easily than JavaScript
    functions and objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: XML使用平衡的开放和关闭标记。JSX类似地工作，它还有助于比JavaScript函数和对象更容易地阅读和理解大量的结构。
- en: Advantages of using JSX in React
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React中使用JSX的优点
- en: 'Here is a list of a few advantages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优点的列表：
- en: JSX is very simple to understand and think about, as compared to JavaScript
    functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与JavaScript函数相比，JSX非常容易理解和思考
- en: Markup of JSX would be more familiar to non-programmers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX的标记更容易让非程序员熟悉
- en: By using JSX, your markup becomes more semantic, organized, and significant
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用JSX，您的标记变得更有语义、有组织和有意义
- en: How to make your code neat and clean
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使您的代码整洁和干净
- en: As I said earlier, the structure/syntax is so easy to visualize/notice, which
    is intended for more clean and understandable code in JSX format when we compare
    it with JavaScript syntax.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，这种结构/语法非常容易可视化/注意到，这意味着当我们将其与JavaScript语法进行比较时，JSX格式的代码更加清晰和易于理解。
- en: 'The following are simple code snippets that will give you a clear idea. Let''s
    see the code snippets in the following example of JavaScript syntax while rendering:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是简单的代码片段，将给你一个清晰的想法。让我们看看在渲染时JavaScript语法的以下示例中的代码片段：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Observe the following JSX syntax:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下JSX语法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I'm assuming that it is clear now that JSX is really easy to understand for
    programmers who are generally not used to dealing with coding, and they can learn
    and execute it as if they are executing HTML language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设现在很清楚JSX对于通常不习惯处理编码的程序员来说是非常容易理解的，并且他们可以学习和执行它，就像执行HTML语言一样。
- en: Acquaintance or understanding
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉或理解
- en: In the development region, UI developers, user experience designers, and quality
    assurance people are not very familiar with any programming language, but JSX
    makes their life easy by providing a simple syntax structure, which is visually
    similar to a HTML structure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发领域，UI开发人员、用户体验设计师和质量保证人员并不太熟悉任何编程语言，但JSX通过提供简单的语法结构使他们的生活变得更加轻松，这个结构在视觉上类似于HTML结构。
- en: JSX shows a path to indicate and see through your mind's eye, the structure
    in a solid and concise way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JSX显示了一种路径，以一种坚实而简洁的方式指示和看到您的思维结构。
- en: Semantics/structured syntax
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义/结构化语法
- en: Until now, we have seen how JSX syntax is easy to understand and visualize,
    the reason being the semantic syntax structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了JSX语法是如何易于理解和可视化的，原因在于语义化的语法结构。
- en: JSX converts your JavaScript code into a more standard solution, which gives
    clarity to set your semantic syntax and significant component. With the help of
    JSX syntax, you can declare the structure of your custom component with information,
    the way you do in HTML syntax, and that will provide the magic to transform your
    syntax to JavaScript functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JSX将您的JavaScript代码转换为更标准的解决方案，这样可以清晰地设置您的语义化语法和重要组件。借助于JSX语法，您可以声明自定义组件的结构和信息，就像在HTML语法中一样，这将为您的语法转换为JavaScript函数提供魔力。
- en: 'The `React.DOM` namespace helps us to use all HTML elements with the help of
    ReactJS: Isn''t it an amazing feature! Moreover, the good part is that you can
    write your own named components with the help of the `React.DOM` namespace.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.DOM`命名空间帮助我们使用所有HTML元素，借助于ReactJS：这不是一个令人惊讶的功能吗！而且，好处是您可以使用`React.DOM`命名空间编写自己命名的组件。'
- en: 'Please check out the following simple HTML markup and how JSX components help
    you to have semantic markup:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下简单的HTML标记以及JSX组件如何帮助您创建语义化标记：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in the preceding example, we have wrapped `<h2>Questions</h2><hr
    />` with the `<div>` tag, which has a `className="divider"`. So, in the React
    composite component, you can create a similar structure and it is as easy as when
    working with HTML coding with semantic syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中所看到的，我们用`<div>`标记包裹了`<h2>Questions</h2><hr />`，并且`<div>`标记具有`className="divider"`。因此，在React复合组件中，您可以创建类似的结构，就像在使用语义化语法的HTML编码时一样简单：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's see in detail what the composite component is and how we can build it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解一下复合组件是什么，以及我们如何构建它。
- en: The composite component
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合组件
- en: As we know, you can create your custom component with JSX markup and JSX syntax,
    and transform your component to a JavaScript syntax component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，您可以使用JSX标记和JSX语法创建自定义组件，并将您的组件转换为JavaScript语法组件。
- en: 'Let''s set up JSX:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置JSX：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Include the following files in your HTML:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的HTML中包含以下文件：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add this HTML in your `<body>` section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将此HTML添加到您的`<body>`部分。
- en: Now, we are all set to define the custom component using JSX as we have the
    JSX file ready to be worked on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用JSX定义自定义组件了。
- en: 'To create a custom component, we have to express the following mentioned HTML
    markup as a React custom component. You have to just follow the given example
    to execute your wrapped syntax/code, and in return after rendering, it will give
    you the expected markup result. The `Divider.js` file would contain:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义组件，我们必须将上述提到的HTML标记表达为React自定义组件。您只需按照给定的示例执行包装的语法/代码，然后在渲染后，它将给您预期的标记结果。`Divider.js`文件将包含：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you want to append the child node to your component then it's possible in
    React-JSX. In the preceding code, you can see that we have created one variable
    named `divider` and, with the help of React-JSX, we can use it as a HTML tag as
    we are using defined HTML tags like `<div>`, `<span>`, and so on. Do you remember
    that we have used the following markup in our earlier example? If not, then please
    refer to the previous topic again, as it will clear up your doubts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将子节点附加到您的组件中，那么在React-JSX中是可能的。在前面的代码中，您可以看到我们创建了一个名为`divider`的变量，并且借助于React-JSX，我们可以将其用作HTML标记，就像我们使用定义的HTML标记`<div>`，`<span>`等一样。您还记得我们在之前的示例中使用了以下标记吗？如果没有，请再次参考前面的主题，因为它将消除您的疑虑。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As in the HTML syntax, here the child nodes are captured between the open and
    close tags in an array, which you can set in your component's `props` (properties).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML语法一样，在这里，子节点被捕获在开放和关闭标记之间的数组中，您可以将其设置在组件的`props`（属性）中。
- en: 'In this example, we will use `this.props.children` = `["Questions"]` where
    `this.props.children` is React''s method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`this.props.children` = `["Questions"]`，其中`this.props.children`是React的方法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we have seen in the preceding example, we can create components with open
    and close tags the way we do in any HTML coding:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中看到的，我们可以像在任何HTML编码中一样创建带有开放和关闭标记的组件：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And we will get the expected output as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下预期的输出：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Namespace components
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间组件
- en: 'A namespace component is another feature request that is available in React
    JSX. I know you''ll have a question: what is a namespace component? OK, let me
    explain.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间组件是React JSX中可用的另一个功能请求。我知道你会有一个问题：什么是命名空间组件？好的，让我解释一下。
- en: We know that JSX is just an extension of JavaScript syntax and it also provides
    the ability to use namespace so React is using JSX namespace pattern rather than
    XML namespacing. By using the standard JavaScript syntax approach, which is object
    property access, this feature is useful for assigning components directly as `<Namespace.Component/>`,
    rather than assigning variables to access components that are stored in an object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道JSX只是JavaScript语法的扩展，它还提供了使用命名空间的能力，因此React使用JSX命名空间模式而不是XML命名空间。通过使用标准的JavaScript语法方法，即对象属性访问，这个功能对于直接分配组件作为`<Namespace.Component/>`而不是分配变量来访问存储在对象中的组件非常有用。
- en: 'Let''s start by looking at the following show/hide example to have a clear
    idea about namespace components:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下的显示/隐藏示例开始，以便清楚地了解命名空间组件：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the following example, we will see how we can compose a `MessagePanel`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下示例中，我们将看到如何组合`MessagePanel`：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A `MessagePanel` is a component that consents to rendering a message in your
    user interface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagePanel`是一个组件，用于在用户界面中呈现消息。'
- en: 'It primarily has two sections:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要有两个部分：
- en: '`MessagePanelHeading`: This displays the heading/title of the message'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessagePanelHeading`：这显示消息的标题'
- en: '`MessagePanelContent`: This is the content of the message'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessagePanelContent`：这是消息的内容'
- en: There is a healthier way to compose `MessagePanel` by *namespacing* the children.
    This can be achieved by making child components as attributes on the parent component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更健康的方式来组成`MessagePanel`，即通过将子组件作为父组件的属性来实现。
- en: 'Let''s see how to do this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, in the preceding snippets, you can see how we have extended `MessagePanel`
    by just adding new React components, `Heading` and `Content`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的代码片段中，您可以看到我们如何通过只添加新的React组件`Heading`和`Content`来扩展`MessagePanel`。
- en: 'Now, let''s see how the composition changes when we bring the namespace notation
    :'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们引入命名空间符号时，组合会发生什么变化：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we will see practical examples of namespace component code after integrating
    in React with Bootstrap:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在React中与Bootstrap集成后看到命名空间组件代码的实际示例：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let me explain the preceding code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下前面的代码：
- en: The `State` property contains the state set by `setState` and `getInitialState`
    of our component
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State`属性包含我们组件的`setState`和`getInitialState`设置的状态'
- en: The `setState(changes)` method applies the given changes to this state and re-renders
    it
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setState(changes)`方法将给定的更改应用于此状态并重新呈现它'
- en: The `handleToggle` function handles the state of our component and returns the
    Boolean values `true` or `false`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleToggle`函数处理我们组件的状态并返回布尔值`true`或`false`'
- en: 'We have also used some Bootstrap classes to give a look and feel to our component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一些Bootstrap类来赋予我们的组件外观和感觉：
- en: '`.collapse`: This is for hiding the content.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.collapse`：这是用于隐藏内容的。'
- en: '`.collapse.in`: This is for showing the content.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.collapse.in`：这是用于显示内容的。'
- en: '`.well`: This is for background, border, and spacing around the content.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.well`：这是用于内容周围的背景、边框和间距。'
- en: '`.btn .btn-primary`: This is for the button look and feel. Bootstrap has also
    provided you some different classes with different color styles that help readers
    to provide a visual indication:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.btn .btn-primary`：这是按钮的外观。Bootstrap还为您提供了一些不同颜色样式的不同类，帮助读者提供视觉指示：'
- en: '`.btn-default`, `.btn-success`, `.btn-info`, `.btn-warning`, `.btn-danger`,
    and `.btn-link`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.btn-default`、`.btn-success`、`.btn-info`、`.btn-warning`、`.btn-danger`和`.btn-link`。'
- en: We can use `<a>`, `<button>`, or the `<input>`element.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`<a>`、`<button>`或`<input>`元素。
- en: '`.col-sm-12`: This is to make your component responsive on small screens.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.col-sm-12`：这是为了使你的组件在小屏幕上响应。'
- en: 'Now, let''s open your HTML in a browser and look at the output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在浏览器中打开你的HTML并查看输出：
- en: '![Namespace components](graphics/image_03_001.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![命名空间组件](graphics/image_03_001.jpg)'
- en: 'Now resize the screen and see how it looks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调整屏幕大小，看看效果：
- en: '![Namespace components](graphics/image_03_002.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![命名空间组件](graphics/image_03_002.jpg)'
- en: It looks amazing!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！
- en: JSXTransformer
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSXTransformer
- en: '**JSXTransformer** is another tool to compile JSX in a browser. While reading
    code, the browser will read `attribute type="text/jsx"` in your mentioned `<script>`
    tag and it will only transform those scripts that have a mentioned `type` attribute
    and then it will execute your script or written function in that file. The code
    will be executed in the same manner as `react-tools` executes on the server. Visit
    [https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html](https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html)
    for more.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSXTransformer**是另一个在浏览器中编译JSX的工具。在阅读代码时，浏览器将读取你所提到的`<script>`标签中的`attribute
    type="text/jsx"`，它只会转换那些具有提到`type`属性的脚本，然后执行你的脚本或文件中的函数。代码将以与`react-tools`在服务器上执行的相同方式执行。访问[https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html](https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html)了解更多。'
- en: JSXTransformer is deprecating in the current version of React, but you can find
    the current version on any provided CDNs and Bower. As per my opinion, it would
    be great to use the **Babel REPL** ([https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&code=](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&code=))
    tool to compile JavaScript. It has already been adopted by React and the broader
    JavaScript community.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JSXTransformer在当前版本的React中已经被弃用，但你可以在任何提供的CDN和Bower上找到当前版本。依我看来，使用**Babel REPL**([https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&code=](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&code=))工具来编译JavaScript会很棒。它已经被React和更广泛的JavaScript社区所采用。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example will not work with the latest version of React. Use an older version
    such as 0.13, as JSXTransformer is deprecated and it's replaced by Babel to transform
    and run the JSX code in the browser. The browser will only understand your `<script>`
    tags when it has the `type="text/babel"` type attribute, which we have used previously
    in examples from [Chapter 1,](ch01.html "Chapter 1. Getting Started with React
    and Bootstrap") *Getting Started with React and Bootstrap* and [Chapter 2,](ch02.html
    "Chapter 2. Lets Build a Responsive Theme with React-Bootstrap and React") *Lets
    Build a Responsive Theme with React-Bootstrap and React*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在最新版本的React中不起作用。使用旧版本，比如0.13，因为JSXTransformer已经被弃用，它被Babel所取代，用于在浏览器中转换和运行JSX代码。当浏览器具有`type="text/babel"`类型属性时，它才能理解你的`<script>`标签，我们之前在[第一章](ch01.html
    "第一章。使用React和Bootstrap入门")和[第二章](ch02.html "第二章。使用React-Bootstrap和React构建响应式主题")的例子中使用过这种类型属性。
- en: Attribute expressions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性表达式
- en: 'If you look at the preceding show/hide example, you can see that we have used
    attribute expressions to show the message panel and hide it. In React, there is
    a small change in writing an attribute value, in JavaScript expressions we write
    attributes in quotes (`""`), but in React we have to provide a pair of curly braces
    (`{}`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下前面的显示/隐藏示例，您会发现我们使用属性表达式来显示消息面板并隐藏它。在React中，写属性值有一个小改变，在JavaScript表达式中，我们用引号(`""`)来写属性，但在React中，我们必须提供一对花括号(`{}`)：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Boolean attributes
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔属性
- en: Boolean attributes have two values, they can either be `true` or `false`, and
    if we neglect the value in JSX while declaring attributes, then by default it
    takes the value as `true`. If we want to have a `false` attribute value, then
    we have to use an attribute expression. This scenario can occur regularly when
    we use HTML form elements, for example, the `disabled` attribute, the `required`
    attribute, the `checked` attribute, and the `readOnly` attribute.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔属性有两个值，它们可以是`true`或`false`，如果我们在JSX中声明属性时忽略了值，那么默认情况下它会取值为`true`。如果我们想要一个`false`属性值，那么我们必须使用属性表达式。当我们使用HTML表单元素时，这种情况经常发生，例如`disabled`属性，`required`属性，`checked`属性和`readOnly`属性。
- en: 'In the Bootstrap example `aria-haspopup="true"aria-expanded="true"`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bootstrap示例中`aria-haspopup="true"aria-expanded="true"`：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: JavaScript expressions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript表达式
- en: As seen in the preceding example, you can embed JavaScript expressions in JSX
    using syntax that will be accustomed to any handlebars user, for example, `style
    = { displayStyle }` allocates the value of the `displayStyle` JavaScript variable
    to the element's `style` attribute.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，您可以使用在任何句柄用户习惯的语法中在JSX中嵌入JavaScript表达式，例如，`style = { displayStyle }`将`displayStyle`
    JavaScript变量的值分配给元素的`style`属性。
- en: Styles
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: The same as expressions, you can set styles by assigning an ordinary JavaScript
    object to the `style` attribute. How interesting. If someone tells you not to
    write CSS syntax, you can still write JavaScript code to achieve this, with no
    extra effort. Isn't that superb! Yes, it is.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与表达式一样，您可以通过将普通的JavaScript对象分配给`style`属性来设置样式。多么有趣。如果有人告诉你不要编写CSS语法，您仍然可以编写JavaScript代码来实现这一点，而不需要额外的努力。这不是很棒吗！是的，确实如此。
- en: Events
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: There is a set of event handlers that you can bind in a way that should look
    familiar to anybody who knows HTML.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组事件处理程序，您可以以一种熟悉HTML的方式绑定它们。
- en: 'Some names of React event handlers are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一些React事件处理程序的名称如下：
- en: Clipboard events
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板事件
- en: Composition events
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合事件
- en: Keyboard events
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘事件
- en: Focus events
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点事件
- en: Form events
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件
- en: Mouse events
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: Selection events
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择事件
- en: Touch events
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸事件
- en: UI events
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI事件
- en: Wheel events
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚轮事件
- en: Media events
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体事件
- en: Image events
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像事件
- en: Animation events
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画事件
- en: Transition events
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡事件
- en: Attributes
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'Some defined `PropTypes` of JSX are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JSX的一些定义的`PropTypes`如下：
- en: '`React.PropTypes.array`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.array`'
- en: '`React.PropTypes.bool`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.bool`'
- en: '`React.PropTypes.func`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.func`'
- en: '`React.PropTypes.number`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.number`'
- en: '`React.PropTypes.object`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.object`'
- en: '`React.PropTypes.string`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.string`'
- en: '`React.PropTypes.symbol`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.symbol`'
- en: 'If you are aware of all the properties well in advance, then it will be helpful
    when creating your component in JSX:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提前了解所有属性，那么在使用JSX创建组件时会很有帮助：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Changing `props` is bad practice, let's see how.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 改变`props`是不好的做法，让我们看看为什么。
- en: 'Generally, as per our practice, we set properties on to the object that is
    non-recommended standard in attribute:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，根据我们的做法，我们将属性设置为非推荐的标准对象：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As shown in the preceding example, you can see the anti-pattern, which is not
    best practice. If you don't know about properties of JSX attributes then `propTypes`
    won't be set and it will throw errors that would be difficult for you to trace.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，您可以看到反模式，这不是最佳实践。如果您不了解JSX属性的属性，则`propTypes`将不会被设置，并且将抛出难以跟踪的错误。
- en: '`props` are a very sensitive part of attributes, so you should not change them,
    as each prop has a predefined method and you should use it as it is meant to be
    used, like when we use other JavaScript methods or HTML tags. This doesn''t mean
    that it is impossible to change `props`. It is possible, but it is against the
    standard defined by React. Even in React, it will throw an error.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`props`是属性的一个非常敏感的部分，所以您不应该更改它们，因为每个prop都有一个预定义的方法，您应该按照其预期的方式使用它，就像我们使用其他JavaScript方法或HTML标签时一样。这并不意味着不可能更改`props`。这是可能的，但这违反了React定义的标准。即使在React中，它也会抛出错误。'
- en: Spread attributes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展属性
- en: 'Let''s check out the JSX feature--spread attributes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看JSX的特性--扩展属性：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see in the preceding example, the properties that you have declared
    have become part of your component's `props` as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您声明的属性也已成为组件的`props`的一部分。
- en: 'Reusability of attributes is also possible here and you can also map it with
    other attributes. But you have to be very careful in ordering your attributes
    while you declare it, as it will override the previous declared attribute with
    the last declared one:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的可重用性在这里也是可能的，您还可以将其与其他属性进行映射。但是在声明属性时，您必须非常小心，因为它将覆盖先前声明的属性，最后声明的属性将覆盖之前的属性。
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hopefully, you now have a clear idea about JSX, JSX expressions, and attributes.
    So, let's check out how we can build simple forms with the help of JSX dynamically.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您现在对JSX、JSX表达式和属性有了清楚的了解。那么，让我们看看如何使用JSX动态构建简单的表单。
- en: Example of a dynamic form with JSX
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSX构建动态表单的示例
- en: Before starting on a dynamic form with JSX, we must be aware of JSX form libraries.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JSX构建动态表单之前，我们必须了解JSX表单库。
- en: Generally, HTML form element inputs take their value as display text/values,
    but in React JSX, they take property values of respective elements and display
    it. As we have already visually perceived that we can't change `props` values
    directly, so the input value won't have that transmuted value as an exhibit value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HTML表单元素输入将其值作为显示文本/值，但在React JSX中，它们将相应元素的属性值作为显示文本/值。由于我们已经直观地感知到我们不能直接更改`props`的值，所以输入值不会具有转变后的值作为展示值。
- en: Let's discuss this in detail. To change the value of a form input you will use
    the `value` attribute and then you will see no change. That doesn't mean that
    we cannot change the form input value, but for that we need to listen to the input
    events and you will see that the value changes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下。要更改表单输入的值，您将使用`value`属性，然后您将看不到任何更改。这并不意味着我们不能更改表单输入的值，但是为此我们需要监听输入事件，然后您将看到值的变化。
- en: 'The following exceptions are self-explanatory, but very important:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下异常是不言自明的，但非常重要：
- en: '`Textarea` content will be considered as a `value` prop in React'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中，`Textarea`内容将被视为`value`属性。
- en: As `For` is a reserved keyword of JavaScript, the HTML for the attribute should
    be bounded like the `htmlFor` prop
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`For`是JavaScript的保留关键字，HTML的`for`属性应该像`htmlFor`prop一样被绑定
- en: Now it's time to learn that to have form elements in the output, we need to
    use the following script, and we also need to replace it with the previously written
    code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习了，为了在输出中拥有表单元素，我们需要使用以下脚本，并且还需要用先前编写的代码替换它。
- en: Now let's start on building an Add Ticket form for our application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始为我们的应用程序构建一个添加工单表单。
- en: Create a `React-JSXform.html` file in the root. The following code snippet is
    just a base HTML page that includes Bootstrap and React.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录中创建一个`React-JSXform.html`文件。以下代码片段只是一个包含Bootstrap和React的基本HTML页面。
- en: 'Here is the markup of our HTML page:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们HTML页面的标记：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is always good practice to load all your scripts at the bottom of the page
    before your `<body>` tag closes, which loads the component successfully in your
    DOM, because when the script is executed in the `<head>` section, the document
    element is not available because the script itself is in the `<head>` section.
    The best solution to resolve this problem is to keep scripts at the bottom of
    your page before your `<body>` tag closes, and it will be executed after loading
    all your DOM elements, which will not throw any JavaScript error.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有脚本加载到页面底部，在`<body>`标签关闭之前，总是一个良好的做法，这样可以成功加载组件到DOM中，因为当脚本在`<head>`部分执行时，文档元素不可用，因为脚本本身在`<head>`部分。解决此问题的最佳方法是将脚本保持在页面底部，在`<body>`标签关闭之前执行，这样在加载所有DOM元素后执行，不会引发任何JavaScript错误。
- en: 'Now let''s create `<form>` elements with Bootstrap and JSX:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Bootstrap和JSX创建`<form>`元素：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we have used `class` as `className` and `for` as `htmlFor`,
    since JSX is similar to JavaScript and `for` and `class` are identifiers in JavaScript.
    We should use `className` and `htmlFor` as property names in the `ReactDOM` component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用`class`作为`className`，`for`作为`htmlFor`，因为JSX类似于JavaScript，而`for`和`class`是JavaScript中的标识符。我们应该在`ReactDOM`组件中将`className`和`htmlFor`作为属性名称使用。
- en: All the form elements `<input>`, `<select>`, and `<textarea>` will get the global
    styling with the `.form-control` class, and will apply the `width:100%` by default.
    So when we are using a label with inputs, we need to wrap it with a `.form-group`
    class for optimum spacing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表单元素`<input>`、`<select>`和`<textarea>`都将使用`.form-control`类获得全局样式，并默认应用`width:100%`。因此，当我们在输入框中使用标签时，我们需要使用`.form-group`类进行包装，以获得最佳间距。
- en: 'For our Add Ticket form, we need these following form fields along with the
    label:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的添加工单表单，我们需要以下表单字段以及标签：
- en: '`Email: <input>`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`邮箱：<input>`'
- en: '`Issue type: <select>`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`问题类型：<select>`'
- en: '`Assign department: <select>`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分配部门：<select>`'
- en: '`Comments: <textarea>`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`评论：<textarea>`'
- en: '`Button: <button>`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮：<button>`'
- en: To make it a responsive form, we will use `*col-*` classes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其成为响应式表单，我们将使用`*col-*`类。
- en: 'Let''s take a quick look at our form component code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下我们的表单组件代码：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To apply a style or call an `onSubmit` function in the attribute value, rather
    than using quotes (`""`), we have to use a pair of curly braces (`{}`) in the
    JavaScript expression. Now, create one `component` folder and save this file as
    a `form.js` in that folder, and then include it in your HTML page. This is what
    our page will look like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性值中应用样式或调用`onSubmit`函数，而不是使用引号(`""`)，我们必须在JavaScript表达式中使用一对花括号(`{}`)。现在，创建一个`component`文件夹，并将此文件保存为`form.js`，然后将其包含在您的HTML页面中。这是我们页面的样子：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s take a quick look at our component''s output in the browser:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下我们组件在浏览器中的输出：
- en: '![Example of a dynamic form with JSX](graphics/image_03_003.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![JSX动态表单示例](graphics/image_03_003.jpg)'
- en: Oh, cool! This is looking awesome.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，太酷了！看起来很棒。
- en: 'Let''s check out the form component''s responsive behavior while resizing the
    browser:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整浏览器大小时，让我们检查一下表单组件的响应行为：
- en: '![Example of a dynamic form with JSX](graphics/image_03_004.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![JSX动态表单示例](graphics/image_03_004.jpg)'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The first character should always be a capital when you create a component in
    React. For example, `AddTicket`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建React组件时，第一个字符应始终是大写。例如，`AddTicket`。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how JSX plays an important role in making custom
    components, as well as making them very simple to visualize, understand, and write.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了JSX在制作自定义组件方面起着重要作用，使它们非常简单易于可视化、理解和编写。
- en: The key examples shown in this chapter will help you to understand JSX syntax
    and its implementation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的关键示例将帮助您了解JSX语法及其实现。
- en: The last example in this chapter covered the responsive Add Ticket form with
    JSX along with Bootstrap, which gave you an idea about JSX syntax execution and
    how to create your custom component. You can use it and instrument it easily as
    you play with HTML.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个示例涵盖了响应式的使用JSX和Bootstrap创建添加工单表单，这给了您关于JSX语法执行以及如何创建自定义组件的想法。您可以在与HTML交互时轻松使用它并进行调整。
- en: If you are still not sure about JSX and its behavior, then I recommend that
    you go through this chapter again, as it will also help you when looking at future
    chapters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然不确定JSX及其行为，我建议您再次阅读本章，因为这也将帮助您在查看未来章节时。
- en: If you fully understand this chapter, then let's move on to [Chapter 4](ch04.html
    "Chapter 4. DOM Interaction with ReactJS"), *DOM Interaction with ReactJS* which
    is all about DOM interacting with React, and where we will see DOM's interaction
    with ReactJS. It's an interesting chapter as when we talk about interactivity
    between inputs and outputs, we have to consider backend code and DOM elements.
    You will see some very interesting topics like, props and state, controlled component,
    uncontrolled component, non-DOM attributes keys and references, and many more
    with examples.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完全理解了本章，那么让我们继续阅读[第四章](ch04.html "第四章。ReactJS中的DOM交互")，*ReactJS中的DOM交互*，这一章将讨论DOM与React的交互，我们将看到DOM与ReactJS的交互。这是一个有趣的章节，因为当我们谈论输入和输出之间的交互时，我们必须考虑后端代码和DOM元素。您将看到一些非常有趣的主题，如props和state，受控组件，不受控组件，非DOM属性键和引用，以及许多示例。
