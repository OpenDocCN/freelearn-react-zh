- en: The React VR Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React VR库
- en: This chapter is about the layout of the React VR library; the objects and components
    in it. Many of the concepts in this chapter will be referenced in later chapters,
    so if you are reading an electronic version of this book, it will be heavily hyperlinked
    for your enjoyment and pleasure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是关于React VR库的布局；其中的对象和组件。本章中的许多概念将在后面的章节中引用，所以如果你正在阅读电子版本的这本书，它将被大量超链接以供你享受和愉悦。
- en: 'React VR has six basic elements within it and is coded with a new, yet familiar,
    paradigm called JSX (JavaScript eXtension). If you already know React, you are
    already familiar with React VR, although there are important differences. We will
    cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React VR有六个基本元素，并且使用一种新的、但又熟悉的范式JSX（JavaScript eXtension）进行编码。如果你已经了解React，那么你对React
    VR也应该很熟悉，尽管有一些重要的区别。我们将涵盖以下内容：
- en: 'JSX, the language and syntax of React VR:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX，React VR的语言和语法：
- en: Differences between React VR and React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React VR和React之间的区别
- en: 'Components and VR components:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和VR组件：
- en: Props
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: State
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局
- en: Style
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式
- en: 'Details of all components and keywords:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有组件和关键字的细节：
- en: Objects-visible and invisible
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象-可见和不可见
- en: Lights
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光
- en: Multimedia - sound and video
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多媒体-声音和视频
- en: Cameras and viewing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机和视图
- en: I have not covered all of the APIs available, as that is mostly a long, dictionary-like
    recitation, and it would be better if you used the documentation on the website
    to explore the APIs. We will, in later chapters, use critical APIs to add life
    to our world and navigate in it. For a full, up-to-date list of APIs, check the
    documentation ([https://facebook.github.io/react-vr/docs/getting-started.html](https://facebook.github.io/react-vr/docs/getting-started.html)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有涵盖所有可用的API，因为那基本上是一个冗长的、像字典一样的背诵，最好是使用网站上的文档来探索API。在后面的章节中，我们将使用关键的API来为我们的世界增添生机并在其中导航。要获取完整的、最新的API列表，请查看文档（[https://facebook.github.io/react-vr/docs/getting-started.html](https://facebook.github.io/react-vr/docs/getting-started.html)）。
- en: JSX - the syntax of React VR
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX-React VR的语法
- en: React VR will look familiar to HTML; this makes it easy to read, edit, and deploy.
    Behind the scenes, the UI syntactical glue that React and React VR use will be
    compiled into JSX or JavaScript eXtension. JSX is a React grammar extension to
    allow coding in a blend of HTML and JavaScript. You can also code JSX directly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: React VR看起来很像HTML；这使得阅读、编辑和部署变得容易。在幕后，React和React VR使用的UI语法粘合剂将被编译成JSX或JavaScript
    eXtension。JSX是React的语法扩展，允许在HTML和JavaScript的混合中编码。你也可以直接编写JSX。
- en: 'An example of React JSX is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React JSX的一个例子如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is not a string, as it's not in quotes, and it's also not JavaScript. It's
    much more readable and easier to use than coding in JavaScript directly. JSX makes
    programming faster and more declarative.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个字符串，因为它不在引号内，也不是JavaScript。它比直接在JavaScript中编码更易读、更易用。JSX使编程更快速、更具声明性。
- en: It is useful, but all of this readability and easy-to-program nature comes with
    a few pitfalls. One of them is that semicolons will automatically get entered.
    Just like with HTML, you can include extra lines, but your code may get extra
    semicolons that you didn't intend.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它很有用，但所有这些易读和易编程的特性也伴随着一些陷阱。其中之一是分号会自动输入。就像HTML一样，你可以包含额外的行，但你的代码可能会得到你没有打算的额外的分号。
- en: Put parentheses around your code to avoid this--I also highly recommend reading
    up on the JavaScript syntax. A few of the things in this book took me longer than
    they should have, as I'm a C++ programmer, not a native JavaScript programmer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码周围加上括号以避免这个问题——我也强烈建议你学习一下JavaScript的语法。这本书中的一些内容花费了我比应该更长的时间，因为我是C++程序员，不是本地的JavaScript程序员。
- en: After your React VR is compiled, JSX is converted automatically into JavaScript.
    An implication of this is that you can include JSX anywhere you would use JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译React VR之后，JSX会自动转换为JavaScript。这意味着你可以在任何需要使用JavaScript的地方包含JSX。
- en: Differences between React VR and React
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React VR和React之间的区别
- en: In React, most of your thinking is around the **Document Object Model **(**DOM**)
    that has both captivated and infuriated us since the beginning of JavaScript.
    With React VR, you need to forget about the DOM; in this way, React VR is more
    similar to React Native. Even then, there are concepts that you need to forget
    about.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，你的大部分思考都围绕着自JavaScript诞生以来一直吸引和激怒我们的**文档对象模型**（**DOM**）。在React VR中，你需要忘记DOM；在这方面，React
    VR更类似于React Native。即便如此，也有一些概念你需要忘记。
- en: Forget about pixels as a dimension; the concept is meaningless with VR.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记像素作为一个维度；在VR中这个概念是没有意义的。
- en: You can have a huge photo spread across so much of the world that it looks grainy,
    and a small photo on the side of a small physical object that looks very sharp.
    You can move closer or further away from objects (assuming you've programmed movement),
    which will dramatically change how many "pixels" wide something is. Instead, everything
    is referred to in real-world units of meters (if you are from a country that clings
    to outmoded units of "feet," you can pretend the units are in Yards. Close enough
    for VR work).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一张巨大的照片铺满世界，看起来很模糊，而一张小照片放在一个小物体的一侧，看起来非常清晰。你可以离物体更近或更远（假设你已经编程了移动），这将极大地改变某物的“像素”宽度。相反，一切都以现实世界的米为单位（如果你来自一个坚持使用过时的“英尺”单位的国家，你可以假装单位是码。对于VR工作来说足够接近）。
- en: Another concept that might seem slightly strange with React VR is the speed
    of rendering**.** With React, your page is loaded, then displayed, then elements
    of the page can be interacted with (clicked on), but the whole page is rarely
    re-rendered unless someone clicks on *Refresh*. The `render` method of an object
    is called when the properties change. This does not mean you have to have a timer
    to "tickle" the rendering of your page in VR.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在React VR中可能会显得有点奇怪的另一个概念是渲染的速度。在React中，你的页面被加载，然后显示，然后页面的元素可以被交互（点击），但整个页面很少重新渲染，除非有人点击*刷新*。当对象的属性发生变化时，`render`方法会被调用。这并不意味着你必须有一个定时器来“刺激”你的页面在VR中的渲染。
- en: With React VR, the entire page is rendered in less (hopefully) than 16 milliseconds
    to make the 60 frames per second that is now consider essential for VR. The entire
    page is not reparsed. This is, sort of, the opposite of regular HTML. In particular,
    with active, alive web pages, individual VR components will be rendered (displayed)
    at 60 frames per second, and when their properties change, they are rendered (to
    the three.js code) to update that representation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React VR，整个页面在不到16毫秒的时间内被渲染，以实现每秒60帧的速度，这现在被认为是VR的基本要求。整个页面不会被重新解析。这在某种程度上与常规HTML相反。特别是在活跃的网页中，单独的VR组件将以每秒60帧的速度被渲染（显示），当它们的属性发生变化时，它们将被渲染（到three.js代码）以更新该表示。
- en: Rendering the object is not the same thing as page rendering. This may be slightly
    confusing. Your page will be rendered as soon as it starts loading, even if the
    `render()` method for various objects, to turn them into three.js code, has not
    run yet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染对象并不等同于页面渲染。这可能会有点令人困惑。即使各种对象的`render()`方法尚未运行，页面在开始加载时就会被渲染，以将它们转换为three.js代码。
- en: The net result is that without any extra programming, when properties update
    in your world, the objects will display as appropriate for those property changes.
    This is a cornerstone of how React works, and it is just as applicable with React
    VR. This adds multiple frame rates per second rendering.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，没有任何额外的编程，当属性在您的世界中更新时，对象将根据这些属性更改适当地显示。这是React工作的基石，它在React VR中同样适用。这增加了每秒多个帧率的渲染。
- en: Now that we've covered what React VR is not, let's cover what React VR is.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了React VR不是什么，让我们来看看React VR是什么。
- en: Core Components
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心组件
- en: 'React VR has reusable UI elements that you can use in a variety of places.
    These are called **components**. There are two built-in components:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: React VR具有可重用的UI元素，您可以在各种地方使用。这些被称为**组件**。有两个内置组件：
- en: Text
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Image
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像
- en: You can also build your own components by extending `React.Component`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过扩展`React.Component`来构建自己的组件。
- en: 'Components are real things, not just labels or placeholders, as they have been
    built in ways to present themselves through the world via a `render()` function.
    This is not just a function; like everything with React VR, `render()` generally
    has a set of child components that render or describe it''s contents. An example
    of a component could be as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是真实的东西，不仅仅是标签或占位符，因为它们已经以通过`render()`函数在世界中呈现自己的方式构建。这不仅仅是一个函数；像React VR的一切一样，`render()`通常有一组子组件，用于呈现或描述其内容。组件的一个示例可能如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would be a text component, a built-in type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个文本组件，一个内置类型。
- en: VR Components
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR组件
- en: 'VR objects, what you would commonly think of components, are covered later.
    The React VR documentation doesn''t mention them under the section Core Components,
    which is a bit confusing. You''re probably thinking *"just text and images? What
    about objects?"* VR components are my terminology for the following things:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: VR对象，您通常会认为是组件，稍后会涉及。React VR文档在核心组件部分没有提到它们，这有点令人困惑。您可能会想“*只有文本和图像？物体呢？*” VR组件是我对以下事物的术语：
- en: '**VR physical components**: These are objects that you can "see" in the world:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VR物理组件**：这些是您可以在世界中“看到”的对象：'
- en: 3D primitives, including boxes, cylinders, planes, spheres, and imported objects
    (which can be very detailed)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D基元，包括盒子，圆柱体，平面，球体和导入的对象（可以非常详细）
- en: UI elements, such as panels and buttons
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI元素，如面板和按钮
- en: '**Lights**: These illuminate the preceding objects and can be of several types.
    Note that in React VR, currently lighting does not cast shadows for real-time
    speed.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光**：这些照亮前面的对象，可以是几种类型。请注意，在React VR中，当前照明不会为实时速度投射阴影。'
- en: '**Multimedia**: This includes video and sound. In this way, you can both create
    moving backgrounds for 360 video as well as have "TVs" inside the the world you
    are creating.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多媒体**：这包括视频和声音。通过这种方式，您可以为360度视频创建移动背景，也可以在您创建的世界中有“电视”。'
- en: '**Cameras and scenes**: Cameras control the rendering and the scene contains
    all of the objects you are placing in it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄像头和场景**：摄像头控制渲染，场景包含您放置其中的所有对象。'
- en: We will cover each of these keywords later in the *The next level - the details*
    section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*下一级-细节*部分中逐个介绍这些关键词。
- en: Props
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Components would be boring if they didn''t have properties. An example of a
    property for our salutation might be the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件没有属性，那将会很无聊。我们的问候语的一个属性示例可能如下：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`name` and other values such as this are referred to as **props**. The prop
    is name and has a value, which I set to a humorous string. They can be programmatically
    accessed, for example, `{this.props.name}`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`和其他值如此被称为**props**。属性是名称，有一个值，我设置为一个幽默的字符串。它们可以通过编程访问，例如，`{this.props.name}`。'
- en: Many of the 3D objects also have properties; these vary from object to object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多3D对象也有属性；这些属性因对象而异。
- en: State
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: Perhaps we're in a state of confusion, but React VR state is very important
    as it affects the display of all components, and thus, the various props of those
    components. If a component's props (external) or state (internal) changes, the
    component will re-render itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们处于一种困惑的状态，但React VR状态非常重要，因为它影响所有组件的显示，因此也影响这些组件的各种属性。如果组件的属性（外部）或状态（内部）发生变化，组件将重新渲染自身。
- en: Rendering does not necessarily refer to "creating an image for the eyeball",
    although it can. Rendering, in this case, can refer to building code through the
    React VR/JSX compilation process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染并不一定指的是“为眼球创建图像”，尽管它可以。在这种情况下，渲染可以指的是通过React VR/JSX编译过程构建代码。
- en: 'React VR is encapsulated, per object orientation philosophy/coding paradigm,
    so that the modifiable state is inside a `this.state` object within the component.
    It should only be modified through a "set" function, specifically as follows:
    `this.setState({myStateVariableBeers: 99 })`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'React VR是封装的，根据对象导向的哲学/编程范式，因此可修改的状态位于组件内的`this.state`对象中。它应该只通过一个“set”函数进行修改，具体如下：`this.setState({myStateVariableBeers:
    99 })`'
- en: Note that while at first this might seem like it's stretching the HTML/JSX format,
    this is what makes React VR so powerful and easy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然乍看起来这似乎是在扭曲HTML/JSX格式，但这正是使React VR如此强大和易于使用的原因。
- en: Events
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: '**Events** aren''t just fun things to go to in your neighborhood, they are
    also ways to make your VR world really come alive. Events are generated when the
    user does certain things through the **user interface** (**UI**). A `View` component
    sends `onEnter` and `onExit` events when you move the cursor in and out of the
    view area.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**不仅仅是在你的社区里去玩的有趣的事情，它们也是让你的VR世界真正活跃起来的方式。事件是当用户通过**用户界面**（**UI**）执行某些操作时生成的。当你将光标移入和移出视图区域时，`View`组件会发送`onEnter`和`onExit`事件。'
- en: The astute reader should be confused--we are talking about VR and I just mentioned
    area. Why is a 2D concept being discussed as a fundamental component of a 3D language?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者可能会感到困惑——我们正在谈论VR，我刚提到了区域。为什么一个2D的概念被讨论为3D语言的一个基本组成部分？
- en: Events and layout (covered next) follow the 2D paradigm and are one example
    of an easy bridge between what you're used to working with (HTML, CSS, and JavaScript,
    and the VR world). There are differences, however, and the one that states "pixels"
    are not considered at all in any of the props and keywords may seem fundamentally
    weird. This is because with a true 3D world, the idea of using pixels as a unit
    of measurement is essentially useless. An object one meter in front of you is
    going to have a much wider screen representation than one ten meters behind you.
    Dimensions are therefore given in units of world space; one is a meter (a bit
    more than a yard).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 事件和布局（下面会讨论）遵循2D范例，并且是易于桥接的一个例子，使你能够轻松地过渡到你习惯使用的东西（HTML、CSS和JavaScript以及VR世界）。然而，也存在差异，其中一个声明“像素”在任何属性和关键字中根本不被考虑可能看起来基本上很奇怪。这是因为在真正的3D世界中，使用像素作为测量单位的概念基本上是没有用的。在你面前一米处的物体将具有比你身后十米处的物体更宽的屏幕表示。因此，尺寸是以世界空间的单位给出的；一个单位是一米（略大于一码）。
- en: The point of React VR is to quickly and declaratively build great 3D worlds.
    It is a declarative programming approach. If you want to build worlds with more
    complexity, the power of React VR is that you can use React Native and other Node.js
    programming methods to add to React VR.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React VR的重点是快速和声明性地构建出色的3D世界。这是一种声明性的编程方法。如果你想要构建更复杂的世界，React VR的强大之处在于你可以使用React
    Native和其他Node.js编程方法来扩展React VR。
- en: Layout and style
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局和样式
- en: Aspects of WebVR and React VR still follow the browser paradigm. Cursors are
    viewed as 2D interactions, and UI elements are generally described in terms of
    2D flex boxes and layout rules to lay those components out in 2D. This does not
    mean we are not developing a VR environment; although most of the UI is in a 2D
    format, these are fully present within a VR environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: WebVR和React VR的一些方面仍然遵循浏览器范式。光标被视为2D交互，UI元素通常以2D弹性框和布局规则的形式描述，以在2D中布置这些组件。这并不意味着我们没有开发VR环境；尽管大多数UI是以2D格式存在，但这些完全存在于VR环境中。
- en: Layout and style naturally move into 3D. Instead of having to describe what
    your 3D objects are for every item (inline), you can set up something similar
    to a style sheet or CSS. It's not actually similar to a style sheet, it is a style
    sheet, so all of your skills will transfer over.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和样式自然地转移到3D。您不必为每个项目（内联）描述您的3D对象，而是可以设置类似于样式表或CSS的东西。它实际上并不类似于样式表，它就是一个样式表，因此您所有的技能都将转移到这里。
- en: Style sheets can be messy, so React VR makes it even easier to lay out UI elements.
    It uses Flexbox, via YogaLayout (at [https://github.com/facebook/yoga](https://github.com/facebook/yoga)).
    React VR is all about creating reality quickly. React is all about user interfaces,
    so it's natural that the UI elements in React VR are so powerful.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表可能会很混乱，所以React VR使得布局UI元素变得更加容易。它使用Flexbox，通过YogaLayout（在[https://github.com/facebook/yoga](https://github.com/facebook/yoga)）。React
    VR的重点是快速创建现实。React关注用户界面，因此React VR中的UI元素非常强大是很自然的。
- en: The next level - the details
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一个级别 - 细节
- en: Although the React VR library is simple, to really learn what it's all about,
    you need to learn a lot of syntax. You could skim it, but there is a danger to
    knowing a little bit without being somewhat familiar with everything.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管React VR库很简单，但要真正了解它的全部内容，您需要学习很多语法。您可以略读，但是知道一点而不熟悉所有内容是有危险的。
- en: '"A little Learning is a dang''rous Thing;'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “一知半解是危险的事情；
- en: 'Drink deep, or taste not the Pierian Spring:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 深饮，或者不尝试皮耶里亚之泉：
- en: There shallow Draughts intoxicate the Brain,
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 浅浅的饮料会使大脑陶醉，
- en: And drinking largely sobers us again."-An Essay on Criticism, by Alexander Pope.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大口地喝则会使我们清醒。-亚历山大·蒲柏的《批评论文》。
- en: You may be thinking *"OK, but where's all the VR stuff? You know, tables, chairs,
    lamps, people ...* *and so forth."* These are going to be a deep drink indeed--there
    are quite a number of components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想“好吧，但是所有的VR东西在哪里？你知道，桌子，椅子，灯，人... *等等。”这确实需要深入研究-有相当多的组件。
- en: The best reference is the online documentation, although they can be a tad sparse
    at times. Remember that the online documentation is *live*, meaning you can file
    an issue or even modify it, if you see a typo or need clarification.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的参考是在线文档，尽管有时可能有点稀疏。请记住在线文档是*实时*的，这意味着您可以提交问题，甚至修改它，如果您发现有错别字或需要澄清。
- en: I highly recommend that you view the next section as a reference section. Of
    course, you could need help going to sleep at night, in which case read on! After
    having said that, this section is very important as you'll need to use many or
    all of these components to actually build your VR world. I will attempt to make
    this section funny. It is a good thing I am writing a book, and not trying to
    make a living on stage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您将下一节视为参考部分。当然，你可能需要帮助入睡，那么请继续阅读！在说完这些之后，这一部分非常重要，因为您需要使用许多或所有这些组件来实际构建您的VR世界。我将尝试使这一部分有趣。我写书是件好事，而不是试图在舞台上谋生。
- en: Stuff (objects, whether visible or not)
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物品（可见或不可见的对象）
- en: 'Most of the interesting things in the world are visible objects or objects
    that you can interact with. Roughly, in the order of complexity, these are as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上大部分有趣的事物都是可见的物体或可以与之交互的物体。大致上，按照复杂性的顺序，它们如下：
- en: Box
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子
- en: Cylinder
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆柱体
- en: Plane
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Sphere
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体
- en: CylindricalPanel
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆柱面板
- en: Model
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: Pano
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全景
- en: VideoControl
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VideoControl
- en: VrButton
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VrButton
- en: Primitives
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基元
- en: The Box, Cylinder, Plane, and Sphere are 3D primitives. They have `lit`, `texture`,
    and `wireframe` props. Lit objects will be affected by the lights in the scene.
    If texture is specified (usually an image file), your browser will look up (fetch
    or render) this image and use it to wrap around the 3D primitive. UV mapping we
    will discuss in [Chapter 6](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml), *Working
    with Poly and the Gon family *and [Chapter 7](55c8c8f8-c349-43ad-b690-2d6de861b8b9.xhtml), *Sitting
    Down with a (Virtual) Teapot*, but most of the 3D primitives are mapped the way
    you would expect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子，圆柱体，平面和球体都是3D基元。它们具有`lit`，`texture`和`wireframe`属性。发光的物体将受到场景中的光线影响。如果指定了纹理（通常是图像文件），您的浏览器将查找（获取或渲染）此图像，并将其用于包裹3D基元。UV映射我们将在[第6章](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml)中讨论，*与Poly和Gon家族合作*和[第7章](55c8c8f8-c349-43ad-b690-2d6de861b8b9.xhtml)中讨论，*与（虚拟）茶壶坐下*，但大多数3D基元的映射方式与您期望的方式相同。
- en: Note that the texture can be a `string` (referring to an image file), an `asset()`
    call, or a `require()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，纹理可以是一个`string`（指向图像文件），一个`asset()`调用，或一个`require()`。
- en: Box
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒子
- en: A `Box` is a basic cube. It's dimensions will default to one (unit) if not specified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box`是一个基本的立方体。如果未指定尺寸，它的尺寸将默认为一（单位）。'
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This would be the Monolith from 2001, a Space Odyssey; the dimensions being
    the squares of the first three primes. For more information, see [https://facebook.github.io/react-vr/docs/box.html](https://facebook.github.io/react-vr/docs/box.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是《2001太空漫游》中的石碑；尺寸是前三个质数的平方。有关更多信息，请参见[https://facebook.github.io/react-vr/docs/box.html](https://facebook.github.io/react-vr/docs/box.html)。
- en: Cylinder
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆柱体
- en: A `Cylinder` is a basic capped cylinder. It can also be used to make cones by
    making the top a radius of zero (or bottom for a closed funnel).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cylinder`是一个基本的封闭圆柱体。也可以通过将顶部半径设为零（或底部为封闭漏斗）来制作圆锥体。'
- en: The `Cylinder` uses radius, not diameter. Don't make your cylinders twice as
    large as they need to be!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cylinder`使用半径，而不是直径。不要把你的圆柱体做得比需要的大两倍！'
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the creative use of the number of sides to make the cone a pyramid. For
    more information, see [https://facebook.github.io/react-vr/docs/cylinder.html](https://facebook.github.io/react-vr/docs/cylinder.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意创造性地使用边数来使圆锥体成为金字塔。有关更多信息，请参见[https://facebook.github.io/react-vr/docs/cylinder.html](https://facebook.github.io/react-vr/docs/cylinder.html)。
- en: As with all 3D primitives, the `Cylinder` has `lit`, `texture`, and `wireframe`
    props.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有3D基元一样，`Cylinder`具有`lit`，`texture`和`wireframe`属性。
- en: Plane
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平面
- en: 'This is not an Airbus, but rather a flat surface. While it is called a **plane**,
    it is more like a flat, square 2D slab. It is not a cubic slab, that would be
    a `Box`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一架空中客车，而是一个平坦的表面。虽然它被称为**平面**，但更像是一个平坦的，正方形的二维板。它不是一个立方体板，那将是一个`Box`：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One thing about a plane that can be tough to work with; they are visible only
    from their primary side. They are quick, lightweight objects, but can only have
    one texture map on them so may look repetitious if you use a large plane. If you
    rotate a plane the wrong way, you may see nothing at all; you could be looking
    at the back side. Be careful with transforms or use a `Box` instead of a `Plane`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于平面的一件棘手的事情是它们只能从其主要一侧可见。它们是快速，轻量级的对象，但只能在其上有一个纹理贴图，因此如果使用大平面可能会显得重复。如果你把平面旋转错了，可能什么也看不到；你可能在看背面。在变换时要小心，或者使用`Box`而不是`Plane`。
- en: For more information, see [https://facebook.github.io/react-vr/docs/plane.html](https://facebook.github.io/react-vr/docs/plane.html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://facebook.github.io/react-vr/docs/plane.html](https://facebook.github.io/react-vr/docs/plane.html)。
- en: As with all 3D primitives, the `Cylinder` has `lit`, `texture`, and `wireframe`
    props.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有3D基元一样，“圆柱体”具有“lit”、“texture”和“wireframe”属性。
- en: Sphere
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球体
- en: 'Follow the bouncing ball, although animation is covered later. As with the
    `Cylinder`, the `Sphere` has a prop that will change its resolution:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随弹跳的球，尽管动画稍后会涉及。与“圆柱体”一样，“球体”有一个属性可以改变其分辨率：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the way we did the pyramid, putting in a really low number of segments
    for the width and height could make the `Sphere` look like different types of
    solids. For more information, see [https://facebook.github.io/react-vr/docs/sphere.html](https://facebook.github.io/react-vr/docs/sphere.html)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们做金字塔的方式类似，为宽度和高度输入非常低的段数可以使“球体”看起来像不同类型的固体。有关更多信息，请参阅[https://facebook.github.io/react-vr/docs/sphere.html](https://facebook.github.io/react-vr/docs/sphere.html)
- en: As with all 3D primitives, the `Sphere` has `lit`, `texture`, and `wireframe`
    props.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有3D基元一样，“球体”具有“lit”、“texture”和“wireframe”属性。
- en: Model
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: The `Model` component allows us to do really interesting things. Until now,
    the VR objects have been fairly simple, but Model allows you to import CAD models
    of arbitrary complexity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “模型”组件允许我们做非常有趣的事情。到目前为止，VR对象一直相当简单，但模型允许您导入任意复杂度的CAD模型。
- en: 'Be careful with `Model`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用“模型”：
- en: You can easily import objects that are more complex than your platform can handle.
    Remember, you still maintain the smooth frame rates that are required for Virtual
    Reality to seem real.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松导入比您的平台处理能力更复杂的对象。请记住，您仍然保持所需的平滑帧速率，以使虚拟现实看起来真实。
- en: 'In  [Chapter 6](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml), *Working with
    Poly and the Gon Family*, we will explore the details of using `Model` effectively.
    The basic method of showing `Model` is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml)中，*使用Poly和Gon Family*，我们将探讨有效使用“模型”的细节。显示“模型”的基本方法如下：
- en: '`Model` with a material file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 带有材料文件的“模型”：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Model` without a material file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有材料文件的“模型”：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As of the time of writing this book, `Model` imports the Wavefront OBJ file
    format, as well as **GL Transmission Format** (**glTF**). OBJ is the most common
    3D model format. One would wonder why React doesn't import X3D, which is the WebVR
    format of choice. This is one of the things that frustrated me into putting so
    much effort, way back when, into VRML and X3D.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，“模型”导入Wavefront OBJ文件格式，以及GL传输格式（glTF）。 OBJ是最常见的3D模型格式。人们可能会想知道为什么React不导入X3D，这是WebVR的首选格式。这是我当初对VRML和X3D投入如此多精力的事情之一，让我感到沮丧。
- en: In any event, OBJ files consist generally of two files; the `filename.obj` contains
    the geometry of the object, and a companion `.MTL` file (material) contains the
    colors, materials, and references to external textures (image files). Note that
    the implication is that you may need far more than just these two files, if the
    OBJ file has many textures loaded in the material file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，OBJ文件通常由两个文件组成；“filename.obj”包含对象的几何形状，而伴随的“.MTL”文件（材料）包含颜色、材料和对外部纹理（图像文件）的引用。请注意，这意味着如果OBJ文件在材料文件中加载了许多纹理，您可能需要远不止这两个文件。
- en: We will cover this in more depth in [Chapter 6](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml),
    *Working with Poly and the the Gon Family*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml)中更深入地介绍这一点，*使用Poly和Gon
    Family*。
- en: Note that `Model` has `lit`, `texture`, and `wireframe` props. The texture prop
    applies to the whole model, which could have multiple UV mappings. It is usually
    better to assign textures through the `.MTL` file, which may be done automatically
    from your modeling program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Model` 有 `lit`、`texture` 和 `wireframe` 属性。纹理属性应用于整个模型，可能有多个UV映射。通常最好通过
    `.MTL` 文件分配纹理，这可能会自动从建模程序中完成。
- en: Don't plan on the texture keyword to apply to a `Model` that you have imported.
    It's far better to texture and map the model in the CAD program you are using,
    than to try to override it in React VR.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不要指望纹理关键字适用于您导入的 `Model`。最好在您使用的CAD程序中为模型贴图和映射，而不是在React VR中尝试覆盖它。
- en: Secondly, you may need to hand edit the `.MTL` file; my experience is that most
    exporters can't handle all of the complexity of a nodal-based shader that even
    real-time engines make dramatic use of; as a result, your `.MTL` file is almost
    certainly not going to have all of the different baked-in maps.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可能需要手动编辑 `.MTL` 文件；我的经验是，大多数导出程序无法处理基于节点的着色器的所有复杂性，即使是实时引擎也会大量使用；因此，您的 `.MTL`
    文件几乎肯定不会包含所有不同的烘焙贴图。
- en: CylindricalPanel
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CylindricalPanel
- en: '`CylindricalPanel` is a bit of a transitional object. It is intended to have
    child objects and provides an ability to draw these on an invisible cylinder centered
    on the current viewpoint. Its main purpose is to allow familiar 2D elements to
    be placed in a 3D world. To be able to do this requires a few anachronistic elements.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`CylindricalPanel` 是一个过渡对象。它旨在拥有子对象，并提供在当前视点上的无形圆柱体上绘制这些对象的能力。它的主要目的是允许将熟悉的2D元素放置在3D世界中。要能够做到这一点需要一些过时的元素。'
- en: When you work with HTML, to do precise layouts of HTML elements, you may have
    to think and code with pixels; for example, a certain element may be 200 pixels
    wide. This allows you to precisely lay out graphics.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用HTML时，要精确布局HTML元素，您可能需要考虑和编写像素级的代码；例如，某个元素可能有200像素宽。这使您能够精确布局图形。
- en: In 3D, none of this is applicable. Is the moon one, two, or 10 pixels wide?
    The world does not have *dots per inch*. As a result, most of the VR primitives
    established their actual size, well, their *virtual* size, in meters. Your VR
    display method will then show the right amount of pixels. If you move your head
    right up to that cube, it could be 2,000 pixels; if you see it at the end of a
    hallway, it might be 10 pixels wide. So you normally do not use pixels for sizes
    with React VR.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D中，这些都不适用。月亮宽是1个像素、2个像素还是10个像素？世界没有*每英寸点数*。因此，大多数VR基元将它们的实际大小，嗯，它们的*虚拟*大小，以米为单位。然后，您的VR显示方法将显示正确数量的像素。如果您把头移动到那个立方体旁边，它可能是2000像素；如果您在走廊的尽头看到它，它可能只有10像素宽。因此，通常不使用像素来确定React
    VR中的大小。
- en: The `CylindricalPanel` object, however, *does* need a property for the amount
    of pixels. This is not for the object itself (well, sort of), it's for an off-screen
    buffer to hold the visible rendering of any child objects. Like many things in
    the web, it has reasonable defaults. The defaults are quite large, but that is
    to make it look less grainy if you get up close.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`CylindricalPanel` 对象确实需要一个像素数量的属性。这不是为了对象本身（嗯，有点是），而是为了一个屏幕外缓冲区来保存任何子对象的可见渲染。像网页中的许多东西一样，它有合理的默认值。默认值相当大，但这是为了使它在近距离看起来不那么粗糙。
- en: I highly recommend not using `CylindricalPanel`, but rather recode your UI into
    actual 3D objects. The resolution and system resource use (RAM mainly) could actually
    be lower this way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议不要使用 `CylindricalPanel`，而是将您的UI重新编码为实际的3D对象。这种方式可能会降低分辨率和系统资源使用（主要是RAM）。
- en: 'For example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Child components` line is very important--here is where you put the actual
    2D objects that will show up spread across `CylindricalPanel`. It is not literal
    code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child components`行非常重要--这里是你放置实际的2D对象，这些对象将显示在`CylindricalPanel`上。这不是字面上的代码。'
- en: VideoControl
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VideoControl
- en: '`VideoControl` is a physical object with the normal `VideoPlayer` functions,
    in other words, start, pause, and so forth. As it is intended to be used in playing
    videos, the example here (straight from the documentation) will show it embedded
    with an animation object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoControl`是一个具有正常`VideoPlayer`功能的物理对象，换句话说，开始、暂停等等。由于它旨在用于播放视频，这里的示例（直接来自文档）将显示它嵌入到一个动画对象中：'
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don't feel limited to its intended use. You can also experiment with it--maybe
    it's a good train controller!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不要局限于其预期用途。你也可以进行实验--也许它是一个不错的火车控制器！
- en: VrButton
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VrButton
- en: The `VrButton` isn't actually a real button (well, it's all virtual, right?),
    meaning it doesn't have any geometry, but is an object that you may, nay, will,
    find very useful to include in the world.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`VrButton`实际上并不是一个真正的按钮（好吧，它都是虚拟的，对吧？），这意味着它没有任何几何形状，但是这是一个你可能会发现非常有用的对象，可以包含在世界中。'
- en: 'The `VrButton` is mainly used for gaze detection. We discuss this and other
    VR movement (locomotion) techniques in [Chapter 11](707dc6f5-9666-4f49-952b-fbcf20fc8afc.xhtml),
    *Take a Walk on the Wild Side*[.](707dc6f5-9666-4f49-952b-fbcf20fc8afc.xhtml) For
    now, let''s just discuss what the `VrButton` is:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`VrButton`主要用于凝视检测。我们将在[第11章](707dc6f5-9666-4f49-952b-fbcf20fc8afc.xhtml) *走在野性的一面*中讨论这个以及其他VR移动（运动）技术。现在，让我们只讨论一下`VrButton`是什么：'
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This `VrButton` wraps an image and plays a sound. We'll discuss sound further
    on in [Chapter 8](c3188254-ca3b-4b7d-af85-97b2c11439a0.xhtml), *Breath Life in
    Your World*, but briefly here, the file format allows the browser to decide which
    sound will play in your chosen browser.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`VrButton`包裹了一个图像并播放声音。我们将在[第8章](c3188254-ca3b-4b7d-af85-97b2c11439a0.xhtml)
    *给你的世界注入生命*中进一步讨论声音，但在这里简要介绍，文件格式允许浏览器决定在你选择的浏览器中播放哪种声音。
- en: Lights
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光
- en: 'The world would be a pretty dark place and full of vampires if we didn''t have
    lights. Let''s chase those undead things away. There are four principal lights:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有灯光，世界将会是一个非常黑暗且充满吸血鬼的地方。让我们赶走这些不死族。有四种主要的灯光：
- en: AmbientLight
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmbientLight
- en: DirectionalLight
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectionalLight
- en: PointLight
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PointLight
- en: SpotLight
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpotLight
- en: Common light properties
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见灯光属性
- en: 'All lights have two common properties:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有灯具都有两个共同的属性：
- en: '`intensity`:  This is how bright the light is in the scene. The default is
    `{1.0}`, but you can go higher. In practice, higher settings make the shadows
    on the curved edge of objects (spheres for example) more sharp and look brighter
    (washed out), but can''t actually get whiter than white (RGB 255, 255, 255) on
    the most lit faces.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intensity`：这是场景中灯光的亮度。默认值是`{1.0}`，但你可以调高。在实践中，更高的设置会使物体（例如球体）曲边上的阴影更加清晰和更亮（变淡），但实际上不能比白色更白（RGB
    255, 255, 255）。'
- en: '`color`:  Color is not listed under light properties, but it is a style prop
    that all lights have. This is an RGB property. You can even have colored ambient
    lights, which could be used for sepia tones and the like, as well as simulating
    background illumination from brightly colored environments. In a forest, for example,
    maybe a light green ambient color. The default is white.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：颜色并未列在灯光属性下，但它是所有灯具都具有的样式属性。这是一个RGB属性。你甚至可以拥有有颜色的环境光，这可以用于赭色调等，以及模拟来自明亮环境的背景照明。例如，在森林中，也许是浅绿色的环境光。默认值是白色。'
- en: Other lights have properties specific for the type of illumination they represent.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其他灯具具有特定于它们所代表的照明类型的属性。
- en: AmbientLight
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AmbientLight
- en: '`AmbientLight` is the simplest way to make your scene visible. It isn''t actually
    a light, really, but it does light up everything in the scene.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`AmbientLight`是使你的场景可见的最简单的方法。实际上它并不是一个真正的光，但它确实照亮了场景中的一切。'
- en: Lighting in the real world is very complex. Photons bounce all around, reflect
    off of objects, penetrate into them, and even make some objects glow (fluorescence
    and luminescence). A useful trick is to make objects light up even if there are
    no lights or to add a light fill to the room that can help simulate background
    light scattering, without the overhead of calculating this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的照明非常复杂。光子四处反射，反射物体，渗透进物体，甚至使一些物体发光（荧光和发光）。一个有用的技巧是让物体即使没有灯也能发光，或者在房间中添加一些光线以帮助模拟背景光的散射，而不需要计算这个过程的开销。
- en: This is called ambient light. Many CAD systems have ambient as a value in materials.
    `AmbientLight` lets you light up the whole room. For you disco, festival-loving
    people, it even lets you change the color from white to whatever color you want.
    Now, you can make a scene that looks like the hallways at the W hotel chain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为环境光。许多CAD系统在材料中都有环境作为一个值。 `AmbientLight`让你点亮整个房间。对于喜欢迪斯科、节日的人来说，它甚至可以让你把颜色从白色变成任何你想要的颜色。现在，你可以制作一个看起来像W酒店连锁酒店走廊的场景。
- en: Oddly, not a single sample in the React VR download shows how to use `AmbientLight`;
    although it's not that hard, it's important.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，React VR下载中没有一个示例显示如何使用`AmbientLight`；尽管这并不难，但它很重要。
- en: 'Here is a screenshot of a sphere with an ambient of `.2`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个环境为`.2`的球体的屏幕截图：
- en: '![](Images/45b254bb-6a90-4877-bf7e-6328b13b4b47.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/45b254bb-6a90-4877-bf7e-6328b13b4b47.jpg)'
- en: 'The code is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice a few things--we also have a directional light in the last photo, so
    you can see the differences. The sphere is white from the directional light, yet
    the underside is dark, but not pitch dark. `AmbientLight` can fake a little global
    illumination or radiosity in real time. GI is the amount of light that bounces
    off other objects and creates "fill light" in the real, non-virtual world. Three.js
    also has a `THREE.HemisphereLight` for this*, *and you can add it to React VR
    through the Native Views or Native Bridge.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意几件事——我们在最后一张照片中还有一个定向光，所以你可以看到不同之处。球体是来自定向光的白色，然而底部是黑暗的，但不是漆黑。 `AmbientLight`可以在实时中伪造一点全局照明或辐射。GI是光线从其他物体反射并在现实的、非虚拟的世界中创造“填充光”的数量。Three.js还有一个`THREE.HemisphereLight`*用于此，*你可以通过本机视图或本机桥将其添加到React
    VR中。
- en: DirectionalLight
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirectionalLight
- en: From `AmbientLight` to `DirectionalLight`, we are moving from the abstract to
    the slightly less abstract. A `DirectionalLight` is really there to take the place
    of the Sun. The sun's rays are always parallel to each other; in the same way,
    the `DirectionalLight` doesn't spread out like a light that's located closer would.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从`AmbientLight`到`DirectionalLight`，我们正在从抽象到稍微不那么抽象。 `DirectionalLight`实际上是用来代替太阳的。太阳的光线总是相互平行的；同样，`DirectionalLight`不像更接近的光源那样扩散。
- en: 'Here is a `DirectionalLight` and no `AmbientLight`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`DirectionalLight`和没有`AmbientLight`的情况：
- en: '![](Images/a2b8bce2-366e-4911-8b04-a71482102329.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a2b8bce2-366e-4911-8b04-a71482102329.jpg)'
- en: 'The code is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the picture, we've rotated the `DirectionalLight` to the side slightly; the
    sphere looks interesting, but not quite right compared to the rest of the scene.
    This is because the lighting for the Pano background is substantially different
    than the scene. You would want to try to match the two up with the appropriate
    transform statement for your `<DirectionalLight>`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片中，我们把`DirectionalLight`稍微旋转到一侧；球体看起来很有趣，但与场景的其余部分相比不太对。这是因为全景背景的照明与场景的照明有很大不同。你会想要尝试用适当的变换语句来匹配两者与你的`<DirectionalLight>`。
- en: PointLight
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PointLight
- en: A `Pointlight` is like an old-school light bulb; light spreads out in every
    direction from the point. One interesting thing about Point and Spot lights is
    again a simplification to make our VR look real. To avoid very slow rendering,
    the atmosphere is not strictly modeled. This means that a light that would normally
    fade out due to the atmosphere would instead shine for miles (atmospheric effects
    might be more of an issue where I live than where you live, unless you live on
    the moon. If you do, give me a ticket, and I'll come and personally read this
    book out loud to you).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pointlight`就像一个老式的灯泡；光从点上向各个方向扩散。关于点光和聚光灯的一个有趣的事情是，再次简化了我们的VR看起来真实的方法。为了避免渲染速度非常慢，大气层并没有严格建模。这意味着通常由于大气层而逐渐消失的光会在数英里之外发光（大气效应可能在我所在的地方比在你所在的地方更严重，除非你住在月球上。如果是的话，给我一张票，我会亲自去给你大声朗读这本书）。'
- en: To avoid modeling atmospheric effects such as extinction (fading), fog, clouds,
    and so forth, `PointLight` and `SpotLight` both take decay and distance props.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免建模大气效应，如消光（褪色）、雾、云等，`PointLight`和`SpotLight`都采用了衰减和距离属性。
- en: '`distance` is how far the light shines. If it is non-zero, the light intensity
    will be zero at that distance.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance`是光线照射的距离。如果它不为零，光的强度将在那个距离为零。'
- en: '`decay` is how often if fades away. It''s sort of a generic (dimensionless)
    number; `2` is physically realistic light falloff. `0.1` makes a much sharper
    fade and is useful for artistic effects.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`decay`是光线消失的频率。这是一个通用的（无量纲）数字；`2`是物理上真实的光线衰减。`0.1`会使光线消失得更快，对艺术效果很有用。'
- en: 'For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To better visualize the preceding, I've constructed a demo scene three times;
    the first with a distance of 10, the second with a distance of four, and the third
    with a distance of four and a decay of `0.1` instead of 2\. You can see the third
    scene looks very unnatural. Note that all three scenes have an intensity of exactly
    one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化前面的内容，我构建了一个演示场景三次；第一次距离为10，第二次距离为4，第三次距离为4，衰减为`0.1`而不是2。你可以看到第三个场景看起来非常不自然。请注意，所有三个场景的强度都是完全一样的。
- en: '![](Images/22675a67-ad9c-4ec2-b46e-69cf89bfa6f6.png)If your point lights seem
    dim, check the distance parameter. I recommend leaving decay at two.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的点光看起来昏暗，检查一下距离参数。我建议将衰减保持在2。
- en: SpotLight
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpotLight
- en: A `SpotLight` is like those lampshade things they shine in a bad guys faces
    in bad film noir or a flashlight. Like `PointLight`, it also has decay and distance
    props (as seen earlier).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpotLight`就像那些在糟糕的黑色电影中对着坏家伙脸上发光的灯罩一样，或者像手电筒。与`PointLight`一样，它也有衰减和距离属性（如前所述）。'
- en: The `distance` and `decay` props are the same as the `PointLight`. The `SpotLight`
    also has a `penumbra` and `angle` props; the two are how far the light spreads
    out. Angle is the maximum outside `angle`,while `penumbra` is a number from one
    to 100 that defines how soft the  `SpotLight` is.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance`和`decay`属性与`PointLight`相同。`SpotLight`还有`penumbra`和`angle`属性；这两个属性决定了光的扩散范围。`angle`是最大的外部`angle`，而`penumbra`是一个从一到100的数字，定义了`SpotLight`的柔和程度。'
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Currently, the position of the SpotLight defines where the light is shining
    "from." The target of the light, in other words what it is pointed at, is currently
    not exposed in React VR. At the time of the writing of this book, this issue is
    not resolved.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，SpotLight的位置定义了光线的“发光”位置。光的目标，换句话说，它指向的东西，目前在React VR中没有暴露出来。在撰写本书时，这个问题还没有解决。
- en: Using a View to wrap the SpotLight doesn't seem to change the target either.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用View来包装SpotLight似乎也不会改变目标。
- en: I recommend not using SpotLight, unless you can arrange your scene to have the
    object of interest located at [0,0,0].
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要使用SpotLight，除非你可以安排你的场景让感兴趣的物体位于[0,0,0]。
- en: Multimedia - sound and video
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多媒体-声音和视频
- en: The world would be a boring place if you couldn't hear anything. Video is normally
    part of dynamic web pages, although in VR, we have a bit of a challenge — video
    itself might not be engaging unless it's 360 video, which some people call VR
    (it can't give you more than disembodied ghost feeling, so from my viewpoint,
    it's not really VR as you can't be totally immersed, but other people may feel
    it is VR. At this point in VR/AR/XR, we really need to all just get along!).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你听不到任何声音，世界将是一个无聊的地方。视频通常是动态网页的一部分，尽管在VR中，我们有一些挑战——视频本身可能不那么吸引人，除非是360度视频，有些人称之为VR（它不能给你更多的超脱感，所以从我的观点来看，它并不是真正的VR，因为你不能完全沉浸其中，但其他人可能认为它是VR。在VR/AR/XR的这一点上，我们真的需要和平相处！）。
- en: Video in a VR world can be an important part of providing atmosphere. If you
    walk into a room and a video is playing, it's going to seem more like most homes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR世界中，视频可以是提供氛围的重要组成部分。如果你走进一个房间，视频正在播放，它会更像大多数家庭。
- en: Sound
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音
- en: '`Sound` in VR is much more complicated than it initially sounds (pun intended).
    The `Sound` node allows an audio source to be placed into your VR world. `Sound`
    will make your world come alive.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，`Sound`比起最初听起来要复杂得多（双关语）。`Sound`节点允许将音频源放置到您的VR世界中。`Sound`会让你的世界变得生动起来。
- en: 'From the React VR manual, consider the example of a `waterfall`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从React VR手册中，考虑一个`waterfall`的例子：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example shows how easy it is to add things by declaring them in React VR.
    The `waterfall` sound is simply attached to the location of the image of the `waterfall`.
    If you are walking around inside the 3D world, you will *hear* the waterfall as
    if it is located where the image is; this is all done by simply adding the `Sound`
    component as a leaf node (child of image in this case). The `Sound` node should
    not have any child components itself.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在React VR中声明并添加东西是多么容易。`waterfall`声音简单地附加到`waterfall`图像的位置。如果你在3D世界中四处走动，你会*听到*瀑布就好像它就在图像所在的位置；这一切都是通过简单地将`Sound`组件添加为叶节点（在这种情况下是图像的子节点）来完成的。`Sound`节点本身不应该有任何子组件。
- en: 'If the `Sound` node is not attached to an object with a position, it will default
    to being at position absolute, for example of position: absolute.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`Sound`节点没有附加到具有位置的对象上，它将默认为绝对位置，例如`position: absolute`。'
- en: 'The `Sound` node has a number of props. They are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound`节点有许多属性。它们如下：'
- en: '`autoPlay`: Boolean'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoPlay`：布尔值'
- en: When the audio starts playing automatically when a component is loaded. The
    default is `true`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件加载时音频自动开始播放。默认值为`true`。
- en: '`loop`: Boolean'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`：布尔值'
- en: When the audio repeats automatically when finished playing. The default is `false`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当音频播放完成时自动重复。默认值为`false`。
- en: '`muted`: Boolean When the audio is muted. The default is `false`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`muted`：布尔值 当音频被静音时。默认值为`false`。'
- en: '`onDurationChange`: (callback function)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDurationChange`：（回调函数）'
- en: This function is called when the sound duration changed, with a parameter for
    the duration of the sound.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当声音持续时间改变时，调用此函数，带有声音持续时间的参数。
- en: '`onEnded`: (callback function)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEnded`：（回调函数）'
- en: The function `onEnded` is called when audio is done playing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当音频播放完成时，将调用`onEnded`函数。
- en: '`onPlayStatusChange`: (callback function) This function is called when the
    play status changed. `event.nativeEvent.playStatus`: This is the play status of
    the sound; one of the strings `''closed''`, `''loading''`, `''error''` , `''ended''`
    , `''paused''` , `''playing''` , or `''ready''`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPlayStatusChange`：（回调函数）当播放状态改变时调用此函数。`event.nativeEvent.playStatus`：这是声音的播放状态；字符串之一为`''closed''`、`''loading''`、`''error''`、`''ended''`、`''paused''`、`''playing''`或`''ready''`。'
- en: '`onTimeUpdate`: (`callback` function) This function is called when `currentTime`
    of sound is changed.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTimeUpdate`：（`回调`函数）当声音的`currentTime`改变时调用此函数。'
- en: '`event.nativeEvent.currentTime`: The `currentTime` of the sound file.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.nativeEvent.currentTime`：音频文件的 `currentTime`。'
- en: '`playControl`: *play*, *pause*, or *stop*.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playControl`：*play*、*pause* 或 *stop*。'
- en: This variable controls the playback status. If not set, the value of `autoPlay`
    determines whether the audio plays when the component is loaded.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量控制播放状态。如果未设置，`autoPlay` 的值将决定组件加载时是否播放音频。
- en: '`playerState`: (object)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerState`：（对象）'
- en: '`playerState` is a `MediaPlayerState` that controls video playback with its
    inner state. When `playerState` is set, the value of `autoPlay`, muted volume
    and `playControl` properties are ignored as they will be set by `playerState`
    instead. See `MediaPlayerState`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerState` 是一个控制视频播放的 `MediaPlayerState`，具有其内部状态。设置 `playerState` 时，`autoPlay`
    的值、静音音量和 `playControl` 属性将被忽略，因为它们将由 `playerState` 而不是自己设置。参见 `MediaPlayerState`。'
- en: '`source`: (object)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：（对象）'
- en: 'The object source audio in the form of {uri: http}.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '以 {uri: http} 形式的对象源音频。'
- en: '`volume`: 0-1.0 (not actually limited)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：0-1.0（实际上没有限制）'
- en: Value of the audio volume. The minimum is zero, which mutes the sound, and the
    suggested maximum is 1.0, which is also the default value. Values greater than
    one are allowed; this may cause clipping/distortion, depending on the audio hardware.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 音频音量的值。最小值为零，将声音静音，建议的最大值为1.0，这也是默认值。允许大于1的值；这可能会导致剪切/失真，取决于音频硬件。
- en: 'An example: To lower the volume by 50% set `volume={0.5}`. As different platforms
    may have differing audio capabilities (sigh), the source can be of several different
    file formats, and the browser will pick the appropriate format that it can read.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：要将音量降低50%，设置 `volume={0.5}`。由于不同平台可能具有不同的音频功能（叹息），源可以是几种不同的文件格式，浏览器将选择它可以读取的适当格式。
- en: It appears that mono files work best; not all browsers seem to support stereo
    sound files. This is because the browser will convert the sound to a stereo sound
    and try to replicate 3D audio (which can be done with only two speakers through
    a Head Related Transfer Function).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 单声道文件似乎效果最佳；并非所有浏览器都支持立体声音频文件。这是因为浏览器会将声音转换为立体声音，并尝试复制3D音频（这可以通过头部相关传输函数仅用两个扬声器完成）。
- en: Use mono files for the best compatibility.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单声道文件以获得最佳兼容性。
- en: Video
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Video
- en: As a `Video` is only a two dimensional (2D) object, it takes a width and height.
    This is not, as you are probably used to, in pixels, but instead in world units
    for the reasons discussed earlier. If people move their point of view closer or
    further away from your 2D video, it will change resolution from a dots per inch
    standpoint. You may need to experiment with sizes and video compression/storage
    to find the ideal balance of quality, download speed, and resolution (graininess).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Video` 只是一个二维（2D）对象，它需要宽度和高度。这不是像你可能习惯的以像素为单位，而是以世界单位，出于前面讨论的原因。如果人们将视角移近或远离你的2D视频，它将从每英寸点数的角度改变分辨率。您可能需要尝试不同的大小和视频压缩/存储方式，以找到质量、下载速度和分辨率（颗粒度）的理想平衡。
- en: '`Video` is best when used with the `VideoControl` (described earlier in this
    chapter).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Video` 与前面在本章中描述的 `VideoControl` 结合使用效果最佳。'
- en: 'This example showing a `Video` as well as a `VideoController`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个 `Video` 以及一个 `VideoController`：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `VideoControl` is not a child of `Video`; it is an independent
    object with its own location. In this example, presumably playing a 4:3 ratio
    video, it coordinates their stop/start/pause activity through `this.state.playerState`.
    In effect, you could think of the `VideoControl`'s `playerState` as being an output
    and the `Video`'s `playerState` as being an input.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`VideoControl` 不是 `Video` 的子级，它是一个独立的对象，有自己的位置。在这个例子中，可能播放一个4:3的视频，通过 `this.state.playerState`
    协调它们的停止/开始/暂停活动。实际上，你可以将 `VideoControl` 的 `playerState` 视为输出，将 `Video` 的 `playerState`
    视为输入。
- en: Cameras and viewing
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机和观看
- en: There is a camera object, called `LiveEnvCamera`, although it is not what you
    would normally expect.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`LiveEnvCamera`的相机对象，尽管它不是你通常期望的那样。
- en: In most CAD systems, the camera sets up basic statistics such as focal length,
    focus, what direction the camera is looking at, and the like.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数CAD系统中，相机设置基本统计数据，如焦距、焦点、相机朝向的方向等。
- en: With React VR, instead, we have a `<View>` at the top level in the `index.vr.js`;
    this is what constructs the VR view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在React VR中，我们在`index.vr.js`的顶层有一个`<View>`；这是构建VR视图的方式。
- en: The parameters of visibility of the view are really controlled by your physical
    viewing device. If your HMD has a 110 degree horizontal field of view, you will
    be seeing a 110 degree horizontal field of view.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的可见性参数实际上由您的物理观看设备控制。如果您的HMD水平视野为110度，您将看到110度的水平视野。
- en: This is something that traditional 3D artists have to get used to--VR is different.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传统3D艺术家必须适应的事情——VR是不同的。
- en: Along the same lines, lens flares and other effects, although they look great
    in movies, look terrible in VR. Your eyes don't have lens flares.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，镜头眩光和其他效果，尽管在电影中看起来很棒，在VR中看起来很糟糕。你的眼睛没有镜头眩光。
- en: Don't try to add them with React Native.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试使用React Native添加它们。
- en: You might wonder, how do we move the camera? The answer is that you transform
    the `<View>` . If you want to move say five meters forward, you transform the
    view five meters backwards, and the point of view will move into the scene. Note
    that this does not work for the `SpotLight`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想，我们如何移动相机？答案是您转换`<View>`。如果您想向前移动五米，您将视图向后移动五米，视点将移入场景。请注意，这对于`SpotLight`不起作用。
- en: LiveEnvCamera
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LiveEnvCamera
- en: This object displays the environment–facing camera. This may or may not be part
    of your viewer's hardware. GearVR, for example, may have an environment–facing
    camera; the Vive does, a Google Cardboard probably does not.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象显示面向环境的相机。这可能是您的观看设备的一部分，也可能不是。例如，GearVR可能有一个面向环境的相机；Vive有，Google Cardboard可能没有。
- en: 'By default, the camera is position: absolute `<LiveEnvCamera />`. The camera
    image is displayed on geometry that is 1000m away from the viewer.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，相机是`position: absolute <LiveEnvCamera />`。相机图像显示在距离观看者1000米的几何体上。'
- en: The LiveEnvCamera is probably intended for **Augmented Reality** (**AR**) applications;
    its use in React VR is experimental at best.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: LiveEnvCamera可能是为**增强现实**（**AR**）应用而设计的；在React VR中使用它充其量是实验性的。
- en: View
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: A `View` object is both the initial scene or camera in the world; it is also
    useful to aggregate objects in the world. In this way, it is very similar to a
    group node in traditional CAD programs. It really is essential to effective React
    VR software as a grouping node, not just the main rendering loop.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`对象既是世界中的初始场景或相机，也有助于聚合世界中的对象。在这种方式上，它与传统CAD程序中的组节点非常相似。作为分组节点，它对于有效的React
    VR软件非常重要，而不仅仅是主渲染循环。'
- en: The reason we mention that view is a camera is that it has layout props and
    transforms. If, in your main `render()` loop, you transform the `<View>` you are
    essentially moving where the camera, your current point of view, is looking.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到视图是相机的原因是它具有布局属性和变换。如果在您的主`render()`循环中，您转换了`<View>`，实际上是在移动相机，您当前的视点所看的位置。
- en: If you are using `<View>` as a grouping node, then the transforms apply to all
    of its children. You could build articulated models in this way, by properly exposing
    their properties and transforms, although it's more likely to do this through
    a glTF file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`<View>`用作分组节点，则变换将应用于其所有子节点。您可以通过适当地公开其属性和变换以此方式构建关节模型，尽管更可能是通过glTF文件来实现这一点。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basics of the React VR library, what components
    are in it, and the APIs and coding techniques they will be using to build your
    app. Enough background! Now that we have done this, in the next chapter, let's
    create an actual VR app.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了React VR库的基础知识，其中包括它的组件、API和编码技术，它们将用于构建您的应用程序。足够的背景知识！现在我们已经做到了，接下来让我们在下一章中创建一个真正的VR应用程序。
