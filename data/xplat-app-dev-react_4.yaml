- en: Chapter 4. Project 4 – Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 项目4 - 游戏
- en: Most of the most successful apps on the app stores are games. They proved to
    be really popular as mobile users tend to play all sort of games while commuting,
    in waiting rooms, when traveling, or even when relaxing at home. It is a fact
    that mobile users are more inclined to pay for a game than for any other kind
    of app in the market as the perceived value is higher most of the time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用商店上大多数成功的应用都是游戏。它们被证明非常受欢迎，因为移动用户倾向于在通勤、候诊室、旅行或者在家休息时玩各种类型的游戏。事实上，移动用户更倾向于为游戏付费，而不是市场上的其他类型的应用，因为大多数时候它们的感知价值更高。
- en: Modern games are usually built in powerful gaming engines such as Unity or Unreal,
    as they provide a wide range of tools and frameworks to work with sprites, animations,
    or physics. But the reality is that great games can also be built in React Native
    due to its native capabilities. Moreover, React Native has introduced many web
    and mobile app programmers into game development as it offers them a familiar
    and intuitive interface. Of book, there are some concepts in game development
    which need to be understood in order to make the most of the library when building
    games. Concepts like sprites, ticks, or collisions are small hurdles, which may
    need to be overcome by non-game developers before building a game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏通常是使用强大的游戏引擎构建的，比如Unity或Unreal，因为它们提供了一系列工具和框架来处理精灵、动画或物理效果。但事实是，由于其原生能力，React
    Native也可以构建出优秀的游戏。此外，React Native已经将许多网页和移动应用程序员引入游戏开发，因为它为他们提供了熟悉和直观的界面。当构建游戏时，非游戏开发人员可能需要理解一些游戏开发的概念，以充分利用库的优势。像精灵、滴答声或碰撞这样的概念是非游戏开发人员在构建游戏之前可能需要克服的小障碍。
- en: The game will be built for both iOS and Android, and will use a limited number
    of external libraries. Redux, the state management library, was chosen to help
    calculate the position of every sprite on each frame.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将为iOS和Android构建，并将使用有限数量的外部库。选择了Redux作为状态管理库，以帮助计算每一帧上每个精灵的位置。
- en: We will use some custom sprites and add a sound effect to notice each time the
    score is increased. One of the main challenges when building a game is making
    sure the sprites are rendered responsively, so different devices will show the
    game with the same proportions providing the same game experience across different
    screen sizes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些自定义精灵，并添加声音效果以提醒每次得分增加。构建游戏时的主要挑战之一是确保精灵能够响应式地渲染，以便不同设备以相同的比例显示游戏，从而在不同的屏幕尺寸上提供相同的游戏体验。
- en: This game will be designed to be played in portrait mode only.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏将设计为仅支持竖屏模式。
- en: Overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The game we will build in this lesson has simple mechanics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这节课中要构建的游戏具有简单的机制：
- en: The goal is to help a parrot fly between rocks in a cave
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是帮助一只鹦鹉在洞穴中飞过岩石
- en: Tapping the screen will result in the parrot flying higher
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击屏幕会使鹦鹉飞得更高
- en: Gravity will pull the parrot toward the ground
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力会把鹦鹉拉向地面
- en: Any collision between the parrot and the rocks or the ground will result in
    the end of the game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鹦鹉与岩石或地面之间的任何碰撞都将导致游戏结束
- en: The score will be increased every time the parrot flies through a group of rocks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次鹦鹉飞过一组岩石时，得分将增加
- en: This kind of game is very well suited to being built with React Native, as it
    doesn't really need complex animations or physics capabilities. All we need to
    be sure of is that we move every sprite (graphics component) on the screen at
    the correct time to create the feeling of continuous animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的游戏非常适合使用React Native构建，因为它实际上不需要复杂的动画或物理能力。我们只需要确保在正确的时间移动屏幕上的每个精灵（图形组件），以创建连续动画的感觉。
- en: 'Let''s take a look at the initial screen for our game:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们游戏的初始屏幕：
- en: '![Overview](Images/04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/04_01.jpg)'
- en: This screen presents the logo and instructions about how to get the game started.
    In this case, a simple tap will start up the game mechanics causing the parrot
    to fly forward and up on every tap.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕展示了游戏的标志和关于如何启动游戏的说明。在这种情况下，简单的轻触将启动游戏机制，导致鹦鹉在每次轻触时向前飞行。
- en: '![Overview](Images/04_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/04_02.jpg)'
- en: The player must help our parrot to fly through the rocks. Each time a set of
    rocks is passed, the player will get one point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家必须帮助我们的鹦鹉飞过岩石。每次通过一组岩石，玩家将获得一分。
- en: '![Overview](Images/04_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/04_03.jpg)'
- en: 'To make it more difficult, the heights of the rocks will vary forcing the parrot
    to fly higher or lower to pass through the rocks. If the parrot collides with
    a rock or the ground, the game will stop and the final score will be presented
    to the user:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加难度，岩石的高度将会变化，迫使鹦鹉飞得更高或更低以通过岩石。如果鹦鹉与岩石或地面发生碰撞，游戏将停止，并向用户呈现最终得分：
- en: '![Overview](Images/04_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/04_04.jpg)'
- en: At this point, the user will be able to restart the game by tapping again on
    the screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，用户可以通过再次在屏幕上轻触来重新开始游戏。
- en: 'To make it nicer and easier to play, tapping can be done anywhere on the screen,
    causing a different effect depending on which screen the user is on:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏更加美观和易玩，可以在屏幕的任何位置进行轻触，这将导致不同的效果，具体取决于用户所在的屏幕：
- en: On the initial screen tapping will start up the game
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始屏幕上轻触将启动游戏
- en: In-game tapping will result in the parrot flying higher
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的轻触将导致鹦鹉飞得更高
- en: On the **GAME OVER** screen tapping will restart the game and reset the score
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**游戏结束**屏幕上轻触将重新开始游戏并重置得分
- en: As can be observed, it will be a very simple game but, due to this, easily extendable
    and fun to play. One import aspect when building this kind of app is counting
    with a nice set of graphics. For this matter, we will download our assets from
    one of the multiple game assets markets, which can be found online (most game
    assets cost a small amount of money although free assets can be found every now
    and then).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如可以观察到的那样，这将是一个非常简单的游戏，但正因为如此，它很容易扩展并且很有趣。在构建这种类型的应用程序时，一个重要的方面是拥有一套精美的图形。为此，我们将从多个游戏资产市场之一下载我们的资产，这些市场可以在线找到（大多数游戏资产需要支付一小笔费用，尽管偶尔也可以找到免费资产）。
- en: 'The technical challenges for this game lie more in how the sprites will be
    moved over time than on a complex state to be maintained. Despite this, we will
    use Redux to keep and update the app''s state as it is a performant and well-known
    solution. Besides revisiting Redux, we will review the following topics in this
    lesson:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的技术挑战更多地在于精灵如何随时间移动，而不是在于复杂的状态维护。尽管如此，我们将使用Redux来保持和更新应用程序的状态，因为它是一个高性能且广为人知的解决方案。除了重新审视Redux，我们还将在本课程中复习以下主题：
- en: Handling animated sprites
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理动画精灵
- en: Playing sound effects
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音效
- en: Detecting colliding sprites
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞的精灵
- en: Absolute positioning in different screen resolutions
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同屏幕分辨率下的绝对定位
- en: Sprites
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵
- en: Sprites are the graphics used by the games, normally grouped into one or several
    images. Many game engines include tools to split and manage those graphics in
    a convenient way, but this is not the case in React Native. Since it was designed
    with a different kind of app having in mind, there are several libraries supporting
    React Native in the task of dealing with sprites, but our game will be simple
    enough not to need any of these libraries, so we will store one graphic in each
    image and we will load them separately into the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是游戏中使用的图形，通常分组成一个或多个图像。许多游戏引擎包括工具来方便地拆分和管理这些图形，但在React Native中并非如此。由于它是设计用来处理不同类型的应用程序的，有几个库支持React
    Native处理精灵，但我们的游戏将足够简单，不需要使用这些库，所以我们将把一个图形存储在每个图像中，并将它们分别加载到应用程序中。
- en: Before starting to build the game, let's get acquainted with the graphics we
    will load, as they will be the building blocks for the whole app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建游戏之前，让我们熟悉一下我们将加载的图形，因为它们将是整个应用程序的构建模块。
- en: Numbers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'Instead of using a `<Text/>` component to display the score in our game, we
    will use sprites for a more attractive look. These are the images we will use
    to represent the user''s score:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用精灵来显示游戏中的得分，而不是使用`<Text/>`组件，以获得更吸引人的外观。这些是我们将用来表示用户得分的图像：
- en: '![Numbers](Images/04_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![数字](Images/04_05.jpg)'
- en: As mentioned, all these graphics will be stored in separate images (named `0.png`
    to `9.png`) due to React Native's lack of sprite splitting capabilities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有这些图形将存储在单独的图像中（命名为`0.png`到`9.png`），因为React Native缺乏精灵拆分功能。
- en: Background
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: 'We need a large background to make sure it will fit all screen sizes. In this
    lesson, we will use this sprite as a static graphic although it could be easily
    animated to create a nice parallax effect:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个大背景来确保它适合所有屏幕尺寸。在本课程中，我们将使用这个精灵作为静态图形，尽管它可以很容易地进行动画处理，以创建一个漂亮的视差效果：
- en: '![Background](Images/04_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![背景](Images/04_06.jpg)'
- en: From this background, we will take a piece of ground to animate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个背景中，我们将取一块地面来进行动画。
- en: Ground
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地面
- en: 'The ground will be animated in a loop to create a constant feeling of velocity.
    The size of this image needs to be larger than the maximum screen resolution we
    want to support, as it should be moved from one side of the screen to the opposite.
    At all times, two ground images will be displayed, one after the other to ensure
    at least one of them is shown on the screen during the animation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 地面将循环动画，以创建恒定的速度感。这个图像的大小需要大于我们想要支持的最大屏幕分辨率，因为它应该从屏幕的一侧移动到另一侧。在任何时候，将显示两个地面图像，一个接一个地确保在动画期间至少显示一个图像在屏幕上。
- en: '![Ground](Images/04_07.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![地面](Images/04_07.jpg)'
- en: Rocks
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 岩石
- en: 'The moving rocks are the obstacles our parrot needs to pass. There will be
    one on the top and one on the bottom and both will be animated at the same speed
    as the ground. Their height will vary for each pair of rocks but always keep the
    same gap size between them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 移动的岩石是我们的鹦鹉需要通过的障碍物。顶部和底部各有一个，并且两者将以与地面相同的速度进行动画处理。它们的高度将因每对岩石而异，但始终保持它们之间的间隙大小相同：
- en: '![Rocks](Images/04_08.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![岩石](Images/04_08.jpg)'
- en: In our `images` folder, we will have `rock-up.png` and `rock-down.png` representing
    each sprite.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`images`文件夹中，我们将有`rock-up.png`和`rock-down.png`代表每个精灵。
- en: Parrot
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鹦鹉
- en: 'We will use two different images for our main character so we can create an
    animation displaying when the user has tapped on the screen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两张不同的图像来表示我们的主角，这样我们就可以创建一个动画，显示用户何时点击了屏幕：
- en: '![Parrot](Images/04_09.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![鹦鹉](Images/04_09.jpg)'
- en: 'The first image will be displayed when the parrot is moving down:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图将在鹦鹉向下移动时显示：
- en: '![Parrot](Images/04_10.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![鹦鹉](Images/04_10.jpg)'
- en: This second image will be shown every time the user presses the screen to move
    the parrot up. The images will be named `parrot1.png` and `parrot2.png`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图片将在用户按下屏幕使鹦鹉上升时显示。这些图片将被命名为`parrot1.png`和`parrot2.png`。
- en: The Home Screen
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主屏幕
- en: 'For the home screen, we will display two images: a logo and some instructions
    about how to get the game started. Let''s take a look at them:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主屏幕，我们将显示两张图片：一个标志和一些关于如何开始游戏的说明。让我们来看看它们：
- en: '![The Home Screen](Images/04_11.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![主屏幕](Images/04_11.jpg)'
- en: 'The instructions to start the game just point out that tapping will get the
    game started:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏的说明只是指出轻触将开始游戏：
- en: '![The Home Screen](Images/04_12.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![主屏幕](Images/04_12.jpg)'
- en: Game Over Screen
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束画面
- en: 'When the parrot hits a rock or the ground, the game will end. Then, it is time
    to display a game over sign and a reset button to get the game started again:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当鹦鹉撞到岩石或地面时，游戏将结束。然后，是时候显示游戏结束标志和重置按钮，以重新开始游戏：
- en: '![Game Over Screen](Images/04_13.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束画面](Images/04_13.jpg)'
- en: 'Although the entire screen will be touchable to get the game restarted, we
    will include a button to let the user know that tapping will result in the game
    restarting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然整个屏幕都可以触摸以重新开始游戏，但我们将包括一个按钮，让用户知道轻触将导致游戏重新开始：
- en: '![Game Over Screen](Images/04_14.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束画面](Images/04_14.jpg)'
- en: This image will be stored as `reset.png`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片将被存储为`reset.png`。
- en: 'This is the full list of images we will have in our game:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们游戏中将拥有的全部图片列表：
- en: '![Game Over Screen](Images/04_15.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束画面](Images/04_15.jpg)'
- en: Now, we know the list of images we will use in our game. Let's take a look at
    the whole folder structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了我们游戏中将使用的图片列表。让我们来看看整个文件夹结构。
- en: Setting up the folder structure
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `birdGame` and will be available for iOS and Android devices:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用React Native的CLI初始化一个React Native项目。该项目将命名为`birdGame`，并可用于iOS和Android设备：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As this one is a simple game, we will only need one screen in which we will
    position all our sprites moving, showing, or hiding them depending on the state
    of the game, which will be managed by Redux. Therefore, our folder structure will
    be in line the standard Redux apps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单的游戏，我们只需要一个屏幕，我们将在其中定位所有我们的精灵，根据游戏状态移动、显示或隐藏它们，这将由Redux管理。因此，我们的文件夹结构将符合标准的Redux应用程序：
- en: '![Setting up the folder structure](Images/04_16.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![设置文件夹结构](Images/04_16.jpg)'
- en: 'The `actions` folder will only contain one file as there are only three actions
    which may happen in this game **(** `start` **,** `tick`, and `bounce`). There
    is also a `sounds` folder to store the sound effect which will be played every
    time the parrot passes a pair of rocks:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions`文件夹将只包含一个文件，因为在这个游戏中只会发生三个动作（`start`，`tick`和`bounce`）。还有一个`sounds`文件夹，用于存储每次鹦鹉通过一对岩石时播放的音效：'
- en: '![Setting up the folder structure](Images/04_17.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![设置文件夹结构](Images/04_17.jpg)'
- en: 'For each sprite, we will create a component so we can move it, show it, or
    hide it easily:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个精灵，我们将创建一个组件，以便可以轻松地移动、显示或隐藏它：
- en: '![Setting up the folder structure](Images/04_18.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![设置文件夹结构](Images/04_18.jpg)'
- en: 'Again, only one reducer will be needed to process all our actions. We will
    also create two helper files:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，只需要一个reducer来处理我们所有的动作。我们还将创建两个辅助文件：
- en: '`constants.js`: This is where we will store helper variables for dividing the
    height and the width of the screen for the device playing the game'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constants.js`：这是我们将存储用于分割播放游戏设备屏幕高度和宽度的辅助变量的地方。'
- en: '`sprites.js`: This stores all the functions which will calculate how the sprites
    should be positioned in each frame to create the required animations'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sprites.js`：这里存储了所有将计算精灵在每一帧中应该定位的函数，以创建所需的动画。'
- en: '`main.js`will serve as the entry point for both iOS and Android and will be
    responsible to initialize Redux:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`将作为iOS和Android的入口点，并负责初始化Redux：'
- en: '![Setting up the folder structure](Images/04_19.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![设置文件夹结构](Images/04_19.jpg)'
- en: The rest of the files are generated by React Native's CLI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其余文件由React Native的CLI生成。
- en: 'Let''s now review the `package.json` file we will need to set the dependencies
    up in our project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来审查一下`package.json`文件，我们需要在项目中设置依赖项：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apart from Redux libraries, we will import `react-native-sound`, which will
    be in charge of playing any sounds in our game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Redux库，我们还将导入`react-native-sound`，它将负责在我们的游戏中播放任何声音。
- en: 'After running `npm install`, we will have our app ready to start coding. As
    happened in previous apps, the entry point for our messaging app will be the same
    code both in `index.ios.js` for iOS and in `index.android.js` for Android, but
    both will delegate the initialisation logic to `src/main.js`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install`后，我们的应用程序将准备好开始编码。与以前的应用程序一样，我们的消息应用的入口点将在`index.ios.js`和`index.android.js`中是相同的代码，但两者都将将初始化逻辑委托给`src/main.js`：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`src/main.js` is responsible for initializing Redux and will set `GameContainer`
    as the root component in our app:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`负责初始化Redux，并将`GameContainer`设置为我们应用程序的根组件：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use `GameContainer` as the root of the component tree in our app. As a regular
    Redux app, a `<Provider />`component is in charge of supplying the store to all
    the components which require reading or modifying the application state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`GameContainer`用作应用程序中组件树的根。作为常规的Redux应用程序，`<Provider />`组件负责向所有需要读取或修改应用程序状态的组件提供存储。
- en: GameContainer
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameContainer
- en: '`GameContainer` is responsible for starting up the game once the user taps
    the screen. It will do this using `requestAnimationFrame()`--one of the custom
    timers implemented in React Native.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameContainer`负责在用户点击屏幕后启动游戏。它将使用`requestAnimationFrame()`来实现这一点——这是React
    Native中实现的自定义定时器之一。'
- en: '`requestAnimationFrame()` is similar to `setTimeout()`, but the former will
    fire after all the frame has flushed, whereas the latter will fire as quickly
    as possible (over 1000x per second on a iPhone 5S); therefore, `requestAnimationFrame()`
    is more suited for animated games as it deals only with frames.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame()`类似于`setTimeout()`，但前者会在所有帧刷新后触发，而后者会尽快触发（在iPhone 5S上每秒超过1000次）；因此，`requestAnimationFrame()`更适合处理动画游戏，因为它只处理帧。'
- en: 'As happens with most animated games, we need to create a loop to animate the
    sprites in the screen by calculating the next position of each element on each
    frame. This loop will be created by a function named `nextFrame()` inside our
    `GameContainer`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数动画游戏一样，我们需要创建一个循环来通过计算每个元素在每一帧上的下一个位置来为屏幕中的精灵创建动画。这个循环将由`GameContainer`内部的名为`nextFrame()`的函数创建：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function will be aborted if the property `gameOver` is set to `true`. Otherwise,
    it will trigger the action `tick()` (which calculates how the sprites should be
    moved on to the next frame, based on the elapsed time) and finally calls itself
    through `requestAnimationFrame()`. This will keep the loop in the game to animate
    the moving sprites.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性`gameOver`设置为`true`，则此函数将被中止。否则，它将触发`tick()`动作（根据经过的时间计算精灵在下一帧上应该如何移动），最后通过`requestAnimationFrame()`调用自身。这将保持游戏中的循环以动画移动精灵。
- en: 'Of book, this `nextFrame()` should be called at the start for the first time,
    so we will also create a `start()` function inside `GameContainer` to get the
    game started:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个`nextFrame()`应该在第一次开始时被调用，所以我们还将在`GameContainer`内创建一个`start()`函数来启动游戏：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `start` function makes sure there is no animation started by calling `cancelAnimationFrame()`.
    This will prevent any double animations being performed when the user resets the
    game.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`函数通过调用`cancelAnimationFrame()`确保没有启动任何动画。这将防止用户重置游戏时执行任何双重动画。'
- en: Then, the functions trigger the `start()` action, which will just set a flag
    in the store to notice the game has started.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些函数触发`start()`动作，它只是在存储中设置一个标志，以通知游戏已经开始。
- en: We want to start the game by moving the parrot up, so the user has the time
    to react. For this, we also call the `bounce()` action.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过将鹦鹉向上移动来开始游戏，这样用户就有时间做出反应。为此，我们还调用`bounce()`动作。
- en: Finally, we start the animation loop by passing the already known `nextFrame()`
    function as a callback of `requestAnimationFrame()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将已知的`nextFrame()`函数作为`requestAnimationFrame()`的回调来启动动画循环。
- en: 'Let''s also review the `render()` method we will use for this container:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来审查一下我们将用于这个容器的`render()`方法：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It may be lengthy, but actually, it's a simple positioning of all the visible
    elements on the screen while wrapping them in a `<TouchableOpacity />` component
    to capture the user tapping no matter in which part of the screen. This `<TouchableOpacity
    />` component is actually not sending any feedback to the user when they tap the
    screen (we disabled it by passing `activeOpacity={1}` as a prop) since this feedback
    is already provided by the parrot bouncing on each tap.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会很长，但实际上，它只是简单地将屏幕上所有可见元素进行定位，同时将它们包裹在`<TouchableOpacity />`组件中，以便捕捉用户在屏幕的任何部分点击。这个`<TouchableOpacity
    />`组件实际上在用户点击屏幕时不会向用户发送任何反馈（我们通过传递`activeOpacity={1}`作为属性来禁用它），因为这个反馈已经由鹦鹉在每次点击时反弹来提供。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could have used React Native's `<TouchableWithoutFeedback />` for this matter,
    but it has several limitations which would have harmed our performance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用React Native的`<TouchableWithoutFeedback />`来处理这个问题，但它有一些限制，这可能会影响我们的性能。
- en: 'The provided `onPress` attribute just defines what the app should do when the
    user taps on the screen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`onPress`属性只是定义了用户在屏幕上点击时应用程序应该执行的操作：
- en: If the game is active, it will bounce the parrot sprite
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果游戏处于活动状态，它将使鹦鹉精灵反弹
- en: If the user is on the game over screen it will restart the game by calling the
    `start()` action
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在游戏结束画面上，它将通过调用`start()`动作重新启动游戏
- en: 'All other children in the `render()` method are the graphic elements in our
    game, specifying for each of them, their position and size. It''s also important
    to note several points:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`方法中的所有其他子元素都是我们游戏中的图形元素，为每个元素指定它们的位置和大小。还有几点需要注意：'
- en: There are two `<Ground />` components because we need to continuously animate
    it in the *x* axis. They will be positioned one after the other horizontally to
    animate them together so when the end of the first `<Ground />` component is shown
    on screen, the beginning of the second will follow creating the sense of continuum.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个`<Ground />`组件，因为我们需要在*x*轴上连续地对其进行动画处理。它们将水平排列在一起，以便一起进行动画处理，因此当第一个`<Ground
    />`组件的末端显示在屏幕上时，第二个的开头将跟随其后，从而创建连续感。
- en: The background is not contained in any custom component but in `<Image />`.
    This is because it doesn't need any special logic being a static element.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景不包含在任何自定义组件中，而是包含在`<Image />`中。这是因为作为静态元素，它不需要任何特殊的逻辑。
- en: Some positions are multiplied by factor variables (`W` and `H`). We will take
    a deeper look at these variables in the constants section. At this point, we only
    need to know that they are variables helping in the absolute positioning of the
    elements taking into account all screen sizes.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些位置被因子变量（`W`和`H`）相乘。我们将在常量部分更深入地研究这些变量。在这一点上，我们只需要知道它们是帮助绝对定位元素的变量，考虑到所有屏幕尺寸。
- en: 'Let''s now put all these functions together to build up our `<GameContainer
    />`:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在让我们将所有这些函数放在一起来构建我们的`<GameContainer />`：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We added three more ES6 and React lifecycle methods to this component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个组件中添加了另外三个ES6和React生命周期方法：
- en: '`super()`: The constructor will save an attribute named `animationFrameId`
    to capture the ID for the animation frame in which the `nextFrame` function will
    run and also another attribute named `time` will store the exact time at which
    the game was initialized. This `time` attribute will be used by the `tick()` function
    to calculate how much the sprites should be moved.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super()`: 构造函数将保存一个名为`animationFrameId`的属性，以捕获`nextFrame`函数将运行的动画帧的ID，还将保存另一个名为`time`的属性，该属性将存储游戏初始化的确切时间。`time`属性将被`tick()`函数用于计算精灵应该移动多少。'
- en: '`componentWillUpdate()`: This function will be called every time new props
    (positions and sizes for the sprites in the game) are passed. It will detect when
    the game must be stopped due to a collision so the game over screen will be displayed.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate()`: 每当传递新的props（游戏中精灵的位置和大小）时，将调用此函数。它将检测游戏是否因碰撞而必须停止，因此游戏结束屏幕将被显示。'
- en: '`shouldComponentUpdate()`: This performs another check to avoid re-rendering
    the game container if the game has ended.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate()`: 这执行另一个检查，以避免在游戏结束时重新渲染游戏容器。'
- en: 'The rest of the functions are Redux related. They are in charge of connecting
    the component to the store by injecting actions and attributes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的函数与Redux相关。它们负责通过注入操作和属性将组件连接到存储中：
- en: '`mapStateToProps()`: This gets the data for all the sprites in the store and
    injects them into the component as props. The sprites will be stored in an array
    and therefore they will be accessed by index. On top of these, the `Score`, a
    flag noting if the current game is over, and a flag noting if the game is in progress
    will also be retrieved from the state and injected into the component.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapStateToProps()`: 这会获取存储中所有精灵的数据，并将它们注入组件作为props。精灵将被存储在一个数组中，因此它们将通过索引访问。除此之外，`Score`，一个标志表示当前游戏是否结束，以及一个标志表示游戏是否正在进行也将从状态中检索并注入到组件中。'
- en: '`mapStateActionsToProps()`: This will inject the three available actions (`tick`,
    `bounce`, and `start`) into the component so they can be used by it.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapStateActionsToProps()`: 这将把三个可用操作（`tick`，`bounce`和`start`）注入到组件中，以便它们可以被使用。'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Accessing the sprites data by index is not a recommended practice as indexes
    can change if the number of sprites grows, but we will use it like this in this
    app for simplicity reasons.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引访问精灵数据并不是一种推荐的做法，因为如果精灵的数量增加，索引可能会发生变化，但出于简单起见，我们将在此应用中使用它。
- en: Actions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: 'As we mentioned before, only three Redux actions will be available:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，只有三个Redux操作将可用：
- en: '`tick()`: To calculate the next position of the sprites on the screen'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tick()`: 计算屏幕上精灵的下一个位置'
- en: '`bounce()`: To make the parrot fly up'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bounce()`: 让鹦鹉向上飞'
- en: '`start()`: To initialize the game variables'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`: 初始化游戏变量'
- en: 'This means our `src/actions/index.js` file should be very simple:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`src/actions/index.js`文件应该非常简单：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Only the `tick()` action needs to pass a payload: the time it passed since
    the last frame.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`tick()`操作需要传递一个有效负载：自上一帧以来经过的时间。
- en: Reducer
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducer
- en: 'Since we have a very limited amount of actions, our reducer will also be fairly
    simple and will delegate most of the functionality to the sprites helper functions
    in the `src/sprites.js` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有非常有限的行动，我们的减速器也会相当简单，并且会将大部分功能委托给`src/sprites.js`文件中的精灵助手函数：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `start()` function only needs to set the `isStarted` flag to `true`, as
    the initial state will have it set to `false` by default. We will reuse this initial
    state every time the game ends.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()`函数只需要将`isStarted`标志设置为`true`，因为初始状态默认情况下将其设置为`false`。我们将在每次游戏结束时重用此初始状态。'
- en: '`bounce()` will use the `bounceParrot()` function from the sprites module to
    set a new direction for the main character.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`bounce()`将使用精灵模块中的`bounceParrot()`函数来为主角设置新的方向。'
- en: The most important changes will happen when the `tick()` function is triggered,
    as it needs to calculate the positions of all moving elements (through the `moveSprites()`
    function), detect if the parrot has collided with any static elements (through
    the `checkForCollision()` function), and update the score in the store (through
    the `getUpdatedScore()` function).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的变化将发生在触发`tick()`函数时，因为它需要计算所有移动元素的位置（通过`moveSprites()`函数），检测鹦鹉是否与任何静态元素发生碰撞（通过`checkForCollision()`函数），并在存储中更新得分（通过`getUpdatedScore()`函数）。
- en: As we can see, most of the game's functionality is delegated to the helper functions
    inside the sprites module, so let's take a deeper look into the `src/sprites.js`
    file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，大部分游戏功能都委托给了精灵模块内的辅助函数，因此让我们更深入地看一下`src/sprites.js`文件。
- en: The Sprites Module
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵模块
- en: 'The structure of the sprites module is formed by an array of sprites and several
    exported functions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵模块的结构由精灵数组和几个导出函数组成：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This module begins by loading the sound effect we will play when the parrot
    passes a set of rocks to give feedback to the user about the increment in their
    score.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块首先通过加载我们将在鹦鹉通过一组岩石时播放的音效来开始，以向用户反馈其得分增加。
- en: 'Then, we define some heights for several sprites:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为几个精灵定义了一些高度：
- en: '`heightOfRockUp`: This is the height of the rock which will appear in the upper
    part of the screen.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfRockUp`：这是将出现在屏幕上部的岩石的高度。'
- en: '`heightOfRockDown`: This is the height of the rock which will show in the lower
    part of the screen.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfRockDown`：这是岩石的高度，将显示在屏幕的下部。'
- en: '`heightOfGap`: We will create an invisible view between the upper and the lower
    rock to detect when the parrot has passed each set of rocks so the score is updated.
    This this gap''s height.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfGap`：我们将在上部和下部岩石之间创建一个不可见的视图，以侦测鹦鹉何时通过每组岩石，以便更新得分。这是间隙的高度。'
- en: '`heightOfGround`: This is a static value for the height of the ground.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfGround`：这是地面高度的静态值。'
- en: Each other item in this module plays a role in moving or positioning the sprites
    on the screen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块中的每个其他项目都在移动或定位屏幕上的精灵。
- en: The Sprites Array
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵数组
- en: This is the array in charge of storing all the sprite's positions and sizes
    at a given time. Why are we using an array for storing our sprites instead of
    a hash map (Object)? Mainly for extensibility; although a hash map would make
    our code noticeably more readable, if we want to add new sprites of an existing
    type (as it happens with the `ground` sprite in this app) we would need to use
    artificial keys for each of them despite being the same type. Using an array of
    sprites is a recurrent pattern in game development which allows to decouple the
    implementation from the list of sprites.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是负责在给定时间存储所有精灵位置和大小的数组。为什么我们使用数组来存储我们的精灵，而不是哈希映射（对象）？主要是为了可扩展性；虽然哈希映射会使我们的代码更易读，但如果我们想要添加新的现有类型的精灵（就像在这个应用程序中的`ground`精灵一样），我们需要为它们每个使用人工键，尽管它们是相同类型的。使用精灵数组是游戏开发中的一种常见模式，它允许将实现与精灵列表解耦。
- en: 'Whenever we want to move a sprite, we will update its position in this array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要移动一个精灵，我们将更新它在这个数组中的位置：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The array will store the initial values for positioning and sizing all the moving
    sprites in the game.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 数组将存储游戏中所有移动精灵的定位和大小的初始值。
- en: prepareNewRockSizes()
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: prepareNewRockSizes()
- en: 'This function randomly calculates the size of the next upper and lower rock
    together with the height of the gap between them:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数随机计算下一个上部和下部岩石的大小以及它们之间间隙的高度：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's important to note that this function only calculates the heights for the
    new set of rocks but doesn't create them. This is just a preparation step.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个函数只计算新一组岩石的高度，但不创建它们。这只是一个准备步骤。
- en: getRockProps()
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: getRockProps()
- en: 'The helper functions to format the `position` and `size` attributes of a rock
    (or `gap)`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化岩石（或`gap`）的`position`和`size`属性的辅助函数：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: moveSprites()
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动精灵()
- en: This is the main function as it calculates the new position for each sprite
    stored in the sprites array. Game development relies in physics to calculate the
    position for each sprite in each frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要函数，因为它计算了存储在精灵数组中的每个精灵的新位置。游戏开发依赖于物理学来计算每帧中每个精灵的位置。
- en: For example, if we want to move an object to the right side of the screen, we
    will need to update its `x` position a number of pixels. The more pixels we add
    to the object's `x` attribute for the next frame, the faster it will move (`sprite.x
    = sprite.x + 5;` moves `sprite` five times faster than `sprite.x = sprite.x +
    1;`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要将一个对象移动到屏幕的右侧，我们将需要更新它的`x`位置一定数量的像素。我们为对象的`x`属性添加的像素越多，下一帧它就移动得越快（`sprite.x
    = sprite.x + 5;`比`sprite.x = sprite.x + 1;`移动得快五倍）。
- en: 'As we can see in the following example, the way we calculate the new position
    for each sprite is based on three factors: the current position of the sprite,
    the time that has passed since the last frame (`elapsedTime`), and the gravity/velocity
    of the sprite (`i.e. sprite.velocity.y + elapsedTime * gravity`).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的例子中所看到的，我们计算每个精灵的新位置的方式基于三个因素：精灵的当前位置，自上一帧以来经过的时间（`elapsedTime`），以及精灵的重力/速度（`即sprite.velocity.y
    + elapsedTime * gravity`）。
- en: 'Additionally, we will use the helper function `getRockProps` to get the new
    sizes and positions for the rocks. Let''s take a look at how the `moveSprites`
    function looks like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用辅助函数`getRockProps`来获取岩石的新大小和位置。让我们看看`moveSprites`函数是什么样子的：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Calculating the next position for a sprite is, most of the time, basic addition
    (or subtraction). Let''s take, for example, how the parrot should move:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 计算精灵的下一个位置，大多数情况下是基本的加法（或减法）。例如，让我们看看鹦鹉应该如何移动：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The parrot will only move vertically, basing its speed on gravity, so the `x`
    attribute will always stay fixed for it while the `y` attribute will change according
    to the function `sprite.position.y +` `sprite.velocity.y * elapsedTime +` `0.5
    * gravity * elapsedTime * elapsedTime` which, in summary, adds the elapsed time
    and the gravity in different factors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 鹦鹉只会在垂直方向移动，其速度基于重力，因此`x`属性对它来说始终保持不变，而`y`属性将根据函数`sprite.position.y +` `sprite.velocity.y
    * elapsedTime +` `0.5 * gravity * elapsedTime * elapsedTime`进行改变，这个函数总结起来就是将经过的时间和重力分别加到不同的因素中。
- en: 'The calculations for how the rocks should move are a little more complex, as
    we need to take into account every time the rocks disappear from the screen (`if
    (sprite.position.x > 0 - sprite.size.width)`). As they have been passed, we need
    to recreate them with different heights (`rockPosition = { x: 100, y: getRockProps(sprite.type).y
    }`).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '岩石应该如何移动的计算要复杂一些，因为我们需要考虑每次岩石从屏幕上消失的情况（`if (sprite.position.x > 0 - sprite.size.width)`）。当它们被超过时，我们需要用不同的高度重新创建它们（`rockPosition
    = { x: 100, y: getRockProps(sprite.type).y }`）。'
- en: We have the same behavior for the ground, in terms of having to recreate it
    once it abandons the screen completely (`if (sprite.position.x > -97)`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对地面也有相同的行为，需要在它完全离开屏幕时重新创建它（`if (sprite.position.x > -97)`）。
- en: bounceParrot()
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹跳鹦鹉()
- en: 'The only task for this function is changing the velocity of the main character,
    so it will fly up reversing the effect of gravity. This function will be called
    whenever the user taps on the screen while the game is started:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的唯一任务是改变主角的速度，这样它就会向上飞，逆转重力的影响。这个函数将在用户在游戏开始时点击屏幕时调用：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's a simple operation in which we take the parrot's sprite data from the `sprites`
    array; we change its velocity on the **y** axis to a negative value so that the
    parrot moves upwards.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的操作，我们从`sprites`数组中获取鹦鹉的精灵数据；我们将其在**y**轴上的速度更改为负值，以使鹦鹉向上移动。
- en: checkForCollision()
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: checkForCollision()
- en: '`checkForCollision()` is responsible for identifying if any of the rigid sprites
    have collided with the parrot sprite, so the game can be stopped. It will use
    `hasCollided()` as a supporting function to perform the required calculations
    on each specific sprite:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForCollision()`负责识别任何刚性精灵是否与鹦鹉精灵发生了碰撞，以便游戏可以停止。它将使用`hasCollided()`作为一个支持函数，对每个特定的精灵执行所需的计算。'
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For simplicity, we assume that all sprites have a rectangular shape (even though
    rocks grow thinner towards the end) because the calculation would be a lot more
    complex if we considered different shapes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们假设所有精灵都是矩形的形状（尽管岩石朝末端变得更薄），因为如果考虑不同的形状，计算会更加复杂。
- en: In summary, `checkForCollision()` is just looping through the `sprites` array
    to find any colliding sprite, `hasCollided()` checks for collisions based on the
    sprite size and position. In just an `if` statement, we compare the boundaries
    of a sprite and the parrot's sprite to see if any of those boundaries are occupying
    the same area of the screen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`checkForCollision()`只是循环遍历`sprites`数组，以找到任何发生碰撞的精灵，`hasCollided()`根据精灵的大小和位置检查碰撞。在一个`if`语句中，我们比较了精灵和鹦鹉精灵的边界，以查看它们是否占据了屏幕相同的区域。
- en: getUpdatedScore()
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: getUpdatedScore()
- en: 'The last function in the sprites module will check if the score needs to be
    updated based on parrot position relative to the gap position (the gap between
    the upper and the lower rock is also counted as a sprite):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵模块中的最后一个函数将检查分数是否需要根据鹦鹉位置相对于间隙位置（上下岩石之间的间隙也被视为一个精灵）进行更新：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An `if` statement checks if the parrot's position in the **x** axis has surpassed
    the gap (`gapXPosition + gapWidth`). When this happens, we play the sound we created
    in the header of the module (`const coinSound = new sound(“coin.wav", sound.MAIN_BUNDLE);`)
    by calling its `play()` method. Moreover, we will increase the `score` variable
    and prepare a new set of rocks to be rendered when the current ones leave the
    screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`语句检查了鹦鹉在**x**轴上的位置是否超过了间隙（`gapXPosition + gapWidth`）。当这种情况发生时，我们通过调用其`play()`方法来播放我们在模块头部创建的声音（`const
    coinSound = new sound(“coin.wav", sound.MAIN_BUNDLE);`）。此外，我们将增加`score`变量，并准备一个新的岩石组在当前的岩石离开屏幕时渲染。
- en: Constants
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'We already saw the variables `W` and `H`. They represent one part of the screen
    if we divided it into 100 parts. Let''s take a look at the `constants.js` file
    to understand this better:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了变量`W`和`H`。它们代表了屏幕的一部分，如果我们把它分成100部分。让我们看一下`constants.js`文件，以更好地理解这一点：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`W` can be calculated as the total width of the device''s screen divided by
    `100` units (as percentages are easier to reason about when positioning our sprites).
    The same goes for `H`; it can be calculated by dividing the total height by `100`.
    Using these two constants, we can position and size our sprites relative to the
    size of the screen, so all screen sizes will display the same ratios for positions
    and sizes.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`W`可以通过将设备屏幕的总宽度除以`100`单位来计算（因为百分比在定位我们的精灵时更容易推理）。`H`也是如此；它可以通过将总高度除以`100`来计算。使用这两个常量，我们可以相对于屏幕的大小来定位和调整我们的精灵的大小，因此所有屏幕尺寸将显示相同的位置和大小比例。'
- en: These constants will be used in all the visual components requiring responsive
    capabilities so they will show and move different depending on the screen size.
    This technique will ensure the game is playable even in small screens as the sprites
    will be resized accordingly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量将用于所有需要响应能力的视觉组件，因此它们将根据屏幕大小的不同显示和移动。这种技术将确保即使在小屏幕上，游戏也是可玩的，因为精灵将相应地调整大小。
- en: Let's move on now to the components which will be displayed inside the `<GameContainer
    />`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续移动到将显示在`<GameContainer />`内的组件。
- en: Parrot
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鹦鹉
- en: 'The main character will be represented by this component, which will comprise
    of two different images (the same parrot with its wings up and down) driven by
    the `Y` position property passed by `<GameContainer />`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 主角将由这个组件表示，它将由`<GameContainer />`传递的`Y`位置属性驱动的两个不同的图像组成（翅膀上扬和下垂的相同鹦鹉）：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use a state variable named `wings` to pick which image the parrot will be--when
    it is flying up the image with the wings down will be displayed while the wings
    up will be shown when flying down. The way this will be calculated is based on
    the position of the bird on the **y** axis passed as a property from the container:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`wings`的状态变量来选择鹦鹉将会是哪个形象--当它向上飞时，会显示翅膀下垂的形象，而向下飞时会显示翅膀上扬的形象。这将根据鸟在**y**轴上的位置来计算，该位置作为属性从容器传递过来：
- en: If the `Y` position is lower than the previous `Y` position means the bird is
    going down and therefore the wings should be up
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Y`位置低于先前的`Y`位置，意味着鸟正在下降，因此翅膀应该上扬
- en: If the `Y` position is higher than the previous `Y` position means the bird
    is going up and therefore the wings should be down
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Y`位置高于先前的`Y`位置，意味着鸟正在上升，因此翅膀应该下垂
- en: The size of the parrot is fixed to `12 * W` both for the `height` and `width`
    as the sprite is a square and we want it to be sized relative to the width of
    each screen device.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 鹦鹉的大小固定为`12 * W`，对于`height`和`width`都是如此，因为精灵是一个正方形，我们希望它相对于每个屏幕设备的宽度进行调整。
- en: RockUp and RockDown
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RockUp和RockDown
- en: 'The sprites for the rocks have no logic on them and are basically `<Image />`
    components positioned and sized by the parent component. This is the code for
    `<RockUp />`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 岩石的精灵上没有逻辑，基本上是由父组件定位和调整大小的 `<Image />` 组件。这是 `<RockUp />` 的代码：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The height and the width will be calculated by the following formulae: `this.props.width
    * W` and `this.props.height * H`. This will size the rock relative to the device''s
    screen and the provided height and width.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 高度和宽度将通过以下公式计算：`this.props.width * W` 和 `this.props.height * H`。这将使岩石相对于设备屏幕和提供的高度和宽度进行调整。
- en: 'The code for `<RockDown />` is quite similar:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`<RockDown />` 的代码非常相似：'
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ground
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地面
- en: 'Building the ground component is similar to the rock sprites. An image rendered
    in the proper position and size will be sufficient for this component:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 构建地面组件与岩石精灵类似。在正确的位置和大小渲染图像将足以满足此组件的需求：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, we will use `H` to relatively positioning the ground image.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用 `H` 来相对定位地面图像。
- en: Score
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分
- en: 'We decided to use number images to render the score, so we will need to load
    them and pick the appropriate digits depending on the user''s score:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用数字图像来渲染分数，因此我们需要加载它们并根据用户的分数选择适当的数字：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are doing the following in the `render` method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `render` 方法中进行以下操作：
- en: Converting the score to a string
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分数转换为字符串
- en: Converting the string into a list of digits
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为数字列表
- en: Turning this list of digits into a list of images using the supporting `getSource()`
    function
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用支持的 `getSource()` 函数将数字列表转换为图像列表
- en: One of the limitations in React Native `<Image />` is that its source cannot
    be required as a variable. Hence, we are using this small trick of retrieving
    the source from our `getSource()` method, which actually acquires all the possible
    images and returns the correct one through a `switch`/`case` clause.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: React Native `<Image />` 的一个限制是其源不能作为变量被引入。因此，我们使用 `getSource()` 方法来检索源的小技巧，该方法实际上获取所有可能的图像，并通过
    `switch`/`case` 子句返回正确的图像。
- en: Start
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The start screen includes two images:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 开始屏幕包括两个图像：
- en: A logo
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标志
- en: A start button explaining how to start up the game (tapping anywhere on the
    screen)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解释如何启动游戏的开始按钮（在屏幕上的任何位置轻触）
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using our `H` and `W` constants again to ensure the elements are positioned
    in the right place on every device screen.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用我们的 `H` 和 `W` 常量，以确保元素在每个设备屏幕上都定位正确。
- en: GameOver
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'When the parrot collides with a rock or the ground, we should display the game
    over screen. This screen only contains two images:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当鹦鹉与岩石或地面发生碰撞时，我们应该显示游戏结束画面。这个画面只包含两个图像：
- en: A game over sign
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束标志
- en: A button to restart the game
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新开始游戏的按钮
- en: 'Let''s first take a look at the game over sign:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下游戏结束标志：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's move on to the reset the game button.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续重置游戏按钮。
- en: StartAgain
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新开始
- en: 'Actually, the reset button is only a sign as the user will be able to tap not
    only on the button but anywhere on the screen to get the game started. In any
    case, we will position this button properly on every screen using the *H* and
    *W* constants:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，重置按钮只是一个标志，因为用户不仅可以在按钮上轻触，还可以在屏幕的任何位置开始游戏。无论如何，我们将使用 *H* 和 *W* 常量在每个屏幕上正确定位此按钮：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Games are a very special kind of app. They are based on displaying and moving
    sprites on the screen, depending on the time and the user interaction. That is
    why we spent most of this lesson explaining how we could easily display all the
    images in the most performant way and how to position and size them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏是一种非常特殊的应用程序。它们基于根据时间和用户交互在屏幕上显示和移动精灵。这就是为什么我们在大部分课程中解释了如何以最高效的方式轻松显示所有图像以及如何定位和调整它们的大小。
- en: We also reviewed a common trick to position and size sprites relatively to the
    height and width of the device screen.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还审查了一种常见的技巧，相对于设备屏幕的高度和宽度来定位和调整精灵的大小。
- en: Despite not being designed for games specifically, Redux was used to store and
    distribute the sprite's data around the components in our app.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Redux并非专门为游戏设计，但我们在应用程序中使用它来存储和分发精灵的数据。
- en: 'At a general level, we proved that React Native can be used to build performant
    games and, although it lacks game-specific tooling, we can produce a very readable
    code which means it should be easy to extend and maintain. In fact, some very
    easy extensions can be created at this stage to make the game more fun and playable:
    increase speed after passing a specific amount of obstacles, reduce or increase
    the gap size, show more than one set of rocks on screen at once, and so.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们证明了React Native可以用于构建高性能的游戏，尽管它缺乏游戏特定的工具，但我们可以生成非常可读的代码，这意味着它应该很容易扩展和维护。事实上，在这个阶段可以创建一些非常简单的扩展来使游戏更有趣和可玩性：在通过特定数量的障碍物后增加速度，减少或增加间隙大小，在屏幕上显示多组岩石等等。
- en: With this, we've come to the end of this learning journey. I hope you'd a smooth
    journey and gained a lot of knowledge on React.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们已经完成了这次学习之旅。我希望你有一个顺利的旅程，并在React上获得了很多知识。
- en: I wish you all the best for your future projects. Keep learning and exploring!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 祝愿你在未来的项目中一切顺利。继续学习和探索！
- en: Assessments
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Name the graphics that are used by the games, normally grouped into one or several
    images.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名游戏中使用的图形，通常分组为一个或多个图像。
- en: Numbers
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字
- en: Background
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 背景
- en: Ground
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面
- en: Sprites
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精灵
- en: 'State whether the following statement is True or False: Sprites are the graphics
    used by the games, normally grouped into one or several images. Many game engines
    include tools to split and manage those graphics in a convenient way, but this
    is not the case in React Native.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请说明以下陈述是真还是假：精灵是游戏中使用的图形，通常分组为一个或多个图像。许多游戏引擎包括工具来方便地拆分和管理这些图形，但在React Native中并非如此。
- en: 'State whether the following statement is True or False: The sprites array is
    the array in charge of storing all the sprite''s positions and sizes at a given
    time.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请说明以下陈述是真还是假：精灵数组是负责在特定时间存储所有精灵位置和大小的数组。
- en: Which functions are in charge of connecting the component to the store by injecting
    actions and attributes?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些功能负责通过注入操作和属性将组件连接到存储中？
- en: ________ is responsible for starting up the game once the user taps the screen.
    It will do this using `requestAnimationFrame()`--one of the custom timers implemented
    in React Native.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ________负责在用户点击屏幕后启动游戏。它将使用`requestAnimationFrame()`来实现这一点——这是React Native中实现的自定义定时器之一。
- en: '`nextFrame()`'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nextFrame()`'
- en: '`cancelAnimationFrame()`'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cancelAnimationFrame()`'
- en: '`GameContainer`'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameContainer`'
- en: '`mapStateToProps(state)`'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mapStateToProps(state)`'
