- en: React Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Redux
- en: So far in this book, we have managed state within our React components. We've
    also used React context when state needs to be shared between different components.
    This approach works well for many applications. React Redux helps us to robustly
    handle complex state scenarios. It shines when user interactions result in several
    changes to state, perhaps some that are conditional, and particularly when the
    interaction results in web service calls. It's also great when there is lots of
    shared state across the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经在React组件内部管理了状态。当状态需要在不同组件之间共享时，我们还使用了React上下文。这种方法对许多应用程序都很有效。React
    Redux帮助我们强大地处理复杂的状态场景。当用户交互导致状态发生多个变化时，它会发挥作用，也许其中一些是有条件的，特别是当交互导致web服务调用时。当应用程序中存在大量共享状态时，它也非常有用。
- en: We are going to continue building our React shop in this chapter, adding React
    Redux to help us manage our state interactions. We'll eventually add a basket
    summary component in the header of our shop, which informs the user of how many
    items are in their basket. Redux will help us update this component when items
    are added to the basket.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建我们的React商店，添加React Redux来帮助我们管理状态交互。最终，我们将在商店的页眉中添加一个购物篮摘要组件，通知用户他们的购物篮中有多少件商品。Redux将帮助我们在商品添加到购物篮时更新此组件。
- en: In the final section of the chapter, we'll explorer a Redux-like method for
    managing complex state within a component. This is a middle ground between managing
    state in a Redux store and just within a component using `setState` or `useState`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将探讨一种类似于Redux的方法，用于在组件内部管理复杂状态。这是在Redux存储中管理状态和仅在组件内部使用`setState`或`useState`之间的中间地带。
- en: 'In this chapter, we''ll learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Principles and key concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原则和关键概念
- en: Installing Redux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Redux
- en: Creating reducers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建reducers
- en: Creating actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动作
- en: Creating a store
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储
- en: Connecting our React App to the store
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的React应用连接到存储
- en: Managing state with useReducer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用useReducer管理状态
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We''ll use the following technologies in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和** `npm`：TypeScript和React依赖于这些。我们可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装这些。如果我们已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写我们的React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要在Visual
    Studio Code中安装 TSLint（由egamma提供）和Prettier（由Estben Petersen提供）扩展。'
- en: '**React shop**: We''ll start from the React shop project we finished in the
    last chapter. This is available on GitHub at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms/04-FormSubmission](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms/04-FormSubmission).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React商店**：我们将从上一章完成的React商店项目开始。该项目可以在GitHub上找到[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms/04-FormSubmission](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms/04-FormSubmission)。'
- en: In order to restore code from a previous chapter, the `LearnReact17WithTypeScript` repository
    at [https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript) can
    be downloaded. The relevant folder can then be opened in Visual Studio Code and
    then `npm install` can be entered in the terminal to do the restore. All the code
    snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从上一章恢复代码，可以下载[https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript)上的`LearnReact17WithTypeScript`存储库。然后可以在Visual
    Studio Code中打开相关文件夹，然后在终端中输入`npm install`进行恢复。本章中的所有代码片段都可以在[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF)上找到。
- en: Principles and key concepts
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则和关键概念
- en: In this section, we'll start by going through the three principles in Redux
    and then dive into the core concepts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先介绍Redux中的三个原则，然后深入探讨核心概念。
- en: Principles
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则
- en: 'Let''s take a look at the three principles of Redux:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Redux的三个原则：
- en: '**Single source of truth**: This means that the whole application state is
    stored in a single object. In a real app, this object is likely to contain a complex
    tree of nested objects.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一数据源**：这意味着整个应用程序状态存储在一个对象中。在真实的应用程序中，该对象可能包含复杂的嵌套对象树。'
- en: '**State is read-only**: This means that state can''t be directly changed. This
    is a bit like saying we can''t directly change the state within a component. In
    Redux, the only way to change state is to dispatch what''s called an action.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态是只读的**：这意味着状态不能直接更改。这有点像说我们不能直接更改组件内的状态。在Redux中，更改状态的唯一方法是分派所谓的动作。'
- en: '**Changes are made with pure functions**: The functions that are responsible
    for changing the state are called reducers.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改是通过纯函数进行的：负责更改状态的函数称为reducers。
- en: In the following sections, we'll dive into actions and reducers a little more
    along with the thing that manages them which is what is called a store.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地了解动作和reducers，以及管理它们的东西，即所谓的**store**。
- en: Key concepts
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键概念
- en: 'The whole state of the application lives inside what is called a **store**.
    The state is stored in a JavaScript object like the one following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的整个状态存储在所谓的**store**中。状态存储在一个JavaScript对象中，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, the single object contains these:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，单个对象包含以下内容：
- en: An array of products
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品数组
- en: Whether the products are being fetched from a web API
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品是否正在从Web API中获取
- en: The current product the user is looking at
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户正在查看的当前产品
- en: The items in the users basket
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户购物篮中的物品
- en: The state won't contain any functions or setters or any getters. It's a simple
    JavaScript object. The store also orchestrates all the moving parts in Redux.
    This includes pushing actions though reducers to update state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 状态不包含任何函数、设置器或任何获取器。它是一个简单的JavaScript对象。存储还协调Redux中的所有移动部分。这包括通过reducers推送动作来更新状态。
- en: 'So, the first thing that needs to happen in order to update state in a store
    is to dispatch an **action**. An action is another simple JavaScript object like
    the one following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要更新存储中的状态，首先需要分派一个**action**。动作是另一个简单的JavaScript对象，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `type` property determines the type of action that needs to be performed.
    This is an important and required part of the action. The reducer won't know how
    to change the state without the `type` in the action object. In the previous example,
    the action doesn't contain anything else other than the `type` property. This
    is because the reducer doesn't need any more information in order to make the
    change to state for this type of action.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`属性确定需要执行的操作类型。这是操作的一个重要且必需的部分。如果操作对象中没有`type`，reducer将不知道如何更改状态。在前面的示例中，操作除了`type`属性之外没有包含任何其他内容。这是因为reducer不需要其他信息来为此类型的操作更改状态。'
- en: 'The following example is another action:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是另一个操作：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time, an additional bit of information is included in the action in a `product`
    property. This additional information is needed by the reducer to make the change
    to state for this type of action.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在操作中包含了一个`product`属性的额外信息。reducer需要这些额外信息来为此类型的操作更改状态。
- en: So, reducers are pure functions that make the actual state changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，reducer是实际更改状态的纯函数。
- en: A pure function always returns the same result for a given set of parameters.
    So, these functions don't depend on any state outside the scope of the function
    that isn't passed into the function. Pure functions also don't change any state outside
    the scope of the function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数对于给定的一组参数总是返回相同的结果。因此，这些函数不依赖于函数范围之外的任何状态，而这些状态没有传递到函数中。纯函数也不会改变函数范围之外的任何状态。
- en: 'The following is an example of a reducer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是reducer的一个示例：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is something about reducers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于reducer的一些内容：
- en: Reducers take in two parameters for the current state and the action that is
    being performed
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reducer接受当前状态和正在执行的操作这两个参数。
- en: The state argument defaults to an initial state object for when the reducer
    is called for the very first time
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当首次调用reducer时，状态参数默认为初始状态对象
- en: A switch statement is used on the action type and creates a new state object
    appropriately for each action type in each of its branches
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作类型上使用switch语句，并为其每个分支创建一个新的状态对象
- en: To create the new state, we spread the current state into a new object and then
    overwrite it with properties that have changed
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创建新状态，我们将当前状态扩展到一个新对象中，然后用已更改的属性覆盖它
- en: The new state is returned from the reducer
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新状态是从reducer返回的
- en: You'll notice that the actions and reducer we have just seen didn't have TypeScript
    types. Obviously, we'll include the necessary types when we implement these in
    the following sections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们刚刚看到的操作和reducer没有TypeScript类型。显然，在我们在接下来的章节中实现这些时，我们将包含必要的类型。
- en: So, now that we have started to get an understanding of what Redux is, it's
    time to put this into practice in our React shop.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经开始了解Redux是什么，是时候在我们的React商店中实践这一点了。
- en: Installing Redux
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Redux
- en: 'Before we can use Redux, we need to install it along with the TypeScript types.
    We will also install an additional library called `redux-thunk`, which we need
    in order to implement asynchronous actions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用Redux之前，我们需要安装它以及TypeScript类型。我们还将安装一个名为`redux-thunk`的额外库，这是为了实现异步操作而需要的：
- en: 'If we haven''t already, let''s open our React shop project in Visual Studio
    Code from where we left off in the last chapter. So, let''s install the core Redux
    library via `npm` in the terminal:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还没有的话，让我们从上一章结束的地方在Visual Studio Code中打开我们的React商店项目。因此，让我们在终端中通过`npm`安装核心Redux库：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the core Redux library contains TypeScript types within it. So, there
    is no need for an additional install for these.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，核心Redux库中包含了TypeScript类型。因此，不需要额外安装这些类型。
- en: 'Let''s now install the React-specific bits for Redux. These bits allow us to
    connect our React components to the Redux store. Let''s install these via `npm`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在安装Redux的React特定部分。这些部分允许我们将React组件连接到Redux存储。让我们通过`npm`安装这些部分：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s also install the TypeScript types for `react-redux`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也安装`react-redux`的TypeScript类型：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s install `redux-thunk` as well:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也安装`redux-thunk`：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, we can install the TypeScript types for `redux-thunk`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以安装`redux-thunk`的TypeScript类型：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With all the Redux bits now installed, we can add Redux to the React shop we
    have been working on in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有Redux部分都已安装，我们可以在下一节中将Redux添加到我们一直在开发的React商店中。
- en: Creating actions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作
- en: We are going to extend the React shop we have been building in previous chapters
    and add Redux to manage the state on the Products page. In this section, we'll
    create actions to start the process of getting the products into the page. There
    will be one action to get the products. There will be another action to change
    some new loading state, which we'll eventually tie to the `withLoading` HOC that
    we already have in our project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们在之前章节中构建的React商店，并添加Redux来管理`Products`页面上的状态。在本节中，我们将创建操作来开始将产品添加到页面的过程。将有一个操作来获取产品。将有另一个操作来改变一些新的加载状态，最终我们将把它与我们项目中已经拥有的`withLoading`
    HOC联系起来。
- en: 'Before we make a start on the Redux actions, let''s create a fake API in `ProductsData.ts`
    for fetching products:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写Redux操作之前，让我们在`ProductsData.ts`中创建一个虚拟API来获取产品：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, the function asynchronously waits a second before returning the products.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该函数在返回产品之前会异步等待一秒钟。
- en: We need to start our action's implementation by creating some types. We'll do
    this next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过创建一些类型来开始实现我们的操作。我们将在下一步完成这个步骤。
- en: Creating state and action types
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建状态和操作类型
- en: 'It''s time to finally make a start on enhancing our React shop with Redux.
    We''ll start by creating some types for the state and actions for our Redux store:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始使用Redux来增强我们的React商店了。我们将首先为Redux存储创建一些状态和操作类型：
- en: 'Let''s create a new file called `ProductsTypes.ts` in the `src` folder with
    the following import statement at the top:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src`文件夹中创建一个名为`ProductsTypes.ts`的新文件，并在顶部添加以下导入语句：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create an enumeration for the two different action types that we are
    going to implement:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们将要实现的两种不同操作类型创建一个枚举：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Redux doesn''t dictate the format of the action type strings. So, the format
    of the action type strings is our choice. We need to make sure the strings are
    unique though across the actions types in the store. So, we''ve included two bits
    of information in the string:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Redux不规定操作类型字符串的格式。因此，操作类型字符串的格式是我们的选择。但是，我们需要确保这些字符串在存储中的操作类型中是唯一的。因此，我们在字符串中包含了两个信息：
- en: The area of the store the action is concerned with. In our case, this is `PRODUCTS`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作涉及的存储区域。在我们的情况下，这是`PRODUCTS`。
- en: The specific operation within that area. In our case, we have `GETALL` for getting
    all the products and `LOADING` to indicate products are being fetched.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该区域内的特定操作。在我们的情况下，我们有`GETALL`用于获取所有产品，`LOADING`用于指示产品正在被获取。
- en: We could have chosen `PRODUCTS`-`GETALL` or `Get All Products`. We just need
    to make sure the strings are unique. We have used an enumeration to give us nice
    IntelliSense when we consume these when implementing the action and reducer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择`PRODUCTS`-`GETALL`或`Get All Products`。我们只需要确保字符串是唯一的。我们使用枚举来在实现操作和减速器时给我们良好的IntelliSense。
- en: 'We can now create interfaces for the two actions:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为这两个操作创建接口：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `IProductsGetAllAction` interface is for an action that will be dispatched
    when the products need to be fetched. The `IProductsLoadingAction` interface is
    for an action that will cause the reducer to change the loading state.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProductsGetAllAction`接口用于在需要获取产品时分派的动作。`IProductsLoadingAction`接口用于导致减速器改变加载状态的动作。'
- en: 'Let''s combine the action types together with a union type:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将动作类型与联合类型结合在一起：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will be the type for the action parameter passed into the reducer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是传递给减速器的动作参数的类型。
- en: 'Lastly, let''s create an interface for this area of the state in the store:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在存储中为这个状态区域创建一个接口：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, our state will contain an array of products, and whether products are being
    loaded.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的状态将包含一个产品数组，以及产品是否正在加载。
- en: Notice that the properties are prefixed with the `readonly` keyword. This will
    help us avoid changing the state directly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，属性前缀带有`readonly`关键字。这将帮助我们避免直接更改状态。
- en: Now that we have types in place for the actions and state, we can create some
    actions in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为动作和状态准备好了类型，我们可以在下一节中创建一些动作。
- en: Creating actions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动作
- en: In this section, we are going to create two actions for getting the products
    and indicating that products are being loaded.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将创建两个动作，用于获取产品并指示产品正在加载。
- en: 'Let''s start by creating a `ProductsActions.ts` file with the following import
    statement:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个带有以下导入语句的`ProductsActions.ts`文件开始：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are a few types from Redux that we are going to use when implementing
    our actions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在实现动作时将要使用的Redux中的一些类型。
- en: 'One of our actions is going to be asynchronous. So, let''s import a type from
    `redux-thunk` ready for when we implement this action:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的动作之一将是异步的。因此，让我们从`redux-thunk`中导入一个类型，以便在实现此动作时准备好：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s add another import statement so that we can use our fake API:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个导入语句，以便我们可以使用我们的虚假API：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've renamed the API function to `getProductsFromAPI` to avoid a name clash
    because we are going to create an action called `getProducts` a little later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将API函数重命名为`getProductsFromAPI`，以避免名称冲突，因为我们将稍后创建一个名为`getProducts`的动作。
- en: 'Let''s also import the types we created in the last section:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还导入上一节中创建的类型：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to create what is called an action creator now. An action creator
    does what it says on the tin: it''s a function that creates and returns an action!
    Let''s create an action creator for creating the product loading action:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在要创建一个称为动作创建者的东西。动作创建者就像它的名字一样：它是一个创建并返回动作的函数！让我们为创建产品加载动作创建一个动作创建者：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We use the generic `ActionCreator` type containing the appropriate action interface
    for the function signature
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用包含适当动作接口的泛型`ActionCreator`类型来定义函数签名
- en: The function simply returns the required action object
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数简单地返回所需的动作对象
- en: 'We can write this function more succinctly using an implicit return statement
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用隐式返回语句更简洁地编写这个函数，如下所示：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We'll use this shorter syntax from now on when implementing action creators.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现动作创建者时，我们将使用这种更短的语法。
- en: 'Let''s move on to implementing the action creator for getting products. This
    is more complex, so let''s start with the function signature:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续实现获取产品的动作创建者。这更复杂，所以让我们从函数签名开始：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We again use the generic `ActionCreator` type, but this time it contains more
    than just the action interface that will eventually be returned. This is because
    this particular action is asynchronous.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用泛型`ActionCreator`类型，但这次它包含的不仅仅是最终返回的动作接口。这是因为这个特定的动作是异步的。
- en: 'We use `ThunkAction` inside `ActionCreator` for asynchronous actions, which
    is, in turn, a generic type with four parameters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ActionCreator`中使用`ThunkAction`进行异步操作，这是一个具有四个参数的泛型类型：
- en: The first parameter is the return type, which should ideally be `Promise<IProductsGetAllAction>`.
    However, the TypeScript compiler struggles to resolve this, so, we have opted
    for the slightly looser `Promise<AnyAction>` type.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是返回类型，理想情况下应该是`Promise<IProductsGetAllAction>`。但是，TypeScript编译器很难解析这一点，因此我们选择了稍微宽松一些的`Promise<AnyAction>`类型。
- en: The second parameter is the state interface that the action is concerned with.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是动作所关注的状态接口。
- en: The third parameter is the type of parameter passed into the action creator,
    which is `null` in our case because there is no parameter.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是传递给动作创建者的参数类型，在我们的情况下是`null`，因为没有参数。
- en: The last parameter is the type of the action.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是动作的类型。
- en: We export this action creator because this is going to be eventually called
    from the `ProductsPage` component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出此动作创建者，因为最终将从`ProductsPage`组件中调用它。
- en: 'Asynchronous actions need to return an asynchronous function that will eventually
    dispatch our action:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步动作需要返回一个最终会分派我们的动作的异步函数：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, the first thing that function does is return another function, flagging
    that it is asynchronous, using the `async` keyword. The inner function takes the
    dispatcher from the store as a parameter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该函数的第一件事是返回另一个函数，使用`async`关键字标记为异步。内部函数将调度程序从存储中作为参数。
- en: 'Let''s implement the inner function then:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现内部函数：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do is dispatch our other action so that the loading state
    is eventually changed accordingly by the reducer
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先要做的是分派另一个动作，以便加载状态最终由reducer相应地更改
- en: The next step is to get the products asynchronously from the fake API
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步是从虚拟API异步获取产品
- en: The final step is to dispatch the required action
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是分派所需的动作
- en: Now that we have created a couple of actions, we'll create a reducer in the
    next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些动作，我们将在下一节中创建一个reducer。
- en: Creating reducers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建reducer
- en: A reducer is a function that is responsible for creating new state for a given
    action. So, the function takes in an action with the current state and returns
    the new state. In this section, we'll create a reducer for the two actions we
    have created on products.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer是一个负责为给定动作创建新状态的函数。因此，该函数接受当前状态的动作，并返回新状态。在本节中，我们将为产品创建两个动作的reducer。
- en: 'Let''s start by creating a file called `ProductsReducer.ts` with the following
    import statements:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`ProductsReducer.ts`的文件开始，其中包含以下导入语句：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are importing the `Reducer` type from Redux along with types for the actions
    and state we created earlier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Redux中导入`Reducer`类型以及我们之前创建的动作和状态的类型。
- en: 'Next, we need to define what the initial state is:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义初始状态是什么：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, we are setting the products to an empty array and product loading state
    to `false`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将产品设置为空数组，并将产品加载状态设置为`false`。
- en: 'We can now start to create the reducer function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以开始创建reducer函数：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've typed the function with the `Reducer` generic type from Redux, passing
    in our state and action types. This gives us a nice level of type safety.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Redux的`Reducer`泛型类型对函数进行了类型化，传入了我们的状态和动作类型。这为我们提供了很好的类型安全性。
- en: The function takes in parameters for the state and action as required by Redux.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数根据Redux所需的状态和动作参数。
- en: The state defaults to the initial state object we just set in the previous step.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态默认为我们在上一步中设置的初始状态对象。
- en: At the end of the function, we return the default state if the action type is
    not recognized by the switch statement.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数的最后，如果动作类型在switch语句中没有被识别，我们将返回默认状态。
- en: 'Let''s carry on implementing our reducer:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续实现我们的reducer：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have implemented a switch branch for each action. Both branches follow the
    same pattern by returning a new state object that has the old state spread into
    it and the appropriate properties merged over the top.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个action实现了一个switch分支。两个分支都遵循相同的模式，通过返回一个新的状态对象，其中包含旧状态并合并了适当的属性。
- en: So, that's our first reducer complete. In the next section, we'll create our
    store.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个reducer完成。在下一节中，我们将创建我们的store。
- en: Creating a store
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个store
- en: 'In this section, we''ll create a store that is going to hold our state and
    manage the actions and reducer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个store，用于保存我们的状态并管理动作和reducer：
- en: 'Let''s start off by creating a new file called `Store.tsx` with the following
    import statement to get the bits and pieces we need from Redux:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`Store.tsx`的新文件，并使用以下导入语句从Redux中获取我们需要的部分：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`createStore` is a function we''ll eventually use to create our store'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createStore`是一个我们最终将用来创建我们的store的函数'
- en: We need the `applyMiddleware` function because we need to use the Redux Thunk
    middleware to manage our asynchronous actions
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要`applyMiddleware`函数，因为我们需要使用Redux Thunk中间件来管理我们的异步动作
- en: The `combineReducers` function is a function we can use to merge our reducers
    together
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineReducers`函数是一个我们可以用来合并我们的reducers的函数'
- en: '`Store` is a TypeScript type we can use for the store'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`是一个我们可以用于store的TypeScript类型'
- en: 'Let''s import `redux-thunk`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入`redux-thunk`：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, let''s import our reducer and state type:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们导入我们的reducer和状态类型：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A key part of the store is the state. So, let''s define an interface for this:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: store的一个关键部分是状态。因此，让我们为此定义一个接口：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, the interface simply contains our products state.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，接口只包含了我们的产品状态。
- en: 'Let''s put our reducer in the Redux `combineReducer` function now:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们把我们的reducer放到Redux的`combineReducer`函数中：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the state and root reducer defined, we can create our store. We are actually
    going to create a function that creates the store:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了状态和根reducer定义，我们可以创建我们的store。实际上，我们要创建一个创建store的函数：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The function that creates our store is called `configureStore` and returns the
    generic `Store` type with our specific store state passed in to it.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的store的函数被称为`configureStore`，并返回具有特定store状态的通用`Store`类型。
- en: The function uses the Redux `createStore` function to create and return the
    store. We pass in our reducer as well as the Redux Thunk middleware. We pass `undefined`
    as the initial state because our reducer takes care of the initial state.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数使用Redux的`createStore`函数来创建并返回store。我们传入我们的reducer以及Redux Thunk中间件。我们将`undefined`作为初始状态，因为我们的reducer会处理初始状态。
- en: We've made a great start on our store. In the next section, we'll start to connect
    our React shop to our store.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的store上取得了很好的进展。在下一节中，我们将开始连接我们的React商店到我们的store。
- en: Connecting our React app to the store
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的React应用连接到store。
- en: In this section, we'll connect the `Products` page to our store. The first job
    is to add the React Redux `Provider` component which we'll do in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将连接`Products`页面到我们的store。第一步是添加React Redux的`Provider`组件，我们将在下一节中完成。
- en: Adding the store Provider component
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加store Provider组件
- en: 'The `Provider` component can pass the store to components beneath it at any
    level. So, in this section we are going to add `Provider` right at the top of
    our component hierarchy so that all our components can access it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Provider`组件可以将store传递给其下的任何级别的组件。因此，在本节中，我们将在组件层次结构的顶部添加`Provider`，以便所有我们的组件都可以访问它：'
- en: 'Let''s open our existing `index.tsx` and import the `Provider` component from
    React Redux:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开我们现有的`index.tsx`并从React Redux中导入`Provider`组件：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s also import the `Store` type from React Redux:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还从React Redux中导入`Store`类型：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The final thing we need to import is the following from our store:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从我们的商店中导入以下内容：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are then going to create a little function component after the import statements:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将在导入语句之后创建一个小的函数组件：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This `Root` component is going to be our new root element. It takes our store
    in as a prop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Root`组件将成为我们的新根元素。它将我们的商店作为一个prop。
- en: 'So, we need to include the old root element, `Routes`, in our new root component:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要在我们的新根组件中包含旧的根元素`Routes`：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There''s one more thing to add to this component, which is the `Provider` component
    from React Redux:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件还需要添加另一件事，那就是来自React Redux的`Provider`组件：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've placed `Provider` at the top of the component tree with our store passed
    into it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`Provider`放在了组件树的顶部，并将我们的商店传递给它。
- en: 'With our new root component complete, let''s change our root render function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成我们的新根组件后，让我们更改我们的根渲染函数：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We first create the store using our `configureStore` function and then pass
    this into our `Root` component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用我们的`configureStore`函数创建商店，然后将其传递给我们的`Root`组件。
- en: So, this is the first step in connecting our components to the store. In the
    next section, we'll complete this connection for our `ProductPage` component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是将我们的组件连接到商店的第一步。在下一节中，我们将完成对`ProductPage`组件的连接。
- en: Connecting components to the store
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将组件连接到商店
- en: We are getting close to seeing our enhanced shop in action. In this section,
    we will connect our store to several components.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将看到我们增强的商店在行动中。在本节中，我们将连接我们的商店到几个组件。
- en: Connecting ProductsPage to the store
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ProductsPage连接到商店
- en: The first component we are going to connect to the store is going to be the
    `ProductsPage` component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要连接到商店的第一个组件将是`ProductsPage`组件。
- en: 'Let''s open up `ProductsPage.tsx` and start to refactor it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`ProductsPage.tsx`并开始重构它：
- en: 'First, let''s import the `connect` function from React Redux:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从React Redux中导入`connect`函数：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We'll use the `connect` function at the end of this section to connect the `ProductsPage`
    component to the store.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节末尾使用`connect`函数将`ProductsPage`组件连接到商店。
- en: 'Let''s import the store state type and the `getProducts` action creator from
    our store:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们的商店中导入存储状态类型和`getProducts`动作创建者：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `ProductPage` component won''t contain any state now because this will
    be held in the Redux store. So, let''s start by removing the state interface,
    the static `getDerivedStateFromProps` method, as well as the constructor. The
    `ProductsPage` component should now have the following shape:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductPage`组件现在不会包含任何状态，因为这将保存在Redux存储中。因此，让我们首先删除状态接口、静态`getDerivedStateFromProps`方法，以及构造函数。`ProductsPage`组件现在应该具有以下形状：'
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The data is going to come from the store via props now. So, let''s refactor
    our props interface:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，数据将通过props从商店中获取。因此，让我们重构我们的props接口：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, we''ll get the following data passed from the store to our component:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从商店传递以下数据到我们的组件：
- en: The `getProducts` action creator
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getProducts`动作创建者'
- en: A flag called `loading` that indicates whether products are being fetched
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`loading`的标志，指示产品是否正在被获取
- en: The array of products
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品数组
- en: 'So, let''s adjust the `componentDidMount` life cycle method to invoke the `getProducts`
    action creator to start the process of products being fetched:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们调整`componentDidMount`生命周期方法，以调用`getProducts`动作创建者来开始获取产品的过程：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We no longer reference the `products` array directly from `ProductsData.ts`.
    So, let''s remove that from the input statement so that it looks as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再直接引用`ProductsData.ts`中的`products`数组。因此，让我们从输入语句中删除它，使其如下所示：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There is still no sign of the `search` state we used to have. We are just going
    to pick this up at the start of the `render` method now and not store it in state
    at all:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然看不到我们以前使用的`search`状态。现在我们将在`render`方法开始时获取它，而不是在状态中存储它：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s stay in the `render` method and replace the old `state` references:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们留在`render`方法中，替换旧的`state`引用：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Under the class, but before the export statement, let''s create a function
    that will map the state coming from the store to the component props:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类下面，但在导出语句之前，让我们创建一个函数，将来自存储的状态映射到组件属性：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, we are getting whether products are being loaded as well as the products
    from the store and passing these to our props.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在获取产品是否正在加载以及从存储中获取这些产品并将它们传递给我们的props。
- en: 'There is one more prop we need to map to and that is the `getProducts` function
    prop. Let''s create another function that will map this action from the store
    to this function prop in the component:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要映射到另一个prop，那就是`getProducts`函数prop。让我们创建另一个函数，将这个操作从存储映射到组件中的函数prop：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There''s one more job to do at the bottom of the file. This is to wrap the
    React Redux `connect` HOC around our `ProductsPage` component before it is exported:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部还有一项工作要做。这是在导出之前，将React Redux的`connect` HOC包装在我们的`ProductsPage`组件周围：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `connect` HOC connects the component to our store, which is provided to
    us by the `Provider` component higher up in the component tree. The `connect`
    HOC also invokes the mapper functions that map the state and action creators from
    the store into the component props.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` HOC将组件连接到我们的存储，这是由组件树中更高级别的`Provider`组件提供给我们的。`connect` HOC还调用映射函数，将存储中的状态和操作创建者映射到组件属性中。'
- en: 'It''s finally time to give our enhanced page a try. Let''s start the dev server
    and the app via the terminal:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在终于是时候尝试我们增强的页面了。让我们通过终端启动开发服务器和应用程序：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We should find the page behaves exactly the same as it did before. The only
    difference is now the state is being managed in our Redux store.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该发现页面的行为与以前完全相同。唯一的区别是现在状态是在我们的Redux存储中管理的。
- en: In the next section, we are going enhance our Products page by adding the loading
    spinner we already have in our project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过添加我们项目中已经拥有的加载旋转器来增强我们的产品页面。
- en: Connecting ProductsPage to the loading store state
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ProductsPage连接到加载存储状态。
- en: 'In this section, we are going to add a loading spinner to the Products page. Before
    we can do this, we are going to extract the list of products out into its own
    component. We can then add the `withLoader` HOC to the extracted component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向产品页面添加一个加载旋转器。在此之前，我们将把产品列表提取到自己的组件中。然后我们可以将`withLoader` HOC添加到提取的组件中：
- en: 'Let''s create a new file for the extracted component called `ProductsList.tsx`
    with the following imports:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为提取的组件创建一个名为`ProductsList.tsx`的新文件，并导入以下内容：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The component will take in props for the products array and the search string:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该组件将接受产品数组和搜索字符串的props：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll call the component `ProductList` and it will be an SFC. Let''s start
    to create the component:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将称该组件为`ProductList`，它将是一个SFC。让我们开始创建组件：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can now move the `ul` tag from the `ProductsPage` component JSX into our
    return statement in our new `ProductList` component:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将`ProductsPage`组件JSX中的`ul`标签移动到我们新的`ProductList`组件的返回语句中：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that we remove references to `this` after moving the JSX.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在移动JSX后，我们会删除对`this`的引用。
- en: 'To finish off the `ProductList` component, let''s export it wrapped with our
    `withLoader` HOC:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`ProductList`组件后，让我们将其导出并使用我们的`withLoader`HOC包装：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s change the return statement in `ProductPage.tsx` to reference the extracted
    component:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更改`ProductPage.tsx`中的返回语句以引用提取的组件：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We mustn''t forget to import the `ProductsList` component having referenced
    it:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不要忘记引入已引用的`ProductsList`组件：
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, we can remove the imported `Link` component in `ProductsPage.tsx` as
    this is no longer referenced.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在`ProductsPage.tsx`中删除导入的`Link`组件，因为它不再被引用。
- en: 'If we go to the running app and browse to the Products page, we should now
    see a loading spinner while the products load:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到正在运行的应用程序并浏览到产品页面，我们现在应该看到产品加载时的加载旋转器：
- en: '![](assets/85661d16-f25f-49f0-a37c-ba5ffde733ba.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85661d16-f25f-49f0-a37c-ba5ffde733ba.png)'
- en: So, our Products page is nicely wired up to our Redux store now. In the next
    section, we'll wire up the Product page to the store.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的产品页面现在已经很好地连接到了Redux存储。在下一节中，我们将把产品页面连接到存储。
- en: Adding product state and actions to the store
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将产品状态和操作添加到存储
- en: 'Connecting the `ProductPage` component to our store is first going to require
    a little work in our store. We need additional state for the current product,
    as well as whether it has been added to the basket. We also need additional actions
    and reducer code to get a product and add it to the basket:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ProductPage`组件连接到我们的存储首先需要在我们的存储中进行一些工作。我们需要额外的状态来存储当前产品，以及它是否已添加到购物篮中。我们还需要额外的操作和减速器代码来获取产品并将其添加到购物篮中：
- en: 'First, let''s add additional state for the current product in `ProductsTypes.ts`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`ProductsTypes.ts`中为当前产品添加额外的状态：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'While we are in `ProductTypes.ts`, let''s add the action type for getting a
    product:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在`ProductTypes.ts`中时，让我们添加获取产品的操作类型：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s also add the action type for getting a product:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为获取产品添加操作类型：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can then add this action type to our union actions type:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将此操作类型添加到我们的联合操作类型中：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s move on to creating the new action creator in `ProductsActions.ts`.
    First, let''s import our fake API to get a product:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续在`ProductsActions.ts`中创建新的操作创建者。首先，让我们导入我们的虚假API以获取产品：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can then import the type for the action creator we need to implement:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以导入我们需要实现的操作创建者的类型：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s implement the action creator for getting a product:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现获取产品的操作创建者：
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is very similar to the `getProducts` action creator. The only difference
    in structure is that the action creator takes in a parameter for the product ID.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`getProducts`操作创建者非常相似。结构上唯一的区别是操作创建者接受产品ID的参数。
- en: 'Move on to the reducer now in `ProductsReducer.ts`. Let''s first set the current
    product to null in the initial state:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`ProductsReducer.ts`中的减速器。首先在初始状态中将当前产品设置为null：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `productReducer` function, let''s add a branch in the switch statement
    for our new action type:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`productReducer`函数中，让我们为我们的新操作类型在switch语句中添加一个分支：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We spread the old state into a new object, overwrite the current project, and
    set the loading state to `false`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旧状态扩展到一个新对象中，覆盖当前项目，并将加载状态设置为`false`。
- en: So, that's some of the state management that the Product page needs in the Redux
    store. However, we aren't managing the basket yet in our store. We'll do this
    in the next section.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是产品页面在Redux存储中需要的一些状态管理。但是，我们还没有在我们的存储中管理购物篮。我们将在下一节中完成这一点。
- en: Adding basket state and actions to the store
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将购物篮状态和操作添加到存储中
- en: We'll add state management for our basket in this section. We'll create a new
    section in our store for this.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为我们的购物篮添加状态管理。我们将在我们的存储中创建一个新的部分。
- en: 'First, let''s create a new file for the types called `BasketTypes.ts` with
    the following content:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`BasketTypes.ts`的类型的新文件，内容如下：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There is only one piece of state in our basket and that's an array of products
    in the basket.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的购物篮中只有一个状态，那就是购物篮中产品的数组。
- en: There is only one action as well. This is to add a product to the basket.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样也只有一个动作。这是将产品添加到购物篮中。
- en: 'Let''s create a file called `BasketActions.ts` with the following content:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`BasketActions.ts`的文件，内容如下：
- en: '[PRE70]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is the action creator for adding to the basket. The function takes in a
    product and returns it in the action with the appropriate action type.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于添加到购物篮的动作创建者。该函数接受一个产品，并在具有适当动作类型的动作中返回它。
- en: 'On to the reducer now. Let''s create a file called `BasketReducer.ts` with
    the following import statements:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在到了减速器。让我们创建一个名为`BasketReducer.ts`的文件，其中包含以下导入语句：
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s create an object for the initial basket state:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为初始购物篮状态创建一个对象：
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s create the reducer now:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建减速器：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This follows the same pattern as `productsReducer`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循与`productsReducer`相同的模式。
- en: One interesting point to note is how we elegantly add the `product` to the `products`
    array without mutating the original array. We use the JavaScript `concat` function,
    which creates a new array by merging the original with the parameter passed in.
    This is a great function to use in reducers where state changes involve adding
    items to arrays.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的地方要注意的是，我们如何优雅地将`product`添加到`products`数组中，而不会改变原始数组。我们使用JavaScript的`concat`函数，它通过将原始数组与传入的参数合并来创建一个新数组。这是在减速器中使用的一个很好的函数，其中状态变化涉及向数组添加项目。
- en: 'Let''s open up `Store.ts` now and import the new reducer and state for the
    basket:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开`Store.ts`并导入购物篮的新减速器和状态：
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s add the basket state to the store:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将购物篮状态添加到存储中：
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We have two reducers now. So, let''s add the basket reducer to the `combineReducers`
    function call:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有两个减速器。因此，让我们将购物篮减速器添加到`combineReducers`函数调用中：
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now that we've adjusted our store, we can connect our `ProductPage` component
    to it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调整了我们的存储，我们可以将我们的`ProductPage`组件连接到它。
- en: Connecting ProductPage to the store
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ProductPage连接到存储
- en: 'In this section, we''ll connect the `ProductPage` component to our store:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将把`ProductPage`组件连接到我们的存储中：
- en: 'Let''s first import the following into `ProductPage.tsx`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将以下内容导入到`ProductPage.tsx`中：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We are going to reference the store''s `getProduct` now and not the one from
    `ProductsData.ts`. So, let''s remove this from this import so that it looks like
    the following:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要引用存储的`getProduct`，而不是来自`ProductsData.ts`的产品。因此，让我们从此导入中删除它，使其看起来像以下内容：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, let''s move the state into props:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将状态移入属性：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: So, the `IState` interface and the `Props` type should be removed after this
    movement.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在此移动之后，应该删除`IState`接口和`Props`类型。
- en: We can remove the constructor as we don't need to initialize any state now.
    This is all done in the store.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以移除构造函数，因为我们现在不需要初始化任何状态。这一切都在存储中完成。
- en: 'Let''s change the `componentDidMount` life cycle method to call the action
    creator for getting the product:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`componentDidMount`生命周期方法更改为调用获取产品的动作创建者：
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Notice that we also remove the `async` keyword because the method is no longer
    asynchronous.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还移除了`async`关键字，因为该方法不再是异步的。
- en: 'Moving on to the `render` function, let''s replace the references to state
    with references to props:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续进行`render`函数，让我们将对状态的引用替换为对属性的引用：
- en: '[PRE82]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s look at the click handler now and refactor it to call the action creator
    for adding to the basket:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来看点击处理程序，并重构它以调用添加到购物篮的动作创建者：
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'On to the final few steps now in the connection process. Let''s implement the
    function that maps the action creators from the store into the component props:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进行连接过程的最后几个步骤。让我们实现将存储中的动作创建者映射到组件属性的函数：
- en: '[PRE84]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Mapping the state to the component props is a little more complex. Let''s start
    with the simple mappings:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将状态映射到组件prop有点复杂。让我们从简单的映射开始：
- en: '[PRE85]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note that we map a null `currentProduct` to `undefined`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将null的`currentProduct`映射到`undefined`。
- en: 'The remaining prop we need to map to is `added`. We need to check whether the
    current product in the store is in the basket state in order to set this `boolean`
    value. We can use the `some` function in the products array for this:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要映射的剩余prop是`added`。我们需要检查商店中的当前产品是否在购物篮状态中，以设置这个`boolean`值。我们可以使用产品数组中的`some`函数来实现这一点：
- en: '[PRE86]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The last step is to use the `connect` HOC from React Redux to wire the `ProductPage`
    component to the store:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用React Redux中的`connect` HOC将`ProductPage`组件连接到商店：
- en: '[PRE87]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We can now go to the running app, visit the product page, and add it to the
    basket. The Add to basket button should disappear after it is clicked. If we browse
    to a different product and then come back to a product we've already added to
    the basket, the Add to basket button shouldn't be present.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入运行的应用程序，访问产品页面，并将其添加到购物篮中。点击“添加到购物篮”按钮后，该按钮应该消失。如果我们浏览到另一个产品，然后回到我们已经添加到购物篮中的产品，那么“添加到购物篮”按钮就不应该出现。
- en: So, we now have both the Products and Product pages connected to our Redux store.
    In the next section, we'll create a basket summary component and connect that
    to the store.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们的产品和产品页面都连接到了Redux商店。在下一节中，我们将创建一个购物篮摘要组件并将其连接到商店。
- en: Creating and connecting BasketSummary to the store
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并连接BasketSummary到商店
- en: 'In this section, we''ll create a new component called `BasketSummary`. This
    will show the number of items in the basket and will be located in the top right
    of our shop. The following screenshot shows what the basket summary will look
    like in the top right of the screen:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个名为`BasketSummary`的新组件。这将显示购物篮中的物品数量，并位于我们商店的右上角。以下截图显示了购物篮摘要将在屏幕右上角的样子：
- en: '![](assets/a46b9de9-0cd5-4ef5-aa49-42bd4cb7ebde.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a46b9de9-0cd5-4ef5-aa49-42bd4cb7ebde.png)'
- en: 'Let''s create a file called `BasketSummary.tsx` with the following content:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`BasketSummary.tsx`的文件，内容如下：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is a simple component that takes in the number of products in the basket
    as a prop and displays this value in a `div` styled with a `basket-summary` CSS
    class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的组件，它以一个prop的形式接收购物篮中产品的数量，并在一个带有`basket-summary` CSS类的`div`中显示这个值。
- en: 'Let''s add the CSS class we have just referenced in `index.css`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`index.css`中添加我们刚刚引用的CSS类：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We''re going to add our basket summary to our header component. So, let''s
    import it into `Header.tsx`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把我们的购物篮摘要添加到我们的页眉组件中。所以，让我们把它导入到`Header.tsx`中：
- en: '[PRE90]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let''s also import the `connect` function from React Redux:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也从React Redux中导入`connect`函数：
- en: '[PRE91]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s import the state type for our store as well:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也导入我们商店的状态类型：
- en: '[PRE92]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Add a prop for the number of products in the basket to the `Header` component:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Header`组件添加一个购物篮中产品数量的prop：
- en: '[PRE93]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We're going to keep the search state local in this component.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个组件中保持搜索状态为本地。
- en: 'Let''s add the `BasketSummary` component to the `Header` component JSX now:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`BasketSummary`组件添加到`Header`组件的JSX中：
- en: '[PRE94]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The next step is to map the number of products in the store basket to the `basketCount`
    prop:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将商店购物篮中的产品数量映射到`basketCount` prop：
- en: '[PRE95]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Lastly, we can connect the `Header` component to the store:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将`Header`组件连接到商店：
- en: '[PRE96]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now that the `Header` component is consuming the `BasketSummary` component and
    is also connected to the store, we should be able to add products to the basket
    in the running app and see the basket summary increase.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Header`组件正在使用`BasketSummary`组件，并且也连接到商店，我们应该能够在运行的应用程序中添加产品到购物篮并看到购物篮摘要增加。
- en: So, that completes this section on connecting components to the store. We have
    connected a few different components to the store, so hopefully this process is
    making good sense now.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，这一部分关于将组件连接到商店的内容就完成了。我们已经将一些不同的组件连接到了商店，所以希望这个过程现在很清晰。
- en: In the next section, we'll explore a Redux-like approach for managing state
    within a component.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种类似Redux的方法来管理组件内的状态。
- en: Managing state with useReducer
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用useReducer管理状态
- en: Redux is great for managing complex state across our app. It is a little heavy
    though if the state we are managing only exists within a single component. Obviously,
    we can manage these cases with `setState` (for class components) or `useState`
    (for function components). However, what if the state is complex? There may be
    lots of pieces of state and the state interactions may involve lots of steps with
    some of them being asynchronous. In this section, we'll explore an approach for
    managing these cases with the `useReducer` function in React. Our example will
    be contrived and simple but it will give us an understanding of this approach.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Redux非常适合管理应用程序中的复杂状态。但是，如果我们要管理的状态只存在于单个组件中，那么它可能会有点重。显然，我们可以使用`setState`（对于类组件）或`useState`（对于函数组件）来管理这些情况。但是，如果状态很复杂怎么办？可能会有很多状态片段，状态交互可能涉及很多步骤，其中一些是异步的。在本节中，我们将探讨使用React中的`useReducer`函数来管理这些情况的方法。我们的示例将是人为的和简单的，但它将让我们了解这种方法。
- en: 'We are going to add a Like button to the Product page in our React shop. Users
    will be able to like a product several times. The `Product` component will keep
    track of the number of likes and the date and time of the last like in its state:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的React商店的产品页面上添加一个喜欢按钮。用户可以多次喜欢一个产品。`Product`组件将跟踪喜欢的数量以及最后一次喜欢的日期和时间：
- en: '![](assets/0a921b6d-3941-43a9-b25c-d14769e8a086.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a921b6d-3941-43a9-b25c-d14769e8a086.png)'
- en: 'We''ll start by opening `Product.tsx` and creating an interface, before the
    `Product` component, for our state, containing the number of likes and the date
    of the last like:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先打开`Product.tsx`并在`Product`组件之前创建一个接口，用于我们的状态，包含喜欢的数量和最后一次喜欢的日期：
- en: '[PRE97]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We''ll create a variable to hold the initial state, also outside of `Product`:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个变量来保存初始状态，也在`Product`之外：
- en: '[PRE98]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s now create a type for the action:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为这个动作创建一个类型：
- en: '[PRE99]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We''ll also create a union type containing all the action types. In our example,
    we only have one action type but let''s do this to understand an approach that
    scales:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个包含所有动作类型的联合类型。在我们的示例中，我们只有一个动作类型，但让我们这样做以了解一个可扩展的方法：
- en: '[PRE100]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Inside the `Product` component, let''s call the `useReducer` function in React
    to get our state and `dispatch` function:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Product`组件内部，让我们在React中调用`useReducer`函数来获取我们的状态和`dispatch`函数：
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Let''s break this down:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: We pass into `useReducer` a function called `reducer` (which we haven't created
    yet).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递给`useReducer`一个名为`reducer`的函数（我们还没有创建）。
- en: We also pass into `useReducer` our initial state.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将我们的初始状态传递给`useReducer`。
- en: '`useReducer` returns an array containing two elements. The first element is
    the current state and the second is a `dispatch` function to invoke an action.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer`返回一个包含两个元素的数组。第一个元素是当前状态，第二个是一个`dispatch`函数来调用一个动作。'
- en: 'Let''s refactor this line and destructure the state so that we can reference
    the pieces of state directly:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重构这一行并解构状态，以便我们可以直接引用状态的片段：
- en: '[PRE102]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'At the bottom of the JSX in the `Product` component, let''s add JSX to render
    how many likes we have and a button to add likes:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Product`组件的JSX底部，让我们添加JSX来渲染我们有多少个喜欢和一个按钮来添加喜欢：
- en: '[PRE103]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s add the `like-container` CSS class we have just referenced into `index.css`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将刚刚引用的`like-container` CSS类添加到`index.css`中：
- en: '[PRE104]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let''s also implement the click handler on the Like button:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也在Like按钮上实现点击处理程序：
- en: '[PRE105]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Our last task is to implement the reducer function outside the `Product` component,
    just under the `LikeActions` type:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后任务是在`Product`组件之外实现reducer函数，在`LikeActions`类型的下面：
- en: '[PRE106]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If we try this out, we'll initially see a Like button after we navigate to the Product
    page. If we click it, the button text turns to Like again and a piece of text
    appears above it indicating how many likes there are and the last time it was
    liked.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试这样做，我们将在导航到产品页面后最初看到一个Like按钮。如果我们点击它，按钮文本会变成Like，上面会出现一段文字，指示有多少个赞和上次点赞的时间。
- en: This implementation feels very similar to implementing actions and reducers
    in a Redux store but this is all within a component. This is overkill for the
    example we have just been through but could prove useful where we need to manage
    lots more pieces of state.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现感觉非常类似于在Redux存储中实现操作和reducers，但这都是在一个组件内部。对于我们刚刚经历过的例子来说，这有点过度，但在我们需要管理更多状态片段的情况下可能会很有用。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started the chapter by introducing ourselves to Redux, learning the principles
    and key concepts. We learned that the state is stored in a single object and changed
    by pure functions called reducers when actions are dispatched.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时介绍了Redux，学习了其原则和关键概念。我们了解到状态存储在一个单一对象中，并在分发action时通过称为reducers的纯函数进行更改。
- en: 'We created our own store in our React shop to put the theory into practice.
    Here are some key points we learned in our implementation:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的React商店中创建了自己的store来将理论付诸实践。以下是我们在实现中学到的一些关键点：
- en: Enumerations for action types give us nice IntelliSense when referencing them.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为action类型创建枚举在引用它们时给我们提供了很好的智能感知。
- en: Using interfaces to define the actions gives a nice level of type safety and
    allows us to create a union type that a reducer can use for the actions it has
    to deal with.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口定义actions可以提供很好的类型安全性，并允许我们创建一个reducer可以用于处理的actions的联合类型。
- en: Using read-only properties within the state interface helps us avoid mutating
    the state directly.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态接口中使用只读属性可以帮助我们避免直接改变状态。
- en: Synchronous action creators simply return the required action object.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步action创建者只是简单地返回所需的action对象。
- en: Asynchronous action creators return a function that eventually returns the action
    object.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步action创建者返回一个最终返回action对象的函数。
- en: The reducer contains a branch of logic for each action type it deals with, creating
    new state by spreading old state into a new object and then overwriting it with
    changed properties.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer包含了它处理的每种action类型的逻辑分支，通过将旧状态扩展到一个新对象中，然后用更改后的属性覆盖它来创建新状态。
- en: A function called `createStore` from Redux creates the actual store. We pass
    all our reducers merged together along with Redux Thunk middleware to manage asynchronous
    actions.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux的`createStore`函数创建了实际的store。我们将所有的reducer合并在一起，还有Redux Thunk中间件来管理异步操作。
- en: 'We then connected some components to the store. Here are the key points in
    this process:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将一些组件连接到了store。以下是这个过程中的关键点：
- en: A `Provider` component from React Redux needs to sit above all the components
    that want to consume the store. This takes in a prop that contains the store.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自React Redux的`Provider`组件需要位于所有想要使用store的组件之上。它接收一个包含store的prop。
- en: A `connect` HOC from React Redux then wires up the individual components to
    the store. This takes in two parameters than can be used to map the state and
    action creators to the component props.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，来自React Redux的`connect`高阶组件将单独的组件连接到store。它接收两个参数，可以用于将状态和action创建者映射到组件props。
- en: There are lots of bits and pieces to get our heads around when implementing
    Redux within our React apps. It does shine in scenarios where the state management
    is complex because Redux forces us to break the logic up into separate pieces
    that are easy to understand and maintain.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的React应用程序中实现Redux时，有很多要理解的细节。因为Redux强制我们将逻辑分解成易于理解和维护的单独部分，所以在状态管理复杂的情况下，Redux会发挥作用。
- en: We learned that we can use a Redux-like approach within just a single component
    by leveraging React's `useReducer` function. This can be used when the state is
    complex and just exists in a single component.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到，我们可以利用React的`useReducer`函数在单个组件中使用类似Redux的方法。当状态复杂且仅存在于单个组件中时，可以使用这种方法。
- en: One task that Redux actions often do is interact with a REST API. We are going
    to learn how we can interact with REST APIs in both class- and function-based
    components in the next chapter. We'll also learn about a native function we use
    to call to a REST API as well as a popular open source library.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Redux动作经常要做的一个任务是与REST API交互。在下一章中，我们将学习如何在基于类和基于函数的组件中与REST API交互。我们还将了解一个我们用来调用REST
    API的本地函数，以及一个流行的开源库。
- en: Questions
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Before we end this chapter, let''s test our knowledge with some questions:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们用一些问题来测试我们的知识：
- en: Is the `type` property in action objects required, and does this property need
    to be called type? Can we call it something else?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: action对象中的`type`属性是必需的吗？这个属性需要被称为type吗？我们可以称其为其他名称吗？
- en: How many properties can the action object contain?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: action对象可以包含多少个属性？
- en: What is an action creator?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是action creator？
- en: Why did we need Redux Thunk in our Redux store in our React shop app?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在React商店应用程序中的Redux存储中需要Redux Thunk？
- en: Could we have used something else other than Redux Thunk?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了Redux Thunk，我们还能用其他东西吗？
- en: In our `basketReducer` we have just implemented, why didn't we just use the
    `push` function to add the item to the basket state? That is, what is wrong with
    the highlighted line?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们刚刚实现的`basketReducer`中，为什么我们不直接使用`push`函数将项目添加到购物篮状态中？也就是说，高亮显示的行有什么问题？
- en: '[PRE107]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Further reading
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links are good resources of further information on React Redux:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是关于React Redux的更多信息的好资源：
- en: The Redux online docs are well worth reading at [https://redux.js.org](https://redux.js.org).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux在线文档非常值得阅读，网址是[https://redux.js.org](https://redux.js.org)。
- en: In addition to these core Redux docs, the React Redux docs are worth looking
    at as well. These are at [https://react-redux.js.org/](https://react-redux.js.org/).
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了这些核心Redux文档外，React Redux文档也值得一看。这些文档位于[https://react-redux.js.org/](https://react-redux.js.org/)。
- en: The Redux Thunk GitHub is at [https://github.com/reduxjs/redux-thunk](https://github.com/reduxjs/redux-thunk).
    The home page contains some useful information and samples.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Thunk GitHub位于[https://github.com/reduxjs/redux-thunk](https://github.com/reduxjs/redux-thunk)。主页包含一些有用的信息和示例。
