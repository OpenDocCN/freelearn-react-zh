- en: Following Best Practices and Developing MERN Further
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循最佳实践并进一步开发MERN
- en: In this chapter, we elaborate on some of the best practices applied while building
    the four MERN applications in this book, along with other practices not applied
    in this book, but that should be considered for real-world applications to ensure
    reliability and scalability as complexity grows. Finally, we wrap up with suggestions
    on enhancing, and steps for extending the applications built.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细阐述了在构建本书中的四个MERN应用程序时应用的一些最佳实践，以及本书中未应用的其他实践，但应考虑用于真实世界的应用程序，以确保可靠性和可扩展性随着复杂性的增长。最后，我们提出了增强和扩展构建的应用程序的建议和步骤。
- en: 'The topics covered in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Separation of concerns with modularity in the app structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序结构中的模块化关注点分离
- en: Considering the options for CSS styling solutions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑CSS样式解决方案的选项
- en: Server-side rendering with data for selected views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为选定视图提供数据的服务器端渲染
- en: Using ES6 class for stateful vs purely functional components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ES6类来区分有状态和纯函数组件
- en: Deciding on using Redux or Flux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用Redux还是Flux
- en: Security enhancements for storing user credentials
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储用户凭据的安全增强功能
- en: Writing test code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试代码
- en: Optimizing bundle size
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化捆绑大小
- en: How to add new features to existing applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向现有应用程序添加新功能
- en: Separation of concerns with modularity
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化的关注点分离
- en: While building out the MERN stack applications, we followed a common folder
    structure across each application, which divided and grouped the code based on
    relevance and common functionality. The idea behind creating these smaller and
    distinct sections in the code is to make sure each section addresses a separate
    concern, so individual sections can be reused, as well as developed and updated
    independently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建MERN堆栈应用程序时，我们遵循了每个应用程序中的常见文件夹结构，根据相关性和常见功能划分和分组了代码。在创建代码中的这些较小和独特的部分的背后思想是确保每个部分都解决了一个单独的问题，因此可以重复使用每个部分，以及独立开发和更新。
- en: Revisiting the application folder structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视应用程序文件夹结构
- en: 'More specifically, in the application folder structure, we kept the client-side
    and server-side code separate with further subdivisions within these two sections.
    This gave us some freedom to design and build the frontend and backend of the
    application independently:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在应用程序文件夹结构中，我们将客户端和服务器端代码分开，并在这两个部分内进一步划分。这使我们可以自由设计和独立构建应用程序的前端和后端：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `client` and `server` sections, we divided the code further into subfolders
    that mapped to unique functionalities, such as models, controllers, and routes
    in the server to a specific feature, such as grouping all components related to
    a user on the client side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client`和`server`部分，我们进一步将代码划分为子文件夹，这些子文件夹映射到唯一的功能，例如在服务器端的模型、控制器和路由，以及在客户端将所有与用户相关的组件分组。
- en: Server-side code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端代码
- en: 'On the server side, we divided the code according to functionality by separating
    code that defines business models from code implementing routing logic and code
    that responds to client requests at these routes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们根据功能将代码分开，通过将定义业务模型的代码与实现路由逻辑的代码以及在这些路由上响应客户端请求的代码分开：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this structure, each folder contains code with a specific purpose:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构中，每个文件夹都包含具有特定目的的代码：
- en: '**models**: This folder is meant to contain all the Mongoose schema model definitions
    in separate files, each file representing a single model.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：该文件夹旨在包含所有Mongoose模式模型定义的单独文件，每个文件代表一个单独的模型。'
- en: '**routes**: This folder contains all routes that allow the client to interact
    with the server - placed in separate files where each file may be associated with
    a model in the models folder.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**routes**：此文件夹包含允许客户端与服务器交互的所有路由 - 放在单独的文件中，其中每个文件可能与模型文件夹中的模型相关联。'
- en: '**controllers**: This contains all the controller functions that define logic
    to respond to incoming requests at the defined routes, divided into separate files
    corresponding to relevant model and route files.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**controllers**：包含定义逻辑以响应定义路由的传入请求的所有控制器函数，分成相应的模型和路由文件。'
- en: As demonstrated throughout the book, these specific separations of concerns
    for the code on the server side allowed us to extend the server developed for
    the skeleton application by just adding the required model, route, and controller
    files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中所示，服务器端代码的这些特定关注点的分离使我们能够通过添加所需的模型、路由和控制器文件来扩展骨架应用程序开发的服务器。
- en: Client-side code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端代码
- en: 'The client-side code for the MERN applications consist primarily of React components.
    In order to organize the component code and related helper code in a reasonable
    and understandable manner, we separated the code into folders related to a feature
    entity or unique functionality:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MERN应用程序的客户端代码主要由React组件组成。为了以合理和可理解的方式组织组件代码和相关的辅助代码，我们将代码分成与功能实体或独特功能相关的文件夹：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding structure, we placed all the auth-related components and helper
    code in the `auth` folder, common and basic components, such as the `Home` and `Menu`
    components, in the `core` folder, then we made `post` and `user` folders for all
    post-related or user-related components in the respective folders.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述结构中，我们将所有与认证相关的组件和辅助代码放在`auth`文件夹中，将常见和基本组件，如`Home`和`Menu`组件，放在`core`文件夹中，然后我们为所有与帖子或用户相关的组件在相应的文件夹中创建`post`和`user`文件夹。
- en: This separation and grouping of components based on features allowed us to extend
    the frontend views in the skeleton application for each application that followed,
    by adding a new feature-related component code folder, as required, to the client
    folder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于功能的组件的分离和分组使我们能够通过根据需要向客户端文件夹添加新的与功能相关的组件代码文件夹来扩展骨架应用程序的前端视图。
- en: In the final section of this chapter, we demonstrate further the advantages
    of this modularized approach of separating the application code, as we outline
    the general workflow that can be adopted to add a new feature to any of the existing
    applications developed in this book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们进一步展示了这种模块化方法分离应用程序代码的优势，同时概述了可以采用的一般工作流程，以向本书中开发的任何现有应用程序添加新功能。
- en: Adding CSS styles
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加CSS样式
- en: When discussing user interface implementations for the applications in this
    book, we chose not to focus on the details of the CSS styling code applied and
    relied mostly on the default Material-UI stylings. But given that implementing
    any user interface requires considering styling solutions, we will briefly look
    at some of the options available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论本书中应用程序的用户界面实现时，我们选择不专注于应用的CSS样式代码的细节，并主要依赖于默认的Material-UI样式。但是，考虑到实现任何用户界面都需要考虑样式解决方案，我们将简要介绍一些可用的选项。
- en: When it comes to adding CSS styles to the frontend, there are a number of options,
    each with pros and cons. In this section, we will discuss the two most common
    options, which are  external style sheets and inline styles, along with a newer
    approach of writing CSS in JavaScript, or more specifically JSS, which is used
    in Material-UI components and hence also for the applications in this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加CSS样式到前端时，有许多选项，每种都有其优缺点。在本节中，我们将讨论两种最常见的选项，即外部样式表和内联样式，以及在JavaScript中编写CSS的较新方法，或者更具体地说是JSS，它用于Material-UI组件，因此也用于本书中的应用程序。
- en: External style sheets
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部样式表
- en: External style sheets allow us to define CSS rules in separate files that can
    be injected into the necessary view. Placing CSS styles this way in external style
    sheets was once considered the better practice because it enforced the separation
    of style and content, allowing reusability and also maintaining modularity if
    a separate CSS file is created for each component.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 外部样式表允许我们在单独的文件中定义CSS规则，然后将其注入到必要的视图中。以这种方式在外部样式表中放置CSS样式曾经被认为是更好的做法，因为它强制执行了样式和内容的分离，允许重用，并且如果为每个组件创建单独的CSS文件，则还可以保持模块化。
- en: However, as web development technologies continue evolving, the demands of better
    CSS organization and performance are no longer met by this approach. For example,
    using external style sheets while developing frontend views with React components
    limits control over updating styles based on the component state. Moreover, loading
    external CSS for React applications requires additional Webpack configurations
    with `css-loader` and `style-loader`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Web开发技术的不断发展，对更好的CSS组织和性能的需求不再适用于这种方法。例如，在使用React组件开发前端视图时，使用外部样式表会限制根据组件状态更新样式的控制。此外，为React应用程序加载外部CSS需要额外的Webpack配置，包括`css-loader`和`style-loader`。
- en: When applications grow and share multiple style sheets, it also becomes impossible
    to avoid selector conflicts because CSS has a single global namespace. Hence,
    though external style sheets may be enough for simple and trivial applications,
    as an application grows, other options for using CSS become more relevant.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序增长并共享多个样式表时，也变得不可能避免选择器冲突，因为CSS具有单一的全局命名空间。因此，尽管外部样式表可能足够简单和琐碎的应用程序，但随着应用程序的增长，使用CSS的其他选项变得更加相关。
- en: Inline styles
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联样式
- en: Inline CSS is a style defined and applied directly to individual elements in
    the view. Though this takes care of some of the problems faced with external style
    sheets, such as eliminating the issue of selector conflicts and allowing state-dependent
    styles, it takes away reusability and introduces a few problems of its own, such
    as limiting the CSS features that can be applied.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS是直接定义和应用于视图中的单个元素的样式。虽然这解决了外部样式表面临的一些问题，比如消除选择器冲突的问题和允许状态相关样式，但它剥夺了可重用性，并引入了一些自己的问题，比如限制可以应用的CSS特性。
- en: Using only inline CSS for a React-based frontend has important limitations for
    growing applications, such as poor performance because all the inline styles are
    recomputed at each render, and inline styles are slower than class names to begin
    with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于React的前端，仅使用内联CSS存在重要的限制，例如性能不佳，因为所有内联样式在每次渲染时都会重新计算，并且内联样式本身比类名慢。
- en: Inline CSS may seem like an easy fix in some cases, but does not serve as a
    good option for overall usage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS在某些情况下可能看起来是一个简单的解决方案，但并不适合作为整体使用的好选择。
- en: JSS
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSS
- en: JSS allows us to write CSS styles using JavaScript in a declarative way. This
    also means all the features of JavaScript are now available for writing CSS, making
    it possible to write reusable and maintainable styling code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSS允许我们以声明方式使用JavaScript编写CSS样式。这也意味着现在可以使用JavaScript的所有功能来编写CSS，从而可以编写可重用和可维护的样式代码。
- en: JSS works as a JS to CSS compiler that takes JS objects, where keys represent
    class names, with values representing corresponding CSS rules, and then generates
    the CSS along with scoped class names.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JSS作为JS到CSS编译器工作，它接受JS对象，其中键表示类名，值表示相应的CSS规则，然后生成带有作用域类名的CSS。
- en: In this way, JSS generates unique class names by default when it compiles JSON
    representations to CSS, eliminating the chances of selector conflicts faced with
    external style sheets. Moreover, unlike inline styles, CSS rules defined with
    JSS can be shared across multiple elements and all CSS features can be used in
    the definitions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，JSS在将JSON表示编译为CSS时默认生成唯一的类名，消除了与外部样式表面临的选择器冲突的可能性。此外，与内联样式不同，使用JSS定义的CSS规则可以在多个元素之间共享，并且可以在定义中使用所有的CSS特性。
- en: Material-UI uses JSS to style its components, and as a result we used JSS to
    apply Material-UI themes and also custom CSS to the components developed for the
    frontend views in all the applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI使用JSS来为其组件设置样式，因此我们使用JSS来应用Material-UI主题，以及为所有应用程序中开发的前端视图的自定义CSS。
- en: Selective server-side rendering with data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有数据的选择性服务器端渲染
- en: When we developed the frontend of the base skeleton application in [Chapter
    4](e161ddf5-86d2-4511-a7df-558b512f46ed.xhtml), *Adding a React Frontend to Complete
    MERN*, we integrated basic server-side rendering to be able to load client-side
    routes directly from the browser address bar when the request goes to the server.
    In this SSR implementation, while rendering the React components server-side,
    we did not consider loading the data from the database for the components that
    displayed data. The data only loads in these components when the client-side JavaScript
    takes over after the initial load of the server-side rendered markup.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在[第4章](e161ddf5-86d2-4511-a7df-558b512f46ed.xhtml)中开发了基本骨架应用程序的前端时，*添加React前端以完成MERN*，我们集成了基本的服务器端渲染，以便在请求发送到服务器时能够直接从浏览器地址栏加载客户端路由。在这种SSR实现中，当在服务器端渲染React组件时，我们没有考虑为显示数据的组件加载来自数据库的数据。只有在服务器端渲染标记的初始加载后，客户端JavaScript接管后，这些组件才会加载数据。
- en: We did update this implementation to add server-side rendering with data for
    the individual media detail pages in the MERN Mediastream application discussed
    in [Chapter 9](3e7c6b91-643a-4af2-8b06-c5ae75356984.xhtml), *Customizing Media
    Player and Improve SEO*. In this case, we decided to render this specific view
    with data by injecting data into the server-side generated markup of the React
    frontend. The reasoning behind this selective server-side rendering with data
    only for specific views can be based on certain desired behaviors for the view
    in question.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实更新了这个实现，以在MERN Mediastream应用程序的个别媒体详细页面中添加带有数据的服务器端渲染，该应用程序在[第9章](3e7c6b91-643a-4af2-8b06-c5ae75356984.xhtml)中讨论了*自定义媒体播放器和改善SEO*。在这种情况下，我们决定通过将数据注入到React前端的服务器端生成标记中来呈现此特定视图。对于特定视图的选择性服务器端渲染与数据的推理可以基于对所讨论视图的某些期望行为。
- en: When is SSR with data relevant?
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么时候使用带有数据的SSR是相关的？
- en: 'Implementing server-side rendering with data for all the React views in an
    application can become complicated and additional work when it is necessary to
    consider views with client-side authentication or consisting of multiple data
    sources. In many cases, it may be unnecessary to tackle these complexities if
    the view does not require server-side rendering with data. In order to judge whether
    a view needs to be server-rendered with data, answer the following questions for
    the specific view to make your decision:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中为所有React视图实现具有数据的服务器端渲染可能会变得复杂，并且在需要考虑具有客户端身份验证或由多个数据源组成的视图时会增加额外的工作。在许多情况下，如果视图不需要服务器端渲染数据，则可能不必解决这些复杂性。为了判断视图是否需要使用数据进行服务器端渲染，请回答以下问题以做出决定：
- en: Is it important for the data to be displayed in the initial load of the view
    when JavaScript may not be available in the browser?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当浏览器中可能无法使用JavaScript时，数据在视图的初始加载中显示是否很重要？
- en: Do the view and its data need to be SEO-friendly?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图及其数据是否需要对SEO友好？
- en: Loading data in the initial load of the page may be relevant from a usability
    persepective, so it really depends on the use case for the specific view. For
    SEO, server-side rendering with data will give search engines easier access to
    the data content in the view, so if this is crucial for the view in question,
    then adding server-side rendering with data is a good idea.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的初始加载中加载数据可能与可用性相关，因此这实际上取决于特定视图的用例。对于SEO，使用数据进行服务器端渲染将使搜索引擎更容易访问视图中的数据内容，因此如果这对于所讨论的视图至关重要，则添加服务器端渲染数据是一个好主意。
- en: Using ES6 class for stateful vs pure functional components
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES6类来定义有状态与纯功能组件
- en: While building UI with React components, composing the views with more stateless
    functional components can make the frontend code manageable, clean, and easier
    to test. But some components will need the state or lifecycle hooks to be more
    than pure presentational components. In this section, we look at what it takes
    to build stateful and stateless functional React components, when to use one or
    the other and how often.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React组件构建UI时，使用更多无状态功能组件来组合视图可以使前端代码更易管理、清晰，并且更易于测试。但是，一些组件将需要状态或生命周期钩子来超出纯呈现组件。在本节中，我们将看看构建有状态和无状态功能React组件需要什么，何时使用其中一个，以及多久使用一次。
- en: React components with ES6 class
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES6类的React组件
- en: React components defined using ES6 class have access to lifecycle methods, the `this`
    keyword, and can manage state with `setState` when building stateful components.
    Stateful components allow us to build interactive components that can manage changing
    data in state, and propagate any business logic that needs to be applied across
    the UI. Generally, for complex UI, stateful components should be higher-level
    container components that manage the state of the smaller stateless functional
    components they are composed of.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES6类定义的React组件可以访问生命周期方法、`this`关键字，并且在构建有状态组件时可以使用`setState`来管理状态。有状态组件允许我们构建交互式组件，可以管理状态中的变化数据，并传播需要应用于UI的任何业务逻辑。通常，对于复杂的UI，有状态组件应该是管理其组成的较小的无状态功能组件的更高级容器组件。
- en: React components as pure functions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件作为纯函数
- en: React components can be defined as stateless functional components using the
    ES6 class syntax or as pure functions. The main idea is a stateless component
    does not modify state and receives props.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: React组件可以使用ES6类语法或纯函数定义为无状态功能组件。主要思想是无状态组件不修改状态并接收props。
- en: 'The following code defines a stateless component using the ES6 class syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用ES6类语法定义了一个无状态组件：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same can also be defined using JavaScript pure functions, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用JavaScript纯函数来定义相同的内容，如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A pure function always gives the same output when given the same input without
    any side effects. Modeling React components as pure functions enforces creation
    of smaller, more defined, and self-contained components that emphasize UI over
    business logic as there is no state manipulation in these components. These kinds
    of components are composable, reusable, and easy to debug and test.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数在给定相同输入时总是给出相同输出，没有任何副作用。将 React 组件建模为纯函数强制创建更小、更明确定义和自包含的组件，强调 UI 而不是业务逻辑，因为这些组件中没有状态操作。这些类型的组件是可组合的、可重用的，易于调试和测试。
- en: Designing the UI with stateful components and stateless functional components
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有状态组件和无状态函数组件设计 UI
- en: While thinking about the component composition for a UI, design the root or
    a parent component as a stateful component that will contain child components
    or the composable components that only receive props and cannot manipulate state.
    All the state-changing actions using `setState` and life-cycle issues will be
    handled by the root or parent component.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 UI 的组件组成时，设计根组件或父组件作为一个有状态的组件，它将包含子组件或只接收 props 且不能操作状态的可组合组件。所有使用 `setState`
    进行状态更改的操作和生命周期问题将由根组件或父组件处理。
- en: In the applications developed for this book, there is a mixture of stateful
    higher-level components and smaller stateless components. For example, in the
    MERN Social application, the `Profile` component modifies the state for stateless
    child components, such as the `FollowProfileButton` and `FollowGrid` components.
    There is scope for refactoring some of the larger components that were developed
    in this book into smaller, more self-contained components, and this should be
    considered before extending the applications to incorporate more features.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书开发的应用程序中，有一些有状态的高级组件和较小的无状态组件的混合。例如，在 MERN Social 应用程序中，`Profile` 组件修改了无状态子组件的状态，比如
    `FollowProfileButton` 和 `FollowGrid` 组件。在将应用程序扩展到包含更多功能之前，应考虑将本书中开发的一些较大组件重构为更小、更自包含的组件。
- en: The main takeaway that can be applied to new component design or refactoring
    existing components, is that as the React application grows and gets more complex,
    it is better to have more stateless functional components added to higher-level
    stateful components that are in charge of managing state for its inner components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于新组件设计或重构现有组件的主要要点是，随着 React 应用程序的增长和复杂性的增加，最好在负责管理其内部组件状态的高级有状态组件中添加更多的无状态函数组件。
- en: Using Redux or Flux
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 或 Flux
- en: When React applications begin to grow and get more complex, managing communication
    between components can become problematic. When using regular React, the way to
    communicate is to pass down values and callback functions as props to the child
    components. But this can be tedious if there are a lot of intermediary components
    that the callback must pass through. To address these state communication and
    management-related issues as the React application grows, people turn to using
    React with libraries and architecture patterns such as Redux and Flux.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React 应用程序开始增长并变得更加复杂时，管理组件之间的通信可能会变得棘手。在使用常规 React 时，通信的方式是将值和回调函数作为 props
    传递给子组件。但是，如果有许多中间组件必须经过回调传递，这可能会很繁琐。随着 React 应用程序的增长，人们会转向使用 Redux 和 Flux 等库和架构模式来解决这些与状态通信和管理相关的问题。
- en: 'It is outside the scope of this book to delve into the details of integrating
    React with the Redux library or the Flux architecture, but the reader may consider
    these options for their growing MERN applications while keeping the following
    in mind:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及将React与Redux库或Flux架构集成的细节，但读者可以在考虑这些选项时牢记他们不断增长的MERN应用程序。
- en: Redux and Flux utilize patterns that enforce changing states in a React application
    from a central location. A trick to avoid using Redux or Flux in React applications
    of manageable sizes, is moving all state changes up the component tree to parent
    components.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux和Flux利用模式来强制从中心位置改变React应用程序的状态。在可管理大小的React应用程序中避免使用Redux或Flux的一个技巧是将所有状态更改移到父组件的组件树上。
- en: Smaller applications work just as well without Flux or Redux.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较小的应用程序同样可以在没有Flux或Redux的情况下运行良好。
- en: You can learn more about using React with Redux at [https://redux.js.org/](https://redux.js.org/),
    and Flux at [facebook.github.io/flux/](http://facebook.github.io/flux/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://redux.js.org/](https://redux.js.org/)了解有关在React中使用Redux的更多信息，并在[facebook.github.io/flux/](http://facebook.github.io/flux/)了解有关Flux的信息。
- en: Enhancing security
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强安全性
- en: In the MERN applications developed for this book, we kept the auth-related security
    implementations simple by using JSON Web Tokens as an authentication mechanism
    and by storing hashed passwords in the User collection. In this section, we will
    go over these choices and point to possible enhancements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在为本书开发的MERN应用程序中，我们通过使用JSON Web Tokens作为身份验证机制，并在用户集合中存储哈希密码，简化了与身份验证相关的安全实现。在本节中，我们将介绍这些选择，并指出可能的增强功能。
- en: JSON web tokens – client-side or server-side storage
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Tokens - 客户端或服务器端存储
- en: With the JWT authentication mechanism, the client side becomes responsible for
    maintaining user state. Once the user signs in, the token sent by the server is
    stored and maintained by the client-side code on browser storage, such as `sessionStorage`.
    Hence, it is also up to the client-side code to invalidate the token by removing
    it when a user signs out or needs to be signed out. This mechanism works out well
    for most applications that need minimal authentication to protect access to resources.
    However, for instances where it may be necessary to track user sign-ins, sign-outs,
    and to let the server know that a specific token is no longer valid for sign-in,
    just the client-side handling of the tokens is not enough.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT身份验证机制，客户端负责维护用户状态。一旦用户登录，服务器发送的令牌将由客户端代码在浏览器存储中存储和维护，例如`sessionStorage`。因此，客户端代码也负责通过在用户退出登录或需要退出登录时删除令牌来使令牌失效。这种机制对于大多数需要最小身份验证以保护资源访问的应用程序非常有效。然而，在某些情况下，可能需要跟踪用户登录、退出登录，并让服务器知道特定令牌不再有效以进行登录，仅仅客户端处理令牌是不够的。
- en: For these cases, the implementation discussed for handling JWT tokens on the
    client side can be extended to storage on the server side as well. In the specific
    case of keeping track of invalidated tokens, a MongoDB collection can be maintained
    by the server to store these invalidated tokens as reference, somewhat similar
    to how it is done for storing session data on the server side.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，可以将客户端处理JWT令牌的实现扩展到服务器端存储。在跟踪失效令牌的特定情况下，服务器可以维护一个MongoDB集合来存储这些失效令牌的引用，类似于在服务器端存储会话数据的方式。
- en: The thing to be cautious about and to keep in mind is that storing and maintaining
    auth-related information on both the client and server side may be overkill in
    most cases. Hence it is entirely up to the specific use case and the related trade-offs
    to be considered.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要谨慎考虑并牢记的是，在大多数情况下，在客户端和服务器端存储和维护与身份验证相关的信息可能过度。因此，完全取决于特定的用例和相关的权衡考虑。
- en: Securing password storage
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护密码存储
- en: While storing user credentials for authentication in the User collection, we
    made sure that the original password string provided by the user is never stored
    directly in the database. Instead we generated a hash of the password along with
    a salt value using the `crypto` module in Node.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在为用户集合中的身份验证存储用户凭据时，我们确保用户提供的原始密码字符串从未直接存储在数据库中。相反，我们使用Node中的`crypto`模块生成密码的哈希值以及盐值。
- en: 'In `user.model.js` from our applications, we defined the following functions
    to generate the hashed `password` and `salt` value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序的`user.model.js`中，我们定义了以下函数来生成哈希的`password`和`salt`值：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this implementation, every time a user enters a password to sign in, a
    hash is generated with the salt. If the generated hash matches the stored hash,
    then the password is correct, otherwise the password is wrong. So in order to
    check whether a password is correct, the salt is required, and hence it is stored
    with the user details in the database along with the hash.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种实现方式，每当用户输入密码进行登录时，就会使用盐生成一个哈希值。如果生成的哈希值与存储的哈希值匹配，那么密码就是正确的，否则密码就是错误的。因此，为了检查密码是否正确，需要盐，因此它与用户详细信息一起存储在数据库中。
- en: This is standard practice for securing passwords stored for user authentication,
    but there are other advanced approaches that may be explored if a specific application's
    security requirements demand it. Some options that can be considered include multi-iteration
    hashing approaches, other secure hashing algorithms, limiting login attempts per
    user account, and multi-level authentication with additional steps such as answering
    security questions or entering security codes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了保护用户身份验证存储的密码的标准做法，但如果特定应用程序的安全要求需要，还可以探索其他高级方法。一些可以考虑的选项包括多次迭代的哈希方法、其他安全的哈希算法、限制每个用户帐户的登录尝试次数，以及具有额外步骤的多级身份验证，例如回答安全问题或输入安全代码。
- en: Writing test code
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试代码
- en: Though discussing and writing test code is outside the scope of this book, it
    is crucial for developing reliable software. In this section, first we will look
    at the testing tools available to test the different parts of a MERN application.
    Then, to help get started with writing test code for the MERN applications developed
    in this book, we will also discuss a real example of adding a client-side test
    to the MERN Social application from [Chapter 5](8af4986f-1f37-45f2-ba05-85caa119a652.xhtml),
    *Starting with a Simple Social Media Application*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然讨论和编写测试代码不在本书的范围之内，但对于开发可靠的软件来说是至关重要的。在本节中，首先我们将看一下用于测试MERN应用程序不同部分的测试工具。然后，为了帮助开始编写本书中开发的MERN应用程序的测试代码，我们还将讨论一个真实的例子，即向MERN
    Social应用程序添加客户端测试，该应用程序来自[第5章](8af4986f-1f37-45f2-ba05-85caa119a652.xhtml) *从一个简单的社交媒体应用程序开始*。
- en: Testing with Jest
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest进行测试
- en: Jest is a comprehensive testing framework for JavaScript. Though it is more
    commonly known for testing React components, it can be used for general-purpose
    testing with any JavaScript library or framework. Among the many JavaScript testing
    solutions in Jest, it provides support for mocking and snapshot testing, comes
    with an assertion library, and tests in Jest are written in the **behavior driven
    development** (**BDD**) style. Besides testing the React components, Jest can
    be also be adapted to write test code for the Node-Express-Mongoose-based backend
    as required. Hence, it is a solid testing option to add test code for the MERN
    applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是一个全面的JavaScript测试框架。虽然它更常用于测试React组件，但它也可以用于任何JavaScript库或框架的通用测试。在Jest的许多JavaScript测试解决方案中，它提供了对模拟和快照测试的支持，配备了一个断言库，并且Jest中的测试是以**行为驱动开发**（**BDD**）风格编写的。除了测试React组件外，Jest也可以根据需要适应编写Node-Express-Mongoose后端的测试代码。因此，它是一个可靠的测试选项，可以为MERN应用程序添加测试代码。
- en: To learn more about Jest, read the docs at [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Jest的信息，请阅读[https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html)上的文档。
- en: Adding a test to the MERN Social application
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向MERN Social应用程序添加测试
- en: Using Jest, we will add a client-side test to the MERN Social application and
    demonstrate how to get started with adding tests to MERN applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest，我们将向MERN Social应用程序添加一个客户端测试，并演示如何开始向MERN应用程序添加测试。
- en: Before writing the test code, first we will set up for testing by installing
    the necessary packages, defining the test run script, and creating a `tests` folder
    for the test code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试代码之前，首先我们将通过安装必要的软件包、定义测试运行脚本和创建一个`tests`文件夹来设置测试。
- en: Installing the packages
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装软件包
- en: 'The following npm packages will be required in order to write test code and
    run the tests:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写测试代码并运行测试，将需要以下npm软件包：
- en: '**jest**: To include the Jest testing framework'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jest**：包括Jest测试框架'
- en: '**babel-jest**: To compile JS code for Jest'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**babel-jest**：用于为Jest编译JS代码'
- en: '**react-test-renderer**: To make a snapshot of the DOM tree rendered by a React
    DOM without using a browser'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**react-test-renderer**：用于创建React DOM渲染的DOM树的快照，而无需使用浏览器'
- en: 'To install these packages as `devDependencies`, run the following `npm install`
    command from the command line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些软件包安装为`devDependencies`，请从命令行运行以下`npm install`命令：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Defining the script to run tests
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义脚本以运行测试
- en: 'In order to run the test code, we will update the run scripts defined in `package.json`,
    to add a script for running tests with `jest`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行测试代码，我们将更新`package.json`中定义的运行脚本，以添加一个使用`jest`运行测试的脚本：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the command line, if we run `npm run test`, it will prompt Jest to find the
    test code in the application folders and run the tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，如果我们运行`npm run test`，它将提示Jest在应用程序文件夹中查找测试代码并运行测试。
- en: Adding a tests folder
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个tests文件夹
- en: To add the client-side test in the MERN Social application, we will create a
    folder called `tests` in the client folder, which will contain test files relevant
    to testing the React components. When the test command is run, Jest will look
    for the test code in these files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在MERN Social应用程序中添加客户端测试，我们将在客户端文件夹中创建一个名为`tests`的文件夹，其中将包含与测试React组件相关的测试文件。当运行测试命令时，Jest将在这些文件中查找测试代码。
- en: The test case for this example will be a test on the `Post` component, and tests
    for the `Post` component will be added in a file called `post.test.js` in the
    `tests` folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的测试用例将是对`Post`组件的测试，并且`Post`组件的测试将添加到`tests`文件夹中的名为`post.test.js`的文件中。
- en: Test case
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例
- en: We will write a test to check whether the `delete` button on a post is only
    visible when the signed-in user is also the creator of the post. This means that
    the delete button will only be a part of the Post view, if the `user._id` of the
    authenticated user is the same as the `postedby` value of the post data being
    rendered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个测试，以检查帖子上的“删除”按钮是否只在登录用户也是帖子创建者时可见。这意味着只有在认证用户的 `user._id` 与正在渲染的帖子数据的
    `postedby` 值相同时，“删除”按钮才会成为帖子视图的一部分。
- en: Adding the test
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试
- en: 'In order to implement this test case, we will add code which takes care of
    the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个测试用例，我们将添加代码来处理以下事项：
- en: Defines dummy data for a post and an `auth` object
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为帖子和 `auth` 对象定义虚拟数据
- en: Mocks `auth-helper.js`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟 `auth-helper.js`
- en: Defines the test and within the test definition
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义测试，并在测试定义内部
- en: Declares the `post` and `auth` variables
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 `post` 和 `auth` 变量
- en: Sets the return value of the mocked `isAuthenticated` method to the dummy `auth`
    object
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模拟的 `isAuthenticated` 方法的返回值设置为虚拟的 `auth` 对象
- en: Uses `renderer.create` to create the `Post` component with the required dummy
    props passed and wrapped in `MemoryRouter` to provide the props related to `react-router`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `renderer.create` 创建带有必需虚拟 props 的 `Post` 组件，并包装在 `MemoryRouter` 中以提供与 `react-router`
    相关的 props
- en: Generates and matches snapshots
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成并匹配快照
- en: 'The code in `post.test.js` to incorporate the steps described for this specific
    test will be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`post.test.js` 中的代码将包括为这个特定测试描述的步骤。'
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generating a snapshot of the correct Post view
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成正确的 Post 视图的快照
- en: The first time this test is run, we will provide it with the values required
    to generate the correct snapshot of the Post view. The correct snapshot for this
    test case will contain the delete button when the `user._id` of the auth object
    is equal to the `postedBy` value of the post object. This snapshot generated when
    the test is first run will be used for comparison for future test executions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此测试时，我们将为其提供生成正确的帖子视图快照所需的值。此测试用例的正确快照将在 `user._id` 的 auth 对象等于帖子对象的 `postedBy`
    值时包含删除按钮。首次运行测试时生成的快照将用于将来的测试执行进行比较。
- en: Snapshot testing in Jest basically records snapshots of rendered component structures
    to compare them to future renderings. When the recorded snapshot and the current
    rendering don’t match, the test fails, indicating that something has changed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 中的快照测试基本上记录了渲染组件结构的快照，以便将来进行比较。当记录的快照与当前渲染不匹配时，测试将失败，表示发生了变化。
- en: Running and checking the test
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行并检查测试
- en: In the code that we just added to the `post.test.js`, the dummy `auth` object
    and `post` object refer to the same user, thus running this test in the command
    line will prompt Jest to generate a snapshot that will contain the delete option
    and also pass the test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加到 `post.test.js` 中的代码中，虚拟的 `auth` 对象和 `post` 对象引用同一用户，因此在命令行中运行此测试将提示
    Jest 生成一个包含删除选项的快照，并且测试也会通过。
- en: 'To run the test, go into the project folder from the command line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请从命令行进入项目文件夹：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test output will show that the test passed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出将显示测试通过：
- en: '![](assets/dd786cee-c6d3-4d46-8eab-b7dfc375cff2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd786cee-c6d3-4d46-8eab-b7dfc375cff2.png)'
- en: The recorded snapshot that is generated, when this test runs successfully for
    the first time, is added automatically to a `_snapshots_` folder in the `tests`
    folder. This snapshot represents the state where the delete button is rendered
    in the view since the authenticated user is also the creator of the post.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当此测试首次成功运行时生成的记录快照将自动添加到 `tests` 文件夹中的 `_snapshots_` 文件夹中。此快照代表了在视图中呈现删除按钮的状态，因为认证用户也是帖子的创建者。
- en: We can now check whether the test actually fails when the component is rendered
    with an authenticated user that is not the creator of the post. To perform this
    check, we will update the dummy data objects by changing `user._id` to not match
    the `postedBy` value, then run the test again. This will give us a failed test,
    as the current rendering will no longer have a delete button that is present in
    the recorded snapshot.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查一下，当组件与一个不是帖子创建者的已认证用户一起渲染时，测试是否实际失败。为了进行这个检查，我们将通过将`user._id`更改为不匹配`postedBy`的值来更新虚拟数据对象，然后再次运行测试。这将导致测试失败，因为当前的渲染将不再有一个在记录的快照中存在的删除按钮。
- en: 'As seen in the test log pictured next, the test fails and indicates that the
    rendered tree does not match the recorded snapshot since the elements representing
    the delete button are missing in the received value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示的测试日志中，测试失败并指示渲染树与记录的快照不匹配，因为接收到的值中缺少代表删除按钮的元素：
- en: '![](assets/5c11456c-887a-450f-ba95-0a8eb79dd656.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c11456c-887a-450f-ba95-0a8eb79dd656.png)'
- en: With this screenshot, we have a client-side test for checking whether a signed-in
    user can view the `delete` button on their posts. Using this setup, more tests
    can be added for the MERN application utilizing the capabilities of Jest.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个屏幕截图，我们可以对客户端进行测试，以检查已登录用户是否可以在他们的帖子上看到`删除`按钮。使用这个设置，可以为利用Jest的MERN应用程序添加更多的测试。
- en: Writing test code will make the application you develop reliable and also help
    ensure code quality. Another good practice for improving and maintaining code
    quality is using a linting tool with your project. Linting tools perform static
    analysis on the code to find problematic patterns or behaviors that violate specified
    rules and guidelines. Linting code in a JavaScript project can improve overall
    code readability and also help find syntax errors before the code is executed.
    For linting in MERN-based projects, you can explore ESLint, which is a JavaScript
    linting utility that allows developers to create their own linting rules.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试代码将使您开发的应用程序更可靠，还有助于确保代码质量。另一个提高和维护代码质量的好方法是在项目中使用一个linting工具。Linting工具对代码进行静态分析，以查找违反指定规则和准则的问题模式或行为。在JavaScript项目中进行linting可以提高整体代码的可读性，还可以帮助在代码执行之前找到语法错误。对于基于MERN的项目，您可以探索ESLint，它是一个JavaScript
    linting实用程序，允许开发人员创建自己的linting规则。
- en: Optimizing the bundle size
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化捆绑大小
- en: As you develop and grow a MERN application, chances are the size of the bundles
    produced with Webpack will also grow, especially if large third-party libraries
    are used. Larger bundle sizes will effect performance and increase the initial
    load time of the application. We can make changes in the code to ensure we don’t
    end up with large bundles and also utilize features packed in Webpack 4 to help
    optimize bundling. In this section, we will highlight some key concepts that can
    give us control in producing smaller bundles and decreasing load time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您开发和扩展MERN应用程序，使用Webpack生成的捆绑包的大小也会增长，特别是如果使用了大型第三方库。更大的捆绑包大小会影响性能，并增加应用程序的初始加载时间。我们可以在代码中进行更改，以确保我们不会得到大型捆绑包，并且还可以利用Webpack
    4中打包的功能来帮助优化捆绑。在本节中，我们将重点介绍一些关键概念，这些概念可以让我们控制生成更小的捆绑包，并减少加载时间。
- en: Before going into the code to update it for bundle size optimization, you can
    also get familiar with the default optimization options that are now part of Webpack
    4\. In the MERN applications, we used the `mode` config to utilize the default
    settings for both development and production mode. To get an overview of the options
    available, check out this article at [https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a](https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码以更新其捆绑大小优化之前，您还可以熟悉现在作为Webpack 4一部分的默认优化选项。在MERN应用程序中，我们使用`mode`配置来利用开发模式和生产模式的默认设置。要了解可用选项的概述，请查看此文章[https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a](https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a)。
- en: Code splitting
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码拆分
- en: Instead of loading all the code at once in one bundle, we can use the code-splitting
    feature supported by Webpack to lazy-load parts of the application code as currently
    needed by the user. After we modify the application code to introduce code splitting,
    Webpack can create multiple bundles rather than one large bundle. These bundles
    can be loaded dynamically at runtime, allowing us to improve the performance of
    the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Webpack支持的代码拆分功能，而不是一次性加载所有代码在一个捆绑包中，以懒加载用户当前需要的应用程序代码的部分。在我们修改应用程序代码以引入代码拆分之后，Webpack可以创建多个捆绑包而不是一个大捆绑包。这些捆绑包可以在运行时动态加载，从而可以改善应用程序的性能。
- en: To learn more about code splitting support in Webpack and how to make necessary
    changes to the setup and configuration, check out the guides in the documentation
    at [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Webpack中的代码拆分支持以及如何对设置和配置进行必要更改，请查看文档中的指南[https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/)。
- en: There are several ways to introduce code splitting for the application code,
    but the most important syntax you will come across for this purpose is the dynamic
    `import()`. In the next section, we will look at how to use `import()` with our
    MERN applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 引入应用程序代码的代码拆分有几种方法，但为此目的遇到的最重要的语法是动态`import()`。在下一节中，我们将看看如何在我们的MERN应用程序中使用`import()`。
- en: Dynamic import()
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态导入()
- en: 'Dynamic `import()` is a new function-like version of the regular import and
    it enables the dynamic loading of JS modules. Using `import(moduleSpecifier)`
    will return a promise for the module namespace object of the requested module. When
    using regular static imports, we import a module at the top of the code and then
    use it in the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 动态`import()`是常规导入的新函数版本，它使JS模块的动态加载成为可能。使用`import(moduleSpecifier)`将返回所请求模块的模块命名空间对象的promise。在使用常规静态导入时，我们在代码顶部导入模块，然后在代码中使用它：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we were to use dynamic `import()` instead of adding the static import at
    the beginning, the code would look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用动态`import()`而不是在开头添加静态导入，代码将如下所示：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows importing and loading the module when the code requires it. While
    bundling the application code, Webpack will treat calls to `import()` as split
    points and automatically start code splitting by placing the requested module
    and its children into a separate chunk from the main bundle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在代码需要时导入和加载模块。在捆绑应用程序代码时，Webpack将调用`import()`视为拆分点，并通过将请求的模块及其子级自动放置到与主捆绑包不同的块中来自动开始代码拆分。
- en: 'In order to optimize the bundling of the frontend React code by applying code
    splitting at a given component, we need to pair dynamic `import()` with React
    Loadable—a higher-order component for loading components with promises. As an
    example, we will look at the shopping cart developed in [Chapter 7](b73b9122-dd0c-45dc-ac34-94ce990e0437.xhtml),
    *Extending the Marketplace for Orders and Payments*. While building the interface
    of the cart, we composed the `Cart` component by importing and adding the `Checkout`
    component to the view as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过在给定组件应用代码拆分来优化前端React代码的捆绑，我们需要将动态`import()`与React Loadable配对——这是一个用于通过promise加载组件的高阶组件。例如，我们将看一下在[第7章](b73b9122-dd0c-45dc-ac34-94ce990e0437.xhtml)中开发的购物车，*扩展订单和支付的市场*。在构建购物车的界面时，我们通过导入和添加`Checkout`组件到视图中来组成`Cart`组件，如下所示：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To introduce code splitting here and import the `Checkout` component dynamically,
    we can replace the static import at the beginning with a `Loadable` Checkout,
    as shown in the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此处引入代码拆分并动态导入`Checkout`组件，我们可以将开头的静态导入替换为`Loadable` Checkout，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Making this change and using Webpack to build the code again will produce a
    `bundle.js` file of reduced size, and generate another smaller bundle file representing
    the split code, which will now only load when the `Cart` component is rendered.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这种更改并再次使用Webpack构建代码将产生一个减小尺寸的`bundle.js`文件，并生成另一个表示拆分代码的较小的bundle文件，这将只在渲染`Cart`组件时加载。
- en: Using this mechanism, we can apply code splitting across our application code
    as required. The thing to keep in mind is that effective code splitting will depend
    on using it correctly and applying it at the right places in the code—places that
    will benefit in optimization from resource-load prioritization.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种机制，我们可以根据需要在整个应用程序代码中应用代码拆分。要记住的是，有效的代码拆分取决于正确使用它并将其应用于代码中的正确位置——这些位置将从资源加载优先级的优化中受益。
- en: Route-based code splitting can be an effective approach for introducing code
    splitting in React apps that use routes to load components in the view. To learn
    more about implementing code splitting, specifically with React Router, check
    out the article at [https://tylermcginnis.com/react-router-code-splitting/](https://tylermcginnis.com/react-router-code-splitting/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基于路由的代码拆分可以是引入React应用程序中使用路由在视图中加载组件的有效方法。要了解更多关于实现代码拆分的信息，特别是使用React Router，请查看[https://tylermcginnis.com/react-router-code-splitting/](https://tylermcginnis.com/react-router-code-splitting/)上的文章。
- en: Extending the applications
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Throughout the chapters in this book, as we developed each application, we added
    features by extending the existing code in a common and repeatable number of steps.
    In this final section, we will review these steps and set a guideline for adding
    more features to the current versions of the applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的各章中，当我们开发每个应用程序时，我们通过在一系列常见且可重复的步骤中扩展现有代码来添加功能。在本节中，我们将回顾这些步骤，并为向当前版本的应用程序添加更多功能设定一个指南。
- en: Extending the server code
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展服务器代码
- en: For a specific feature, that will require data persistence and APIs to allow
    the views to manipulate the data, we can start by extending the server code and
    adding the necessary models, routes, and controller functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定功能，这将需要数据持久性和API来允许视图操作数据，我们可以通过扩展服务器代码并添加必要的模型、路由和控制器函数来开始。
- en: Adding a model
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: For the data persistence aspect of the feature, design the data model considering
    the fields and values that need to be stored. Then, define and export a Mongoose
    schema for this data model in a separate file in the `server/models` folder.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能的数据持久性方面，设计数据模型时要考虑需要存储的字段和值。然后，在`server/models`文件夹中的单独文件中定义并导出此数据模型的Mongoose模式。
- en: Implementing the APIs
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API
- en: Next, design the APIs relevant for the desired feature, in order to manipulate
    and access the data that will be stored in the database based on the model.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设计与所需功能相关的API，以便根据模型操作和访问将存储在数据库中的数据。
- en: Adding controllers
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制器
- en: With the APIs decided, add the corresponding controller functions that will
    respond to the requests to these APIs in a separate file in the `server/controllers`
    folder. The controller functions in this file should access and manipulate the
    data for the model defined for this feature.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了API后，在`server/controllers`文件夹中的一个单独文件中添加将响应这些API请求的相应控制器函数。此文件中的控制器函数应访问和操作为此功能定义的模型的数据。
- en: Adding routes
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: To complete the implementation of the server-side APIs, corresponding routes
    need to be declared and mounted on the Express app. In a separate file in the
    `server/routes` folder, first declare and export the routes for these APIs, assigning
    the relevant controller functions that should be executed when a specific route
    is requested. Then, load these new routes on the Express app in the `server/express.js`
    file, like the other existing routes in the application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完成服务器端API的实现，需要声明相应的路由并挂载到Express应用程序上。在`server/routes`文件夹中的一个单独文件中，首先声明并导出这些API的路由，分配应该在请求特定路由时执行的相关控制器函数。然后，在`server/express.js`文件中加载这些新路由到Express应用程序中，就像应用程序中的其他现有路由一样。
- en: This will produce a working version of the new backend APIs that can be run
    and checked from a REST API client application, before going on to build and integrate
    frontend views for the feature being developed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个可以从REST API客户端应用程序运行和检查的新后端API的工作版本，然后再构建和集成正在开发的功能的前端视图。
- en: Extending the client code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展客户端代码
- en: On the client side, first design the views required for the feature, and determine
    how these views will incorporate user interaction with the data relevant to the
    feature. Then add the fetch API code to integrate with the new backend APIs, define
    the new components that represent these new views, and update the existing code
    to include these new components in the frontend of the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，首先设计所需的功能视图，并确定这些视图将如何与与功能相关的数据进行用户交互。然后添加获取API代码以与新后端API集成，定义代表这些新视图的新组件，并更新现有代码以在应用程序的前端中包含这些新组件。
- en: Adding the API fetch methods
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加API获取方法
- en: In the client folder, create a new folder to house the components and helper
    code relevant to the feature module being developed. Then to integrate the new
    backend APIs, add and export the corresponding fetch methods in a separate file
    in this new components folder.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端文件夹中，创建一个新文件夹，用于存放正在开发的功能模块相关的组件和辅助代码。然后，为了集成新的后端API，添加并导出相应的获取方法到这个新组件文件夹中的一个单独文件中。
- en: Adding components
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加组件
- en: Create and export new React components that represent views for the desired
    feature, in separate files in the new folder. Integrate auth into these new components
    using the existing auth-helper methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在新文件夹的单独文件中创建和导出代表所需功能的React组件，将其视图分离。使用现有的auth-helper方法将auth集成到这些新组件中。
- en: Loading new components
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载新组件
- en: In order to incorporate these new components into the frontend, the components
    either need to be added into existing components or rendered at their own client-side
    routes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些新组件整合到前端，这些组件要么需要添加到现有组件中，要么在自己的客户端路由上呈现。
- en: Updating frontend routes
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新前端路由
- en: If these new components need to be rendered at individual routes, update the
    `MainRouter.js` code to add new routes that load these components at given URL
    paths.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些新组件需要在单独的路由上呈现，更新`MainRouter.js`代码以添加加载这些组件的新路由，以给定的URL路径。
- en: Integrating with existing components
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与现有组件集成
- en: If the new components will become part of existing views, import the component
    into the existing component to add it to the view as desired. The new components
    can also be integrated with existing components, such as in the `Menu` component,
    by linking to new components that were added with individual routes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新组件将成为现有视图的一部分，请将该组件导入现有组件，以便根据需要将其添加到视图中。新组件也可以与现有组件集成，例如在`Menu`组件中，通过链接到添加了单独路由的新组件。
- en: With the components integrated and connected with the backend, the new feature
    implementation is complete. These steps can be repeated to add on new features
    to the applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与后端集成和连接组件，新功能实现已经完成。这些步骤可以重复，以向应用程序添加新功能。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter, we reviewed and elaborated on some of the best practices
    used while building the MERN applications in this book, highlighted areas of improvement,
    gave pointers to address issues that may crop up when applications grow, and finally
    set down the guidelines to continue developing more features into the existing
    applications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们回顾并详细阐述了构建MERN应用程序时使用的一些最佳实践，突出了改进的领域，给出了解决应用程序增长时可能出现的问题的指引，并最终制定了继续向现有应用程序中开发更多功能的准则。
- en: We saw that modularizing the application's code structure helped extend the
    application easily, choosing to use JSS over inline CSS and external style sheets
    kept the styling code contained and easy to work with, and only implementing server-side
    rendering for specific views as required kept unnecessary complications out of
    the code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，模块化应用程序的代码结构有助于轻松扩展应用程序，选择在内联CSS和外部样式表之间使用JSS保持了样式代码的可控性和易用性，并且只在必要时为特定视图实现服务器端渲染，避免了代码中不必要的复杂性。
- en: We discussed the benefits of creating fewer stateful components that are composed
    of smaller and more defined stateless functional components, and how this can
    be applied while refactoring existing components or designing new components to
    extend the applications. For growing applications that may run into issues of
    managing and communicating state across hundreds of components, we pointed to
    options such as Redux or Flux that may be considered to address these issues.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了创建更少的有状态组件的好处，这些组件由更小、更明确定义的无状态功能组件组成，以及如何在重构现有组件或设计新组件以扩展应用程序时应用这一原则。对于可能遇到跨数百个组件管理和通信状态问题的不断增长的应用程序，我们指出了诸如Redux或Flux之类的选项，可以考虑解决这些问题。
- en: For applications that may have higher demands for stricter security enforcement,
    we looked back at our existing implementation of user auth with JWT and password
    encryption, and discussed possible extensions for improved security.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能对更严格的安全执行有更高要求的应用程序，我们回顾了我们现有的使用JWT和密码加密的用户认证实现，并讨论了改进安全性的可能扩展。
- en: We used Jest to demonstrate how test code can be added to the MERN applications,
    and discussed how good practices, such as writing test code and using a linting
    tool, can improve code quality besides ensuring reliability in an application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Jest演示了如何向MERN应用程序添加测试代码，并讨论了良好的实践，比如编写测试代码和使用linting工具，可以提高代码质量，同时确保应用程序的可靠性。
- en: We also looked at bundle optimization features, such as code splitting, that
    can help to improve performance by reducing the initial bundle size, and by lazy-loading
    parts of the application as required.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了捆绑优化功能，例如代码拆分，可以通过减少初始捆绑大小和根据需要延迟加载应用程序的部分来提高性能。
- en: Finally, we reviewed and set down the repeatabe steps that were used throughout
    the book, and can be used as a guideline moving forward to extend the MERN applications
    by adding more features.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾并确定了整本书中使用的可重复步骤，并可以作为指导方针，通过添加更多功能来扩展MERN应用程序。
