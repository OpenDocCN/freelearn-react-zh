- en: Implementing Server-Side Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务器端渲染
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下示例：
- en: Implementing Server-Side Rendering
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务器端渲染
- en: Implementing promises with Server-Side Rendering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器端渲染实现承诺
- en: Implementing Next.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Next.js
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'React typically uses client-side rendering (CSR). This means that it dynamically
    injects the HTML code in the target `div` (it generally uses the `#app` or `#root` IDs), and
    that''s why if you try to see the page''s code directly (right-click—View Page
    Code) you will see something like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: React通常使用客户端渲染（CSR）。这意味着它动态地将HTML代码注入到目标`div`中（通常使用`#app`或`#root` ID），这就是为什么如果您尝试直接查看页面的代码（右键单击-查看页面代码），您将看到类似于这样的内容：
- en: '![](assets/76039f9f-fe36-408f-a130-57f991ed7205.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76039f9f-fe36-408f-a130-57f991ed7205.png)'
- en: 'The only way to see the actual code is by inspecting the site with Chrome Dev
    Tools, or other tools, and here is the code generated by React using CSR:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看实际代码的唯一方法是使用Chrome Dev工具或其他工具检查网站，以下是React使用CSR生成的代码：
- en: '![](assets/34b17d83-a4c8-4d2e-914c-5a2402c18df3.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34b17d83-a4c8-4d2e-914c-5a2402c18df3.png)'
- en: By inspecting the page, you can see the code that is injected into our `#root`
    div. *Server-side rendering (SSR)* is very useful for improving the *SEO* of our
    website and be indexed by the main search engines, such as *Google*, *Yahoo*,
    and *Bing*. You probably don't need to worry about *S**SR* if you don't care too
    much about SEO. Currently, the Googlebot supports *CSR*, and it can index our
    site on *Google*, but if you care about SEO and you are worried about improving
    the SEO on other search engines, such as *Yahoo*, *Bing*, or *DuckDuckGo*, then
    using SSR is the way to go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查页面，您可以看到注入到我们的`#root` div中的代码。*服务器端渲染（SSR）*对于改善我们网站的*SEO*并被主要搜索引擎（如*Google*、*Yahoo*和*Bing*）索引非常有用。如果您不太关心SEO，可能不需要担心*SSR*。目前，*Googlebot*支持*CSR*，并且可以在*Google*上索引我们的网站，但如果您关心SEO并且担心改善其他搜索引擎（如*Yahoo*、*Bing*或*DuckDuckGo*）上的SEO，则使用*SSR*是正确的选择。
- en: Implementing Server-Side Rendering
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务器端渲染
- en: In this recipe, we will implement SSR in our project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在我们的项目中实现SSR。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to use the code from the last recipe (*Implementing Node.js with
    React/Redux and Webpack 4)* from [Chapter 10](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*, Mastering
    Webpack 4.x*, and install some other dependencies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一篇示例（*使用Node.js与React/Redux和Webpack 4实现*）中的代码，从[第10章](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*，掌握Webpack
    4.x*，并安装一些其他依赖项：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s now go through the steps of rendering:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下渲染的步骤：
- en: 'First, we need to add our npm scripts to our `package.json` file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将npm脚本添加到我们的`package.json`文件中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'File: package.json'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：package.json
- en: 'Now we have to change our `webpack.config.js` file. Because we are going to
    implement SSR, we need to separate our Webpack configuration into a client configuration
    and server configuration, returning them as an array. The file should look like
    this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要更改我们的`webpack.config.js`文件。因为我们要实现SSR，我们需要将我们的Webpack配置分成客户端配置和服务器配置，并将它们作为数组返回。文件应该看起来像这样：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'File: webpack.config.js'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack.config.js
- en: 'Now we need to create a file for our client configuration inside our `webpack`
    folder. We need to call it `webpack.config.client.js`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在我们的`webpack`文件夹内为我们的客户端配置创建一个文件。我们需要将其命名为`webpack.config.client.js`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'File: webpack/webpack.config.client.js'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/webpack.config.client.js
- en: 'Now the server config should be like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在服务器配置应该是这样的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'File: webpack/webpack.config.server.js'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/webpack.config.server.js
- en: 'As you can see, in both files we are importing a common configuration file
    that contains a configuration that needs to be added to both the client and the
    server:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这两个文件中，我们正在导入一个包含需要添加到客户端和服务器端的配置的共同配置文件：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'File: webpack/webpack.config.common.js'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/webpack.config.common.js
- en: 'We need to add new configuration files for Webpack nodes and also modify some
    of the files we already have. The first one we need to create is `context.js`.
    In this file (and some others) we are going to export a function with a type parameter,
    which can be *client* or *server*, and depending on that value we will return
    different configurations:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为Webpack节点添加新的配置文件，并修改一些我们已经有的文件。我们需要创建的第一个文件是`context.js`。在这个文件（和其他一些文件）中，我们将导出一个带有类型参数的函数，该参数可以是*client*或*server*，并根据该值返回不同的配置：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'File: webpack/configuration/context.js'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/context.js
- en: 'The entry file is where we will add all the files that are going to be added
    to the bundle. Our entry file now should be like this:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入口文件是我们将添加到捆绑包中的所有文件的位置。我们的入口文件现在应该是这样的：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'File: webpack/configuration/entry.js'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/entry.js
- en: 'We need to create a file called externals.js, which contains the modules we
    won''t bundle (unless they are on the whitelist):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为externals.js的文件，其中包含我们不打包的模块（除非它们在白名单上）：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'File: webpack/configuration/externals.js'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/externals.js
- en: 'Also, we need to modify our `module.js` file to return our rules based on the
    environment or the configuration type:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要修改我们的`module.js`文件，根据环境或配置类型返回我们的规则：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'File: webpack/configuration/module.js'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/module.js
- en: 'Now we need to create a node for the name:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为名称创建一个节点：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'File: webpack/configuration/name.js'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/name.js
- en: 'For the output configuration, we need to return an object depending on the
    type of configuration (client or server):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于输出配置，我们需要根据配置的类型（客户端或服务器端）返回一个对象：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'File: webpack/configuration/output.js'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/output.js
- en: 'In our `plugins.js` file, we are validating whether the user has sent the `ANALYZER`
    variable to display the `BundleAnalyzerPlugin` just in that case and not every
    time we run our application in development mode:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`plugins.js`文件中，我们正在验证用户是否发送了`ANALYZER`变量，以便在开发模式下运行应用程序时仅在该情况下显示`BundleAnalyzerPlugin`，而不是每次都显示。
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'File: webpack/configuration/plugins.js'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/plugins.js
- en: 'We need to specify our modules in our resolve file; the file should be like
    this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的解析文件中指定我们的模块；文件应该是这样的：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'File: webpack/configuration/resolve.js'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/resolve.js
- en: 'The last configuration we need to create is the `target.js` file:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个配置是`target.js`文件：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'File: webpack/configuration/target.js'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：webpack/configuration/target.js
- en: 'After we have configured our Webpack, we need to modify our `App.jsx` file,
    in which we need to create our routes for the client using the `<BrowserRouter>`
    component and `<StaticRouter>` for the server:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们配置了Webpack之后，我们需要修改我们的`App.jsx`文件，其中我们需要使用`<BrowserRouter>`组件为客户端创建路由，并使用`<StaticRouter>`为服务器端创建路由：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'File: src/client/App.jsx'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/App.jsx
- en: 'Now we need to modify our server file (`index.js`) to use our *clientRender*
    and *serverRender* middleware:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修改我们的服务器文件（`index.js`）以使用我们的*clientRender*和*serverRender*中间件：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'File: src/server/index.js'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/server/index.js
- en: 'We need to modify our `clientRender.js` file. If we detect a search bot with
    the `isBot` function,we will return the `next()` middleware. Otherwise, we render
    the HTML and we execute the app with CSR:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改我们的`clientRender.js`文件。如果我们检测到一个搜索引擎爬虫使用`isBot`函数，我们将返回`next()`中间件。否则，我们渲染HTML并使用CSR执行应用程序：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'File: src/server/render/clientRender.js'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/server/render/clientRender.js
- en: 'Now let''s create our `serverRender.js` file. Here, we need to render our `App`
    component using the `renderToString` method from `react-dom/server` library:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的`serverRender.js`文件。在这里，我们需要使用`react-dom/server`库中的`renderToString`方法来渲染我们的`App`组件：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'File: src/server/render/serverRender.js'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/server/render/serverRender.js
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can start the application by running the `npm start` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`npm start`命令启动应用程序。
- en: 'If you open the app at `http://localhost:3000` in your browser (Chrome, for
    example) and you right-click and then View page source, you will probably notice
    that we are not using SSR:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器（例如Chrome）中打开`http://localhost:3000`中的应用程序，然后右键单击，然后查看页面源代码，您可能会注意到我们没有使用SSR：
- en: '![](assets/35cb0370-fc71-4da4-9af0-a7f60c764cea.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/35cb0370-fc71-4da4-9af0-a7f60c764cea.png)'
- en: 'This is because we will only use SSR for search bots. The *isBot* function will
    detect all the search bots, and just for a test I added *curl* as a bot to test
    our SSR; this is the code of that function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们将仅将SSR用于搜索引擎爬虫。*isBot*函数将检测所有搜索引擎爬虫，仅供测试，我添加了*curl*作为一个爬虫来测试我们的SSR；这是该函数的代码：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'File: src/shared/utils/device.js'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/utils/device.js
- en: 'Open a new terminal while you have the application running in another terminal,
    and then execute the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中打开一个新的终端，然后执行以下命令：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](assets/41cfa504-72bc-456f-a9e3-bdcb9c524d4f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41cfa504-72bc-456f-a9e3-bdcb9c524d4f.png)'
- en: 'As you can see, the HTML code inside the #root div is render it using the SSR.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，#root div内的HTML代码是使用SSR渲染的。
- en: 'Also, if you want to try to run `/about` in curl, you will see that also will
    render it using SSR:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您想尝试在curl中运行`/about`，您将看到它也将使用SSR进行渲染：
- en: '![](assets/29b3774a-7a5b-4b0a-9e15-d34da262b8c7.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/29b3774a-7a5b-4b0a-9e15-d34da262b8c7.png)'
- en: 'There is an extension for Chrome called User-Agent Switcher for C*hrome* where
    you can specify the user agent you want to use in your browser. In this way, you
    can add a special user agent for Googlebot, for example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome有一个名为User-Agent Switcher for Chrome的扩展，您可以在其中指定要在浏览器中使用的用户代理。通过这种方式，您可以为Googlebot添加一个特殊的用户代理，例如：
- en: '![](assets/cce1b59f-6f77-4908-aecc-59ad8cc815fe.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cce1b59f-6f77-4908-aecc-59ad8cc815fe.png)'
- en: 'Then, if you select Chrome | Bot in User-Agent Switcher, you can see that the
    HTML code renders it as SSR when you do View page source:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您在User-Agent Switcher中选择Chrome | Bot，您会发现当您查看页面源代码时，HTML代码会将其呈现为SSR：
- en: '![](assets/0fa6e9d4-7f9e-4d11-b32e-df15a3694b29.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0fa6e9d4-7f9e-4d11-b32e-df15a3694b29.png)'
- en: There's more...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When we are using SSR, we have to be very careful when we try to use the object
    window for the client. If you use it directly using SSR you will get a ReferenceError
    such as this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用SSR时，当我们尝试在客户端使用window对象时，我们必须非常小心。如果您直接使用SSR，您将收到ReferenceError，例如：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To solve this problem, you can validate that the window object exists, but
    this can be very repetitive. I prefer to create a function that can verify whether
    we are using a browser (client) or a server. You can do it like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您可以验证window对象是否存在，但这可能非常重复。我更喜欢创建一个可以验证我们是使用浏览器（客户端）还是服务器的函数。您可以这样做：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then every time you need to use the window object, you can do something like
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次您需要使用window对象时，可以这样做：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing promises with Server-Side Rendering
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器端渲染实现承诺
- en: In the last recipe, we saw how SSR works, but that recipe was limited to displaying
    the SSR with simple components. In this recipe, we will learn how to implement
    promises to connect our components to Redux, use an API to get data and render
    the components using SSR.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了SSR的工作原理，但该示例仅限于显示具有简单组件的SSR。在本示例中，我们将学习如何实现承诺以将我们的组件连接到Redux，使用API获取数据并使用SSR渲染组件。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We are going to use the same code from the last recipe, but we will make some
    changes. In this recipe, we need to install these packages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一个步骤中的相同代码，但我们将进行一些更改。在这个步骤中，我们需要安装这些软件包：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we are going to implement a basic todo list pulled from an
    API to show how to connect Redux to our application using SSR:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，我们将实现一个基本的待办事项列表，从API中拉取数据，以展示如何使用SSR将Redux连接到我们的应用程序中：
- en: 'The first thing we need to do is to add a simple API to display a to-do list:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加一个简单的API来显示待办事项列表：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'File: src/server/controllers/api.js'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/server/controllers/api.js
- en: 'The second step is to import this API controller into our `src/server/index.js`
    file and add it as middleware on the `/api` route:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是将这个API控制器导入到我们的`src/server/index.js`文件中，并将其添加为`/api`路由的中间件：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'File: src/server/index.js'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/server/index.js
- en: 'Previously, in our `serverRender.js` file, we rendered our `App` component
    directly. Now we need to get the promises from the components that have a static
    method called `initialAction`, save them into a promises array, resolve them,
    and then render our `App` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前，在我们的`serverRender.js`文件中，我们直接渲染了我们的`App`组件。现在我们需要从具有名为`initialAction`的静态方法的组件中获取承诺，将它们保存到一个承诺数组中，解决它们，然后渲染我们的`App`方法：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'File: src/server/render/serverRender.js'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/server/render/serverRender.js
- en: 'In this recipe, we need to change our folder structure a little bit in our
    client directory. Previously, we had a `components` directory and our components
    were inside. Now we are going to encapsulate our components as small applications,
    and inside we can create our actions, API, components, containers, and reducers.
    Our new structure should look like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们需要在客户端目录中稍微改变我们的文件夹结构。以前，我们有一个`components`目录，我们的组件都在里面。现在我们要将我们的组件封装为小应用程序，在里面我们可以创建我们的操作、API、组件、容器和减速器。我们的新结构应该是这样的：
- en: '![](assets/e4c2cc9b-d2f6-42b6-b495-2d18c088157a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e4c2cc9b-d2f6-42b6-b495-2d18c088157a.png)'
- en: 'We will create a todo application. To do this, first we need to add our actions
    folder, and inside we need to make first our `actionTypes.js` file. In this file,
    we need to add our `FETCH_TODO` actions. I prefer to create an object with two
    functions, one for requests and the other for the success; you will see the advantage
    of this when we use this on our reducer and when we dispatch our actions:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个待办事项应用程序。为此，首先我们需要添加我们的操作文件夹，在里面我们需要首先创建我们的`actionTypes.js`文件。在这个文件中，我们需要添加我们的`FETCH_TODO`操作。我更喜欢创建一个具有两个函数的对象，一个用于请求，另一个用于成功；当我们在减速器中使用它们并分发我们的操作时，你将看到这一点的优势：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'File: src/client/todo/actions/actionTypes.js'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/actions/actionTypes.js
- en: 'In our `index.js` file, we will create a fetchTodo action to retrieve our todo
    list items from our API:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`index.js`文件中，我们将创建一个fetchTodo操作，从我们的API中检索我们的待办事项列表项：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'File: src/client/todo/actions/index.js'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/actions/index.js
- en: 'As you can see, we are using two particular methods (request and received)
    from our base actions. These functions will help us to dispatch our actions easily
    (do you remember that we used the request and success methods in the actions?):'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在使用基本操作中的两种特定方法（请求和接收）。这些函数将帮助我们轻松地分发我们的操作（你还记得我们在操作中使用了请求和成功方法吗？）：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'File: src/shared/redux/baseActions.js'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/redux/baseActions.js
- en: 'Now let''s create our `api` folder, where we need to add a `constants.js` file
    and our `index.js` file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的`api`文件夹，在这里我们需要添加一个`constants.js`文件和我们的`index.js`文件：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'File: src/client/todo/api/constants.js'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/api/constants.js
- en: 'In our `index.js` file, we have to create our Api class and add a static method
    called `fetchTodo`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`index.js`文件中，我们必须创建我们的Api类并添加一个名为`fetchTodo`的静态方法：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'File: src/client/todo/api/index.js'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/api/index.js
- en: 'In our Todo container, we need to map our todo list and add the *fetchTodo*
    action to Redux. We will export a Layout component, to which we will add our other
    components and manipulate the way we want to display the layout:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Todo容器中，我们需要映射我们的待办事项列表，并将*fetchTodo*动作添加到Redux中。我们将导出一个布局组件，然后我们将添加我们的其他组件，并操纵我们想要显示布局的方式：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'File: src/client/todo/container/index.js'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/container/index.js
- en: 'Our Layout component should be like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的布局组件应该是这样的：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'File: src/client/todo/components/Layout.jsx'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/components/Layout.jsx
- en: 'In this recipe, we are not going to see the layout components (Header, Content,
    and Footer) since they are very generic and we have used them in the past recipes.
    Now let''s create our reducer file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个教程中，我们不会看到布局组件（Header、Content和Footer），因为它们非常通用，我们在过去的教程中已经使用过它们。现在让我们创建我们的reducer文件：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'File: src/client/todo/reducer/index.js'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/reducer/index.js
- en: 'Our Todo component will execute our fetchTodo action in the componentDidMount
    method, and then we render the Todo list into an HTML list; very simple:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的Todo组件将在componentDidMount方法中执行我们的fetchTodo动作，然后我们将待办事项列表呈现为HTML列表；非常简单：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'File: src/client/todo/components/Todo.jsx'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/components/Todo.jsx
- en: 'Finally, we need to create an `index.jsx` file for our todo app, and in this
    file we are going to add our initialAction (this will return a promise) to execute
    our fetchTodo action and render this Todo list using SSR:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为我们的待办事项应用程序创建一个`index.jsx`文件，在这个文件中，我们将添加我们的initialAction（这将返回一个承诺）来执行我们的fetchTodo动作，并使用SSR呈现这个待办事项列表：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'File: src/client/todo/index.jsx'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/client/todo/index.jsx
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see in our `serverRender.js` file, we get the promises and resolve
    them, and then we render our application using SSR.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在我们的`serverRender.js`文件中所看到的，我们获取承诺并解决它们，然后我们使用SSR渲染我们的应用程序。
- en: If you want to test the application, you need to go to http://localhost:3000/todo
    in your browser.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试该应用程序，您需要在浏览器中转到http://localhost:3000/todo。
- en: Remember that in our app, we are just using SSR for search bots and curl, otherwise
    will use CSR. This is because the only reason we have to use SSR is to improve
    our SEO in Google, Yahoo, and Bing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的应用程序中，我们只是为搜索引擎爬虫和curl使用SSR，否则将使用CSR。这是因为我们必须使用SSR的唯一原因是为了改善我们在Google、Yahoo和Bing中的SEO。
- en: If we use CSR, the way we will execute our action is on the `componentDidMount()`
    method in our Todo component; and if we are using SSR, we will use the `initialAction`
    method, which returns a promise that will be resolved in `serverRender.js`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用CSR，我们将在Todo组件的`componentDidMount()`方法中执行我们的动作；如果我们使用SSR，我们将使用`initialAction`方法，该方法返回一个将在`serverRender.js`中解决的承诺。
- en: 'If you open the page, you should see this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开页面，您应该会看到这个：
- en: '![](assets/7487add2-4819-4a66-9a88-9b7742f03046.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7487add2-4819-4a66-9a88-9b7742f03046.png)'
- en: 'If you want to see whether the SSR is working, you can use the `curl` command
    and execute the same URL in your Terminal:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看SSR是否正常工作，可以使用`curl`命令并在终端中执行相同的URL：
- en: '![](assets/3f0d3e9b-3983-4b55-ad35-2a09ae9f9c5a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f0d3e9b-3983-4b55-ad35-2a09ae9f9c5a.png)'
- en: As you can see, the todo list reducer has been added to `initialState` and from
    there, we can render the list using SSR.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，待办事项列表reducer已添加到`initialState`中，从那里，我们可以使用SSR渲染列表。
- en: Implementing Next.js
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Next.js
- en: Next.js is a minimalistic framework for server-rendered React applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js是一个用于服务器渲染的React应用程序的极简框架。
- en: In this recipe, we are going to learn how to implement Next.js with Sass, and
    we will also get data from a service using axios.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用Sass实现Next.js，并且我们还将使用axios从服务中获取数据。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, let''s create a new directory called `nextjs`, initialize `package.json`,
    and finally create a new directory inside it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`nextjs`的新目录，初始化`package.json`，最后在其中创建一个新目录：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then we need to install some dependencies:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要安装一些依赖项：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now that we have installed the dependencies, let''s create our first Next.js
    application:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了依赖项，让我们创建我们的第一个Next.js应用程序：
- en: 'The first thing we need to do is to create some scripts in our package.json.
    In each script, we need to specify the `src` directory. Otherwise, it will try
    to start Next from the root instead of the `src` path:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在我们的package.json中创建一些脚本。在每个脚本中，我们需要指定`src`目录。否则，它将尝试从根目录而不是`src`路径启动Next：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'File: package.json'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：package.json
- en: 'The main directory in Next is called `pages`. This is where we will include
    all the `pages` we want to render using Next:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Next中的主目录称为`pages`。这是我们将使用Next渲染的所有`pages`的位置：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first page we need to create is `index.jsx`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建的第一个页面是`index.jsx`：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'File: src/pages/index.jsx'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/pages/index.jsx
- en: 'Now let''s run our application using the dev script:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用dev脚本运行我们的应用程序：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If everything works, you should see this in your terminal:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该在终端中看到这个：
- en: '![](assets/f75b2344-5ab1-4d52-af63-01d928622c7d.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/f75b2344-5ab1-4d52-af63-01d928622c7d.png)
- en: 'Open `http://localhost:3000`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:3000`：
- en: '![](assets/d996d9a6-c555-4412-9451-dce13b0b2d21.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/d996d9a6-c555-4412-9451-dce13b0b2d21.png)
- en: Next.js has its own Webpack configuration and hot reloading enabled. That means
    if you edit the index.js file you will see the changes reflected without refreshing
    the page.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js有自己的Webpack配置和热重载功能。这意味着如果您编辑index.js文件，您将看到反映这些更改而无需刷新页面。
- en: 'Now let''s create an About page to see how the routing works:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个关于页面，看看路由是如何工作的：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'File: src/pages/about.jsx'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/pages/about.jsx
- en: Now you will see the about page if you go to http://localhost:3000/about. As
    you can see, Next.js automatically creates a new route for each page we have created.
    This means we don't need to install React Router to handle the routing.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您转到http://localhost:3000/about，您将看到关于页面。正如您所看到的，Next.js会自动为我们创建的每个页面创建一个新路由。这意味着我们不需要安装React
    Router来处理路由。
- en: In Next pages, it is not necessary to import React because it is automatically
    handled by Next as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next页面中，不需要导入React，因为Next也会自动处理它。
- en: 'Now we need to create a `next.config.js` file and import the withSass method
    to use Sass in our project. Unfortunately, this file needs to be written in ES5
    syntax because the babel extension to use ES6 is not supported  at the moment
    ([https://github.com/zeit/next.js/issues/2916](https://github.com/zeit/next.js/issues/2916)):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个`next.config.js`文件，并导入withSass方法来在我们的项目中使用Sass。不幸的是，这个文件需要用ES5语法编写，因为目前不支持使用ES6的babel扩展（[https://github.com/zeit/next.js/issues/2916](https://github.com/zeit/next.js/issues/2916)）：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'File: src/next.config.jsIn this file, we can also add custom Webpack configuration
    if we need it.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/next.config.js在这个文件中，如果需要，我们还可以添加自定义的Webpack配置。
- en: 'Then we need to create a special file in the `pages` directory called `_document.js`.
    This file is automatically handled by Next.js, and here we can define the head
    and body of our document:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要在`pages`目录中创建一个特殊的文件叫做`_document.js`。这个文件会被Next.js自动处理，我们可以在这里定义文档的头部和正文：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'File: src/pages/_document.jsThe path to the CSS file (`/_next/static/style.css`)
    is by default; we should use that one to use styles in our project.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/pages/_document.jsCSS文件的路径（`/_next/static/style.css`）是默认的；我们应该使用它来在我们的项目中使用样式。
- en: 'Now we can create some components to wrap up our pages. The first one we need
    to create is a navbar for menu options:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一些组件来包装我们的页面。我们需要创建的第一个是菜单选项的导航栏：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'File: src/components/Navbar.jsxThe Link component is not the same as the React
    Router Link. There are a few differences; for example, the React Router Link uses
    the "to" prop and the Next Link uses "href" to specify the URL.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Navbar.jsx Link组件与React Router Link不同。有一些区别；例如，React Router
    Link使用“to”prop，而Next Link使用“href”来指定URL。
- en: 'Now we can add Sass styles for our `navbar`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的`navbar`添加Sass样式：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'File: src/components/Navbar.scss'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Navbar.scss
- en: 'Then we need to create our Layout component:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要创建我们的Layout组件：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'File: src/components/Layout.jsx'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Layout.jsx
- en: 'The styles for our Layout are as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的Layout的样式如下：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'File: src/components/Layout.scss'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Layout.scss
- en: 'Do you remember the recipe in [Chapter 5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml), *Mastering
    Redux*,  about listing the top 100 cryptocurrencies from CoinMarketCap (`Repository:
    Chapter05/Recipe2/coinmarketcap`)? In this recipe, we are going to do the same
    using Next.js. The first thing we need to do is to modify the page''s `index.js`
    file and do an async `axios` request in the `getInitialProps` method:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你还记得[第5章](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml)中的配方，*精通Redux*，关于从CoinMarketCap列出前100个加密货币（`Repository:
    Chapter05/Recipe2/coinmarketcap`）吗？在这个配方中，我们将使用Next.js做同样的事情。我们需要做的第一件事是修改页面的`index.js`文件，并在`getInitialProps`方法中进行异步`axios`请求：'
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'File: src/pages/index.js'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/pages/index.js
- en: 'Now let''s create the `Coins` component:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建`Coins`组件：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'File: src/components/Coins.jsx'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Coins.jsx
- en: 'The styles for the `Coins` component are as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Coins`组件的样式如下：'
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'File: src/components/Coins.scss'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Coins.scss
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now that we have created all the pages and components, let''s test our Next
    application by running `npm run dev`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有页面和组件，让我们通过运行`npm run dev`来测试我们的Next应用程序：
- en: '![](assets/3fce3ceb-4c6d-44df-acdc-dcd320c4437f.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3fce3ceb-4c6d-44df-acdc-dcd320c4437f.png)'
- en: 'Let''s now see how it is rendering it in the HTML view:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看它在HTML视图中是如何渲染的：
- en: '![](assets/34746655-239c-4230-8419-333d76ce7bd2.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34746655-239c-4230-8419-333d76ce7bd2.png)'
- en: Banzai! The HTML is rendered with SSR and is perfect for improving the SEO.
    As you can see, creating an application with Next is super fast, and we avoid
    a lot of configuration when enabling SSR.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！HTML以SSR方式呈现，非常适合改善SEO。正如你所看到的，使用Next创建应用程序非常快速，而且在启用SSR时避免了大量的配置。
