- en: Making Your Components Look Beautiful
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的组件看起来漂亮
- en: Our journey into React best practices and design patterns has now reached the
    point where we want to make our components look beautiful. To do that, we will
    go through all the reasons why regular CSS may not be the best approach for styling
    components, and we will check out various alternative solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的React最佳实践和设计模式之旅现在已经达到了我们想要让组件看起来漂亮的地步。为了做到这一点，我们将详细介绍为什么常规CSS可能不是样式化组件的最佳方法的所有原因，并且我们将了解各种替代解决方案。
- en: Starting with inline styles, then Radium, CSS modules, and `styled-components`,
    this chapter will guide you through the magical world of CSS in JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从内联样式开始，然后是Radium、CSS模块和`styled-components`，本章将指导您进入JavaScript中CSS的神奇世界。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Common problems with regular CSS at scale
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模上常见的常规CSS问题
- en: What it means to use inline styles in React and the downsides
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中使用内联样式及其缺点
- en: How the Radium library can help fix issues of inline styles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Radium库如何帮助解决内联样式的问题
- en: How to set up a project from scratch using Webpack and CSS modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Webpack和CSS模块从头开始设置项目
- en: Features of CSS modules and why they represent a great solution to avoid global
    CSS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS模块的特性以及它们为什么是避免全局CSS的绝佳解决方案
- en: '`styled-components`, a new library that offers a modern approach to styling
    React components'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styled-components`，一种为React组件提供现代样式的新库'
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter08).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍的GitHub存储库中找到本章的代码：[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter08)。
- en: CSS in JavaScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的CSS
- en: In the community, everyone agrees that a revolution took place in the styling
    of React components in November 2014, when  Christopher Chedeaugave a talk at
    the NationJS conference.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在社区中，每个人都同意在2014年11月，React组件的样式发生了革命，当时Christopher Chedea在NationJS会议上发表了演讲。
- en: Also known as  **vjeux** on the internet,  Christopher  works at Facebook and
    contributes to React. In his talk, he went through all the problems related to
    CSS on the scale  that they were facing at Facebook. It is worth understanding
    all of them because some are  pretty  common and they will help us  introduce  concepts
    such as  inline styles and  locally scoped class names.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上也被称为**vjeux**，Christopher在Facebook工作并为React做出贡献。在他的演讲中，他详细介绍了他们在Facebook面临的所有与CSS相关的问题。值得理解所有这些问题，因为其中一些问题非常普遍，它们将帮助我们引入内联样式和本地作用域类名等概念。
- en: 'The following is a list of the issues with CSS, basically problems with CSS
    at scale:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CSS存在的问题清单，基本上是在规模上出现的问题：
- en: Global namespace
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局命名空间
- en: Dependencies
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系
- en: Dead code elimination
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死代码消除
- en: Minification
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化
- en: Sharing constants
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享常量
- en: Non-deterministic resolution
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非确定性解决方案
- en: Isolation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离
- en: The first well-known problem of CSS is that all the selectors are global. No
    matter how we organize our styles, using namespaces or a procedure such as the
    **Block,** **Element,** **Modifier** (**BEM**) methodology, in the end, we are
    always polluting the global namespace, which we all know is wrong. It is not only
    wrong in principle, but it also leads to many errors in big code bases, and it
    makes maintainability very hard in the long term. Working with big teams, it is
    non-trivial to know whether a particular class or element has already been styled,
    and most of the time, we tend to add more classes instead of reusing existing
    ones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的第一个众所周知的问题是所有选择器都是全局的。无论我们如何组织我们的样式，使用命名空间或诸如**块**，**元素**，**修饰符**（**BEM**）方法之类的过程，最终我们总是在污染全局命名空间，我们都知道这是错误的。这不仅在原则上是错误的，而且在大型代码库中会导致许多错误，并且在长期内使可维护性非常困难。与大团队合作，要知道特定类或元素是否已经被样式化是非平凡的，大多数情况下，我们倾向于添加更多类而不是重用现有类。
- en: The second problem with CSS regards the definition of the dependencies. It is
    very hard, in fact, to state clearly  that a particular component depends on a
    specific CSS and that the CSS has to be loaded for the style to be applied. Since
    styles are global, any style from any file can be applied to any element, and
    losing control is very easy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的第二个问题涉及依赖关系的定义。事实上，很难清楚地说明特定组件依赖于特定的CSS，并且必须加载CSS才能应用样式。由于样式是全局的，任何文件中的任何样式都可以应用于任何元素，失去控制非常容易。
- en: The third is that frontend developers tend to use preprocessors to be able to
    split their CSS into submodules, but in the end, a big, global CSS bundle is generated
    for the browser. Since CSS code bases tend to become huge quickly, we lose control
    over them, and the third problem is to do with  **dead code elimination**. It
    is not easy to  identify quickly  which styles belong to which component, and
    this makes deleting code incredibly hard. In fact, due to the cascading nature
    of CSS, removing a selector or a rule can result in an unintended result within
    the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题是前端开发人员倾向于使用预处理器来将他们的CSS拆分成子模块，但最终，会为浏览器生成一个大的全局CSS捆绑包。由于CSS代码库很快变得庞大，我们失去了对它们的控制，第三个问题与死代码消除有关。很难迅速确定哪些样式属于哪个组件，这使得删除代码非常困难。事实上，由于CSS的级联特性，删除选择器或规则可能会导致浏览器中出现意外结果。
- en: Another pain of working with CSS concerns the minification of the selectors
    and the class names, both in the CSS and in the JavaScript application. It might
    seem an easy task but it is not, especially when classes are applied on the fly
    or concatenated in the client; this is the fourth problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS工作的另一个痛点涉及选择器和类名在CSS和JavaScript应用程序中的缩小。这似乎是一项简单的任务，但实际上并非如此，特别是当类在客户端上应用或连接时；这是第四个问题。
- en: Not being able to minify and optimize class names is pretty bad for performance,
    and it can make a huge difference to the size of the CSS. Another pretty common
    operation that is non-trivial with regular CSS is sharing constants between the
    styles and the client application. We often need to know the height of a header,
    for example, to recalculate the position of other elements that depend on it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无法缩小和优化类名对性能来说非常糟糕，并且它可能会对CSS的大小产生巨大影响。另一个常见的非平凡操作是在样式和客户端应用程序之间共享常量。我们经常需要知道标题的高度，例如，以便重新计算依赖于它的其他元素的位置。
- en: Usually, we read the value in the client using the JavaScript APIs, but the
    optimal solution would be to share constants and avoid doing expensive calculations
    at runtime. This represents the fifth problem that vjeux and the other developers
    at Facebook tried to solve.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用JavaScript API在客户端读取值，但最佳解决方案是共享常量并避免在运行时进行昂贵的计算。这代表了vjeux和Facebook的其他开发人员试图解决的第五个问题。
- en: The sixth issue concerns the non-deterministic resolution of CSS. In fact, in
    CSS, the order matters, and if the CSS is loaded on demand, the order is not guaranteed,
    which leads to the wrong styles being applied to the elements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个问题涉及CSS的非确定性解析。实际上，在CSS中，顺序很重要，如果CSS按需加载，顺序就无法保证，这会导致错误的样式应用于元素。
- en: Suppose, for example, that we want to optimize the way we request CSS, loading
    the CSS related to a particular page only when the users navigate to it. If the
    CSS related to this last page has some rules that also apply to the elements of
    different pages, the fact that it has been loaded last could affect the styling
    of the rest of the app. For example, if the user goes back to the previous page,
    they might see a page with a UI that is slightly different than the first time
    they visited it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想优化请求CSS的方式，只有在用户导航到特定页面时才加载与该页面相关的CSS。如果与最后一个页面相关的CSS具有一些规则，这些规则也适用于不同页面的元素，那么最后加载它可能会影响应用程序其余部分的样式。例如，如果用户返回到上一个页面，他们可能会看到一个UI略有不同于他们第一次访问时的页面。
- en: It is incredibly hard to control all the various combinations of styles, rules,
    and navigation paths, but again, being able to load the CSS when needed could
    have a critical impact on the performance of a web application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 控制各种样式、规则和导航路径的各种组合非常困难，但是，能够在需要时加载CSS可能会对Web应用程序的性能产生关键影响。
- en: Last but not least, the seventh problem of CSS, according to  Christopher Chedeau,
    is related to isolation. In CSS, it is almost impossible to achieve proper isolation
    between files or components. Selectors are global, and they can easily be overwritten.
    It is tricky to predict the final style of an element just by knowing the class
    names applied to it because styles are not isolated and other rules in other parts
    of the application can affect unrelated elements. This can be solved by using
    inline styles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，根据Christopher Chedeau的说法，CSS的第七个问题与隔离有关。在CSS中，几乎不可能在文件或组件之间实现适当的隔离。选择器是全局的，很容易被覆盖。仅仅通过知道应用于元素的类名就很难预测元素的最终样式，因为样式不是隔离的，应用程序其他部分的其他规则可能会影响不相关的元素。这可以通过使用内联样式来解决。
- en: In the following section, we will look at what it means to use inline styles
    with React and the benefits and downsides of it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看看在React中使用内联样式意味着什么，以及其优缺点。
- en: Understanding and implementing inline styles
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并实现内联样式
- en: The official React documentation suggests developers use inline styles to style
    their React components. This seems  odd  because we all learned in past years
    that separating the concerns is important and we should not mix markup and CSS.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的React文档建议开发人员使用内联样式来为他们的React组件设置样式。这似乎有点奇怪，因为多年来我们都学到了分离关注点很重要，我们不应该混合标记和CSS。
- en: React tries to change the concept of separation of concerns by moving it from
    the separation of technologies to the separation of components. Separating markup,
    styling, and logic into different files when they are tightly coupled and where
    one cannot work without the other is just an illusion. Even if it helps keep the
    project structure cleaner, it does not give any real benefit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: React 试图通过将关注点的概念从技术的分离转移到组件的分离来改变。当标记、样式和逻辑紧密耦合且一个不能没有另一个而无法工作时，将它们分离到不同的文件中只是一种幻觉。即使它有助于保持项目结构更清洁，但它并没有提供任何真正的好处。
- en: In React, we compose components to  create  applications where components are
    a fundamental unit of our structure. We should be able to move components across
    the application, and they should provide the same result regarding both logic
    and UI, no matter where they get rendered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，我们组合组件来创建应用程序，其中组件是我们结构的基本单位。我们应该能够在应用程序中移动组件，并且无论它们被渲染在哪里，它们都应该提供相同的逻辑和
    UI 结果。
- en: This is one of the reasons why collocating the styles within our components
    and applying them using inline styles on the elements could make sense in React.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为什么在 React 中将样式与组件放在一起，并使用内联样式在元素上应用它们可能是有意义的原因之一。
- en: 'First, let''s look at an example of what it means to use the style attribute
    of the nodes to apply the styling to our components in React. We are going to
    create a button with the text  `Click me!` and we are going to apply color and
    background color to it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个例子，看看在 React 中使用节点的样式属性来为我们的组件应用样式意味着什么。我们将创建一个带有文本 `Click me!` 的按钮，并为其应用颜色和背景颜色：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it is pretty easy to style elements with inline styles in React.
    We just have to create an object where the attributes are the CSS rules, and the
    values are the values we would use in a regular CSS file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用内联样式在 React 中很容易为元素设置样式。我们只需要创建一个对象，其中属性是 CSS 规则，值是我们在常规 CSS 文件中使用的值。
- en: The only differences are that the hyphenated CSS rules must be camelCased to
    be JavaScript-compliant, and the values are strings, so they have to be wrapped
    in quote marks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，连字符的 CSS 规则必须转换为驼峰命名以符合 JavaScript 的规范，并且值是字符串，因此它们必须用引号括起来。
- en: There are some exceptions regarding the vendor prefixes. For example, if we  want  to
    define a transition on  `webkit`, we should use the `WebkitTransition` attribute,
    where the  `webkit`  prefix begins with a capital letter. This rule applies to
    all the vendor prefixes, except  for  `ms`, which is lowercase.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于供应商前缀有一些例外情况。例如，如果我们想在 `webkit` 上定义一个过渡，我们应该使用 `WebkitTransition` 属性，其中 `webkit`
    前缀以大写字母开头。这条规则适用于所有供应商前缀，除了 `ms`，它是小写的。
- en: Other use cases are numbers – they can be written without quotes or units of
    measurement and, by default, they are treated as pixels.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用例是数字 - 它们可以不用引号或单位来编写，并且默认情况下被视为像素。
- en: 'The following rule applies a height of  `100` pixels:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则适用于 `100` 像素的高度：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using inline styles, we can also do things that are hard to implement with
    regular CSS. For example, we can recalculate some  CSS  values on the client at
    runtime, which is a very powerful concept, as you will see in the following example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用内联样式，我们还可以做一些难以用常规 CSS 实现的事情。例如，我们可以在客户端动态重新计算一些 CSS 值，这是一个非常强大的概念，正如你将在下面的例子中看到的。
- en: Suppose you want to create a form field in which the font size changes according
    to its value. So, if the value of the field is `24`, the font size is going to
    be 24 pixels. With normal CSS, this behavior is almost impossible to reproduce
    without putting in  a huge  effort and duplicated code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个表单字段，其字体大小根据其值改变。因此，如果字段的值为`24`，字体大小将为24像素。使用普通的CSS，这种行为几乎不可能在不付出巨大努力和重复代码的情况下复制。
- en: 'Let''s look at how easy it is to use inline styles instead, by creating a `FontSize`
    component first and then declare a value state:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用内联样式有多容易，首先创建一个`FontSize`组件，然后声明一个值状态：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We implement a simple change handler, where we use the target attribute of
    the event to retrieve the current value of the field:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个简单的变更处理程序，其中我们使用事件的目标属性来检索字段的当前值：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we render the input file of the `number` type, which is a controlled
    component because we keep its value updated by using the state. It also has an
    event handler, which is fired every time the value of the field changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染`number`类型的输入文件，这是一个受控组件，因为我们通过使用状态来保持其值更新。它还有一个事件处理程序，每当字段的值改变时就会触发。
- en: 'Last but not least, we use the style attribute of the field to set its  `font-size`
    value. As you can see, we are using the camelCased version of the CSS rule to
    follow the React convention:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们使用字段的样式属性来设置其`font-size`值。正如你所看到的，我们使用了CSS规则的驼峰命名版本，以遵循React的约定：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rendering the preceding component, we can see an input field, which changes
    its font size according to its value. The way it works is that when the value
    changes, we store the new value of the field inside the state. Modifying the state
    forces the component to re-render, and we use the new state value to set the display
    value of the field and its font size; it's easy and powerful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染前面的组件，我们可以看到一个输入字段，它根据其值更改其字体大小。它的工作方式是，当值改变时，我们将字段的新值存储在状态中。修改状态会强制组件重新渲染，我们使用新的状态值来设置字段的显示值和字体大小；这很简单又很强大。
- en: Every solution in computer science has its downsides, and it always represents
    a trade-off. In the case of inline styles, unfortunately, the problems are many.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的每个解决方案都有其缺点，并且总是代表一种权衡。在内联样式的情况下，不幸的是，问题很多。
- en: For example, with inline styles, it is not possible to use pseudo-selectors
    (for example,  `:hover`) and pseudo-elements, which is a pretty significant limitation
    if you are creating a UI with interactions and animations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用内联样式时，不可能使用伪选择器（例如`:hover`）和伪元素，如果你正在创建具有交互和动画的UI，这是一个相当重要的限制。
- en: There are some workarounds and, for example, you can always create real elements
    instead of pseudo ones, but for the pseudo-classes, it is necessary to use JavaScript
    to simulate the CSS behavior, which is not optimal.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些变通方法，例如，你总是可以创建真实的元素而不是伪元素，但对于伪类，需要使用JavaScript来模拟CSS行为，这并不理想。
- en: 'The same applies to  **media queries**, which cannot be  defined  using inline
    styles, and it makes it harder to create responsive web applications. Since styles
    are declared using JavaScript objects, it is also not possible to use style fallbacks:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于**媒体查询**，无法使用内联样式来定义，这使得创建响应式Web应用程序变得更加困难。由于样式是使用JavaScript对象声明的，也不可能使用样式回退：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JavaScript objects cannot have two attributes with the same name. Style fallbacks
    should be avoided, but it is always good to have the ability to use them if needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象不能具有相同名称的两个属性。应该避免使用样式回退，但如果需要，总是可以使用它们。
- en: Another feature of  CSS that it is not possible to emulate using inline styles
    is  **animations**. The workaround here is to define animations globally and use
    them inside the style attribute of the elements. With inline styles, whenever
    we need to override a style with regular CSS, we are always forced to use the  `!important`  keyword,
    which is bad practice because it prevents any other style from being applied to
    the element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的另一个特性是**动画**，这是无法使用内联样式来模拟的。在这里的解决方法是全局定义动画，并在元素的style属性中使用它们。使用内联样式时，每当我们需要用常规CSS覆盖样式时，我们总是被迫使用`!important`关键字，这是一种不好的做法，因为它会阻止任何其他样式被应用到元素上。
- en: The most difficult thing that happens to work  with  inline styles is debugging.
    We tend to use class names to find elements in the browser DevTools to debug and
    check which styles have been applied. With inline styles, all the styles of the
    items are listed in their `style` attribute, which makes it very hard to check
    and debug the result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联样式最困难的事情是调试。我们倾向于使用类名在浏览器的开发工具中查找元素进行调试，并检查应用了哪些样式。使用内联样式时，所有项目的样式都列在它们的`style`属性中，这使得检查和调试结果非常困难。
- en: 'For example, the button that we created earlier in this section is rendered
    in the following way:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在本节早些时候创建的按钮以以下方式呈现：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By itself, it does not seem very hard to read, but if you imagine you have hundreds
    of elements and hundreds of styles, you realize that the problem becomes very
    complicated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单独看起来并不难阅读，但是如果想象一下您有数百个元素和数百种样式，您会意识到问题变得非常复杂。
- en: Also, if you are debugging a list where every single item has the same `style`
    attribute, and if you modify one on the fly to check the result in the browser,
    you will see that you are applying the styles only to it and not to all the other
    siblings, even if they share the same style.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您正在调试一个列表，其中每个项目都具有相同的`style`属性，并且如果您在浏览器中实时修改其中一个以检查结果，您会发现您只将样式应用于该项目，而不是所有其他兄弟项目，即使它们共享相同的样式。
- en: Last but not least, if we render our application on the server-side (we will
    cover this topic in  *Chapter 9*, *Server-Side Rendering for Fun and Profit*),
    the size of the page is bigger when using inline styles.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，如果我们在服务器端渲染我们的应用程序（我们将在*第9章* *为了乐趣和利润而进行服务器端渲染*中涵盖此主题），那么使用内联样式时页面的大小会更大。
- en: With inline styles, we are putting all the content of the CSS into the markup,
    which adds an extra number of bytes to the file that we send to the clients and
    makes the web application appear slower. Compression algorithms can help with
    that because they can easily compress similar patterns, and, in some cases, loading
    the critical path CSS is a good solution; but in  general, we should try to avoid
    it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联样式，我们将所有CSS内容放入标记中，这会向发送给客户端的文件添加额外的字节数，并使Web应用程序显得更慢。压缩算法可以帮助解决这个问题，因为它们可以轻松压缩相似的模式，并且在某些情况下，加载关键路径CSS是一个很好的解决方案；但总的来说，我们应该尽量避免使用内联样式。
- en: It turns out that inline styles give more problems than the problems they try
    to solve. For this reason, the community created different tools to solve the
    problems of inline styles but keeping the styles inside the components, or local
    to the components, to get the best of both worlds.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，内联样式带来的问题比它们试图解决的问题更多。因此，社区创建了不同的工具来解决内联样式的问题，但同时保持样式在组件内部或局部，以获得两全其美。
- en: After  Christopher Chedeau's  talk, a lot of developers started talking about
    inline styles, and many solutions and experiments have been made to find new ways
    of writing CSS in JavaScript. In the beginning, there were two or three solutions,
    while today there are more than 40.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Christopher Chedeau的讲话之后，许多开发人员开始谈论内联样式，并进行了许多解决方案和实验，以找到在JavaScript中编写CSS的新方法。起初，有两三种解决方案，而今天已经有40多种。
- en: In the following sections, we will go through the most popular solutions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍最受欢迎的解决方案。
- en: Exploring the Radium library
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Radium库
- en: One of the first libraries that were created to solve the problems of inline
    styles that we encountered in the previous section is **Radium**. It is maintained
    by the great developers at  Formidable Labs, and it is still one of the most popular
    solutions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们在前一节中遇到的内联样式问题而创建的最早的库之一是**Radium**。它由Formidable Labs的优秀开发人员维护，仍然是最受欢迎的解决方案之一。
- en: In this section, we will look at how  Radium  works, which problems it solves,
    and why it is a great library to use in conjunction with React for styling components.
    We are going to create a very simple button, similar to the one we built in the
    example earlier in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看Radium是如何工作的，它解决了哪些问题，以及为什么它是与React一起用于样式化组件的绝佳库。我们将创建一个非常简单的按钮，类似于本章前面示例中构建的按钮。
- en: We will start with a basic button without styling, and we will add some basic
    styling, as well as pseudo-classes and media queries, so that we can learn about
    the main features of the library.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个没有样式的基本按钮开始，然后添加一些基本样式，以及伪类和媒体查询，以便我们可以了解该库的主要特性。
- en: 'The button we will start with is created as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下方式创建按钮开始：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we have to install Radium using `npm`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用`npm`安装Radium：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the installation is complete, we can import the library and wrap the button
    in it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以导入库并将按钮包装在其中：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The  `Radium`  function is a **Higher-Order Component** (**HOC**) (see  *Chapter
    4*, *Exploring All Composition Patterns*), which extends the functionalities of
    `Button`, returning a new enhanced component. If we render the button  inside  the
    browser, we will not see anything in particular at the moment, because we are
    not applying any styles to it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Radium`函数是一个**高阶组件**（**HOC**）（见*第4章*，*探索所有组合模式*），它扩展了`Button`的功能，返回一个新的增强组件。如果我们在浏览器中渲染按钮，目前不会看到任何特别之处，因为我们没有对其应用任何样式。'
- en: 'Let''s start with a simple style object, where we set the background color,
    the padding, the size, and a couple of other CSS properties. As we saw in the
    previous section, inline styles in React are defined using JavaScript objects
    with camelCased CSS properties:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的样式对象开始，我们在其中设置背景颜色、填充、大小和一些其他CSS属性。正如我们在前一节中看到的，React中的内联样式是使用驼峰式CSS属性定义的JavaScript对象：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding snippet is no different from plain inline styles with React,
    and if we pass it to our button as follows, we can see all the styles applied
    to the button inside the browser:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段与React中的普通内联样式没有区别，如果我们将其传递给我们的按钮，我们可以在浏览器中看到应用于按钮的所有样式：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is the following markup:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下标记：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only difference you can see here is that there is a `data-radium` attribute
    set to  `true`  attached to the element.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到的唯一区别是元素附加了`data-radium`属性设置为`true`。
- en: Now, we have seen that inline styles do not let us define any pseudo-classes;
    let's take a look at how to solve the problem using Radium.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到内联样式不允许我们定义任何伪类；让我们看看如何使用Radium解决这个问题。
- en: 'Using pseudo-classes, such as  `:hover`, with Radium is pretty straightforward.
    We have to create a  `:hover`  property inside our style object, and Radium will
    do the rest:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪类，比如`：hover`，与Radium一起非常简单。我们必须在样式对象内创建一个`:hover`属性，Radium会完成其余工作：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you apply this style object to your button and render it on the screen, you
    can see that passing the mouse over the button results in a button with white
    text, as opposed to the default black one. That is great! We can use pseudo-classes
    and inline styles together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将这个样式对象应用于您的按钮并在屏幕上呈现它，您会看到将鼠标悬停在按钮上会导致按钮变成白色文本，而不是默认的黑色。这太棒了！我们可以同时使用伪类和内联样式。
- en: However, if you open your DevTools and try to force  the  `:hover`  status in
    the  `Styles` panel, you will see that nothing happens. The reason you can see
    the hover effect but you cannot simulate it with  CSS  is that Radium uses JavaScript
    to apply and remove the hover state defined in the `style` object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您打开DevTools并尝试在`Styles`面板中强制`：hover`状态，您会发现什么也没有发生。您可以看到悬停效果，但无法用CSS模拟它的原因是Radium使用JavaScript来应用和移除`style`对象中定义的悬停状态。
- en: 'If you hover over the element with the DevTools open, you can see that the
    `style` string changes and the color gets added to it dynamically:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在打开DevTools的情况下悬停在元素上，您会看到`style`字符串发生变化，并且颜色会动态添加到其中：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The way Radium works is by adding an event handler for each one of the events
    that can trigger the behavior of pseudo-classes and listening to them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Radium的工作方式是为可以触发伪类行为的每个事件添加事件处理程序并监听它们。
- en: As soon as one of the events gets fired, Radium changes the state of the component,
    which re-renders with the right style for the state. This might seem weird in
    the beginning, but there are no real downsides to this approach, and the difference
    regarding performance is not perceivable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦其中一个事件被触发，Radium会改变组件的状态，这将重新呈现具有正确状态样式的组件。这一开始可能看起来很奇怪，但这种方法没有真正的缺点，而且在性能方面的差异是不可感知的。
- en: 'We can add new pseudo-classes, for example,  `:active`, and they will work
    as well:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加新的伪类，例如`:active`，它们也会起作用：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another critical feature that Radium enables is media queries. Media queries
    are crucial for creating responsive applications, and Radium again uses JavaScript
    to enable that CSS feature in our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Radium启用的另一个关键功能是媒体查询。媒体查询对于创建响应式应用程序至关重要，Radium再次使用JavaScript在我们的应用程序中启用了这个CSS特性。
- en: 'Let''s look at how it works – the API is pretty similar; we have to create
    a new attribute on our style object and nest the styles that must be applied when
    the media query matches inside it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的 - API非常相似；我们必须在我们的样式对象上创建一个新属性，并在其中嵌套必须在媒体查询匹配时应用的样式：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is one thing we must do to make media queries work, and that is wrapping
    our application in the  `StyleRoot`  component provided by Radium.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做一件事才能使媒体查询正常工作，那就是将我们的应用程序包装在Radium提供的`StyleRoot`组件中。
- en: For the media queries to work properly, especially  with  server-side rendering,
    Radium will inject the rules related to the media query in a style element inside
    the **Document Object Model** (**DOM**), with all the properties set as  `!important`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使媒体查询正常工作，特别是在服务器端渲染中，Radium将在**文档对象模型**（**DOM**）中注入与媒体查询相关的规则，所有属性都设置为`!important`。
- en: This is to avoid flickering between the different styles that are applied to
    the document before the library figures out which is the matching query. Implementing
    the styles inside a `style` element prevents this by letting the browser do its
    regular job.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了避免在库弄清匹配查询之前应用于文档的不同样式之间闪烁。通过在`style`元素内实现样式，可以通过让浏览器执行其常规工作来防止这种情况。
- en: 'So, the idea is to import the  `Radium.StyleRoot`  component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想法是导入`Radium.StyleRoot`组件：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we can wrap our entire application inside it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将整个应用程序包装在其中：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a result of this, if you open the DevTools, you can see that Radium injected
    the following style into the DOM:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您打开DevTools，您会看到Radium将以下样式注入到DOM中：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `rmq-1d8d7428` class has been applied to the button automatically as well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmq-1d8d7428`类也已自动应用于按钮：'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you now resize the browser window, you can see that the button becomes smaller
    for small screens, as expected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在调整浏览器窗口大小，您会发现按钮在小屏幕上变小，这是预期的。
- en: In the next section, we are going to learn how to use the CSS modules.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用CSS模块。
- en: Using CSS modules
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS模块
- en: If you feel that inline styles are not a suitable solution for your project
    and your team, but you still want to keep the styles as close as possible to your
    components, there is a solution for you, called **CSS modules**. The CSS modules
    are CSS files in which all class names and animation names are scoped locally
    by default. Let's see how we can use them in our projects; but first, we need
    to configure Webpack.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得内联样式不适合您的项目和团队，但仍希望将样式尽可能靠近组件，那么有一个适合您的解决方案，称为**CSS模块**。CSS模块是CSS文件，默认情况下所有类名和动画名称都是本地作用域的。让我们看看如何在我们的项目中使用它们；但首先，我们需要配置Webpack。
- en: Webpack 5
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack 5
- en: Before diving into CSS modules and learning how they work, it is important to
    understand how they were created and the tools that support it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究CSS模块并了解它们的工作原理之前，重要的是要了解它们是如何创建的以及支持它们的工具。
- en: In  *Chapter 2*,  *Cleaning Up Your Code*, we looked at how we can write ES6
    code and transpile it using Babel and its presets. As soon as the application
    grows, you may want to split  your  code base into modules as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章* *清理您的代码*中，我们看到了如何编写ES6代码并使用Babel及其预设进行转译。随着应用程序的增长，您可能还希望将代码库拆分为模块。
- en: You can use Webpack or Browserify to divide the application into small modules
    that you can import whenever you need them, while still creating a big bundle
    for the browser. These tools are called  **module bundlers**, and what they do
    is load all the dependencies of your application into a single bundle that can
    be executed in the browser, which does not have any concept of modules (yet).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Webpack或Browserify将应用程序分成小模块，需要时可以导入它们，同时为浏览器创建一个大捆绑。这些工具被称为**模块捆绑器**，它们的作用是将应用程序的所有依赖项加载到一个可以在浏览器中执行的单个捆绑中，浏览器本身没有任何模块的概念（尚未）。
- en: In the React world, Webpack is especially popular because it offers many interesting
    and useful features, with the first one being the concept of loaders. With Webpack,
    you can potentially load any dependencies other than JavaScript, if there is a
    loader for it. For example, you can load JSON files, as well as images and other
    assets, inside the bundle.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在React世界中，Webpack特别受欢迎，因为它提供了许多有趣和有用的功能，第一个功能是加载器的概念。使用Webpack，您可以潜在地加载除JavaScript以外的任何依赖项，只要有相应的加载器。例如，您可以在捆绑包中加载JSON文件，以及图像和其他资产。
- en: In May 2015, Mark Dalgleish, one of the creators of CSS modules, figured out
    that you could import CSS inside a Webpack bundle as well, and he pushed the concept
    forward. He thought that, since the  CSS  could be imported locally into a component,
    all the imported class names could be locally scoped as well, this is great because
    this will isolate the styles.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年5月，CSS模块的创作者之一Mark Dalgleish发现您也可以在Webpack捆绑包中导入CSS，并推动了这一概念。他认为，由于CSS可以在组件中本地导入，所有导入的类名也可以本地作用域，这很棒，因为这将隔离样式。
- en: Setting up a project
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'In this section, we will look at how to set up a very simple Webpack application,
    using Babel to transpile the JavaScript and the CSS modules to load our locally
    scoped CSS into the bundle. We will also go through all the features of CSS modules
    and look at the problems they can solve. The first thing to do is move to an empty
    folder and run the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何设置一个非常简单的Webpack应用程序，使用Babel来转译JavaScript和CSS模块以将我们的本地作用域CSS加载到捆绑包中。我们还将介绍CSS模块的所有特性并看看它们可以解决的问题。首先要做的是移动到一个空文件夹并运行以下命令：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will create a  `package.json` file with some defaults.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`package.json`文件并设置一些默认值。
- en: 'Now, it is time to install the dependencies, with the first one being `webpack`
    and the second being `webpack-dev-server`, which we will use to run the application
    locally and to create the bundle on the fly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候安装依赖项了，第一个是`webpack`，第二个是`webpack-dev-server`，我们将使用它来在本地运行应用程序并即时创建捆绑包：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once Webpack is installed, it is time to install Babel and its loader. Since
    we are using Webpack to create the bundle, we will use the Babel loader to transpile
    our ES6 code within Webpack itself:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Webpack，就是安装Babel及其加载器的时候了。由于我们使用Webpack来创建捆绑包，我们将使用Babel加载器在Webpack内部转译我们的ES6代码：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we install `style-loader` and the CSS loader, which are the two loaders
    we need to enable the CSS modules:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们安装`style-loader`和CSS加载器，这是我们需要启用CSS模块的两个加载器：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is one more thing to do to make things easier, and that is to install
    `html-webpack-plugin`, which is a plugin that can create an HTML page to host
    our JavaScript application on the fly, just by looking into the Webpack configuration
    and without us needing to create a regular file. Also, we need to install the
    `fork-ts-checker-webpack-plugin` package to make TypeScript work with Webpack:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要做，让事情变得更容易，那就是安装`html-webpack-plugin`，这是一个插件，可以通过查看Webpack配置来即时创建一个HTML页面来托管我们的JavaScript应用程序，而无需我们创建一个常规文件。此外，我们需要安装`fork-ts-checker-webpack-plugin`包来使TypeScript与Webpack一起工作：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Last but not least, we install `react` and `react-dom` to use them in our simple
    example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们安装`react`和`react-dom`来在我们的简单示例中使用它们：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that all the dependencies are installed, it is time to  configure  everything
    to make it work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的依赖都安装好了，是时候配置一切使其工作了。
- en: 'First, you need to create a `.babelrc` file in your root path:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在根路径下创建一个`.babelrc`文件：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first thing to do is add an  `npm`  script in  `package.json`  to run the  `webpack-dev-server`,
    which will serve the application in development:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在`package.json`中添加一个`npm`脚本来运行`webpack-dev-server`，它将在开发中为应用程序提供服务：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Webpack 5, you need to use this way to call `webpack` instead of `webpack-dev-server`
    but you still need to have this package installed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Webpack 5中，您需要使用这种方式调用`webpack`而不是`webpack-dev-server`，但您仍然需要安装这个包。
- en: 'Webpack needs a configuration file to know how to handle the different types
    of dependencies we are using in our application, and to do so, we must create
    a file called `webpack.config.js`, which exports an object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack需要一个配置文件来知道如何处理我们应用程序中使用的不同类型的依赖关系，为此，我们必须创建一个名为`webpack.config.js`的文件，它导出一个对象：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The object we export represents the configuration object used by Webpack to
    create the bundle, and it can have different properties depending on the size
    and the features of the project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出的对象代表Webpack用来创建捆绑包的配置对象，它可以根据项目的大小和特性有不同的属性。
- en: 'We want to keep our example very simple, so we are going to add three attributes.
    The first one is `entry`, which tells Webpack where the main file of our application
    is:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保持我们的示例非常简单，所以我们将添加三个属性。第一个是`entry`，它告诉Webpack我们应用程序的主文件在哪里：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second one is `module`, which is where we tell Webpack how to load the
    external dependencies. It has an attribute called `rules`, where we set a specific
    loader for each one of the file types:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`module`，在那里我们告诉Webpack如何加载外部依赖项。它有一个名为`rules`的属性，我们为每种文件类型设置了特定的加载器：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are saying that the files that match the `.ts` or `.tsx` regular expression
    are loaded using `ts-loader` so that they get transpiled and loaded into the bundle.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说匹配`.ts`或`.tsx`正则表达式的文件将使用`ts-loader`加载，以便它们被转译并加载到捆绑包中。
- en: You may also have noticed that we added our presets in the `.babelrc` file.
    As we saw in  *Chapter 2*,  *Cleaning Up Your Code*,  the presets are sets of
    configuration options that instruct Babel on how to deal with the different types
    of syntax (for example, TSX).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到我们在`.babelrc`文件中添加了我们的预设。正如我们在*第2章*中看到的*清理您的代码*，预设是一组配置选项，指示Babel如何处理不同类型的语法（例如TSX）。
- en: The second entry in the `rules` array tells Webpack what to do when a CSS file
    is imported, and it uses `css-loader` with the `modules` flag enabled to activate
    CSS modules. The result of the transformation is then passed to `style-loader`,
    which injects the styles into the header of the page.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`rules`数组中的第二个条目告诉Webpack在导入CSS文件时该怎么做，并且它使用`css-loader`和启用`modules`标志来激活CSS模块。转换的结果然后传递给`style-loader`，它将样式注入到页面的头部。'
- en: 'Finally, we enable the HTML plugin to generate the page for us, adding the
    `script` tag automatically using the entry path we specified earlier:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启用HTML插件来为我们生成页面，自动使用我们之前指定的入口路径添加`script`标签：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The complete `webpack.config.js` should be as shown in the following code block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`webpack.config.js`应该如下代码块所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, to configure TypeScript, you need this `tsconfig.json` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要配置TypeScript，您需要这个`tsconfig.json`文件：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order to import `css` files using TypeScript, you need to create a declarations
    file at `src/declarations.d.ts`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用TypeScript导入`css`文件，您需要在`src/declarations.d.ts`中创建一个声明文件：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, you need to create the main file at `src/index.tsx`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要在`src/index.tsx`中创建主文件：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, you need to create the initial HTML file at `src/index.html`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在`src/index.html`中创建初始HTML文件：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are done, and if we run the `npm run dev` command in the terminal and point
    the browser to `http://localhost:8080`, we should be able to see the following
    markup being served:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了，如果我们在终端中运行`npm run dev`命令并将浏览器指向`http://localhost:8080`，我们应该能够看到提供的以下标记：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Perfect – our React application is working! Let's see now how we can add some
    CSS to our project.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完美-我们的React应用程序正在运行！现在让我们看看如何向我们的项目添加一些CSS。
- en: Locally scoped CSS
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地作用域的CSS
- en: Now, it is time to create our app, which will consist of a  simple button, of
    the same sort we used in previous examples. We will use it to show all the features
    of the CSS modules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建我们的应用程序了，它将由一个简单的按钮组成，与我们在以前的示例中使用的相同类型。我们将用它来展示CSS模块的所有功能。
- en: 'Let''s update the `src/index.tsx`  file, which is the entry we specified in
    the Webpack configuration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`src/index.tsx`文件，这是我们在Webpack配置中指定的入口：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then create a simple button. As usual, we are going to start with a
    non-styled button, and we will add the styles step by step:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个简单的按钮。像往常一样，我们将从一个非样式化的按钮开始，然后逐步添加样式：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we can render the button into the DOM:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将按钮呈现到DOM中：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, suppose we want to apply some styles to the button – a background color,
    the size, and so on. We create a regular CSS file, called  `index.css`, and we
    put the following class into it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要为按钮应用一些样式-背景颜色，大小等。我们创建一个名为`index.css`的常规CSS文件，并将以下类放入其中：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we said that with CSS modules we could import the CSS files into the JavaScript;
    let's look at how it works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们说过使用 CSS 模块可以将 CSS 文件导入到 JavaScript 中；让我们看看它是如何工作的。
- en: 'Inside our  `index.js` file where we defined the button component, we can add
    the following line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义按钮组件的 `index.js` 文件中，我们可以添加以下行：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The result of this  `import`  statement is a `styles` object, where all the
    attributes are the classes defined in `index.css`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `import` 语句的结果是一个 `styles` 对象，其中所有属性都是在 `index.css` 中定义的类。
- en: 'If we run  `console.log(styles)`, we can see the following object in the DevTools:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 `console.log(styles)`，我们可以在 DevTools 中看到以下对象：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, we have an object where the attributes are the class names and the values
    are (apparently) random strings. We will see later that they are non-random, but
    let's check what we can do with that object first.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个对象，其中属性是类名，值是（表面上）随机字符串。我们稍后会看到它们并非随机，但让我们先检查一下该对象可以做什么。
- en: 'We can use the object to set the class name attribute of our button, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用对象来设置按钮的类名属性，如下所示：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we go back to the browser, we can now see that the styles we defined in
    `index.css`  have been applied to the button. This is not magic, because if we
    check in DevTools, the class that has been applied to the element is the same
    string that''s attached to the `style` object we imported inside our code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到浏览器，现在可以看到我们在 `index.css` 中定义的样式已经应用到按钮上。这并不是魔术，因为如果我们在 DevTools 中检查，应用到元素的类与我们在代码中导入的
    `style` 对象附加的相同字符串。
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we look at the header section of the page, we can now see that the same
    class name has also been injected into the page:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看页面的头部部分，现在可以看到相同的类名也已经被注入到页面中：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is how the CSS and the style loaders work.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 CSS 和样式加载器的工作原理。
- en: The CSS loader lets you import the CSS files into your JavaScript modules and,
    when the module flag is activated, all the class names are locally scoped to the
    module they are imported into. As we mentioned previously, the string we imported
    was non-random, but it is generated using the hash of the file and some other
    parameters in a way that is unique within the code base.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 加载器允许您将 CSS 文件导入到您的 JavaScript 模块中，并且当模块标志被激活时，所有类名都会被局部作用于导入的模块。正如我们之前提到的，我们导入的字符串并非随机，而是使用文件的哈希和一些其他参数生成的，以在代码库中是唯一的。
- en: Finally, `style-loader` takes the result of the CSS module's transformation
    and injects the styles inside the header section of the page. This is very powerful
    because we have the full power and expressiveness of the CSS, combined with the
    advantages of having locally scoped class names and explicit dependencies.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`style-loader` 接受 CSS 模块转换的结果，并将样式注入到页面的头部部分。这非常强大，因为我们拥有 CSS 的全部功能和表现力，同时又具有局部作用域类名和明确依赖项的优势。
- en: As mentioned at the beginning of this chapter, CSS is global, and that makes
    it very hard to maintain in large applications. With CSS modules, class names
    are locally scoped and they cannot clash with other class names in different parts
    of the application, enforcing a deterministic result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头提到的，CSS 是全局的，这使得在大型应用程序中很难维护。使用 CSS 模块，类名是局部作用域的，它们不会与应用程序不同部分的其他类名冲突，从而强制产生确定性结果。
- en: Moreover, explicitly importing the CSS dependencies inside our components helps
    us see clearly which components need which CSS. It is also very useful for eliminating
    dead code because when we delete a component for any reason, we can tell exactly
    which CSS it was using.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，明确地在组件内部导入 CSS 依赖项有助于清晰地看到哪些组件需要哪些 CSS。它还非常有用，可以消除死代码，因为当我们出于任何原因删除一个组件时，我们可以准确地知道它使用的是哪些
    CSS。
- en: CSS modules are regular CSS, so we can use pseudo-classes, media queries, and
    animations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: CSS模块是常规的CSS，因此我们可以使用伪类、媒体查询和动画。
- en: 'For example, we can add CSS rules such as the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以添加以下CSS规则：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will be transformed into the following code and injected into the document:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换为以下代码并注入到文档中：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The class names get created and they get replaced everywhere the button is used,
    making it reliable and local, as expected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 类名被创建并在按钮使用的所有地方被替换，使其可靠且本地化，正如预期的那样。
- en: As you may have noticed, those class names are great, but they make debugging
    pretty  hard  because we cannot easily tell which classes generated the hash.
    What we can do in development mode is add a special configuration parameter, with
    which we can choose the pattern that's used to produce the scoped class names.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些类名很棒，但它们使调试变得非常困难，因为我们无法轻松地知道哪些类生成了哈希。在开发模式下，我们可以添加一个特殊的配置参数，通过它我们可以选择用于生成作用域类名的模式。
- en: 'For example, we can change the value of the loader as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将加载程序的值更改如下：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here,  `localIdentName`  is the parameter, and  `[local]`  and  `[hash:base64:5]`  are
    placeholders for the original class name value and a five-character hash. Other
    available placeholders are `[path]`, which represents the path of the CSS file,
    and `[name]`, which is the name of the source CSS file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`localIdentName`是参数，`[local]`和`[hash:base64:5]`是原始类名值和五个字符哈希的占位符。其他可用的占位符是`[path]`，代表CSS文件的路径，以及`[name]`，代表源CSS文件的名称。
- en: 'Activating the previous configuration option, the result we have in the browser
    is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 激活之前的配置选项，我们在浏览器中得到的结果如下：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is way more readable and easier to debug.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更易读，更容易调试。
- en: In production, we do not need class names like this, and we are more interested
    in performance, so we may want shorter class names and hashes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们不需要这样的类名，我们更关心性能，因此我们可能希望更短的类名和哈希。
- en: With Webpack, it is pretty straightforward  because  we can have multiple configuration
    files that can be used in the different stages of our application life cycle.
    Also, in production, we may want to extract the CSS file instead of injecting
    it into the browser from the bundle so that we can have a lighter bundle and cache
    the CSS on a Content Delivery Network for better performance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Webpack非常简单，因为我们可以有多个配置文件，可以在应用程序生命周期的不同阶段使用。此外，在生产环境中，我们可能希望提取CSS文件，而不是将其从捆绑包中注入到浏览器中，以便我们可以获得更轻的捆绑包，并将CSS缓存到内容交付网络以获得更好的性能。
- en: To do that, you need to install another Webpack plugin, called `mini-css-extract-plugin`,
    which can write an actual CSS file, putting in all the scoped classes that were
    generated from CSS modules.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您需要安装另一个Webpack插件，称为`mini-css-extract-plugin`，它可以编写一个实际的CSS文件，其中包含从CSS模块生成的所有作用域类。
- en: There are a couple of features of CSS modules that are worth mentioning.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个值得一提的CSS模块特性。
- en: The first one is the  `global`  keyword. Prefixing  any  class  with  `:global`,
    in fact, means asking CSS modules not to scope the current selector locally.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`global`关键字。实际上，用`:global`作为任何类的前缀意味着要求CSS模块不要在本地范围内对当前选择器进行范围限定。
- en: 'For example, let''s say we change our CSS as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们将CSS更改如下：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is good if you want to apply styles that cannot be scoped locally, such
    as third-party widgets.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想应用无法在本地范围内进行范围限定的样式，例如第三方小部件，这是很好的。
- en: My favorite feature of CSS modules is  **composition**. With composition, we
    can extract classes from the same file or external dependencies and get all the
    styles applied to the element.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: CSS模块的我最喜欢的特性是**组合**。通过组合，我们可以从同一文件或外部依赖中提取类，并将所有样式应用于元素。
- en: 'For example, extract the rule to set the background to red from the rules for
    the button into a separate block, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将将按钮的背景设置为红色的规则从按钮的规则中提取到一个单独的块中，如下所示：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then compose it inside our button in the following way:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式在我们的按钮中进行组合：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The result is that all the rules of the button and all the rules of the  `composes`  declaration
    are applied to the element.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是按钮的所有规则和`composes`声明的所有规则都应用于元素。
- en: This is a very powerful feature and it works in a fascinating way. You might
    expect that all the composed classes are duplicated inside the classes  where  they
    are referenced as SASS  `@extend`  does, but that is not the case. Simply put,
    all the composed class names are applied one after the other on the component
    in the DOM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的功能，它以一种迷人的方式工作。你可能期望所有组合的类在被引用为SASS `@extend`时会在类内部重复，但事实并非如此。简而言之，所有组合的类名都会依次应用于DOM中的组件。
- en: 'In our specific case, we would have the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定情况下，我们会有以下情况：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, the CSS that is injected into the page is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注入到页面中的CSS如下：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, our CSS class names have unique names, which is good to isolate
    our styles. Now, let's take a look at the Atomic CSS modules.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的CSS类名具有唯一的名称，这有利于隔离我们的样式。现在，让我们来看看原子CSS模块。
- en: Atomic CSS modules
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子CSS模块
- en: It should be clear how composition works and why it is a  very  powerful feature
    of CSS modules. At YPlan, the company where I worked when I started writing this
    book, we tried to push it a step further, combining the  power  of  `composes`  with
    the flexibility of  **Atomic CSS**  (also known as  **Functional CSS**).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚组合是如何工作的，以及为什么它是CSS模块的一个非常强大的特性。在我开始写这本书的时候工作的公司YPlan中，我们试图将其推向更高一步，结合`composes`的强大功能和**原子CSS**（也称为**功能性CSS**）的灵活性。
- en: Atomic CSS is a way to use CSS where every class has a single rule.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 原子CSS是一种使用CSS的方式，其中每个类都有一个单一的规则。
- en: 'For example, we can create a class to set `margin-bottom`  to `0`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个类来将`margin-bottom`设置为`0`：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can use another one to set `font-weight` to `600`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个类将`font-weight`设置为`600`：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, we can apply all those atomic classes to the elements:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将所有这些原子类应用于元素：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This technique is controversial and particularly efficient at the same time.
    It is hard to start using it because you end up having too many classes in your
    markup, which makes it hard to predict the final result. If you think about it,
    it is pretty similar to inline styles, because you apply one class per rule, apart
    from the fact that you are using a shorter class name as a proxy.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术既有争议，又非常高效。开始使用它很困难，因为最终会在标记中有太多的类，这使得难以预测最终结果。如果你仔细想想，它与内联样式非常相似，因为你每条规则应用一个类，除了你使用更短的类名作为代理。
- en: The biggest argument against Atomic CSS is usually that you are moving the styling
    logic from the CSS to the markup, which is wrong. Classes are defined in CSS files,
    but they are composed in the views, and every time you have to modify the style
    of an element, you end up editing the markup.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 反对原子CSS的最大论点通常是你将样式逻辑从CSS移动到标记中，这是错误的。类是在CSS文件中定义的，但它们在视图中组合，每当你必须修改元素的样式时，你最终会编辑标记。
- en: On the other hand, we tried using Atomic CSS for a bit and we found that it
    makes prototyping incredibly fast.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们尝试使用原子CSS一段时间，发现它使原型设计变得非常快速。
- en: In fact, when all the base rules have been generated, applying those classes
    to the elements and creating new styles is a very quick process, which is good.
    Second, using Atomic CSS, we can control the size of the CSS file, because as
    soon as we create new components with their styles, we are using existing classes
    and we do not need to create new ones, which is great for performance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当所有基本规则都已生成时，将这些类应用到元素并创建新样式是一个非常快速的过程，这是很好的。其次，使用原子CSS，我们可以控制CSS文件的大小，因为一旦我们创建了具有其样式的新组件，我们就使用现有的类，而不需要创建新的类，这对性能来说非常好。
- en: So, we tried to solve the problems of  Atomic  CSS using CSS modules and we
    called the technique  **Atomic CSS modules**.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们尝试使用CSS模块解决原子CSS的问题，并将这种技术称为**原子CSS模块**。
- en: In essence, you start creating your base CSS classes (for example, `mb0`), and
    then, instead of applying the class names one by one in the markup, you compose
    them into placeholder classes using CSS modules.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，您开始创建您的基本CSS类（例如，`mb0`），然后，而不是在标记中逐个应用类名，您可以使用CSS模块将它们组合成占位符类。
- en: 'Let''s look at an example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here''s another example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is great because you still keep the styling logic inside the CSS, and the
    CSS module's  `composes`  does the job for you by applying all the single classes
    in the markup.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为您仍然将样式逻辑保留在CSS中，而CSS模块的`composes`会通过在标记中应用所有单个类来为您完成工作。
- en: 'The result of the preceding code is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, `title`, `mb0`, and `fw6` are all applied automatically to the element.
    They are scoped locally as well, so we have all the advantages of CSS modules.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`title`，`mb0`和`fw6`都会自动应用到元素上。它们也是局部作用域的，因此我们拥有CSS模块的所有优势。
- en: React CSS modules
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React CSS模块
- en: Last but not least, there is a great library that can help us work with CSS
    modules. You may have noticed how we were using a `style` object to load all the
    classes of the CSS, and because JavaScript does not support hyphenated attributes,
    we are forced to use a camelCased class name.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有一个很棒的库可以帮助我们使用CSS模块。您可能已经注意到，我们使用`style`对象来加载CSS的所有类，因为JavaScript不支持连字符属性，我们被迫使用驼峰命名的类名。
- en: Also, if we are referencing a class name that does not exist in the CSS file,
    there is no way to know it, and  `undefined`  is added to the list of classes.
    For these and other useful features, we may want to try a package that makes working
    with CSS modules even smoother.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们引用了CSS文件中不存在的类名，就无法知道它，`undefined`会被添加到类名列表中。出于这些和其他有用的功能，我们可能想尝试一个使使用CSS模块更加顺畅的包。
- en: Let's look at what this means by going back to the  `index.tsx` file we were
    using previously in this section with plain CSS modules, and changing it to use
    React CSS modules instead.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回到我们在本节中之前使用普通CSS模块的`index.tsx`文件，将其更改为使用React CSS模块来看看这意味着什么。
- en: 'The package is called  `react-css-modules`, and the first thing we must do
    is install it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该包名为`react-css-modules`，我们首先必须安装它：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the package is installed, we import it inside our `index.tsx` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，我们在`index.tsx`文件中导入它：
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We use it as an HOC, passing to it the `Button` component we want to enhance
    and the `styles` object we imported from the CSS:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其作为HOC使用，将要增强的`Button`组件和我们从CSS中导入的`styles`对象传递给它：
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, we have to change the implementation of the button to  avoid  using the
    `styles` object. With React CSS modules, we use the  `styleName`  property, which
    is transformed into a regular class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须改变按钮的实现，避免使用`styles`对象。使用React CSS模块，我们使用`styleName`属性，它会转换为常规类。
- en: 'The great thing about this is that we can use the class name as a string (for
    example,  `"button"`):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，我们可以将类名作为字符串使用（例如，`"button"`）：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we now render `EnhancedButton`  into the DOM, we will see that nothing has
    really changed from before, which means that the library works.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将 `EnhancedButton` 渲染到 DOM 中，我们会发现与之前相比，实际上没有什么变化，这意味着库是有效的。
- en: 'Let''s say we try to change the  `styleName`  property to reference a non-existing
    class name, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试将 `styleName` 属性更改为引用一个不存在的类名，如下所示：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will see the following error in the console of the browser by doing so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将在浏览器的控制台中看到以下错误：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is particularly helpful when the code base grows and we have multiple developers
    working on different components and styles.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码库不断增长，我们有多个开发人员在不同的组件和样式上工作时，这将特别有帮助。
- en: Implementing styled-components
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 styled-components
- en: There is a library that is very promising because it takes into account all
    the problems other libraries have encountered in styling components. Different
    paths have been followed for writing  CSS  in JavaScript, and many solutions have
    been tried, so now the time is ripe for a library that takes all the learning
    and then builds something on top of it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有前途的库，因为它考虑了其他库在样式化组件方面遇到的所有问题。已经有了不同的路径来编写 JavaScript 中的 CSS，并且尝试了许多解决方案，因此现在是时候使用所有这些经验教训来构建一个库了。
- en: 'The library is conceived and maintained by two popular developers in the JavaScript
    community:  *Glenn Maddern*  and  *Max Stoiberg*. It represents a very modern
    approach to the problem, and it uses edge features of ES2015 and some advanced
    techniques that have been applied to React to provide a complete solution for
    styling.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该库由 JavaScript 社区中两位知名的开发人员 *Glenn Maddern* 和 *Max Stoiberg* 构思和维护。它代表了解决问题的一种非常现代的方法，并且使用了
    ES2015 的边缘功能和一些已应用于 React 的高级技术，为样式提供了一个完整的解决方案。
- en: Let's look at how it is possible to create the same button we saw in the previous
    sections, and check whether all the CSS features we are interested in (for example,
    pseudo-classes and media queries) work with `styled-components`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建与前几节中看到的相同的按钮，并检查我们感兴趣的所有 CSS 特性（例如伪类和媒体查询）是否与 `styled-components`
    一起工作。
- en: 'First, we have to install the library by running the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须通过运行以下命令来安装该库：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Once the library is installed, we have to import it inside our component''s
    file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 安装库后，我们必须在组件文件中导入它：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: At that point, we can use the `styled` function to create  any  element by using  `styled.elementName`,
    where  `elementName`  can be a  `div`, a button, or any other valid DOM element.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在那时，我们可以使用 `styled` 函数通过 `styled.elementName` 来创建任何元素，其中 `elementName` 可以是 `div`、按钮或任何其他有效的
    DOM 元素。
- en: The second thing to do is to define the style of the element  we  are creating
    and to do so, we use  an ES6 feature called **t****agged template literals**,
    which is a way of passing template strings to a function without them being interpolated
    beforehand.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事是定义我们正在创建的元素的样式，为此，我们使用了一个名为 **tagged template literals** 的 ES6 特性，这是一种在不被插值的情况下将模板字符串传递给函数的方法。
- en: This means that the function receives the actual template with all the JavaScript
    expressions, and this makes the library able to use the full power of JavaScript
    to apply the styles to the elements.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数接收到了包含所有 JavaScript 表达式的实际模板，这使得库能够充分利用 JavaScript 的全部功能来应用样式到元素上。
- en: 'Let''s start by creating a simple button with a basic styling:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个带有基本样式的简单按钮开始：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This *kind-of-weird* syntax returns a proper React component called  `Button`,  which
    renders a button element and applies to it all the styles defined in the template.
    The way the styles are applied is by creating a unique class name, adding it to
    the element, and then injecting the corresponding style in the head of the document.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*有点奇怪*的语法返回一个名为`Button`的合适的React组件，它渲染一个按钮元素，并将模板中定义的所有样式应用于它。样式的应用方式是创建一个唯一的类名，将其添加到元素中，然后将相应的样式注入到文档的头部。
- en: 'The following is the component that gets rendered:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是被渲染的组件：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The style that gets added to the page is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到页面的样式如下：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The good thing about `styled-components` is that it supports almost all the
    features of CSS, which makes it a good candidate to be used in a real-world application.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-components`的好处是它支持几乎所有CSS的功能，这使它成为在实际应用中使用的一个很好的选择。'
- en: 'For example, it supports pseudo-classes using a SASS-like syntax:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它使用类似SASS的语法支持伪类：
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It also supports media queries:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持媒体查询：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There are many other features that this library can bring to your project.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库还有许多其他功能可以为您的项目带来。
- en: For example, once you have created the button, you can easily override its styles
    and use it multiple times with different properties. Inside the templates, it
    is also possible to use the props that the component received and change the style
    accordingly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一旦您创建了按钮，就可以轻松地覆盖其样式，并多次使用具有不同属性的按钮。在模板内，还可以使用组件接收到的props，并相应地更改样式。
- en: Another great feature is  **theming**. Wrapping your  components  in a `ThemeProvider`
    component, you can inject a theme property down to the three component's children,
    which makes it extremely easy to create UIs where part of the style is shared
    between components and some other properties depend on the currently selected
    theme.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的功能是**主题**。将您的组件包装在`ThemeProvider`组件中，您可以向三个组件的子组件注入一个主题属性，这样就可以轻松地创建UI，其中一部分样式在组件之间共享，而另一些属性取决于当前选择的主题。
- en: No doubt `styled-components` library is a game-changer when you are taking your
    styles to the next level, at the beginning could seem weird because the way is
    implementing styles with components, but once you get used to I guarantee will
    be your favorite styles package.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`styled-components`库在将样式提升到下一个级别时是一个改变游戏规则的工具，在开始时可能会感觉有点奇怪，因为它是通过组件实现样式，但一旦您习惯了，我保证它会成为您最喜欢的样式包。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a lot of interesting topics. We started by going
    through the problems of CSS at scale, specifically, the problems that they had
    at Facebook while dealing with CSS. We learned how inline styles work in React
    and why it is good to co-locate the styles within components. We also looked at
    the limitations of inline styles. Then, we moved on to Radium, which solves the
    main problems of inline styles, giving us a clear interface to write our CSS in
    JavaScript. For those who think that inline styles are a bad solution, we moved
    into the world of CSS modules, setting up a simple project from scratch.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了许多有趣的话题。我们首先讨论了在规模上使用CSS时遇到的问题，具体来说，Facebook在处理CSS时遇到的问题。我们了解了在React中如何使用内联样式，以及为什么将样式与组件共同定位是有益的。我们还看了内联样式的局限性。然后，我们转向了Radium，它解决了内联样式的主要问题，为我们提供了一个清晰的接口来在JavaScript中编写CSS。对于那些认为内联样式是一个不好的解决方案的人，我们进入了CSS模块的世界，从零开始设置了一个简单的项目。
- en: Importing the CSS files into our components makes the dependencies clear, and
    scoping the class names locally avoids clashes. We looked at how CSS module's
    `composes`  is a great feature, and how we can use it in conjunction with Atomic
    CSS to create a framework for quick prototyping.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将CSS文件导入到我们的组件中可以清晰地表明依赖关系，而在本地范围内命名类名可以避免冲突。我们看到了CSS模块的`composes`是一个很棒的功能，以及我们如何可以将其与原子CSS结合使用，创建一个快速原型的框架。
- en: Finally, we had a quick look at `styled-components`, which is a very promising
    library and is meant to change the way we approach the styling of components  completely.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要地看了一下`styled-components`，这是一个非常有前途的库，旨在彻底改变我们处理组件样式的方式。
- en: So far, you have learned about a lot of ways to work with CSS styles with React
    from inline styles to CSS modules or using a library such as `styled-components`.
    In the next chapter, we are going to learn how to implement and get the benefits
    from server-side rendering.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了许多在React中使用CSS样式的方法，从内联样式到CSS模块，或者使用诸如`styled-components`之类的库。在下一章中，我们将学习如何实现并从服务器端渲染中获益。
