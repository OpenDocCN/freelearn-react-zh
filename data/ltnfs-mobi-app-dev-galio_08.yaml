- en: '*Chapter 8*: Creating Your Own Custom Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：创建您自己的自定义组件'
- en: After getting through all these lessons, we're now ready for more practical
    challenges, which are going to get us ready for creating fully-fledged React Native
    applications. We've touched upon all the basic and a bit more advanced information,
    so we're prepared to take on more difficult challenges.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些课程的学习，我们现在准备好迎接更多实际挑战，这将使我们为创建完整的React Native应用做好准备。我们已经接触了所有基本和一些更高级的信息，所以我们准备好迎接更困难的挑战。
- en: In this chapter, we're going through four different exercises. The first one
    is going to be a simple exercise where we're going to use Galio's components to
    create new ones that'll fit our imaginary app. Doing this will once again prove
    to us how helpful Galio can be for almost all of our programming needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行四个不同的练习。第一个将是一个简单的练习，我们将使用Galio的组件来创建新的组件，以适应我们想象中的应用程序。这样做将再次向我们证明Galio对于几乎所有编程需求都有多大帮助。
- en: After that, we're going to create our own profile card. This exercise will mostly
    focus on layout and styling, as I feel this is a really important part of any
    app creation. Learning this will get us one step closer to creating the app of
    our dreams because nowadays, almost every app has a profile screen or card included
    somewhere.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建自己的个人资料卡。这个练习将主要关注布局和样式，因为我觉得这是任何应用程序创建的一个非常重要的部分。学会这个将使我们离梦想中的应用程序更近一步，因为如今几乎每个应用程序都在某个地方包含个人资料屏幕或卡。
- en: The next exercise will deal with controlled inputs. On top of creating a simple
    registration form and styling it to the best of our abilities, we'll also understand
    how state is necessary when working with inputs or forms in general.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习将涉及受控输入。除了创建一个简单的注册表单并尽力进行样式设置之外，我们还将了解在处理输入或一般表单时状态是必要的。
- en: The final challenge for us will be creating an e-commerce card. This will serve
    as proof of the fact that almost anything can be created by figuring out how it's
    similar to something you've already created. This is the moment where we can understand
    that having experience in a field will definitely help in another field. No experience
    is useless; everything helps us grow as a better human being overall.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终挑战将是创建一个电子商务卡。这将证明几乎任何东西都可以通过弄清楚它与您已经创建的某些东西的相似之处来创建。这是我们可以理解在一个领域有经验肯定会在另一个领域有所帮助的时刻。没有经验是无用的；一切都帮助我们成为更好的人。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating your own component!
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的组件！
- en: Creating your own profile card
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的个人资料卡
- en: Creating your own register form
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的注册表单
- en: Building your e-commerce cards
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建您的电子商务卡
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 08` that contains all the code we've written
    inside this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问GitHub [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)
    查看本章的代码。您将找到一个名为“第8章”的文件夹，其中包含本章中编写的所有代码。为了使用该项目，请按照“README.md”文件中的说明进行操作。
- en: Creating your own component!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的组件！
- en: Now that we've gotten through all the basic knowledge about how React and React
    Native work, it's time to put our skills to the test by creating a lot of different
    components. Worry not—we're also going to create a bigger and more complex app.
    But as you know, a React application is formed from lots of different components,
    so by creating components, we're actually getting ready to create apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了React和React Native的基本知识，是时候通过创建许多不同的组件来测试我们的技能了。不用担心，我们也将创建一个更大更复杂的应用程序。但是你知道，一个React应用程序是由许多不同的组件组成的，所以通过创建组件，我们实际上是在准备创建应用程序。
- en: I was thinking that for our first component, we should start with a news card.
    This would usually go straight to the news feed—we'd use multiple components like
    this with different text if we were to create a news app. So, how do we start?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我在想，对于我们的第一个组件，我们应该从一个新闻卡开始。这通常会直接进入新闻动态，如果我们要创建一个新闻应用程序，我们会使用多个类似的组件来显示不同的文本。那么，我们该如何开始呢？
- en: 'Just like we usually do, create an app with the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们通常做的那样，用以下命令创建一个应用程序：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're going to use the same app for all our exercises in this chapter because
    it's a lot easier than creating a project for each of them. So, right after the
    project has been created, let's open it up and then open our `App.js` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有练习中，我们将使用相同的应用程序，因为这比为每个练习创建一个项目要容易得多。因此，在创建项目后，让我们打开它，然后打开我们的`App.js`文件。
- en: Now, we're going to create a new `components` folder inside our root folder.
    Here, we're going to start developing our own components. At the end of this chapter,
    you should have four files inside this folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要在根文件夹内创建一个新的`components`文件夹。在这里，我们将开始开发我们自己的组件。在本章结束时，你应该在这个文件夹里有四个文件。
- en: 'Because we''re going to use Galio for creating our component''s layout, we
    should install it now via the terminal. Remember the command we''re using for
    installing external packages? We''re going to use the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用Galio来创建我们组件的布局，所以我们现在应该通过终端安装它。记住我们用于安装外部包的命令吗？我们将使用以下命令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's create a new file called `NewsCard.js` inside our `components` folder.
    Because we're creating a news feed type of component, we need to think of what
    exactly we would need to use inside this component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`components`文件夹内创建一个名为`NewsCard.js`的新文件。因为我们正在创建一个新闻动态类型的组件，我们需要考虑在这个组件内部究竟需要使用什么。
- en: We know for sure that we need `StyleSheet` for the styles and the `Block` component
    from **Galio**. But we also need a `Text` component for rendering the text and
    an `Icon` component, so that we'll be able to have some sort of icon. I feel that
    every post should also have an avatar, so an `Image` component is also required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定需要`StyleSheet`来设置样式和来自**Galio**的`Block`组件。但是我们还需要一个`Text`组件来渲染文本，以及一个`Icon`组件，这样我们就能够拥有某种图标。我觉得每篇帖子也应该有一个头像，所以还需要一个`Image`组件。
- en: 'So, our imports should now look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的导入现在应该是这样的：
- en: '![Figure 8.1 – Imports used for our NewsCard component'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 用于我们的NewsCard组件的导入'
- en: '](Images/Figure_8.01_B17074.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.01_B17074.jpg)'
- en: Figure 8.1 – Imports used for our NewsCard component
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 用于我们的NewsCard组件的导入
- en: Now that we know what we're going to use inside our component, let's start building
    it piece by piece. We'll start by creating a functional component named `NewsCard`.
    This function is going to return, for now, just a `Block` element and a `Text`
    element in order to have something to be rendered.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在组件内部要使用的东西，让我们一步一步地开始构建它。我们将首先创建一个名为`NewsCard`的函数组件。这个函数暂时只会返回一个`Block`元素和一个`Text`元素，以便有一些东西可以被渲染出来。
- en: 'We''ll also create a `styles` object at the end of the file. Remember how we
    were supposed to do that? Nice! Let''s create a style called `card` for our main
    `Block` component. For the styling, I was thinking of adding something new that
    we haven''t discussed until now: shadows.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在文件末尾创建一个`styles`对象。还记得我们应该这样做吗？很好！让我们为我们的主`Block`组件创建一个名为`card`的样式。在样式方面，我想添加一些新的东西，这是我们到目前为止还没有讨论过的：阴影。
- en: 'Shadows are really not that hard to use but I feel that some people might not
    really understand how those work. After adding the style, let''s take a look at
    what our component looks like up to now:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影实际上并不难使用，但我觉得有些人可能真的不明白它是如何工作的。在添加样式之后，让我们来看看我们的组件到目前为止是什么样子的：
- en: '![Figure 8.2 – The beginning of our first component'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 我们第一个组件的开始'
- en: '](Images/Figure_8.02_B17074.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.02_B17074.jpg)'
- en: Figure 8.2 – The beginning of our first component
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 我们第一个组件的开始
- en: 'So, everything should look fairly simple to understand at this point. The shadows
    here are the only topic we haven''t really explored, but the styling should be
    self-explanatory. First, we have `shadowColor`, to which we''ve assigned `#000`,
    which is black. Then we have `shadowOffset`, which is telling our shadow how to
    fall down from the object we''ve been assigning it to. If things still seem a
    bit confusing, we should think about `width` and `height` values like this: `width`
    is the *x* axis and `height` is the *y* axis. Saying `width: 0` means that our
    shadow is expected to fall down straight to the ground underneath the object,
    but combining it with `height: 2` will tell our shadow to drop down 2 **pixels**
    (**px**) from the center. Then, we have `shadowOpacity`, which does what you''d
    expect it to do: it calculates the opacity of our shadow. You''ve probably noticed
    `elevation`; this is what you''re using to set the shadow for Android devices,
    and it only is supported on Android 5.0+.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '所以，到目前为止，一切看起来应该相当简单易懂。这里的阴影是我们真正探讨过的唯一主题，但样式应该是不言自明的。首先，我们有`shadowColor`，我们已经分配了`#000`，也就是黑色。然后我们有`shadowOffset`，它告诉我们的阴影如何从我们一直分配给它的对象上落下来。如果事情看起来仍然有点混乱，我们应该像这样考虑`width`和`height`的值：`width`是*x*轴，`height`是*y*轴。说`width:
    0`意味着我们的阴影预计会直接落到对象下面的地面上，但将其与`height: 2`结合使用将告诉我们的阴影从中心向下掉落2个像素(**px**)。然后，我们有`shadowOpacity`，它做你期望它做的事情：计算我们阴影的不透明度。你可能已经注意到了`elevation`；这是你用来为Android设备设置阴影的，它只支持Android
    5.0+。'
- en: Now that we've set the basis of our new component, let's import it to `App.js`
    so that we can see our changes in real time. So, let's open up the file and delete
    everything inside the `main` function besides the main `View` component. Keep
    the styles—I love having everything centered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了新组件的基础，让我们将其导入到`App.js`中，这样我们就可以实时看到我们的更改。因此，让我们打开文件并删除`main`函数内除了主`View`组件之外的所有内容。保留样式
    - 我喜欢一切都居中。
- en: 'Now, let''s import our newly created component and render it on the screen.
    We''ll go right below our main imports and write the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导入我们新创建的组件并在屏幕上呈现它。我们将在主要导入的下方编写以下代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we''ve imported the component, place it inside the `View` component
    like this: `<NewsCard />`. Start up the Expo server, open the simulator, and you
    should be able to see the card with the text **News Card** on it. Great! Now,
    we can work on it—save the file and see the changes in real time.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了组件，将其放在`View`组件内，像这样：`<NewsCard />`。启动Expo服务器，打开模拟器，你应该能够看到带有文本**News
    Card**的卡片。太棒了！现在，我们可以开始工作了 - 保存文件并实时查看更改。
- en: Eventually, we'll add each component we're creating in our `App.js` file. This
    should be a pretty easy workflow to test our components visually.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将在我们的`App.js`文件中添加我们创建的每个组件。这应该是一个非常简单的工作流程，可以用来测试我们的组件视觉效果。
- en: Now, let's go back to our `NewsCard.js` file and start creating the basic layout.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的“NewsCard.js”文件，并开始创建基本布局。
- en: 'We''ll start by arranging the layout with `Block` components, so we''ll use
    two of these. The first one is for the header of our card, which will contain
    the `bookmark` icon to the far right of the card, and to the left side, we''ll
    have the avatar and information about the author. The second one is for the title
    of the news article and a summary of the text. Let''s see how that looks right
    now by putting it into practice, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用“Block”组件来安排布局开始，所以我们将使用两个。第一个是用于卡片的标题，其中将包含卡片的最右边的“书签”图标，左侧将有头像和关于作者的信息。第二个是用于新闻文章的标题和文本摘要。让我们看看通过实践它看起来如何：
- en: '![Figure 8.3 – Coding the basic layout'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 编写基本布局'
- en: '](Images/Figure_8.03_B17074.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.03_B17074.jpg)'
- en: Figure 8.3 – Coding the basic layout
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 编写基本布局
- en: 'So, as far as you can see, for `title`, `summary`, `author`, and `date`, we''ll
    be using `props`. As for `Avatar`, right now we''ll be using a `Text` component
    as a placeholder. So, let''s save and move to our `App.js` file to finish sending
    all the props back to our `NewsCard` component, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就像你看到的那样，对于“title”、“summary”、“author”和“date”，我们将使用“props”。至于“Avatar”，现在我们将使用一个“Text”组件作为占位符。所以，让我们保存并转到我们的“App.js”文件，以完成将所有props发送回我们的“NewsCard”组件，如下所示：
- en: '![Figure 8.4 – App.js file with props completed for our NewsCard component'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - App.js文件已完成我们的NewsCard组件的props'
- en: '](Images/Figure_8.04_B17074.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.04_B17074.jpg)'
- en: Figure 8.4 – App.js file with props completed for our NewsCard component
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - App.js文件已完成我们的NewsCard组件的props
- en: Right—now, we're going to save the `App.js` file and switch to our simulator.
    We should be able to see our `NewsCard` component taking form. There's a title,
    a summary, a date, and even an author. Yeah—I've used `lorem ipsum` for the summary
    because it's easier and quicker than actually creating a summary text for our
    dummy component. We could even start a news feed with our components. But right
    now, let's go back to our `NewsCard` component and add the stuff that we're still
    missing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在，我们要保存“App.js”文件，并切换到我们的模拟器。我们应该能够看到我们的“NewsCard”组件正在成形。有标题、摘要、日期，甚至作者。是的，我在摘要中使用了“lorem
    ipsum”，因为这比实际创建摘要文本更容易更快。我们甚至可以用我们的组件开始一个新闻订阅。但现在，让我们回到我们的“NewsCard”组件，并添加我们还缺少的东西。
- en: 'For sure, there''s a need for us to replace the placeholder we''ve been using
    with an actual `Image` component. So, let''s replace that text with the following
    line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要用实际的“Image”组件替换我们一直在使用的占位符。所以，让我们用以下行替换那段文字：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might remember that an image needs to have some styling attributed to it
    in order to render. Let's go to the `styles` object and do all the styling we
    need for our image. I was thinking of having a `width` and `height` value of `30px`
    and a `borderRadius` value of `15px`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，图像需要一些样式才能渲染。让我们转到“styles”对象，并做好我们图像所需的所有样式。我想设置“width”和“height”值为“30px”，“borderRadius”值为“15px”。
- en: Now, the only thing we're missing is going back to our `App.js` file and adding
    the `avatar` prop to our component. Search an image online and paste the link
    in there. Now, refresh everything, and congratulations—we have an image rendered!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们唯一缺少的就是回到我们的“App.js”文件，并向我们的组件添加“avatar”prop。在网上搜索一张图片并粘贴链接进去。现在，刷新一切，恭喜——我们有一张图像渲染了！
- en: I'd say that right now, the only thing we're missing is to add some colors to
    the text, but I'll let you do that on your own. If you haven't coded this at the
    same time as me, worry not—just go to GitHub and search for the `Chapter 08` folder.
    This is going to have all the code we've done until now, and you'll also see how
    I've colored the text. I've also destructured the `props` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我想说的是，现在我们唯一缺少的就是给文本添加一些颜色，但我会让你自己来做。如果你没有和我同时编写代码，不用担心 - 只需转到GitHub并搜索`Chapter
    08`文件夹。这将包含我们到目前为止所做的所有代码，你还将看到我如何给文本上色。我还解构了`props`对象。
- en: 'Now, let''s see how this looks on my simulator so that you can make sure that
    once you clone the repository on GitHub, things look the same way we''ve been
    describing them. You can see the result here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这在我的模拟器上是什么样子，这样你就可以确保一旦在GitHub上克隆存储库，事情看起来和我们描述的一样。你可以在这里看到结果：
- en: '![Figure 8.5 – Simulator displaying our finished component'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 模拟器显示我们完成的组件'
- en: '](Images/Figure_8.05_B17074.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.05_B17074.jpg)'
- en: Figure 8.5 – Simulator displaying our finished component
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 模拟器显示我们完成的组件
- en: This looks pretty good, right? I'll let you use this component as much as you
    want in your future apps, so don't shy away from reusing your components. The
    next one should be cooler, so let's move on and start building our first profile
    card.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？我会让你在未来的应用中尽情使用这个组件，所以不要害羞地重复使用你的组件。下一个应该会更酷，所以让我们继续，开始构建我们的第一个个人资料卡。
- en: Creating your own profile card
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的个人资料卡
- en: A profile card is something any user needs to see inside an app with a user
    system. So, I was thinking of creating a simple profile card that is going to
    display some basic information for our users. The main elements that I feel should
    be displayed are a profile picture and the user's name, email, and phone number.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料卡是任何用户在具有用户系统的应用程序中需要看到的东西。所以，我想创建一个简单的个人资料卡，用于显示我们用户的一些基本信息。我觉得应该显示的主要元素是个人资料图片、用户的姓名、电子邮件和电话号码。
- en: This will serve us great purpose in an app where maybe we have a list of phone
    contacts and we want to see each contact separately. Now, let's start creating
    our profile card component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在一个应用程序中对我们非常有用，也许我们有一个电话联系人列表，我们想要单独查看每个联系人。现在，让我们开始创建我们的个人资料卡组件。
- en: Go ahead and create a new file in our `components` folder called `ProfileCard.js`.
    Now, as you read earlier, I've stated which elements this component will be composed
    of. Based on that, let's think of what type of imports we need.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在我们的`components`文件夹中创建一个名为`ProfileCard.js`的新文件。现在，正如你之前所读到的，我已经说明了这个组件将由哪些元素组成。基于此，让我们考虑我们需要什么类型的导入。
- en: You guessed it! The same imports we've been using in our last component. Now
    that we're sure of what type of imports we need to have, let's write a basic function
    so that we can get something on the screen to see while we start working on the
    component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜对了！和我们上一个组件中使用的相同的导入。既然我们确定了需要什么类型的导入，让我们写一个基本的函数，这样我们就可以在开始工作在组件上时在屏幕上看到一些东西。
- en: As you can see in the component's filename, our main `Block` component should
    be a card, so let's apply the same styling that we applied to our last component.
    We'll change the background color and some values, but this `style` object should
    be mostly the same as the last one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在组件的文件名中所看到的，我们的主要`Block`组件应该是一个卡片，所以让我们应用与上一个组件相同的样式。我们会改变背景颜色和一些值，但这个`style`对象应该大部分与上一个相同。
- en: 'Let''s take a look at what we''ve been writing until now:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们到目前为止写了什么：
- en: '![Figure 8.6 – The start of our ProfileCard component'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 我们的ProfileCard组件的开始'
- en: '](Images/Figure_8.06_B17074.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.06_B17074.jpg)'
- en: Figure 8.6 – The start of our ProfileCard component
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 我们的ProfileCard组件的开始
- en: Things look really similar, right? There are some values changed, but this is
    because I feel different colors might suit this card better. It should be of the
    same width as our previous component based on the `"80%"` value we've assigned
    to the `width` property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常相似，对吧？有一些值已经改变了，但这是因为我觉得不同的颜色可能更适合这张卡片。根据我们为`width`属性分配的`"80%"`值，它应该与我们以前的组件具有相同的宽度。
- en: Now, let's go to our `App.js` file and comment out our `<NewsCard />` component
    and import our new component, just like we've done before.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到我们的`App.js`文件，注释掉我们的`<NewsCard />`组件，并导入我们的新组件，就像我们以前做过的那样。
- en: Now, we should be able to see this small card with no content on our simulator's
    screen. Let's go back to our card and continue adding the rest of the layout.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够在模拟器屏幕上看到这张没有内容的小卡片。让我们回到我们的卡片，继续添加布局的其余部分。
- en: We should have an icon on the left side of our component, something that the
    user might want to press in order to modify the contents of our component. We'll
    not create the functionality yet, but having an icon there pointing to this functionality
    should be good enough for us.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件左侧应该有一个图标，用户可能想要按下该图标以修改组件的内容。我们暂时不会创建功能，但在那里放一个指向该功能的图标应该已经足够好了。
- en: Below this icon, I feel we should have an avatar and the contact's name centered
    on the card.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图标下面，我觉得我们应该有一个头像和联系人的名字居中显示在卡片上。
- en: 'Right below these, the phone number and email should be available for us to
    see. Between those two, I was thinking of having a line dividing the information.
    Why? It just looks better, in my opinion. So, let''s move on to the next step
    and add all the basic components we need for this type of layout, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这些下面，电话号码和电子邮件应该可以供我们查看。在这两者之间，我想放一条线来分隔信息。为什么？在我看来，这样看起来更好。因此，让我们继续下一步，添加我们这种布局所需的所有基本组件，如下所示：
- en: '![Figure 8.7 – Basic layout for our ProfileCard component'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 - 我们的ProfileCard组件的基本布局'
- en: '](Images/Figure_8.07_B17074.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.07_B17074.jpg)'
- en: Figure 8.7 – Basic layout for our ProfileCard component
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 - 我们的ProfileCard组件的基本布局
- en: This sort of layout is really easy to prototype with Galio. As you can see,
    all we're using are `Block` components and we can already center, create rows,
    and define the spaces that each component needs. Again, we're using `props` because
    your job right now is to go back to `App.js` and pass down the `props` to our
    component so that it can render with more information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Galio很容易实现这种布局原型。正如你所看到的，我们只是使用`Block`组件，我们已经可以居中、创建行，并定义每个组件所需的空间。同样，我们正在使用`props`，因为你现在的工作是回到`App.js`，将`props`传递给我们的组件，以便它可以渲染更多信息。
- en: 'Done? Great! You might be wondering now what''s up with that `<Block />` component
    between the two rows we''ve created. Well, that''ll act as a divider. So, let''s
    write the styling for it and for our `avatar` image. At this point, you can even
    go ahead and add colors for each `Text` component so that you can make this look
    a lot more interesting. I''d probably use white for the text, but any color would
    work as long as you''re happy with it. Let''s check out how our styling looks,
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了？太棒了！你可能现在想知道我们在创建的两行之间的`<Block />`组件是什么。好吧，那将充当分隔线。因此，让我们为它编写样式，以及我们的`avatar`图像的样式。在这一点上，你甚至可以为每个`Text`组件添加颜色，这样你就可以使其看起来更有趣。我可能会使用白色的文本，但只要你喜欢，任何颜色都可以。让我们看看我们的样式是如何的，如下所示：
- en: '![Figure 8.8 – Styling for our divider and avatar'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - 我们的分隔线和头像的样式'
- en: '](Images/Figure_8.08_B17074.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.08_B17074.jpg)'
- en: Figure 8.8 – Styling for our divider and avatar
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 我们的分隔线和头像的样式
- en: Now that we've created the styling, let's dive in for a second. The divider
    should be a sort of white line between our `Email` and `Phone` number. So, we've
    used a `Block` component to create a straight line. This should make you realize
    in how many ways you can use a `Block` component. What's up with `hairlineWidth`,
    though? This is defined by React Native as the width of a thin line on the specific
    platform. It is mostly used for creating a division between two elements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了样式，让我们深入一下。分隔线应该是我们的“电子邮件”和“电话号码”之间的一条白线。因此，我们使用了一个“Block”组件来创建一条直线。这应该让你意识到你可以用“Block”组件有多少种方式。不过，“hairlineWidth”是怎么回事呢？这是由React
    Native定义的特定平台上细线的宽度。它主要用于在两个元素之间创建分隔。
- en: 'Now, let''s save everything and see how it looks on the simulator. The output
    should be similar to what I have right here. Maybe you''ve changed some colors,
    but the layout should look identical:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们保存一切，看看在模拟器上的效果。输出应该与我这里的类似。也许你改变了一些颜色，但布局应该是相同的：
- en: '![Figure 8.9 – Final render of our component'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 - 我们组件的最终渲染'
- en: '](Images/Figure_8.09_B17074.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.09_B17074.jpg)'
- en: Figure 8.9 – Final render of our component
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 - 我们组件的最终渲染
- en: This has been a real adventure! We've already created two different components
    and we're not stopping here. I hope you're having fun and following closely with
    some code in front of you. It's always a good idea to recreate everything from
    memory in 2-3 days. Just a cool little exercise you can do to make sure you're
    learning everything that you're reading. Now, let's move forward because the next
    one is going to be really cool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是一次真正的冒险！我们已经创建了两个不同的组件，而且我们还没有停下来。我希望你玩得开心，并且在你面前有一些代码。从记忆中重新创建一切通常是一个好主意，大约2-3天。这只是一个很酷的小练习，可以确保你学到了你所阅读的一切。现在，让我们继续前进，因为接下来的内容将会非常酷。
- en: Creating your own register form
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的注册表单
- en: Register forms are used almost in every app you can think of. You might need
    one, so let's see what's going on when creating a register form. This is pretty
    cool because, on top of creating a nice little register card, we're also going
    to learn something new about inputs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序中都使用注册表单。你可能需要一个，所以让我们看看创建注册表单时发生了什么。这非常酷，因为除了创建一个漂亮的小注册卡之外，我们还将学到有关输入的新知识。
- en: Let's start how we always start—comment out the previous components from `App.js`
    and create a new file in our `components` folder called `RegisterForm.js`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像往常一样开始 - 注释掉“App.js”中的先前组件，并在我们的“components”文件夹中创建一个名为“RegisterForm.js”的新文件。
- en: We've already created two components, so let's see whether you can start creating
    this on your own. The form in the following screenshot will be the final rendered
    version of our register form. I've chosen to let you look at it before you actually
    start creating it because I think you should be able to achieve a similar result
    on your own without my help. Of course, I'll still help you, but this is a good
    chance to take your time, close the book, and start creating this on your own.
    Check out the following screenshot and start creating on your own!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了两个组件，所以让我们看看你是否可以开始自己创建这个。以下截图中的表单将是我们注册表单的最终渲染版本。我选择让你在实际开始创建之前先看一下，因为我认为你应该能够在没有我的帮助下自己实现类似的结果。当然，我仍然会帮助你，但这是一个很好的机会，花点时间，关闭书本，然后自己开始创建。看看以下截图，然后开始自己创建吧！
- en: '![Figure 8.10 – Final rendered version of our register card'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 - 我们注册卡的最终渲染版本'
- en: '](Images/Figure_8.10_B17074.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.10_B17074.jpg)'
- en: Figure 8.10 – Final rendered version of our register card
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 - 我们注册卡的最终渲染版本
- en: Looks pretty neat, right? This isn't really hard to create based on what we've
    done until now. So, now that you've taken a look at it, maybe you're already thinking
    about how to start working on this component. That's great! If you're still reading,
    that's also fine because we'll go right ahead and start creating this component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当整洁，对吧？根据我们到目前为止所做的事情，这并不难创建。所以，既然你已经看过了，也许你已经在考虑如何开始处理这个组件了。太好了！如果你还在阅读，也没关系，因为我们将立即开始创建这个组件。
- en: Just as we've done up to now, we're going to start thinking of what types of
    imports we need to have. We don't need an image anymore, but we do need an `Input`
    and a `Button component`. Worry not about the icons placed inside the inputs—you
    can do that directly from the `Input` component. Galio makes it really easy to
    style and add icons inside your input.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们到目前为止所做的那样，我们将开始考虑我们需要有什么类型的导入。我们不再需要图像，但我们确实需要一个`Input`和一个`Button`组件。不要担心输入框内放置的图标-你可以直接从`Input`组件中做到这一点。Galio让在输入框内添加图标和样式变得非常容易。
- en: 'I feel that our inputs should look something like this for this specific component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得我们的输入框应该看起来像这样，特别是对于这个特定的组件：
- en: '![Figure 8.11 – Imports used for our register form'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11-用于我们的注册表单的导入'
- en: '](Images/Figure_8.11_B17074.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.11_B17074.jpg)'
- en: Figure 8.11 – Imports used for our register form
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11-用于我们的注册表单的导入
- en: Can you already think of how we should be creating the layout for this one?
    We don't need any rows here because all the elements are coming straight down
    in a column. The only `Block` element we'll be using is the one used for creating
    the card itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经想到我们应该如何为这个创建布局了吗？我们这里不需要任何行，因为所有的元素都是直接垂直排列的。我们将使用的唯一的`Block`元素是用于创建卡片本身的元素。
- en: 'Let''s start by writing our main function, just like we did before. We need
    a `Block` component with the card styling applied to it, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始写我们的主要函数，就像我们以前做过的那样。我们需要一个带有卡片样式的`Block`组件，如下所示：
- en: '![Figure 8.12 – The beginning of our RegisterForm component'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12-我们的RegisterForm组件的开始'
- en: '](Images/Figure_8.12_B17074.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.12_B17074.jpg)'
- en: Figure 8.12 – The beginning of our RegisterForm component
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12-我们的RegisterForm组件的开始
- en: Now, let's go into our `App.js` file and comment out our previous components
    so that we can import our newly created component. We've done this multiple times
    by now, so this should be easy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入我们的`App.js`文件，并注释掉以前的组件，以便我们可以导入我们新创建的组件。到目前为止，我们已经做过这个多次了，所以这应该很容易。
- en: Now, let's continue with our component and quickly go through the layout. As
    we've already done this multiple times, this shouldn't be hard to understand.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的组件，快速浏览一下布局。由于我们已经做过多次了，这应该不难理解。
- en: 'We obviously start with a `Text` component, followed by three `Input` components
    and one `Button` component. So, let''s write that down, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们首先使用一个`Text`组件，然后是三个`Input`组件和一个`Button`组件。所以，让我们写下来，如下所示：
- en: '![Figure 8.13 – Our almost completed component'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13-我们几乎完成的组件'
- en: '](Images/Figure_8.13_B17074.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.13_B17074.jpg)'
- en: Figure 8.13 – Our almost completed component
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13-我们几乎完成的组件
- en: 'OK—so, everything is pretty much what we''ve always done up to now. Let''s
    tackle the new things found here. So, on our third `Input` component, we can see
    two props: `password` and `viewPass`. The first one is for making sure you cannot
    see the password as you write; it transforms your writing into those dots we so
    often see whenever we''re typing out our password somewhere. The second one is
    there to display that icon on the right, which the user can press in order to
    see whether there''s something wrong with the password they just typed, basically
    transforming the dots into letters and vice versa.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，所以，一切基本上都是我们到目前为止一直在做的事情。让我们来解决这里发现的新东西。所以，在我们的第三个`Input`组件上，我们可以看到两个props：`password`和`viewPass`。第一个是为了确保您在输入时看不到密码；它会将您的输入转换为我们在输入密码时经常看到的那些点。第二个是为了在右侧显示那个图标，用户可以按下它以查看他们刚刚输入的密码是否有问题，基本上是将点转换为字母，反之亦然。
- en: 'Our `Button` component also has that `shadowless` prop, which does exactly
    what you''d think: it makes the button shadowless.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Button`组件也有`shadowless`属性，它的作用正如你所想的那样：使按钮没有阴影。
- en: Now, here comes the interesting part. Of course, we'd like to know what the
    user is typing; how else are we going to verify that the information is correct
    or even typed the way we want it to be typed? Maybe you asked for the user's email,
    but what if the typed words are some random words just to break into the app without
    actually registering? So, there must be some way we can make sure that we know
    what the user has typed and verify that text once the user presses the **Register
    now** or **Submit** buttons.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有趣的部分来了。当然，我们想知道用户在输入什么；否则，我们怎么能验证信息是否正确，或者是否按我们希望的方式输入？也许你要求用户输入电子邮件，但如果输入的是一些随机单词，只是为了不注册就进入应用程序呢？因此，我们必须有一种方法来确保我们知道用户输入了什么，并在用户按下**立即注册**或**提交**按钮后验证文本。
- en: This technique is called **controlled components**. A controlled component takes
    its current value through props and sends any changes through callbacks. A parent
    component "controls" it by handling the callback and managing its own state and
    then passing the new state values as props to the controlled component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术称为**受控组件**。受控组件通过props获取其当前值，并通过回调发送任何更改。父组件通过处理回调并管理自己的状态，然后将新的状态值作为props传递给受控组件来“控制”它。
- en: In most—or even all—cases, you should use controlled components when we're dealing
    with forms.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，甚至是所有情况下，当我们处理表单时，应该使用受控组件。
- en: 'Because we''re in a functional component, we''ll be using **hooks** for our
    states. Don''t forget to import the `useState` hook, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在一个函数组件中，我们将使用**钩子**来处理我们的状态。不要忘记导入`useState`钩子，如下所示：
- en: '![Figure 8.14 – Hooks used inside our functional component'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 - 在我们的函数组件中使用的钩子'
- en: '](Images/Figure_8.14_B17074.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.14_B17074.jpg)'
- en: Figure 8.14 – Hooks used inside our functional component
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 - 在我们的函数组件中使用的钩子
- en: 'This is pretty easy as we''ve already learned about hooks and a component''s
    state. Now, let''s apply our states to our `Input` components, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易，因为我们已经学习过钩子和组件的状态。现在，让我们将我们的状态应用到我们的`Input`组件中，如下所示：
- en: '![Figure 8.15 – State applied to our Input components'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 - 应用于我们的输入组件的状态'
- en: '](Images/Figure_8.15_B17074.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.15_B17074.jpg)'
- en: Figure 8.15 – State applied to our Input components
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 - 应用于我们的输入组件的状态
- en: So, what exactly happens here? Once the user presses on an **input** and starts
    writing their name or email, for example, our `onChangeText` prop triggers our
    `setName` prop, which sets the `name` state variable to the current value of our
    input. This way, we're making sure that our `RegisterForm` component is *controlling*
    the *inputs* and is constantly updated with information about our input's state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里到底发生了什么？一旦用户按下**输入**并开始输入他们的姓名或电子邮件，例如，我们的`onChangeText`属性会触发我们的`setName`属性，这将把`name`状态变量设置为我们输入的当前值。这样，我们确保我们的`RegisterForm`组件*控制*着*输入*，并且始终更新有关我们输入状态的信息。
- en: It might be somewhat hard for some people to grasp why we need it. The truth
    is this is how React is making sure that there won't be any errors related to
    our input's state, while also giving us full control and knowledge of our input's
    current state at all times.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，可能有点难以理解为什么我们需要它。事实上，这就是React确保我们的输入状态不会出现任何错误的方式，同时还让我们完全控制和了解我们输入的当前状态。
- en: Now, let's write a simple verification for our form. We need to at least have
    a message for our users popping up in case there's nothing written there and the
    user presses the **Register now** button.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的表单编写一个简单的验证。我们至少需要在用户没有输入任何内容并按下**立即注册**按钮时弹出一条消息。
- en: So, we'll create a function called `registerButton`. You can name it however
    you want, but I called it this because it made sense to me. This function will
    verify the length of our input's value. Now, if we weren't having this controlled
    component, we wouldn't have been able to access those values via normal variables.
    We might have to use something called `refs`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个名为`registerButton`的函数。您可以按自己的意愿命名，但我称它为这个是因为对我来说有意义。这个函数将验证我们输入值的长度。现在，如果我们没有这个受控组件，我们将无法通过普通变量访问这些值。我们可能需要使用一种叫做`refs`的东西。
- en: 'This is mostly beside the point as we''re not going to learn about `refs`,
    but it''s important to know that there is something called `refs`. Let''s take
    a look at this `registerButton` function, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们不打算学习`refs`的情况下并不重要，但重要的是要知道有一种叫做`refs`的东西。让我们来看看这个`registerButton`函数，如下所示：
- en: '![Figure 8.16 – Our form verification function'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 - 我们的表单验证函数'
- en: '](Images/Figure_8.16_B17074.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.16_B17074.jpg)'
- en: Figure 8.16 – Our form verification function
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 - 我们的表单验证函数
- en: 'Now that we have this function, we just have to call it whenever the user presses
    the **Register now** button, so we''re going to use the `onPress` prop on our
    `Button` component. Go ahead and apply this prop to our `Button` component, like
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个函数，我们只需要在用户按下**立即注册**按钮时调用它，所以我们将在我们的`Button`组件上使用`onPress`属性。继续并将此属性应用到我们的`Button`组件中，就像这样：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, save and refresh the app and try it out! Pretty cool, right? There's a
    message popping up whenever you try to press the button with no text inside the
    inputs, while there's also another cool message where we're using the values written
    in our inputs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存并刷新应用程序，然后试一下！很酷，对吧？每当您尝试按下没有输入文本的按钮时，会弹出一条消息，同时在我们使用输入中编写的值时，还会出现另一条很酷的消息。
- en: This wasn't a hard component to be created but we've learned about something
    really cool, and that's *controlled components*. I hope this little exercise managed
    to successfully teach you something new that you'll be using quite often from
    now on whenever working with forms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个难以创建的组件，但我们学到了一些真正酷的东西，那就是*受控组件*。我希望这个小练习成功地教会了你一些新东西，从现在开始在处理表单时你会经常使用它。
- en: Now that we've finished with this component, let's move ahead and start working
    on a different component involved with e-commerce mobile applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个组件，让我们继续开始处理与电子商务移动应用程序相关的另一个组件。
- en: Building your e-commerce cards
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的电子商务卡
- en: As you know, whenever you buy something online, there's always a basket full
    of the products you've chosen. Each item in that basket is usually a card with
    information about the price, the item's name, a picture, and the possibility to
    increase or decrease the number of items of the same type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，每当你在网上购物时，总会有一个装满你选择的产品的购物篮。篮子里的每件物品通常都是一张卡片，上面有关于价格、物品名称、图片以及增加或减少相同类型物品数量的信息。
- en: 'So, this is what we''re going to create as well. Let''s take a look at it here,
    as we''ve already become so advanced that we should now be able to think of ways
    of creating the functionality with only those things that we''ve learned up to
    now:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这也是我们要创建的东西。让我们来看看这里，因为我们已经变得如此先进，现在应该能够想出只用到目前为止学到的东西来创建功能的方法：
- en: '![Figure 8.17 – Final rendered version of our e-commerce card'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 - 我们电子商务卡的最终渲染版本'
- en: '](Images/Figure_8.17_B17074.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.17_B17074.jpg)'
- en: Figure 8.17 – Final rendered version of our e-commerce card
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 - 我们电子商务卡的最终渲染版本
- en: Looks pretty good, right? Honestly, it isn't even that hard to build, so we'll
    be moving quickly through the layout. Let's create a new file called `CommerceCard.js`
    inside the `components` folder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？老实说，甚至构建起来也不那么难，所以我们将快速通过布局。让我们在`components`文件夹中创建一个名为`CommerceCard.js`的新文件。
- en: 'Now, let''s think about which types of imports we''d need for this one—obviously,
    a `Block` and `Text` component. We''ll also need to import the `Icon` component
    because, as we can see in *Figure 8.17*, we have a minus button and a plus button
    there. To make those buttons clickable, we''ll be using a `react-native` component
    called `TouchableOpacity`, so let''s import that as well. On top of that, as we
    can all see, we also have an `Image` component. Let''s see what all of our imports
    look like, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想想我们需要哪些类型的导入 - 显然，需要一个`Block`和`Text`组件。我们还需要导入`Icon`组件，因为正如我们在*图8.17*中看到的，那里有一个减号按钮和一个加号按钮。为了使这些按钮可点击，我们将使用一个名为`TouchableOpacity`的`react-native`组件，所以也让我们导入它。除此之外，正如我们都能看到的，我们还有一个`Image`组件。让我们看看我们所有的导入是什么样子，如下所示：
- en: '![Figure 8.18 – The imports we''ll be using for creating a CommerceCard component'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 - 我们将用于创建CommerceCard组件的导入'
- en: '](Images/Figure_8.18_B17074.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.18_B17074.jpg)'
- en: Figure 8.18 – The imports we'll be using for creating a CommerceCard component
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 - 我们将用于创建CommerceCard组件的导入
- en: 'We''ve also imported `useState` because the number will change based on which
    icon we''re pressing. So, let''s start creating our functional component now,
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了`useState`，因为数字将根据我们按下的图标而改变。所以，让我们现在开始创建我们的功能组件，如下所示：
- en: '![Figure 8.19 – Our component''s layout'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 - 我们组件的布局'
- en: '](Images/Figure_8.19_B17074.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.19_B17074.jpg)'
- en: Figure 8.19 – Our component's layout
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 - 我们组件的布局
- en: That doesn't look that hard to read, right? Let's explain some of it because
    we've moved a bit faster right now. But this is because I feel like you've advanced
    quite a bit, so you should just try to challenge yourself and see whether what
    you think matches with the component that I've written and we've seen in *Figure
    8.17*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来并不难读，对吧？让我们解释一些，因为我们现在走得有点快。但这是因为我觉得你已经进步了很多，所以你应该尝试挑战自己，看看你的想法是否与我写的组件和我们在*图8.17*中看到的相匹配。
- en: As far as we can see, we can have a big `Block` component containing everything
    and making the content inside in a row. The first element in the row is our image.
    After that, we have another `Block` component with the prop of `flex`, which is
    basically telling our component to take as much space as it can.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 据我们所见，我们可以有一个包含所有内容并使内容在一行中的大`Block`组件。行中的第一个元素是我们的图像。之后，我们有另一个具有`flex`prop的`Block`组件，基本上告诉我们的组件尽可能占据空间。
- en: Inside that `Block` component, we have a `Text` component that receives the
    name of the item as a prop called `itemName`. We then have another `Block` component
    with the `row` prop applied, which will be used to separate the price and the
    quantity, both of which are going to be state variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Block`组件内部，我们有一个`Text`组件，它接收项目名称作为名为`itemName`的prop。然后我们有另一个`Block`组件，应用了`row`prop，它将用于分隔价格和数量，这两者都将是状态变量。
- en: 'Now, let''s see what the styling looks like—trust me, the styling is a piece
    of cake. Here it is:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看样式是什么样子的 - 相信我，样式很简单。在这里：
- en: '![Figure 8.20 – Styling for our component'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 - 组件的样式'
- en: '](Images/Figure_8.20_B17074.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.20_B17074.jpg)'
- en: Figure 8.20 – Styling for our component
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 - 组件的样式
- en: As you can see, the styling we're using here is really not that complicated.
    So, let's get on with the logic behind how this component works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里使用的样式实际上并不复杂。因此，让我们继续讨论这个组件的工作原理。
- en: 'As you may remember, I''ve said we''re going to use the state for our price
    and quantity, so let''s initialize our state, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，我说过我们将使用状态来存储我们的价格和数量，所以让我们初始化我们的状态，如下所示：
- en: '![Figure 8.21 – Initializing state for our component'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 - 初始化组件状态'
- en: '](Images/Figure_8.21_B17074.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.21_B17074.jpg)'
- en: Figure 8.21 – Initializing state for our component
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 - 初始化组件状态
- en: Now, I was thinking, we could pass the price via a prop; that way, this component
    is more reusable for future cases. Because this is done via a prop, we should've
    used a life cycle function, as if we were writing a class component as this is
    a functional component—and, as we remember, we can use `useEffect` instead of
    a life cycle function. So, let's import `useEffect` at the same place where `useState`
    is imported.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我在想，我们可以通过prop传递价格；这样，这个组件对于将来的情况更具重用性。因为这是通过prop完成的，所以我们应该使用生命周期函数，就好像我们在编写类组件一样，因为这是一个函数组件
    - 正如我们记得的那样，我们可以使用`useEffect`代替生命周期函数。因此，让我们在导入`useState`的地方同时导入`useEffect`。
- en: 'Now, let''s see how we should write the `useEffect` function, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们应该如何编写`useEffect`函数，如下所示：
- en: '![Figure 8.22 – useEffect function used to initialize the price state variable'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 - useEffect函数用于初始化价格状态变量'
- en: '](Images/Figure_8.22_B17074.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.22_B17074.jpg)'
- en: Figure 8.22 – useEffect function used to initialize the price state variable
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 - useEffect函数用于初始化价格状态变量
- en: So, when `useEffect` gets called, the `setPrice` function inside of it will
    get called, which is going to set our `price` state variable to whatever number
    the prop is sending. But what's with the `[props.price]` argument used as the
    second argument for our `useEffect` function?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用`useEffect`时，其中的`setPrice`函数将被调用，这将设置我们的`price`状态变量为prop发送的任何数字。但是作为`useEffect`函数的第二个参数使用的`[props.price]`参数是什么意思呢？
- en: This tells our `useEffect` function to get called only when the `props.price`
    variable gets changed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的`useEffect`函数仅在`props.price`变量发生变化时才会被调用。
- en: Now that we've initialized our `price` variable, let's change the price based
    on the quantity. How should we do that? I've written a function called `quantityMath`
    that receives a string variable named `action` that will tell our function whether
    the quantity should be dropping or rising.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经初始化了我们的`price`变量，让我们根据数量来改变价格。我们应该如何做呢？我写了一个名为`quantityMath`的函数，它接收一个名为`action`的字符串变量，这将告诉我们的函数数量是应该下降还是上升。
- en: As we all know, when we're shopping online, every item in our basket has a plus
    and a minus that, whenever pressed, either increments the quantity with one or
    decrements with one. Based on this, we calculate the total price of that item.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，当我们在线购物时，篮子中的每件物品都有一个加号和一个减号，每当按下时，要么增加一个数量，要么减少一个数量。基于此，我们计算该物品的总价格。
- en: 'Now, let''s take a look at this function, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这个函数，如下所示：
- en: '![Figure 8.23 – quantityMath function used to calculate the final price'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – 用于计算最终价格的quantityMath函数'
- en: '](Images/Figure_8.23_B17074.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.23_B17074.jpg)'
- en: Figure 8.23 – quantityMath function used to calculate the final price
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 用于计算最终价格的quantityMath函数
- en: 'Now that we have created this function, let''s make sure that when our user
    presses the buttons, this function is getting called. `TouchableOpacity` is a
    component used to make other components pressable. So, let''s go to one of the
    `TouchableOpacity` components and change the `onPress` prop to `{() => quantityMath("minus")}`.
    Of course, we''ll use `minus` for the minus icon and `plus` for the plus icon
    as an argument for our `quantityMath` function. Let''s take a look at how that
    looks in our code, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了这个函数，让我们确保当用户按下按钮时，这个函数被调用。`TouchableOpacity`是一个用于使其他组件可按压的组件。所以，让我们去其中一个`TouchableOpacity`组件，将`onPress`属性改为`{()
    => quantityMath("minus")}`。当然，我们将使用`minus`作为`quantityMath`函数的参数，用于减号图标，`plus`用于加号图标。让我们来看看这在我们的代码中是什么样子的：
- en: '![Figure 8.24 – Implementing the quantityMath function'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24 – 实现quantityMath函数'
- en: '](Images/Figure_8.24_B17074.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.24_B17074.jpg)'
- en: Figure 8.24 – Implementing the quantityMath function
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 实现quantityMath函数
- en: 'Now our component is finished, let''s go inside our `App.js` file and test
    it out. Comment out the previous component and let''s import our newly created
    component. Now, let''s add this component to our main function, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的组件已经完成，让我们进入我们的`App.js`文件并测试一下。注释掉之前的组件，然后导入我们新创建的组件。现在，让我们将这个组件添加到我们的主函数中，就像这样：
- en: '![Figure 8.25 – Main app function with our CommerceCard component inside of
    it'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – 主应用程序函数，其中包含我们的CommerceCard组件'
- en: '](Images/Figure_8.25_B17074.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_8.25_B17074.jpg)'
- en: Figure 8.25 – Main app function with our CommerceCard component inside of it
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 主应用程序函数，其中包含我们的CommerceCard组件 inside of it
- en: Save all files, refresh the app, and you should see our card. Go ahead and start
    playing with the plus and minus buttons, and you'll see how everything accurately
    changes based on the quantity you want.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件，刷新应用程序，你应该能看到我们的卡片。继续玩加号和减号按钮，你会看到一切都根据你想要的数量准确地改变。
- en: This was pretty cool, right? We now have a cool little component we can use
    whenever we want to start prototyping for an e-commerce app.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，对吧？现在我们有了一个很酷的小组件，我们可以在想要为电子商务应用程序进行原型设计时使用。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After learning so much about how React and React Native work, we finally got
    to the point where more practical challenges are getting tackled head-on. We've
    started by creating a simple component, where we mostly focused on styling and
    layout.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了关于React和React Native的工作原理之后，我们终于到了更多实际挑战的阶段。我们首先创建了一个简单的组件，主要关注样式和布局。
- en: That was the easy part, and the first step into our next component was where
    we saw a different example of creating a layout, and we strengthened our brain
    muscles so that we can more easily start prototyping components on our own.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那是容易的部分，我们下一个组件的第一步是看到一个不同的创建布局的例子，我们加强了大脑肌肉，这样我们就可以更容易地开始自己原型化组件。
- en: Right after this, we got into more serious components, and that was the register
    form where we learned a new concept called controlled inputs. This was really
    fascinating as we learned how to actually attack the problem of forms in React
    Native.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们开始涉及更严肃的组件，那就是注册表单，我们学到了一个叫做受控输入的新概念。这真的很有趣，因为我们学会了如何在React Native中实际解决表单问题。
- en: Our next component was even cooler as we used the `useEffect` function to initialize
    one of our state variables with a prop received by our component. Now, that's
    some seriously cool stuff, and I hope you got as excited as I did when I first
    discovered the function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个组件甚至更酷，因为我们使用`useEffect`函数来初始化我们组件接收到的一个prop变量。现在，这真的很酷，我希望你和我第一次发现这个函数时一样兴奋。
- en: Now that we've done more practical challenges, it's time to think about how
    debugging works so that we can make sure we know how to properly find out what's
    wrong with our component. We'll also learn about some limitations with debugging
    when it comes to React Native. Let's move on with this cool adventure and get
    closer to creating our own cross-platform mobile applications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了更多的实际挑战，是时候考虑调试的工作原理了，这样我们就可以确保知道如何正确地找出组件的问题所在。当涉及到React Native时，我们还会了解一些调试的限制。让我们继续这个酷炫的冒险，更接近创建我们自己的跨平台移动应用程序。
