- en: Chapter 2. Installing Powerful Tools for Your Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。为您的项目安装强大的工具
- en: 'Here is a great quote by Charles F. Kettering:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一句查尔斯·F·凯特林的名言：
- en: '"My interest is in the future because I am going to spend the rest of my life
    there."'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我对未来感兴趣，因为我将在那里度过余生。”
- en: This brilliant inventor has left software engineers with the single most important
    piece of advice way before we even started thinking how to write software. Yet,
    half a century later, we're still figuring out why we end up with spaghetti code
    or the "spaghetti mental model."
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这位杰出的发明家在我们甚至开始思考如何编写软件之前就给软件工程师留下了最重要的建议。然而，半个世纪后，我们仍在弄清楚为什么最终会得到意大利面代码或“意大利面心智模型”。
- en: Have you ever been in a situation where you inherit code from a previous developer
    and spend weeks trying to understand how everything works because no blueprints
    were made available, and the pseudo-self-explanatory-code became too hard to debug?
    Better yet, the project keeps growing and so does its complexity. Making or breaking
    changes is dangerous and no one wants to touch that "ugly" legacy code. Rewriting
    the whole codebase is way too expensive, so the current one is supported by introducing
    new bug fixes and patches every day. The cost of maintaining software is way higher
    than the original cost of developing it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经处于这样一种情况：你继承了前任开发者的代码，并花费了数周的时间试图理解一切是如何工作的，因为没有提供蓝图，而伪自解释的代码变得太难以调试？更糟糕的是，项目不断增长，复杂性也在增加。做出改变或破坏性的改变是危险的，没有人愿意去碰那些“丑陋”的遗留代码。重写整个代码库成本太高，因此目前的代码通过引入新的错误修复和补丁来支持。维护软件的成本远高于最初开发的成本。
- en: What does it mean to write software for the future today? I think it boils down
    to creating a simple mental model that doesn't change, no matter how big your
    project becomes over time. When the size of your project grows, the complexity
    always stays the same. This mental model is your blueprint, and once you understand
    it, you will understand how your software works.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 写软件是为了未来而今天就开始。我认为关键在于创建一个简单的心智模型，无论项目在未来变得多么庞大，它都不会改变。当项目规模增长时，复杂性始终保持不变。这个心智模型就是你的蓝图，一旦你理解了它，你就会明白你的软件是如何工作的。
- en: If you take a look at the modern web development, and in particular, the frontend
    development, you'll notice that we live in exciting times. Internet companies
    and individual developers are tackling problems of speed and cost of development
    versus code and user experience quality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下现代的Web开发，特别是前端开发，你会注意到我们生活在激动人心的时代。互联网公司和个人开发者正在解决速度和开发成本与代码和用户体验质量之间的问题。
- en: 'In 2013, Facebook released React—an open source JavaScript library for building
    user interfaces. You can read more about it at [http://facebook.github.io/react/](http://facebook.github.io/react/).
    In early 2015, Tom Occhino from Facebook has summarized what makes React so powerful:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Facebook发布了React——一个用于构建用户界面的开源JavaScript库。您可以在[http://facebook.github.io/react/](http://facebook.github.io/react/)上阅读更多信息。2015年初，来自Facebook的Tom
    Occhino总结了React的强大之处：
- en: '"React wraps an imperative API with a declarative one. React''s real power
    lies in how it makes you to write code."'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “React用声明式API包装了一个命令式API。React的真正力量在于它让你编写代码。”
- en: Declarative programming results in less code. It tells a computer what to do
    without specifying how, while an imperative style of programming describes how
    to do it. JavaScript calling the DOM API is an example of imperative programming.
    jQuery is another such example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程会导致代码量减少。它告诉计算机要做什么，而不指定如何做，而命令式编程风格描述了如何做。JavaScript调用DOM API就是命令式编程的一个例子。jQuery就是另一个例子。
- en: 'Facebook has been using React in production for years along with Instagram
    and other companies. It works for small projects too; here is an example of a
    shopping list built with React: [http://fedosejev.github.io/shopping-list-react](http://fedosejev.github.io/shopping-list-react).
    I think React is one of the best JavaScript libraries used for building user interfaces
    that is available for developers today.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook多年来一直在生产中使用React，还有Instagram和其他公司。它也适用于小型项目；这里有一个使用React构建的购物清单的示例：[http://fedosejev.github.io/shopping-list-react](http://fedosejev.github.io/shopping-list-react)。我认为React是今天开发人员可以使用的构建用户界面的最好的JavaScript库之一。
- en: My goal is that you understand the fundamental principles of React. To achieve
    this, I will introduce you to one React concept at a time, explain it, and show
    how you can apply it. Step by step we'll build a real-time web application, raise
    important questions along the way, and discuss solutions that React provides us
    with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是让你理解React的基本原则。为了实现这一目标，我将逐步向您介绍React的一个概念，解释它，并展示您如何应用它。我们将逐步构建一个实时Web应用程序，沿途提出重要问题，并讨论React为我们提供的解决方案。
- en: You will learn about Flux/Redux and the unidirectional flow of data. Together
    with Flux/Redux and React, we'll create a predictable and manageable code base
    that you will be able to expand by adding new features, without scaling its complexity.
    The mental model of how your web application works will stay the same no matter
    how many new features you add later on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解Flux/Redux和数据的单向流动。与Flux/Redux和React一起，我们将创建一个可预测和可管理的代码库，您将能够通过添加新功能来扩展它，而不会增加其复杂性。您的Web应用程序的心智模型将保持不变，无论以后添加了多少新功能。
- en: As with any new technology, there are things that work very differently from
    the way that you're used to. React is no exception. In fact, some of the core
    concepts of React might look counter-intuitive, thought provoking, or even like
    a step backward. Don't rush to any conclusions. As you would expect, a lot of
    thought went into how React works, from experienced Facebook engineers who build
    and use React in production in business-critical applications. My advice to you
    is to keep your mind open while learning React, and I believe that at the end
    of this book, these new concepts will settle in and make great sense to you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何新技术一样，有些东西的工作方式与您习惯的方式非常不同。React也不例外。事实上，React的一些核心概念可能看起来违反直觉，引发思考，甚至看起来像是一种倒退。不要草率下结论。正如您所期望的那样，Facebook的经验丰富的工程师们在构建和使用React的过程中进行了大量思考，这些应用程序在业务关键应用中进行了生产。我给你的建议是，在学习React的过程中保持开放的心态，我相信在本书结束时，这些新概念将会让你感到很有意义。
- en: Join me in this journey of learning React and following Charles F. Kettering's
    advice. Let's take care of our future!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我一起学习React，并遵循查尔斯·F·凯特林的建议。让我们照顾好我们的未来！
- en: Approaching our project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近我们的项目
- en: I firmly believe that the best motivation for learning new technology is a project
    that excites you that you can't wait to build. As an experienced developer, you've
    probably already built a number of successful commercial projects that share certain
    product features, design patterns, and even target audiences. In this book, I
    want you to build a project that feels like a breath of fresh air. A project,
    which you most likely wouldn't build in your day-to-day work. It has to be a fun
    endeavor, which will not only educate you but also satisfy your curiosity and
    stretch your imagination. However, assuming that you're a busy professional, this
    project shouldn't be a time-consuming, long-term commitment for you either.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信学习新技术的最好动力是一个激发你兴趣、让你迫不及待地想要构建的项目。作为一名经验丰富的开发者，你可能已经构建了许多成功的商业项目，这些项目共享某些产品特性、设计模式，甚至目标受众。在这本书中，我希望你能建立一个感觉焕然一新的项目。一个你在日常工作中很可能不会构建的项目。它必须是一个有趣的尝试，不仅能教育你，还能满足你的好奇心并拓展你的想象力。然而，假设你是一个忙碌的专业人士，这个项目也不应该成为你长时间的、耗时的承诺。
- en: 'Enter **Snapterest**—a web application that allows you to discover and collect
    public photos posted on Twitter. Think of it as a Pinterest ([www.pinterest.com](http://www.pinterest.com))
    with the only source of pictures being Twitter. We will implement a fully functional
    website with the following core functionalities:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**Snapterest**—一个允许你发现和收集Twitter上发布的公共照片的网络应用。把它想象成一个Pinterest（[www.pinterest.com](http://www.pinterest.com)），唯一的图片来源就是Twitter。我们将实现一个具有以下核心功能的完全功能的网站：
- en: Receiving and displaying tweets in real time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时接收和显示推文
- en: Adding and removing tweets to/from a collection
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向/从收藏中添加和删除推文
- en: Reviewing collected tweets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查收集的推文
- en: Exporting a collection of tweets as an HTML snippet that you can share
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将推文收藏导出为可以分享的HTML片段
- en: When you start working on a new project, the very first thing that you do is
    to get your tools ready. For this project, we will be using a number of tools
    that you might not be familiar with, so let's discuss what they are, and how you
    can install and configure them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始着手一个新项目时，你要做的第一件事就是准备好你的工具。对于这个项目，我们将使用一些你可能不熟悉的工具，所以让我们讨论一下它们是什么，以及你如何安装和配置它们。
- en: If you have any trouble with installing and configuring tools and modules from
    this chapter, then go to [https://github.com/PacktPublishing/React-Essentials-Second-Edition](https://github.com/PacktPublishing/React-Essentials-Second-Edition)
    and create a new issue; describe what you're doing and what error message you're
    getting. I believe our community will help you to resolve your issue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装和配置本章中的工具和模块时遇到任何问题，请访问[https://github.com/PacktPublishing/React-Essentials-Second-Edition](https://github.com/PacktPublishing/React-Essentials-Second-Edition)并创建一个新的问题；描述你正在做什么以及你遇到了什么错误消息。我相信我们的社区会帮助你解决问题。
- en: In this book, I'll assume that you're working on a Macintosh or Windows computer.
    If you're a Unix user, then most likely you would know your package manager very
    well, and it should be easy enough for you to install the tools that you will
    learn about in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我假设你正在使用Macintosh或Windows计算机。如果你是Unix用户，那么你很可能非常了解你的软件包管理器，并且应该很容易为你安装本章中将要学习的工具。
- en: Let's start with the installation of Node.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装Node.js开始。
- en: Installing Node.js and npm
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node.js和npm
- en: '**Node.js** is a platform that allows us to write server-side applications
    with a client-side language that we''re all familiar with—JavaScript. However,
    the real benefit of Node.js is that it uses an event-driven, nonblocking I/O model,
    which is perfect for building data-intensive, real-time applications. It means
    that with Node.js, we should be able to handle an incoming stream of tweets and
    process them as soon as they arrive; just what we need for our project.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js**是一个平台，允许我们使用我们都熟悉的客户端语言JavaScript编写服务器端应用程序。然而，Node.js的真正好处在于它使用事件驱动的、非阻塞的I/O模型，非常适合构建数据密集型、实时应用程序。这意味着使用Node.js，我们应该能够处理传入的推文流，并在其到达时立即处理它们；这正是我们项目所需要的。'
- en: Let's install Node.js. We'll be using version 8.7.0 because at the time of writing
    this book, that's the latest version of Node.js. Jest is a testing framework from
    Facebook that you'll learn about in [Chapter 9](ch09.html "Chapter 9. Testing
    Your React Application with Jest"), *Testing Your React Application with Jest*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Node.js。我们将使用8.7.0版本，因为在撰写本书时，这是Node.js的最新版本。Jest是Facebook的一个测试框架，您将在[第9章](ch09.html
    "第9章。使用Jest测试您的React应用程序")中了解到，*使用Jest测试您的React应用程序*。
- en: 'Download the installation package for your OS from one of these links:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接之一下载适用于您操作系统的安装包：
- en: 'OS X: [http://nodejs.org/dist/v8.7.0/node-v8.7.0.pkg](http://nodejs.org/dist/v8.7.0/node-v8.7.0.pkg)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS X：[http://nodejs.org/dist/v8.7.0/node-v8.7.0.pkg](http://nodejs.org/dist/v8.7.0/node-v8.7.0.pkg)
- en: 'Windows 64-bit: [http://nodejs.org/dist/v8.7.0/node-v8.7.0-x64.msi](http://nodejs.org/dist/v8.7.0/node-v8.7.0-x64.msi)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 64位：[http://nodejs.org/dist/v8.7.0/node-v8.7.0-x64.msi](http://nodejs.org/dist/v8.7.0/node-v8.7.0-x64.msi)
- en: 'Windows 32-bit: [http://nodejs.org/dist/v8.7.0/node-v8.7.0-x86.msi](http://nodejs.org/dist/v8.7.0/node-v8.7.0-x86.msi)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 32位：[http://nodejs.org/dist/v8.7.0/node-v8.7.0-x86.msi](http://nodejs.org/dist/v8.7.0/node-v8.7.0-x86.msi)
- en: 'Run the downloaded package and follow the installation steps that Node.js will
    prompt you with. Once finished, check whether you have successfully installed
    Node.js. Open Terminal/Command Prompt, and type the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行下载的安装包，并按照Node.js提示的安装步骤进行操作。完成后，检查是否成功安装了Node.js。打开终端/命令提示符，并键入以下命令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows (don’t worry if your version doesn’t match exactly):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果（如果您的版本不完全匹配，不要担心）：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Node.js has a very rich ecosystem of modules that is available for us to use.
    A module is a Node.js application that you can reuse in your own Node.js application.
    At the time of writing, there are over 500,000 modules. How do you manage such
    a wide diversity of Node.js modules? Meet **npm**, a package manager that manages
    Node.js modules. In fact, npm is shipped together with Node.js, so you''ve got
    it installed already. Type the following in Terminal/Command Prompt:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js拥有一个非常丰富的模块生态系统，可供我们使用。模块是一个可以在您自己的Node.js应用程序中重复使用的Node.js应用程序。在撰写本文时，已有超过50万个模块。您如何管理这么广泛的Node.js模块？认识一下**npm**，这是一个管理Node.js模块的包管理器。事实上，npm与Node.js一起发布，因此您已经安装了它。在终端/命令提示符中键入以下内容：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the following output (don’t worry if your version doesn’t match
    exactly):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出（如果您的版本不完全匹配，不要担心）：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can learn more about npm at [www.npmjs.com](http://www.npmjs.com). Now we
    are ready to start with the installation of Node.js applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[www.npmjs.com](http://www.npmjs.com)了解更多关于npm的信息。现在我们准备开始安装Node.js应用程序。
- en: Installing Git
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Git
- en: In this book, we'll be using Git to install Node.js modules. If you haven't
    installed Git yet, visit [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    and follow the installation instructions for your OS.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Git来安装Node.js模块。如果您还没有安装Git，请访问[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)并按照您的操作系统的安装说明进行安装。
- en: Getting data from the Twitter Streaming API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Twitter Streaming API获取数据
- en: The data for our React application will come from Twitter. Twitter has a **Streaming
    API** that anyone can plug into and start receiving an endless flow of public
    tweets in the JSON format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的React应用程序的数据将来自Twitter。Twitter有一个**Streaming API**，任何人都可以接入并开始以JSON格式接收无尽的公共推文流。
- en: 'To start using the Twitter Streaming API, you''ll need to perform the following
    steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Twitter Streaming API，您需要执行以下步骤：
- en: Create a Twitter account. For this, go to [https://twitter.com](https://twitter.com)
    and sign up; or sign in if you already have an account.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Twitter账户。为此，转到[https://twitter.com](https://twitter.com)并注册；或者如果您已经有账户，请登录。
- en: Create a new Twitter app by navigating to [https://apps.twitter.com](https://apps.twitter.com),
    and click on **Create New App**. You will need to fill the **Application Details**
    form, agree with **Developer Agreement**, and click on **Create your Twitter application**.
    Now you should see your application's page. Switch to the **Keys and Access Tokens**
    tab.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到[https://apps.twitter.com](https://apps.twitter.com)创建一个新的Twitter应用程序，并点击**创建新应用程序**。您需要填写**应用程序详细信息**表格，同意**开发者协议**，然后点击**创建您的Twitter应用程序**。现在您应该看到您的应用程序页面。切换到**Keys
    and Access Tokens**选项卡。
- en: 'In the **Application Settings** section of this page, you''ll find two vital
    pieces of information:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本页的**应用程序设置**部分，您会找到两个重要的信息：
- en: '**Consumer Key (API Key)**, for example, `jqRDrAlKQCbCbu2o4iclpnvem`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consumer Key (API Key)**，例如，`jqRDrAlKQCbCbu2o4iclpnvem`'
- en: '**Consumer Secret (API Secret)**, for example, `wJcdogJih7uLpjzcs2JtAvdSyCVlqHIRUWI70aHOAf7E3wWIgD`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consumer Secret (API Secret)**，例如，`wJcdogJih7uLpjzcs2JtAvdSyCVlqHIRUWI70aHOAf7E3wWIgD`'
- en: Take a note of these; we will need them later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记下这些；我们以后会用到它们。
- en: 'Now we need to generate an access token. On the same page, you''ll see the
    **Your Access Token** section that is empty. Click on the **Create my access token**
    button. It creates two pieces of information:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要生成一个访问令牌。在同一页上，您会看到空的**您的访问令牌**部分。点击**创建我的访问令牌**按钮。它会创建两个信息：
- en: '**Access Token**, for example, `12736172-R017ah2pE2OCtmi46IAE2n0z3u2DV6IqsEcPa0THR`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access Token**，例如，`12736172-R017ah2pE2OCtmi46IAE2n0z3u2DV6IqsEcPa0THR`'
- en: '**Access Token Secret**, for example, `4RTJJWIezIDcs5VX1PMVZolXGZG7L3Ez7Iz1gMdZucDaM`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access Token Secret**，例如，`4RTJJWIezIDcs5VX1PMVZolXGZG7L3Ez7Iz1gMdZucDaM`'
- en: Take a note of these too. An access token is unique to you and you should not
    share it with anyone. Keep it private.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 也记下这些。访问令牌是唯一的，您不应该与任何人分享。保持私密。
- en: Now we have everything that we need to start using Twitter's Streaming API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了开始使用Twitter的Streaming API所需的一切。
- en: Filtering data with Snapkite Engine
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Snapkite Engine过滤数据
- en: The amount of tweets that you'll receive via the Twitter Streaming API is more
    than you can ever consume, so we need to find a way to filter that stream of data
    into a meaningful set of tweets that we can display and interact with. I recommend
    that you take a quick look at the Twitter Streaming API documentation at [https://dev.twitter.com/streaming/overview](https://dev.twitter.com/streaming/overview),
    and in particular, take a look at this page that describes the way you can filter
    an incoming stream at [https://dev.twitter.com/streaming/reference/post/statuses/filter](https://dev.twitter.com/streaming/reference/post/statuses/filter).
    You'll notice that Twitter provides very few filters that we can apply, so we
    need to find a way to filter that stream of data even further.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Twitter Streaming API接收的推文数量超过您所能消费的数量，因此我们需要找到一种方法将数据流过滤为一组有意义的推文，以便我们可以显示和交互。我建议您快速查看Twitter
    Streaming API文档，特别是查看描述如何过滤传入流的页面。您会注意到Twitter提供的过滤器非常少，因此我们需要找到一种方法进一步过滤数据流。
- en: Luckily, there is a Node.js application just for this. It's called **Snapkite
    Engine**. It connects to the Twitter Streaming API, filters it using the available
    filters and according to the rules that you define, and outputs the filtered tweets
    to a web socket connection. Our proposed React application can listen to the events
    on that socket connection and process tweets as they arrive.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个专门用于此目的的Node.js应用程序。它被称为**Snapkite Engine**。它连接到Twitter Streaming API，使用可用的过滤器进行过滤，并根据您定义的规则输出经过过滤的推文到Web套接字连接。我们提出的React应用程序可以监听该套接字连接上的事件，并在推文到达时处理推文。
- en: 'Let''s install Snapkite Engine. First, you need to clone the Snapkite Engine
    repository. Cloning means that you''re copying the source code from a GitHub server
    to your local directory. In this book, I''ll assume that your local directory
    is your home directory. Open Terminal/Command Prompt and type the following commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Snapkite Engine。首先，您需要克隆Snapkite Engine存储库。克隆意味着您正在将源代码从GitHub服务器复制到本地目录。在本书中，我将假设您的本地目录是您的主目录。打开终端/命令提示符并输入以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should create the `~/snapkite-engine/` folder. We''re now going to install
    all the other node modules that `snapkite-engine` depends on. One of them is the
    `node-gyp` module. Depending on what platform you''re using, Unix or Windows,
    you will need to install other tools that are listed on this web page: [https://github.com/TooTallNate/node-gyp#installation](https://github.com/TooTallNate/node-gyp#installation).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该创建`~/snapkite-engine/`文件夹。现在我们将安装`snapkite-engine`依赖的所有其他节点模块。其中之一是`node-gyp`模块。根据您使用的平台，Unix或Windows，您将需要安装列在此网页上的其他工具：
- en: 'Once you install them, you''re ready to install the `node-gyp` module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完毕后，您可以安装`node-gyp`模块：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now navigate to the `~/snapkite-engine` directory:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导航到`~/snapkite-engine`目录：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command will install the Node.js modules that Snapkite Engine depends
    on. Now let''s configure Snapkite Engine. Assuming that you''re in the `~/snapkite-engine/`
    directory, copy the `./example.config.json` file to `./config.json` by running
    the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将安装Snapkite Engine依赖的Node.js模块。现在让我们配置Snapkite Engine。假设你在`~/snapkite-engine/`目录中，通过运行以下命令将`./example.config.json`文件复制到`./config.json`：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, if you''re using Windows, run this command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用Windows，请运行此命令：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open `config.json` in your favorite text editor. We will now edit the configuration
    properties. Let''s start with `trackKeywords`. This is where we will tell what
    keywords we want to track. If we want to track the `"my"` keyword, then set it
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开`config.json`。我们现在将编辑配置属性。让我们从`trackKeywords`开始。这是我们将告诉要跟踪哪些关键字的地方。如果我们想跟踪`"my"`关键字，那么设置如下：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we need to set our Twitter Streaming API keys. Set `consumerKey`, `consumerSecret`,
    `accessTokenKey`, and `accessTokenSecret` to the keys you saved when you created
    your Twitter App. Other properties can be set to their defaults. If you're curious
    to learn about what they are, check out the Snapkite Engine documentation at [https://github.com/snapkite/snapkite-engine](https://github.com/snapkite/snapkite-engine).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置Twitter Streaming API密钥。将`consumerKey`，`consumerSecret`，`accessTokenKey`和`accessTokenSecret`设置为创建Twitter应用程序时保存的密钥。其他属性可以设置为它们的默认值。如果你想了解它们是什么，请查看Snapkite
    Engine文档[https://github.com/snapkite/snapkite-engine](https://github.com/snapkite/snapkite-engine)。
- en: Our next step is to install Snapkite Filters. **Snapkite Filter** is a Node.js
    module that validates tweets according to a set of rules. There are a number of
    Snapkite Filters out there, and we can use any combination of them to filter our
    stream of tweets as we like. You can find a list of all the available Snapkite
    Filters at [https://github.com/snapkite/snapkite-filters](https://github.com/snapkite/snapkite-filters).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是安装Snapkite过滤器。**Snapkite Filter**是一个根据一组规则验证推文的Node.js模块。有许多Snapkite过滤器可供使用，我们可以根据需要使用任意组合来过滤我们的推文流。您可以在[https://github.com/snapkite/snapkite-filters](https://github.com/snapkite/snapkite-filters)找到所有可用的Snapkite过滤器的列表。
- en: 'In our application, we''ll use the following Snapkite Filters:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将使用以下Snapkite过滤器：
- en: '**Is Possibly Sensitive**: [https://github.com/snapkite/snapkite-filter-is-possibly-sensitive](https://github.com/snapkite/snapkite-filter-is-possibly-sensitive)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可能敏感**：[https://github.com/snapkite/snapkite-filter-is-possibly-sensitive](https://github.com/snapkite/snapkite-filter-is-possibly-sensitive)'
- en: '**Has Mobile Photo**: [https://github.com/snapkite/snapkite-filter-has-mobile-photo](https://github.com/snapkite/snapkite-filter-has-mobile-photo)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有移动照片**：[https://github.com/snapkite/snapkite-filter-has-mobile-photo](https://github.com/snapkite/snapkite-filter-has-mobile-photo)'
- en: '**Is Retweet**: [https://github.com/snapkite/snapkite-filter-is-retweet](https://github.com/snapkite/snapkite-filter-is-retweet)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是转推**：[https://github.com/snapkite/snapkite-filter-is-retweet](https://github.com/snapkite/snapkite-filter-is-retweet)'
- en: '**Has Text**: [https://github.com/snapkite/snapkite-filter-has-text](https://github.com/snapkite/snapkite-filter-has-text)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有文本**：[https://github.com/snapkite/snapkite-filter-has-text](https://github.com/snapkite/snapkite-filter-has-text)'
- en: 'Let''s install them. Navigate to the `~/snapkite-engine/filters/` directory:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装它们。导航到`~/snapkite-engine/filters/`目录：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then clone all Snapkite Filters by running these commands:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过运行以下命令克隆所有Snapkite过滤器：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to configure them. In order to do so, you need to create a
    configuration file for each Snapkite Filter in a **JSON** format and define some
    properties in it. Luckily, each Snapkite Filter comes with an example configuration
    file that we can duplicate and edit as needed. Assuming that you''re in the `~/snapkite-engine/filters/`
    directory, run the following commands (use `copy` and replace the forward slashes
    with backward slashes on Windows):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置它们。为了这样做，您需要为每个Snapkite过滤器创建一个**JSON**格式的配置文件，并在其中定义一些属性。幸运的是，每个Snapkite过滤器都附带了一个示例配置文件，我们可以根据需要复制和编辑。假设您在`~/snapkite-engine/filters/`目录中，运行以下命令（在Windows上使用`copy`并将正斜杠替换为反斜杠）：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We don't need to change any of the default settings in these `config.json` files,
    as they're already configured to fit our purposes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要更改这些`config.json`文件中的任何默认设置，因为它们已经配置好以适应我们的目的。
- en: 'Finally, we need to tell Snapkite Engine which Snapkite Filters it should use.
    Open the `~/snapkite-engine/config.json` file in a text editor and look for this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉Snapkite Engine应该使用哪些Snapkite Filters。在文本编辑器中打开`~/snapkite-engine/config.json`文件，查找这个：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now replace that with the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用以下内容替换它：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Well done! You''ve successfully installed Snapkite Engine with a number of
    Snapkite Filters. Now let''s check if we can run it. Navigate to `~/snapkite-engine/`
    and run the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经成功安装了带有多个Snapkite Filters的Snapkite Engine。现在让我们检查一下是否可以运行它。导航到`~/snapkite-engine/`并运行以下命令：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should see no error messages, but if you do and you're not sure how to fix
    them, then go to [https://github.com/fedosejev/react-essentials/issues](https://github.com/fedosejev/react-essentials/issues),
    create a new issue, and copy and paste the error message that you get.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看不到错误消息，但如果你看到了并且不确定如何解决，那么去[https://github.com/fedosejev/react-essentials/issues](https://github.com/fedosejev/react-essentials/issues)，创建一个新的问题，并复制粘贴你得到的错误消息。
- en: Next, let's set up our project's structure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置项目的结构。
- en: Creating the project structure
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目结构
- en: Now it's time to create our project structure. Organizing source files may sound
    like a simple task, but a well-thought-out project structure organization helps
    us understand the underlying architecture of our application. You'll see an example
    of this later in this book, when we'll talk about the Flux application architecture.
    Let's start by creating our root project directory named `snapterest` inside your
    home directory `~/snapterest/`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的项目结构了。组织源文件可能听起来像一个简单的任务，但深思熟虑的项目结构组织帮助我们理解我们应用的基础架构。在本书的后面，当我们谈论Flux应用程序架构时，你将看到这方面的一个例子。让我们从在你的主目录`~/snapterest/`内创建我们的根项目目录`snapterest`开始。
- en: 'Then, inside it, we will create two other directories:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在其中，我们将创建另外两个目录：
- en: '`~/snapterest/source/`: Here, we''ll store our source JavaScript files'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/snapterest/source/`：在这里，我们将存储我们的源JavaScript文件'
- en: '`~/snapterest/build/`: Here, we''ll put compiled JavaScript files and an HTML
    file'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/snapterest/build/`：在这里，我们将放置编译后的JavaScript文件和一个HTML文件'
- en: 'Now, inside `~/snapterest/source/`, create the `components/` folder so that
    your project structure would look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`~/snapterest/source/`中，创建`components/`文件夹，使得你的项目结构看起来像这样：
- en: '`~/snapterest/source/components/`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/snapterest/source/components/`'
- en: '`~/snapterest/build/`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/snapterest/build/`'
- en: Now when we have our fundamental project structure ready, let's start populating
    it with our application files. First, we need to create our main application file
    `app.js` in the `~/snapterest/source/` directory. This file will be the entry
    point to our application, `~/snapterest/source/app.js`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的基本项目结构准备好了，让我们开始用我们的应用文件填充它。首先，我们需要在`~/snapterest/source/`目录中创建我们的主应用文件`app.js`。这个文件将是我们应用的入口点，`~/snapterest/source/app.js`。
- en: Leave it empty for now, as we have a more pressing matter to discuss.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先留空，因为我们有一个更紧迫的问题要讨论。
- en: Creating package.json
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建package.json
- en: Have you ever heard of **D.R.Y.** before? It stands for **Don't Repeat Yourself**,
    and it promotes one of the core principles in software development—code reuse.
    The best code is the code that you don't need to write. In fact, one of our goals
    in this project is to write as little code as possible. You might not realize
    this yet, but React helps us achieve this goal. Not only it saves us time, but
    if we also decide to maintain and improve our project in the future, it will save
    us even more time in the long run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你以前听说过**D.R.Y.**吗？它代表**不要重复自己**，并且它提倡软件开发中的核心原则之一——代码重用。最好的代码是你不需要写的代码。事实上，我们在这个项目中的一个目标就是尽可能少地编写代码。你可能还没有意识到，但React帮助我们实现了这个目标。它不仅节省了我们的时间，而且如果我们决定在将来维护和改进我们的项目，它将在长远来看节省我们更多的时间。
- en: 'When it comes to not writing our code, we can apply the following strategies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到不编写我们的代码时，我们可以应用以下策略：
- en: Writing our code in a declarative programming style
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以声明式编程风格编写我们的代码
- en: Reusing code written by someone else
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用他人编写的代码
- en: In this project, we'll be using both techniques. The first one is covered by
    React itself. React leaves us no choice but to write our JavaScript code in a
    declarative style. This means that instead of telling our web browser how to do
    what we want (like we do with jQuery), we just tell it what we want it to do,
    and the how part is explained by React. That's a win for us.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用两种技术。第一种技术由React本身提供。React只能让我们以声明式风格编写JavaScript代码。这意味着我们不是告诉网页浏览器如何做我们想要的事情（就像我们用jQuery做的那样），而是告诉它我们想要它做什么，而React解释了如何做。这对我们来说是一个胜利。
- en: Node.js and npm cover the second technique. I mentioned earlier in this chapter
    that there are hundreds of thousands of different Node.js applications available
    for us to use. This means that most likely someone already implemented the functionality
    that our application depends on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和npm涵盖了第二种技术。我在本章前面提到，有数十万不同的Node.js应用程序可供我们使用。这意味着很可能有人已经实现了我们的应用程序所依赖的功能。
- en: The question is, where do you get all these Node.js applications that we want
    to reuse? We can install them via the `npm install <package-name>` command. In
    the npm context, a Node.js application is called a **package**, and each **npm
    package** has a `package.json` file that describes the metadata associated with
    that package. You can learn more about the fields that are stored in `package.json`
    at [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们从哪里获取所有这些我们想要重用的Node.js应用程序？我们可以通过`npm install <package-name>`命令安装它们。在npm上下文中，一个Node.js应用程序被称为**包**，每个**npm包**都有一个描述该包相关元数据的`package.json`文件。您可以在[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)了解有关存储在`package.json`中的字段的更多信息。
- en: Before we install our dependency packages, we will initialize a package for
    our own project. Normally, `package.json` is only required when you want to submit
    your package to the npm registry so that others can reuse your Node.js application.
    We're not going to build a Node.js application, and we're not going to submit
    our project to npm. Remember that `package.json` is technically only a metadata
    file that the `npm` command understands, and as such, we can use it to store a
    list of dependencies that our application requires. Once we store a list of dependencies
    in `package.json`, we can easily install them anytime with the `npm install` command;
    npm will figure out from where to get them automatically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装依赖包之前，我们将为我们自己的项目初始化一个包。通常，只有当您想要将您的包提交到npm注册表以便其他人可以重用您的Node.js应用程序时，才需要`package.json`。我们不打算构建Node.js应用程序，也不打算将我们的项目提交到npm。请记住，`package.json`从技术上讲只是`npm`命令理解的元数据文件，因此我们可以使用它来存储我们的应用程序所需的依赖项列表。一旦我们在`package.json`中存储了依赖项列表，我们就可以随时使用`npm
    install`命令轻松安装它们；npm将自动找到它们的位置。
- en: How do we create the `package.json` file for our own application? Luckily, npm
    comes with an interactive tool that asks us a bunch of questions and then based
    on our answers, creates `package.json` for our project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为我们自己的应用程序创建`package.json`文件？幸运的是，npm带有一个交互式工具，询问我们一系列问题，然后根据我们的答案为我们的项目创建`package.json`。
- en: 'Make sure that you''re located in the `~/snapterest/` directory. In Terminal/Command
    Prompt, run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您位于`~/snapterest/`目录中。在终端/命令提示符中，运行以下命令：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first thing it will ask you is your package name. It will suggest a default
    name, the name of the directory you''re located in. It should suggest `name: (snapterest)`
    in our case. Press *Enter* to accept the proposed default name (`snapterest`).
    The next question is the version of your package, that is, `version: (1.0.0)`.
    Press *Enter*. These two would be the most important fields if we were planning
    to submit our package to npm for others to reuse. Because we''re not going to
    submit it to npm, we can confidently accept defaults for all the questions that
    we were asked. Keep pressing *Enter* until `npm init` completes its execution
    and exits. Then, if you go to your `~/snapterest/` directory, you will find a
    new file there—`package.json`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它将首先询问您的软件包名称。 它将建议一个默认名称，即您所在目录的名称。 在我们的情况下，它应该建议`name：（snapterest）`。 按*Enter*接受建议的默认名称（`snapterest`）。
    下一个问题是您软件包的版本，即`version：（1.0.0）`。 按*Enter*。 如果我们计划将软件包提交给npm供其他人重用，这两个将是最重要的字段。
    因为我们不打算将其提交给npm，所以我们可以自信地接受我们被问到的所有问题的默认值。 继续按*Enter*，直到`npm init`完成执行并退出。 然后，如果您转到`〜/snapterest/`目录，您将在那里找到一个新文件-`package.json`。
- en: Now we're ready to install other Node.js applications that we're going to reuse.
    An application that is built of multiple individual applications is called **modular**,
    whereas individual applications are called **modules**. This is what we'll call
    our Node.js dependencies from now on—Node.js modules.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备安装其他我们将要重用的Node.js应用程序。 由多个单独应用程序构建的应用程序称为**模块化**，而单独的应用程序称为**模块**。 从现在开始，这就是我们将称之为我们的Node.js依赖项-Node.js模块。
- en: Reusing Node.js modules
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用Node.js模块
- en: As I mentioned earlier, there will be a step in our development process called
    **building**. During this step, our build script will take our source files and
    all our Node.js dependency packages and transform them into a single file that
    web browsers can successfully execute. The most important part of this building
    process is called **packaging**. But what do we need to package and why? Let's
    think about it. I briefly mentioned earlier that we're not creating a Node.js
    application, but yet we're talking about reusing Node.js modules. Does this mean
    that we'll be reusing Node.js modules in a nonNode.js application? Is that even
    possible? It turns out that there is a way of doing this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们的开发过程中将有一个称为**构建**的步骤。 在此步骤中，我们的构建脚本将获取我们的源文件和所有Node.js依赖包，并将它们转换为Web浏览器可以成功执行的单个文件。
    这个构建过程中最重要的部分称为**打包**。 但是我们需要打包什么以及为什么呢？ 让我们考虑一下。 我之前简要提到过，我们并不是在创建一个Node.js应用程序，但我们正在谈论重用Node.js模块。
    这是否意味着我们将在非Node.js应用程序中重用Node.js模块？ 这可能吗？ 原来有一种方法可以做到这一点。
- en: '**Webpack** is a tool used for bundling all your dependency files together
    in such a way that you can reuse Node.js modules in client-side JavaScript applications.
    You can learn more about Webpack at [http://webpack.js.org](http://webpack.js.org).
    To install Webpack, run the following command from inside the `~/snapterest/`
    directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Webpack**是一种工具，用于以这样一种方式捆绑所有依赖文件，以便您可以在客户端JavaScript应用程序中重用Node.js模块。 您可以在[http://webpack.js.org](http://webpack.js.org)了解有关Webpack的更多信息。
    要安装Webpack，请从`〜/snapterest/`目录内运行以下命令：'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice the `--save-dev` flag. It tells npm to add Webpack to our `package.json`
    file as a development dependency. Adding a module name to our `package.json` file
    as a dependency allows us to record what dependencies we''re using, and we can
    easily install them later with the `npm install` command, if needed. There is
    a distinction between the dependencies that are required to run your application
    and the ones that are required to develop your application. Webpack is used at
    build time, and not at runtime, so it''s a development dependency. Hence, the
    use of the `--save-dev` flag. If you check the content of your `package.json`
    file now, you''ll see this (don’t worry if your Webpack version doesn’t match
    exactly):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`--save-dev`标志。它告诉npm将Webpack添加到我们的`package.json`文件中作为开发依赖项。将模块名称添加到我们的`package.json`文件中作为依赖项允许我们记录我们正在使用的依赖项，并且如果需要的话，我们可以很容易地使用`npm
    install`命令稍后安装它们。运行应用程序所需的依赖项与开发应用程序所需的依赖项之间有区别。Webpack在构建时使用，而不是在运行时，因此它是开发依赖项。因此，使用`--save-dev`标志。如果您现在检查您的`package.json`文件的内容，您会看到这个（如果您的Webpack版本不完全匹配，不要担心）：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that npm created a new folder in your `~/snapterest/` directory called
    `node_modules`. This is the place where it puts all your local dependency modules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: npm在您的`〜/snapterest/`目录中创建了一个名为`node_modules`的新文件夹。这是它放置所有本地依赖模块的地方。
- en: Congrats on installing your first Node.js module! Webpack will allow us to use
    Node.js modules in our client-side JavaScript applications. It will be a part
    of our build process. Now let's take a closer look at our build process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您安装了您的第一个Node.js模块！Webpack将允许我们在客户端JavaScript应用程序中使用Node.js模块。它将成为我们构建过程的一部分。现在让我们更仔细地看看我们的构建过程。
- en: Building with Webpack
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack构建
- en: Today, any modern client-side application represents a mix of many concerns
    that are addressed individually by various technologies. Addressing each concern
    individually simplifies the overall process of managing the project's complexity.
    The downside of this approach is that at some point in your project, you need
    to put together all the individual parts into one coherent application. Just like
    the robots in an automotive factory that assemble cars from individual parts,
    developers have something called as build-tools that assemble their projects from
    individual modules. This process is called the **build** process, and depending
    on the size and complexity of your project, it can take anywhere from milliseconds
    to hours to build.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，任何现代的客户端应用程序都代表了许多由各种技术单独解决的问题的混合。单独解决每个问题简化了管理项目复杂性的整个过程。这种方法的缺点是，在项目的某个时候，您需要将所有单独的部分组合成一个连贯的应用程序。就像汽车工厂中的机器人从单独的零件组装汽车一样，开发人员有一种称为构建工具的东西，可以从单独的模块中组装他们的项目。这个过程被称为**构建**过程，根据项目的大小和复杂性，构建过程可能需要从毫秒到几个小时不等的时间。
- en: Webpack will help us to automate our build process. First, we need to configure
    Webpack. Assuming you're in your `~/snapterest/` directory, create a new `webpack.config.js`
    file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将帮助我们自动化我们的构建过程。首先，我们需要配置Webpack。假设您在`〜/snapterest/`目录中，创建一个新的`webpack.config.js`文件。
- en: 'Now let''s describe our build process in the `webpack.config.js` file. In this
    file, we''ll create a JavaScript object that describes how to bundle our source
    files. We want to export that configuration object as a Node.js module. Yes, we''ll
    treat our `webpack.config.js` file as a Node.js module. To do this, we''ll assign
    our empty configuration object to a special `module.exports` property:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`webpack.config.js`文件中描述我们的构建过程。在这个文件中，我们将创建一个描述如何捆绑我们的源文件的JavaScript对象。我们希望将该配置对象导出为一个Node.js模块。是的，我们将把我们的`webpack.config.js`文件视为一个Node.js模块。为了做到这一点，我们将把我们的空配置对象分配给一个特殊的`module.exports`属性：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `module.exports` property is a part of the Node.js API. It''s a way of
    telling Node.js that whenever someone imports our module they will get access
    to that object. So what should this object look like? This is where I recommend
    that you to take a look at Webpack''s documentation and read about the core concepts
    of Webpack, from the following link: [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports`属性是Node.js API的一部分。这是告诉Node.js，每当有人导入我们的模块时，他们将获得对该对象的访问权限。那么这个对象应该是什么样子的呢？这就是我建议你去查看Webpack文档并阅读关于Webpack核心概念的链接：[https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)'
- en: 'The first property of our configuration object will be the `entry` property:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置对象的第一个属性将是`entry`属性：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the name suggests, the `entry` property describes the entry point to our
    web application. In our case, the value for this property is `./source/app.js`—this
    is the first file that starts our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，`entry`属性描述了我们web应用的入口点。在我们的例子中，这个属性的值是`./source/app.js`—这是启动我们应用的第一个文件。
- en: 'The second property of our configuration object will be the `output` property:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置对象的第二个属性将是`output`属性：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `output` property tells Webpack where to output the resulting bundle file.
    In our case, we're saying that we want the resulting bundle file to be called
    `snapterest.js` and it should be saved to the `./build` directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`output`属性告诉Webpack在哪里输出生成的捆绑文件。在我们的例子中，我们说我们希望生成的捆绑文件叫做`snapterest.js`，并且应该保存到`./build`目录中。'
- en: Webpack treats every source file as a module, which means all our JavaScript
    source files will be treated as modules that Webpack will need to bundle together.
    How do we explain this to Webpack?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将每个源文件视为一个模块，这意味着所有我们的JavaScript源文件将被视为Webpack需要捆绑在一起的模块。我们如何向Webpack解释这一点呢？
- en: 'We do this with the help of the third property of our configuration object
    called `module`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过配置对象的第三个属性`module`来实现这一点：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, our `module` property gets an object as its value. This object
    has a single property called `rules`—an array of rules where each rule describes
    how to create Webpack modules from different source files. Let's take a closer
    look at our rules.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`module`属性得到一个对象作为它的值。这个对象有一个叫做`rules`的属性—一个规则数组，其中每个规则描述了如何从不同的源文件创建Webpack模块。让我们更仔细地看看我们的规则。
- en: 'We have a single rule that tells Webpack how to handle our source JavaScript
    files:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单一规则告诉Webpack如何处理我们的源JavaScript文件：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This rule has three properties: `test`, `use`, and `exclude`. The `test` property
    tells Webpack which files this rule applies to. It does this by matching our source
    file names against the RegEx expression that we specified as a value for our `test`
    property: `/\.js$/`. If you''re familiar with RegEx, then you''ll recognise that
    `/\.js$/` will match all filenames that end with `.js`. This is exactly what we
    want: to bundle all our JavaScript files.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有三个属性：`test`，`use`和`exclude`。`test`属性告诉Webpack这个规则适用于哪些文件。它通过将我们的源文件名与我们指定为`test`属性值的正则表达式进行匹配来实现：`/\.js$/`。如果你熟悉正则表达式，你会认识到`/\.js$/`将匹配所有以`.js`结尾的文件名。这正是我们想要的：打包所有的JavaScript文件。
- en: When Webpack finds and loads all source JavaScript files, it tries to interpret
    them as plain JavaScript files. However, our JavaScript files won't be plain JavaScript
    files, instead they will have ECMAScript 2016 syntax, as well as React-specific
    syntax.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当Webpack找到并加载所有源JavaScript文件时，它会尝试将它们解释为普通的JavaScript文件。然而，我们的JavaScript文件不会是普通的JavaScript文件，而是具有ECMAScript
    2016语法以及React特定语法。
- en: 'How can Webpack understand all that nonplain JavaScript syntax? With the help
    of Webpack loaders we can transform nonplain JavaScript syntax in to plain JavaScript.
    A Webpack loader is a transformation applied to a source file. Our `use` property
    describes a list of transformations that we want to apply:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack如何理解所有非普通的JavaScript语法？借助于Webpack加载器，我们可以将非普通的JavaScript语法转换为普通的JavaScript。Webpack加载器是应用于源文件的转换。我们的`use`属性描述了我们想要应用的转换列表：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have one transformation that is responsible for transforming our React-specific
    syntax and ECMAScript 2016 syntax into plain JavaScript:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个转换负责将我们的React特定语法和ECMAScript 2016语法转换为普通JavaScript：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Webpack transformations are described with objects that have the `loader` and
    `options` properties. The `loader` property tells Webpack which loader performs
    the transformation, and the `options` property tells it which options should be
    passed to that loader. The loader that will transform our ECMAScript 2016 and
    React-specific syntaxes in to plain JavaScript is called `babel-loader`. This
    specific transformation process is called **transpilation** or **source-to-source
    compilation**—it takes source code written in one syntax and transforms it into
    a source code written in another syntax. We''re using one of the most popular
    JavaScript transpilers today, called **Babel**: [https://babeljs.io](https://babeljs.io).
    Webpack has a Babel loader that uses Babel transpiler to transform our source
    code. Babel loader comes as a separate Node.js module. Let''s install this module
    and add it to the list of our development dependencies. Assuming you''re in your
    `~/snapterest/` directory, run this command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack转换是用具有`loader`和`options`属性的对象来描述的。`loader`属性告诉Webpack哪个加载器执行转换，`options`属性告诉它应该传递给该加载器哪些选项。将我们的ECMAScript
    2016和特定于React的语法转换为普通JavaScript的加载器称为`babel-loader`。这个特定的转换过程称为**转译**或**源到源编译**——它将用一种语法编写的源代码转换为另一种语法编写的源代码。我们今天使用的是最流行的JavaScript转译器之一，叫做**Babel**：[https://babeljs.io](https://babeljs.io)。Webpack有一个使用Babel转译器来转换我们源代码的Babel加载器。Babel加载器作为一个独立的Node.js模块。让我们安装这个模块并将其添加到我们的开发依赖列表中。假设你在`~/snapterest/`目录中，运行以下命令：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `options` property of our Webpack loader has a couple of Babel presents:
    `latest` and `react` and a Babel `transform-class-properties` plugin:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Webpack加载器的`options`属性有一些Babel预设：`latest`和`react`以及一个Babel`transform-class-properties`插件：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These are Babel plugins that transpile different syntaxes: the `latest` plugin
    transpiles the syntaxes of ECMAScript 2015, ECMAScript 2016, and ECMAScript 2017
    to old JavaScript syntax, and the `react` plugin transpiles React-specific syntax
    to plain JavaScript syntax, while the `transform-class-properties` plugin transpiles
    class properties.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是负责转换不同语法的Babel插件：`latest`插件将ECMAScript 2015、ECMAScript 2016和ECMAScript 2017的语法转换为旧的JavaScript语法，`react`插件将React特定的语法转换为普通的JavaScript语法，而`transform-class-properties`插件将类属性转换为普通的JavaScript语法。
- en: 'These Babel plugins are distributed as standalone Node.js modules, which we
    need to install separately. Assuming you''re in your `~/snapterest/` directory,
    run the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Babel插件是作为独立的Node.js模块分发的，我们需要单独安装它们。假设你在`~/snapterest/`目录中，运行以下命令：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we have the third property in our Webpack rule called `exclude`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在Webpack规则中有第三个属性叫做`exclude`：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This property tells Webpack to exclude the `node_modules` directory from our
    transformation process.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性告诉Webpack在转换过程中排除`node_modules`目录。
- en: 'Now we have our `webpack.config.js` file ready. Before we run our bundling
    process for the first time, let''s add a new script called `start` to our `package.json`
    file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`webpack.config.js`文件已经准备好了。在我们第一次运行打包过程之前，让我们在`package.json`文件中添加一个名为`start`的新脚本：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now if you run `npm run start` or `npm start`, npm will run the `webpack -p
    --config webpack.config.js` command. This command runs Webpack that bundles our
    source files for production using the `webpack.config.js` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行`npm run start`或者`npm start`，npm会运行`webpack -p --config webpack.config.js`命令。这个命令会运行Webpack，用`webpack.config.js`文件打包我们的源文件以供生产使用。
- en: 'We''re ready to bundle our source files! Navigate to your `~/snapterest/` directory
    and run this command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好打包我们的源文件了！转到你的`~/snapterest/`目录并运行这个命令：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the output, you should see the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你应该会看到以下内容：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: More importantly, if you check your project's `~/snapterest/build/` directory,
    you'll notice that it now has the `snapterest.js` file with some code already
    inside of it—that's our (empty) JavaScript application with some Node.js modules
    that are ready to run in a web browser!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，如果你检查你的项目的`~/snapterest/build/`目录，你会注意到现在有一个`snapterest.js`文件，里面已经有一些代码了——那就是我们（空的）JavaScript应用程序，里面有一些Node.js模块，可以在web浏览器中运行！
- en: Creating a web page
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个网页
- en: If you're hungry for some React goodness, then I have great news for you! We're
    almost there. All that's left to do is to create `index.html` with a link to our
    `snapterest.js` script.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渴望一些React的好处，那么我有个好消息告诉你！我们快要完成了。剩下要做的就是创建一个带有指向我们`snapterest.js`脚本的`index.html`。
- en: 'Create the `index.html` file in the `~/snapterest/build/` directory. Add the
    following HTML markup to it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`~/snapterest/build/`目录中创建`index.html`文件。添加以下HTML标记：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open `~/snapterest/build/index.html` in a web browser. You should see the following
    text: **I am about to learn the essentials of React.js**. That''s right, we have
    finished setting up our project, and it''s time to get to know React!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在web浏览器中打开`~/snapterest/build/index.html`。你应该会看到以下文字：**我即将学习React.js的基本知识**。没错，我们已经完成了项目的设置，现在是时候了解React了！
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned why we should use React to build user interfaces
    for modern web applications. Then, we discussed the project that we'll be building
    in this book. Finally, we installed all the right tools and created the project's
    structure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了为什么我们应该使用React来构建现代web应用程序的用户界面。然后，我们讨论了这本书中我们将要构建的项目。最后，我们安装了所有正确的工具，并创建了项目的结构。
- en: In the next chapter, we'll install React, take a closer look at how React works,
    and create our first React Element.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将安装React，更仔细地了解React的工作原理，并创建我们的第一个React元素。
