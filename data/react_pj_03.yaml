- en: Build a Dynamic Project Management Board with React and Suspense
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React和Suspense构建动态项目管理面板
- en: In the first two chapters of this book, you've already created two React projects
    all by yourself, and you should, by now, have a solid understanding of the core
    concepts of React. The concepts you've used so far will also be used in this chapter
    to create your third project with React, including some new and more advanced
    concepts that will show you the strength of using React. Again, if you feel you
    may lack some of the knowledge you'll need to finalize the contents of this chapter,
    you can always repeat what you have built so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的前两章中，你已经自己创建了两个React项目，现在你应该对React的核心概念有了扎实的理解。到目前为止，你已经使用的概念也将在本章中用于创建你的第三个React项目，其中包括一些新的和更高级的概念，这将展示出使用React的强大之处。如果你觉得自己可能缺乏完成本章内容所需的一些知识，你可以随时重复你到目前为止所建立的内容。
- en: This chapter will once again use Create React App, which you used in the previous
    chapter. During the development of the project management board application for
    this chapter, you'll use reusable components that have been created using `styled-components`.
    Following this, you'll use more advanced React techniques to control the dataflow
    throughout your components. Furthermore, HTML5 Web APIs will be used to dynamically
    drag and drop components that function as **Higher-Order Components** (**HOC**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将再次使用Create React App，这是你在上一章中使用过的。在开发本章的项目管理面板应用程序时，你将使用使用`styled-components`创建的可重用组件。之后，你将使用更高级的React技术来控制组件中的数据流。此外，将使用HTML5
    Web API来动态拖放作为**高阶组件**（**HOC**）的组件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: React Suspense and code-splitting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Suspense和代码拆分
- en: Using HOC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HOC
- en: Dynamic data flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态数据流
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a **Progressive Web Application** (**PWA**)
    that has reusable React components and styling using Create React App and `styled-components`.
    The application will feature a dynamic drag and drop interface that uses the HTML5
    Drag and Drop API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Create React App和`styled-components`创建一个可重用的React组件和样式的**渐进式Web应用程序**（**PWA**）。该应用程序将具有使用HTML5拖放API的动态拖放界面。
- en: The build time is 1.5-2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为1.5-2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch3-initial](https://github.com/PacktPublishing/React-Projects/tree/ch3-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch3](https://github.com/PacktPublishing/React-Projects/tree/ch3).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个基于GitHub上初始版本的项目：[https://github.com/PacktPublishing/React-Projects/tree/ch3-initial](https://github.com/PacktPublishing/React-Projects/tree/ch3-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch3](https://github.com/PacktPublishing/React-Projects/tree/ch3)。
- en: After downloading the initial application from GitHub, we can start by moving
    into its root directory and running the `npm install` command. This will install
    the core packages from Create React App (`react`, `react-dom`, and `react-scripts`) next
    to the `styled-components` package, which we used in the previous chapter. After
    the installation, we can start the application by executing the `npm start` command and
    visit the project in the browser by visiting `http://localhost:3000`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载初始应用程序后，我们可以进入其根目录并运行`npm install`命令。这将安装来自Create React App的核心包（`react`、`react-dom`和`react-scripts`），以及我们在上一章中使用的`styled-components`包。安装完成后，我们可以通过执行`npm
    start`命令启动应用程序，并通过访问`http://localhost:3000`在浏览器中访问项目。
- en: We can also build the application by executing `npm run build` and subsequently `serve
    -s build`. The minified version of the application can now be visited at `http://localhost:5000`.
    Since it's been set up as a PWA, it will also work without any internet connection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过执行`npm run build`，然后`serve -s build`来构建应用程序。现在可以访问应用程序的缩小版本`http://localhost:5000`。由于它被设置为PWA，即使没有任何互联网连接，它也可以工作。
- en: It's possible that you'll see a different application than when you ran the
    project locally, if you've built and served a Create React App PWA before. This
    is due to the service worker of the PWA that has stored a cached version of that
    application in the browser. You can delete any previous application from the browser
    cache by opening `devTools` and opening the Application tab, where you can click
    on the Clear site data button in the Clear storage section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前构建并提供了Create React App PWA，可能会看到与在本地运行项目时不同的应用程序。这是由于PWA的service worker在浏览器中存储了该应用程序的缓存版本。您可以通过打开`devTools`并打开`Application`选项卡，在`Clear
    storage`部分中单击`Clear site data`按钮来从浏览器缓存中删除任何先前的应用程序。
- en: 'As shown in the following screenshot, the application has a basic header with
    a title and is divided into four columns. These columns are the lanes for the
    **Project Management Board** and will contain the individual tickets once we''ve
    connected the project to the data file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，该应用程序具有一个基本的标题和分为四列。这些列是**项目管理看板**的车道，一旦我们将项目连接到数据文件，它们将包含各个票证：
- en: '![](assets/85a074c4-8949-4341-a38f-6bd913bc28a5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85a074c4-8949-4341-a38f-6bd913bc28a5.png)'
- en: As we mentioned in [Chapter 2](ee5cf0ab-57c2-48bc-8c50-281de22969c5.xhtml), *Creating
    a Progressive Web Application with Reusable React Components*, we can check whether
    our application is running when there is no internet connection by visiting the Service
    Workers section of the Application tab. On this page, we can check the Offline checkbox
    and try refreshing the browser.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ee5cf0ab-57c2-48bc-8c50-281de22969c5.xhtml)中提到的，*使用可重用的React组件创建渐进式Web应用程序*，我们可以通过访问`Application`选项卡的`Service
    Workers`部分来检查当没有互联网连接时我们的应用程序是否正在运行。在此页面上，我们可以选中`Offline`复选框，然后尝试刷新浏览器。
- en: If we look at the project's structure, we'll see that it's structured in the
    same way as the projects in the previous chapters. The entry point of the application
    is the `src/index.js` file, which renders a component called `App`, which holds
    two other components called `Header` and `Board`. The first one is the actual
    header of the application, while the `Board` component holds the four columns
    we can see in the application. These columns are represented by the `Lane` component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看项目的结构，我们会发现它的结构与前几章的项目相同。应用程序的入口点是`src/index.js`文件，它渲染了一个名为`App`的组件，该组件包含两个其他组件，分别是`Header`和`Board`。第一个是应用程序的实际标题，而`Board`组件包含我们在应用程序中看到的四个列。这些列由`Lane`组件表示。
- en: 'Also, in the `assets` directory, we will see a file called `data.json`, which
    contains data that we can display on the project management board:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`assets`目录中，我们会看到一个名为`data.json`的文件，其中包含我们可以在项目管理看板上显示的数据：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a project management board application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目管理看板应用
- en: In this section, we'll create a project management board PWA that uses React
    APIs such as Suspense and the HTML5 Drag and Drop API. We're going to use a Create
    React App, which we can find in the GitHub repository for this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个使用React API（如Suspense和HTML5拖放API）的项目管理看板PWA。我们将使用Create React App，可以在本章的GitHub存储库中找到。
- en: Handling the data flow
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据流
- en: With the initial version of the application in place, the next step is to fetch
    the data from the data file and handle its flow through the components. For this,
    we will use React Suspense and memo. With Suspense, we can access the React lazy
    API to dynamically load components and, with memo, we can control which components
    should rerender when their props change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置初始版本的应用程序之后，下一步是从数据文件中获取数据并通过组件处理其流程。为此，我们将使用React Suspense和memo。使用Suspense，我们可以访问React懒加载API来动态加载组件，并且使用memo，我们可以控制哪些组件在其props更改时应该重新渲染。
- en: The first part of this section will show us how to load data from a data source
    using React life cycle methods and display this in React components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的第一部分将向我们展示如何使用React生命周期方法从数据源加载数据并在React组件中显示。
- en: Loading and displaying the data
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示数据
- en: 'Loading and displaying data that is retrieved from a data source is something
    we did in the previous chapter. This section will explore this further. Follow
    these steps to get started:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和显示从数据源检索的数据是我们在上一章中做过的事情。本节将进一步探讨这一点。按照以下步骤开始：
- en: 'We will start by fetching the project data from the data file. To do this,
    we need to add the necessary functions to the `Board` component. We need these
    to access the React life cycles. These are `constructor`, where the initial state
    is set, and `componentDidMount`, where the data will be fetched:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从数据文件中获取项目数据开始。为此，我们需要向`Board`组件添加必要的函数。我们需要这些函数来访问React生命周期。这些是`constructor`，在其中设置初始状态，以及`componentDidMount`，在其中将获取数据：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `componentDidMount` life cycle function, the data is fetched inside a
    `try..catch` statement. This statement catches any errors that are being returned
    from the data fetching process and replaces the error state with this message.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`componentDidMount`生命周期函数中，在`try..catch`语句内获取数据。此语句捕获从数据获取过程返回的任何错误，并用此消息替换错误状态。
- en: 'Now, we can distribute the tickets over the corresponding lanes:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将票务分发到相应的车道上：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we can see that, inside `render`, the `data`, `loading`,
    and `error` constants have been destructured from the state object. Inside the
    function that iterates over the `lanes` constant, these values should be passed
    as props to the `Lane` component. For the data state, something special is going
    on since the `filter` function is being used to only return tickets from the `data`
    state that match the lane ID.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以看到，在`render`内部，`data`，`loading`和`error`常量已经从状态对象中解构出来。在迭代`lanes`常量的函数内部，这些值应该作为props传递给`Lane`组件。对于数据状态，有一些特殊的情况，因为`filter`函数被用来仅返回与车道ID匹配的`data`状态的票。
- en: '3\. Next, we need to make some changes to the `Lane` component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 接下来，我们需要对`Lane`组件进行一些更改：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Lane` component now takes three other props, that is, `tickets`, `loading`,
    and `error`, where `tickets` contains the array of tickets from the `data` state, `loading`
    indicates whether the loading message should be displayed, and `error` contains
    the error message when there is one. We can see that a wrapper has been created
    and that, inside the `map` function, the `Ticket` component that displays the
    ticket information will be rendered. This `Ticket` component is also something
    we need to create in the `src/components` directory:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Lane`组件现在需要三个其他props，即`tickets`，`loading`和`error`，其中`tickets`包含来自`data`状态的票数组，`loading`表示是否应显示加载消息，`error`包含错误消息（如果有的话）。我们可以看到已经创建了一个包装器，并且在`map`函数内部，将呈现显示票务信息的`Ticket`组件。这个`Ticket`组件也是我们需要在`src/components`目录中创建的：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we visit our application in a web browser at `http://localhost:3000`, we
    will see the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网页浏览器中访问`http://localhost:3000`，我们会看到以下内容：
- en: '![](assets/36586f9d-bcd0-4458-829f-6d7eaf57f8c3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36586f9d-bcd0-4458-829f-6d7eaf57f8c3.png)'
- en: As this application has been set up as a PWA, we can build the project again
    and restart the service worker. In offline mode, the project should still display
    the header and the four columns, with a message inside these columns that displays Failed
    to fetch*.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此应用程序已设置为PWA，我们可以重新构建项目并重新启动服务工作程序。在离线模式下，项目应该仍然显示标题和四列，并在这些列内显示一个消息，显示“无法获取*”。
- en: To build and serve the PWA, we need to run `npm run` and `serve -s build` after
    the build process has completed. Now, we can visit the project at `http://localhost:5000`.
    We may need to restart the service worker, which we can do in the `devTools` on
    the Application tab, and select the Service Worker section. On the right-hand
    side of this section, next to the service worker, press Update. To check out the
    application in offline mode, we need to check the Offline checkbox.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和提供PWA，我们需要在构建过程完成后运行`npm run`和`serve -s build`。现在，我们可以访问项目`http://localhost:5000`。我们可能需要重新启动服务工作程序，在“devTools”中的“应用程序”选项卡上可以执行此操作，并选择“服务工作程序”部分。在此部分的右侧，紧挨服务工作程序，按“更新”。要在离线模式下查看应用程序，我们需要选中“离线”复选框。
- en: Fetching data from a data source is logic that can be reused throughout our
    application. In the next section, we will explore how this logic can be reused across
    multiple components with HOC.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据源获取数据是可以在整个应用程序中重复使用的逻辑。在下一节中，我们将探讨如何使用HOC在多个组件之间重用此逻辑。
- en: Getting started with HOC
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用HOC
- en: HOCs are advanced features in React that focus on the reusability of our components.
    They aren't part of the official React APIs, but introduce a pattern that is popular
    among the core team and many libraries, such as Redux.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: HOC是React中的高级功能，专注于组件的可重用性。它们不是官方的React API的一部分，但引入了一种在核心团队和许多库中流行的模式。
- en: In the first part of this section, we'll create our first HOC, which uses logic
    to retrieve data from the data source that we created in the previous section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分中，我们将创建我们的第一个HOC，该HOC使用逻辑从我们在上一节中创建的数据源中检索数据。
- en: Creating HOC
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HOC
- en: 'As we mentioned previously, HOCs focus on reusing components. Therefore, it
    can best be described as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，HOC专注于重用组件。因此，它可以最好地描述如下：
- en: '"A HOC is a function that takes a component and returns a new component."'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “HOC是一个接受组件并返回一个新组件的函数。”
- en: To explain what this means in practice, let's create an example. Our project
    has a `Board` component, which fetches and renders all the lanes. There is logic
    in this component in the form of a `constructor`, a `componentDidMount`, and information
    about how each `Lane` component is being rendered. How would we handle a situation
    where we just want to show a board without lanes, but only tickets? Do we just
    send different props to the `Board` component? Sure, that's possible, but, in
    React, that's what HOCs are used for.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这在实践中意味着什么，让我们创建一个示例。我们的项目有一个`Board`组件，它获取并呈现所有的车道。在这个组件中有逻辑，以`constructor`、`componentDidMount`的形式，以及关于如何呈现每个`Lane`组件的信息。我们如何处理只想显示一个没有车道，只有票的情况？我们只是向`Board`组件发送不同的props吗？当然，这是可能的，但在React中，这就是HOC的用途。
- en: A `Board` component without lanes wouldn't map over all the lanes and render
    the corresponding lane with the tickets as a prop. Instead, it would map over
    all the tickets and render them directly. Although the rendered components are
    different, the logic to set the initial state, fetch the data, and render the
    component(s) could be reused. The HOC should be able to add the life cycles to
    the `Board` component just by sending this component to it, along with some additional
    props.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有`lanes`的`Board`组件将不会映射所有的`lanes`并将相应的`lane`作为props渲染。相反，它将映射所有的`tickets`并直接渲染它们。尽管渲染的组件不同，但设置初始状态、获取数据和渲染组件的逻辑可以被重用。HOC应该能够通过将这个组件发送给它以及一些额外的props，为`Board`组件添加生命周期。
- en: 'To create the HOC, place a new file called `withDataFetching.js` inside the
    `src` directory. Now, follow these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建HOC，将一个名为`withDataFetching.js`的新文件放在`src`目录中。现在，按照以下步骤进行操作：
- en: 'First, we need to import React and create a new function for the HOC which
    becomes the default export. Since this HOC will add the life cycles for data fetching,
    let''s call this HOC `withDataFetching` and have it take a component as a parameter.
    This function should return another component:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入React并创建一个新的HOC函数，它成为默认导出。由于这个HOC将为数据获取添加生命周期，让我们称这个HOC为`withDataFetching`，并让它以组件作为参数。这个函数应该返回另一个组件。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside this returned component, add the `constructor` component, which has
    almost the same structure as the `Board` component:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回的组件内部，添加`constructor`组件，它的结构几乎与`Board`组件相同。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to create the `componentDidMount` function, which is where the
    data fetching will be done. The `dataSource` prop is used as the location to fetch
    from. Also, notice that the constant names are now more generic and no longer
    specify a single use:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`componentDidMount`函数，这是数据获取的地方。`dataSource`属性被用作获取数据的位置。另外，请注意，常量名称现在更加通用，不再指定单一用途。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `render` function, we can return the `WrappedComponent` that was inserted
    into the function and pass the `data`, `loading`, and `error` state as props.
    It''s important to understand that it also takes any additional props that are
    spread with `{...this.props}`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`函数中，我们可以返回插入到函数中的`WrappedComponent`，并将`data`、`loading`和`error`状态作为props传递。重要的是要理解，它还接受任何通过`{...this.props}`扩展的额外props。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Congratulations! You''ve created your very first HOC! However, it needs a component
    to return a component that supports data fetching. Therefore, we need to refactor
    our `Board` component into a function component. Let''s get started:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了你的第一个HOC！但是，它需要一个组件来返回一个支持数据获取的组件。因此，我们需要将我们的`Board`组件重构为一个函数组件。让我们开始吧：
- en: 'Import the HOC from the `src/withDataFetching.js` file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/withDataFetching.js`文件中导入HOC：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Subsequently, we can delete the entire class component, that is, `Board`, from
    this file and create a new function component that returns the JSX we declared
    in the `return` function for the refactored class component. This function component
    will take `lanes`, `loading`, `error`, and `data` as props:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，我们可以从这个文件中删除整个类组件`Board`，并创建一个新的函数组件，返回我们在重构后的类组件的`return`函数中声明的JSX。这个函数组件将以`lanes`、`loading`、`error`和`data`作为props。
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '3\. Finally, export the function component along with the HOC function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 最后，导出函数组件以及HOC函数：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But where do these props come from? If we open the application and open up
    the browser, we will see the following error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些props是从哪里来的呢？如果我们打开应用程序并打开浏览器，我们会看到以下错误：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is because our `Board` component tries to map over the `lanes` prop, but,
    in the HOC, `WrappedComponent` receives the `data`, `loading`, and `error` props.
    Luckily, we''ve also added the option to spread over any additional props that
    are sent to the component. If we open the `App` component where the `Board` component
    is being opened, we can pass the `lanes` prop with the `lane` constant that was
    declared in the `Board` component previously:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的`Board`组件尝试对`lanes`prop进行映射，但是在HOC中，`WrappedComponent`接收到`data`、`loading`和`error`
    prop。幸运的是，我们还添加了通过组件发送的任何其他props的扩展选项。如果我们打开`App`组件，在那里`Board`组件被打开，我们可以使用之前在`Board`组件中声明的`lane`常量传递`lanes`prop：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, if we take a look at our project in the browser, we''ll see that the application
    has been rendered again. However, it displays an error message from the `try...catch`
    statement in the HOC. This HOC needs the `dataSource0` prop, which we also need
    to pass to the `Board` component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在浏览器中查看我们的项目，我们会看到应用程序再次被渲染。然而，它显示了HOC中`try...catch`语句的错误消息。这个HOC需要`dataSource0`
    prop，我们也需要将其传递给`Board`组件：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we can see the `Board` component being rendered by the HOC in the browser.
    However, as we mentioned previously, a HOC is supposed to reuse logic. In the
    next section, we'll learn how to do this by adding the HOC to a different component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到`Board`组件在浏览器中由HOC渲染。然而，正如我们之前提到的，HOC应该重用逻辑。在下一节中，我们将学习如何通过将HOC添加到不同的组件来实现这一点。
- en: Using the HOC
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HOC
- en: 'With the very first HOC in place it''s time to think of other components you
    can create with this HOC, such as a component that is displaying only tickets.
    The process to create this component consists of two steps: creating the actual
    component and importing the component and passing the required props to it. Let''s
    get started:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个HOC就位的情况下，现在是时候考虑使用这个HOC创建其他组件，比如只显示票的组件。创建这个组件的过程包括两个步骤：创建实际的组件并导入组件并向其传递所需的props。让我们开始吧：
- en: 'Inside the directory containers, we need to create a new file called `Tickets.js` and
    place the following code inside it. Where we imported the HOC, set some basic
    styling with `styled-components` and create a function component that we can export
    with the HOC:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在containers目录中，我们需要创建一个名为`Tickets.js`的新文件，并将以下代码放入其中。在我们导入HOC的地方，使用`styled-components`设置一些基本样式，并创建一个可以导出的函数组件：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `App` component, we can import this component and pass a `dataSource`
    prop to it:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件中，我们可以导入这个组件并向其传递一个`dataSource` prop：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Something that seems a bit off is how the tickets are displayed next to each
    other without any margin. We could change this in the actual `Ticket` component,
    but that would also change the margin for the tickets that are displayed in the
    lanes. What we can do to solve this problem is pass a prop that is being used
    by `styled-components` to this component. To do this, we need to make changes
    to the `Tickets` component where we render the tickets and the `Ticket` component
    where the styling is defined. Let''s get started:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有点不对劲的是，票据显示在一起而没有任何边距。我们可以在实际的`Ticket`组件中更改这一点，但这也会改变在车道中显示的票据的边距。为了解决这个问题，我们可以传递一个被`styled-components`用于这个组件的prop。为了做到这一点，我们需要对渲染票据的`Tickets`组件和定义样式的`Ticket`组件进行更改。让我们开始吧：
- en: 'Pass a new prop called `marginRight` to the `Ticket` components inside the
    `map` function. This prop is just a Boolean and takes no value:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`map`函数内部向`Ticket`组件传递一个名为`marginRight`的新prop。这个prop只是一个布尔值，不需要值：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `Ticket` component, we need to destructure this prop and pass it to
    the `TicketWrapper` we created with `styled-components`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Ticket`组件中，我们需要解构这个prop并将它传递给我们用`styled-components`创建的`TicketWrapper`：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can control the `margin-right` property for this `TicketWrapper` just
    by sending props to the `Ticket` component. If we view our application in a browser,
    we''ll see how, right below our `Board` component with the four lanes, another
    component rendering a `Ticket` component is being displayed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过向`Ticket`组件发送props来控制`TicketWrapper`的`margin-right`属性。如果我们在浏览器中查看我们的应用程序，我们会看到，在具有四个车道的`Board`组件正下方，另一个组件正在呈现一个`Ticket`组件。
- en: '![](assets/996d76ec-4437-4aaa-bfef-3fe46f0753f4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/996d76ec-4437-4aaa-bfef-3fe46f0753f4.png)'
- en: 'Another thing we can customize is how the components that are returned by the
    HOC are named by the React developer tools. Open up the application in the browser
    and have a look at the component tree. Here, we can see the components that we''ve
    created without the HOC have a readable naming convention such as `App` or `Header`.
    The components that have been created by the HOC are named `<_class />`. To make
    this component tree more clear, we can easily have our HOC add this naming convention
    to the components it creates. Usually, we would use the name of the component
    that is created by the HOC. In our case, however, the HOC is called `withDataFetching`
    and when we insert a component called `Board`, the name that''s displayed in the
    React developer tools would be `withDataFetching(Board)`. To set this up, we need
    to make a few changes to the `withDataFetching.js` file. Let''s get started:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自定义的另一件事是，HOC返回的组件在React开发者工具中的命名方式。在浏览器中打开应用程序并查看组件树。在这里，我们可以看到我们创建的没有HOC的组件具有可读的命名约定，如`App`或`Header`。由HOC创建的组件被命名为`<_class
    />`。为了使这个组件树更清晰，我们可以让我们的HOC轻松地将这种命名约定添加到它创建的组件中。通常，我们会使用HOC创建的组件的名称。然而，在我们的情况下，HOC被称为`withDataFetching`，当我们插入一个名为`Board`的组件时，在React开发者工具中显示的名称将是`withDataFetching(Board)`。为了设置这一点，我们需要对`withDataFetching.js`文件进行一些更改。让我们开始吧：
- en: 'Remove `return` before declaring the class component and give the class component
    a name. For this, use the name of the HOC and change the first character to a
    capital letter. This results in `WithDataFetching`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明类组件之前删除`return`，并给类组件命名。为此，使用HOC的名称，并将第一个字符改为大写字母。这将得到`WithDataFetching`：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the last few lines of this file, we can take the name of the `WrappedComponent`
    that has been inserted into the HOC and use it to name the HOC by setting the
    `displayName` of the returned component. Don''t forget to return the `WithDataFetching`
    class component at the end of this file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的最后几行，我们可以获取已插入HOC的`WrappedComponent`的名称，并将其用于通过设置返回组件的`displayName`来命名HOC。不要忘记在文件末尾返回`WithDataFetching`类组件：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looking at the React developer tools again, we can see that these changes have
    resulted in a more readable naming convention for the components that have been
    created by the HOC.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看React开发者工具，我们可以看到这些更改导致了HOC创建的组件具有更可读的命名约定。
- en: All the tickets that are displayed in the lanes are only in one part of our
    application since we want to be able to drag and drop these tickets into different
    lanes. We'll learn how to do this in the next section, where we'll add dynamic
    functionalities to the board.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，显示在车道中的所有票据只在一个部分，因为我们希望能够将这些票据拖放到不同的车道中。我们将在下一节中学习如何做到这一点，我们将为板块添加动态功能。
- en: Making the board dynamic
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让板块变得动态起来
- en: One of the things that usually gives project management boards great user interaction
    is the ability to drag and drop tickets from one lane into another. This is something
    that can easily be accomplished using the HTML5 Drag and Drop API, which is available
    in every modern browser, including IE11.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常给项目管理板提供良好用户交互的一件事是能够将票务从一个车道拖放到另一个车道。这是可以很容易地通过HTML5拖放API来实现的，该API在包括IE11在内的每个现代浏览器中都可用。
- en: 'The HTML5 Drag and Drop API makes it possible for us to drag and drop elements
    across our project management board. To make this possible, it uses drag events. `onDragStart`, `onDragOver`,
    and `onDrop` will be used for this application. These events should be placed
    on both the `Lane` and the `Ticket` components. Let''s get started:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5拖放API使我们能够在项目管理板中拖放元素。为了实现这一点，它使用拖动事件。`onDragStart`、`onDragOver`和`onDrop`将用于此应用程序。这些事件应放置在`Lane`和`Ticket`组件上。让我们开始吧：
- en: 'First, we need to make the `Board` component a class component instead of a
    functional component. We''re doing this because the ticket data needs to be added
    to the state and the `Board` component is the most logical place to do this since
    we may want the `Lane` component to be reused somewhere else. We can do this by
    changing the definition of the `Board` constant, like so:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将`Board`组件从函数组件更改为类组件。我们这样做是因为票务数据需要添加到状态中，而`Board`组件是最合适的地方，因为我们可能希望`Lane`组件在其他地方被重用。我们可以通过更改`Board`常量的定义来实现这一点，如下所示：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can add the initial value for the tickets to the state. We''re doing
    this since we want to change the key of the lane it should be placed on. By adding
    this data to the state, we can mutate it dynamically with the `setState` function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将票务的初始值添加到状态中。我们这样做是因为我们希望更改应该放置在的车道的键。通过将这些数据添加到状态中，我们可以使用`setState`函数动态地改变它。
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since the data needs to be loaded from the source and isn''t available when
    the application first mounts, we need to check whether the props for these components
    have changed. If they have, we need to add the ticket data to the state. To do
    this, use the `componentDidUpdate` life cycle method, which can take the previous
    props as a parameter:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据需要从源加载，并且在应用程序首次挂载时不可用，我们需要检查这些组件的props是否已更改。如果是，我们需要将票务数据添加到状态中。为此，使用`componentDidUpdate`生命周期方法，该方法可以将先前的props作为参数：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, show the tickets from the state:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，显示来自状态的票务：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we take at the project in the browser now, no visible changes should be present.
    The only difference is the data for the tickets is now loaded from the state,
    instead of being loaded from the props.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在浏览器中查看项目，应该没有可见的变化。唯一的区别是票务的数据现在是从状态中加载，而不是从props中加载。
- en: 'In this same file, let''s add the functions that respond to the drop events,
    which need to be sent to the `Lane` and `Ticket` components:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个文件中，让我们添加响应拖放事件的函数，这些函数需要发送到`Lane`和`Ticket`组件：
- en: 'Start by adding the event handler function for the `onDragStart` event, which fires
    when the dragging operation is started, to the `Board` component. This function
    needs to be passed to the `Lane` component, where it can be passed on to the `Ticket` component.
    This function sets an ID for the ticket that is being dragged to the `dataTransfer`
    object of the element, which is used by the browser to identify the drag element:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加`onDragStart`事件的事件处理程序函数，该函数在开始拖动操作时触发，添加到`Board`组件。这个函数需要传递给`Lane`组件，然后可以传递给`Ticket`组件。这个函数为被拖动的票务设置一个ID，该ID被用于浏览器识别拖动元素的`dataTransfer`对象：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `Lane` component, we need to pass this event handler function to the
    `Ticket` component:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Lane`组件中，我们需要将此事件处理程序函数传递给`Ticket`组件：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can invoke this function in the `Ticket` component, where we also need
    to add the `draggable` attribute to`TicketWrapper`. Here, we send the element
    and the ticket ID as a parameter to the event handler:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`Ticket`组件中调用这个函数，我们还需要在`TicketWrapper`中添加`draggable`属性。在这里，我们将元素和票据ID作为参数发送到事件处理程序：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After making these changes, we should be able to see each ticket can be dragged
    around. But don''t drop them anywhere yet—the other drop events and event handlers
    that update the state should be added as well. Dragging a ticket from one lane
    to another can be done by clicking on a ticket without releasing the mouse and
    dragging it to another lane, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，我们应该能够看到每个票据都可以被拖动。但是现在不要把它们放在任何地方——其他放置事件和更新状态的事件处理程序也应该被添加。可以通过点击票据而不释放鼠标并将其拖动到另一个车道来将票据从一个车道拖动到另一个车道，如下面的截图所示：
- en: '![](assets/8294248f-db92-4260-9317-934a712d18a1.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8294248f-db92-4260-9317-934a712d18a1.png)'
- en: 'With the `onDragStart` event implemented, the `onDragOver` and `onDrop` events
    can be implemented as well. Let''s get started:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了`onDragStart`事件后，`onDragOver`和`onDrop`事件也可以实现。让我们开始吧：
- en: 'By default, it''s impossible to drop elements into another element; for example,
    a `Ticket` component into the `Lane` component. This can be prevented by calling
    the `preventDefault` method for the `onDragOver` event:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，不可能将元素放入另一个元素中；例如，将`Ticket`组件放入`Lane`组件中。这可以通过在`onDragOver`事件中调用`preventDefault`方法来防止：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '2\. This event handler needs to be placed on the `Lane` component:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 这个事件处理程序需要放在`Lane`组件上：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `onDrop` event is where things get interesting since, this event makes it
    possible for us to mutate the state after we've finished the drag operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDrop`事件是让事情变得有趣的地方，因为这个事件使我们能够在完成拖动操作后改变状态。'
- en: 'The event handler function for this event should be placed on the `Ticket` component,
    but defined in the `Board` component, since the `setState` function can only be
    invoked in the same file as the initial value for the state:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件处理程序的函数应该放在`Ticket`组件上，但在`Board`组件中定义，因为`setState`函数只能在与状态的初始值相同的文件中调用。
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This `onDrop` event handler function takes an element and ID of the lane as
    a parameter, because it needs the ID of the dragged element and the new lane it
    should be placed in. With this information, the function uses a `filter` function
    to find the ticket that needs to be moved and changes the ID of the lane. This
    new information will replace the current object for the tickets in the state with
    the `setState` function. Since the `onDrop` event gets fired from the `Lane` component,
    it is passed as a prop to this component. Also, the ID of the lane is added as
    a prop because this needs to be passed to the `onDrop` event handler function
    from the `Lane` component:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`onDrop`事件处理函数接受一个元素和车道的ID作为参数，因为它需要被拖动元素的ID和它应该放置在的新车道的ID。有了这些信息，函数使用`filter`函数来找到需要移动的票，并改变车道的ID。这些新信息将用`setState`函数替换状态中票的当前对象。由于`onDrop`事件是从`Lane`组件触发的，它作为一个prop传递给这个组件。此外，车道的ID也作为一个prop添加，因为这需要从`Lane`组件传递给`onDrop`事件处理函数：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this, we're able to drag and drop tickets onto other lanes in our board.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就能在我们的看板上将票据拖放到其他车道上了。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you created a project management board that lets you move and
    drag and drop tickets from one lane to another using React Suspense and the HTML5
    Drag and Drop API. The data flow of this application is handled using local state
    and life cycles and determines which tickets are displayed in the different lanes.
    This chapter also introduced the advanced React pattern of **Higher-Order Components**
    (**HOCs**). With HOCs, you can reuse state logic from class components across
    your applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您创建了一个项目管理面板，可以使用React Suspense和HTML5拖放API将票据从一个车道移动到另一个车道。该应用程序的数据流使用本地状态和生命周期来处理，并确定在不同车道中显示哪些票据。本章还介绍了**高阶组件**（HOCs）的高级React模式。使用HOCs，您可以在应用程序中跨类组件重用状态逻辑。
- en: This advanced pattern will be also be used in the next chapter, which will handle
    routing and **Server-Side Rendering** (**SSR**) in React applications. Have you
    ever tried using Stack Overflow to find a solution to a programming issue you
    once had? I have!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种高级模式还将在下一章中使用，该章将处理React应用程序中的路由和**服务器端渲染**（SSR）。您有没有尝试过使用Stack Overflow来找到您曾经遇到的编程问题的解决方案？我有！
- en: In the next chapter, we will be building a community feed that uses Stack Overflow
    as a data source and React to render the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个使用Stack Overflow作为数据源并使用React来渲染应用程序的社区动态。
- en: Further reading
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Drag and Drop API: [https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖放API：[https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API)。
- en: HOC: [https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HOC：[https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750)。
- en: DataTransfer: [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataTransfer：[https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)。
- en: React DnD: [https://github.com/react-dnd/react-dnd](https://github.com/react-dnd/react-dnd).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React DnD：[https://github.com/react-dnd/react-dnd](https://github.com/react-dnd/react-dnd)。
