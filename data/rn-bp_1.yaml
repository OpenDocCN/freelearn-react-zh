- en: Shopping List
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物清单
- en: 'Most of the modern languages and frameworks used to present a to-do list as
    their sample app. It is a great way to understand the basics of a framework as
    user interaction, basic navigation, or how to structure code. We''ll start in
    a more pragmatic way: building a shopping list app.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代语言和框架用于展示待办事项清单作为它们的示例应用程序。这是了解框架基础知识的绝佳方式，如用户交互、基本导航或代码结构。我们将以更加务实的方式开始：构建一个购物清单应用程序。
- en: You will be able to develop this app in React Native code, build it for both
    iOS and Android, and finally install it on your phone. This way, you could not
    only show your friends what you built, but also understand missing features that
    you can build by yourself, thinking about user-interface improvements, and above
    all, motivating yourself to keep learning React Native as you feel its true potential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够使用React Native代码开发此应用程序，为iOS和Android构建它，并最终安装在您的手机上。这样，您不仅可以向朋友展示您所构建的内容，还可以了解您可以自己构建的缺失功能，思考用户界面改进，最重要的是，激励自己继续学习React
    Native，感受其真正的潜力。
- en: By the end of this chapter, you will have built a fully-functional shopping
    list that you can use on your phone and will have all the tools you need to create
    and maintain simple stateful apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将已经构建了一个完全功能的购物清单，可以在手机上使用，并且拥有创建和维护简单有状态应用程序所需的所有工具。
- en: Overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'One of the most powerful features of React Native is its cross-platform capabilities;
    we will build our shopping list app for both iOS and Android, reusing 99% of our
    code. Let''s take a look at how the app will look on both platforms:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的最强大功能之一是其跨平台能力；我们将为iOS和Android构建我们的购物清单应用程序，重用我们代码的99%。让我们来看看这个应用在两个平台上的样子：
- en: 'iOS:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: iOS：
- en: '![](Images/80e9e967-6d95-4ece-9618-9315dca63086.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/80e9e967-6d95-4ece-9618-9315dca63086.png)'
- en: 'After adding more products, this is how it will look:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多产品后，它将如下所示：
- en: '![](Images/7209e648-c819-45e5-bf3c-90ebf6db1325.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7209e648-c819-45e5-bf3c-90ebf6db1325.png)'
- en: 'Android:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android：
- en: '![](Images/a7448887-adee-415c-a4fa-e6bff040a8eb.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a7448887-adee-415c-a4fa-e6bff040a8eb.png)'
- en: 'After adding more products, this is how it will look:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多产品后，它将如下所示：
- en: '![](Images/b40260c4-d53a-4e30-b84b-6fa59943bc99.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b40260c4-d53a-4e30-b84b-6fa59943bc99.png)'
- en: The app will have a very similar user interface on both platforms, but we won't
    need to care much about the differences (for example, the back button on the Add
    a product screen), as they will be handled automatically by React Native.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序在两个平台上的用户界面非常相似，但我们不需要过多关注差异（例如，“添加产品”屏幕上的返回按钮），因为它们将由React Native自动处理。
- en: It is important to understand that each platform has its own user interface
    patterns, and it's a good practice to follow them. For example, navigation is
    usually handled through tabs in iOS while Android prefers a drawer menu, so we
    should build both navigation patterns if we want happy users on both platforms.
    In any case, this is only a recommendation, and any user interface pattern could
    be built on every platform. In later chapters, we will see how to handle two different
    patterns in the most effective way within the same codebase.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解每个平台都有自己的用户界面模式，并且遵循它们是一个好的做法。例如，iOS通常通过选项卡来处理导航，而Android更喜欢抽屉菜单，因此如果我们希望在两个平台上都有满意的用户，我们应该构建这两种导航模式。无论如何，这只是一个建议，任何用户界面模式都可以在每个平台上构建。在后面的章节中，我们将看到如何在同一代码库中以最有效的方式处理两种不同的模式。
- en: 'The app comprises of two screens: your shopping list and a list of the products
    which could be added to your shopping list. The user can navigate from the Shopping
    List screen to the Add a product screen through the round blue button and back
    through the < Back button. We will also build a clear button in the shopping list
    screen (the round red button) and the ability to add and remove products on the
    Add a product screen.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用包括两个屏幕：您的购物清单和可以添加到您的购物清单的产品列表。用户可以通过圆形蓝色按钮从购物清单屏幕导航到“添加产品”屏幕，然后通过<返回按钮返回。我们还将在购物清单屏幕上构建一个清除按钮（圆形红色按钮），以及在“添加产品”屏幕上添加和删除产品的功能。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Folder structure for a basic React Native project
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本React Native项目的文件夹结构
- en: React Native's basic CLI commands
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native的基本CLI命令
- en: Basic navigation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本导航
- en: JS debugging
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS调试
- en: Live reloading
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时重新加载
- en: Styling with NativeBase
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NativeBase进行样式设置
- en: Lists
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Basic state management
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本状态管理
- en: Handling events
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事件
- en: '`AsyncStorage`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncStorage`'
- en: Prompt popups
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示弹出
- en: Distributing the app
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发应用
- en: Setting up our project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的项目
- en: 'React Native has a very powerful CLI that we will need to install to get started
    with our project. To install, just run the following command in your command line
    (you might need to run this with `sudo`), if you don''t have enough permissions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: React Native具有非常强大的CLI，我们需要安装它才能开始我们的项目。要安装，只需在命令行中运行以下命令（如果权限不够，可能需要使用`sudo`）：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the installation is finished, we can start using the React Native CLI
    by typing `react-native`. To start our project, we will run the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过输入`react-native`来开始使用React Native CLI。要启动我们的项目，我们将运行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command will create a basic project named `GroceriesList` with all the
    dependencies and libraries you need to build the app on iOS and Android. Once
    the CLI has finished installing all the packages, you should have a folder structure
    similar to this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为`GroceriesList`的基本项目，其中包含构建iOS和Android应用所需的所有依赖项和库。一旦CLI完成安装所有软件包，您应该有一个类似于此的文件夹结构：
- en: '![](Images/127ee358-1f61-464c-8cdd-dc51619f81ab.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/127ee358-1f61-464c-8cdd-dc51619f81ab.png)'
- en: 'The entry file for our project is `index.js`. If you want to see your initial
    app running on a simulator, you can use React Native''s CLI again:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的入口文件是`index.js`。如果您想在模拟器上看到您的初始应用程序运行，可以再次使用React Native的CLI：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Or
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Provided you have XCode or Android Studio and Android Simulator installed,
    you should be able to see a sample screen on your simulator after compilation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经安装了XCode或Android Studio和Android模拟器，编译后您应该能够在模拟器上看到一个示例屏幕：
- en: '![](Images/c08290d0-ef33-4138-b3b6-e44a8b34946c.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c08290d0-ef33-4138-b3b6-e44a8b34946c.png)'
- en: 'We have everything we need to set up to start implementing our app, but in
    order to easily debug and see our changes in the simulator, we need to enable
    two more features: remote JS debugging and live reloading.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好设置开始实现我们的应用程序，但为了轻松调试并在模拟器中看到我们的更改，我们需要启用另外两个功能：远程JS调试和实时重新加载。
- en: For debugging, we will use *React Native Debugger*, a standalone app, based
    on the official debugger for React Native, which includes React Inspector and
    Redux DevTools. It can be downloaded following the instructions on its GitHub
    repository ([https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger)).
    For this debugger to work properly, we will need to enable Remote JS Debugging
    from within our app by opening a React Native development menu within the simulator
    by pressing *command* + *ctrl* + *Z* on iOS or *command* + *M* on Android.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试，我们将使用*React Native Debugger*，这是一个独立的应用程序，基于React Native的官方调试器，其中包括React
    Inspector和Redux DevTools。它可以通过按照其GitHub存储库上的说明进行下载（[https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger)）。为了使这个调试器正常工作，我们需要在应用程序内部启用远程JS调试，方法是在模拟器中通过按下iOS上的*command*
    + *ctrl* + *Z*或Android上的*command* + *M*来打开React Native开发菜单。
- en: 'If everything goes well, we should see the following menu appear:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到以下菜单出现：
- en: '![](Images/269055ed-9910-4a00-bba6-c43fe50bcd98.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/269055ed-9910-4a00-bba6-c43fe50bcd98.png)'
- en: '![](Images/67e2584e-18b2-48b8-8b05-c0c966e79b18.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/67e2584e-18b2-48b8-8b05-c0c966e79b18.png)'
- en: 'Now, we will press two buttons: Debug Remote JS and Enable Live Reload. Once
    we are done with this, we have all our development environment up and ready to
    start writing React code.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按下两个按钮：Debug Remote JS和Enable Live Reload。完成后，我们的开发环境已经准备好开始编写React代码。
- en: Setting up the folder structure
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Our app only comprises of two screens: Shopping List and Add Products. Since
    the state for such a simple app should be easy to manage, we won''t add any library
    for state management (for example, Redux), as we will send the shared state through
    the navigation component. This should make our folder structure rather simple:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序只包括两个屏幕：购物清单和添加产品。由于这样一个简单应用的状态应该很容易管理，我们不会添加任何状态管理库（例如Redux），因为我们将通过导航组件发送共享状态。这应该使我们的文件夹结构相当简单：
- en: '![](Images/3e58d766-c67e-4b38-bffe-fb0b5d6b6875.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e58d766-c67e-4b38-bffe-fb0b5d6b6875.png)'
- en: 'We have to create an `src` folder where we will store all our React code. The
    self-created file `index.js` will have the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个`src`文件夹，我们将在其中存储所有我们的React代码。自创建的文件`index.js`将包含以下代码：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In short, these files will import the common root code for our app, store it
    in a variable named `App` and later pass this variable to the `AppRegistry` through
    the `registerComponent` method. `AppRegistry` is the component to which we should
    register our root components. Once we do this, React Native will generate a JS
    bundle for our app and then run the app when it's ready by invoking `AppRegistry.runApplication`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这些文件将导入我们应用程序的通用根代码，将其存储在名为`App`的变量中，然后通过`registerComponent`方法将这个变量传递给`AppRegistry`。`AppRegistry`是我们应该注册我们的根组件的组件。一旦我们这样做，React
    Native将为我们的应用程序生成一个JS捆绑包，然后通过调用`AppRegistry.runApplication`在准备就绪时运行应用程序。
- en: Most of the code we will be writing, will be placed inside the `src` folder.
    For this app, we will create our root component (`main.js`) in this folder, and
    a `screens` subfolder, in which we will store our two screens (`ShoppingList` and
    `AddProduct`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将写的大部分代码都将放在`src`文件夹中。对于这个应用程序，我们将在这个文件夹中创建我们的根组件（`main.js`），以及一个`screens`子文件夹，我们将在其中存储我们的两个屏幕（`ShoppingList`和`AddProduct`）。
- en: 'Now let''s install all the initial dependencies for our app before continue
    coding. In our project''s root folder, we will need to run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在继续编码之前安装应用程序的所有初始依赖项。在我们项目的根文件夹中，我们需要运行以下命令：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running that command will install all the basic dependencies for every React
    Native project. Let''s now install the three packages we will be using for this
    specific app:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令将为每个React Native项目安装所有基本依赖项。现在让我们安装这个特定应用程序将使用的三个软件包：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Further ahead in this chapter, we will explain what each package will be used
    for.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将解释每个包将被用于什么。
- en: Adding a Navigation component
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加导航组件
- en: Most mobile apps comprise of more than one screen, so we will need to be able
    to "travel" between those screens. In order to achieve this, we will need a `Navigation`
    component. React Native comes with a `Navigator` and a `NavigatorIOS` component
    out of the box, although the React maintainers recommend using an external navigation
    solution built by the community named `react-navigation` ([https://github.com/react-community/react-navigation](https://github.com/react-community/react-navigation)),
    which is very performant, well maintained, and rich in features, so we will use
    it for our app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数移动应用程序由多个屏幕组成，因此我们需要能够在这些屏幕之间“切换”。为了实现这一点，我们需要一个`Navigation`组件。React Native自带了`Navigator`和`NavigatorIOS`组件，尽管React的维护者建议使用社区构建的外部导航解决方案`react-navigation`（[https://github.com/react-community/react-navigation](https://github.com/react-community/react-navigation)），这个解决方案非常高效，维护良好，并且功能丰富，所以我们将在我们的应用程序中使用它。
- en: 'Because we already installed our module for navigation (`react-navigation`),
    we can set up and initialize our `Navigation` component inside our `main.js` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经安装了导航模块（`react-navigation`），我们可以在`main.js`文件中设置和初始化我们的`Navigation`组件：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our root component imports both of the screens in our app (`ShoppingList` and
    `AddProduct`) and passes them to the `StackNavigator` function, which generates
    the `Navigator` component. Let's take a deeper look into how `StackNavigator`
    works.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的根组件导入了应用程序中的两个屏幕（`ShoppingList`和`AddProduct`）并将它们传递给`StackNavigator`函数，该函数生成了`Navigator`组件。让我们深入了解一下`StackNavigator`的工作原理。
- en: '`StackNavigator` provides a way for any app to transition between screens,
    where each new screen is placed on top of a stack. When we request the navigation
    to a new screen, `StackNavigator` will slide the new screen from the right and
    place a `< Back` button in the upper-right corner to go back to the previous screen
    in iOS or, will fade in from the bottom while a new screen is placing a `<-` arrow
    to go back in Android. With the same codebase, we will trigger familiar navigation
    patterns in iOS and Android. `StackNavigator` is also really simple to use, as
    we only need to pass the screens in our apps as a hash map, where the keys are
    the names we want for our screens and the values are the imported screens as React
    components. The result is a `<Navigator/>` component which we can render to initialize
    our app.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackNavigator`提供了一种让任何应用程序在屏幕之间进行过渡的方式，其中每个新屏幕都放置在堆栈的顶部。当我们请求导航到一个新屏幕时，`StackNavigator`将从右侧滑动新屏幕，并在iOS中的右上角放置一个`<
    Back`按钮，以返回到上一个屏幕，或者在Android中，新屏幕将从底部淡入，同时放置一个`<-`箭头以返回。使用相同的代码库，我们将在iOS和Android中触发熟悉的导航模式。`StackNavigator`也非常简单易用，因为我们只需要将我们应用程序中的屏幕作为哈希映射传递，其中键是我们想要为我们的屏幕设置的名称，值是导入的屏幕作为React组件。结果是一个`<Navigator/>`组件，我们可以渲染来初始化我们的应用程序。'
- en: Styling our app with NativeBase
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NativeBase为我们的应用程序设置样式
- en: React Native includes a powerful way to style our components and screens using
    Flexbox and a CSS-like API but, for this app, we want to focus on the functionality
    aspect, so we will use a library including basic styled components as buttons,
    lists, icons, menus, forms, and many more. It can be seen as a Twitter Bootstrap
    for React Native.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: React Native包括一种强大的方式来使用Flexbox和类似CSS的API来为我们的组件和屏幕设置样式，但是对于这个应用程序，我们想要专注于功能方面，所以我们将使用一个包括基本样式组件的库，如按钮、列表、图标、菜单、表单等。它可以被视为React
    Native的Twitter Bootstrap。
- en: There are several popular UI libraries, NativeBase and React Native elements
    being the two most popular and best supported. Out of these two, we will choose
    NativeBase, since it's documentation is slightly clearer for beginners.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个流行的UI库，NativeBase和React Native元素是最受欢迎和最受支持的两个。在这两者中，我们将选择NativeBase，因为它对初学者来说稍微更清晰一些。
- en: 'You can find the detailed documentation on how NativeBase works on their website
    ([https://docs.nativebase.io/](https://docs.nativebase.io/)), but we will go through
    the basics of installing and using some of their components in this chapter. We
    previously installed `native-base` as a dependency of our project through `npm
    install` but NativeBase includes some peer dependencies, which need to be linked
    and included in our iOS and Android native folders. Luckily, React Native already
    has a tool for finding out those dependencies and linking them; we just need to
    run:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在他们的网站上找到有关NativeBase如何工作的详细文档（[https://docs.nativebase.io/](https://docs.nativebase.io/)），但是在本章中，我们将介绍安装和使用其中一些组件的基础知识。我们之前通过`npm
    install`将`native-base`安装为项目的依赖项，但NativeBase包括一些对等依赖项，需要链接并包含在我们的iOS和Android本机文件夹中。幸运的是，React
    Native已经有一个工具来查找这些依赖项并将它们链接起来；我们只需要运行：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, we have all the UI components from NativeBase fully available
    in our app. So, we can start building our first screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的应用程序中已经完全可用来自NativeBase的所有UI组件。因此，我们可以开始构建我们的第一个屏幕。
- en: Building the ShoppingList screen
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建ShoppingList屏幕
- en: 'Our first screen will contain a list of the items we need to buy, so it will
    contain one list item per item we need to buy, including a button to mark that
    item as already bought. Moreover, we need a button to navigate to the `AddProduct`
    screen, which will allow us to add products to our list. Finally, we will add
    a button to clear the list of products, in case we want to start a new shopping
    list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个屏幕将包含我们需要购买的物品清单，因此它将包含每个我们需要购买的物品的一个列表项，包括一个按钮来标记该物品已购买。此外，我们需要一个按钮来导航到`AddProduct`屏幕，这将允许我们向我们的列表中添加产品。最后，我们将添加一个按钮来清除产品列表，以防我们想要开始一个新的购物清单：
- en: '![](Images/81cbfccf-1b8f-48e0-9035-b47acaf9030e.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/81cbfccf-1b8f-48e0-9035-b47acaf9030e.jpg)'
- en: Let's start by creating `ShoppingList.js` inside the `screens` folder and importing
    all the UI components we will need from `native-base` and `react-native` (we will
    use an alert popup to warn the user before clearing all items). The main UI components
    we will be using are `Fab` (the blue and red round buttons), `List`, `ListItem`,
    `CheckBox`, `Text`, and `Icon`. To support our layout, we will be using `Body`,
    `Container`, `Content`, and `Right`, which are layout containers for the rest
    of our components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`screens`文件夹内创建`ShoppingList.js`开始，并从`native-base`和`react-native`导入我们将需要的所有UI组件（我们将使用警告弹出窗口在清除所有项目之前警告用户）。我们将使用的主要UI组件是`Fab`（蓝色和红色的圆形按钮），`List`，`ListItem`，`CheckBox`，`Text`和`Icon`。为了支持我们的布局，我们将使用`Body`，`Container`，`Content`和`Right`，这些是我们其余组件的布局容器。
- en: 'Having all these components, we can create a simple version of our `ShoppingList`
    component:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些组件，我们可以创建一个简单版本的`ShoppingList`组件：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is just a dumb component statically displaying the components we will
    be using on this screen. Some things to note:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个愚蠢的组件，静态显示我们将在此屏幕上使用的组件。需要注意的一些事情：
- en: '`navigationOptions` is a static attribute which will be used by `<Navigator>`
    to configure how the navigation would behave. In our case, we want to display
    My Groceries List as the title for this screen.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigationOptions`是一个静态属性，将被`<Navigator>`用来配置导航的行为。在我们的情况下，我们希望将“我的杂货清单”显示为此屏幕的标题。'
- en: For `native-base` to do its magic, we need to use `<Container>` and `<Content>`
    to properly form the layout.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使`native-base`发挥其作用，我们需要使用`<Container>`和`<Content>`来正确地形成布局。
- en: '`Fab` buttons are placed outside `<Content>`, so they can float over the left
    and right-bottom corners.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fab`按钮放置在`<Content>`之外，因此它们可以浮动在左下角和右下角。'
- en: Each `ListItem` contains a `<Body>` (main text) and a `<Right>` (icons aligned
    to the right).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`ListItem`包含一个`<Body>`（主要文本）和一个`<Right>`（右对齐的图标）。
- en: Since we enabled Live Reload in our first steps, we should see the app reloading
    after saving our newly created file. All the UI elements are now in place, but
    they are not functional since we didn't add any state. This should be our next
    step.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在最初的步骤中启用了实时重新加载，所以在保存新创建的文件后，我们应该看到应用程序重新加载。现在所有的UI元素都已经就位，但它们还没有功能，因为我们还没有添加任何状态。这应该是我们下一步要做的事情。
- en: Adding state to our screen
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的屏幕上添加状态
- en: 'Let''s add some initial state to our `ShoppingList` screen to populate the
    list with actual dynamic data. We will start by creating a constructor and setting
    the initial state there:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ShoppingList`屏幕上添加一些初始状态，以用实际动态数据填充列表。我们将首先创建一个构造函数，并在那里设置初始状态：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can render that state inside of `<List>` (inside the `render` method):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`<List>`（在`render`方法内部）中呈现该状态：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now rely on a list of products inside our component's state, each product
    storing an `id`, a `name`, and `gotten` properties. When modifying this state,
    we will automatically be re-rendering the list.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在依赖于组件状态中的产品列表，每个产品存储一个`id`、一个`name`和`gotten`属性。在修改此状态时，我们将自动重新呈现列表。
- en: Now, it's time to add some event handlers, so we can modify the state at the
    users' command or navigate to the `AddProduct` screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加一些事件处理程序，这样我们就可以根据用户的命令修改状态或导航到`AddProduct`屏幕。
- en: Adding event handlers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加事件处理程序
- en: 'All the interaction with the user will happen through event handlers in React
    Native. Depending on the controller, we will have different events which can be
    triggered. The most common event is `onPress`, as it will be triggered every time
    we push a button, a checkbox, or a view in general. Let''s add some `onPress`
    handlers for all the components which can be pushed in our screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与用户的交互都将通过React Native中的事件处理程序进行。根据控制器的不同，我们将有不同的可以触发的事件。最常见的事件是`onPress`，因为每次我们按下按钮、复选框或一般视图时都会触发它。让我们为屏幕中可以被按下的所有组件添加一些`onPress`处理程序：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice we added three `onPress` event handlers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们添加了三个`onPress`事件处理程序：
- en: On `<ListItem>`, to react when the user taps on one product in the list
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<ListItem>`上，当用户点击列表中的一个产品时做出反应
- en: On `<CheckBox>`, to react when the user taps on the checkbox icon next to every
    product in the list
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<CheckBox>`上，当用户点击列表中每个产品旁边的复选框图标时做出反应
- en: On both the `<Fab>` buttons
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个`<Fab>`按钮上
- en: If you know React, you probably understand why we use `.bind` in all our handler
    functions, but, in case you have doubts, `.bind` will make sure we can use `this`
    inside the definition of our handlers as a reference to the component itself instead
    of the global scope. This will allow us to call methods inside our components
    as `this.setState` or read our component's attributes, such as `this.props` and
    `this.state`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解React，你可能明白为什么我们在所有的处理程序函数中使用`.bind`，但是，如果你有疑问，`.bind`将确保我们可以在处理程序的定义中使用`this`作为对组件本身的引用，而不是全局范围。这将允许我们在组件内调用方法，如`this.setState`或读取我们组件的属性，比如`this.props`和`this.state`。
- en: For the cases when the user taps on a specific product, we also bind the product
    itself, so we can use them inside our event handlers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户点击特定产品的情况，我们还绑定产品本身，这样我们可以在事件处理程序中使用它们。
- en: 'Now, let''s define the functions which will serve as event handlers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义将作为事件处理程序的函数：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, let's create a handler for when the user taps on a product from our shopping
    list or in its checkbox. We want to mark the product as `gotten` (or unmark it
    if it was already `gotten`), so we will update the state with the product marked
    properly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为用户点击购物清单中的产品或其复选框时创建一个处理程序。我们希望将产品标记为“已购得”（或者如果已经“已购得”，则取消标记），因此我们将使用正确地标记产品来更新状态。
- en: 'Next, we will add a handler for the blue `<Fab>` button to navigate to the
    `AddProduct` screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为蓝色的`<Fab>`按钮添加一个处理程序，以导航到`AddProduct`屏幕：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This handler uses `this.props.navigation`, which is a property automatically
    passed by the `Navigator` component from `react-navigation`. This property contains
    a method named `navigate`, receiving the name of the screen to which the app should
    navigate plus an object which can be used as a global state. In the case of this
    app, we will store three keys:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序使用了`this.props.navigation`，这是一个由`react-navigation`中的`Navigator`组件自动传递的属性。这个属性包含一个名为`navigate`的方法，接收应用程序应该导航到的屏幕的名称，以及一个可以作为全局状态使用的对象。在这个应用程序的情况下，我们将存储三个键：
- en: '`addProduct`: One function to allow the `AddProduct` screen to modify the `ShoppingList`
    component''s state to reflect the action of adding a new product to the shopping
    list.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addProduct`：一个函数，允许`AddProduct`屏幕修改`ShoppingList`组件的状态，以反映向购物清单添加新产品的操作。'
- en: '`deleteProduct`: One function to allow the `AddProduct` screen to modify the `ShoppingList`
    component''s state to reflect the action of removing a product from the shopping
    list.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteProduct`：一个函数，允许`AddProduct`屏幕修改`ShoppingList`组件的状态，以反映从购物清单中删除产品的操作。'
- en: '`productsInList`: A variable holding the list of products is already on the
    shopping list, so the `AddProducts` screen can know which products were already
    added to the shopping list and display those as "already added", preventing the
    addition of duplicate items.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productsInList`：一个变量，保存着已经在购物清单上的产品列表，这样`AddProducts`屏幕就可以知道哪些产品已经添加到购物清单中，并将它们显示为“已添加”，防止重复添加物品。'
- en: Handling state within the navigation should be seen as a workaround for simple
    apps containing a limited number of screens. In larger apps (as we will see in
    later chapters), a state management library, such as Redux or MobX, should be
    used to keep the separation between pure data and user interface handling.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航中处理状态应该被视为简单应用程序的一种解决方法，其中包含有限数量的屏幕。在更大的应用程序中（正如我们将在后面的章节中看到的），应该使用状态管理库，比如Redux或MobX，来保持纯数据和用户界面处理之间的分离。
- en: 'We will add the last handler for the blue `<Fab>` button, which enables the
    user to clear all the items in the shopping list in case you want to start a new
    list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为蓝色的`<Fab>`按钮添加最后一个处理程序，这样用户就可以清空购物清单中的所有项目，以便开始一个新的清单：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are using `Alert` to prompt the user for confirmation before clearing all
    the elements in our shopping list. Once the user confirms this action, we will
    empty the `products` attribute in our component's state.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`Alert`来在清空购物清单中的所有元素之前提示用户确认。一旦用户确认了这个操作，我们将清空组件状态中的`products`属性。
- en: Putting it all together
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'Let''s see how the whole component''s structure would look like when putting
    all the methods together:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当把所有方法放在一起时，整个组件的结构会是什么样子：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The structure of a React Native component is very similar to a normal React
    component. We need to import React itself and then some components to build up
    our screen. We also have several event handlers (which we have prefixed with an
    underscore as a mere convention) and finally a `render` method to display our
    components using standard JSX.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: React Native组件的结构非常类似于普通的React组件。我们需要导入React本身，然后一些组件来构建我们的屏幕。我们还有几个事件处理程序（我们已经用下划线作为纯粹的约定），最后是一个`render`方法来使用标准的JSX显示我们的组件。
- en: The only difference with a React web app is the fact that we are using React
    Native UI components instead of DOM components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与React web应用程序唯一的区别是，我们使用React Native UI组件而不是DOM组件。
- en: Building the AddProduct screen
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建AddProduct屏幕
- en: As the user will have the need of adding new products to the shopping list,
    we need to build a screen in which we can prompt the user for the name of the
    product to be added and save it in the phone's storage for later use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户需要向购物清单中添加新产品，我们需要构建一个屏幕，可以提示用户输入要添加的产品的名称，并将其保存在手机的存储中以供以后使用。
- en: Using AsyncStorage
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AsyncStorage
- en: When building a React Native app, it's important to understand how mobile devices
    handle the memory used by each app. Our app will be sharing the memory with the
    rest of the apps in the device so, eventually, the memory which is using our app
    will be claimed by a different app. Therefore, we cannot rely on putting data
    in memory for later use. In case we want to make sure the data is available across
    users of our app, we need to store that data in the device's persistent storage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建React Native应用程序时，了解移动设备如何处理每个应用程序使用的内存是很重要的。我们的应用程序将与设备中的其他应用程序共享内存，因此，最终，我们的应用程序使用的内存将被另一个应用程序占用。因此，我们不能依赖将数据放在内存中以供以后使用。如果我们想确保数据在我们的应用程序的用户之间可用，我们需要将数据存储在设备的持久存储中。
- en: React Native offers an API to handle the communication with the persistent storage
    in our mobile devices and this API is the same on iOS and Android, so we can write
    cross-platform code comfortably.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: React Native提供了一个API来处理与移动设备中的持久存储的通信，这个API在iOS和Android上是相同的，因此我们可以舒适地编写跨平台代码。
- en: 'The API is named `AsyncStorage`, and we can use it after importing from React
    Native:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: API的名称是`AsyncStorage`，我们可以在从React Native导入后使用它：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will only use two methods from `AsyncStorage`: `getItem` and `setItem`.
    For example, we will create within our screen a local function to handle the addition
    of a product to the full list of products:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会使用`AsyncStorage`的两个方法：`getItem`和`setItem`。例如，我们将在我们的屏幕内创建一个本地函数来处理将产品添加到产品列表中的操作。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are some interesting things to note here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情需要注意：
- en: We are using ES7 features such as `async` and `await` to handle asynchronous
    calls instead of promises or callbacks. Understanding ES7 is outside the scope
    of this book, but it is recommended to learn and understand about the use of `async`
    and `await`, as it's a very powerful feature we will be using extensively throughout
    this book.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用ES7的特性，比如`async`和`await`来处理异步调用，而不是使用promises或回调函数。理解ES7不在本书的范围之内，但建议学习和了解`async`和`await`的使用，因为这是一个非常强大的特性，在本书中我们将广泛使用它。
- en: Every time we add a product to `allProducts`, we also call `AsyncStorage.setItem`
    to permanently store the product in our device's storage. This action ensures
    that the products added by the user will be available even when the operating
    system clears the memory used by our app.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们向`allProducts`添加一个产品时，我们还会调用`AsyncStorage.setItem`来永久存储产品在设备的存储中。这个操作确保用户添加的产品即使在操作系统清除我们的应用程序使用的内存时也是可用的。
- en: 'We need to pass two parameters to `setItem` (and also to `getItem`): a key
    and a value. Both of them must be strings, so we would need to use `JSON.stringify`,
    if we want to store the JSON-formatted data.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要向`setItem`（以及`getItem`）传递两个参数：一个键和一个值。它们都必须是字符串，所以如果我们想存储JSON格式的数据，我们需要使用`JSON.stringify`。
- en: Adding state to our screen
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的屏幕添加状态
- en: As we have just seen, we will be using an attribute in our component's state
    named `allProducts`, which will contain the full list of products the user can
    add to the shopping list.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，我们将在组件状态中使用一个名为`allProducts`的属性，其中将包含用户可以添加到购物清单中的完整产品列表。
- en: 'We can initialize this state inside the component''s constructor to give the
    user a gist of what he/she will be seeing on this screen even during the first
    run of the app (this is a trick used by many modern apps to onboard users by faking
    a `used` state):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在组件的构造函数中初始化这个状态，以便在应用程序的第一次运行期间给用户一个概述，让他/她看到这个屏幕上的内容（这是许多现代应用程序用来引导用户的技巧，通过伪造一个“已使用”状态）：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Besides `allProducts`, we will also have a `productsInList` array, holding all
    the products which are already added to the current shopping list. This will allow
    us to mark the product as `Already in shopping list`, preventing the user from
    trying to add the same product twice in the list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“allProducts”，我们还将有一个“productsInList”数组，其中包含已经添加到当前购物清单中的所有产品。这将允许我们将产品标记为“已经在购物清单中”，防止用户尝试在列表中两次添加相同的产品。
- en: 'This constructor will be very useful for our app''s first run but once the
    user has added products (and therefore saved them in persistent storage), we want
    those products to display instead of this test data. In order to achieve this
    functionality, we should read the saved products from `AsyncStorage` and set it
    as the initial `allProducts` value in our state. We will do this on `componentWillMount`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数对我们应用程序的第一次运行非常有用，但一旦用户添加了产品（因此将它们保存在持久存储中），我们希望这些产品显示出来，而不是这些测试数据。为了实现这个功能，我们应该从“AsyncStorage”中读取保存的产品，并将其设置为我们状态中的初始“allProducts”值。我们将在“componentWillMount”上执行这个操作。
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are updating the state once the screen is ready to be mounted. First, we
    will update the `allProducts` value by reading it from the persistent storage.
    Then, we will update the list `productsInList` based on what the `ShoppingList`
    screen has set as the state in the `navigation` property.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦屏幕准备好被挂载，我们就会更新状态。首先，我们将通过从持久存储中读取它来更新“allProducts”值。然后，我们将根据“购物清单”屏幕在“导航”属性中设置的状态更新产品列表“productsInList”。
- en: 'With this state, we can build our list of products, which can be added to the
    shopping list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个状态，我们可以构建我们的产品列表，这些产品可以添加到购物清单中：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inside our `render` method, we will use an `Array.map` function to iterate and
    print each possible product, checking if the product is already added to the current
    shopping list to display a note, warning the user: `Already in shopping list`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“render”方法中，我们将使用“Array.map”函数来迭代和打印每个可能的产品，检查产品是否已经添加到当前购物清单中以显示一个提示，警告用户：“已经在购物清单中”。
- en: Of course, we still need to add a better layout, buttons, and event handlers
    for all the possible user actions. Let's start improving our `render` method to
    put all the functionality in place.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然需要为所有可能的用户操作添加更好的布局、按钮和事件处理程序。让我们开始改进我们的“render”方法，将所有功能放在适当的位置。
- en: Adding event listeners
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加事件监听器
- en: As it happened with the `ShoppingList` screen, we want the user to be able to
    interact with our `AddProduct` component, so we will add some event handlers to
    respond to some user actions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“购物清单”屏幕一样，我们希望用户能够与我们的“AddProduct”组件进行交互，因此我们将添加一些事件处理程序来响应一些用户操作。
- en: 'Our `render` method should then look something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“render”方法应该看起来像这样：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are three event handlers responding to the three press events in this
    component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，有三个事件处理程序响应三个按压事件：
- en: On the blue `<Fab>` button, which is in charge of adding new products to the
    products list
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝色的“<Fab>”按钮上，负责向产品列表中添加新产品
- en: On each `<ListItem>`, which will add the product to the shopping list
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个“<ListItem>”上，这将把产品添加到购物清单中
- en: On the delete icons inside each `<ListItem>` to remove this product from the
    list of the products, which can be added to the shopping list
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个“<ListItem>”内的删除图标上，以将此产品从可以添加到购物清单中的产品列表中移除
- en: 'Let''s start adding new products to the available products list once the user
    presses the `<Fab>` button:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在用户按下`<Fab>`按钮时开始向可用产品列表中添加新产品：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are using here the `prompt` function from the `react-native-prompt-android`
    module. Despite its name, it''s a cross-platform prompt-on-a-pop-up library, which
    we will use to add products through the `addNewProduct` function we created before.
    We need to import the `prompt` function before we use it, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了`react-native-prompt-android`模块的`prompt`函数。尽管它的名称是这样，但它是一个跨平台的弹出式提示库，我们将使用它通过我们之前创建的`addNewProduct`函数来添加产品。在使用之前，我们需要导入`prompt`函数，如下所示：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And here is the output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](Images/80a2b8e1-ff09-4493-a4ef-41a52d6ecd3e.png)![](Images/c1729134-4da3-4dcd-bf9a-f5ae93639a81.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/80a2b8e1-ff09-4493-a4ef-41a52d6ecd3e.png)![](Images/c1729134-4da3-4dcd-bf9a-f5ae93639a81.png)'
- en: 'Once the user enters the name of the product and presses OK, the product will
    be added to the list so that we can move to the next event handler, adding products
    to the shopping list when the user taps on the product name:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入产品名称并按下确定，产品将被添加到列表中，这样我们就可以转到下一个事件处理程序，当用户点击产品名称时将产品添加到购物清单中：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This handler checks if the selected product is on the shopping list already.
    If it is, it will remove it by calling `deleteProduct` from the navigation state
    and also from the component's state by calling `setState` . Otherwise, it will
    add the product to the shopping list by calling `addProduct` in the navigation
    state and refresh the local state by calling `setState`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序检查所选产品是否已在购物清单上。如果是，它将通过调用导航状态中的`deleteProduct`和通过调用`setState`从组件状态中删除它。否则，它将通过调用导航状态中的`addProduct`将产品添加到购物清单，并通过调用`setState`刷新本地状态。
- en: 'Finally, we will add an event handler for the delete icon on each of the `<ListItems>`,
    so the user can remove products from the list of available products:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为每个`<ListItems>`上的删除图标添加事件处理程序，以便用户可以从可用产品列表中删除产品：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We need to remove the product from the component's local state, but also from
    the `AsyncStorage` so it doesn't show during later runs of our app.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从组件的本地状态和`AsyncStorage`中删除产品，这样在应用程序的后续运行中就不会显示。
- en: Putting it all together
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'We have all the pieces to build our `AddProduct` screen, so let''s take a look
    at the general structure of this component:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有构建`AddProduct`屏幕的所有组件，所以让我们来看一下这个组件的一般结构：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have a very similar structure to the one we built for `ShoppingList `: the `navigatorOptions` constructor
    building the initial state, user action handlers, and a `render` method. In this
    case, we added a couple of async methods as a convenient way to deal with `AsyncStorage`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结构与我们为`ShoppingList`构建的结构非常相似：构建初始状态的`navigatorOptions`构造函数，用户操作处理程序和`render`方法。在这种情况下，我们添加了一对异步方法，作为处理`AsyncStorage`的便捷方式。
- en: Installing and distributing the app
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和分发应用程序
- en: Running our app on a simulator/emulator is a very reliable way to feel how our
    app will behave in a mobile device. We can simulate touch gestures, poor network
    connectivity environments, or even memory problems, when working in simulators/emulators.
    But eventually, we would like to deploy the app to a physical device, so we could
    perform a more in-depth testing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器/仿真器上运行我们的应用程序是感受应用程序在移动设备上行为的非常可靠的方法。当在模拟器/仿真器中工作时，我们可以模拟触摸手势、网络连接不佳的环境，甚至内存问题。但最终，我们希望将应用程序部署到物理设备上，这样我们就可以进行更深入的测试。
- en: There are several options to install or distribute an app built in React Native,
    the direct cable connection being the easiest one. Facebook keeps an updated guide
    on how to achieve direct installation on React Native's site ([https://facebook.github.io/react-native/docs/running-on-device.html](https://facebook.github.io/react-native/docs/running-on-device.html)),
    but there are other alternatives when the time comes to distribute the app to
    other developers, testers, or designated users.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选项可以安装或分发使用React Native构建的应用程序，直接连接电缆是最简单的方法。Facebook在React Native的网站上保持了一份更新的指南，介绍了如何实现在设备上的直接安装（[https://facebook.github.io/react-native/docs/running-on-device.html](https://facebook.github.io/react-native/docs/running-on-device.html)），但是当分发应用程序给其他开发人员、测试人员或指定用户时，还有其他选择。
- en: Testflight
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Testflight
- en: 'Testflight ([https://developer.apple.com/testflight/](https://developer.apple.com/testflight/))
    is an awesome tool for distributing the app to beta testers and developers, but
    it comes with a big drawback--it only works for iOS. It''s really simple to set
    up and use as it is integrated into iTunes Connect, and Apple considers it the
    official tool for distributing apps within the development team. On top of that,
    it''s absolutely free, and it''s usage limits are quite large:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Testflight（[https://developer.apple.com/testflight/](https://developer.apple.com/testflight/)）是一个很棒的工具，用于将应用程序分发给测试人员和开发人员，但它有一个很大的缺点——它只适用于iOS。它非常容易设置和使用，因为它集成在iTunes
    Connect中，苹果认为它是在开发团队内分发应用程序的官方工具。此外，它是完全免费的，使用限制相当大：
- en: Up to 25 testers in your team
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多25名团队成员进行测试
- en: Up to 30 devices per tester in your team
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试人员团队最多30台设备
- en: Up to 2,000 external testers outside your team (with grouping capabilities)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多2,000名团队外的外部测试人员（具有分组功能）
- en: In short, Testflight is the platform to choose when you target your apps only
    to iOS devices.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Testflight是在只针对iOS设备时选择的平台。
- en: Since, in this book, we want to focus on cross-platform development, we will
    introduce other alternatives to distribute our apps to iOS and Android devices
    from the same platform.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本书中，我们希望专注于跨平台开发，我们将介绍其他分发我们的应用程序到iOS和Android设备的替代方案。
- en: Diawi
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Diawi
- en: 'Diawi ([http://diawi.com](http://diawi.com)) is a website where developers
    can upload their `.ipa` and `.apk` files (the compiled app) and share the links
    with anybody, so the app can be downloaded and installed on any iOS or Android
    device connected to the internet. The process is simple:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Diawi（[http://diawi.com](http://diawi.com)）是一个网站，开发人员可以在上面上传他们的`.ipa`和`.apk`文件（已编译的应用程序），并与任何人分享链接，因此该应用程序可以在连接到互联网的任何iOS或Android设备上下载和安装。这个过程很简单：
- en: Build the `.ipa` (iOS) / `.apk` (Android) in XCode/Android studio.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XCode/Android studio中构建`.ipa`（iOS）/`.apk`（Android）。
- en: Drag and drop the generated `.ipa`/`.apk` file into Diawi's site.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`.ipa`/`.apk`文件拖放到Diawi的网站上。
- en: Share the link created by Diawi with the list of testers by email or any other
    method.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过电子邮件或其他方式与测试人员列表共享Diawi创建的链接。
- en: Links are private and can be password protected for those apps with the higher
    need of security. The main downside is the management of the testing devices,
    as once the links are distributed, Diawi loses control over them, so the developer
    cannot know which versions were downloaded and tested. If managing the list of
    testers manually is an option, Diawi is a good alternative to Testflight.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是私有的，可以为那些需要更高安全性的应用程序设置密码保护。主要缺点是测试设备的管理，因为一旦链接分发，Diawi就失去了对它们的控制，因此开发人员无法知道哪些版本被下载和测试。如果手动管理测试人员列表是一个选择，Diawi是Testflight的一个很好的替代方案。
- en: Installr
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Installr
- en: If we are in need of managing what versions were distributed to which testers
    and whether they have already started testing the app or not, we should give Installr
    ([https://www.installrapp.com](https://www.installrapp.com)) a try, since functionality-wise
    it is quite similar to Diawi, but it also includes a dashboard to control who
    are the users, which apps were sent to them individually, and the status of the
    app in the testing device (not installed, installed, or opened). This dashboard
    is quite powerful and definitely a big plus when one of our requirements is to
    have good visibility over our testers, devices, and builds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要管理分发给哪些测试人员的版本以及他们是否已经开始测试应用程序，我们应该尝试使用Installr（[https://www.installrapp.com](https://www.installrapp.com)），因为在功能上它与Diawi相当类似，但它还包括一个仪表板，用于控制用户是谁，哪些应用程序已经单独发送给他们，以及测试设备上应用程序的状态（未安装、已安装或已打开）。这个仪表板非常强大，当我们的要求之一是对测试人员、设备和构建有良好的可见性时，它绝对是一个重要的优势。
- en: The downside of Installr is its free plan only covers three testing devices
    per build, although they offer a cheap one-time pay scheme in case we really want
    to have that number increased. It's a very reasonable option when we are in need
    of visibility and cross-platform distribution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Installr的缺点是其免费计划仅覆盖每次构建的三个测试设备，尽管他们提供了一个廉价的一次性付费方案，以防我们真的想增加那个数字。当我们需要可见性和跨平台分发时，这是一个非常合理的选择。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: During the course of this chapter, we learned how to start up a React Native
    project, building an app which includes basic navigation and handling several
    user interactions. We saw how to handle persistent data and basic states using
    the navigation module, so we could transition through the screens in our project.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们学会了如何启动React Native项目，构建一个包括基本导航和处理多个用户交互的应用程序。我们看到了如何使用导航模块处理持久数据和基本状态，以便我们可以在项目中的屏幕之间进行过渡。
- en: All these patterns can be used to build lots of simple apps, but in the next
    chapter, we will dive deeper into more complex navigation patterns and how to
    communicate and process external data fetched from the internet, which will enable
    us to structure and prepare our app for growing. On top of that, we will use MobX,
    a JavaScript library, for state management, which will make our domain data available
    to all the screens inside our app in a very simple and effective way.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模式都可以用来构建许多简单的应用程序，但在下一章中，我们将深入探讨更复杂的导航模式以及如何通信和处理从互联网获取的外部数据，这将使我们能够为应用程序的增长进行结构化和准备。除此之外，我们将使用JavaScript库MobX进行状态管理，这将以一种非常简单和有效的方式使我们的领域数据可用于应用程序中的所有屏幕。
