- en: Getting Started with React and TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习React和TypeScript
- en: React is a JavaScript library that helps us build the frontend of an app. It
    allows us to structure our apps using powerful and reusable components. It helps
    us manage the data that the components use, and their state, in a structured fashion.
    It uses something called a virtual DOM to efficiently render our frontend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个帮助我们构建应用程序前端的JavaScript库。它允许我们使用强大且可重用的组件来构建应用程序的结构。它帮助我们以结构化的方式管理组件使用的数据和它们的状态。它使用一种叫做虚拟DOM的东西来高效地渲染我们的前端。
- en: TypeScript can work beautifully with React, giving us the ability to add static
    types to our React components. The types help our code editor to surface problems
    while we write our React components, and give us tools to safely refactor them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript可以与React完美配合，使我们能够为我们的React组件添加静态类型。这些类型帮助我们的代码编辑器在编写React组件时发现问题，并为我们提供安全重构的工具。
- en: In this chapter, we'll look at two different ways to create a React and TypeScript
    project. We'll create our first React component, which will be a confirmation
    dialog. Early topics we'll cover are JSX and strongly typed props. We'll look
    at handling the dialog's button click events.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍创建React和TypeScript项目的两种不同方式。我们将创建我们的第一个React组件，这将是一个确认对话框。我们将首先涵盖JSX和强类型props。我们将讨论如何处理对话框的按钮点击事件。
- en: We'll then look at declaring and interacting with strongly typed states, which
    will be used to hide and show the dialog. We'll discuss component life cycle methods,
    and touch on the ones that have been removed in React 17.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将学习声明和与强类型状态交互，这将用于隐藏和显示对话框。我们将讨论组件的生命周期方法，并涉及在React 17中已删除的方法。
- en: Finally, we'll look at function components, and when these are used.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习函数组件以及它们的使用场景。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a React and TypeScript project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建React和TypeScript项目
- en: Creating a class component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类组件
- en: Handling class component events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理类组件事件
- en: Class component states
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类组件状态
- en: Class component life cycle methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类组件的生命周期方法
- en: Creating a function component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数组件
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We use the following technologies in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用以下技术：
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. Install
    them from the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和** `npm`：TypeScript和React依赖于这些。可以从以下链接安装它们：[https://nodejs.org/en/download/](https://nodejs.org/en/download)。如果您已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We''ll also need the TSLint extension (by egamma) and the Prettier extension (by Estben
    Petersen).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写我们的React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要由egamma开发的TSLint扩展和由Estben
    Petersen开发的Prettier扩展。'
- en: '**Babel Repl**: We''ll use this online tool briefly to explore JSX. This can
    be found at[ https://babeljs.io/repl](https://babeljs.io/repl).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babel Repl**：我们将简要使用这个在线工具来探索JSX。它可以在[https://babeljs.io/repl](https://babeljs.io/repl)找到。'
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/03-GettingStartedWithReactAndTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/03-GettingStartedWithReactAndTypeScript).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在以下网址找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/03-GettingStartedWithReactAndTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/03-GettingStartedWithReactAndTypeScript)。
- en: Creating a React and TypeScript project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建React和TypeScript项目
- en: There are several ways to create a React and TypeScript project. We'll start
    by quickly creating a project using a popular tool called `create-react-app`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建一个React和TypeScript项目。我们将首先使用一个名为`create-react-app`的流行工具快速创建一个项目。
- en: We'll then create a project in a more manual way, helping us to understand all
    the different pieces in play.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将以更加手动的方式创建一个项目，帮助我们理解所有不同的部分。
- en: Using create-react-app
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用create-react-app
- en: '`create-react-app` is a command-line tool that we can use to quickly create
    a React and TypeScript app with lots of useful pieces.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`是一个命令行工具，我们可以使用它快速创建一个带有许多有用部分的React和TypeScript应用程序。'
- en: 'Open Visual Studio Code in an empty folder of your choice. Let''s create an
    app using this tool:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的空文件夹中打开Visual Studio Code。让我们使用这个工具创建一个应用程序：
- en: 'We use the `create-react-app` `npm` package to create a React and TypeScript
    project by entering the following:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`create-react-app` `npm`包来创建一个React和TypeScript项目，输入以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `npx` tool temporarily installs the `create-react-app` `npm` package and
    uses it to create our project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx`工具会临时安装`create-react-app` `npm`包，并使用它来创建我们的项目。'
- en: We chose to call our project `my-react-ts-app`. We also specified `--typescript`,
    which is the bit that tells the tool to set the project up with TypeScript.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择将项目命名为`my-react-ts-app`。我们还指定了`--typescript`，这是告诉工具使用TypeScript设置项目的部分。
- en: The tool will take a minute or so to create your project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将花费一分钟左右的时间来创建您的项目。
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json`
    is less that `16.7.0-alpha.0` then we can install this version using the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的React版本至少需要是`16.7.0-alpha.0`版本。我们可以在`package.json`文件中检查这一点。如果`package.json`中的React版本小于`16.7.0-alpha.0`，那么我们可以使用以下命令安装此版本：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the project is created, add TSLint as a development dependency, along
    with some rules that work well with React and Prettier:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建完成后，将TSLint作为开发依赖项添加到项目中，并添加一些与React和Prettier兼容的规则：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now add a `tslint.json` file, containing some rules:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个包含一些规则的`tslint.json`文件：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we are merging the generally recommended rules with specific ones for React
    and Prettier. We've enabled the use of `debugger` and `console` statements, which
    will come in handy from time to time as we develop our app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一般推荐的规则与React和Prettier的特定规则合并在一起。我们已经启用了`debugger`和`console`语句的使用，这在开发应用程序时会偶尔派上用场。
- en: We've also suppressed the rule about the ordering of `import` statements and
    object literal keys, to make life easier as we copy bits of code from this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还抑制了关于`import`语句和对象字面量键排序的规则，以使我们从本书中复制代码的生活更轻松。
- en: 'We can now start the app running in a development server, by entering the following
    command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过输入以下命令来启动开发服务器中的应用程序：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After a few seconds, a browser window opens, with our app running:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，一个浏览器窗口打开，我们的应用程序正在运行：
- en: '![](assets/a96969e2-42c9-4fe9-90a0-87511bdb988b.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a96969e2-42c9-4fe9-90a0-87511bdb988b.png)'
- en: Our React code is in the `src` folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的React代码在`src`文件夹中。
- en: 'With our app still running, open the `App.tsx` file. You''ll immediately see
    a linting error on the `render` method, because we haven''t specified the modifier:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序仍在运行时，打开`App.tsx`文件。您将立即看到`render`方法上的一个linting错误，因为我们没有指定修饰符：
- en: '![](assets/48d8fa70-431f-4d63-90f4-abff818b1851.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48d8fa70-431f-4d63-90f4-abff818b1851.png)'
- en: 'So, let''s fix that by adding `public` as the modifier:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过添加`public`作为修饰符来修复这个问题：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While we are still in `App.tsx`, let''s change the anchor tag to the following:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们仍然在`App.tsx`中时，让我们将锚点标签更改为以下内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the file, and go back to the app in the browser. The app has automatically
    changed, showing the new content. Nice!
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后返回浏览器中的应用程序。应用程序已自动更改，显示新内容。不错！
- en: '![](assets/85a4cb7a-d20c-4c55-80d7-0b974afb25f8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85a4cb7a-d20c-4c55-80d7-0b974afb25f8.png)'
- en: '`create-react-app` has configured a lot of great stuff for us in our project.
    This is great if we just want to quickly start learning React, and skip over how
    the React and TypeScript code is packaged up to be served from a web server.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`已经为我们的项目配置了很多很棒的东西。如果我们只是想快速开始学习React，并跳过React和TypeScript代码如何打包以便从web服务器提供的部分，这很棒。'
- en: In the next section, we'll do manually do some of what `create-react-app` did
    for us automatically. This will start to give us an understanding of what needs
    to happen when React and TypeScript apps are packaged up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将手动执行一些`create-react-app`自动为我们执行的操作。这将开始让我们了解当React和TypeScript应用程序打包时需要发生什么。
- en: Creating a project manually
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建项目
- en: In this section, we'll create a React and TypeScript project manually, step
    by step. We'll start by creating our folder structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步手动创建一个React和TypeScript项目。我们将从创建我们的文件夹结构开始。
- en: Creating our folder structure
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的文件夹结构
- en: We need a folder structure that gives us decent separation between the project's
    configuration files, source code, and files to distribute to our web server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个文件夹结构，可以在项目的配置文件、源代码和要分发到我们的web服务器的文件之间提供良好的分离。
- en: 'All our configuration files will go in our project route:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的配置文件都将放在我们项目的根目录中：
- en: Open Visual Studio Code in an empty folder of your choice, and create a folder
    called `src`. This will hold our source code.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的空文件夹中打开Visual Studio Code，并创建一个名为`src`的文件夹。这将保存我们的源代码。
- en: Let's also create a folder called `dist`. This will hold the files to distribute
    to our web server.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还创建一个名为`dist`的文件夹。这将保存要分发到我们的web服务器的文件。
- en: Creating package.json
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建package.json
- en: The `package.json`file defines our project name, description, build commands,
    dependent `npm` modules, and much more.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件定义了我们的项目名称、描述、构建命令、依赖的`npm`模块等等。'
- en: 'Open a terminal window, and run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，并运行以下命令：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will prompt you for various bits of information about the project, and
    then create a `package.json` file containing that information.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示您输入有关项目的各种信息，然后创建一个包含该信息的`package.json`文件。
- en: Adding TypeScript
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加TypeScript
- en: We installed TypeScript globally in [Chapter 1](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml),
    *TypeScript Basics*. In this section, we are going to install it locally within
    our project. Having TypeScript locally simplifies the build process a little bit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml)中全局安装了TypeScript，*TypeScript基础*。在本节中，我们将在我们的项目中本地安装它。在本地拥有TypeScript可以简化构建过程。
- en: 'We can install TypeScript just within our project by running the following
    command in the terminal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在终端中运行以下命令来在我们的项目中安装TypeScript：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `--save-dev` command marks the TypeScript dependency as being only for development
    purposes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save-dev`命令将TypeScript依赖标记为仅用于开发目的。'
- en: Creating tsconfig.json
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建tsconfig.json
- en: As outlined in [Chapter 1](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml),* TypeScript
    Basics*, `tsconfig.json` specifies how our TypeScript code is compiled and transpiled.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml)中所述，*TypeScript基础*，`tsconfig.json`指定了我们的TypeScript代码如何编译和转译。
- en: 'Let''s create a new file called `tsconfig.json` in the root of our project,
    and enter the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的根目录中创建一个名为`tsconfig.json`的新文件，并输入以下内容：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding TSLint
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加TSLint
- en: 'in [Chapter 1](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=24&action=edit#post_24),* TypeScript
    Linting*, introduced us to TSLint. Add it to your project as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=24&action=edit#post_24)，*TypeScript
    Linting*中，我们介绍了TSLint。按照以下步骤将其添加到您的项目中：
- en: 'Install TSLint by entering the following command in the terminal:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中输入以下命令来安装TSLint：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a basic `tslint.json` file at the root of our project, and enter the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目的根目录下添加一个基本的`tslint.json`文件，并输入以下内容：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding React with types
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加带有类型的React
- en: 'Let''s add the React library to our project, by running the following command
    in the terminal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在终端中运行以下命令来将React库添加到我们的项目中：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also want the TypeScript types for React. So, add these to our project as
    a development dependency, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为React添加TypeScript类型。因此，将这些作为开发依赖项添加到我们的项目中，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a root web page
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个根网页
- en: 'We need an HTML page that is going to host our React app. Create a file called `index.html` in
    our `dist` folder, and enter the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个HTML页面来托管我们的React应用程序。在我们的`dist`文件夹中创建一个名为`index.html`的文件，并输入以下内容：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The HTML from our React app will be injected into the `div` with `id ="root"`.
    All the app's JavaScript code will eventually be bundled together into a file
    called `bundle.js` in the `dist` folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 来自我们的React应用程序的HTML将被注入到具有`id ="root"`的`div`中。所有应用程序的JavaScript代码最终将捆绑在一起，形成一个名为`bundle.js`的文件，位于`dist`文件夹中。
- en: Of course, neither of these exist at the moment—we'll do this in a later section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，目前这两者都不存在-我们将在以后的部分中进行这样做。
- en: Creating a simple React component
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的React组件
- en: 'Let''s create a very simple React component. Create a file called `index.tsx`
    in your `src` folder, and enter the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的React组件。在您的`src`文件夹中创建一个名为`index.tsx`的文件，并输入以下内容：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our component simply returns `My React App!` in an `h1` tag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件简单地在`h1`标签中返回`My React App!`。
- en: The `tsx` extension distinguishes TypeScript React components from vanilla JavaScript
    React components, which have a `jsx`extension. `React.SFC` is a TypeScript type
    we can use for React components that don't have any internal state. We'll learn
    more about these components later in this book, and we'll look at state later
    in this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsx`扩展名将TypeScript React组件与普通JavaScript React组件区分开来，后者具有`jsx`扩展名。`React.SFC`是我们可以用于没有任何内部状态的React组件的TypeScript类型。我们将在本书的后面学到更多关于这些组件的知识，并且我们将在本章的后面看到状态。'
- en: The next step is to inject our React component into `index.html`. We can do
    that by using the `ReactDOM.render` function. `ReactDOM.render` takes in our component
    as the first parameter, and the HTML element to inject it into as the next element.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将我们的React组件注入到`index.html`中。我们可以通过使用`ReactDOM.render`函数来实现。`ReactDOM.render`将我们的组件作为第一个参数，要注入的HTML元素作为下一个元素。
- en: 'Let''s add the highlighted lines into `index.tsx`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将突出显示的行添加到`index.tsx`中：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have a small app in place, we need to package it up. We'll cover
    that in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个小型的应用程序，我们需要打包它。我们将在下一节中介绍这个。
- en: Adding webpack
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加webpack
- en: Webpack is a popular tool that we can use to bundle all our JavaScript code
    into the `bundle.js` file that our `index.html` is expecting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack是一个流行的工具，我们可以使用它将所有JavaScript代码捆绑成`bundle.js`文件，这是我们的`index.html`所期望的。
- en: 'Install webpack and its command-line interface into our project as development
    dependencies, by entering the following command in the terminal:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中输入以下命令，将webpack及其命令行界面安装到我们的项目中作为开发依赖项：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Webpack also has a handy web server that we can use during development. So,
    let''s install that as well via the terminal:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack还有一个方便的Web服务器，我们可以在开发过程中使用。因此，让我们也通过终端安装它：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There''s one final task to complete before we can start configuring webpack.
    This is to install a webpack plugin called `ts-loader`, which will help it load
    our TypeScript code. Install this as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始配置webpack之前，还有一个最后的任务要完成。这就是安装一个名为`ts-loader`的webpack插件，它将帮助加载我们的TypeScript代码。按照以下方式安装：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have all this webpack stuff in our project, it''s time to configure
    it. Create a file called `webpack.config.js` in the project root, and enter the
    following into it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在项目中有了所有这些webpack的东西，是时候配置它了。在项目根目录中创建一个名为`webpack.config.js`的文件，并输入以下内容：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There''s a fair bit going on here, so let''s break it down:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情要做，让我们来分解一下：
- en: The `module.exports` is our webpack configuration object.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.exports`是我们的webpack配置对象。'
- en: The `entry` field tells webpack where to start looking for modules to bundle.
    In our project, this is `index.tsx`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`字段告诉webpack从哪里开始查找要捆绑的模块。在我们的项目中，这是`index.tsx`。'
- en: The `module` field tells webpack how different modules will be treated. Our
    project is telling webpack to use `ts-loader` to handle files with `ts` and `tsx`
    extensions.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`字段告诉webpack如何处理不同的模块。我们的项目告诉webpack使用`ts-loader`来处理带有`ts`和`tsx`扩展名的文件。'
- en: The `resolve` field tells webpack how to resolve modules. In our project, we
    need to process `tsx` and `.ts` files, as well as the standard `.js` files.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolve`字段告诉webpack如何解析模块。在我们的项目中，我们需要处理`tsx`和`.ts`文件，以及标准的`.js`文件。'
- en: The `output` field tells webpack where to bundle our code. In our project, this
    is the file called `bundle.js` in the `dist` folder.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`字段告诉webpack在哪里捆绑我们的代码。在我们的项目中，这是`dist`文件夹中名为`bundle.js`的文件。'
- en: The `devServer` field configures the webpack development server. We are telling
    it that the root of the web server is the `dist` folder, and to serve files on
    `port 9000`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devServer`字段配置webpack开发服务器。我们告诉它web服务器的根目录是`dist`文件夹，并在`9000端口`上提供文件。'
- en: Project folders and files
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目文件夹和文件
- en: 'We should now have the following folders, with the following files within them:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有以下文件夹，并且其中有以下文件：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are nearly ready to run our app now—there's just one more thing to do, as
    we'll discuss in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎可以运行我们的应用程序了，只剩下一件事要做，我们将在下一节讨论。
- en: Creating start and build scripts
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建启动和构建脚本
- en: 'We are going to leverage `npm` scripts to start our app in development mode,
    and also to build a production version of our app:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用`npm`脚本来启动我们的应用程序以开发模式运行，并构建我们应用程序的生产版本：
- en: 'Let''s open up `package.json`—there should be quite a bit of content in there
    now. We need to find the `scripts` section, which will probably have a single
    script called `test` in place. Add the highlighted scripts for `start` and `build`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`package.json` - 现在里面应该有相当多的内容。我们需要找到`scripts`部分，其中可能只有一个名为`test`的脚本。添加`start`和`build`的突出显示脚本：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following command, which produces a production version of our app:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，生成我们应用程序的生产版本：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, webpack will kick in and do its stuff. If we look in the `dist` folder,
    eventually a file called `bundle.js` will appear. This file contains all the JavaScript
    minified code, including code from the React library and our simple React component.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，webpack将开始并执行其操作。如果我们查看`dist`文件夹，最终会出现一个名为`bundle.js`的文件。此文件包含所有JavaScript压缩代码，包括来自React库和我们简单的React组件的代码。
- en: 'Now, enter the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The webpack development server will start.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: webpack开发服务器将启动。
- en: 'If we browse to `http://localhost:9000/` we''ll see our web app:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们浏览到`http://localhost:9000/`，我们会看到我们的Web应用程序：
- en: '![](assets/31fcd5ee-d43e-4ac6-9043-883e5e2fc4ad.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/31fcd5ee-d43e-4ac6-9043-883e5e2fc4ad.png)
- en: 'With our app still running, in `index.tsx`, let''s change our `App` component
    to the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序仍在运行时，在`index.tsx`中，让我们将我们的`App`组件更改为以下内容：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we save `index.tsx` and go to the browser, we''ll see that our app automatically
    updates with the new content:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们保存`index.tsx`并转到浏览器，我们会看到我们的应用程序会自动更新新内容：
- en: '![](assets/d6eaae2c-cbff-47d2-8df0-d95baab0d1f9.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/d6eaae2c-cbff-47d2-8df0-d95baab0d1f9.png)
- en: We'll leave our manually-configured project there. It doesn't do as much as
    the `create-react-app` project, but we have started to gain an understanding of
    how React and TypeScript projects are packaged up.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留我们手动配置的项目。它不像`create-react-app`项目那样功能强大，但我们已经开始了解React和TypeScript项目是如何打包的。
- en: Creating a class component
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个类组件
- en: So far we have created some very simple components. In this section, we are
    going to build a component that is a little more complex, and start to get more
    familiar with some of the different parts of a component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一些非常简单的组件。在本节中，我们将构建一个稍微复杂一些的组件，并开始更熟悉组件的一些不同部分。
- en: Together, we'll start to build a component called `Confirm` that will allow
    a user to either continue with an operation or stop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，我们将开始构建一个名为`Confirm`的组件，该组件将允许用户继续进行操作或停止。
- en: 'Our component will look like the following screenshot when we''ve finished:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们的组件将看起来像以下截图：
- en: '![](assets/479ba1df-b4b2-42c1-a901-e9684cd9e788.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/479ba1df-b4b2-42c1-a901-e9684cd9e788.png)'
- en: 'We''re going to use `create-react-app` to spin up a project quickly, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`create-react-app`快速启动一个项目，如下所示：
- en: 'Open up Visual Studio Code in a folder of your choice and enter the following
    in the terminal:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的文件夹中打开Visual Studio Code，并在终端中输入以下内容：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This time we chose to call our project `my-components`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们选择将项目命名为`my-components`。
- en: 'Let''s add TSLint with some rules as a development dependency to our project:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将TSLint与一些规则作为开发依赖项添加到我们的项目中：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now add a `tslint.json` file, containing the following rules:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个包含以下规则的`tslint.json`文件：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Fix the linting error in `App.tsx` by adding the missing access modifier on
    the `render` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`App.tsx`中为`render`方法添加缺少的访问修饰符来修复linting错误：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now start a development server and start our app:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动开发服务器并启动我们的应用程序：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next we''ll shrink and fix the app header, so that there is enough space for
    our confirmation component. Change the highlighted lines in `app.css`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将缩小并修复应用程序标题，以便为我们的确认组件留出足够的空间。更改`app.css`中的突出显示的行：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The app header should now be a little shorter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序标题现在应该会短一点。
- en: We'll keep our app running while we develop our component in the following sections.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将继续开发我们的组件，同时保持应用程序运行。
- en: Creating a basic class component
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的类组件
- en: 'Let''s look at `App.tsx`, which has been created for us. This is an example
    of a class component. We''re going to create our own class component now. Follow
    these steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下为我们创建的`App.tsx`。这是一个类组件的示例。现在我们将创建我们自己的类组件。按照以下步骤进行：
- en: 'Create a file called `Confirm.tsx` in the `src` folder, and enter the following
    into it:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`Confirm.tsx`的文件，并输入以下内容：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We learned all about classes in [Chapter 1](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml),
    *TypeScript Basics**.* Here we are creating a class that extends the standard
    `Component` class from React. Note that we've imported React at the top of our
    file, and also that we are exporting our class component using a default export
    at the bottom of our file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml)中学习了有关类的所有内容，*TypeScript
    Basics**.* 在这里，我们正在创建一个扩展自React标准`Component`类的类。请注意，我们已经在文件顶部导入了React，并且我们还在文件底部使用默认导出导出了我们的类组件。
- en: 'Let''s start to implement our `Confirm` class component now, by creating a
    `render` method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们开始实现我们的`Confirm`类组件，通过创建一个`render`方法：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `render` method determines what the component needs to display. We define
    what needs to be displayed using JSX. In simple terms, JSX is a mix of HTML and
    JavaScript. We'll explore it in more detail in the next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法确定组件需要显示什么。我们使用JSX定义需要显示的内容。简单来说，JSX是HTML和JavaScript的混合。我们将在下一节中更详细地探讨它。'
- en: 'For the time being, let''s enter the following in our `render` method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时，让我们在我们的`render`方法中输入以下内容：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At the moment, our `render` method looks a lot more like HTML than JavaScript,
    apart from that funny `className` attribute—shouldn't that be `class`?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`render`方法看起来更像HTML而不是JavaScript，除了那个有趣的`className`属性——那不应该是`class`吗？
- en: We'll cover this and JSX in a little more detail in the next section, but before
    that, let's consume our `Confirm` component in the `App` component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地介绍这一点和JSX，但在此之前，让我们在`App`组件中使用我们的`Confirm`组件。
- en: 'In `App.tsx`, we need to import our `Confirm` component class, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.tsx`中，我们需要导入我们的`Confirm`组件类，如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our `Confirm` component can be referenced as `<Confirm />` in JSX. So, let''s
    add this to the JSX in `App.tsx`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Confirm`组件可以在JSX中被引用为`<Confirm />`。因此，让我们将其添加到`App.tsx`中的JSX中：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we look at the browser page where our app is running, it should now look
    like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们应用程序运行的浏览器页面，现在应该看起来像下面这样：
- en: '![](assets/e7737339-e6c2-4376-bb53-7cda7d4a6751.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7737339-e6c2-4376-bb53-7cda7d4a6751.png)'
- en: 'We are going to make our component look more like a dialog using CSS. Let''s
    create a file called `Confirm.css`, and enter the following into it:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用CSS使我们的组件看起来更像一个对话框。让我们创建一个名为`Confirm.css`的文件，并将以下内容输入其中：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s import our CSS in our `Confirm.tsx`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`Confirm.tsx`中导入我们的CSS：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our component in the browser page should now look like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器页面中的组件现在应该看起来像下面这样：
- en: '![](assets/f4c03642-d503-4ae2-a8ce-442cc9e83126.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4c03642-d503-4ae2-a8ce-442cc9e83126.png)'
- en: So, a React class component has a special method called `render`, where we define
    what our component displays in JSX.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React类组件有一个称为`render`的特殊方法，在其中我们定义了组件在JSX中显示的内容。
- en: In the next section, we'll take a little break from our confirmation component
    while we learn a little more about JSX.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将暂时离开我们的确认组件，同时学习更多关于JSX的知识。
- en: JSX
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: As mentioned in the previous section, JSX looks a bit like HTML. We can have
    JSX in our JavaScript (or TypeScript) code, as we did in the last section in our
    `render` function. JSX isn't valid JavaScript though—we need a preprocessor step
    to convert it into JavaScript.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，JSX看起来有点像HTML。我们可以在我们的JavaScript（或TypeScript）代码中使用JSX，就像我们在上一节的`render`函数中所做的那样。不过，JSX并不是有效的JavaScript——我们需要一个预处理步骤将其转换为JavaScript。
- en: 'We''re going to use an online Babel REPL to play with JSX:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在线的Babel REPL来玩转JSX：
- en: 'Open a browser, go to [https://babeljs.io/repl](https://babeljs.io/repl), and
    enter the following JSX in the left-hand pane:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，转到[https://babeljs.io/repl](https://babeljs.io/repl)，并在左侧窗格中输入以下JSX：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following appears in the right-hand pane, which is what our JSX has compiled
    down to:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧窗格中显示的是我们的JSX编译后的内容：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can see that it compiles down to a call to `React.createElement`, which
    has three parameters:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它编译为对`React.createElement`的调用，它有三个参数：
- en: The element type, which can be an HTML tag name string (such as `"span"`), a
    React component type, or a React fragment type
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素类型，可以是HTML标签名称字符串（例如`"span"`），React组件类型或React片段类型
- en: An object containing the props to be applied to the element
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含要应用于元素的props的对象
- en: The children for the element
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的子元素
- en: 'Let''s expand our example by putting `div` tags around our `span`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在我们的`span`周围放置`div`标签来扩展我们的示例：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This now compiles down to two calls to `React.createElement`, with `span` being
    passed in as a child to `div`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它编译为两个对`React.createElement`的调用，其中`span`作为子元素传递给`div`：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is starting to make sense, but so far our JSX has consisted of only HTML.
    Let''s add some JavaScript now, by declaring a props object literal. Let''s also
    reference the `title` prop inside the `span` using curly braces:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始有点意义了，但到目前为止，我们的JSX只包含HTML。现在让我们通过声明一个props对象文字来添加一些JavaScript。我们还可以使用大括号在`span`中引用`title`属性：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is more interesting now. It compiles down to this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更有趣了。它编译成了这样：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The key point is that we can inject JavaScript into HTML by using curly braces.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是我们可以通过使用大括号将JavaScript注入HTML中。
- en: 'To further illustrate the point, let''s empty the `props` object literal, and
    use a JavaScript ternary inside `span`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们清空`props`对象文字，并在`span`中使用JavaScript三元表达式：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We see that the nested call to `React.createElement` uses our ternary as the
    child of `span`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到嵌套调用`React.createElement`使用我们的三元表达式作为`span`的子元素：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, why do we use the `className` attribute rather than `class`? Well, we now
    understand that JSX compiles down to JavaScript, and as `class` is a keyword in
    JavaScript, having a `class` attribute in JSX would clash. So, React uses `className` instead
    for CSS class references.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们使用`className`属性而不是`class`？嗯，我们现在明白了JSX编译成JavaScript，而`class`是JavaScript中的关键字，在JSX中有一个`class`属性会产生冲突。因此，React使用`className`来代替CSS类引用。
- en: Now that we understand a little more about JSX, let's come back to our `Confirm`
    component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对JSX有了更多的了解，让我们回到我们的`Confirm`组件。
- en: Component props
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件props
- en: At the moment, the title and content text for our `Confirm` component is hardcoded.
    Let's change these to reference properties (props) that the component takes in.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`Confirm`组件的标题和内容文本是硬编码的。让我们将这些更改为引用组件接受的属性（props）。
- en: 'First, we need to define a TypeScript type for our props. We''ll use an interface
    for this preceding the `Confirm` class in `Confirm.tsx`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的props定义一个TypeScript类型。我们将在`Confirm.tsx`中的`Confirm`类之前使用接口：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can then reference the `IProps` type in angle brackets, after we reference
    `React.Component` in the class definition:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类定义中引用`React.Component`之后，我们可以在尖括号中引用`IProps`类型：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`React.Component` is what is called a generic class. Generic classes allow
    types used within the class to be passed in. In our case, we have passed in our
    `IProps` interface. Don''t worry if this doesn''t make too much sense at the moment—we''ll
    cover generic classes later in the book.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.Component`是所谓的通用类。通用类允许在类内使用的类型被传递进来。在我们的情况下，我们已经传入了我们的`IProps`接口。如果这一点目前还不太明白，不要担心，我们将在本书的后面介绍通用类。'
- en: 'We get access to props in our class using `this.props.propName`. In our JSX,
    we can now reference props instead of hardcoding the title and content:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`this.props.propName`在我们的类中访问props。在我们的JSX中，我们现在可以引用props而不是硬编码标题和内容：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that we now have a TypeScript compilation error when we reference our
    `Confirm` component in `App.tsx`. This is because our component now expects `title` and `content` attributes,
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在`App.tsx`中引用我们的`Confirm`组件时，现在会有一个TypeScript编译错误。这是因为我们的组件现在期望`title`和`content`属性，如下所示：
- en: '![](assets/4263da72-8c5c-4219-904d-5402bbdf22bb.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4263da72-8c5c-4219-904d-5402bbdf22bb.png)'
- en: 'Let''s add the `title` and `content` attributes:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`title`和`content`属性：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The compilation error now goes away, and if we look at the browser, our component
    is rendered exactly as it was before we implemented props.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误现在消失了，如果我们查看浏览器，我们的组件呈现方式与我们实现props之前完全相同。
- en: Optional props
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选的props
- en: Interface props can be optional, as we discovered in [Chapter 1](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml),
    *TypeScript Basics*. So, we can also use this mechanism to add optional props
    to a React component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接口props可以是可选的，正如我们在[第1章](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml)中发现的那样，*TypeScript基础*。因此，我们也可以使用这种机制向React组件添加可选的props。
- en: 'Let''s add some optional props to allow the button captions to be configurable
    on our confirmation component:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些可选的props，以允许确认组件上的按钮标题可配置：
- en: 'Add some additional optional props called `cancelCaption` and `okCaption` to
    our interface:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的接口中添加一些额外的可选props，称为`cancelCaption`和`okCaption`：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We put a `?` before the type annotation to denote that the prop is optional.
    Note also that we don't get a compilation error in `App.tsx`, where we reference,
    `Confirm` because we are not required to enter these as attributes on `Confirm`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类型注释之前放一个`?`来表示该prop是可选的。还要注意，在我们引用`Confirm`的`App.tsx`中，我们没有得到编译错误，因为我们不需要在`Confirm`上输入这些属性。
- en: 'Let''s reference these props in our JSX now, replacing the hardcoded captions:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在JSX中引用这些props，替换硬编码的标题：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we look at the browser now, we have no button captions in our running app:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看浏览器，我们在我们正在运行的应用程序中没有按钮标题：
- en: '![](assets/4f338c2a-2d36-4e95-af4e-4b0512a7f2cb.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f338c2a-2d36-4e95-af4e-4b0512a7f2cb.png)'
- en: This is because we haven't supplied these values when we reference `Confirm` in `App.tsx`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当我们在`App.tsx`中引用`Confirm`时，我们没有提供这些值。
- en: In the next section, we'll resolve this issue by adding some default values
    for `cancelCaption` and `okCaption`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过为`cancelCaption`和`okCaption`添加一些默认值来解决这个问题。
- en: Default prop values
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认属性值
- en: Default values can be added to component props when the component is initialized.
    These can be implemented using a static object literal called `defaultProps`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化时，可以向组件props添加默认值。这可以使用一个名为`defaultProps`的静态对象文字来实现。
- en: 'Let''s make use of this feature in our `Confirm` component, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`Confirm`组件中利用这个特性，如下所示：
- en: 'Create some default values for `cancelCaption` and `okCaption` in our class:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类中为`cancelCaption`和`okCaption`创建一些默认值：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we look at our running app again, we have button captions once more.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们正在运行的应用程序，我们再次有了按钮标题。
- en: 'Let''s finish this section by overriding the defaults, and supplying specific
    attributes for these captions in `App.tsx`, as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过覆盖默认值，并在`App.tsx`中提供这些标题的特定属性来完成本节：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our running app should now look like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在运行的应用程序现在应该看起来像下面这样：
- en: '![](assets/81002284-87f1-4fcd-9aa0-c6a345529b40.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81002284-87f1-4fcd-9aa0-c6a345529b40.png)'
- en: Optional props with default values can make components easier to consume, because
    the most common configurations can be automatically set up without needing to
    specify anything.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 具有默认值的可选props可以使组件更容易消耗，因为最常见的配置可以自动设置，而无需指定任何内容。
- en: So, our `Confirm` component is nice and flexible now, but the buttons don't
    do anything yet. We'll tackle this in the following sections.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Confirm`组件现在很灵活，但按钮还没有做任何事情。我们将在接下来的几节中解决这个问题。
- en: Handling class component events
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理类组件事件
- en: Events exist in many programming languages. They allow us to specify logic to
    be executed, depending on how a user interacts with our app.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 事件存在于许多编程语言中。它们允许我们指定逻辑，根据用户与我们的应用程序的交互方式执行。
- en: Basic event handlers
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本事件处理程序
- en: All the native JavaScript events are available for us to handle in JSX. JSX
    allows us to do this with props that call functions. The prop name is derived
    by prefixing the native event name with `on`, using camel case. So the prop name
    for the `click` event is `onClick` in JSX.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原生的JavaScript事件都可以在JSX中处理。JSX允许我们使用调用函数的props来做到这一点。prop名称是通过在原生事件名称前加上`on`并使用驼峰命名法来派生的。因此，在JSX中，`click`事件的prop名称是`onClick`。
- en: We can see a list of all the available events with their corresponding types
    in the `index.d.ts` file in the `node_modules/@types/react` folder.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`node_modules/@types/react`文件夹中的`index.d.ts`文件中看到所有可用事件及其相应类型的列表。
- en: 'We need to be able to control what the buttons do in our `Confirm` component.
    Follow these steps:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够控制我们的`Confirm`组件中按钮的行为。按照以下步骤进行：
- en: 'The first step is handling the `click` events on those buttons. Let''s set
    the `onClick` prop on the Okay button, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是处理这些按钮的`click`事件。让我们在确定按钮上设置`onClick`属性，如下所示：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, we're telling the button to call a `handleOkClick` method within our `Confirm`
    class when it is clicked.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们告诉按钮在被点击时调用`Confirm`类中的`handleOkClick`方法。
- en: 'Next, let''s create the `handleOkClick` method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`handleOkClick`方法：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Switch to the browser with our app running, and click the Yes please! button.
    If we look in the console, we should see Ok clicked displayed:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到运行我们应用的浏览器，并点击“是的，请！”按钮。如果我们查看控制台，应该会看到“Ok clicked”显示：
- en: '![](assets/b5435d53-febb-484b-9409-1fbc945b3d7e.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5435d53-febb-484b-9409-1fbc945b3d7e.png)'
- en: As we can see, it is pretty straightforward to handle events, using mechanisms
    we are already familiar with. There is actually a problem with our `handleOkClick` method,
    though. We'll drill into this and resolve the issue in the next section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用我们已经熟悉的机制处理事件非常简单。不过，我们的`handleOkClick`方法实际上存在问题。我们将在下一节详细讨论并解决这个问题。
- en: The this problem
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这个问题
- en: Our event handler suffers from JavaScript's classic `this` problem. We aren't
    currently referencing `this` in our event handler, which is why the problem hasn't
    surfaced yet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件处理程序遭受JavaScript经典的`this`问题。我们目前在事件处理程序中没有引用`this`，这就是为什么问题还没有浮出水面的原因。
- en: 'Let''s expose the problem with the `handleOkClick` method, so that we can better
    understand what''s happening:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暴露`handleOkClick`方法的问题，以便更好地理解发生了什么：
- en: 'Log the component props to the console:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件的props记录到控制台：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, try clicking the Yes please! button again. The following error appears:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试点击“是的，请！”按钮。将出现以下错误：
- en: '![](assets/573cb4bc-dcf4-4716-9c3e-11b7d91b21be.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/573cb4bc-dcf4-4716-9c3e-11b7d91b21be.png)'
- en: The problem is that `this` doesn't reference our class in the event handler—it
    is `undefined` instead.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`this`在事件处理程序中不引用我们的类，而是`undefined`。
- en: One solution is to change the `handleOkClick` method to be an arrow function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是将`handleOkClick`方法更改为箭头函数。
- en: Arrow function expressions have shorter syntax than function expressions. They
    also don't create their own `this`—so they are a great solution to the `this`
    problem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数表达式比函数表达式的语法更短。它们也不会创建自己的`this`，所以它们是解决`this`问题的一个很好的解决方案。
- en: 'Let''s convert our method to an arrow function, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们的方法转换为箭头函数，如下所示：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now try clicking the Yes please! button again. We should see props successfully
    output to the console.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次尝试点击“是的，请！”按钮。我们应该看到成功将props输出到控制台。
- en: 'Moving on, let''s implement a click handler on the Cancel button now. First,
    we need to reference a handler on the Cancel button''s `onClick` prop:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续，现在让我们在取消按钮上实现一个点击处理程序。首先，我们需要在`Cancel`按钮的`onClick`属性上引用一个处理程序：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we''ll create the `handleCancelClick` arrow function:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建`handleCancelClick`箭头函数：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: To summarize, in order to avoid the `this` problem, we can use arrow functions
    to implement event handlers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，为了避免`this`问题，我们可以使用箭头函数来实现事件处理程序。
- en: Next, we want the consumer of the component to be able to execute some logic
    when the buttons are clicked. We'll cover how to do this in the next section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望组件的使用者能够在按钮被点击时执行一些逻辑。我们将在下一节中介绍如何做到这一点。
- en: Function props
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数props
- en: In the previous section, we saw how props can be set for functions with our
    `onClick` event handlers. In this section, we'll implement our own function props,
    so that the consumer of our component can execute some logic when the Ok and Cancel
    buttons are pressed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何为具有我们的`onClick`事件处理程序的函数设置props。在本节中，我们将实现自己的函数props，以便我们组件的消费者在按下确定和取消按钮时可以执行一些逻辑。
- en: 'Let''s implement these two additional props on our interface. The function
    will take no parameters, and not return anything. So, the type is `() => void`,
    as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们的接口上实现这两个额外的props。该函数不接受任何参数，也不返回任何内容。因此，类型为`() => void`，如下所示：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The props are required, so, we immediately get a compilation error in `App.tsx`
    when we reference the `Confirm` component. We'll fix this a little later.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些props是必需的，所以当我们引用`Confirm`组件时，我们立即在`App.tsx`中得到编译错误。我们稍后会修复这个问题。
- en: 'Next, let''s invoke our function props when the buttons are clicked, instead
    of logging messages to the console:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在按钮被点击时调用我们的函数props，而不是将消息记录到控制台中：
- en: '[PRE62]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We''ll fix the compilation error now, by implementing arrow function handlers
    for these props in `App.tsx`. First let''s create the arrow function handlers:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将通过在`App.tsx`中实现箭头函数处理程序来修复编译错误。首先让我们创建箭头函数处理程序：
- en: '[PRE63]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we can reference these functions we where consume the `Confirm` component:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以引用这些函数，我们在其中使用`Confirm`组件：
- en: '[PRE64]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we go back to our app, we''ll see the compilation errors have been resolved.
    If we click the Ok and Cancel buttons, we get the message output to the console
    as expected:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的应用程序，我们会看到编译错误已经解决。如果我们单击确定和取消按钮，我们会得到预期的消息输出到控制台：
- en: '![](assets/2b7617e1-c796-4058-85fe-f780bbeac83d.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2b7617e1-c796-4058-85fe-f780bbeac83d.png)'
- en: At the moment, our buttons still don't do anything other than log a message
    to the console. We want the confirmation dialog to close when we click either
    button. We'll implement this in the next section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的按钮除了将消息记录到控制台外什么都不做。我们希望确认对话框在单击任一按钮时关闭。我们将在下一节中实现这一点。
- en: Class component states
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类组件状态
- en: State is an object that determines how the component behaves and renders. We
    need to introduce state into our app, in order to manage whether our confirmation
    dialog is open or closed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一个确定组件行为和渲染方式的对象。我们需要在我们的应用程序中引入状态，以便管理我们的确认对话框是打开还是关闭。
- en: This particular state is going to live and be managed within the `App` component,
    and be passed in as a prop to the `Confirm` component.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的状态将存在并由`App`组件中进行管理，并作为一个prop传递给`Confirm`组件。
- en: 'First, create an `open` prop in the `Confirm` component by adding it to its
    props interface:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Confirm`组件中创建一个`open`属性，将其添加到其props接口中：
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We're going to use the `open` prop in the `render` function to determine whether
    the dialog is visible or not. The `confirm-visible` CSS class makes the dialog visible.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`render`函数中使用`open`属性来确定对话框是否可见。`confirm-visible` CSS类使对话框可见。
- en: 'So, on the outermost `div`, let''s use a JavaScript ternary expression in the
    `className` attribute to only include `confirm-visible` when the `open` prop is
    `true`, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在最外层的`div`中，让我们在`className`属性中使用JavaScript三元表达式，只有在`open`属性为`true`时才包含`confirm-visible`，如下所示：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We now have a compilation error in `App.tsx` because we haven't specified the
    `open` attribute where we use `Confirm`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`App.tsx`中有一个编译错误，因为我们在使用`Confirm`时没有指定`open`属性。
- en: 'Before we start to create and manage state within `App.tsx`, let''s simply
    pass `false` in the `open` attribute in `Confirm`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始在`App.tsx`中创建和管理状态之前，让我们在`Confirm`中的`open`属性中简单地传递`false`：
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we look at the app in the browser now, the compilation error will have disappeared,
    and our confirmation dialog will be closed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在浏览器中查看应用程序，编译错误将消失，我们的确认对话框将关闭。
- en: Defining state type
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义状态类型
- en: 'Let''s create a state in `App.tsx`, and properly manage whether the confirmation
    dialog is open or closed:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`App.tsx`中创建一个状态，并正确地管理确认对话框是打开还是关闭：
- en: 'First, let''s create an interface for the state above the `App` class:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`App`类上面创建一个状态的接口：
- en: '[PRE68]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We then tell the `App` component about the state type, which we can do using
    the second generic parameter of `React.Component`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们告诉`App`组件关于状态类型，我们可以使用`React.Component`的第二个泛型参数来做到这一点：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We have used `{}` as the props type because there are no props for this component.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`{}`作为props类型，因为这个组件没有props。
- en: Initializing the state
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化状态
- en: Now that we have specified that our component has a state, we need to initialize
    it. We initialize component state in the class constructor.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了我们的组件有一个状态，我们需要初始化它。我们在类构造函数中初始化组件状态。
- en: 'Let''s create a constructor, and initialize the `confirmOpen` state to be `true`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个构造函数，并将`confirmOpen`状态初始化为`true`：
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We call `super` because our class extends `React.Component`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`super`因为我们的类扩展了`React.Component`。
- en: The state is held in a private prop in a component class. In the constructor,
    we can set the state to our required object literal, which in our case has `confirmOpen`
    set to `true`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 状态保存在组件类的私有属性中。在构造函数中，我们可以将状态设置为我们所需的对象字面量，我们的情况下`confirmOpen`设置为`true`。
- en: 'We can then use this state when we reference the `Confirm` component:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们引用`Confirm`组件时，我们可以使用这个状态：
- en: '[PRE71]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If we look at our running app, the confirmation dialog should be open again.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行的应用中查看，确认对话框应该再次打开。
- en: So, a private state prop gives us access to the component state, and we can
    initialize this in the class constructor.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，私有状态属性给了我们访问组件状态的权限，并且我们可以在类构造函数中初始化它。
- en: Changing state
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变状态
- en: When the confirmation dialog buttons are clicked, we want to close the dialog.
    So, we want to change the state of `confirmOpen` to be false when the buttons
    are clicked.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当确认对话框按钮被点击时，我们希望关闭对话框。因此，我们希望在按钮被点击时将`confirmOpen`的状态改为false。
- en: 'We already have arrow function handlers for the button click events, so perhaps
    we can change state in there:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了箭头函数处理按钮点击事件，也许我们可以在那里改变状态：
- en: 'Let''s try to do that in `handleOkConfirmClick`, replacing the `console.log`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在`handleOkConfirmClick`中做到这一点，替换`console.log`：
- en: '[PRE72]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We get a compilation error, as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个编译错误，如下所示：
- en: '![](assets/edfa879c-274c-4cb6-a891-5a01685fccf8.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edfa879c-274c-4cb6-a891-5a01685fccf8.png)'
- en: The error message is saying that the state is read-only! Why is this so, and
    how can we change the state?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息表明状态是只读的！为什么会这样，我们如何改变状态？
- en: We need to use a method called `setState` in the component class to change state.
    This helps ensure we manage state robustly and efficiently. `setState` takes a
    parameter, which is an object literal containing the state we want to change.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在组件类中使用一个叫做`setState`的方法来改变状态。这有助于确保我们稳健和高效地管理状态。`setState`接受一个参数，这个参数是一个包含我们想要改变的状态的对象字面量。
- en: 'Let''s change our code to use `setState`:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变我们的代码来使用`setState`：
- en: '[PRE73]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The compilation error disappears, and if we click Yes please! in the running
    app, the confirmation dialog will now close. We have successfully changed the
    state.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误消失了，如果我们在运行的应用中点击Yes please!，确认对话框现在将关闭。我们成功地改变了状态。
- en: 'Change the implementation of `handleCancelConfirmClick` to close the dialog
    as well:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变`handleCancelConfirmClick`的实现以关闭对话框：
- en: '[PRE74]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: After we close the confirmation dialog, we have no way to open it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭确认对话框之后，我们没有办法再次打开它。
- en: 'So, let''s add a button labeled Confirmthat does that in `App.tsx`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，让我们在`App.tsx`中添加一个名为Confirm的按钮：
- en: '[PRE75]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We need to create the handler that we just referenced:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建刚刚引用的处理程序：
- en: '[PRE76]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can now click the Confirm button to reopen the confirmation dialog when it
    has been closed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以点击确认按钮，在确认对话框关闭后重新打开它。
- en: 'Let''s add a piece of text above the Confirm button in `App.tsx` that changes
    depending on whether the confirmation dialog is canceled or okayed. We''ll define
    an additional state to drive this text:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`App.tsx`中的Confirm按钮上方添加一段文本，根据确认对话框是取消还是确认而变化。我们将定义一个额外的状态来驱动这段文本：
- en: '[PRE77]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, let''s initialize the message in the constructor:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在构造函数中初始化消息：
- en: '[PRE78]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The state is now changed when the confirmation dialog is okayed or canceled:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当确认对话框被确认或取消时，状态现在已经改变：
- en: '[PRE79]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we can render the message above the Confirm button:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在确认按钮上方呈现消息：
- en: '[PRE80]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If we play with the running app now, we'll see the message in our app changing
    depending on whether we okay or cancel the confirmation dialog.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们会看到应用程序中的消息根据我们确认或取消确认对话框而改变。
- en: Although we can set the state prop directly in the constructor when we initialize
    it, we can't elsewhere in a class component. Instead, state should be changed
    by calling the `setState` method in the component class.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在构造函数中直接设置状态属性，但在类组件的其他地方却不能。相反，状态应该通过在组件类中调用`setState`方法来改变。
- en: Class component life cycle methods
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类组件生命周期方法
- en: 'Life cycle methods in a class component allow us to run code at particular
    points in the process. The following is a high-level diagram of the component
    process, showing when the different methods are invoked:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件中的生命周期方法允许我们在过程中的特定点运行代码。以下是组件过程的高级图表，显示了不同方法何时被调用：
- en: '![](assets/2ecfe87e-38c2-4fd0-856e-a05ecd325e72.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2ecfe87e-38c2-4fd0-856e-a05ecd325e72.png)'
- en: Diagram of modern React life cycle methods, from React documentation
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现代React生命周期方法的图表，来自React文档
- en: componentDidMount
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: componentDidMount
- en: '`componentDidMount` is invoked when a component has been inserted into the
    DOM. Here are some common use cases for this method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount`在组件被插入DOM时被调用。以下是该方法的一些常见用例：'
- en: Calling a web service to get some data
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用web服务以获取一些数据
- en: Adding event listeners
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加事件监听器
- en: Initializing timers
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化计时器
- en: Initializing third-party libraries
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化第三方库
- en: 'We''re going to change the app we have been building to give users a time limit
    of 10 seconds to confirm whether or not they want to learn React and TypeScript.
    In order to do this, we''ll need to make use of the `componentDidMount` method:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改变我们一直在构建的应用程序，为用户提供10秒的时间来确认他们是否想要学习React和TypeScript。为了做到这一点，我们需要利用`componentDidMount`方法：
- en: 'Let''s start by making the confirmation dialog closed when the app loads in
    `App.tsx`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`App.tsx`中使确认对话框在应用程序加载时关闭：
- en: '[PRE81]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We''re going to count down the seconds from `10` to `0`, and then hide the
    Confirm button when `0` is reached. Let''s add and initialize a state for both
    of these in `App.tsx`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`10`开始倒计时到`0`，然后在达到`0`时隐藏确认按钮。让我们在`App.tsx`中添加和初始化这两个状态：
- en: '[PRE82]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We''ll use `timer` to count down from `10` to `1` in the `App` class. Let''s
    create a private prop called `timer` just above the constructor:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`App`类中使用`timer`从`10`倒数到`1`。让我们在构造函数上方创建一个名为`timer`的私有属性：
- en: '[PRE83]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s use the `componentDidMount` method to initialize our `timer`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`componentDidMount`方法来初始化我们的`timer`：
- en: '[PRE84]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The timer will call a method called `handleTimerTick` every second. Implement
    this method as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计时器将每秒调用一个名为`handleTimerTick`的方法。实现该方法如下：
- en: '[PRE85]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We are reducing our counter as well, updating the message shown to the user
    in this method. We need to do some more work here, though: we need to stop the
    timer, hide the Confirm button, and tell the user they are too late!'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在减少计数器，更新用户在此方法中显示的消息。但是，我们需要在这里做更多的工作：我们需要停止计时器，隐藏确认按钮，并告诉用户他们来得太迟了！
- en: 'Our natural instinct may be to write something like this:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的自然本能可能是写出这样的东西：
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: However, this is incorrect, because the state is updated asynchronously, and
    so `this.state.countDown` won't have necessarily updated the line after we update
    it in the `setState` call.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是不正确的，因为状态是异步更新的，所以在`setState`调用中更新后，`this.state.countDown`可能还没有更新下一行。
- en: 'Instead, we need to move this code to the callback in `setState`:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，我们需要将此代码移动到`setState`的回调中：
- en: '[PRE87]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let''s also stop the timer if the Confirm, Ok, or Cancel buttons are clicked:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果点击确认、确定或取消按钮，我们也要停止计时器：
- en: '[PRE88]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Our final job is to put a condition around the Confirm button to only show
    it if the `confirmVisible` state is `true`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一项工作是在确认按钮周围加上条件，只有在`confirmVisible`状态为`true`时才显示它：
- en: '[PRE89]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`x && y`allows us to concisely express a condition with a single branch in
    JSX. Basically, the right operand of `&&` isn''t evaluated and rendered if the
    left operand is falsy.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`x && y`允许我们用单个分支简洁地表达条件。基本上，如果左操作数为假，那么`&&`的右操作数不会被评估和渲染。'
- en: 'Now, it''s time to give this a try. We''ll see the countdown when the app first
    runs:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候试一试了。当应用程序首次运行时，我们会看到倒计时：
- en: '![](assets/da7cda2b-f66d-4351-b761-21a66c56db0d.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da7cda2b-f66d-4351-b761-21a66c56db0d.png)'
- en: 'If we don''t confirm within ten seconds, it''ll be too late:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在十秒内不确认，就太迟了：
- en: '![](assets/cd90782e-9f5a-46cc-ae72-2c1e55eb4a6d.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cd90782e-9f5a-46cc-ae72-2c1e55eb4a6d.png)'
- en: componentWillUnmount
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: componentWillUnmount
- en: '`componentWillUnmount` is invoked just before the component is removed from
    the DOM. Here are some common use cases for this method:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`在组件从DOM中移除之前被调用。以下是此方法的一些常见用例：'
- en: Removing event listeners
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除事件监听器
- en: Canceling active network requests
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消活动网络请求
- en: Removing timers
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除计时器
- en: 'We are going to use `componentWillUnmount` in our app to make sure our `timer`
    is stopped and removed. Let''s add the following in the `App` class after the
    `componentDidMount` method:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中使用`componentWillUnmount`来确保我们的`timer`被停止和移除。让我们在`componentDidMount`方法之后的`App`类中添加以下内容：
- en: '[PRE90]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: getDerivedStateFromProps
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从props获取派生状态
- en: '`getDerivedStateFromProps` is invoked every time a component is rendered. It
    can be used to change state when certain props change. This is a static method
    in a component class that returns the changed state, or null if there are no changes
    to the state.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDerivedStateFromProps`在每次组件渲染时被调用。它可以用于在某些props更改时更改状态。这是组件类中的静态方法，返回更改后的状态，如果状态没有更改则返回null。'
- en: 'Let''s have a look at this life cycle method in our app. Add the following
    at the top of the `App` class:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中查看这个生命周期方法。在`App`类的顶部添加以下内容：
- en: '[PRE91]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If we look in the console when the app is running, we see that our method is
    called each time the countdown decrements:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在应用程序运行时查看控制台，我们会发现我们的方法在倒计时递减时被调用：
- en: '![](assets/c6d95f4f-88ff-4fe5-ba0d-386d9009b0e8.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6d95f4f-88ff-4fe5-ba0d-386d9009b0e8.png)'
- en: getSnapshotBeforeUpdate and componentDidUpdate
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在更新之前获取快照和更新后获取快照
- en: '`getSnapshotBeforeUpdate` is called just before the DOM is updated. The value
    that is returned from `getSnapshotBeforeUpdate` is passed on to `componentDidUpdate`.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSnapshotBeforeUpdate`在更新DOM之前调用。从`getSnapshotBeforeUpdate`返回的值会传递给`componentDidUpdate`。'
- en: '`componentDidUpdate` is called as soon as the DOM is updated. Resizing the
    window during rendering is an example of when `getSnapshotBeforeUpdate` can be
    useful.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidUpdate`在DOM更新后立即被调用。在渲染期间调整窗口大小是`getSnapshotBeforeUpdate`有用的示例。'
- en: 'Let''s have a look at these life cycle methods in our app:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们应用中的这些生命周期方法：
- en: 'Let''s add the following near the top of the `App` class, under the `timer`
    variable declaration:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`App`类的顶部附近，在`timer`变量声明下面添加以下内容：
- en: '[PRE92]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, let''s add the life cycle methods:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加生命周期方法：
- en: '[PRE93]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Look at the running app:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 查看正在运行的应用程序：
- en: '![](assets/248117fa-5847-439f-aef2-ae492218628b.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/248117fa-5847-439f-aef2-ae492218628b.png)'
- en: We see the methods being invoked in the order we expect, and `componentDidUpdate`
    successfully taking in the render count from `getSnapshotBeforeUpdate`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到方法按照我们期望的顺序被调用，并且`componentDidUpdate`成功地从`getSnapshotBeforeUpdate`中获取了渲染计数。
- en: shouldComponentUpdate
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shouldComponentUpdate
- en: '`shouldComponentUpdate` is invoked just before rendering happens. It returns
    a Boolean value that determines whether rendering should happen. It can be used
    to optimize performance, preventing unnecessary render cycles.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`在渲染发生之前被调用。它返回一个布尔值，用于确定是否应该进行渲染。它可以用于优化性能，防止不必要的渲染周期。'
- en: 'Let''s have a look at this life cycle method in our app by adding the following
    method:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加以下方法来查看我们应用中的这个生命周期方法：
- en: '[PRE94]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If we look at the running app, we see that `shouldComponentUpdate` happens between `getDerivedStateFromProps`
    and `getSnapshotBeforeUpdate`, as we expect.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，我们会发现`shouldComponentUpdate`发生在`getDerivedStateFromProps`和`getSnapshotBeforeUpdate`之间，正如我们所期望的那样。
- en: 'Let''s now prevent rendering by returning `false`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过返回`false`来阻止渲染：
- en: '[PRE95]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We see `getSnapshotBeforeUpdate` and `componentDidUpdate` aren''t invoked,
    because no rendering occurs after the initial render:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`getSnapshotBeforeUpdate`和`componentDidUpdate`没有被调用，因为在初始渲染之后没有发生渲染：
- en: '![](assets/e807de25-6c9d-4cd8-823f-e3ce4f16362d.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e807de25-6c9d-4cd8-823f-e3ce4f16362d.png)'
- en: 'Before moving on to the next section, let''s allow our component to render
    again by setting this flag back to `true`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进入下一节之前，让我们通过将此标志设置回`true`来允许我们的组件再次渲染：
- en: '[PRE96]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`shouldComponentUpdate` can increase performance by stopping unnecessary rendering,
    but it should be used with care. It can introduce bugs that are hard to pin down. Also,
    the additional code we need to add to check whether a render should occur could
    in fact slow the app down.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`可以通过阻止不必要的渲染来提高性能，但应谨慎使用。它可能引入难以解决的错误。此外，我们需要添加的额外代码来检查是否应该进行渲染实际上可能会减慢应用程序的速度。'
- en: Deprecated life cycle methods
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已弃用的生命周期方法
- en: 'There are a few life cycle methods that have been deprecated and renamed in
    React 17\. We don''t need to use these anymore—`getDerivedStateFromProps` and `getSnapshotBeforeUpdate`
    essentially replaced them. However, here''s a brief description of these methods,
    in case you come across them in existing codebases:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在React 17中，有一些生命周期方法已被弃用并更名。我们不再需要使用这些方法——`getDerivedStateFromProps`和`getSnapshotBeforeUpdate`基本上取代了它们。然而，以下是这些方法的简要描述，以防您在现有代码库中遇到它们：
- en: '`componentWillMount` (now `UNSAFE_componentWillMount`): This is called before
    the component is added to the DOM during an initial render'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount`（现在是`UNSAFE_componentWillMount`）：在初始渲染期间，在组件被添加到DOM之前调用'
- en: '`componentWillReceiveProps` (now `UNSAFE_componentWillReceiveProps`): This
    is called when the component props change'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`（现在是`UNSAFE_componentWillReceiveProps`）：在组件属性更改时调用'
- en: '`componentWillUpdate` (now `UNSAFE_componentWillUpdate`): This is called just
    before a component updates'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`（现在是`UNSAFE_componentWillUpdate`）：在组件更新之前调用'
- en: Creating a function component
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数组件
- en: As the name suggests, a function component is implemented using a JavaScript
    function. These components are sometimes referred to as *functional stateless
    components*, which can be a little confusing because they can contain states in
    more recent versions of React.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，函数组件是使用JavaScript函数实现的。这些组件有时被称为*功能无状态组件*，这可能有点令人困惑，因为它们在React的较新版本中可以包含状态。
- en: Creating a basic function component
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的函数组件
- en: 'Let''s refactor our `Confirm` component to be a function component, in order
    to learn how to implement these:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的`Confirm`组件为一个函数组件，以学习如何实现这些：
- en: 'Open `Confirm.tsx` and replace the class signature with the following:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Confirm.tsx`并用以下内容替换类签名：
- en: '[PRE97]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We define a function component using an arrow function, passing the props type
    in as a generic parameter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用箭头函数来定义一个函数组件，将props类型作为泛型参数传递进去。
- en: We'll learn about generic functions later in the book—so don't worry if this
    doesn't make perfect sense right now.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面学习泛型函数，所以如果现在还不太明白，不用担心。
- en: We use **stateless functional component** (**SFC**) `React.SFC` to represent
    these type of components.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**无状态功能组件**（**SFC**）`React.SFC`来表示这些类型的组件。
- en: Our component is now throwing several compilation errors. We'll resolve these
    in the next steps.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件现在出现了几个编译错误。我们将在接下来的步骤中解决这些问题。
- en: 'Function components don''t have render methods. Instead, the function itself
    returns the JSX that should be rendered. So, let''s change this part of our function
    by removing the `render` signature, and leaving the return statement as it was:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数组件没有渲染方法。相反，函数本身返回应该被渲染的JSX。所以，让我们通过删除`render`签名来改变我们函数的这部分，并保留返回语句：
- en: '[PRE98]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We need to change the event handlers to be arrow function constants, and access
    props directly rather than through `this`. We should also move these handlers
    above the `return` statement:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将事件处理程序更改为箭头函数常量，并直接访问props，而不是通过`this`。我们还应该将这些处理程序移到`return`语句之上：
- en: '[PRE99]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We then reference the props and event handlers directly, rather than through
    `this` in our JSX:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们直接引用props和事件处理程序，而不是通过`this`在我们的JSX中：
- en: '[PRE100]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We also have a problem with the static `defaultProps` variable. We move this
    outside our function, and place it as an object literal under the function, as
    follows:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个关于静态`defaultProps`变量的问题。我们将这个移出我们的函数，并将其放在函数下面的对象文字中，如下所示：
- en: '[PRE101]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: If we look at the running app, all the compilation errors should be resolved,
    and the app should be working as it was before.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，所有的编译错误应该都已经解决了，应用程序应该像以前一样工作。
- en: 'The following code is a template for a function component. Our `Confirm` component
    should have a structure similar to this now:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个函数组件的模板。我们的`Confirm`组件现在应该有类似于这样的结构：
- en: '[PRE102]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: So, function components are an alternative way to create components. In the
    next section, we'll look at how to add state to a function component.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数组件是创建组件的另一种方式。在下一节中，我们将看看如何向函数组件添加状态。
- en: Stateful function components
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态的函数组件
- en: 'We''ve mentioned that function components can have state. In this section,
    we''ll add state to our function `Confirm` component, to force users to click
    the Cancel button twice before closing it, as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到函数组件可以有状态。在本节中，我们将向我们的函数`Confirm`组件添加状态，以强制用户在关闭之前点击取消按钮两次，如下所示：
- en: 'We''ll start by defining and initializing state for the number of times the
    Cancel button is clicked, by adding the highlighted line:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先通过添加下面突出显示的行来定义和初始化取消按钮被点击的次数状态：
- en: '[PRE103]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This line of code looks a little strange, so let''s break it down:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码看起来有点奇怪，让我们来分解一下：
- en: '`React.useState` is a React function that lets us create state, passing in
    a default value as a parameter. In our case, we pass it a default value of 0.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.useState`是一个React函数，它让我们创建状态，将默认值作为参数传递。在我们的例子中，我们将其传递一个默认值为0。'
- en: 'The `useState` function returns an array containing two elements:'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`函数返回一个包含两个元素的数组：'
- en: The first array element contains the current value of state
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数组元素包含状态的当前值
- en: The second array element contains a function to set state to a different value
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数组元素包含将状态设置为不同值的函数。
- en: We destructure the array and store the first array element (the state value)
    in `cancelClickCount`, and the second array element (the function to set state)
    in `setCancelClickCount`.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解构数组并将第一个数组元素（状态值）存储在`cancelClickCount`中，将第二个数组元素（设置状态的函数）存储在`setCancelClickCount`中。
- en: The rest of the function now has access to the cancel click count, via the `cancelClickCount`
    variable. The function is also able to increment the cancel click count, via the `setCancelClickCount`
    variable.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的其余部分现在可以通过`cancelClickCount`变量访问取消点击计数。该函数还能够通过`setCancelClickCount`变量增加取消点击计数。
- en: 'Let''s refactor the `handleCancelClick` arrow function to increment `cancelClickCount`,
    and only invoke the `onCancelClick` prop if the count has reached `2`:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重构`handleCancelClick`箭头函数以增加`cancelClickCount`，并且只在计数达到`2`时调用`onCancelClick`属性：
- en: '[PRE104]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Now, functions to set the piece of state take in the new state as their parameter.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置状态的函数将新状态作为其参数。
- en: 'Next, we''ll change the Cancel button caption, to say Really? after the first
    click:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更改取消按钮的标题，在第一次点击后显示"真的吗？"：
- en: '[PRE105]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: So, we access the state value in JSX through the variable we destructured when the
    state was defined.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过在定义状态时解构的变量在JSX中访问状态值。
- en: If we give this a try in the running app, we should find the Cancel button text
    changes to Really? after the first click, and the confirmation dialog closes after
    the second click.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行的应用程序中尝试这样做，我们应该会发现取消按钮文本在第一次点击后更改为"真的吗？"，并且确认对话框在第二次点击后关闭。
- en: After we've got our heads around the code needed to define state, accessing
    and setting state is fairly simple and elegant.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解了定义状态所需的代码之后，访问和设置状态就变得非常简单和优雅。
- en: Let's continue to the next section, and look into how we can hook into a function
    component's life cycle events.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一部分，并了解如何钩入函数组件的生命周期事件。
- en: Function component life cycle hooks
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组件生命周期钩子
- en: 'We can invoke code to execute at certain points in a function component''s
    life cycle. Let''s explore this in our `Confirm` component, starting with when
    the component is first rendering, as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数组件的生命周期的某些时刻调用代码。让我们从`Confirm`组件开始探索这一点，从组件首次渲染开始，如下所示：
- en: 'Let''s add the highlighted lines of code just beneath where we define state:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在定义状态的下面添加高亮显示的代码行：
- en: '[PRE106]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We use React's `useEffect` function to hook into the component life cycle.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用React的`useEffect`函数来钩入组件的生命周期。
- en: The function takes in an arrow function, which executes when the component is
    first rendered.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数接受一个箭头函数，当组件首次渲染时执行。
- en: The function takes in a second parameter, which determines when our arrow function
    is called. This parameter is an array of values that, when changed, will cause
    the arrow function to be invoked. In our case, we pass in an empty array, so our
    arrow function will never be called after the first render.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数接受第二个参数，确定何时调用我们的箭头函数。该参数是一个值的数组，当更改时，将调用箭头函数。在我们的例子中，我们传入一个空数组，因此我们的箭头函数在第一次渲染后永远不会被调用。
- en: If we now try the running app and open the console, we'll see Confirm first
    rendering only appears once.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行应用程序并打开控制台，我们会看到确认第一次渲染只出现一次。
- en: 'Let''s remove the second parameter into `useEffect` now:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`useEffect`的第二个参数移除：
- en: '[PRE107]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If we look at the running app and the console, we'll see Confirm rendering appear
    each time `Confirm` is rendered.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看运行中的应用程序和控制台，我们会看到每次`Confirm`被渲染时都会出现`确认渲染`。
- en: 'Let''s change this once again to the following:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次将其更改为以下内容：
- en: '[PRE108]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If we look at the running app and the console, we'll see open changed appear
    each time the `Confirm` component's `open` prop changes value.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看运行中的应用程序和控制台，我们会看到每次`Confirm`组件的`open`属性值发生变化时都会出现`open changed`。
- en: 'What about hooking into when a component is unmounted? Let''s try the following:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么如何在组件卸载时进行挂钩呢？让我们尝试以下内容：
- en: '[PRE109]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: So, our arrow function can return a function that is executed when the component
    is unmounted.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的箭头函数可以返回一个在组件卸载时执行的函数。
- en: 'Our `Confirm` component doesn''t currently unmount, so, in `App.tsx`, let''s
    make this not render if the countdown reaches `0`:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Confirm`组件目前不会卸载，因此在`App.tsx`中，让我们在倒计时达到`0`时不再渲染它：
- en: '[PRE110]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: If we look at the running app and the console, we'll see `Confirm unmounted` appear
    when the countdown reaches `0`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看运行中的应用程序和控制台，当倒计时达到`0`时，我们会看到`确认卸载`出现。
- en: So, we can execute logic in function components when they are first rendered,
    when their props change, and when they are unmounted.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当函数组件首次渲染、当它们的props改变以及当它们被卸载时，我们可以执行逻辑。
- en: In the next section, we'll look at a method we can use to optimize function
    component rendering cycles.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一种可以用来优化函数组件渲染周期的方法。
- en: This section on hooks is written on React v16.6.0\. We will share updated codes
    when new version releases.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于hooks的内容是基于React v16.6.0编写的。当新版本发布时，我们将分享更新的代码。
- en: Optimizing function component rendering
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化函数组件渲染
- en: 'Our `Confirm` component is actually being rendered more than it needs to be.
    In this section, we are going to optimize this so that it only renders when its
    props change:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Confirm`组件实际上被渲染得比它需要的更多。在本节中，我们将对此进行优化，以便它仅在其props发生变化时才进行渲染：
- en: 'First, let''s add a line at the top of our function component, so that we can
    see when it renders:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在函数组件的顶部添加一行，这样我们就可以看到它何时被渲染：
- en: '[PRE111]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: If we look at the running app and the console, we'll see that a render occurs
    every time the `App` component counts down. The countdown is in the `App` component
    state, and a change to state means the component will be rendered again, along
    with any child components. This is why, without any optimization, our `Confirm`
    component renders on each countdown.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看运行中的应用程序和控制台，我们会看到每次`App`组件倒计时时都会发生渲染。倒计时是在`App`组件状态中的，状态的改变意味着组件将被重新渲染，以及任何子组件。这就是为什么，没有任何优化的情况下，我们的`Confirm`组件在每次倒计时时都会被渲染。
- en: 'On to the optimization then. It''s actually really simple:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是优化。实际上非常简单：
- en: '[PRE112]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: So, we wrap our component with a function called `memo` from React. We then
    export this wrapper function. The `memo` function then only renders the component
    if its props change.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们用来自React的`memo`函数包装我们的组件。然后导出这个包装函数。`memo`函数只在组件的props发生变化时才会渲染组件。
- en: If we look at the running app and the console, we'll see that our component
    no longer renders on each countdown.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看运行中的应用程序和控制台，我们会看到我们的组件不再在每次倒计时时被渲染。
- en: So, given how simple this is, shouldn't we just wrap all our function components
    with `memo`? No! There is a performance cost when `memo` determines whether a
    component has changed. If the component doesn't actually do any unnecessary rendering,
    using `memo` would result in the component being slower.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这是多么简单，我们是否应该用`memo`包装所有的函数组件呢？不！当`memo`确定组件是否发生变化时，会有性能成本。如果组件实际上没有进行任何不必要的渲染，使用`memo`会导致组件变慢。
- en: '`memo` should be used with care, and only on components that are being rendered
    more than they need to be.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo`应该谨慎使用，只用于需要多次渲染的组件。'
- en: Given that the features of class components and function components are similar,
    which type should we be using? There is no straightforward answer, really. If
    our team is used to object-oriented code, perhaps class-based components will
    be easier to learn. If our team is used to more functional programming techniques,
    then function-based components may enable them to be more productive.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于类组件和函数组件的特性相似，我们应该使用哪种类型？实际上并没有直接的答案。如果我们的团队习惯于面向对象的代码，也许基于类的组件会更容易学习。如果我们的团队习惯于更多的函数式编程技术，那么基于函数的组件可能会使他们更加高效。
- en: Both approaches are great ways to create React components—it's down to you to
    choose!
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是创建React组件的好方法——选择权在你手中！
- en: Summary
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we learned a couple of different ways we can create a React
    and TypeScript project. The more manual way taught us just how many moving parts
    there are. We'll use `create-react-app` regularly to quickly create our apps in
    this book.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了几种不同的方法来创建React和TypeScript项目。更加手动的方法教会了我们有多少个组成部分。在本书中，我们将经常使用`create-react-app`来快速创建我们的应用程序。
- en: We learned how all React class components have a `render` method that returns
    JSX, which tells React what to display. JSX is very flexible and powerful, because
    JavaScript expressions can be mixed in with HTML.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了所有的React类组件都有一个返回JSX的`render`方法，告诉React要显示什么。JSX非常灵活和强大，因为JavaScript表达式可以与HTML混合在一起。
- en: We learned how components can be configured using props, and how we can add
    TypeScript types to props, to help prevent mistakes when consuming components.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用props配置组件，以及如何向props添加TypeScript类型，以帮助在使用组件时防止错误。
- en: Next, we learnt how components manage what is rendered and how they behave using
    state. Like props, state in a React and TypeScript app is strongly typed. We initialize
    state in the constructor, and change it via a `setState` method.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了组件如何管理渲染的内容以及它们如何使用状态。与props一样，在React和TypeScript应用程序中，状态是强类型的。我们在构造函数中初始化状态，并通过`setState`方法进行更改。
- en: We also learnt about event handlers, which allow us to react to how users interact
    with our components. JSX gives us handy `onEventName` attributes for handling
    events.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了事件处理程序，它们允许我们对用户与我们的组件的交互做出反应。JSX为我们提供了方便的`onEventName`属性来处理事件。
- en: Next, we learnt about the various life cycle methods that can be implemented
    to execute logic at various points in the process. The most commonly used life
    cycle method is `componentDidMount` , which occurs when a component has just been
    added to the DOM.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了可以实现的各种生命周期方法，以在过程的各个阶段执行逻辑。最常用的生命周期方法是`componentDidMount`，它在组件刚刚添加到DOM时发生。
- en: Finally, we learned about function components, which are an alternative approach
    to implementing components. In recent versions of React, we are able to use state
    within them, access common life cycle hooks, and even optimize rendering cycles.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了函数组件，这是一种实现组件的替代方法。在React的最新版本中，我们可以在其中使用状态，访问常见的生命周期钩子，甚至优化渲染周期。
- en: In [Chapter 3](6938e951-47cf-4751-9cfc-c5afcdd73c9e.xhtml), *Getting Started
    with React and TypeScript*, we will learn about how we can efficiently build React
    and TypeScript apps that have multiple pages.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](6938e951-47cf-4751-9cfc-c5afcdd73c9e.xhtml)中，*开始使用React和TypeScript*，我们将学习如何高效地构建具有多个页面的React和TypeScript应用程序。
- en: Questions
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions, based on what we have just learned:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚刚学到的知识，回答以下问题：
- en: During development, what are the TSLint settings for allowing debugger statements
    and logging to the console?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发过程中，允许调试器语句和向控制台输出日志的TSLint设置是什么？
- en: In JSX, how can we display a button with a label from a prop called `buttonLabel`
    in a class component?
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX中，我们如何在类组件中显示一个带有来自名为`buttonLabel`的prop的标签的按钮？
- en: How can we make the `buttonLabel` prop optional, and default to Do It?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使`buttonLabel` prop成为可选的，并默认为Do It？
- en: In JSX, how can we display this button only if the `doItVisible` state is `true`?
    (Assume we already have a state type declared containing `doItVisible`, and it
    has already been initialized in the constructor.)
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX中，我们如何只在`doItVisible`状态为`true`时显示这个按钮？（假设我们已经声明了一个包含`doItVisible`的状态类型，并且它已经在构造函数中初始化。）
- en: How would we create a click handler for this button?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为这个按钮创建一个点击处理程序？
- en: We have a state type declared containing `doItDisabled`. It has also been initialized in
    the constructor. How would we set this state to disable the Do it button after
    we click it?
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个包含`doItDisabled`的状态类型。它也已经在构造函数中初始化。我们如何在点击后将这个状态设置为禁用Do it按钮？
- en: If the button is clicked when it is in a disabled state, is the click handler
    still executed?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按钮在禁用状态下被点击，点击处理程序是否仍然被执行？
- en: What life cycle method would we use in a class component to add event handlers
    to a non-React web component living in our React component?
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类组件中，我们将使用哪个生命周期方法来向我们的React组件中的非React网络组件添加事件处理程序？
- en: Which life cycle method would we use to remove this event handler?
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用哪个生命周期方法来移除这个事件处理程序？
- en: We have a function component called `Counter`. It needs to contain a piece of
    state called `count`, and a function to update it called `setCount`. How can we
    define this state and default the initial count to 10?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个名为`Counter`的函数组件。它需要包含一个名为`count`的状态片段，以及一个用于更新它的函数`setCount`。我们如何定义这个状态并将初始计数默认为10？
- en: In the preceding `Counter` component, we have a `decrement` function that needs
    to reduce `count` by `1`.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的`Counter`组件中，我们有一个需要将`count`减少1的`decrement`函数。
- en: '[PRE113]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How can this be implemented?
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何实现？
- en: Further reading
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official React introduction tutorial is worth going through: [https://reactjs.org/tutorial/tutorial.html](https://reactjs.org/tutorial/tutorial.html)'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的React入门教程值得一读：[https://reactjs.org/tutorial/tutorial.html](https://reactjs.org/tutorial/tutorial.html)
- en: The `create-react-app` documentation is also worth bookmarking: [https://facebook.github.io/create-react-app/docs/getting-started](https://facebook.github.io/create-react-app/docs/getting-started)
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create-react-app`文档也值得收藏：[https://facebook.github.io/create-react-app/docs/getting-started](https://facebook.github.io/create-react-app/docs/getting-started)'
