- en: Streamlining Development and Refactoring with Type-Safe React Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型安全简化开发和重构React组件
- en: 'The tool of focus in this chapter is Flow, a static type checker for JavaScript
    applications. The scope of Flow and what you can do with it is enormous, so I''ll
    be introducing Flow in the context of a tool that''s used to make React components
    better. In this chapter, you''ll learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍的工具是Flow，它是JavaScript应用程序的静态类型检查器。Flow的范围和你可以用它做的事情是巨大的，所以我将在引入Flow的上下文中介绍它，这是一个用于改进React组件的工具。在本章中，你将学到以下内容：
- en: The problems that are solved by introducing type-safety into your React application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引入类型安全解决的问题
- en: Enabling Flow in your React projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的React项目中启用Flow
- en: Using Flow to validate your React components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flow验证你的React组件
- en: Other ways to enhance React development using type-safety
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型安全增强React开发的其他方法
- en: What does type-safety solve?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型安全解决了什么问题？
- en: Type-safety is no silver bullet. For example, I'm perfectly capable of writing
    a type-safe application that's riddled with bugs. It's the kind of bugs that just
    sort of stop happening after a type-checker is introduced that are interesting.
    So what types of things can you expect after introducing a tool like Flow? I'll
    share three factors that I've experienced while learning Flow. The *Type System*
    section in the Flow docs goes into much more detail on this topic, available at [https://flow.org/en/docs/lang/](https://flow.org/en/docs/lang/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全并非万能药。例如，我完全有能力编写一个充满错误的类型安全应用程序。有趣的是，只是在引入类型检查器后，那种停止发生的错误。那么在引入Flow这样的工具后，你可以期待什么类型的事情？我将分享我在学习Flow时经历的三个因素。Flow文档中的*类型系统*部分对这个主题进行了更详细的介绍，可在[https://flow.org/en/docs/lang/](https://flow.org/en/docs/lang/)上找到。
- en: Replacing guesswork with assurance
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用保证替换猜测
- en: One of the nice features of a dynamically-typed language like JavaScript is
    that you can write code without having to think about types. Types are good and
    they do solve a lot of problems—the point I'm trying to make, believe it or not—but
    sometimes you need to be able to just write code without having to formally validate
    for correctness. In other words, sometimes guesswork is exactly what you need.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript这样的动态类型语言的一个很好的特性是，你可以编写代码而不必考虑类型。类型是好的，它们确实解决了很多问题——你可能不相信，但有时你需要能够只是编写代码而不必正式验证正确性。换句话说，有时候猜测恰恰是你需要的。
- en: If I'm writing a function that I know takes an object as an argument, I can
    just assume that any object that's passed to my function will have the expected
    properties. This allows me to implement what I need to, without having to make
    sure that the correct types are passed as arguments. This will only work for so
    long, though. Because invariably, your code will get something unexpected passed
    to it as input. Once you have a complex application with many moving parts, type-safety
    can remove the guesswork.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我正在编写一个我知道接受一个对象作为参数的函数，我可以假设传递给我的函数的任何对象都将具有预期的属性。这使我能够实现我需要的东西，而不必确保正确的类型作为参数传递。然而，这种方法只能持续那么长时间。因为不可避免地，你的代码将会得到一些意外的输入。一旦你有了一个由许多组成部分组成的复杂应用程序，类型安全可以消除猜测。
- en: Flow takes an interesting approach. Instead of compiling new JavaScript code
    based on types, it simply checks that the source is correct based on type annotations.
    These annotations are then removed from the source so that it can run. By using
    a type checker like Flow, you can be explicit about what each of your components
    is willing to accept as input, and how it iterates with the rest of the application
    by using type annotations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Flow采取了一种有趣的方法。它不是基于类型编译新的JavaScript代码，而是简单地根据类型注释检查源代码是否正确。然后将这些注释从源代码中移除，以便可以运行。通过使用Flow这样的类型检查器，你可以明确地指定每个组件愿意接受的输入，并通过使用类型注释来说明它与应用程序的其他部分是如何交互的。
- en: Removing runtime checks
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除运行时检查
- en: The solution to handling data with unknown types in dynamic languages such as
    JavaScript is to check values at runtime. Depending on the type of value, you
    might have to perform some alternate action to get the value that your code is
    expecting. For example, a common idiom in JavaScript is to make sure that a value
    is neither undefined or null. If it is, then we either throw an error or provide
    a default value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如JavaScript之类的动态语言中处理未知类型的数据的解决方案是在运行时检查值。根据值的类型，你可能需要执行一些替代操作来获取你的代码所期望的值。例如，在JavaScript中的一个常见习惯是确保一个值既不是undefined也不是null。如果是，那么我们要么抛出一个错误，要么提供一个默认值。
- en: When you perform runtime checks, it changes the way you think about your code.
    Once you start performing these checks, they inevitably evolve into more elaborate
    checks and more of them. This frame of mind really amounts to not trusting yourself
    or others to call code with the correct data. You think since it's likely that
    your function will be called with junk arguments, you need to be ready to handle
    anything that is thrown at your function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行运行时检查时，它会改变你对代码的思考方式。一旦你开始执行这些检查，它们不可避免地会演变成更复杂的检查和更多的检查。这种思维方式实际上意味着不相信自己或他人能够使用正确的数据调用代码。你会认为，由于很可能你的函数会被用垃圾参数调用，你需要准备好处理任何被传递给你的函数的东西。
- en: On the other hand, embracing type-safety means that you don't have to rely on
    implementing custom solutions to defend against bad data. Let the type system
    handle this for you instead. You just need to think about what types your code
    needs to work with, and go from there. Think what does my code need, not how do
    I get what my code needs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，拥抱类型安全意味着你不必依赖于实现自定义解决方案来防御错误数据。让类型系统来代替你处理这个问题。你只需要考虑你的代码需要处理什么类型的数据，然后从那里开始。思考我的代码需要什么，而不是如何获得我的代码需要的东西。
- en: Obvious low-severity bugs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明显的低严重性错误
- en: If you can use a type checker such as Flow to remove the insidious errors that
    creep up on you as a result of bad types, you're left with high-level application
    bugs. These bugs are obvious when they happen because the application is simply
    wrong. It produces the wrong output, it computes the wrong number, one of the
    screens doesn't load, and so on. You can more easily see and interact with these
    kinds of bugs. This makes them obvious, and when bugs are obvious, they're easier
    to track down and fix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以使用诸如Flow之类的类型检查器来消除由于错误类型而产生的隐匿错误，那么你将只剩下高级别的应用程序错误。当这些错误发生时，它们是显而易见的，因为应用程序是错误的。它产生了错误的输出，计算出了错误的数字，其中一个屏幕无法加载，等等。你可以更容易地看到并与这些类型的错误进行交互。这使它们变得显而易见，而当错误显而易见时，它们更容易被追踪和修复。
- en: On the other hand, you have bugs that are subtly wrong. These can result from
    bad types. What makes these types of bugs particularly horrifying is that you
    don't even know something is wrong. Something with your application could be slightly
    off. Or it could be outright broken because part of your code is expecting an
    array, but it sort of works because it's getting another kind of iterable that
    works in one place but not in others.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可能会遇到微妙错误的错误。这些可能是由于错误的类型。这些类型的错误特别可怕的原因是您甚至不知道出了什么问题。您的应用程序可能有些微妙的问题。或者它可能完全崩溃，因为您的代码的一部分期望一个数组，但它在某些地方可以工作，因为它得到了另一种可迭代的东西，但在其他地方却不行。
- en: If you had just used type annotations and checked your source with Flow, it
    would have told you that you're passing something that isn't an array. There's
    no room for these types of errors when types are statically checked. It turns
    out that these are usually the more difficult bugs to figure out.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是使用类型注释并使用Flow检查了您的源代码，它会告诉您正在传递的不是数组。当类型静态检查时，这些类型的错误就没有了容身之地。原来，这些通常是更难解决的错误。
- en: Installing and initializing Flow
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和初始化Flow
- en: Before you can start implementing type-safe React components, you need to install
    and initialize Flow. I'll show you how this is done with a `create-react-app`
    environment, but the same steps can be followed for almost any React environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始实现类型安全的React组件之前，您需要安装和初始化Flow。我将向您展示如何在`create-react-app`环境中完成此操作，但几乎可以为几乎任何React环境遵循相同的步骤。
- en: You can install Flow globally, but I would recommend installing it locally,
    along with all the other packages that your project depends on. Unless there's
    a good reason to install something globally, install it locally. This way, anyone
    installing your application can get every dependency by running `npm install`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以全局安装Flow，但我建议将其与项目依赖的所有其他软件包一起本地安装。除非有充分的理由全局安装某些东西，否则请将其本地安装。这样，安装您的应用程序的任何人都可以通过运行`npm
    install`来获取每个依赖项。
- en: 'To install Flow locally, run the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地安装Flow，请运行以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will install the Flow executable locally to your project and will update
    your `package.json` so that Flow is installed as a dependency of your project.
    Now let''s add a new command to `package.json` so that you can run the Flow type
    checker against your source code. Make the `scripts` section look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地安装Flow可执行文件到您的项目，并将更新您的`package.json`，以便Flow作为项目的依赖项安装。现在让我们向`package.json`添加一个新的命令，以便您可以针对您的源代码运行Flow类型检查器。使`scripts`部分看起来像这样：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now you can run Flow by executing the following command in your Terminal:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过在终端中执行以下命令来运行Flow：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will run the `flow` script as expected, but Flow will complain about not
    being able to find a Flow configuration file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按预期运行`flow`脚本，但Flow将抱怨找不到Flow配置文件：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The easiest way to resolve this issue is to use the `flow init` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的最简单方法是使用`flow init`命令：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will create a `.flowconfig` file in your project directory. You don''t
    need to worry about changing anything in this file right now; it''s just that
    Flow expects it to be present. Now when you run `npm run flow`, you should get
    a message that indicates there are no errors:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的项目目录中创建一个`.flowconfig`文件。您现在不需要担心更改此文件中的任何内容；只是Flow希望它存在。现在当您运行`npm run
    flow`时，您应该会收到一条指示没有错误的消息：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It turns out that none of your source files were actually checked. This is
    because by default, Flow only checks files that have the `// @flow` directive
    as their first line. Let''s go ahead and add this line at the top of `App.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原来，实际上没有检查您的任何源文件。这是因为默认情况下，Flow只检查具有`// @flow`指令作为其第一行的文件。让我们继续在`App.js`的顶部添加这一行：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that Flow is checking this module, we''re getting an error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Flow正在检查这个模块，我们得到了一个错误：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What does this mean? Flow attempts to provide an explanation on the next line
    of the error output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？Flow试图在错误输出的下一行提供解释：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Flow is complaining about the `Component` class that you''re extending with
    `App`. This means that you need to provide at least one `type` argument to `Component`
    for props. Since `App` isn''t actually using any props, this could just be an
    empty type for now:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Flow抱怨你正在用`App`扩展的`Component`类。这意味着你需要为`Component`提供至少一个`type`参数来表示props。由于`App`实际上并没有使用任何props，现在可以暂时使用一个空类型：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now when you run Flow again, there aren't any errors in `App.js`! This means
    that you've successfully annotated your module with type information that Flow
    used to statically analyze your source to make sure everything is sound.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你再次运行Flow时，在`App.js`中就没有任何错误了！这意味着你已经成功地用类型信息注释了你的模块，Flow用它来静态分析你的源代码，确保一切都是正确的。
- en: So how did Flow know what the `Component` class from React was expecting in
    terms of its generics? It turns out that React is itself Flow type-annotated,
    and this is how you get specific error messages when Flow detects a problem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么Flow是如何知道React的`Component`类在泛型方面期望什么的呢？事实证明，React本身是Flow类型注释的，这就是当Flow检测到问题时你会得到具体错误消息的原因。
- en: 'Next, let''s add the `// @flow` directive to the top of `index.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`index.js`的顶部添加`// @flow`指令：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run `npm run flow` again, you''ll see the following error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行`npm run flow`，你会看到以下错误：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is because the value of `root` comes from `document.getElementById(''root'')`.
    Since there''s no DOM for this method to return an element, Flow detects a `null`
    value and complains. Since this is a legitimate concern (the `root` element might
    not be there) and we need path for Flow to follow when there''s no element, you
    can add some logic to handle this case:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`root`的值来自`document.getElementById('root')`。由于这个方法没有返回元素的DOM，Flow检测到一个`null`值并抱怨。由于这是一个合理的担忧（`root`元素可能不存在），我们需要在没有元素时为Flow提供路径，你可以添加一些逻辑来处理这种情况：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before calling `ReactDOM.render()`, you can manually check the type of `root`
    to make sure that it's what Flow expects to see. Now when you run `npm run flow`,
    there are no errors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`ReactDOM.render()`之前，你可以手动检查`root`的类型，以确保它是Flow期望看到的类型。现在当你运行`npm run flow`时，就不会有错误了。
- en: You're all set! You have Flow installed and configured locally, and you have
    the initial source from `create-react-app` passing the type check. You can now
    proceed to develop type-safe React components.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了！你已经在本地安装和配置了Flow，并且`create-react-app`的初始源已经通过了类型检查。现在你可以继续开发类型安全的React组件了。
- en: Validating component properties and state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证组件属性和状态
- en: React was designed with Flow static type-checking in mind. The most common use
    of Flow in React applications is to validate that component properties and state
    are being used correctly. You can also enforce the types of components that are
    allowed as children of another component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: React设计时考虑了Flow静态类型检查。在React应用程序中，Flow最常见的用途是验证组件属性和状态是否被正确使用。你还可以强制执行作为另一个组件子元素的组件的类型。
- en: Prior to Flow, React would rely on the prop-types mechanism to validate values
    passed to components. This is now a separate package from React and you can still
    use it today. Flow is a superior choice over prop-types because it performs checks
    statically whereas prop-types performs runtime validation. This means that your
    application doesn't need to run superfluous code during runtime.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flow之前，React依赖于prop-types机制来验证传递给组件的值。现在这是React的一个单独包，你仍然可以使用它。Flow比prop-types更优秀，因为它执行静态检查，而prop-types执行运行时验证。这意味着你的应用程序在运行时不需要运行多余的代码。
- en: Primitive property values
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始属性值
- en: The most common types of values that are passed to components via props are
    primitive values—strings, numbers, and Booleans for example. Using Flow, you can
    declare your own type that says which primitive values are allowed for a given
    property.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过props传递给组件的最常见的值类型是原始值——例如字符串、数字和布尔值。使用Flow，您可以声明自己的类型，指定给定属性允许哪些原始值。
- en: 'Let''s take a look at an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This component renders the name and version of some app. These values are passed
    in through property values. For this component, let''s say that you only want
    string values for the `name` property and number values for the `version` property.
    This module declares a new `Props` type, using the `type` keyword:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件渲染了一些应用程序的名称和版本。这些值是通过属性值传递的。对于这个组件，让我们说您只想要`name`属性的字符串值和`version`属性的数字值。这个模块使用`type`关键字声明了一个新的`Props`类型：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This Flow syntax allows you to create new types that can then be used to type
    function arguments. In this case, you have a functional React component where
    the props are passed as the first argument. This is where you tell Flow that the
    props object should have a specific type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Flow语法允许您创建新类型，然后可以用来对函数参数进行类型化。在这种情况下，您有一个功能性的React组件，其中props作为第一个参数传递。这是告诉Flow，props对象应该具有特定类型的地方：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this in place, Flow can figure out if there's any places where we're passing
    invalid prop types to this component! Even better, this is done statically, before
    anything runs in the browser. Before Flow, you would have to use the `prop-types`
    package to validate component props during runtime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，Flow可以找出我们传递无效的属性类型到这个组件的任何地方！更好的是，这是在静态地完成的，在浏览器中运行任何东西之前。在Flow之前，您必须使用`prop-types`包在运行时验证组件属性。
- en: 'Let''s put this component to use, and then we''ll run Flow. Here''s `App.js`
    using the `Intro` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个组件，然后我们将运行Flow。这是`App.js`使用`Intro`组件：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The property values that are passed to `Intro` meet the expectations of the
    `Props` type:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Intro`的属性值符合`Props`类型的期望：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can validate this by running `npm run flow`. You should see `No errors!`
    as the output. Let''s see what happens if we change the type of these properties:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`npm run flow`来验证这一点。您应该会看到`没有错误！`作为输出。让我们看看如果我们改变这些属性的类型会发生什么：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we''re passing a string where a number is expected, and a number where
    a string is expected. If you run `npm run flow` again, you should see the following
    errors:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在传递一个字符串，而期望的是一个数字，以及一个数字，而期望的是一个字符串。如果您再次运行`npm run flow`，您应该会看到以下错误：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These two errors go to great lengths to show you what the problem is. It starts
    by showing you where the component property values were passed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个错误都非常详细地向您展示了问题所在。它首先向您展示了组件属性值被传递的地方：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, it shows you where the `Props` type is being used—to declare the type
    of the properties argument:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它向您展示了`Props`类型被用来声明属性参数的类型：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, it shows you what the exact problem with the type is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它向您展示了类型的确切问题是什么：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Flow error messages try to give you as much information as possible, meaning
    less time spent by you, hunting down files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 流错误消息试图为您提供尽可能多的信息，这意味着您花费的时间更少，寻找文件。
- en: Object property values
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象属性值
- en: 'In the preceding section, you learned how to check for primitive property types.
    React components can also accept objects with primitive values—and other objects.
    If your component is expecting an object as a property value, you can use the
    same approach as you did for primitive values. The difference is how you structure
    your `Props` type declaration:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，您学会了如何检查原始属性类型。React组件也可以接受具有原始值和其他对象的对象。如果您的组件期望一个对象作为属性值，您可以使用与原始值相同的方法。不同之处在于您如何构造`Props`类型声明：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This component expects a `person` property which is an object. Further, it
    expects this object to have a `name` string property and a number `age` property.
    In fact, if you had other components that required a `person` property, you could
    break this type down into reusable parts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件期望一个“person”属性，它是一个对象。此外，它期望此对象具有一个“name”字符串属性和一个数字“age”属性。实际上，如果您有其他需要“person”属性的组件，您可以将此类型分解为可重用的部分：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s take a look at values being passed to this component as properties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看作为属性传递给此组件的值：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of passing the `Person` component several property values, it''s passed
    a single property value, an object that meets the type expectations of the `Props`
    type. If it doesn''t, Flow will complain. Let''s try removing a property from
    this object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将“Person”组件传递给几个属性值，它被传递了一个单一的属性值，一个符合“Props”类型期望的对象。如果不符合，Flow会抱怨。让我们试着从这个对象中删除一个属性：
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now when you run `npm run flow`, it complains about the missing property of
    the object passed to `person`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您运行“npm run flow”时，它会抱怨传递给“person”的对象的缺少属性：
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: No matter how exotic you get with property values, Flow can figure out if you're
    misusing them. Trying to accomplish the same thing at runtime using something
    like `prop-types` is cumbersome at best.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何奇特地使用属性值，Flow都可以弄清楚您是否在错误使用它们。尝试在运行时使用诸如“prop-types”之类的东西来实现相同的功能最多是麻烦的。
- en: Validating component state
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证组件状态
- en: You can validate the properties of functional React components by typing the
    props argument that's passed to the component. Some of your components will have
    state and you can validate a component's state much the same as with properties.
    You can create a type that represents the state of your component, and pass this
    to `Component` as a type argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过对传递给组件的props参数进行类型化来验证功能性React组件的属性。您的一些组件将具有状态，您可以验证组件的状态与属性的方式大致相同。您可以创建一个表示组件状态的类型，并将其作为类型参数传递给“Component”。
- en: 'Let''s take a look at a container component that has state that is used and
    manipulated by a child component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个包含由子组件使用和操作的状态的容器组件：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Child` component rendered by `Container` takes an `on` Boolean property
    and a `toggle` function. The `toggle()` method that is passed to `Child` will
    change the state of `Container`. This means that `Child` can call this function
    in order to change the state of its parent. At the top of the module, above the
    component class, there''s a `State` type that''s used to specify what values are
    allowed to be set as state. In this case, the state is just a simple `on` Boolean
    value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由“Container”渲染的“Child”组件需要一个“on”布尔属性和一个“toggle”函数。“Child”传递给的“toggle（）”方法将改变“Container”的状态。这意味着“Child”可以调用此函数以改变其父级的状态。在模块顶部，在组件类的上方，有一个“State”类型，用于指定允许设置为状态的值。在这种情况下，状态只是一个简单的“on”布尔值：
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This type is then passed as a type argument to `Component` when it''s extended:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在扩展时将此类型作为类型参数传递给“Component”：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By passing this type argument to `Component`, you can bow set component state
    however you want. For example, the `toggle()` method is called by the `Child`
    component to change the state of the `Container` component. If this call sets
    the state incorrectly, Flow will detect it and complain. Let''s change the `toggle()`
    implementation so that it fails by setting the state to something that disagrees
    with Flow:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此类型参数传递给“Component”，您可以随意设置组件状态。例如，“Child”组件调用“toggle（）”方法来改变“Container”组件的状态。如果此调用设置状态不正确，Flow将检测到并抱怨。让我们更改“toggle（）”实现，使其通过将状态设置为与Flow不一致的内容而失败：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You''ll get an error that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到以下错误：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Setting the state incorrectly on a component is easy to do during development,
    so having Flow tell you what you're doing wrong is a real time saver.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中错误地设置组件状态是很容易的，因此让Flow告诉您您做错了什么是真正的时间节省器。
- en: Function property values
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数属性值
- en: It's perfectly normal to pass functions from one component to another as a property.
    You can use Flow to ensure that not only are functions passed to the component,
    but also that the correction type of function is passed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数从一个组件传递到另一个组件作为属性是完全正常的。您可以使用Flow来确保不仅将函数传递给组件，而且还传递了正确类型的函数。
- en: 'Let''s examine this idea by looking at a common pattern in React applications.
    Let''s say that you have the following `Articles` component that renders `Article`
    components:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看React应用程序中的常见模式来检验这个想法。假设您有以下渲染`Article`组件的`Articles`组件：
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Articles` component is a container component because it has state and it
    uses this state to render child `Article` components. It also defines an `onClick()`
    method that changes the `summary` state and the `selected` state. The idea is
    that the `Article` component needs access to this method so that it can trigger
    state changes. If you pay close attention to the `onClick()` method, you'll notice
    that it's actually returning a new event handler function. This is so that when
    the click event actually calls the returned function, it will have scoped access
    to the selected argument.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Articles`组件是一个容器组件，因为它具有状态，并且使用此状态来渲染子`Article`组件。它还定义了一个`onClick()`方法，用于更改`summary`状态和`selected`状态。其想法是`Article`组件需要访问此方法，以便触发状态更改。如果您仔细观察`onClick()`方法，您会注意到它实际上返回了一个新的事件处理程序函数。这样，当单击事件实际调用返回的函数时，它将具有对选定参数的作用域访问权限。'
- en: 'Now let''s take a look at the `Article` component and see how Flow can help
    you make sure that you''re getting the function you expect passed to your component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`Article`组件，看看Flow如何帮助您确保您得到了您期望传递给组件的函数：
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `onClick` handler of the `<a>` element that this component renders calls
    the `onClick()` function that was pass in as a property, expecting a new function
    in return. If you take a look at the `Props` type declaration, you can see that
    the `onClick` property expects a specific type of function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件渲染的`<a>`元素的`onClick`处理程序调用了作为属性传递的`onClick()`函数，并期望返回一个新函数。如果您查看`Props`类型声明，您会发现`onClick`属性期望特定类型的函数：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This tells Flow that this property must be a function that accepts a number
    argument and returns a new function. Passing this component an event handler function
    instead of a function that returns the event handler function is an easy mistake
    to make. Flow can easily spot this and make it easy for you to correct.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Flow，这个属性必须是一个接受数字参数并返回一个新函数的函数。将此组件传递给一个事件处理程序函数，而不是返回事件处理程序函数的函数是一个容易犯的错误。Flow可以轻松发现这一点，并让您轻松进行更正。
- en: Enforcing child component types
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制子组件类型
- en: In addition to validating the types of state and property values, Flow can also
    validate that your component is getting the right child components as well. The
    following sections will show you common scenarios where Flow can tell you when
    you're misusing a component by passing it the wrong children.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了验证状态和属性值的类型之外，Flow还可以验证您的组件是否获得了正确的子组件。接下来的部分将向您展示Flow可以在哪些常见情况下告诉您，当您通过传递错误的子组件来误用组件时。
- en: Parents with specific children types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有特定子类型的父级
- en: 'You can tell Flow that a component should only work with specific types of
    child components. Let''s say that you have a `Child` component, and this is the
    only type of component that should be allowed as a child of the component you''re
    working on. Here''s how you can tell Flow about this constraint:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以告诉Flow组件只能与特定类型的子组件一起使用。假设您有一个`Child`组件，并且这是唯一允许作为正在处理的组件的子组件的类型。以下是如何告诉Flow这个约束的方法：
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s start with the first `import` statement:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个`import`语句开始：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The reason that you want to import the asterisk as `React` is because this will
    pull in all of the Flow type declarations available within React. In this example,
    you're using the `ChildrenArray` type to specify that the value is in fact a child
    of the component, and `Element` to specify that you need a React element. The
    type argument that's used in this example tells Flow that the `Child` component
    is the only type of component that's acceptable here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将星号导入为`React`的原因是因为这将引入React中可用的所有Flow类型声明。在此示例中，您使用`ChildrenArray`类型来指定该值实际上是组件的子组件，并使用`Element`来指定您需要一个React元素。在此示例中使用的类型参数告诉Flow，`Child`组件是此处可接受的唯一组件类型。
- en: 'This JSX will pass flow validation, given the child constraints:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 给定子组件约束，此JSX将通过flow验证：
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's no restriction on the number of `Child` components that are rendered
    as children of `Parent`, just as long as there's at least one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为`Parent`子组件渲染的`Child`组件的数量没有限制，只要至少有一个即可。
- en: Parents with one child
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只有一个子组件的父组件
- en: 'For some components, it makes no sense to have more than one child. For these
    cases, you would use the `React.Element` type instead of the `React.ChildrenArray`
    type:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些组件，拥有多个子组件是没有意义的。对于这些情况，您将使用`React.Element`类型而不是`React.ChildrenArray`类型：
- en: '[PRE46]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As with the example before this one, you can still specify the type of child
    component that is allowed. In this case, the child component is called `Child`,
    imported from `''./Child''`. Here''s how you would pass this component a child
    component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，您仍然可以指定允许的子组件类型。在这种情况下，子组件称为`Child`，从`'./Child'`导入。以下是如何将此组件传递给子组件的方法：
- en: '[PRE47]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you were to pass it multiple `Child` components, Flow would complain:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您传递多个`Child`组件，Flow会抱怨：
- en: '[PRE48]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once again, the Flow error message shows you exactly what is wrong with your
    code and where.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Flow错误消息会准确显示代码的问题所在。
- en: Parents with an optional child
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有可选子组件的父组件
- en: 'Always requiring a child component isn''t necessary and can actually cause
    headaches. For example, what if there is nothing to render because nothing was
    returned from the API? Here''s an example of how to specify that a child is optional
    using Flow syntax:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 始终需要一个子组件并不是必要的，实际上可能会引起麻烦。例如，如果没有要渲染的内容，因为API没有返回任何内容怎么办？以下是如何使用Flow语法指定子组件是可选的示例：
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This looks a lot like a React component that requires a specific type of element.
    The difference is with the question mark: `children?`. This means that either
    a child component of type `Child` may be passed, or no child at all.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像需要特定类型元素的React组件。不同之处在于有一个问号：`children?`。这意味着可以传递`Child`类型的子组件，也可以不传递任何子组件。
- en: Parents with primitive child values
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有原始子值的父组件
- en: 'It''s common to render React components that take primitive values as children.
    In some cases, you might want to accept a string or a Boolean type. Here''s how
    you would do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染接受原始值作为子组件的React组件是很常见的。在某些情况下，您可能希望接受字符串或布尔类型。以下是您可以这样做的方法：
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once again, you can use the `React.ChildrenArray` type to specify that multiple
    child elements are allowed. To specify a specific child type, you pass it to `React.ChildrenArray`
    as a type argument—in this case a string and Boolean union. Now you can render
    this component with a string:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以使用`React.ChildrenArray`类型来指定允许多个子元素。要指定特定的子类型，您将其传递给`React.ChildrenArray`作为类型参数—在这种情况下是字符串和布尔联合。现在您可以使用字符串渲染此组件：
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or with a Boolean:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用布尔值：
- en: '[PRE52]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Or with both:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者两者都使用：
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Validating event handler functions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证事件处理程序函数
- en: React components use functions to respond to events. These are called **event
    handler functions**, and they're passed an event object as an argument when the
    React event system calls them. It can be useful to use Flow to explicitly type
    these event arguments to make sure that your event handler is getting the type
    of element that it expects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: React组件使用函数来响应事件。这些被称为**事件处理程序函数**，当React事件系统调用它们时，它们会被传递一个事件对象作为参数。使用Flow明确地为这些事件参数类型化可能是有用的，以确保您的事件处理程序获得它所期望的元素类型。
- en: 'For example, assume that you''re working on a component that responds to clicks
    from an `<a>` element. Your event handler function also needs to interact with
    the clicked element, in order to get the `href` property. Using the Flow types
    exposed by React, you can ensure that the correct element type is indeed triggering
    the event that is causing your function to run:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在开发一个组件，该组件响应来自`<a>`元素的点击。您的事件处理程序函数还需要与被点击的元素交互，以获取`href`属性。使用React公开的Flow类型，您可以确保正确的元素类型确实触发了导致函数运行的事件：
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `clickHandler()` function in this example is assigned as the `onClick`
    handler of an <a> element. Notice the type of the event argument: `SyntheticEvent<HTMLAnchorElement>`.
    Flow will use this to make sure that your code that uses the event is only accessing
    the appropriate properties of the event, and `currentTarget` of the event.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`clickHandler()`函数被分配为`<a>`元素的`onClick`处理程序。注意事件参数的类型：`SyntheticEvent<HTMLAnchorElement>`。Flow将使用此来确保您的代码只访问事件的适当属性和事件的`currentTarget`。
- en: '`currentTarget` is the element that triggered the event, and in this example,
    you''ve specified that it should be `HTMLAnchorElement`. Had you used another
    type, Flow would complain about you referencing the `href` property, because that
    doesn''t exist in other HTML elements.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTarget`是触发事件的元素，在这个例子中，您已指定它应该是`HTMLAnchorElement`。如果您使用了其他类型，Flow会抱怨您引用`href`属性，因为其他HTML元素中不存在该属性。'
- en: Bringing Flow into the development server
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Flow引入开发服务器
- en: Wouldn't it be great if type-checking your React code were more tightly-integrated
    into the `create-react-app` development process? There's been talk of making this
    a reality in a future release of `create-react-app`. For now, you'll have to eject
    from `create-react-app` if you want this functionality for your project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在项目中为此功能，您需要从`create-react-app`中退出。
- en: The goal of this approach is to have the development server run Flow for you
    whenever changes are detected. Then, you can see the Flow output in your dev server
    console output, and in the browser console.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的目标是在检测到更改时让开发服务器为您运行Flow。然后，您可以在开发服务器控制台输出和浏览器控制台中看到Flow输出。
- en: 'Once you''ve ejected from `create-react-app` by running `npm eject`, you need
    to install the following Webpack plugin:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您通过运行`npm eject`从`create-react-app`中退出，您需要安装以下Webpack插件：
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, you need to enable the plugin by editing `config/webpack.config.dev.js`.
    First, you need to include the plugin:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要通过编辑`config/webpack.config.dev.js`来启用插件。首先，您需要包含插件：
- en: '[PRE56]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, you need to add the plugin to the array in the `plugins` option. This
    array should look something like this afterward:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将插件添加到`plugins`选项中的数组中。之后，这个数组应该看起来像这样：
- en: '[PRE57]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That''s all there is to it. Now when you start your dev server, Flow will automatically
    run and type-check your code as part of the Webpack build process. Let''s add
    the `@flow` directive to the top of `App.js` and run `npm start`. Since the `App`
    component won''t validate as a subclass of `Component`, you should get an error
    in the dev server console output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在当你启动开发服务器时，Flow将自动运行并在Webpack构建过程中对你的代码进行类型检查。让我们在`App.js`的顶部添加`@flow`指令，然后运行`npm
    start`。由于`App`组件不会作为`Component`的子类进行验证，你应该会在开发服务器控制台输出中得到一个错误：
- en: '[PRE58]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'What I really like about this approach is that the dev server will still start,
    even if there''s a Flow error. If you look at the app in your browser, you''ll
    see the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢这种方法，即使有Flow错误，开发服务器仍然会启动。如果你在浏览器中查看应用程序，你会看到以下内容：
- en: '![](Images/3b760a4f-2ae2-47cf-afa9-527bb9be4fa1.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b760a4f-2ae2-47cf-afa9-527bb9be4fa1.png)'
- en: 'This means that you don''t even have to look at your dev server console during
    development to catch type errors! And since it''s part of the development dev
    server, your code is rechecked by Flow every time you make a change. So let''s
    fix the current error in `App.js` by passing it a property type argument (`<{}>`):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在开发过程中，你甚至不需要查看开发服务器控制台来捕捉类型错误！而且由于它是开发服务器的一部分，每次你进行更改时，Flow都会重新检查你的代码。所以让我们通过传递一个属性类型参数(`<{}>`)来修复`App.js`中的当前错误。
- en: '[PRE59]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once this change is made, save the file. Just like that, the error is gone and
    you're back in business.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进行了这个改变，保存文件。就像这样，错误就消失了，你又可以继续工作了。
- en: Bringing Flow into your editor
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Flow整合到你的编辑器中
- en: One final option that we'll look at for validating your React code using Flow
    is integrating the process into your code editor. I'm using the popular Atom editor
    so I'll use this as an example, but there are likely options for integrating Flow
    with other editors.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下最后一个选项，用于使用Flow验证你的React代码，那就是将这个过程整合到你的代码编辑器中。我正在使用流行的Atom编辑器，所以我会以此为例，但很可能也有其他编辑器可以与Flow整合。
- en: 'To enable Flow capabilities in the Atom ([https://atom.io/](https://atom.io/))
    editor, you''ll need to install the `linter-flow` package:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Atom编辑器中启用Flow功能，你需要安装`linter-flow`包：
- en: '![](Images/ae5686bc-9c22-44a0-a10c-e07202c52db4.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ae5686bc-9c22-44a0-a10c-e07202c52db4.png)'
- en: 'Once installed, you''ll need to change the executable path setting of `linter-flow`.
    By default, the plugin assumes that you have Flow installed globally, which, you
    probably don''t. You have to tell the plugin to look in the local `node_modules`
    directory for the Flow executable:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你需要改变`linter-flow`的可执行路径设置。默认情况下，插件假设你已经全局安装了Flow，但实际上你可能没有。你需要告诉插件在本地的`node_modules`目录中查找Flow可执行文件：
- en: '![](Images/0d2e1839-6db9-4019-ac26-08ffda5f2104.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0d2e1839-6db9-4019-ac26-08ffda5f2104.png)'
- en: 'You''re all set. To verify that this is working as expected, open up `App.js`
    from a fresh `create-react-app` install and add the `@flow` directive at the top
    of the file. This should trigger an error from Flow and should be displayed within
    Atom:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了。为了验证这是否按预期工作，请打开一个新的`create-react-app`安装中的`App.js`，并在文件顶部添加`@flow`指令。这应该会触发Flow的错误，并应该在Atom中显示出来：
- en: '![](Images/09fe4981-2a7c-4620-98df-5a60dc5d2b13.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fe4981-2a7c-4620-98df-5a60dc5d2b13.png)'
- en: 'The Linter will also highlight the problematic code that''s causing Flow to
    complain as well:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Linter还会突出显示导致Flow抱怨的有问题的代码：
- en: '![](Images/e0f29729-4e75-4715-a42b-0bc789def958.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e0f29729-4e75-4715-a42b-0bc789def958.png)'
- en: With the in-editor approach to using Flow, you don't even have to save, let
    alone switch windows to have your code type-checked—all you have to do is write
    it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在编辑器中使用Flow的方法，您甚至不需要保存，更不用说切换窗口来进行代码类型检查——您只需要编写代码。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about why type-checking your React code matters.
    You also learned about Flow—the tool used to type-check React code. Type-checking
    is important for React applications because it removes the need to perform runtime
    checks of values in the majority of cases. This is because Flow is able to statically
    follow code paths and determine whether everything is being used as intended.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了为什么对React代码进行类型检查很重要。您还了解了Flow——用于对React代码进行类型检查的工具。对于React应用程序来说，类型检查很重要，因为它消除了在大多数情况下执行值的运行时检查的需要。这是因为Flow能够静态地跟踪代码路径，并确定是否一切都被按照预期使用。
- en: Then, you installed Flow locally to a React application and learned how to run
    it. Next, you learned the basics of validating property and state values of React
    components. Then you learned how to validate function types and how to enforce
    child React component types.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您在本地安装了Flow到一个React应用程序，并学会了如何运行它。接下来，您学会了验证React组件的属性和状态值的基础知识。然后，您学会了验证函数类型以及如何强制执行子React组件类型。
- en: Flow can be used in `create-react-app` dev server, but you have to eject first.
    In future versions of `create-react-app`, there will likely be better integrated
    support for running Flow as part of the dev server. Another option is to install
    a Flow plugin in a code editor such as Atom, and have errors displayed right in
    front of your eyes as you write your code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Flow可以在`create-react-app`开发服务器中使用，但您必须先进行弹出。在未来的`create-react-app`版本中，可能会有更好的集成支持，可以作为开发服务器的一部分运行Flow。另一个选择是在诸如Atom之类的代码编辑器中安装Flow插件，并在编写代码时直接在眼前显示错误。
- en: In the following chapter, you'll learn how to enforce a high quality level with
    your React code with the help of tools.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习如何借助工具来强制执行React代码的高质量水平。
