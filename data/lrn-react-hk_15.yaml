- en: Redux and Hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux和Hooks
- en: In the previous chapter we learned about React class components, and how to
    migrate from an existing class component-based project to a Hook-based one. Then,
    we learned about the trade-offs between the two solutions, and we discussed when
    and how existing projects should be migrated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于React类组件，以及如何从现有的基于类组件的项目迁移到基于Hook的项目。然后，我们了解了两种解决方案之间的权衡，并讨论了现有项目应该何时以及如何迁移。
- en: In this chapter, we are going to turn the ToDo application that we created in
    the previous chapter into a Redux application. First, we are going to learn what
    Redux is, including the three principles of Redux. We are also going to learn
    when it makes sense to use Redux in an app, and that it is not appropriate for
    every app. Furthermore, we are going to learn how to handle state with Redux.
    Afterward, we are going to learn how to use Redux with Hooks, and how to migrate
    an existing Redux application to Hooks. Finally, we are going to learn the trade-offs
    of Redux, in order to be able to decide which solution would be best for a certain
    use case. By the end of this chapter, you will fully understand how to write Redux
    applications using Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把上一章中创建的ToDo应用程序转换为Redux应用程序。首先，我们将学习Redux是什么，包括Redux的三个原则。我们还将学习在应用程序中何时使用Redux是有意义的，以及它并不适用于每个应用程序。此外，我们将学习如何使用Redux处理状态。之后，我们将学习如何在Hooks中使用Redux，以及如何将现有的Redux应用程序迁移到Hooks。最后，我们将学习Redux的权衡，以便能够决定哪种解决方案对于特定用例最合适。通过本章结束时，您将完全了解如何使用Hooks编写Redux应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What Redux is and when and why it should be used
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux是什么，以及何时以及为什么应该使用它
- en: Handling state with Redux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux处理状态
- en: Using Redux with Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks与Redux
- en: Migrating a Redux application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移Redux应用程序
- en: Learning the trade-offs of Redux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Redux的权衡
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: 'The code for this chapter can be found on the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter12).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库上找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter12)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码运行情况：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    write the code yourself in order for you to be able to learn and understand properly.
    However, if you run into any issues, you can always refer to the code example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行提供的代码示例。重要的是您自己编写代码，以便您能够正确学习和理解。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始本章。
- en: What is Redux?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux是什么？
- en: 'As we have previously learned, there are two kinds of state in an application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，应用程序中有两种状态：
- en: '**Local** **state**: For example, to handle input field data'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地** **状态**：例如，处理输入字段数据'
- en: '**Global** **state**: For example, to store the currently logged-in user'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局** **状态**：例如，存储当前登录的用户'
- en: Previously in this book, we handled local state by using a State Hook, and more
    complex state (often global state) using a Reducer Hook.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用State Hook处理本地状态，使用Reducer Hook处理更复杂的状态（通常是全局状态）。
- en: Redux is a solution that can be used to handle all kinds of state in React applications.
    It provides a single state tree object, which contains all application state.
    This is similar to what we did with the Reducer Hook in our blog application.
    Traditionally, Redux was also often used to store local state, which makes the
    state tree very complex.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是一种可以用来处理 React 应用程序中各种状态的解决方案。它提供了一个包含所有应用程序状态的单个状态树对象。这与我们在博客应用程序中使用的
    Reducer Hook 类似。传统上，Redux 也经常用于存储本地状态，这使得状态树非常复杂。
- en: 'Redux essentially consists of five elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 本质上由五个元素组成：
- en: '**Store**: Contains state, which is an object that describes the full state
    of our application—`{ todos: [], filter: ''all'' }`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：包含状态的对象，描述了我们应用程序的完整状态—`{ todos: [], filter: ''all'' }`'
- en: '**Actions**: Objects that describe a state modification—``{ type: ''FILTER_TODOS'',
    filter: ''completed'' }``'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：描述状态修改的对象—``{ type: ''FILTER_TODOS'', filter: ''completed'' }``'
- en: '**Action creators**: Functions that create action objects—`(filter) => ({ type:
    ''FILTER_TODOS'', filter })`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作创建者**：创建动作对象的函数—`(filter) => ({ type: ''FILTER_TODOS'', filter })`'
- en: '**Reducers**: Functions that take the current `state` value and an `action`
    object, and return a new state—`(state, action) => { ... }`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减速器**：接受当前 `state` 值和一个 `action` 对象，并返回一个新状态的函数—`(state, action) => { ...
    }`'
- en: '**Connectors**: Higher-order components that connect an existing component
    to Redux, by injecting the Redux state and action creators as props—`connect(mapStateToProps,
    mapDispatchToProps)(Component)`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接器**：将现有组件连接到 Redux 的高阶组件，通过将 Redux 状态和动作创建者注入为 props—`connect(mapStateToProps,
    mapDispatchToProps)(Component)`'
- en: In the Redux life cycle, the **Store** contains state, which defines the UI.
    The UI is connected to the Redux store, via **Connectors**. User interactions
    with the UI then trigger **Actions**, which are sent to the **Reducer**. The **Reducer** then
    updates the state in the **Store**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 生命周期中，**存储** 包含定义 UI 的状态。UI 通过 **连接器** 连接到 Redux 存储。用户与 UI 的交互触发 **动作**，然后发送到
    **减速器**。**减速器** 然后更新 **存储** 中的状态。
- en: 'We can see a visualization of the Redux life cycle in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下图中看到 Redux 生命周期的可视化：
- en: '![](assets/56b43307-68c8-4181-9f8a-1a45e4e65da6.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/56b43307-68c8-4181-9f8a-1a45e4e65da6.png)'
- en: Visualization of the Redux life cycle
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 生命周期的可视化
- en: 'As you can see, we have already learned about three of these components: the
    store (state tree), actions, and reducers. Redux is like a more advanced version
    of the Reducer Hook. The difference is that with Redux, we always dispatch state
    to a single reducer, therefore changing a single state. There should not be more
    than one instance of Redux. Through this restriction, we can be sure that our
    whole application state is contained in a single object, which allows us to reconstruct
    the whole application state, just from the Redux store.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经了解了这些组件中的三个：store（状态树）、动作和减速器。Redux 就像是 Reducer Hook 的更高级版本。不同之处在于，使用
    Redux，我们总是将状态分派给单个减速器，因此只改变一个状态。Redux 不应该有多个实例。通过这种限制，我们可以确保整个应用程序状态都包含在一个对象中，这使我们能够仅从
    Redux 存储中重建整个应用程序状态。
- en: As a result of having a single store containing all state, we can easily debug
    faulty states by saving the Redux store in a crash report, or we can automatically
    replay certain actions during debugging so that we do not need to manually enter
    text and click on buttons, over and over again. Additionally, Redux offers middleware
    that simplifies how we deal with asynchronous requests, such as fetching data
    from a server. Now that we understand what Redux is, in the next section, we will
    learn the three fundamental principles of Redux.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个包含所有状态的存储，我们可以通过在崩溃报告中保存Redux存储，或者在调试过程中自动重放某些操作来轻松调试错误的状态，这样我们就不需要手动输入文本和点击按钮，一遍又一遍。此外，Redux提供了简化我们处理异步请求的中间件，例如从服务器获取数据。现在我们了解了Redux是什么，在下一节中，我们将学习Redux的三个基本原则。
- en: The three principles of Redux
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux的三个原则
- en: The Redux API is very small, and actually only consists of a handful of functions.
    What makes Redux so powerful is a certain set of rules that are applied to your
    code when using the library. These rules allow for the writing of scalable applications
    that are easy to extend, test, and debug.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的API非常小，实际上只包含少数几个函数。Redux如此强大的原因在于在使用该库时应用于代码的一套规则。这些规则允许编写可扩展、易于扩展、测试和调试的应用程序。
- en: 'Redux is based on three fundamental principles:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Redux基于三个基本原则：
- en: Single source of truth
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真相的单一来源
- en: Read-only state
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读状态
- en: State changes are processed with pure functions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态更改通过纯函数处理
- en: Single source of truth
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真相的单一来源
- en: This Redux principle states that data should always have a single source of
    truth. This means that global data comes from a single Redux store, and local
    data comes from, for example, a certain State Hook. Each kind of data only has
    a single source. As a result, applications become easier to debug, and are less
    prone to errors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Redux原则指出数据应该始终有一个单一的真相来源。这意味着全局数据来自单一的Redux存储，本地数据来自，例如，某个State Hook。每种数据只有一个来源。因此，应用程序变得更容易调试，更不容易出错。
- en: Read-only state
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读状态
- en: 'With Redux, it is not possible to modify the application state directly. It
    is only possible to change the state by dispatching actions. This principle makes
    state changes predictable: if no action happened, the application state will not
    change. Furthermore, actions are processed one at a time, so we do not have to
    deal with race conditions. Finally, actions are plain JavaScript objects, which
    makes them easy to serialize, log, store, or replay. As a result, debugging and
    testing a Redux application becomes very easy to do.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Redux，不可能直接修改应用程序状态。只能通过分派动作来改变状态。这个原则使状态变化可预测：如果没有动作发生，应用程序状态将不会改变。此外，动作是逐个处理的，因此我们不必处理竞争条件。最后，动作是纯粹的JavaScript对象，这使它们易于序列化、记录、存储或重放。因此，调试和测试Redux应用程序变得非常容易。
- en: State changes are processed with pure functions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态更改通过纯函数处理
- en: Pure functions are functions that, given the same input, will always return
    the same output. Reducer functions in Redux are pure, so, given the same state
    and action, they will always return the same new state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是指，给定相同的输入，将始终返回相同的输出。Redux中的Reducer函数是纯的，因此，给定相同的状态和动作，它们将始终返回相同的新状态。
- en: 'For example, the following reducer is an impure function, because calling the
    function multiple times with the same input results in a different output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下的reducer是一个不纯的函数，因为多次使用相同的输入调用该函数会产生不同的输出：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To turn this reducer into a pure function, we have to make sure it does not
    depend on an outside state, and only uses its arguments for the computation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个reducer转变为纯函数，我们必须确保它不依赖于外部状态，只使用其参数进行计算：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using pure functions for reducers makes them predictable, and easy to test
    and debug. With Redux, we need to be careful to always return a new state, and
    not modify the existing one. So, for example, we cannot use `Array.push()` on
    an array state, as it would modify the existing array; we have to use `Array.concat()`
    in order to create a new array. The same goes for objects, where we have to use
    rest/spread syntax to create new objects, instead of modifying existing ones.
    For example, `{ ...state, completed: true }`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '使用纯函数进行减速器使它们可预测，易于测试和调试。使用Redux时，我们需要小心始终返回新状态，而不是修改现有状态。因此，例如，我们不能在数组状态上使用`Array.push()`，因为它会修改现有数组；我们必须使用`Array.concat()`来创建一个新数组。对于对象也是一样，我们必须使用rest/spread语法来创建新对象，而不是修改现有对象。例如，`{
    ...state, completed: true }`。'
- en: Now that we have learned about the three fundamental principles of Redux, we
    can move on to using Redux in practice, by implementing state handling with Redux
    in our ToDo application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Redux的三个基本原则，我们可以开始在我们的ToDo应用程序中实践使用Redux来实现状态处理。
- en: Handling state with Redux
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux处理状态
- en: State management with Redux is actually really similar to using a Reducer Hook.
    We first define the state object, then actions, and finally, our reducers. An
    additional pattern in Redux is to create functions that return action objects,
    so-called action creators. Furthermore, we need to wrap our whole app with a `Provider`
    component, and connect components to the Redux store in order to be able to use
    Redux state and action creators.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Redux进行状态管理实际上与使用Reducer Hook非常相似。我们首先定义状态对象，然后操作，最后是我们的减速器。Redux中的另一个模式是创建返回操作对象的函数，即所谓的操作创建者。此外，我们需要用`Provider`组件包装整个应用程序，并连接组件到Redux存储，以便能够使用Redux状态和操作创建者。
- en: Installing Redux
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Redux
- en: 'First of all, we have to install Redux, React Redux, and Redux Thunk. Let us
    look at what each one does individually:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装Redux，React Redux和Redux Thunk。让我们分别看看每个库的作用：
- en: Redux itself just deals with JavaScript objects, so it provides the store, deals
    with actions and action creators, and handles reducers.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux本身只处理JavaScript对象，因此它提供存储，处理操作和操作创建者，并处理减速器。
- en: React Redux provides connectors in order to connect Redux to our React components.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Redux提供连接器，以便将Redux连接到我们的React组件。
- en: Redux Thunk is a middleware that allows us to deal with asynchronous requests
    in Redux.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Thunk是一个中间件，允许我们在Redux中处理异步请求。
- en: 'Using **Redux** in combination with **React** offloads global state management
    to **Redux**, while **React** deals with rendering the application and local state:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在**React**中与**Redux**结合使用**Redux**可以将全局状态管理转移到**Redux**，而**React**处理应用程序的渲染和本地状态：
- en: '![](assets/57db1dda-569a-49f4-848a-935ea4c4f55c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57db1dda-569a-49f4-848a-935ea4c4f55c.png)'
- en: Illustration of how React and Redux work together
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: React和Redux如何一起工作的示例
- en: 'To install Redux and React Redux, we are going to use `npm`. Execute the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Redux和React Redux，我们将使用`npm`。执行以下命令：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that all of the required libraries are installed, we can start setting up
    our Redux store.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有必需的库都已安装好，我们可以开始设置我们的Redux存储。
- en: Defining state, actions, and reducers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义状态、操作和减速器
- en: The first step in developing a Redux application is defining the state, then
    the actions that are going to change the state, and finally, the reducer functions,
    which carry out the state modification. In our ToDo application, we have already
    defined the state, the actions, and the reducers, in order to use the Reducer
    Hook. Here, we simply recap what we defined in the previous chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Redux应用程序的第一步是定义状态，然后是将改变状态的操作，最后是执行状态修改的减速器函数。在我们的ToDo应用程序中，我们已经定义了状态，操作和减速器，以便使用Reducer
    Hook。在这里，我们只是简单地回顾了我们在上一章中定义的内容。
- en: State
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'The full state object of our ToDo app consists of two keys: an array of todo
    items, and a string, which specifies the currently selected `filter` value. The
    initial state looks as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们ToDo应用程序的完整状态对象由两个键组成：一个todo项目数组和一个字符串，用于指定当前选择的`filter`值。初始状态如下：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, in Redux, the state object contains all of the state that is
    important to our app. In this case, the application state consists of an array
    of `todos` and a `filter`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在Redux中，状态对象包含了对我们应用程序重要的所有状态。在这种情况下，应用程序状态由一个`todos`数组和一个`filter`字符串组成。
- en: Actions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作
- en: 'Our app accepts the following five actions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序接受以下五个动作：
- en: '`FETCH_TODOS`: To fetch a new list of todo items—`{ type: ''FETCH_TODOS'',
    todos: [] }`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FETCH_TODOS`：获取新的todo项目列表——`{ type: ''FETCH_TODOS'', todos: [] }`'
- en: '`ADD_TODO`: To insert a new todo item—`{ type: ''ADD_TODO'', title: ''Test
    ToDo app'' }`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD_TODO`：插入新的todo项目——`{ type: ''ADD_TODO'', title: ''Test ToDo app'' }`'
- en: '`TOGGLE_TODO`: To toggle the `completed` value of a todo item—`{ type: ''TOGGLE_TODO'',
    id: ''xxx'' }`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOGGLE_TODO`：切换todo项目的`completed`值——`{ type: ''TOGGLE_TODO'', id: ''xxx''
    }`'
- en: '`REMOVE_TODO`: To remove a todo item—`{ type: ''REMOVE_TODO'', id: ''xxx''
    }`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOVE_TODO`：移除todo项目——`{ type: ''REMOVE_TODO'', id: ''xxx'' }`'
- en: '`FILTER_TODOS`: To filter todo items—`{ type: ''FILTER_TODOS'', filter: ''completed''
    }`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILTER_TODOS`：过滤todo项目——`{ type: ''FILTER_TODOS'', filter: ''completed'' }`'
- en: Reducers
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: We defined three reducers—one for each part of our state—and an app reducer
    to combine the other two reducers. The filter reducer waits for a `FILTER_TODOS`
    action, and then sets the new filter accordingly. The todos reducer listens to
    the other todo-related actions, and adjusts the todos array by adding, removing,
    or modifying elements. The app reducer then combines both reducers, and passes
    actions down to them. After defining all the elements that are needed to create
    a Redux application, we can now set up the Redux store.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个reducer——分别用于我们状态的每个部分，并且定义了一个app reducer来合并其他两个reducer。filter reducer等待`FILTER_TODOS`动作，然后相应地设置新的过滤器。todos
    reducer监听其他与todo相关的动作，并通过添加、删除或修改元素来调整todos数组。然后app reducer合并这两个reducer，并将动作传递给它们。在定义了创建Redux应用所需的所有元素之后，我们现在可以设置Redux存储。
- en: Setting up the Redux store
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Redux存储
- en: In order to keep things simple initially, and to show how Redux works, we are
    not going to use connectors for now. We are simply going to replace the `state`
    object, and the `dispatch` function that was previously provided by a Reducer
    Hook, with Redux.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最初保持简单，并展示Redux的工作原理，我们现在不会使用连接器。我们只是简单地用Redux替换了之前由Reducer Hook提供的`state`对象和`dispatch`函数。
- en: 'Let''s set up the Redux store now:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置Redux存储：
- en: 'Edit `src/App.js`, and import the `useState` Hook, as well as the `createStore`
    function from the Redux library:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并从Redux库中导入`useState` Hook和`createStore`函数：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Below the import statements and before the `App` function definition, we are
    going to initialize the Redux store. We start by defining the initial state:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入语句之后，并在`App`函数定义之前，我们将初始化Redux存储。我们首先定义初始状态：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we are going to use the `createStore` function in order to define the
    Redux store, by using the existing `appReducer` function and passing the `initialState` object:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`createStore`函数来定义Redux存储，通过使用现有的`appReducer`函数并传递`initialState`对象：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that in Redux, it is not best practice to initialize the state by
    passing it to `createStore`. However, with a Reducer Hook, we need to do it this
    way. In Redux, we usually initialize state by setting default values in the reducer
    functions. We are going to learn more about initializing state via Redux reducers
    later in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Redux中，通过将其传递给`createStore`来初始化状态并不是最佳实践。然而，在Reducer Hook中，我们需要以这种方式进行。在Redux中，我们通常通过在reducer函数中设置默认值来初始化状态。我们将在本章后面学习更多关于通过Redux
    reducer初始化状态的内容。
- en: 'Now, we can get the `dispatch` function from the store:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从存储中获取`dispatch`函数：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next step is removing the following Reducer Hook definition within the
    `App` function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`App`函数中删除以下Reducer Hook定义：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is replaced with a simple State Hook, which is going to store our Redux
    state:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它被一个简单的State Hook替换，它将存储我们的Redux状态：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we define an Effect Hook, in order to keep the State Hook in sync
    with the Redux store state:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个Effect Hook，以便将State Hook与Redux存储状态同步：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the app still runs in exactly the same way as before. Redux works
    very similarly to the Reducer Hook, but with more functionality. However, there
    are slight differences in how actions and reducers should be defined, which we
    are going to learn about in the following sections.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，应用程序仍然以与以前完全相同的方式运行。Redux的工作方式与Reducer Hook非常相似，但具有更多的功能。然而，在如何定义动作和减速器方面有轻微的差异，我们将在接下来的章节中学习。
- en: Example code
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter12/chapter12_1` folder.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter12/chapter12_1`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Defining action types
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作类型
- en: The first step when creating a full Redux application is to define so-called
    action types. They will be used to create actions in action creators and to handle
    actions in reducers. The idea here is to avoid making typos when defining, or
    comparing, the `type` property of actions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完整的Redux应用程序的第一步是定义所谓的动作类型。它们将用于在动作创建者中创建动作，并在减速器中处理动作。这里的想法是避免在定义或比较动作的`type`属性时出现拼写错误。
- en: 'Let''s define the action types now:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义动作类型：
- en: Create a new `src/actionTypes.js` file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/actionTypes.js`文件。
- en: 'Define and export the following constants in the newly created file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件中定义并导出以下常量：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have defined our action types, we can start using them in action
    creators and reducers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的动作类型，我们可以开始在动作创建者和减速器中使用它们。
- en: Defining action creators
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作创建者
- en: 'After defining the action types, we need to define the actions themselves.
    In doing so, we are going to define the functions that will return the action
    objects. These functions are called action creators, of which there are two types:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义动作类型之后，我们需要定义动作本身。这样做，我们将定义返回动作对象的函数。这些函数被称为动作创建者，有两种类型：
- en: '**Synchronous** **action creators**: These simply return an action object'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步** **动作创建者**：这些只是返回一个动作对象'
- en: '**Asynchronous** **action creators**: These return an `async` function, which
    will later dispatch an action'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步** **动作创建者**：这些返回一个`async`函数，稍后将调度一个动作'
- en: We are going to start by defining synchronous action creators, then we are going
    to learn how to define asynchronous action creators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义同步动作创建者，然后我们将学习如何定义异步动作创建者。
- en: Defining synchronous action creators
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义同步动作创建者
- en: We have already defined the action creator functions earlier, in `src/App.js`.
    We can now copy them from our `App` component, making sure that we adjust the
    `type` property in order to use the action type constants, instead of a static
    string.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`src/App.js`中早些时候定义了动作创建者函数。现在我们可以从我们的`App`组件中复制它们，确保我们调整`type`属性以使用动作类型常量，而不是静态字符串。
- en: 'Let''s define the synchronous action creators now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义同步动作创建者：
- en: Create a new `src/actions.js` file.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/actions.js`文件。
- en: 'Import all action types, which we are going to need to create our actions:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们将需要创建动作的所有动作类型：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can define and export our action creator functions:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义并导出我们的动作创建者函数：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, synchronous action creators simply create and return action objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，同步动作创建者只是创建并返回动作对象。
- en: Defining asynchronous action creators
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义异步动作创建者
- en: The next step is defining an asynchronous action creator for the `fetchTodos`
    action. Here, we are going to use the `async`/`await` construct.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为“fetchTodos”动作定义一个异步动作创建者。在这里，我们将使用“async”/“await”结构。
- en: 'We are now going to use an `async` function to define the `fetchTodos` action
    creator:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用“async”函数来定义“fetchTodos”动作创建者：
- en: 'In `src/actions.js`, first import the `FETCH_TODOS` action type and the `fetchAPITodos`
    function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“src/actions.js”中，首先导入“FETCH_TODOS”动作类型和“fetchAPITodos”函数：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, define a new action creator function, which will return an `async` function
    that is going to get the `dispatch` function as an argument:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个新的动作创建者函数，该函数将返回一个获取“dispatch”函数作为参数的“async”函数：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this `async` function, we are now going to call the API function, and `dispatch`
    our action:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个“async”函数中，我们现在将调用API函数，并“dispatch”我们的动作：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, asynchronous action creators return a function that will dispatch
    actions at a later time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，异步动作创建者返回一个函数，该函数将在以后的时间调度动作。
- en: Adjusting the store
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整存储
- en: In order for us to be able to use asynchronous action creator functions in Redux,
    we are going to need to load the `redux-thunk` middleware. This middleware checks
    if an action creator returned a function, rather than a plain object, and if that
    is the case, it executes that function, while passing the `dispatch` function
    to it as an argument.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们能够在Redux中使用异步动作创建者函数，我们需要加载“redux-thunk”中间件。此中间件检查动作创建者是否返回一个函数，而不是一个普通对象，如果是这种情况，它会执行该函数，并将“dispatch”函数作为参数传递给它。
- en: 'Let''s adjust the store to allow for asynchronous action creators now:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调整存储以允许异步动作创建者：
- en: Create a new `src/configureStore.js` file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“src/configureStore.js”文件。
- en: 'Import the `createStore` and `applyMiddleware` functions from Redux:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Redux中导入“createStore”和“applyMiddleware”函数：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, import the `thunk` middleware and `appReducer` function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入“thunk”中间件和“appReducer”函数：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can define the store and apply the `thunk` middleware to it:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义存储并将“thunk”中间件应用于它：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we export the `store`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们导出“store”：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `redux-thunk` middleware, we can now dispatch functions that will
    later dispatch actions, which means that our asynchronous action creator is going
    to work fine now.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“redux-thunk”中间件，我们现在可以调度稍后调度动作的函数，这意味着我们的异步动作创建者现在将正常工作。
- en: Adjusting reducers
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整reducers
- en: 'As previously mentioned, Redux reducers differ from Reducer Hooks in that they
    have certain conventions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Redux reducers与Reducer Hooks不同，它们具有某些约定：
- en: Each reducer needs to set its initial state by defining a default value in the
    function definition
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个reducer需要通过在函数定义中定义默认值来设置其初始状态
- en: Each reducer needs to return the current state for unhandled actions
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个reducer需要返回未处理动作的当前状态
- en: We are now going to adjust our existing reducers so that they follow these conventions.
    The second convention is already implemented, because we defined a single app
    reducer earlier, in order to avoid having multiple dispatch functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将调整现有的reducers，使它们遵循这些约定。第二个约定已经实现了，因为我们之前定义了一个单一的应用程序reducer，以避免有多个dispatch函数。
- en: Setting the initial state in Redux reducers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Redux reducers中设置初始状态
- en: 'So, we are going to focus on the first convention—to set the initial state
    by defining a default value in the function arguments, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将专注于第一个约定-通过在函数参数中定义默认值来设置初始状态，如下所示：
- en: 'Edit `src/reducers.js` and import the `combineReducers` function from Redux:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/reducers.js`并从Redux中导入`combineReducers`函数：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, rename `filterReducer` to `filter`, and set a default value:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`filterReducer`重命名为`filter`，并设置默认值：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, edit `todosReducer` and repeat the same process there:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`todosReducer`中进行相同的编辑和重复相同的过程：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we are going to use the `combineReducers` function to create our `appReducer`
    function. Instead of creating the function manually, we can now do the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`combineReducers`函数来创建我们的`appReducer`函数。现在我们可以这样做，而不是手动创建函数：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, Redux reducers are very similar to Reducer Hooks. Redux even
    provides a function that allows us to combine multiple reducer functions into
    a single app reducer!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Redux reducers非常类似于Reducer Hooks。Redux甚至提供了一个函数，允许我们将多个reducer函数组合成一个单一的应用reducer！
- en: Connecting components
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接组件
- en: Now, it is time to introduce connectors and container components. In Redux we
    can use the `connect` higher-order component to connect existing components to
    Redux, through injecting state and action creators as props into them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍连接器和容器组件了。在Redux中，我们可以使用`connect`高阶组件将现有的组件连接到Redux，通过将状态和动作创建者作为props注入到它们中。
- en: 'Redux defines two different kinds of components:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Redux定义了两种不同类型的组件：
- en: '**Presentational** **components**: React components, as we have been defining
    them until now'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示性** **组件**：就像我们一直定义的React组件'
- en: '**Container** **components**: React components that connect presentational
    components to Redux'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器** **组件**：连接表示性组件到Redux的React组件'
- en: 'Container components use a connector to connect Redux to a presentational component.
    This connector accepts two functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件使用连接器将Redux连接到表示性组件。这个连接器接受两个函数：
- en: '`mapStateToProps(state)`: Takes the current Redux state, and returns an object
    of props to be passed to the component; used to pass state to the component'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapStateToProps(state)`: 获取当前的Redux状态，并返回一个要传递给组件的props对象；用于将状态传递给组件'
- en: '`mapDispatchToProps(dispatch)`: Takes the `dispatch` function from the Redux
    store, and returns an object of props to be passed to the component; used to pass
    action creators to the component'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapDispatchToProps(dispatch)`: 从Redux存储中获取`dispatch`函数，并返回一个要传递给组件的props对象；用于将动作创建者传递给组件'
- en: 'We are now going to define container components for our existing presentational
    components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为现有的表示性组件定义容器组件：
- en: First, we create a new `src/components/` folder for all our presentational components.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为所有我们的表示性组件创建一个新的`src/components/`文件夹。
- en: 'Then, we copy all of the existing component files to the `src/components/`
    folder, and adjust the import statements for the following files: `AddTodo.js`,
    `App.js`, `Header.js`, `TodoFilter.js`, `TodoItem.js`, and `TodoList.js`.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将所有现有的组件文件复制到`src/components/`文件夹，并调整以下文件的导入语句：`AddTodo.js`，`App.js`，`Header.js`，`TodoFilter.js`，`TodoItem.js`和`TodoList.js`。
- en: Connecting the AddTodo component
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接AddTodo组件
- en: We are now going to start connecting our components to the Redux store. The
    presentational components can stay the same as before. We only create new components—container
    components—that wrap the presentational components, and pass certain props to
    them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始连接我们的组件到Redux存储。表示性组件可以保持与以前相同。我们只创建新的组件—容器组件—将表示性组件包装起来，并向它们传递特定的props。
- en: 'Let''s connect the `AddTodo` component now:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`AddTodo`组件：
- en: Create a new `src/containers/` folder for all our container components.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有我们的容器组件创建一个新的`src/containers/`文件夹。
- en: Create a new `src/containers/ConnectedAddTodo.js` file.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/containers/ConnectedAddTodo.js`文件。
- en: 'In this file, we import the `connect` function from `react-redux`, and the
    `bindActionCreators` function from `redux`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们从`react-redux`中导入`connect`函数，从`redux`中导入`bindActionCreators`函数：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we import the `addTodo` action creator and the `AddTodo` component:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`addTodo`动作创建者和`AddTodo`组件：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we are going to define the `mapStateToProps` function. Since this component
    does not deal with any state from Redux, we can simply return an empty object
    here:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义`mapStateToProps`函数。由于这个组件不涉及Redux中的任何状态，我们可以在这里简单地返回一个空对象：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we define the `mapDispatchToProps` function. Here we use `bindActionCreators`
    to wrap the action creator with the `dispatch` function:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`mapDispatchToProps`函数。在这里，我们使用`bindActionCreators`将动作创建者与`dispatch`函数包装起来：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code is essentially the same as manually wrapping the action creators,
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本质上与手动包装动作创建者是一样的，如下所示：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we use the `connect` function to connect the `AddTodo` component to
    Redux:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`connect`函数将`AddTodo`组件连接到Redux：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, our `AddTodo` component is successfully connected to the Redux store.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`AddTodo`组件成功连接到了Redux存储。
- en: Connecting the TodoItem component
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接TodoItem组件
- en: Next, we are going to connect the `TodoItem` component, so that we can use it
    in the `TodoList` component in the next step.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将连接`TodoItem`组件，以便在下一步中在`TodoList`组件中使用它。
- en: 'Let''s connect the `TodoItem` component now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`TodoItem`组件：
- en: Create a new `src/containers/ConnectedTodoItem.js` file.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/containers/ConnectedTodoItem.js`文件。
- en: 'In this file, we import the `connect` function from `react-redux`, and the `bindActionCreators` function
    from `redux`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们从`react-redux`中导入`connect`函数，从`redux`中导入`bindActionCreators`函数：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we import the `toggleTodo` and `removeTodo` action creators, and the `TodoItem` component:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`toggleTodo`和`removeTodo`动作创建者，以及`TodoItem`组件：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Again, we only return an empty object from `mapStateToProps`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们只从`mapStateToProps`中返回一个空对象：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This time, we bind two action creators to the `dispatch` function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次，我们将两个动作创建者绑定到`dispatch`函数：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we connect the component, and export it:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们连接组件，并导出它：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, our `TodoItem` component is successfully connected to the Redux store.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`TodoItem`组件成功连接到了Redux存储。
- en: Connecting the TodoList component
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接TodoList组件
- en: After connecting the `TodoItem` component, we can now use the `ConnectedTodoItem`
    component in the `TodoList` component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 连接`TodoItem`组件之后，我们现在可以在`TodoList`组件中使用`ConnectedTodoItem`组件。
- en: 'Let''s connect the `TodoList` component now:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`TodoList`组件：
- en: 'Edit `src/components/TodoList.js`, and adjust the import statement as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/TodoList.js`，并调整导入语句如下：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, rename the component that is returned from the function to `ConnectedTodoItem`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将从函数返回的组件重命名为`ConnectedTodoItem`：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, create a new `src/containers/ConnectedTodoList.js` file.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的`src/containers/ConnectedTodoList.js`文件。
- en: 'In this file, we import only the `connect` function from `react-redux`, as
    we are not going to bind the action creators this time:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们只从`react-redux`中导入`connect`函数，因为这一次我们不打算绑定动作创建者：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we import the `TodoList` component:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`TodoList`组件：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we define the `mapStateToProps` function. This time, we use destructuring
    to get `todos` and `filter` from the `state` object, and return them:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义`mapStateToProps`函数。这一次，我们使用解构从`state`对象中获取`todos`和`filter`，然后返回它们：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we define the `mapDispatchToProps` function, where we only return an
    empty object, since we are not going to pass any action creators to the `TodoList`
    component:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`mapDispatchToProps`函数，在这里我们只返回一个空对象，因为我们不打算将任何动作创建者传递给`TodoList`组件：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we connect and export the connected `TodoList` component:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们连接并导出连接的`TodoList`组件：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, our `TodoList` component is successfully connected to the Redux store.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`TodoList`组件成功连接到了Redux存储。
- en: Adjusting the TodoList component
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整TodoList组件
- en: 'Now that we have connected the `TodoList` component, we can move the filter
    logic from the `App` component to the `TodoList` component, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了`TodoList`组件，我们可以将`App`组件中的过滤逻辑移动到`TodoList`组件中，如下所示：
- en: 'Import the `useMemo` Hook in `src/components/TodoList.js`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components/TodoList.js`中导入`useMemo` Hook：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Edit `src/components/App.js`, and remove the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/App.js`，并删除以下代码：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, edit `src/components/TodoList.js`, and add the `filteredTodos` code here.
    Please note that we removed the destructuring from the state object, as the component
    already receives the `filter` and `todos` values as props. We also adjusted the
    dependency array accordingly:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/TodoList.js`，并在这里添加`filteredTodos`代码。请注意，我们从状态对象中删除了解构，因为组件已经以props接收了`filter`和`todos`值。我们还相应地调整了依赖数组：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, our filtering logic is in the `TodoList` component, instead of the `App`
    component. Let's move on to connecting the rest of our components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的过滤逻辑在`TodoList`组件中，而不是`App`组件中。让我们继续连接其余的组件。
- en: Connecting the TodoFilter component
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接`TodoFilter`组件
- en: Next up is the `TodoFilter` component. Here, we are going to use both `mapStateToProps`
    and `mapDispatchToProps`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`TodoFilter`组件。在这里，我们将使用`mapStateToProps`和`mapDispatchToProps`。
- en: 'Let''s connect the `TodoFilter` component now:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`TodoFilter`组件：
- en: Create a new `src/containers/ConnectedTodoFilter.js` file.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/containers/ConnectedTodoFilter.js`文件。
- en: 'In this file, we import the `connect` function from `react-redux` and the `bindActionCreators` function
    from `redux`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们从`react-redux`中导入`connect`函数，从`redux`中导入`bindActionCreators`函数：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we import the `filterTodos` action creator and the `TodoFilter` component:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`filterTodos`动作创建者和`TodoFilter`组件：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We use destructuring to get the `filter` from our `state` object, and then
    we return it:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用解构从我们的`state`对象中获取`filter`，然后返回它：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we bind and return the `filterTodos` action creator:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们绑定并返回`filterTodos`动作创建者：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we connect the component and export it:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们连接组件并导出它：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, our `TodoFilter` component is successfully connected to the Redux store.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`TodoFilter`组件已成功连接到Redux存储。
- en: Connecting the App component
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接App组件
- en: The only component that still needs to be connected now, is the `App` component.
    Here, we are going to inject the `fetchTodos` action creator, and update the component
    so that it uses the connected versions of all the other components.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一还需要连接的组件是`App`组件。在这里，我们将注入`fetchTodos`动作创建者，并更新组件以使用所有其他组件的连接版本。
- en: 'Let''s connect the `App` component now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`App`组件：
- en: 'Edit `src/components/App.js`, and adjust the following import statements:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/App.js`，并调整以下导入语句：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Also, adjust the following components that are returned from the function:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要调整从函数返回的以下组件：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we can create the connected component. Create a new `src/containers/ConnectedApp.js`
    file.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建连接的组件。创建一个新的`src/containers/ConnectedApp.js`文件。
- en: 'In this newly created file, we import the `connect` function from `react-redux`,
    and the `bindActionCreators` function from `redux`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，我们从`react-redux`中导入`connect`函数，从`redux`中导入`bindActionCreators`函数：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we import the `fetchTodos` action creator, and the `App` component:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`fetchTodos`动作创建者和`App`组件：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We already deal with the various parts of our state in other components, so
    there is no need to inject any state into our `App` component:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在其他组件中处理了状态的各个部分，因此无需将任何状态注入我们的`App`组件中：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we bind and return the `fetchTodos` action creator:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们绑定并返回`fetchTodos`动作创建者：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we connect the `App` component and export it:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们连接`App`组件并导出它：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, our `App` component is successfully connected to the Redux store.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`App`组件已成功连接到Redux存储。
- en: Setting up the Provider component
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Provider组件
- en: Finally, we have to set up a `Provider` component, which is going to provide
    a context for the Redux store, which will be used by the connectors.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须设置一个`Provider`组件，它将为Redux存储提供上下文，这将被连接器使用。
- en: 'Let''s set up the `Provider` component now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置`Provider`组件：
- en: 'Edit `src/index.js`, and import the `Provider` component from `react-redux`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/index.js`，并从`react-redux`中导入`Provider`组件：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, import the `ConnectedApp` component from the `containers` folder and import
    the Redux store that was created by `configureStore.js`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`containers`文件夹中导入`ConnectedApp`组件，并导入由`configureStore.js`创建的Redux存储：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, adjust the first argument to `ReactDOM.render`, by wrapping the `ConnectedApp`
    component with the `Provider` component, as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将`ConnectedApp`组件与`Provider`组件包装起来，调整`ReactDOM.render`的第一个参数，如下所示：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, our application will work in the same way as before, but everything is
    connected to the Redux store! As we can see, Redux requires a bit more boilerplate
    code than simply using React, but it comes with a lot of advantages:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序将以与以前相同的方式工作，但一切都连接到Redux存储！正如我们所看到的，Redux需要比仅仅使用React更多的样板代码，但它带来了许多优势：
- en: Easier handling of asynchronous actions (using the `redux-thunk` middleware)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易处理异步操作（使用`redux-thunk`中间件）
- en: Centralized action handling (no need to define action creators in the components)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中的操作处理（无需在组件中定义操作创建者）
- en: Useful functions for binding action creators and combining reducers
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于绑定操作创建者和组合减速器的有用函数
- en: Reduced possibilities for errors (for example, by using action types, we can
    ensure that we did not make a typo)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少错误的可能性（例如，通过使用操作类型，我们可以确保没有拼写错误）
- en: 'However, there are also disadvantages, which are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有以下缺点：
- en: A lot of boilerplate code is required (action types, action creators, and connected
    components)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要大量的样板代码（操作类型、操作创建者和连接组件）
- en: Mapping of state/action creators in separate files (not in the components, where
    they are needed)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的文件中映射状态/操作创建者（而不是在需要它们的组件中）
- en: The first point is an advantage and disadvantage at the same time; action types
    and action creators do require more boilerplate code, but they also make it easier
    to update action-related code at a later stage. The second point, and the boilerplate
    code that is required for the connected components, can be solved by using Hooks
    to connect our components to Redux. We are going to use Hooks with Redux in the
    next section of this chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点既是优点又是缺点；操作类型和操作创建者确实需要更多的样板代码，但它们也使得以后更容易更新与操作相关的代码。第二点，以及连接组件所需的样板代码，可以通过使用Hooks来连接我们的组件到Redux来解决。我们将在本章的下一节中使用Redux与Hooks。
- en: Example code
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter12/chapter12_2` folder.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter12/chapter12_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using Redux with Hooks
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks与Redux
- en: After turning our todo application into a Redux-based application, we are now
    using higher-order components, instead of Hooks, in order to get access to the
    Redux state and action creators. This is the traditional way to develop a Redux
    application. However, in the latest versions of Redux, it is possible to use Hooks
    instead of higher-order components! We are now going to replace the existing connectors
    with Hooks.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的待办事项应用程序转换为基于Redux的应用程序后，我们现在使用高阶组件而不是Hooks来访问Redux状态和动作创建者。这是开发Redux应用程序的传统方式。但是，在Redux的最新版本中，可以使用Hooks代替高阶组件！我们现在将用Hooks替换现有的连接器。
- en: Even with Hooks, the `Provider` component is still required in order to provide
    the Redux store to other components. The definition of the store and the provider
    can stay the same when refactoring from `connect()` to Hooks.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了Hooks，`Provider`组件仍然需要，以便向其他组件提供Redux存储。当从`connect()`重构到Hooks时，存储和提供程序的定义可以保持不变。
- en: The latest version of React Redux offers various Hooks as an alternative to
    the `connect()` higher-order component. With these Hooks, you can subscribe to
    the Redux store, and dispatch actions without having to wrap your components.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的React Redux提供了各种Hooks作为`connect()`高阶组件的替代方案。使用这些Hooks，您可以订阅Redux存储，并且无需包装组件即可分派动作。
- en: Using the dispatch Hook
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dispatch Hook
- en: 'The `useDispatch` Hook returns a reference to the `dispatch` function that
    is provided by the Redux store. It can be used to dispatch actions that are returned
    from action creators. Its API looks as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDispatch` Hook返回Redux存储提供的`dispatch`函数的引用。它可以用于分派从动作创建者返回的动作。其API如下所示：'
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We are now going to use the Dispatch Hook to replace the existing container
    components with Hooks.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Dispatch Hook来替换现有的容器组件。
- en: You do not need to migrate your whole Redux application at once in order to
    use Hooks. It is possible to selectively refactor certain components—meaning that
    they will use Hooks—while still using `connect()` for other components.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要一次性迁移整个Redux应用程序以使用Hooks。可以有选择性地重构某些组件，这意味着它们将使用Hooks，同时仍然使用`connect()`来处理其他组件。
- en: After learning how to use the Dispatch Hook, let's move on to migrating our
    existing components so that they use the Dispatch Hook.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 学会如何使用Dispatch Hook后，让我们继续迁移现有组件，使它们使用Dispatch Hook。
- en: Using Hooks for the AddTodo component
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks为AddTodo组件
- en: Now that we have learned about the Dispatch Hook, let's see it in action by
    implementing it in our `AddTodo` component.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Dispatch Hook，让我们通过在`AddTodo`组件中实现它来看看它的作用。
- en: 'Let''s migrate the `AddTodo` component to Hooks now:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`AddTodo`组件迁移到Hooks：
- en: First delete the `src/containers/ConnectedAddTodo.js` file.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先删除`src/containers/ConnectedAddTodo.js`文件。
- en: 'Now, edit the `src/components/AddTodo.js` file and import the `useDispatch` Hook
    from `react-redux`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/AddTodo.js`文件并从`react-redux`中导入`useDispatch` Hook：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Additionally, import the `addTodo` action creator:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，导入`addTodo`动作创建者：
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we can remove the props from the function definition:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从函数定义中删除props：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, define the Dispatch Hook:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义Dispatch Hook：
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, adjust the handler function and call `dispatch()`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调整处理程序函数并调用`dispatch()`：
- en: '[PRE66]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, all that is left to do is to replace the `ConnectedAddTodo` component
    with the `AddTodo` component in `src/components/App.js`. First, adjust the import
    statement:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的事情就是在`src/components/App.js`中用`AddTodo`组件替换`ConnectedAddTodo`组件。首先，调整导入语句：
- en: '[PRE67]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, adjust the rendered component:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整渲染的组件：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, our app still works in the same way as before, but we are now
    using Hooks in order to connect the component to Redux!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序仍然以与以前相同的方式工作，但现在我们正在使用Hooks来连接组件到Redux！
- en: Using Hooks for the App component
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks为App组件
- en: 'Next, we are going to update our `App` component so that it directly dispatches
    the `fetchTodos` action. Let''s migrate the `App` component to Hooks now:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的`App`组件，以便直接调度`fetchTodos`动作。现在让我们将`App`组件迁移到Hooks：
- en: First delete the `src/containers/ConnectedApp.js` file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先删除`src/containers/ConnectedApp.js`文件。
- en: 'Now, edit the `src/components/App.js` file and import the `useDispatch` Hook
    from `react-redux`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/App.js`文件，并从`react-redux`导入`useDispatch` Hook：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Additionally, import the `fetchTodos` action creator:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，导入`fetchTodos`动作创建者：
- en: '[PRE70]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we can remove the props from the function definition:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从函数定义中删除props：
- en: '[PRE71]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, define the Dispatch Hook:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义Dispatch Hook：
- en: '[PRE72]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, adjust the Effect Hook and call `dispatch()`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调整Effect Hook并调用`dispatch()`：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, all that is left to do is to replace the `ConnectedApp` component with
    the `App` component in `src/index.js`. First, adjust the import statement:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，剩下的就是在`src/index.js`中用`App`组件替换`ConnectedApp`组件。首先，调整导入语句：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, adjust the rendered component:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整渲染的组件：
- en: '[PRE75]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As we can see, using Hooks is much simpler and more concise than defining a
    separate container component.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用Hooks比定义一个单独的容器组件更简单和更简洁。
- en: Using Hooks for the TodoItem component
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks为TodoItem组件
- en: 'Now, we are going to upgrade the `TodoItem` component to use Hooks. Let''s
    migrate it now:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将升级`TodoItem`组件以使用Hooks。让我们现在迁移它：
- en: First delete the `src/containers/ConnectedTodoItem.js` file.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先删除`src/containers/ConnectedTodoItem.js`文件。
- en: 'Now, edit the `src/components/TodoItem.js` file, and import the `useDispatch` Hook
    from `react-redux`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/TodoItem.js`文件，并从`react-redux`导入`useDispatch` Hook：
- en: '[PRE76]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Additionally, import the `toggleTodo` and `removeTodo` action creators:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，导入`toggleTodo`和`removeTodo`动作创建者：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we can remove the action creator-related props from the function definition.
    The new code should look as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从函数定义中删除与动作创建者相关的props。新代码应如下所示：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, define the Dispatch Hook:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义Dispatch Hook：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, adjust the handler functions to call `dispatch()`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调整处理函数以调用`dispatch()`：
- en: '[PRE80]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, all that is left to do is to replace the `ConnectedTodoItem` component
    with the `TodoItem` component in `src/components/TodoList.js`. First, adjust the
    import statement:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，剩下的就是在`src/components/TodoList.js`中用`TodoItem`组件替换`ConnectedTodoItem`组件。首先，调整导入语句：
- en: '[PRE81]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, adjust the rendered component:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整渲染的组件：
- en: '[PRE82]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now the `TodoItem` component uses Hooks instead of a container component. Next,
    we are going to learn about the Selector Hook.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`TodoItem`组件使用Hooks而不是容器组件。接下来，我们将学习有关Selector Hook的内容。
- en: Using the Selector Hook
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Selector Hook
- en: 'Another very important Hook that is provided by Redux is the Selector Hook.
    It allows us to get data from the Redux store state, by defining a selector function.
    The API for this Hook is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Redux提供的另一个非常重要的Hook是Selector Hook。它允许我们通过定义选择器函数从Redux存储状态中获取数据。该Hook的API如下：
- en: '[PRE83]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`selectorFn` is a function that works similarly to the `mapStateToProps` function.
    It will get the full state object as its only argument. The selector function
    gets executed whenever the component renders, and whenever an action is dispatched
    (and the state is different than the previous state).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectorFn`是一个类似于`mapStateToProps`函数的函数。它将完整的状态对象作为唯一参数。当组件渲染时，选择器函数将被执行，以及当动作被调度时（并且状态与先前状态不同）。'
- en: 'It is important to note that returning an object with multiple parts of the
    state from one Selector Hook will force a re-render every time an action is dispatched.
    If multiple values from the store need to be requested, we can do the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，从一个选择器 Hook 返回多个状态部分的对象将在每次分派动作时强制重新渲染。如果需要请求存储中的多个值，我们可以这样做：
- en: Use multiple Selector Hooks, each one returning a single field from the state
    object
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个 Selector Hooks，每个返回状态对象中的单个字段
- en: Use `reselect`, or a similar library, to create a memoized selector (we are
    going to cover this in the next section)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reselect`或类似的库创建一个记忆化选择器（我们将在下一节中介绍）
- en: Use the `shallowEqual` function from `react-redux` as `equalityFn`
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`react-redux`中的`shallowEqual`函数作为`equalityFn`
- en: We are now going to implement the Selector Hook in our ToDo application, specifically
    in the `TodoList` and `TodoFilter` components.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的 ToDo 应用程序中实现选择器 Hook，特别是在`TodoList`和`TodoFilter`组件中。
- en: Using Hooks for the TodoList component
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 为 TodoList 组件
- en: 'First, we are going to implement a Selector Hook to get all `todos` for the
    `TodoList` component, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现一个选择器 Hook 来获取`TodoList`组件的所有`todos`，如下所示：
- en: First delete the `src/containers/ConnectedTodoList.js` file.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先删除`src/containers/ConnectedTodoList.js`文件。
- en: 'Now, edit the `src/components/TodoList.js` file, and import the `useSelector` Hook
    from `react-redux`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/TodoList.js`文件，并从`react-redux`中导入`useSelector` Hook：
- en: '[PRE84]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we can remove all the props from the function definition:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从函数定义中删除所有的 props：
- en: '[PRE85]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, we define two Selector Hooks, one for the `filter` value, and one for
    the `todos` value:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义两个 Selector Hooks，一个用于`filter`值，一个用于`todos`值：
- en: '[PRE86]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, all that is left to do is to replace the `ConnectedTodoList` component
    with the `TodoList` component in `src/components/App.js`. First, adjust the import
    statement:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，剩下的就是在`src/components/App.js`中用`TodoList`组件替换`ConnectedTodoList`组件。首先，调整导入语句：
- en: '[PRE87]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, adjust the rendered component:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整渲染的组件：
- en: '[PRE88]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The rest of the component can stay the same, because the values where we store
    the parts of the state have the same names as before.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的其余部分可以保持不变，因为我们存储状态部分的值与以前的名称相同。
- en: Using Hooks for the TodoFilter component
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 为 TodoFilter 组件
- en: Finally, we are going to implement both the Selector and Dispatch Hooks in the
    `TodoFilter` component, because we need to highlight the current filter (state
    from the Selector Hook) and dispatch an action to change the filter (the Dispatch
    Hook).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`TodoFilter`组件中实现选择器和 Dispatch Hooks，因为我们需要突出显示当前的过滤器（来自选择器 Hook 的状态）并分派一个动作来改变过滤器（Dispatch
    Hook）。
- en: 'Let''s implement Hooks for the `TodoFilter` component now:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`TodoFilter`组件实现 Hooks：
- en: First, delete the `src/containers/ConnectedTodoFilter.js` file.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除`src/containers/ConnectedTodoFilter.js`文件。
- en: We can also delete the `src/containers/` folder, as it is empty now.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以删除`src/containers/`文件夹，因为现在它是空的。
- en: 'Now, edit the `src/components/TodoFilter.js` file, and import the `useSelector`
    and `useDispatch` Hooks from `react-redux`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/TodoFilter.js`文件，并从`react-redux`中导入`useSelector`和`useDispatch`
    Hooks：
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Additionally, import the `filterTodos` action creator:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，导入`filterTodos`动作创建者：
- en: '[PRE90]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, we can remove all the props from the function definition:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从函数定义中删除所有的 props：
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then, define the Dispatch and Selector Hooks:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义 Dispatch 和 Selector Hooks：
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, adjust the handler function to call `dispatch()`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调整处理函数以调用`dispatch()`：
- en: '[PRE93]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, all that is left to do is to replace the `ConnectedTodoFilter` component
    with the `TodoFilter` component in `src/components/App.js`. First, adjust the
    import statement:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，剩下的就是在`src/components/App.js`中用`TodoFilter`组件替换`ConnectedTodoFilter`组件。首先，调整导入语句：
- en: '[PRE94]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, adjust the rendered component:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整渲染的组件：
- en: '[PRE95]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now, our Redux application makes full use of Hooks instead of container components!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的Redux应用程序完全使用Hooks而不是容器组件！
- en: Example code
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter12/chapter12_3` folder.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter12/chapter12_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Creating reusable selectors
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的选择器
- en: When defining selectors as we have done until now, a new instance of the selector
    is created every time the component is rendered. This is fine, if the selector
    function does not do any complex operations and does not maintain internal state.
    Otherwise, we need to use reusable selectors, which we are going to learn about
    now.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义选择器时，我们一直以来都是在每次组件渲染时创建选择器的新实例。这是可以的，如果选择器函数不执行任何复杂操作并且不维护内部状态。否则，我们需要使用可重用的选择器，现在我们将学习有关它们的知识。
- en: Setting up reselect
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置reselect
- en: 'In order to create reusable selectors, we can use the `createSelector` function
    from the `reselect` library. First, we have to install the library via `npm`.
    Execute the following command:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建可重用的选择器，我们可以使用`reselect`库中的`createSelector`函数。首先，我们必须通过`npm`安装该库。执行以下命令：
- en: '[PRE96]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now, the `reselect` library has been installed, and we can use it to create
    reusable selectors.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`reselect`库已经安装，我们可以使用它来创建可重用的选择器。
- en: Memoizing selectors that only depend on state
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对仅依赖于状态的选择器进行记忆化
- en: 'If we want to memoize selectors, and the selector only depends on the state
    (not props), we can declare the selector outside of the component, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要记忆化选择器，并且选择器仅依赖于状态（而不是props），我们可以在组件外部声明选择器，如下所示：
- en: 'Edit the `src/components/TodoList.js` file, and import the `createSelector`
    function from `reselect`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/TodoList.js`文件，并从`reselect`中导入`createSelector`函数：
- en: '[PRE97]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, we define selectors for the `todos` and `filter` parts of the state,
    before the component definition:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在组件定义之前，我们为状态的`todos`和`filter`部分定义选择器：
- en: '[PRE98]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If selectors are used by many components, it might make sense to put them in
    a separate `selectors.js` file, and import them from there. For example, we could
    put the `filterSelector` in a separate file, and then import it in `TodoList.js`,
    as well as `TodoFilter.js`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择器被许多组件使用，将它们放在单独的`selectors.js`文件中并从那里导入可能是有意义的。例如，我们可以将`filterSelector`放在一个单独的文件中，然后在`TodoList.js`以及`TodoFilter.js`中导入它。
- en: 'Now, we define a selector for the filtered todos, before the component is defined,
    as follows:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在定义组件之前，我们为过滤后的todos定义一个选择器，如下所示：
- en: '[PRE99]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'First, we specify the other two selectors that we want to reuse:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们指定要重用的另外两个选择器：
- en: '[PRE100]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we specify a filtering selector, copying the code from the `useMemo` Hook:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们指定一个过滤选择器，从`useMemo` Hook中复制代码：
- en: '[PRE101]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we use our defined selector in the Selector Hook:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在选择器钩子中使用我们定义的选择器：
- en: '[PRE102]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Now that we have defined a reusable selector for the filtered todos, the result
    of filtering the todos will be memoized, and will not be re-computed if the state
    did not change.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为过滤后的todos定义了一个可重用的选择器，过滤todos的结果将被记忆化，如果状态没有改变，将不会重新计算。
- en: Example code
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter12/chapter12_4` folder.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter12/chapter12_4`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using the store Hook
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用store Hook
- en: 'React Redux also provides a `useStore` Hook, which returns a reference to the
    Redux store itself. This is the same `store` object that was passed to the `Provider`
    component. Its API looks like this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: React Redux还提供了一个`useStore` Hook，它返回对Redux存储本身的引用。这是传递给`Provider`组件的相同`store`对象。其API如下：
- en: '[PRE103]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: It is best practice to avoid using the Store Hook directly. It usually makes
    more sense to use Dispatch or Selector Hooks instead. However, there are special
    use cases, such as replacing reducers, where using this Hook may be required.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是避免直接使用Store Hook。通常更有意义的是使用Dispatch或Selector Hooks。但是，也有特殊情况，比如替换reducer，可能需要使用这个Hook。
- en: In this section, we have learned how to replace connectors with Hooks in existing
    Redux applications. Now, we are going to learn a strategy that will allow us to
    effectively migrate existing Redux applications to Hooks.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经学会了如何在现有的Redux应用程序中用Hooks替换连接器。现在，我们将学习一种策略，可以有效地将现有的Redux应用程序迁移到Hooks。
- en: Migrating a Redux application
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移Redux应用程序
- en: 'In some Redux applications, local state was also stored in the Redux state
    tree. In others, React class component state was used to store local state. In
    either case, the way to migrate an existing Redux application is as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些Redux应用程序中，本地状态也存储在Redux状态树中。在其他情况下，React类组件状态用于存储本地状态。在任何情况下，迁移现有的Redux应用程序的方法如下：
- en: Replace **simple local state**, such as input field values, with State Hooks
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用状态钩子替换**简单的本地状态**，比如输入字段的值
- en: Replace **complex local state** with Reducer Hooks
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Reducer Hooks替换**复杂的本地状态**
- en: Keep **global state** (state that is used across multiple components) in the
    Redux store
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**全局状态**（在多个组件中使用的状态）存储在Redux存储中
- en: We have already learned how to migrate React class components in the previous
    chapter. In the previous section, we learned how to migrate from Redux connectors
    to using Selector and Dispatch Hooks. We are now going to show an example of migrating
    Redux local state to a Hook-based approach.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经学会了如何迁移React类组件。在上一节中，我们学会了如何从Redux连接器迁移到使用Selector和Dispatch Hooks。现在，我们将展示一个将Redux本地状态迁移到基于Hook的方法的示例。
- en: 'Let us assume that our existing todo application stores the input field state
    in Redux, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现有的待办事项应用程序将输入字段状态存储在Redux中，如下所示：
- en: '[PRE104]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Right now, whenever text is entered, we need to dispatch an action, compute
    the new state by calling all reducers, and then update the Redux store state.
    As you can imagine, this can get quite performance heavy if we have many input
    fields. Instead of storing the `newTodo` field in Redux, we should use a State
    Hook to store this local state, as it is only used internally by one component. We
    have already done this correctly during the implementation of the `AddTodo` component
    in our example app.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当输入文本时，我们需要分派一个动作，通过调用所有的reducer来计算新的状态，然后更新Redux存储状态。可以想象，如果有很多输入字段，这可能会导致性能问题。 我们应该使用状态钩子来存储这个本地状态，因为它只在一个组件内部使用。在我们的示例应用程序中，我们在实现`AddTodo`组件时已经正确地做到了这一点。
- en: Now that we have learned how to migrate existing Redux applications to Hooks,
    we can move on to discussing the trade-offs of Redux.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将现有的Redux应用程序迁移到Hooks，我们可以继续讨论Redux的权衡。
- en: Trade-offs of Redux
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux的权衡
- en: 'To wrap up, let us summarize the pros and cons of using Redux in a web application.
    First, let us start with the positives:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，让我们总结一下在Web应用程序中使用Redux的利弊。首先，让我们从积极的方面开始：
- en: Provides a certain project structure that allows us to easily extend and modify
    code later on
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一定的项目结构，使我们可以轻松地扩展和修改代码
- en: Fewer possibilities for errors in our code
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码中出错的可能性较少
- en: Better performance than using React Context for state
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比使用React Context进行状态管理性能更好
- en: Makes the `App` component much simpler (offloads state management and action
    creators to Redux)
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 `App` 组件更简单（将状态管理和操作创建者卸载到 Redux）
- en: Redux is a perfect fit for larger projects that deal with complex state changes,
    and state that is used across many components.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是处理复杂状态变化和在许多组件中使用的状态的较大项目的完美选择。
- en: 'However, there are also downsides to using Redux:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用 Redux 也有缺点：
- en: Writing boilerplate code required
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要编写样板代码
- en: Project structure becomes more complicated
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构变得更加复杂
- en: Redux requires a wrapper component (`Provider`) to connect the app to the store
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 需要一个包装组件（`Provider`）来连接应用程序到存储
- en: As a result, Redux should not be used for simple projects. In these cases, a
    Reducer Hook might be enough. With a Reducer Hook, there is no need for wrapper
    components in order to connect our app to the state store. Furthermore, if we
    use multiple Reducer Hooks, it is slightly more performant to send actions to
    a specific reducer, instead of a global app reducer. However, the downside lies
    in having to deal with multiple dispatch functions, and keeping the various states
    synchronized. We also cannot use middleware, including support for asynchronous
    actions, with a Reducer Hook. If state changes are complex but only local to a
    certain component, it might make sense to use a Reducer Hook, but if the state
    is used throughout multiple components, or it is relevant for the whole app, we
    should definitely store it in Redux.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Redux 不应该用于简单的项目。在这些情况下，Reducer Hook 可能就足够了。使用 Reducer Hook，我们无需包装组件来连接我们的应用程序到状态存储。此外，如果我们使用多个
    Reducer Hook，向特定的 reducer 发送操作稍微更有效，而不是全局应用程序 reducer。然而，缺点在于必须处理多个 dispatch 函数，并保持各种状态同步。我们也不能使用中间件，包括对
    Reducer Hook 的异步操作的支持。如果状态变化复杂但仅局限于某个组件，可能使用 Reducer Hook 是有意义的，但如果状态在多个组件中使用，或者对整个应用程序都很重要，我们应该将其存储在
    Redux 中。
- en: 'You might not need Redux if your component does not do the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组件不执行以下操作，则可能不需要 Redux：
- en: Use the network
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络
- en: Save or load state
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存或加载状态
- en: Share state with other non-child components
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他非子组件共享状态
- en: In that case, it makes sense to use a State or Reducer Hook, instead of Redux.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用状态或 Reducer Hook 而不是 Redux 是有意义的。
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we first learned what Redux is, as well as when and why it should
    be used. Then, we learned about the three principles of Redux. Next, we used Redux
    in practice to handle state in our ToDo application. We also learned about synchronous
    and asynchronous action creators. Then, we learned how to use Redux with Hooks,
    and how to migrate an existing Redux application to a Hook-based solution. Finally,
    we learned about the trade-offs of using Redux and Reducer Hooks.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了 Redux 是什么，以及何时以及为什么应该使用它。然后，我们学习了 Redux 的三个原则。接下来，我们在实践中使用 Redux
    处理我们的 ToDo 应用程序中的状态。我们还学习了同步和异步操作创建者。然后，我们学习了如何使用 Hooks 使用 Redux，以及如何将现有的 Redux
    应用程序迁移到基于 Hook 的解决方案。最后，我们了解了使用 Redux 和 Reducer Hook 的权衡。
- en: In the next and final chapter, we are going to learn about handling state with
    MobX. We are going to learn what MobX is and how to use it the traditional way
    with React. Then, we are going to learn how to use MobX with Hooks, and we will
    also understand how to migrate an existing MobX application to a Hook-based solution.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 MobX 处理状态。我们将学习 MobX 是什么，以及如何以传统方式与 React 一起使用它。然后，我们将学习如何使用
    Hooks 使用 MobX，并且我们还将了解如何将现有的 MobX 应用程序迁移到基于 Hook 的解决方案。
- en: Questions
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章学到的内容，请尝试回答以下问题：
- en: What kind of state should Redux be used for?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux 应该用于哪种状态？
- en: Which elements does Redux consist of?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux 由哪些元素组成？
- en: What are the three principles of Redux?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux的三大原则是什么？
- en: Why do we define action types?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要定义动作类型？
- en: How can we connect components to Redux?
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将组件连接到Redux？
- en: Which Hooks can we use with Redux?
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些Hooks与Redux？
- en: Why should we create reusable selectors?
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该创建可重用的选择器？
- en: How can we migrate a Redux application?
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何迁移Redux应用程序？
- en: What are the trade-offs of Redux?
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux的权衡是什么？
- en: When should we use Redux?
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们什么时候应该使用Redux？
- en: Further reading
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following reading material:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章学习的概念更多信息感兴趣，请查看以下阅读材料：
- en: '*Learning Redux*, published by *Packt: *[ https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Redux*，由*Packt*出版：[https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)'
- en: Official Redux docs: [https://redux.js.org](https://redux.js.org)
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Redux文档：[https://redux.js.org](https://redux.js.org)
- en: Official React-Redux docs: [https://react-redux.js.org/](https://react-redux.js.org/)
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方React-Redux文档：[https://react-redux.js.org/](https://react-redux.js.org/)
- en: Information about Hooks and Redux: [https://react-redux.js.org/next/api/hooks](https://react-redux.js.org/next/api/hooks)
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Hooks和Redux的信息：[https://react-redux.js.org/next/api/hooks](https://react-redux.js.org/next/api/hooks)
- en: Reselect library on GitHub: [https://github.com/reduxjs/reselect](https://github.com/reduxjs/reselect)
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的Reselect库：[https://github.com/reduxjs/reselect](https://github.com/reduxjs/reselect)
