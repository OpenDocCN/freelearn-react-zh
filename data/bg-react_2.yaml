- en: Creating Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to implement React components, how
    to assemble multiple components into one, and how to manage their internal states.
    We will explore React component implementation by building a simple application.
    This application will be implemented step-by-step, in order to put the outlined
    concepts into practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create basic React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JSX to define a component's markup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine multiple React components in order to create complex UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the internal state of React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definition of a Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As defined in the previous chapter, components are the fundamental building
    blocks of React. Virtually any visual item in a user interface can be a component. From
    a formal point of view, we would say that a React component is a piece of JavaScript
    code defining a portion of a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is an ECMAScript 2015 module, defining a basic React component.
  prefs: []
  type: TYPE_NORMAL
- en: It imports the `React` namespace from the `react` module and defines the `Catalog` class
    by extending the `React.Component` class. The module exports the `Catalog` class
    as a default export.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part of this definition is the implementation of the `render()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render()` method defines the visual part of the component. It may execute
    any JavaScript code, and it should return a markup expression defining its visual
    output. The presence of the `render()` method is mandatory for React components. In
    our example, the `render()` method returns the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It looks like HTML; although it uses similar syntax, it defines plain objects
    called **elements**. React elements are similar to **Document Object Model** (**DOM**)
    elements, but are lighter and more efficient. So, React components generate a
    set of React elements that will be mapped to DOM elements by the library's engine.
    This set of React elements is called the **Virtual DOM**, a lightweight representation
    of the browser's DOM. React takes care of updating the DOM to match the Virtual
    DOM, only when it is strictly necessary. This approach allows React to have very
    high performance when rendering user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render()` method must comply with a few constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: It is mandatory; that is, every React component must implement it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must return one React element; that is, a single markup item with any nested
    elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be a pure function; that is, it should not change the internal state of
    the component (we will discuss this topic in further detail in the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should not directly interact with the browser; that is, it shouldn't contain statements
    that try to access the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pure function is a function whose output result depends only on its input data,
    and its execution has no side effect, like, for example, updating a global variable.
    Given an input value, a pure function always returns the same result.
  prefs: []
  type: TYPE_NORMAL
- en: A pure component is a component that acts like a pure function. This means that,
    given the same initial conditions, it always renders the same output. It is very
    important to keep the `render()` method a pure function. This avoids weird bugs,
    as we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined our component, we can use it as a React element inside
    any other React component. For example, we know that the React application itself
    is already a React component. Let''s recall the code generated by the `create-react-app` tool
    in the `App.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this code has the same structure as the `Catalog` component
    that we defined. Let''s change this code in order to use our component inside
    of the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We simplified the code by removing some of the automatically generated markup. We
    then imported the `Catalog` component, and put the `<Catalog />` element inside the
    `<div>` element returned by the app's `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Building Our First React Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps open the existing project, `my-shop-01`, in order to show
    the result of the previous code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-1` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an example of what we will see in a browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/888b626e-0f78-4346-9515-29ba28498237.png)'
  prefs: []
  type: TYPE_IMG
- en: We have built our first React component, and we can see it in action!
  prefs: []
  type: TYPE_NORMAL
- en: Managing Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps you have noticed that we have an `import` statement concerning a CSS
    file in the `App` component module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This may seem a bit strange, since `import` statements should only work for
    JavaScript code. However, thanks to the development environment provided by `create-react-app`, we
    can use the same syntax, even for CSS files. This allows us to use the classes and
    other CSS definitions defined in `App.css` in our component, keeping component-specific styles
    close to the component definition itself. For example, if we want our `Catalog`
    component to have the title in red, we can proceed as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now change the content of the existing project, `my-shop-01`, in order
    to add some CSS code and show the catalog title in red:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-1/src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file, `Catalog.css`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Catalog.js` file and add the statement to import the `Catalog.css` module,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run `npm start` and look at the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find a project ready in the `my-shop-02` folder at `Code/Chapter-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser will show the Catalog title in red:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e2fe10c-32de-4a03-8f13-3a1ebfa19cc5.png)The CSS import is not a
    React feature, and it is not required by React. It is a convenience provided by
    the development environment, built by `create-react-app`. In particular, this
    feature is provided by **webpack**, one of the most frequently used bundlers and
    module loaders.'
  prefs: []
  type: TYPE_NORMAL
- en: You should take this aspect into account when you want to migrate the application
    into a development environment not based on webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Defining a Shopping Cart'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: We need a shopping cart for our e-shop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to start using React to define a component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: We should define a React component that acts as the basis of a shopping cart
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be a component that simply shows the string `Cart`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new React application by using `create-react-app`, and change the application,
    as shown in the current section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-01` folder at `Code/Chapter-2/`.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous examples, we defined the visual output returned by the `render()` method
    of a component by using an HTML-like markup expression. Let''s see, for example,
    the definition of the `Catalog` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The markup expression is not using JavaScript syntax, but it is included inside
    of a JavaScript code snippet. Why do we mix HTML and JavaScript syntaxes? How
    is that possible?
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by saying that the HTML-like language describing the React component's visual
    output is called **JSX**. This language extends JavaScript with XML expressions in
    order to simplify the creation of HTML elements within JavaScript code. You may think
    of it as a sort of `document.write("...")`, but much more powerful. In fact, when
    building a React application, the JSX markup is pre-processed by a specific parser,
    in order to produce pure JavaScript code. So, we can exploit the simplicity of
    using a declarative markup language that will automatically be converted into optimized
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, a JSX expression creates a React element, which is
    the counterpart of an HTML element. From a syntactical point of view, a JSX expression
    is a single markup item with any nested elements. So, the following is a valid
    JSX expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is not a valid JSX expression, since it contains two markup items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JSX expressions are XML fragments, so they are compliant with XML syntax rules.
    This means that, among other things, the markup is case-sensitive, and all of
    the tags must be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following JSX expression is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<img src="image.png">`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its valid version is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<img src="image.png"/>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign a JSX expression to a variable, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also embed any JavaScript expression inside of a JSX expression by wrapping it
    in curly braces, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the JavaScript expression can be as complex as we need it to be,
    like in the following component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In addition to optimizing output rendering, JSX also provides support to prevent
    injection attacks. In fact, any value embedded in a JSX expression escapes before
    being rendered. This, for example, prevents malicious code from being inserted
    by a user's input.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use of a combination of JavaScript and JSX expressions is called **conditional
    rendering**; that is, a technique that allows you to generate a JSX expression
    based on some Boolean conditions. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `render()` method returns one message or another, according
    to the current day of the week. This causes the generation of a React element
    with a different message and CSS class, but we could even return a completely
    different markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can put a JSX expression in multiple lines, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very important when returning a JSX expression to start it in the same
    line of the `return` statement, as in the previous example. If you want to start
    the JSX expression on a new line, you need to enclose it in round brackets and
    put the left bracket on the same line as the `return` statement, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`return (`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  <div>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    <h2>Catalog</h2>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  </div>);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can put comments inside of a JSX expression by using the JavaScript syntax wrapped
    in curly brackets. The following is an example of a JSX expression with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'JSX tags match HTML tags, which is why we can use the whole HTML syntax to define
    JSX elements. However, there are a few restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: All HTML tags are in lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to use `className` instead of the `class` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to use `htmlFor` instead of the `for` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows the use of the `className` attribute instead of
    `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: JSX uses the `className` and `htmlFor` attributes instead of `class` and `for`
    because as JSX expressions are inside JavaScript, `class` and `for` could clash
    with the corresponding reserved keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Translating HTML into JSX'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: The Graphics department has provided you with an HTML snippet, and you need
    to translate it into JSX in order to create a React component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to understand the difference between HTML and JSX.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Code02.txt` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the HTML code it contains into JSX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `activity-b.html` file at `Code/Chapter-2/`.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining React components, we can use them as the children of another component
    by using that component as a React element. We already saw this when we included
    the `Catalog` component inside of the `App` component, but let's analyze this
    composition further.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now see how to combine components in order to create new, complex components:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `src/ProductList.js` file in the `my-shop-03` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the text until the end of the section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s consider the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This component defines a list of wines, names, and descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to integrate our `Catalog` component with the wine list. Since we have created
    the `ProductList` component, we can use it as a tag in the JSX markup of the `Catalog`
    component, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we simply imported the `ProductList` component in order to make
    it available inside the `Catalog` component's module, and we used the `ProductList`
    tag where we wanted the wine list to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `npm start` to launch the application. The resulting page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/772ab3c7-0d0d-49dc-b8cf-08cb9a057d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: We said that the HTML tags in JSX expressions should always be in lowercase.
    However, we used the `ProductList` tag in Pascal case.
  prefs: []
  type: TYPE_NORMAL
- en: Tags corresponding to components must follow the case used in the class definition,
    and by convention, component class names use Pascal case, even though it is not
    required by React.
  prefs: []
  type: TYPE_NORMAL
- en: The ease of composing React components makes it very simple to create user interfaces,
    following the guidelines provided in the previous chapter. We can decompose a
    page layout into a hierarchical set of components, each one consisting of other
    components. This approach allows us to focus on the behavior of a single component,
    and promotes its reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Defining a Composed Cart'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to create some content for our shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to compose React components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Integrate the previously created `Cart` component in order to contain a `CartList` component,
    showing two items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-02` folder at `Code/Chapter-2/`.
  prefs: []
  type: TYPE_NORMAL
- en: Data Propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ProductList` component that we defined in the previous section is impractical. Let''s
    take a look at it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The list items are all defined as JSX markup, so if you need to change the graphical appearance
    of the catalog's product, you need to change all of the occurrences of each `<li>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a better implementation by going further in the user interface decomposition.
    We can consider each list item as a component, and the `Product` component as
    the one defined by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code acts as a template for each list item, so that we can build our product
    list dynamically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see the definition of an array of objects, `products`, containing the
    relevant data for each product. The second array, `productComponents`, will contain
    the list of React components created by merging product data with the `Product`
    component's markup. The `for` loop is intended to perform such merging. Finally,
    the resulting `productComponents` array, surrounded by the `<ul>` element, will
    be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the code structure appears to be correct, the result will not be as
    expected. In fact, we will obtain a list of items with the fixed names and descriptions
    that we put in the `Product` component definition. In other words, the merge between
    data and component definition didn't happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we need a way to pass the data of each product to the `Component`
    class. Let''s think of React components as plain JavaScript functions. They may
    be implemented as functions returning React elements, and, as with any function,
    components may have data input. Such data input is passed through JSX attributes,
    and is accessible inside of a component through a special object called `**props**`.
    Let''s change the `ProductList` component''s code in order to pass data through
    JSX attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We added an `item` attribute to the `<Product>` tag and assigned a single object
    from the `products` array to it. This allows us to pass the data of each product
    to the `Product` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we modify the `Product` component''s code in order to receive
    and manage the passed data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can find a project ready in the `my-shop-04` folder at `Code/Chapter-2/`.
  prefs: []
  type: TYPE_NORMAL
- en: Every React component has a `props` property. The purpose of this property is to
    collect data input passed to the component itself. Whenever a JSX attribute is attached
    to a React element, a property with the same name is attached to the `props` object.
    So, we can access the passed data by using the attached property. In our example,
    we found the product data passed via the `item` attribute mapped to the `this.props.item`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '`props` are immutable; that is, they are read-only properties.'
  prefs: []
  type: TYPE_NORMAL
- en: This new implementation allows the catalog to be shown as before, but makes graphical
    markup independent from a product's data.
  prefs: []
  type: TYPE_NORMAL
- en: In a component hierarchy, data propagation is very important. It allows us to think
    about components as functions with inputs and outputs. In addition, the immutability
    of `props` allows us to think of components as pure functions, which are functions
    that have no side effects (since they don't change their input data). We can think
    of data passing from one component to another as a **unidirectional data ****flow**,
    from the parent component toward the child components. This gives us a more controllable
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how we would imagine the data propagation in a component
    hierarchy, ideally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4e8e2c52-6d4e-4ebc-969a-497971c28dfb.png)'
  prefs: []
  type: TYPE_IMG
- en: A change in the state causes a data propagation toward the child components
    through the `props` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Creating a Cart Item Component'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to make the `CartList` component a dynamic component, so that it can adapt
    its content to received data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to compose React components and pass data between them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `CartItem` component showing the name of an item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the previously created `CartList` component so that it is dynamically composed
    of `CartItem` instances, based on an `items` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-03` folder at `Code/Chapter-2`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Internal State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components have the ability to store data that can change over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a component shows data that can change over time, we want changes to be shown
    as soon as possible. For example, consider the `ProductList` component: it shows
    a list of products contained in the `products` array. If a new product is added to
    the array, we want it to be shown immediately. React provides a mechanism to support
    the automatic rendering of a component when data changes. Such a mechanism is
    based on the concept of **state**.'
  prefs: []
  type: TYPE_NORMAL
- en: React `state` is a property that represents data that changes over time. Every component
    supports the `state` property, but it should be used carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, consider the `ProductList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From a practical point of view, it is not so useful. It shows a hardcoded list
    of products. If we want to add a new product, we need to make changes to the component
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real-world scenario, we want to keep the component''s code independent
    from the product data. For example, we would get product data by making an HTTP request
    to the web server. In this case, the `products` array would represent data that changes
    over time: initially an empty array, it would then be filled with product data received
    from the server, and it could be changed again by subsequent requests to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Components that store data that can change over time are said to be **stateful components**. A
    stateful component stores the state in the `this.state` property. To inform a component
    that the state has changed, you must use the `setState()` method. This method
    sets a new state for the component; it does not update it. Changes to the state trigger
    the component's rendering; that is, the automatic execution of the `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to manage the state by changing the `ProductList` component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We added the constructor to the component. The constructor runs the superclass constructor
    and sets the initial state of the component to an object with the `products` property
    as an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Then, send a GET HTTP request to the server via `fetch()`. Since the request
    is asynchronous, the initial rendering of the component will be an empty list
    of products.
  prefs: []
  type: TYPE_NORMAL
- en: State initialization is the only case where you can assign a value to the `this.state`
    property without using `setState()`.
  prefs: []
  type: TYPE_NORMAL
- en: When the HTTP response is received, it is used to change the component's state
    with `setState()`. This state change causes the automatic execution of `render()`,
    which will show the list of products received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to manage the component''s state, here are a couple of
    things to remember when using the `setState()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setState()` merges new data with old data already contained in the state, and
    overwrites the previous state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setState()` triggers the execution of the `render()` method, so you should never
    call `render()` explicitly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component state management appears to be very simple. However, it is easy to
    get in trouble when deciding what should be considered state and which component
    should be stateful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some advice about state:'
  prefs: []
  type: TYPE_NORMAL
- en: State should contain the minimum data needed to represent data that can change
    over time in your UI; any information that can be derived from this minimal data
    should be computed inside the `render()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State should be avoided as much as possible, since it adds complexity to a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful components should be located high up in the component hierarchy of
    a UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can consider the last piece of advice a consequence of the second piece of advice.
    If we should restrict the usage of state, we should reduce the number of stateful
    components. So, it is a good rule to assign the role of stateful component to
    components that are the root of a component hierarchy in a user interface. Do you
    remember the classification of components into presentational and container components,
    which we discussed in the previous chapter? In general, container components are
    good candidates for stateful components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example application, we assigned the role of a stateful component to
    the `ProductList` component. Even if it is a container component, it is not the
    highest in the component hierarchy of the application. Maybe this role would be
    more appropriate for the `Catalog` component. In this case, we should move the
    logic of getting data inside of the `Catalog` component, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can find a project ready in the `my-shop-05` folder at `Code/Chapter-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Adding State Management to the Cart Component'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the `Cart` component production ready, we add state management and
    dynamic data loading.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to become familiar with component state management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Change the previously created `Cart` component to add state management, so that data
    is loaded via HTTP requests, and the contents of the cart is automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-04` folder at `Code/Chapter-2/`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started to create React components and explored their basic features.
    In particular, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned how to define a component as a class derived from `React.Component`,
    and how to import specific CSS styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored the syntax of JSX, which allows us to quickly define the graphical aspect
    of a component and use React components that were defined elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combined React components in order to build other components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used state management features so that React components automatically update
    their visual representation when data changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will analyze how to manage user interaction with a React-based
    application; in other words, how to capture events and make a UI react to those events.
  prefs: []
  type: TYPE_NORMAL
