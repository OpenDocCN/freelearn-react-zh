- en: Store Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储模式
- en: The patterns built around virtual stores in JavaScript contain everything that
    is needed to decide what to show in an application. In my opinion, it is the most
    important piece necessary to understand Flux well, hence, I have dedicated a special
    chapter to store patterns, to go through many examples and compare alternatives.
    As React Native applications usually need to work offline, we will also learn
    how to transition our JavaScript store into a persistent store on a user's mobile
    device. This will take our application to the next level when it comes to user
    experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕JavaScript虚拟存储构建的模式包含了决定应用程序中显示什么的一切所需内容。在我看来，这是理解Flux的最重要的部分，因此，我专门为存储模式撰写了一个特别的章节，以便通过许多示例并比较替代方案。由于React
    Native应用程序通常需要离线工作，我们还将学习如何将我们的JavaScript存储转换为用户移动设备上的持久存储。这将在用户体验方面将我们的应用程序提升到一个新的水平。
- en: 'In this chapter, you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到以下内容：
- en: How to integrate Redux into your Flux architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Redux集成到您的Flux架构中
- en: How Redux differs from classic Flux and the benefits of the new approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux与经典Flux的不同之处以及新方法的好处
- en: The core principles of Redux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux的核心原则
- en: How to create a store that will be a single source of truth
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个将成为唯一真相来源的存储
- en: What effect patterns and side effects are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果模式和副作用是什么
- en: Using Redux stores
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux存储
- en: It took me a while to figure out how to advertise Redux to you. Most likely,
    you expect it is some sort of Store implementation that will be used within Flux.
    This is true; however, there is more to it than that. Redux is a brilliant piece
    of code that makes a great tool. This tool can be used in many ways in many different
    projects. In this book, I strive to teach you to think in React and Redux.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了一段时间才弄清楚如何向您宣传Redux。您很可能期望它是一种在Flux中使用的存储实现。这是正确的；但是，Redux不仅仅是这样。Redux是一段精彩的代码，是一个很棒的工具。这个工具可以在许多不同的项目中以许多不同的方式使用。在这本书中，我致力于教会您如何在React和Redux中思考。
- en: This introduction was inspired by a useful talk from Cheng Lou, called *Taming
    the Meta Language*, and delivered at React Conf 2017.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个介绍受到了Cheng Lou在React Conf 2017上发表的有用演讲*Taming the Meta Language*的启发。
- en: Watch it at [https://goo.gl/2SkWAj](https://goo.gl/2SkWAj).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://goo.gl/2SkWAj](https://goo.gl/2SkWAj)观看。
- en: Minimal Redux application example
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux应用程序的最小示例
- en: Before I show you the Redux architecture, let's see it in action. It is vital
    to get a feeling for what the Redux API looks like. Once we develop the simplest
    hello world app in Redux, we will move on to a more high-level overview.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向您展示Redux架构之前，让我们看看它的实际运行情况。了解Redux API的外观至关重要。一旦我们在Redux中开发了最简单的hello world应用程序，我们将进行更高级的概述。
- en: The hello world app we will be building is a counter app, as simple as two buttons
    (increase and decrease) and a text indicating the current count.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的hello world应用程序是一个计数器应用程序，只有两个按钮（增加和减少）和一个显示当前计数的文本。
- en: 'Before we dive in, let''s install two packages using the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们使用以下命令安装两个软件包：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Okay, first, let''s create some basic Flux pieces that we already know, but
    this time using the Redux API:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，首先，让我们创建一些基本的Flux部分，这些部分我们已经知道，但这次使用Redux API：
- en: '`ActionTypes`:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActionTypes`：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Store`:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pay attention to two new words—`Reducer` and `rootReducer`. `rootReducer` combines
    all other reducers into one. `Reducer` is responsible for generating new versions
    of the state based on the action that has happened. Reducers can also return the
    old version of state if the current action is not relevant to the particular `Reducer`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个新词——`Reducer`和`rootReducer`。`rootReducer`将所有其他reducer组合成一个。`Reducer`负责根据已发生的操作生成状态的新版本。如果当前操作与特定的`Reducer`不相关，Reducer也可以返回旧版本的状态。
- en: '`CounterReducer`:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CounterReducer`：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Dispatcher`:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatcher`：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great, we have all the Flux pieces, so we can now move on to the actual implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经有了所有的Flux组件，所以现在可以继续实际的实现了。
- en: 'Let''s start with simple things first, the view. It should display two `Button` and
    one `Text` components. On a button press, the counter should be increased or decreased,
    as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从简单的事情开始，视图。它应该显示两个`Button`和一个`Text`组件。在按钮按下时，计数器应该增加或减少，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s time to provide the necessary dependencies to the view: the `inc`, `dec`,
    and `counter` props. The first two are rather straightforward:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向视图提供必要的依赖项了：`inc`，`dec`和`counter`属性。前两个非常简单：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we pass them to the view. Here, a number of specific Redux API components
    will be used. `Provider` is used to provide `store` to connect calls. This is
    optional—if you really want to do this manually, you can pass `store` directly
    to `connect`. I highly recommend using `Provider. Connect` to create a facade
    around the dispatch and state. In case of state changes, the component will be
    automatically re-rendered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将它们传递给视图。在这里，将使用许多特定的Redux API组件。`Provider`用于提供`store`以连接调用。这是可选的 - 如果您真的想手动执行此操作，可以直接将`store`传递给`connect`。我强烈建议使用`Provider.Connect`来创建一个围绕分发和状态的facade。在状态更改的情况下，组件将自动重新渲染。
- en: Facade is another pattern entirely. It is a structural design pattern created
    to interact with complex APIs. If the typical user is not interested in all of
    the capabilities, it is handy to provide a function with some defaults already
    preset on behalf of the user. Such a function is called a `facade` function and
    is also exposed in the API. The end user can use it a lot quicker, with none of
    the additional deep-diving that is required for complex and optimized projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Facade是另一种完全不同的模式。它是一种结构设计模式，用于与复杂的API进行交互。如果典型用户对所有功能都不感兴趣，提供一个带有一些默认设置的函数对用户来说非常方便。这样的函数被称为`facade`函数，并且也在API中公开。最终用户可以更快地使用它，而无需进行复杂和优化项目所需的深入挖掘。
- en: 'Check how to use `Provider` and `Connect` in the following snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中检查如何使用`Provider`和`Connect`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's it. We have completed the first Redux application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经完成了第一个Redux应用程序。
- en: How Redux fits into Flux
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux如何适配Flux
- en: 'The steps we performed to create a `Counter` app involved connecting Flux pieces.
    Let''s look at the diagram we used:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的步骤创建了一个`Counter`应用程序，涉及连接Flux组件。让我们看看我们使用的图表：
- en: '![](Images/4d9f0c18-5054-4873-95bf-e1b3e4db7a68.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4d9f0c18-5054-4873-95bf-e1b3e4db7a68.png)'
- en: First of all, we have **Actions** that are dispatched. Then the root `Reducer`
    function is run and each reducer determines whether the state needs to be changed
    or not. The root **Reducer** returns a new version of **State** and the state
    is passed to the **View** root. The `connect` function determines whether a particular
    view should be re-rendered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有**Actions**被分发。然后运行根`Reducer`函数，并且每个reducer确定是否需要更改状态。根**Reducer**返回一个新版本的**State**，并且状态传递给**View**根。`connect`函数确定是否应重新渲染特定视图。
- en: Please note that the previous diagram follows the Flux architecture. The actual
    Redux implementation, as you could spot in the Counter example, is a little different.
    The dispatcher is encapsulated by the Store API and exposed as a `store` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的图表遵循Flux架构。实际的Redux实现，正如您在计数器示例中所看到的，有些不同。分发器由Store API封装并作为`store`函数公开。
- en: Moving to Redux
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向Redux
- en: Redux can do more than just very simple state management. It is also known to
    be performant and beneficial in applications with huge state objects and a lot
    of business models in it. That said, let's refactor our tasks application to Redux.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Redux不仅可以做简单的状态管理。它也以在具有庞大状态对象和许多业务模型的应用程序中表现出色而闻名。也就是说，让我们将我们的任务应用程序重构为Redux。
- en: The `Tasks` application was developed in the previous chapters. If you have
    jumped straight to this chapter, please have a look at the application located
    at `src / Chapter 4 / Example 1_ Todo app with Flux`, in the GitHub repository.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tasks`应用程序是在前几章中开发的。如果你直接跳到这一章，请看一下位于GitHub存储库中的`src / Chapter 4 / Example
    1_ Todo app with Flux`的应用程序。'
- en: 'The refactor steps will be similar. Replace existing Flux pieces with Redux
    ones:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重构步骤将类似。用Redux的部分替换现有的Flux部分：
- en: '`ActionTypes`:The actual implementation is okay:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActionTypes`：实际的实现是可以的：'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`TaskStore.js`: Rename to `AppStore.js`. Now, `store` has just one instance.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskStore.js`: 重命名为`AppStore.js`。现在，`store`只有一个实例。'
- en: 'Additionally, we will need to move the `reduce` function to a separate reducer
    file. What''s left should be converted into a new syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要将`reduce`函数移动到一个单独的reducer文件中。剩下的部分应该转换为新的语法：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`AppDispatcher.js`: The dispatcher is now part of the store.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDispatcher.js`：调度程序现在是存储的一部分。'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`taskReducer.js`: This is a new file that we need to create. Its contents,
    however, are copied from the previous `reduce` function:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskReducer.js`：这是一个我们需要创建的新文件。然而，它的内容是从之前的`reduce`函数中复制过来的：'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last required step is an app container change, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个必需的步骤是更改应用程序容器，如下所示：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So far, so good. It works. But there are a few things that we skipped here.
    I will show you what we can do better, but first, let's learn some Redux principles.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。它有效。但这里有一些事情我们跳过了。我会向你展示我们可以做得更好的地方，但首先，让我们学习一些Redux的原则。
- en: Redux as a pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux作为一种模式
- en: Redux, when done right, provides outstanding capabilities, such as **time **travelling and
    **hot reloading**. Time travelling allows us to see how an application looked
    over time based on the action log. Hot reloading, on the other hand, allows us
    to substitute parts of the code without reloading the app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当Redux做得好时，它提供了出色的功能，比如**时间旅行**和**热重载**。时间旅行允许我们根据操作日志看到应用程序随时间的变化。另一方面，热重载允许我们在不重新加载应用程序的情况下替换代码的部分。
- en: In this section, we will learn about the core principles of Redux and some commonly
    recommended approaches.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习Redux的核心原则和一些常见的推荐方法。
- en: 'Please make the effort to read the Redux documentation. It is a great and free
    resource to learn how to think in React and Redux. It will also help you expand
    your use of Redux beyond the React ecosystem, and is available at:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请努力阅读Redux文档。这是一个很好的免费资源，可以学习如何在React和Redux中思考。它还将帮助你将Redux的使用扩展到React生态系统之外，并且可以在以下网址找到：
- en: '[https://redux.js.org/introduction/examples](https://redux.js.org/introduction/examples).[ ](https://redux.js.org/introduction/examples)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/introduction/examples](https://redux.js.org/introduction/examples).[ ](https://redux.js.org/introduction/examples)'
- en: Core principles of Redux
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux的核心原则
- en: '**Single source of truth**: The state of your whole application is stored in
    an object tree within a single store. Ideally, there should be a single Redux
    store that can guide your views to render the whole application. This means you
    should keep all of your states away from class components and place them directly
    in the Redux store. This will simplify the method with which we will restore the
    view in tests or when we do a time travel.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一数据源**：整个应用程序的状态存储在单个存储中的对象树中。理想情况下，应该有一个单一的Redux存储，可以指导视图渲染整个应用程序。这意味着你应该将所有的状态远离类组件，直接放在Redux存储中。这将简化我们在测试中恢复视图的方法，或者当我们进行时间旅行时。'
- en: Having a single place to store things feels unnatural to some developers, most
    likely because, over the years on the backend, we have learned that it leads to
    monolithic architecture. This is not, however, the case in an application environment.
    An application window is not expected to be scaled vertically to handle a high
    load of users. Neither should it be used by hundreds of users at the same time
    on a single device.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发人员来说，有一个单一的存储位置感觉不自然，很可能是因为多年来在后端，我们已经学会了它会导致单片架构。然而，在应用环境中并非如此。不会期望应用窗口在垂直方向上扩展以处理大量用户的负载。也不应该在单个设备上同时被数百名用户使用。
- en: '**State is read-only**: The only way to change the state is to emit an action—an
    object describing what happened. It is vital that we have a single stream that
    can affect our store. The store is a representation of our application state and
    should not be mutated by random code. Instead, any code that is interested in
    changing the state should hand in a **signed paper** that is called an **action
    object**. This action object represents a known action that is registered in our
    library, called **action types**. The reducers are the logic that decides the
    state changes. The immutable state with a single stream of modifying actions is
    much easier to maintain and supervise. It is quicker to determine whether something
    has changed or not and when it changed. We can easily create an audit database. Particularly
    in sensitive industries such as banking, it is a huge advantage.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态是只读的**：改变状态的唯一方法是发出一个动作——描述发生了什么的对象。我们必须有一个单一的流来影响我们的存储。存储是我们应用状态的表示，不应该被随机代码改变。相反，任何有兴趣改变状态的代码都应该提交一份被称为**动作对象**的**签名文件**。这个动作对象代表了一个已知的在我们库中注册的动作，称为**动作类型**。Reducer是决定状态变化的逻辑。具有单一流的不可变状态更容易维护和监督。确定是否有变化以及何时发生变化更快。我们可以轻松地创建一个审计数据库。特别是在银行等敏感行业，这是一个巨大的优势。'
- en: '**Changes are made with pure functions**: To specify how the state tree is
    transformed by actions, you write pure reducers. This is a concept that we have
    not talked about yet. Reducers need to be pure functions. Pure functions guarantee
    that no external circumstances will affect the result of a function. To put it
    in a nutshell, reducers cannot perform I/O code, time-constrained code, or code
    that relies on mutable scoped data.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过纯函数进行更改**：为了指定状态树如何通过操作进行转换，您需要编写纯净的reducer。这是一个我们还没有讨论过的概念。Reducer需要是纯函数。纯函数保证没有外部情况会影响函数的结果。简而言之，reducer不能执行I/O代码、受时间限制的代码，或者依赖于可变作用域数据的代码。'
- en: 'A pure function is a function that satisfies two requirements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是满足两个要求的函数：
- en: It returns the same output, given the same input arguments
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定相同的输入参数，它返回相同的输出
- en: Function execution does not cause any side effects
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数执行不会引起任何副作用
- en: A good example are common math functions. For instance, an addition function
    given 1 and 3 always returns 4.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是常见的数学函数。例如，给定1和3的加法函数总是返回4。
- en: It may not be obvious why all of this is beneficial and should be considered
    one of the principles. Imagine a situation where a bug was unintentionally introduced
    into your project in the development phase. Or, even worse, it leaked into production
    and blew up a critical application during one of the user's sessions. Most likely,
    you have some error tracking, and you can get the exception and stack trace, which show
    a long and vague path through minified code. However, you need to fix it, so you
    try to replay the exact same situation on a local machine of yours and eventually
    spend three consecutive days just to realize that the problem was some boring
    race condition. Imagine, instead, that you had a single stream of actions (no
    random interchanging of untracked conditions) that you track and log. Also, your
    entire app relies on a state that can only be changed based on the stream of actions.
    In case of failure, all you need to store in order to reply to the situation is
    the action trace. Voila, I've just saved you a day or two.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么有益并且应该被视为原则可能并不明显。想象一种情况，一个bug在开发阶段无意中被引入到你的项目中。或者更糟糕的是，它泄漏到生产环境，并在用户的某个会话期间炸毁了一个关键应用。很可能你有一些错误跟踪，你可以得到异常和堆栈跟踪，显示了一个漫长而模糊的路径通过被压缩的代码。然而，你需要修复它，所以你尝试在你的本地机器上重现完全相同的情况，最终花了连续三天的时间才意识到问题是一些无聊的竞争条件。想象一下，相反，你有一个单一的动作流（没有未跟踪条件的随机交换），你跟踪和记录。此外，你的整个应用依赖于只能根据动作流改变的状态。在失败的情况下，你需要存储的只是动作跟踪，以便回放情况。瞧，我刚刚为你节省了一两天的时间。
- en: When I learned Redux with similar examples, I still struggled to understand
    why pure functions are so important here. Playing with time-traveling within the
    Redux tab for Chrome allowed me to see it more clearly in the flesh. When you
    go back and forth with actions, some components that are stateful (that is, that
    rely on an internal state instead of the Redux one) will not be following along.
    This is a huge issue as it breaks your time travel, leaving some parts in a future
    state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我用类似的例子学习Redux时，我仍然很难理解为什么纯函数在这里如此重要。在Chrome的Redux标签中进行时间旅行的玩耍让我更清楚地看到了实际情况。当你来回进行操作时，一些有状态的组件（即依赖内部状态而不是Redux状态的组件）将不会跟随。这是一个巨大的问题，因为它破坏了你的时间旅行，使一些部分处于未来状态。
- en: Moving to a single source of truth
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向单一真相来源
- en: It's time for an exercise. Our new goal is to refactor the Tasks application
    so that it has a store that is a single source of truth.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是练习的时候了。我们的新目标是重构Tasks应用程序，使其具有一个单一的真相来源的存储。
- en: 'To do so, we need to look for places where we rely on a component state instead
    of the Redux store. So far we have three views:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要寻找依赖组件状态而不是Redux存储的地方。到目前为止，我们有三个视图：
- en: '`AppView.js`: This has a fairly simple division into header, footer, and main
    content.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppView.js`：这个组件相当简单，分为头部、底部和主要内容。'
- en: This is a presentational component and holds no state. Its props are provided
    by `AppContainer`, which already uses the Redux store. `AppView` delegates main
    content to the following two sub-views.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个呈现组件，不持有状态。它的props由`AppContainer`提供，后者已经使用了Redux存储。`AppView`将主要内容委托给以下两个子视图。
- en: '`TaskList.js`: This is a presentational component responsible for displaying
    to-do tasks in a simple scrollable list. Its props are forwarded by `AppView`
    from `AppContainer`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskList.js`：这是一个呈现组件，负责在一个简单可滚动的列表中显示待办任务。它的props是由`AppView`从`AppContainer`中转发的。'
- en: '`AddTaskForm.js`: This is a container component, based on the `TextInput` component.
    This piece uses an internal state. If possible, we should refactor this.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTaskForm.js`：这是一个容器组件，基于`TextInput`组件。这个部分使用了内部状态。如果可能的话，我们应该重构这个部分。'
- en: If you have ever read about React and Redux, you may find this example pretty
    similar to what you can find for web pages—however, it is not. If you followed
    this book for the first chapters, you may have a gut instinct as to why; if not,
    I highly recommend going back for a while to `Chapter 2 > Building Forms > Uncontrolled
    Inputs`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经读过关于React和Redux的内容，你可能会发现这个例子与你在网页上找到的内容非常相似，但实际上并不是。如果你在阅读本书的前几章时，可能会有一种直觉；如果没有，我强烈建议你回到“第2章
    > 构建表单 > 不受控输入”。
- en: Our goal is to somehow move the state from `AddTaskForm` to the Redux store.
    This is where problems begin. You may have already spotted that `TextInput` is
    part of the React-Native API and we have no ability to change it. But `TextInput`
    is a stateful component. This is the first thing you should realize about Redux
    when building React Native apps—some parts need to be stateful and you cannot
    work around it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是以某种方式将状态从`AddTaskForm`移动到Redux存储中。这就是问题开始的地方。你可能已经注意到`TextInput`是React-Native
    API的一部分，我们无法改变它。但`TextInput`是一个有状态的组件。这是在构建React Native应用时，你应该意识到的关于Redux的第一件事——有些部分需要有状态，你无法绕过它。
- en: Luckily, the stateful part of `TextInput` only manages focus. It is highly unlikely
    that you would need to store information about that in the Redux store. All the
    other states belong to our `AddTaskForm` component and we can work around it.
    Let's do that straight away.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`TextInput`的有状态部分只管理焦点。你几乎不太可能需要在Redux存储中存储关于它的信息。所有其他状态都属于我们的`AddTaskForm`组件，我们可以解决这个问题。让我们马上做。
- en: In idiomatic Redux, your state should be normalized similarly to the databases.
    There are known normalization techniques used in SQL databases that usually are
    based on ID references between entities. You can adopt this approach in your Redux
    store by using, for the instance, Normalizr library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在惯用的Redux中，你的状态应该被规范化，类似于数据库。在SQL数据库中有已知的规范化技术，通常是基于实体之间的ID引用。你可以通过使用Normalizr库在Redux存储中采用这种方法。
- en: 'First, we will rebuild the `AddTaskForm` component. It needs to dispatch a
    new action that will trigger a new reducer and alter a new key in the Redux store
    (we will develop the latter parts later on):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重建`AddTaskForm`组件。它需要分派一个新的动作，这将触发一个新的减速器，并改变Redux存储中的一个新键（我们将在后面开发后面的部分）：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The hardest part is behind us. It''s time to create a brand new `taskFormReducer`,
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的部分已经过去了。现在是时候创建一个全新的`taskFormReducer`，如下所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Following this, add a new action type to `TasksActionTypes`, as demonstrated
    in this snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`TasksActionTypes`添加一个新的动作类型，如下所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add the action itself, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加动作本身，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, register a new reducer in `AppStore`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`AppStore`中注册一个新的减速器，如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the end, we need to pass the new state along:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要传递新的状态：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We pass it down the component tree up to `AppView`, as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其传递到组件树上的`AppView`，如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, we have connected all the bits. Enjoy your centralized single source
    of truth Redux store.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们连接了所有的部分。享受你的集中式单一真相源Redux存储。
- en: Alternatively, take a look at the `redux-form` library. As of writing this book,
    it is an industry standard for building forms in Redux. The library can be found
    at [https://redux-form.com](https://redux-form.com).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，看一下`redux-form`库。在写这本书的时候，它是Redux中构建表单的行业标准。该库可以在[https://redux-form.com](https://redux-form.com)找到。
- en: Creating an alternative with MobX
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MobX创建一个替代方案
- en: It would be foolish to rely on Redux with no strong alternative. One of such
    alternatives is MobX, a state management library that is not so opinionated on
    mutations. MobX comes with as little boilerplate as possible. This is huge compared
    to Redux, which, being very explicit, requires a lot of boilerplate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有强大替代方案的情况下依赖Redux是愚蠢的。MobX就是这样的替代方案之一，它是一个状态管理库，对变化没有那么多意见。MobX尽可能少地提供样板文件。与Redux相比，这是一个巨大的优势，因为Redux非常显式，需要大量的样板文件。
- en: Here I must stop to remind you that the React ecosystem leans towards explicitness,
    that is, building apps without too many hidden mechanisms. You control the flow
    and you see all of the bits that are required for the app to go the full cycle
    of Flux. It's n surprise, then, that mainstream developers prefer Redux. An interesting
    fact is that Facebook Open Source is backing the MobX project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我必须停下来提醒您，React生态系统倾向于显式性，即构建应用程序而没有太多隐藏的机制。您控制流程，并且可以看到应用程序完成Flux的整个周期所需的所有位。毫不奇怪，主流开发人员更喜欢Redux。有趣的是，Facebook
    Open Source支持MobX项目。
- en: MobX, being more implicit, can hide away some logic built around Observables
    and provide neat annotations to quickly enhance your stateful components with
    MobX flow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: MobX更加隐式，可以隐藏一些围绕Observables构建的逻辑，并提供整洁的注释，以快速增强您的具有状态的组件与MobX流。
- en: Some developers may find it a much better approach, most likely those coming
    from an object-oriented background who are used to such things. I find MobX a
    much easier library to start with and develop a prototype or proof-of-concept
    application. However, as logic is hidden away from me, I'm afraid that some developers
    will never have a look under the hood. This may lead to poor performance that
    cannot easily be fixed later on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员可能会发现这是一个更好的方法，最有可能是那些来自面向对象背景并习惯于这些事情的人。我发现MobX是一个更容易开始并开发原型或概念验证应用程序的库。然而，由于逻辑被隐藏在我身后，我担心一些开发人员永远不会查看底层。这可能会导致性能不佳，以后很难修复。
- en: Let's see how it feels in action.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在实际操作中的感觉。
- en: Moving to MobX
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向MobX
- en: In this section, we will refactor the Tasks application to use MobX instead
    of vanilla Flux.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构Tasks应用程序，以使用MobX而不是vanilla Flux。
- en: The Tasks application was developed in the previous chapters. If you have jumped
    straight to this chapter, please have a look at the application located at `src
    / Chapter 4 / Example 1_ Todo app with Flux`, in the GitHub repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 任务应用程序是在前几章中开发的。如果您直接跳转到本章，请查看位于GitHub存储库中的`src / Chapter 4 / Example 1_ Todo
    app with Flux`位置的应用程序。
- en: 'Before we dive in, install the two packages using the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，使用以下命令安装这两个软件包：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Okay, first, let''s clean up unneeded pieces:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，首先，让我们清理不需要的部分：
- en: '`AppDispatcher.js`: Dispatching is done by MobX using observables behind the
    scenes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDispatcher.js`：MobX在幕后使用可观察对象进行分发。'
- en: '`TaskActions.js`: Actions will now live in `TaskStore` and work on its state.
    In MobX, you will most likely end up with many stores, so this is not a big issue—we
    keep related things together.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskActions.js`：操作现在将驻留在`TaskStore`中并在其状态上工作。在MobX中，您很可能最终会有许多存储，因此这不是一个大问题-我们将相关的东西放在一起。'
- en: '`TasksActionTypes.js`: There is no need to define this. MobX will take care
    of it internally.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TasksActionTypes.js`：没有必要定义这个。MobX会在内部处理它。'
- en: As you can see, before we begin, we have already removed so much overhead. This
    is one of the biggest advantages of MobX that fans of the library mention.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在我们开始之前，我们已经去掉了很多开销。这是库的粉丝们提到的MobX最大的优势之一。
- en: 'It''s time to rebuild the store in MobX fashion. This will require some new
    keywords, so read the following snippet carefully:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候以MobX方式重建存储了。这将需要一些新的关键字，因此请仔细阅读以下代码片段：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, there are three new keywords that I have imported from the
    MobX library:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有三个新关键字我从MobX库中导入：
- en: '`configure`: This is used to set up our store in such a way as to enforce mutations
    only by actions.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure`：这用于设置我们的存储，以便只能通过操作来强制执行变化。'
- en: '`observable`: This is used to enrich property in such a way it can now be observed.
    If you have some JavaScript background on streams or Observables, it is literally
    wrapped by these.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observable`：这用于丰富属性，使其可以被观察到。如果您对流或可观察对象有一些JavaScript背景，它实际上是由这些包装的。'
- en: '`action`: This is just like any other action but it''s used in a decorator
    fashion.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：这就像任何其他操作一样，但是以装饰器的方式使用。'
- en: Finally, we create an instance of the store and pass it along as a default export.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个存储的实例，并将其作为默认导出传递。
- en: 'Now we need to expose our new store to the views. To do this, we will use MobX
    `Provider`, a similar utility to that found in Redux:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将新的存储暴露给视图。为此，我们将使用MobX `Provider`，这是Redux中找到的类似实用程序：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The last section of the preceding snippet involves refactoring the descendant
    views.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段的最后一部分涉及重构后代视图。
- en: 'The `AppView` component provides tasks down to `TaskList` component. Let''s
    now consume tasks from our newly created store:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppView`组件向下提供任务到`TaskList`组件。现在让我们从新创建的存储中消耗任务：'
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s do something similar with `AddTaskForm`, but instead of using `tasks`,
    we will use the `addTask` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`AddTaskForm`做类似的事情，但是不是使用`tasks`，而是使用`addTask`函数：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That's it! Our app is fully functional again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的应用程序再次完全可用。
- en: Using PropTypes with annotations
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注释与PropTypes
- en: If you followed along, you may feel a little lost, as your linter probably started
    complaining about insufficient or missing `PropTypes`. Let's fix that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟着做，您可能会感到有点迷茫，因为您的linter可能开始抱怨`PropTypes`不足或缺失。让我们来解决这个问题。
- en: 'For `AppView`, we are missing `PropTypes` validation for the `tasks` store.
    When the class is annotated with `@observer`, it is a little tricky—you need to
    write `PropTypes` for `wrappedComponent`, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`AppView`，我们缺少对`tasks`存储的`PropTypes`验证。当类被标注为`@observer`时，这有点棘手-您需要为`wrappedComponent`编写`PropTypes`，如下所示：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For `AddTaskForm`, we are missing the `PropTypes` validation for the `addTask`store
    action. Let''s fix this now:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`AddTaskForm`，我们缺少对`addTask`存储操作的`PropTypes`验证。让我们现在来解决这个问题：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's it, the linter complaints are gone.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，linter的投诉都消失了。
- en: Comparing Redux and MobX
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Redux和MobX
- en: One day I was thinking how to compare those two and the following came to mind.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，我在想如何比较这两者，接下来的想法浮现在脑海中。
- en: This section is highly influenced by Preethi Kasireddy's talk at React Conf
    2017\. Please spend half an hour and watch it. You can find the talk at [https://www.youtube.com/watch?v=76FRrbY18Bs](https://www.youtube.com/watch?v=76FRrbY18Bs).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分受到了Preethi Kasireddy在React Conf 2017的演讲的很大影响。请花半个小时观看一下。您可以在[https://www.youtube.com/watch?v=76FRrbY18Bs](https://www.youtube.com/watch?v=76FRrbY18Bs)找到这个演讲。
- en: MobX is like system of roads for cars. You create a road map and let people
    drive. Some will cause accidents, some will drive carefully. Some roads may be
    limited to one-way to restrict traffic a little, or even shaped in a certain way
    to allow easier reasoning about the car flow, as in Manhattan. Redux, on the other
    hand, is like a train. Only one train can move on a track at a time. If there
    are a few at the same moment and something is holding up the one in front, every
    other train waits behind, just like in a subway station. Sometimes trains need
    to transfer people as far as the other side of a continent, and this is also possible.
    All of this train flow is governed by one (distributed) agency that plans the
    movement and puts restrictions on the train flow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: MobX就像汽车的道路系统。你创建了一张路线图，让人们开车。有些人会造成事故，有些人会小心驾驶。有些道路可能限制为单向，以限制交通，甚至以某种方式塑造，以便更容易推理汽车流量，就像在曼哈顿一样。另一方面，Redux就像一辆火车。一次只能有一列火车在轨道上行驶。如果有几列火车同时行驶，前面的火车被阻挡，其他火车就会在后面等待，就像在地铁站一样。有时火车需要把人们送到大陆的另一边，这也是可能的。所有这些火车流量都由一个（分布式）机构管理，规划移动并对火车流量施加限制。
- en: 'Keeping this example in mind, let''s take a more technical look at these libraries:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个例子，让我们更加技术性地看看这些库：
- en: Redux uses plain objects, while MobX wraps objects into Observables.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux使用普通对象，而MobX将对象包装成可观察对象。
- en: 'You may expect me to mention some magic again—no. The brutal truth is that
    MobX comes at a cost. It needs to wrap observable data and add some weight to
    each single object or each member of a collection. It is fairly easy to look up
    just how much data: use `console.log` to see your observable collection.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期待我再次提到一些魔法——不会。残酷的事实是，MobX是有代价的。它需要包装可观察数据，并为每个对象或集合的每个成员增加一些负担。很容易查看有多少数据：使用`console.log`来查看您的可观察集合。
- en: Redux manually tracks updates, whereas MobX automatically tracks updates.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux手动跟踪更新，而MobX自动跟踪更新。
- en: A Redux state is read-only and can be altered by dispatching an action, while
    a MobX state can be altered at any time, sometimes only by using actions exposed
    by your Store API. Also, in MobX, actions are not required. You can change state
    directly.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux状态是只读的，并且可以通过分派操作进行更改，而MobX状态可以随时更改，有时只能使用存储API公开的操作来更改。此外，在MobX中，不需要操作。您可以直接更改状态。
- en: In Redux, a state is typically normalized, or at least this is recommended.
    In MobX, your state is denormalized and computed values are nested.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redux中，状态通常是规范化的，或者至少建议这样做。在MobX中，您的状态是非规范化的，并且计算值是嵌套的。
- en: 'Stateless and stateful components: here it may seem difficult. Preethi Kasireddy,
    in the lecture linked in the preceding information box, mentioned that MobX can
    be used with smart components only. To some extent, this is true, but there is
    no distinction here from Redux. Both support presentational components, as these
    are completely decoupled from state management libraries!'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态和有状态组件：这里可能看起来很困难。在前面的信息框中链接的讲座中，Preethi Kasireddy提到MobX只能与智能组件一起使用。在某种程度上，这是正确的，但这与Redux没有区别。两者都支持展示组件，因为它们与状态管理库完全解耦！
- en: The learning curve—this is very subjective criteria. Some will find Redux easier,
    others will find MobX easier. The popular belief is that MobX is easier to learn.
    I'm an exception to this.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习曲线——这是非常主观的标准。有些人会发现Redux更容易，而其他人会发现MobX更容易。普遍的看法是MobX更容易学习。我是这方面的例外。
- en: Redux requires more boilerplate. Being more explicit, this is quite straightforward,
    but there are libraries that fix this if you don't care. No references will be
    provided here, as I recommend educated use.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux需要更多的样板文件。更加明确，这是非常直接的，但如果您不在乎，也有一些库可以解决这个问题。我不会在这里提供参考资料，因为我建议您进行教育性的使用。
- en: Redux is much easier to debug. This comes naturally with single flow and easy
    replay of messages. This is where Redux shines. MobX is more old-school here,
    a little harder to predict, and not so obvious, even to experienced users.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux更容易调试。这自然而然地带来了单一流程和消息的轻松重放。这就是Redux的亮点。MobX在这方面更加老派，有点难以预测，甚至对经验丰富的用户来说也不那么明显。
- en: Redux wins when it comes to scalability. MobX may pose some maintainability
    problems, especially in big projects with a lot of connections and a big domain.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及可扩展性时，Redux胜出。MobX可能会在大型项目中提出一些可维护性问题，特别是在有很多连接和大型领域的项目中。
- en: MobX is concise and shines in small, time-constrained projects. If you go to
    a hackathon, consider using MobX. In big, long-term projects, you would need a
    more opinionated approach on top of the freedom that MobX gives.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX在小型、时间受限的项目中更加简洁，发光。如果你参加黑客马拉松，考虑使用MobX。在大型、长期项目中，你需要在MobX的自由基础上采用更有见地的方法。
- en: MobX follows the Flux architecture and does not alter it as much as Redux does.
    Redux leans towards one global store (although can be used with many!), while
    MobX is quite flexible with the amount of stores and its examples usually demonstrate
    similar thinking to the early ideas of Flux.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX遵循Flux架构，并且不像Redux那样对其进行修改。Redux倾向于一个全局存储（尽管可以与多个一起使用！），而MobX在存储的数量上非常灵活，其示例通常展示了与Flux早期思想类似的思维方式。
- en: While using Redux, you need to learn how to deal with different situations and
    how to structure things. When it comes to dealing with side effects especially,
    you will need to learn Redux Thunk and possibly Redux Saga, which will be introduced
    in the following chapter. In MobX, all of this is magically taken care of behind
    the scenes, using reactive streams. In this respect, MobX is opinionated, but
    takes one responsibility away from you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Redux时，您需要学习如何处理不同的情况以及如何构建结构。特别是在处理副作用时，您需要学习Redux Thunk，可能还有Redux Saga，这将在下一章中介绍。在MobX中，所有这些都在幕后神奇地处理，使用响应式流。在这方面，MobX是有见地的，但却减轻了你的一个责任。
- en: Using system storage in React Native
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React Native中使用系统存储
- en: Those who come from a Native environment are used to persistent storage, such
    as databases or files. So far, any time our app has been relaunched, it has lost
    its state. We can fix that using system storage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那些来自原生环境的人习惯于持久存储，比如数据库或文件。到目前为止，每当我们的应用重新启动时，它都会丢失状态。我们可以使用系统存储来解决这个问题。
- en: 'For this purpose, we will use the `AsyncStorage` API that comes with React
    Native:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用React Native附带的`AsyncStorage` API：
- en: '"On iOS, AsyncStorage is backed by native code that stores small values in
    a serialized dictionary and larger values in separate files. On Android, AsyncStorage
    will use either RocksDB or SQLite based on what is available."'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “在iOS上，AsyncStorage由存储小值的序列化字典和存储大值的单独文件的本机代码支持。在Android上，AsyncStorage将根据可用的情况使用RocksDB或基于SQLite。”
- en: '- From the React Native official documentation, which can be found at:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '- 来自React Native官方文档，可以在以下网址找到：'
- en: '[https://facebook.github.io/react-native/docs/asyncstorage.html](https://facebook.github.io/react-native/docs/asyncstorage.html).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/asyncstorage.html](https://facebook.github.io/react-native/docs/asyncstorage.html)。'
- en: 'The `AsyncStorage` API is pretty easy to use. First, let''s save the data:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage` API非常容易使用。首先，让我们保存数据：'
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, here''s how we retrieve a saved value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是我们如何检索保存的值：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, the documentation advises that we use some abstraction with `AsyncStorage`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文档建议我们在`AsyncStorage`中使用一些抽象：
- en: '"It is recommended that you use an abstraction on top of AsyncStorage instead
    of AsyncStorage directly for anything more than light usage since it operates
    globally."'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “建议您在AsyncStorage上使用一个抽象，而不是直接使用AsyncStorage，因为它在全局范围内运行。”
- en: '- From the React Native official documentation, which can be found at:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '- 可以在React Native官方文档中找到：'
- en: '[https://facebook.github.io/react-native/docs/asyncstorage.html](https://facebook.github.io/react-native/docs/asyncstorage.html).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/asyncstorage.html](https://facebook.github.io/react-native/docs/asyncstorage.html)。'
- en: So, let's follow the standard library, `redux-persist`. The topic of storage
    is huge and spans a little beyond this book, so I don't want to dive too deep
    into this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们遵循标准库`redux-persist`。存储的主题很大，超出了这本书的范围，所以我不想深入探讨这个问题。
- en: 'Let''s install the library with the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令安装该库：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first step is to enhance our `AppStore` definition with the new persistence
    middleware, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过新的持久性中间件增强我们的`AppStore`定义，如下所示：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we are done with the configuration, we need to load the state using `PersistGate.`
    You can provide a custom component to the loading prop if you have one:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，我们需要使用`PersistGate`加载状态。如果有自定义组件，可以将其提供给加载属性：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Voila! Whenever you relaunch the application, the state will be loaded from
    the persistent store, and you will see all of the tasks from the last application
    launch.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 看哪！每当重新启动应用程序时，状态将从持久存储加载，并且您将看到上次应用程序启动时的所有任务。
- en: Effect patterns
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果模式
- en: When working with external data, you need to deal with external factors, such
    as the network or disk. These factors influence your code, so it needs to be asynchronous.
    Also, you should strive to decouple it from your predictable parts, as a network
    is unpredictable and may fail. We call such things side effects and you have already
    learned a little about them already.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理外部数据时，您需要处理外部因素，如网络或磁盘。这些因素会影响您的代码，因此它需要是异步的。此外，您应该努力将其与可预测的部分解耦，因为网络是不可预测的，可能会失败。我们称这样的事情为副作用，您已经学到了一些关于它们的知识。
- en: 'To understand this, I would like to introduce a big word: effect.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，我想介绍一个大词：效果。
- en: '"We yield plain JavaScript Objects [...]. We call those Objects *Effects*.
    An Effect is simply an object that contains some information to be interpreted
    by the middleware. You can view Effects like instructions to the middleware to
    perform some operation (e.g., invoke some asynchronous function, dispatch an action
    to the store, etc.)."'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “我们产生纯粹的JavaScript对象[...]。我们称这些对象为*效果*。效果就是一个包含一些信息的对象，由中间件解释。您可以将效果视为中间件执行某些操作的指令（例如，调用某些异步函数，向存储分发操作等）。”
- en: '- From the Redux Saga official documentation, which can be found at:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- 可以在Redux Saga官方文档中找到：'
- en: '[https://redux-saga.js.org/docs/basics/DeclarativeEffects.html](https://redux-saga.js.org/docs/basics/DeclarativeEffects.html).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux-saga.js.org/docs/basics/DeclarativeEffects.html](https://redux-saga.js.org/docs/basics/DeclarativeEffects.html)。'
- en: Such effects, if used outside of the immediate scope, cause a so-called **side
    effect**, hence the name. Most commonly, this means a mutation of an outer scope
    variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在立即范围之外使用这些效果，就会引起所谓的**副作用**，因此得名。最常见的情况是对外部范围变量的改变。
- en: The absence of side effects is key to mathematical proofs of the correctness
    of a program. We will dive into this topic later on in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 没有副作用是程序正确性的数学证明的关键。我们将在[第9章](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml)中深入探讨这个话题，*函数式编程模式的要素*。
- en: Handling side effects
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理副作用
- en: 'In [Chapter 4](71c15ec6-339c-49e3-840c-577c650f5694.xhtml), *Flux Architecture*,
    you learned what side effects are and what strategies you can follow to decouple
    them from Views and Store. When using Redux, you should stick to them. However,
    there are a few neat libraries that have been developed for Redux to solve the
    problem. You will learn more on them in the following chapter, which is dedicated
    just to this issue:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第4章](71c15ec6-339c-49e3-840c-577c650f5694.xhtml) *Flux架构*中，您学会了副作用是什么，以及您可以遵循哪些策略来将其与视图和存储解耦。在使用Redux时，您应该坚持这些策略。然而，已经开发了一些很棒的库来解决Redux的问题。您将在接下来的章节中了解更多，这些章节专门讨论这个问题:'
- en: '"We''re mixing two concepts that are very hard for the human mind to reason
    about: mutation and asynchronicity. I call them Mentos and Coke. Both can be great
    in separation, but together they create a mess. Libraries like React attempt to
    solve this problem in the view layer by removing both asynchrony and direct DOM
    manipulation. However, managing the state of your data is left up to you. This
    is where Redux enters."'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们正在混合两个对人类思维来说非常难以理解的概念：突变和异步性。我称它们为Mentos和Coke。它们分开时都很棒，但一起就会变成一团糟。像React这样的库试图通过在视图层中移除异步性和直接DOM操作来解决这个问题。然而，管理数据状态留给了你。这就是Redux介入的地方。"'
- en: '- Official Redux documentation'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '- 官方Redux文档'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the importance of stores in our architecture.
    You learned how to shape your application in order to fulfill different business
    needs, from very fragile ones using a mixed approach of state and global state,
    to sophisticated ones allowing time-traveling and UI reconstruction.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了存储在我们架构中的重要性。您学会了如何塑造您的应用程序，以满足不同的业务需求，从使用状态和全局状态的混合方法来处理非常脆弱的需求，到允许时间旅行和UI重建的复杂需求。
- en: Instead of focusing on one mainstream solution, that is, Redux, we also explored
    the quite different approach of the MobX library. We found it great in many areas,
    such as rapid prototyping and small projects, and you now know when and in which
    projects it is wise to choose MobX over Redux.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅关注了Redux这一主流解决方案，还探讨了MobX库的完全不同的方法。我们发现它在许多领域都非常出色，比如快速原型设计和小型项目，现在您知道在何时以及在哪些项目中选择MobX而不是Redux是明智的。
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Redux official documentation:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redux官方文档:'
- en: '[https://redux.js.org/](https://redux.js.org/). [](https://redux.js.org/) This
    is a particularly useful part of the documentation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/](https://redux.js.org/). [](https://redux.js.org/) 这是文档中特别有用的部分:'
- en: '[https://redux.js.org/faq](https://redux.js.org/faq).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/faq](https://redux.js.org/faq).'
- en: '*Introduction of Redux Time Travel and Hot Reloading* by Dan Abramov, on React
    Europe:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Redux时间旅行和热重载介绍* 由Dan Abramov在React Europe上:'
- en: '[https://www.youtube.com/watch?v=xsSnOQynTHs](https://www.youtube.com/watch?v=xsSnOQynTHs).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=xsSnOQynTHs](https://www.youtube.com/watch?v=xsSnOQynTHs).'
- en: 'Dan Abramov''s courses on Egghead:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dan Abramov在Egghead上的课程:'
- en: '[https://egghead.io/instructors/dan-abramov](https://egghead.io/instructors/dan-abramov).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://egghead.io/instructors/dan-abramov](https://egghead.io/instructors/dan-abramov).'
- en: 'Redux GitHub page with closed issues. This contains a ton of useful discussions:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redux GitHub页面上有已关闭的问题。这包含了大量有用的讨论:'
- en: '[https://github.com/reduxjs/redux/issues?q=is%3Aissue+is%3Aclosed](https://github.com/reduxjs/redux/issues?q=is%3Aissue+is%3Aclosed).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/reduxjs/redux/issues?q=is%3Aissue+is%3Aclosed](https://github.com/reduxjs/redux/issues?q=is%3Aissue+is%3Aclosed).'
- en: Netflix JavaScript Talks: *RxJS + Redux + React = Amazing*!
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Netflix JavaScript Talks: *RxJS + Redux + React = Amazing*!'
- en: '[https://www.youtube.com/watch?v=AslncyG8whg](https://www.youtube.com/watch?v=AslncyG8whg).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=AslncyG8whg](https://www.youtube.com/watch?v=AslncyG8whg).'
- en: '*How Airbnb Is Using React Native*:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Airbnb如何使用React Native*:'
- en: '[https://www.youtube.com/watch?v=8qCociUB6aQ](https://www.youtube.com/watch?v=8qCociUB6aQ).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=8qCociUB6aQ](https://www.youtube.com/watch?v=8qCociUB6aQ)。'
- en: This is not strictly on store patterns but illustrates how to think about big
    production applications, such as Airbnb.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是关于存储模式，而是说明了如何思考像 Airbnb 这样的大型生产应用程序。
- en: 'You might need Redux:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能需要 Redux：
- en: '[https://www.youtube.com/watch?v=2iPE5l3cl_s&feature=youtu.be&t=2h7m28s](https://www.youtube.com/watch?v=2iPE5l3cl_s&feature=youtu.be&t=2h7m28s).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=2iPE5l3cl_s&feature=youtu.be&t=2h7m28s](https://www.youtube.com/watch?v=2iPE5l3cl_s&feature=youtu.be&t=2h7m28s).'
- en: 'Last but not least, a very important topic brought to you by the Redux author:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，Redux 作者为您带来的一个非常重要的话题：
- en: '*You Might Not Need Redux*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可能不需要 Redux*：'
- en: '[https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367).'
