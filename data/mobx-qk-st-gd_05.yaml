- en: Derivations, Actions, and Reactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生、操作和反应
- en: Now that the MobX foundations have been laid with the three pillars of *observables*,
    *actions*, and *reactions*, it's time we go deeper and understand the finer aspects.
    In this chapter, we will explore the core philosophies and nuances of the MobX
    API, as well as some special APIs to simplify asynchronous programming in MobX.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MobX 的基础已经奠定了*可观察*、*操作*和*反应*这三大支柱，是时候深入了解更精妙的细节了。在本章中，我们将探索 MobX API 的核心理念和微妙之处，以及一些特殊的
    API 来简化 MobX 中的异步编程。
- en: 'The topics covered in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: Computed properties (also known as derivations) and their various options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性（也称为派生）及其各种选项
- en: Actions, with special focus on async actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作，特别关注异步操作
- en: Reactions and the rules governing when MobX reacts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应和规则，控制 MobX 反应的时机
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装 Node.js。最后，要使用本书的 Git 存储库，用户需要安装 Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter05](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter05)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter05](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter05)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：
- en: '[http://bit.ly/2mAvXk9](http://bit.ly/2mAvXk9)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2mAvXk9](http://bit.ly/2mAvXk9)'
- en: Derivations (computed properties)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生（计算属性）
- en: '*Derivation* is a term that is used quite frequently in the MobX parlance.
    It is given special emphasis in client-state modeling. As we saw in the previous
    chapter, the observable state can be determined by the combination of the *core-mutable-state*
    and a *derived-read-only-state*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*派生*是 MobX 术语中经常使用的一个词。在客户端状态建模中特别强调。正如我们在上一章中看到的，可观察状态可以由*核心可变状态*和*派生只读状态*的组合确定：'
- en: '*Observable State = (Core-mutable-State) + (Derived-readonly-State)*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*可观察状态 = (核心可变状态) + (派生只读状态)*'
- en: 'It is essential to keep the core state as lean as possible. This is the part
    that is expected to stay stable and grow slowly during the lifetime of the application.
    It is only the core state that is actually mutable and the *actions* always mutate
    only the *core state*. The derived state depends on the core state and is kept
    up-to-date by the MobX reactivity system. We know that *computed properties* act
    as the derived state in MobX. They can depend not only on the *core state* but
    also on other derived states, creating a dependency tree that is kept alive by
    MobX:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量保持核心状态尽可能精简。这部分预计在应用程序的生命周期内保持稳定并缓慢增长。只有核心状态实际上是可变的，*操作*总是只改变*核心状态*。派生状态取决于核心状态，并由
    MobX 反应性系统保持最新。我们知道 *计算属性* 在 MobX 中充当派生状态。它们不仅可以依赖于*核心状态*，还可以依赖于其他派生状态，从而创建一个由
    MobX 保持活跃的依赖树：
- en: '![](../images/00026.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: A key characteristic of the derived state is that it is *read only*. Its job
    is to generate a *computed value* (using the *core state*) but never mutate the
    *core state*. MobX is smart to cache these computed values and not perform any
    unnecessary computation. It also does efficient clean-ups when there are no observers
    of the *computed values*. It is highly recommended to leverage the computed properties
    as much as possible and not worry about the performance impact.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 派生状态的一个关键特征是它是*只读*的。它的工作是生成一个*计算值*（使用*核心状态*），但永远不会改变*核心状态*。MobX很聪明地缓存这些计算值，并且在没有*计算值*的观察者时不执行任何不必要的计算。强烈建议尽可能利用计算属性，并不用担心性能影响。
- en: 'Let''s take an example where you can have a minimal core state and a derived
    state for satisfying the UI needs. Consider the humble `Todo`, `TodoList`, and
    `TodoManager`. You can probably guess what these classes do. They form the observable
    state of a *Todos* application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，你可以拥有一个最小的核心状态和一个派生状态来满足UI的需求。考虑一下`Todo`，`TodoList`和`TodoManager`。你可能猜到这些类是做什么的。它们构成了*Todos*应用程序的可观察状态：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the preceding code, the core state is defined by the properties
    marked with `@observable`. They are the mutable properties of these classes. For
    a *Todos* app, the core state is primarily the list of `Todo` items.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中可以看出，核心状态由使用`@observable`标记的属性定义。它们是这些类的可变属性。对于*Todos*应用程序，核心状态主要是`Todo`项目的列表。
- en: 'The derived state, which is mostly to take care of the filtering needs of the
    UI, includes the properties marked with `@computed`. Of particular interest is
    the `TodoList` class, which only has one `@observable`: an array of `todos`. Rest
    is the derived state consisting of the `pendingTodos`, `pendingTodosDescription`,
    and `completedTodos`, all marked by `@computed`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 派生状态主要是为了满足UI的过滤需求，其中包括使用`@computed`标记的属性。特别感兴趣的是`TodoList`类，它只有一个`@observable`：一个`todos`数组。其余的是由`@computed`标记的`pendingTodos`，`pendingTodosDescription`和`completedTodos`组成的派生状态。
- en: By keeping a lean core state, we can produce many variations of the derived
    state, as needed by the UI. Such a derived state could also help in keeping the
    semantic model clean and simple. This also gives you a chance to *enforce the
    vocabulary of the domain* rather than exposing the raw core state directly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持精简的核心状态，我们可以根据UI的需要产生许多派生状态的变化。这样的派生状态也有助于保持语义模型的清晰和简单。这也给了你一个机会来*强制执行领域的词汇*，而不是直接暴露原始的核心状态。
- en: Is it a side effect?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是一个副作用吗？
- en: In [Chapter 1](part0023.html#LTSU0-58c2559ca4304cecab9bc46f496bc070), *Introduction
    to State Management*, we talked about the role of side effects. These are the
    reactive aspects of the application that produce *external effects* based on changes
    in state (also known as data). If we now look at *computed properties* through
    the lens of side effects, you can find it very similar to the reactions in MobX.
    After all, a reaction in MobX looks at observables and produces side effects.
    This is what a computed-property does too! It depends on observables and produces
    an observable-value as side effect. So, shouldn't *computed properties* be considered
    as side effects?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0023.html#LTSU0-58c2559ca4304cecab9bc46f496bc070) *状态管理简介*中，我们谈到了副作用的作用。这些是应用程序的响应性方面，根据状态（也称为数据）的变化产生*外部效果*。如果我们现在通过副作用的角度来看*computed属性*，你会发现它与MobX中的反应非常相似。毕竟，在MobX中，反应会查看可观察对象并产生副作用。计算属性也是这样做的！它依赖于可观察对象并产生可观察值作为副作用。那么，*computed属性*应该被视为副作用吗？
- en: Very sound argument indeed. It can appear as a side effect from the way it is
    derived, but the fact that it generates an *observable-value* brings it back into
    the world of *client-state* rather than becoming an external effect. Computed
    properties are, in fact, data for the UI and other state-management aspects. Unlike
    the side effect-causing functions of MobX, such as `autorun()`, `reaction()`,
    and `when()`, computed properties don't cause any *external* side effects and
    stay within the confines of the client-state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是一个非常有力的论点。它可能会出现作为它派生的一种副作用，但它生成*可观察值*的事实将其带回到*客户端状态*的世界，而不是成为外部影响。实际上，计算属性是UI和其他状态管理方面的数据。与MobX引起副作用的函数（如`autorun()`、`reaction()`和`when()`）不同，计算属性不会引起任何*外部*副作用，并且保持在客户端状态的范围内。
- en: Another clear distinction between MobX reactions and computed properties is
    that there is an implicit expectation that *computed properties will give back
    a value*, whereas reactions are *fire-and-forget* with no expectation of getting
    back a value. Also, with computed properties the re-evaluation (the *side effect*
    part of a computed-property) can stop as soon as there are no more observers.
    However, with reactions, it is not always clear when to stop them. For example,
    it is not always clear when logging or a network request should be stopped.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MobX反应和计算属性之间的另一个明显区别是，*计算属性有一个隐含的期望会返回一个值*，而反应是*即时反应*，没有期望得到一个值。此外，对于计算属性，重新评估（计算属性的*副作用*部分）可以在没有更多观察者时停止。然而，对于反应，何时停止它们并不总是清楚。例如，何时停止记录或网络请求并不总是清楚。
- en: So, let's rest the case by saying that *computed properties* are only a *partial
    side effect* and not the full-on, fire-and-forget reactions of MobX.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过说*计算属性*只是*部分副作用*而不是MobX的全面、即时反应来结束这个案例。
- en: There's more to computed()
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: computed()还有更多内容
- en: So far, we have looked at the use of the `@computed` decorator along with `@computed.struct`,
    where structural equality was crucial. There is of course more to the `computed`
    function, which also takes several options for a fine-grained customization. These
    options are available when used in the `decorate()` function, the `@computed`
    decorator, or when creating *boxed-computed observables*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了`@computed`装饰器与`@computed.struct`的使用，其中结构相等非常重要。当然，`computed`函数还有更多内容，还可以采用多个选项进行精细的定制。在使用`decorate()`函数、`@computed`装饰器或创建*boxed-computed
    observables*时，这些选项都是可用的。
- en: 'In the following snippet, we see the usage in the `decorate()` function, which
    is more common:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，我们看到了在`decorate()`函数中的使用，这更常见：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Options for `computed()` can be passed as an *object-argument* with several
    properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`computed()`的选项作为*对象参数*传递，具有多个属性：
- en: '`name`: This is useful when combined with MobX DevTools (part of the ***mobx-react-devtools***
    NPM package). The name specified here is used in logs and also when introspecting
    the *observables* of a rendered React component.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：与MobX DevTools（***mobx-react-devtools*** NPM包的一部分）结合使用时很有用。在日志中使用此处指定的名称，并且在检查呈现的React组件的*observables*时也会使用。'
- en: '`context`: The value of *"****this**"* inside the computed function. In general,
    you don''t need to specify as it will default to the decorated instance.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：计算函数内部的值*“**this**”*。一般情况下，您不需要指定，因为它将默认为装饰实例。'
- en: '`set`: A *computed-property* is most often used as a *getter*. But, you could
    supply a setter too. This is not to replace the value of the computed property,
    but rather acts as an *inverse*. Consider the following example, where the setter
    for `fullName` is splitting it into `firstName` and `lastName`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`：*计算属性*最常用作*getter*。但是，你也可以提供一个setter。这不是为了替换计算属性的值，而是作为*反向*。考虑以下示例，其中`fullName`的setter将其拆分为`firstName`和`lastName`：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To do the same inside the class, without `decorate()`, you just add a setter,
    as seen in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在类内部执行相同的操作，而不使用`decorate()`，只需添加一个setter，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`keepAlive`: There are times when you need a computed value to be always available,
    even when there are no tracking observers. This option keeps the computed value
    *hot* and always updated. One caution with this option is that the computed value
    will *always be cached* and you may want to think more deeply for possible memory
    leaks and expensive computations. Objects with computed properties with `{ keepAlive:
    true }` can only be garbage-collected when all of their dependent observables
    are garbage-collected. So, use this option with care.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepAlive`：有时候你需要一个计算值始终可用，即使没有跟踪观察者。这个选项保持计算值的“热度”并始终更新。但要注意的是，这个选项会始终缓存计算值，可能会导致内存泄漏和昂贵的计算。具有`{
    keepAlive: true }`的计算属性的对象只有在所有依赖的观察者都被垃圾回收时才能被垃圾回收。因此，请谨慎使用此选项。'
- en: '`requiresReaction`: This is a property meant to safeguard against *expensive
    computations running more often than expected*. The default is set to `false`,
    which means even without an observer (also known as reaction) it will be evaluated
    the first time. When set to `true`, it does not perform the computation if there
    are no observers. Instead, it throws an error informing you of the need for an
    observer. It is possible to change the global behavior by calling `configure({
    computedRequiresReaction: Boolean })`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requiresReaction`：这是一个旨在防止*昂贵的计算运行频率超出预期*的属性。默认值设置为`false`，这意味着即使没有观察者（也称为反应），它也会在第一次评估。当设置为`true`时，如果没有观察者，它不会执行计算。相反，它会抛出一个错误，告诉您需要一个观察者。可以通过调用`configure({
    computedRequiresReaction: Boolean })`来更改全局行为。'
- en: '`equals`: This sets the equality checker for the computed property. The equality
    check determines if a notification needs to be fired to inform all observers (also
    known as reactions). As we know, only when the *newly-computed value* is different
    from the *previously-cached-value* will a notification be fired. The default is
    `comparer.identity`, which does a `===` check. In other words, a value and a reference
    check. The other kind of equality check is with `comparer.structural`, which performs
    a deep comparison of the values to determine if they are equal. Conceptually,
    it is similar to an `observable.struct` decorator. This is also the comparer used
    for the `computed.struct` decorator:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`：这设置了计算属性的相等检查器。相等检查确定是否需要发出通知以通知所有观察者（也称为反应）。我们知道，只有当*新计算值*与*先前缓存的值*不同时，才会发出通知。默认值为`comparer.identity`，它执行`===`检查。换句话说，值和引用检查。另一种相等检查是使用`comparer.structural`，它执行值的深度比较以确定它们是否相等。在概念上，它类似于`observable.struct`装饰器。这也是`computed.struct`装饰器使用的比较器：'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Error handling inside computed
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算内部的错误处理
- en: Computed properties have the special ability to recover from errors thrown during
    computation. Rather than bailing out immediately, they catch and hold on to the
    error. It is only when you try to read from a *computed-property*, that it will rethrow
    the error. This gives you the chance to recover by resetting some state and getting
    back to some default state.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性具有在计算过程中捕获错误并从中恢复的特殊能力。它们不会立即退出，而是捕获并保留错误。只有当您尝试从*计算属性*中读取时，它才会重新抛出错误。这使您有机会通过重置一些状态并返回到一些默认状态来恢复。
- en: 'The following example is straight from the MobX docs, and aptly demonstrates
    the error recovery:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例直接来自MobX文档，并恰当地演示了错误恢复：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Actions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: '*Actions* are the way to mutate the core state of your application. In fact,
    MobX strongly recommends that you always use actions and never do any mutations
    outside of an action. It even goes to the extent of enforcing this requirement
    across your app if you `configure` MobX with: `{ enforceActions: true }`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作*是改变应用程序核心状态的方式。事实上，MobX强烈建议您始终使用操作，永远不要在操作之外进行任何变化。如果您使用`configure`配置MobX为`{
    enforceActions: true }`，它甚至会在整个应用程序中强制执行此要求：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let the preceding lines of code be the starting point of your *MobX-driven*
    React app. It's obvious that there are some benefits to using actions for all
    state-mutation. But so far, it hasn't been very clear. Let's drill a little deeper
    to uncover these hidden benefits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让上述代码行成为您的*MobX驱动*React应用程序的起点。显然，对于所有状态变异使用操作有一些好处。但到目前为止，这还不太清楚。让我们深入挖掘一下，揭示这些隐藏的好处。
- en: '`configure({ enforceActions: true })` isn''t the only option available for
    guarding state-mutation. There is a stricter form with `{ enforceActions: ''strict''
    }`. The difference is subtle but worth calling out. When set to `true`, you are
    still allowed to make stray mutations outside of an action, **if** there are *no
    observers* tracking the mutating observable. This may seem like a slip on the
    part of MobX. However, it is OK to allow this because there are no side effects
    happening yet, since there are no observers. It won''t cause any harm to the consistency
    of the MobX reactivity system. It''s like the old saying, *If a tree falls in
    the forest and no one is around, does it make a sound? *Maybe too philosophical,
    but the gist is: without observers, you have no-one tracking observables and causing
    side effects, so you can safely apply the mutation.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure({ enforceActions: true })`并不是保护状态变异的唯一选项。还有一种更严格的形式，即`{ enforceActions:
    ''strict'' }`。差异微妙但值得注意。当设置为`true`时，仍允许在操作之外进行偶发变异，**如果**没有*观察者*跟踪变异的可观察对象。这可能看起来像是MobX的一个疏忽。但是，允许这样做是可以的，因为尚未发生任何副作用，因为没有观察者。这不会对MobX反应性系统的一致性造成任何伤害。就像古话说的那样，*如果树倒在森林里，没有人在附近，它会发出声音吗？*也许有点哲学，但要点是：没有观察者，没有人跟踪可观察对象并引起副作用，因此您可以安全地应用变异。'
- en: 'But, if you do want to go the purist route, you can use `{ enforceActions:
    ''strict'' }` and call foul even in cases where there are no observers. It''s
    really a personal choice here.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，如果您确实想要走纯粹的路线，您可以使用`{ enforceActions: ''strict'' }`，即使在没有观察者的情况下也可以进行操作。这真的是个人选择。'
- en: Why an action?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用操作？
- en: When an observable is changed, MobX immediately fires a notification informing
    every observer of the change. So, if you happen to change 10 observables, 10 notifications
    will be sent out. At times, this is just excessive. You don't want a noisy system
    that notifies too eagerly. It is better to batch up the notifications and send
    them in one shot instead. It saves on CPU cycles, keeps your battery on your mobile
    device happy, and in general leads to a balanced, healthier app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当可观察对象发生变化时，MobX立即发出通知，通知每个观察者发生了变化。因此，如果您改变了10个可观察对象，将发送10个通知。有时，这只是过多的。您不希望一个过于急切地通知的嘈杂系统。最好将通知批量处理并一次性发送。这样可以节省CPU周期，使您移动设备上的电池更加愉快，并且通常会导致一个平衡、更健康的应用程序。
- en: That is exactly what an `action()` achieves when you put all your mutations
    inside it. It wraps the mutating-function with `untracked()` and `transaction()`,
    two special-purpose, low-level utilities inside MobX. `untracked()` prevents tracking
    of observables (also known as creation of new *observable-observer* relationships)
    inside the mutating function; whereas `transaction()` batches the notifications,
    coerces notifications on the same observable, and then dispatches the minimal
    set of notifications at the end of ***action***.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将所有的变化放在`action()`中时，这正是`action()`所实现的。它用`untracked()`和`transaction()`包装了变异函数，这两个是MobX中的特殊用途的低级实用程序。`untracked()`阻止在变异函数内跟踪可观察对象（也称为创建新的*可观察-观察者*关系）；而`transaction()`批处理通知，强制在同一可观察对象上的通知，然后在***action***结束时发送最小的通知集。
- en: 'There is one more core utility function that is used by actions, which is `allowStateChanges(true)`.
    This ensures state changes do happen on the observables and they get their new
    values. The combination of *untracked*, *transaction*, and *allowStateChanges*
    is what makes up an action:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个核心实用功能被操作使用，即`allowStateChanges(true)`。这确保状态变化确实发生在可观察对象上，并且它们获得它们的新值。*untracked*、*transaction*和*allowStateChanges*的组合构成了一个动作：
- en: '*action = untracked(transaction(allowStateChanges(true, <mutating-function>)
    ) )*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*action = untracked(transaction(allowStateChanges(true, <mutating-function>)
    ) )*'
- en: 'This combination has the following much-intended effects:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合具有以下预期效果：
- en: Reducing excessive notifications
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少过多的通知
- en: Improving efficiency by batching up a minimal set of notifications
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过批量处理最小的通知来提高效率
- en: Minimizing executions of *side effects*, for observables that change several
    times in an *action*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过批量处理最小的通知来最小化在*动作*中多次改变的可观察对象的*副作用*执行
- en: In fact, actions can be nested within each other, which ensures the notifications
    only go out after the *outermost action* has finished executing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，动作可以嵌套在彼此之内，这确保通知只在*最外层动作*执行完成后才发出。
- en: '*Actions* also help bring out the semantics of the domain and enable your app
    to become more declarative. By wrapping the details of how the observables are
    mutated, you give a *distinct name* to the operation that changes state. This
    emphasizes the *vocabulary* of your domain and codifies it as part of your *state-management*.
    This is a nod to the principles of *Domain-Driven Design* that brings the ubiquitous
    language (the terms of your domain) into the client-side code.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*动作*还有助于展现领域的语义，并使您的应用程序变得更具声明性。通过包装可观察对象如何被改变的细节，您为改变状态的操作赋予了一个*独特的名称*。这强调了您领域的*词汇*，并将其编码为您的*状态管理*的一部分。这是对*领域驱动设计*原则的一种赞同，它将普遍语言（您领域的术语）引入客户端代码。'
- en: '*Actions* help in bridging the gap between the vocabulary of your domain and
    names used in the actual code. Besides the efficiency benefits, you also get the
    semantic benefits that keep the code more readable.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*动作*有助于弥合领域词汇和实际代码中使用的名称之间的差距。除了效率上的好处，您还可以获得保持代码更可读的语义上的好处。'
- en: We saw earlier, in the *Derivations (computed properties)* section, that you
    can also have setters. These setters are automatically wrapped by an `action()`
    by MobX. A setter for a computed-property is not really changing the computed-property
    directly. Instead, it is the inverse that mutates the dependent observables that
    make up the computed-property. Since we are mutating observables, it makes sense
    to wrap them in an action. MobX is smart enough to do this for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在*派生（计算属性）*部分看到，您也可以有设置器。这些设置器会被MobX自动包装在`action()`中。计算属性的设置器实际上并不直接改变计算属性。相反，它是改变组成计算属性的依赖可观察对象的逆过程。由于我们正在改变可观察对象，将它们包装在一个动作中是有意义的。MobX足够聪明，可以为您做到这一点。
- en: Async actions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步操作
- en: 'Asynchronous programming is pervasive in JavaScript, and MobX fully embraces
    that idea without adding too much ceremony. Here is a small snippet showing some
    async code interspersed with MobX state mutation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的异步编程无处不在，MobX完全拥抱了这个想法，而没有增加太多的仪式感。这里有一个小片段展示了一些异步代码与MobX状态变化交织在一起：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Looks normal, like any other async code. This is exactly the point. By default,
    MobX simply steps aside and lets you mutate the observables as expected. However,
    if you configure MobX to `{ enforceActions: ''strict'' }`, you get a warm **red**
    welcome on the console:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '看起来很正常，就像任何其他异步代码一样。这正是重点所在。默认情况下，MobX简单地让步，让您按预期改变可观察对象。然而，如果您将MobX配置为`{ enforceActions:
    ''strict'' }`，您将在控制台上得到一个热烈的**红色**欢迎：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What's wrong here, you may ask? It has to do with our use of `async-await` operators.
    You see, the code that follows the `await` is *not executed* synchronously. It
    executes *after* the `await` promise fulfills. Now, the `action()` decorator can
    only guard code that is executed synchronously within its block. Code that is
    run asynchronously is not considered, and thus runs outside the `action()`. Hence,
    the code following `await` is not part of `action` anymore, causing MobX to complain.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，这里有什么问题？这与我们对`async-await`操作符的使用有关。您看，跟在`await`后面的代码*不会*同步执行。它会在`await`承诺实现之后执行。现在，`action()`装饰器只能保护在其块内同步执行的代码。异步运行的代码不被考虑，因此在`action()`之外运行。因此，跟在`await`后面的代码不再是`action`的一部分，导致MobX抱怨。
- en: Wrapping with runInAction()
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用runInAction()进行包装
- en: 'The way to circumvent this problem is to use a utility function provided by
    MobX, called `runInAction()`. This is a handy function that takes in a *mutating-function* and
    executes it inside an `action()`. In the following code, you can see the use of
    `runInAction()` to wrap the mutations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用MobX提供的一个实用函数，称为`runInAction()`。这是一个方便的函数，它接受一个*变异函数*并在`action()`内执行它。在下面的代码中，您可以看到使用`runInAction()`来*包装*这些变化：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we have applied `runInAction()` to the code following `await`, both
    in the *try-block* and in the *catch-block*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经在跟在`await`后面的代码中应用了`runInAction()`，无论是在*try块*还是在*catch块*中。
- en: '`runInAction(fn)` is just a convenience utility that is equivalent to `action(fn)()`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`runInAction(fn)`只是一个方便的实用程序，相当于`action(fn)()`。'
- en: 'Although *async-await* provides a beautiful, concise syntax to write `async`
    code, beware of the parts of code that are not synchronous. The co-location of
    the code within the `action()` block can be misleading. At runtime, not all statements
    execute synchronously. The code that follows `await` is always run `async`, after
    the *awaited-promise* fulfills. Wrapping the parts that are `async` with `runInAction()`
    gives us back the benefits of the `action()` decorator. Now, MobX has no more
    complaints when you configure `({ enforceActions: ''strict'' })`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然*async-await*提供了一种美观简洁的语法来编写`async`代码，但要注意那些不是同步的代码部分。`action()`块中代码的共同位置可能会让人产生误解。在运行时，并非所有语句都是同步执行的。跟在`await`后面的代码总是以`async`方式运行，等待的promise完成后才会执行。将那些`async`部分用`runInAction()`包装起来，可以让我们重新获得`action()`装饰器的好处。现在，当你配置`({
    enforceActions: ''strict'' })`时，MobX不再抱怨了。'
- en: flow()
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flow()
- en: 'In the previous, simple example, we only had to wrap two segments of the code
    in `runInAction()`. That was quite straightforward and did not involve too much
    effort. However, there will be cases where you will have multiple `await` statements
    within a function. Consider the `login()` method shown next, which performs an
    action involving multiple *awaits*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的简单示例中，我们只需要将代码的两个部分用`runInAction()`包装起来。这是相当直接的，不需要太多的努力。然而，有些情况下你会在一个函数中有多个`await`语句。考虑下面展示的`login()`方法，它执行涉及多个*await*的操作：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wrapping the state-mutations in `runInAction()` after each `await` can quickly
    turn cumbersome. You can even forget wrapping some parts if there are more conditionals
    involved or if the mutations are spread across multiple functions. What if there
    was a way to automatically wrap the asynchronous parts of the code in `action()`?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`await`后用`runInAction()`包装状态变化会很快变得繁琐。如果涉及更多条件或者变化分散在多个函数中，甚至可能会忘记包装一些部分。如果有一种方法可以自动将代码的异步部分包装在`action()`中会怎么样呢？
- en: 'MobX provides a solution for this use-case too. There is a utility function
    called `flow()` that takes a *generator-function* as input. Instead of `await`,
    you use the `yield` operator instead. Conceptually, it is very similar to the *async-await*
    kind of code, but uses a *generator function* with `yield` statements to achieve
    the same effect. Let''s rewrite the code from the previous example, using the
    `flow()` utility:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: MobX也为这种情况提供了解决方案。有一个名为`flow()`的实用函数，它以*生成器函数*作为输入。你可以使用`yield`操作符，而不是`await`。在概念上，它与*async-await*类型的代码非常相似，但是使用*生成器函数*和`yield`语句来实现相同的效果。让我们使用`flow()`实用程序重写前面示例中的代码：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the use of the generator `function*()` instead of the regular function,
    which is passed as argument to `flow()`. Structurally, it is no different than
    the *async-await* style of code, but has the added benefit of automatically wrapping
    the parts of code following a `yield` with an `action()`. With `flow()`, you are
    back to being more declarative with your async code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用生成器`function*()`而不是传递给`flow()`的常规函数。结构上，它与*async-await*风格的代码没有什么不同，但它有一个额外的好处，就是自动将`yield`后面的代码部分用`action()`包装起来。有了`flow()`，你可以更加声明式地编写异步代码。
- en: There is yet another benefit that `flow()` gives you. It is the ability to *cancel
    execution of the async code*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow()`给你另一个好处。它可以*取消异步代码的执行*。'
- en: 'The return value of `flow()` is a function that you can invoke to execute the
    async code. This is the `login` method of the `AuthStore`, in the preceding example.
    When you call `new AuthStore().login()`, you get back a promise that has been
    enhanced by MobX with the `cancel()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow()`的返回值是一个函数，你可以调用它来执行异步代码。这是前面示例中`AuthStore`的`login`方法。当你调用`new AuthStore().login()`时，你会得到一个由MobX增强的带有`cancel()`方法的promise：'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is useful for canceling a long-running operation by giving user-level control.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于通过给予用户级别的控制来取消长时间运行的操作非常有用。
- en: Reactions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应
- en: Observables and actions keep things within the confines of the MobX reactivity
    system. Actions mutate the observables and, through the power of notifications,
    the rest of the MobX system aligns to the mutation to keep the state consistent.
    To start making a change outside of this MobX system, you need *reactions*. It
    is the bridge to the outside world that informs the *state-changes* happening
    within the MobX world.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象和操作使事物保持在MobX反应系统的范围内。操作改变可观察对象，并通过通知的力量，MobX系统的其余部分会调整以保持状态一致。要开始在MobX系统之外进行更改，您需要*反应*。它是连接MobX世界内部发生的*状态变化*与外部世界的桥梁。
- en: '*Consider reactions to be the reactive-bridge-crossing between MobX and  the
    outside world. These are also the side effect producers of your application.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*将反应视为MobX和外部世界之间的反应桥梁。这也是您的应用程序的副作用产生者。*'
- en: 'We know that reactions come in three flavors: `autorun`, `reaction`, and `when`.
    These three flavors have distinct characteristics that tackle the various scenarios
    within your app.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道反应有三种类型：`autorun`，`reaction`和`when`。这三种类型具有不同的特征，可以处理应用程序中的各种情况。
- en: 'When determining which one to pick, you can apply this simple decision-making
    process:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确定选择哪一个时，您可以应用这个简单的决策过程：
- en: '![](../images/00027.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'Each of the reactions give you back a *disposer-function*, which can be used
    to prematurely dispose the reaction thus:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个反应都会返回一个*清除函数*，可以用来提前清除反应，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Going back to the preceding diagram on the decision-tree, we can now define
    what it means to be *long-running*: the reaction does not dispose itself automatically
    after executing the first time. It continues to live until explicitly disposed
    using the *disposer-function*. `autorun()` and `reaction()` fall under the category
    of long-running reactions, whereas `when()` is one-time only. Note that `when()`
    also gives back a *disposer-function*, which can pre-maturely cancel the `when()`
    effect. However, the *one-time* behavior means that after the effect executes,
    `when()` will automatically dispose of itself, without requiring any clean up.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到决策树上的前面图表，我们现在可以定义什么是“长时间运行”：反应在第一次执行后不会自动清除。它会继续存在，直到使用“清除函数”明确清除为止。`autorun()`和`reaction()`属于长时间运行的反应，而`when()`是一次性的。请注意，`when()`也会返回一个“清除函数”，可以提前取消`when()`的效果。然而，“一次性”的行为意味着在效果执行后，`when()`将自动清除自身，无需任何清理。
- en: The second defining characteristic that is covered in the decision-tree is about
    *selecting the observables* to track. This is a guarding condition for the *effect-function*
    to execute. `reaction()` and `when()` have the ability to decide which observables
    to use for tracking, whereas, `autorun()` implicitly selects all observables in
    its *effect-function*. In the case of `reaction()` it's the *tracking-function*, and
    for `when()` it's the *predicate-function*. These functions are expected to produce
    a value, and when it changes, the *effect-function* is executed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树中涵盖的第二个定义特征是关于*选择要跟踪的可观察对象*。这是执行*效果函数*的保护条件。`reaction()`和`when()`有能力决定要用于跟踪的可观察对象，而`autorun()`隐式选择其*效果函数*中的所有可观察对象。在`reaction()`中，这是*跟踪函数*，而在`when()`中，这是*谓词函数*。这些函数应该产生一个值，当它改变时，*效果函数*就会被执行。
- en: The *selector-function* of `reaction()` and `when()` is where the observable
    tracking happens. The *effect-function* is only for causing side effects with
    no tracking. `autorun()` implicitly combines the *selector-function* and the *effect-function*
    into just one function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`reaction()`和`when()`的*选择器函数*是可观察跟踪发生的地方。*效果函数*仅用于引起没有跟踪的副作用。`autorun()`隐式地将*选择器函数*和*效果函数*合并为一个函数。'
- en: Using the decision tree, you can classify the different *side effects* in your
    application. In [Chapter 6](part0101.html#30A8Q0-58c2559ca4304cecab9bc46f496bc070),
    *Handling Real-World Use Cases*, we will look at various examples that will make
    this selection process more natural.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用决策树，您可以对应用程序中的不同*副作用*进行分类。在[第6章](part0101.html#30A8Q0-58c2559ca4304cecab9bc46f496bc070)中，*处理真实用例*，我们将看一些示例，这将使选择过程更加自然。
- en: Configuring autorun() and reaction()
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置autorun()和reaction()
- en: Both `autorun()` and `reaction()` offer an extra argument to customize the behavior
    a little more. Let's look at the most common properties that can be passed as
    options.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`autorun()`和`reaction()`都提供了一个额外的参数来自定义行为。让我们看看可以作为选项传递的最常见属性。'
- en: Options for autorun()
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: autorun()的选项
- en: 'The second argument to `autorun()` is an object that carries the *options*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`autorun()`的第二个参数是一个携带*选项*的对象：'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It has the following properties:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下属性：
- en: '`name`: This is useful for debugging purposes, especially in the context of
    MobX DevTools, where the `name` is printed in the logs. The name is also used
    with the `spy()` utility function provided by MobX. Both of these will be covered
    in a later chapter.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这对于调试目的非常有用，特别是在MobX DevTools的上下文中，其中`name`在日志中打印出来。名称也与MobX提供的`spy()`实用程序函数一起使用。这两者将在以后的章节中介绍。'
- en: '`delay`: This acts as a debouncer for frequently changing observables. The
    *effect-function* will wait for the `delay` period (specified in milliseconds)
    before re-executing. In the example shown next, we want to be careful not to fire
    a network request for every change to `profile.couponsUsed`. An easy guard is
    to use the `delay` option:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：这充当频繁更改的可观察对象的去抖器。*效果函数*将在`delay`期间（以毫秒为单位指定）等待重新执行。在接下来的示例中，我们要小心，不要在每次更改`profile.couponsUsed`时都发出网络请求。使用`delay`选项是一个简单的防护措施：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`onError`: Errors thrown during the execution of the *effect-function* can
    be safely handled by providing the `onError` handler. The error is given as input
    to the `onError` handler, which can then be used to recover, and prevent the exceptional
    state for subsequent runs of the *effect-function*. Note that by providing this
    handler, MobX continues tracking even after an error occurs. This keeps the system
    running and allows other scheduled *side effects*, which are possibly unrelated,
    to run as expected.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：在*效果函数*执行期间抛出的错误可以通过提供`onError`处理程序来安全处理。错误作为输入提供给`onError`处理程序，然后可以用于恢复，并防止*效果函数*的后续运行出现异常状态。请注意，通过提供此处理程序，MobX即使在发生错误后也会继续跟踪。这使系统保持运行，并允许其他已安排的*副作用*按预期运行，这些副作用可能是不相关的。'
- en: 'In the following example, we have an `onError` handler that deals with cases
    where the number of coupons is greater than two. Providing this handler keeps
    the `autorun()` running without interfering with the rest of the MobX reactivity
    system. We are also removing the excess coupons to prevent this from happening
    again:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有一个`onError`处理程序，用于处理优惠券数量大于两的情况。通过提供此处理程序，保持`autorun()`的运行，而不会干扰MobX反应性系统的其余部分。我们还删除多余的优惠券，以防止再次发生这种情况：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Options for reaction()
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reaction()的选项
- en: 'Similar to `autorun()`, we can pass an extra argument to `reaction()` that
    contains the *options*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与`autorun()`类似，我们可以传递一个额外的参数给`reaction()`，其中包含*选项*：
- en: '`*reaction(() => {/* tracking data */}, (data) => { /* side effects */}, options)*`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`*reaction(() => {/* tracking data */}, (data) => { /* side effects */}, options)*`'
- en: 'Some of the options, as shown below, are exactly like *autorun*, which keeps
    it consistent:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些选项如下所示，与*autorun*完全相同，保持一致：
- en: '`name`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`delay`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`'
- en: '`onError`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`'
- en: 'However, there are additional options, specifically for `reaction()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，特别针对`reaction()`，还有其他选项：
- en: '`fireImmediately`: This is a boolean value that indicates whether the *effect-function*
    should be triggered immediately after the first invocation of the *tracking-function*.
    Notice that this behavior gets us closer to `autorun()`, which also runs immediately.
    By default, it is set to `false`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fireImmediately`：这是一个布尔值，指示在*跟踪函数*第一次调用后是否立即触发*效果函数*。请注意，这种行为使我们更接近`autorun()`，它也会立即运行。默认情况下，它被设置为`false`。'
- en: '`equals`: Notice that the *tracking-function* in a `reaction()` gives back `data`
    that is used to compare with the previously produced value. For primitive values,
    the default *equality comparison* (`comparer.default`), which is based on value,
    works well. However, you are free to supply a structural comparer (`comparer.structural`)
    to ensure a deeper comparison is performed. The equality check is important, because
    only when the values (produced by *tracking-function*) differ, will the *effect-function*
    be invoked.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`：请注意，`reaction()`中的*跟踪函数*返回的`data`将与先前产生的值进行比较。对于原始值，默认的*相等比较*（`comparer.default`）基于值的比较效果很好。但是，您可以自由提供结构比较器（`comparer.structural`）来确保执行更深层次的比较。相等检查很重要，因为只有当值（由*跟踪函数*产生）不同时，*效果函数*才会被调用。'
- en: When does MobX react?
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX何时会做出反应？
- en: The MobX reactivity system starts with the tracking or observation of the *observables*.
    This is an important aspect of building the reactivity graph, so tracking the
    correct observables is key. By following a simple set of rules, you can guarantee
    the outcome of the tracking process and ensure your reactions fire correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的反应性系统始于*可观察对象*的跟踪或观察。这是构建反应性图的重要方面，因此跟踪正确的可观察对象至关重要。通过遵循一套简单的规则，您可以保证跟踪过程的结果，并确保您的反应正确触发。
- en: 'We will use the term *tracking-function* to mean any one of the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用术语*跟踪函数*来指代以下任何一个：
- en: The function passed into `autorun()`. The observables used in that function
    are tracked by MobX.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`autorun()`的函数。该函数中使用的可观察对象将被MobX跟踪。
- en: The *selector-function* (first argument) of a `reaction()` or `when()`. The
    observables used in it are tracked.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reaction()`或`when()`的*选择器函数*（第一个参数）。其中使用的可观察对象也将被跟踪。'
- en: The `render()` method of an *observer*-React-component. The observables used
    during the execution of the `render()` method are tracked.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*observer*-React组件的`render()`方法。在执行`render()`方法时使用的可观察对象将被跟踪。'
- en: The rules
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则
- en: 'With each of the following rules, we will look at an example of the rule in
    action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下每条规则中，我们将看一个规则在实际中的例子：
- en: Always dereference observables during the execution of the tracking-function. Dereferencing
    is the key to establishing the MobX tracker.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*跟踪函数*的执行过程中始终解引用可观察对象。解引用是建立MobX跟踪器的关键。
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding snippet, the `autorun()` is not invoked again since there
    is no observable property being dereferenced. For MobX to react to changes, it
    needs an observable property being read inside the *tracking-function*. One possible
    fix is to read the `item.price` inside the `autorun()`, which will re-trigger
    anytime `item.price` is changed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，由于没有可观察属性被解引用，`autorun()`不会再次被调用。为了让MobX对更改做出反应，需要在*跟踪函数*内读取可观察属性。一个可能的修复方法是在`autorun()`内部读取`item.price`，这样每当`item.price`发生变化时就会重新触发：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Tracking only happens in the synchronously executing code of the tracking-function:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪仅发生在跟踪函数的同步执行代码中：
- en: The observables should be accessed directly in the tracking-function and not
    in an async function inside.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该直接在跟踪函数中访问observable，而不是在异步函数中访问。
- en: 'In the following code, MobX will never react to the change in `item.quantity`.
    Although we are dereferencing the observable inside `autorun()`, it is not being
    done synchronously. Hence, MobX will never re-execute `autorun()`:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，MobX永远不会对`item.quantity`的更改做出反应。尽管我们在`autorun()`中取消引用observable，但这并不是同步进行的。因此，MobX永远不会重新执行`autorun()`：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To fix, we can pull the code out from the `setTimeout()` and place it directly
    inside `autorun()`. If the use of `setTimeout()` is to add some delayed execution,
    we can do that with the `delay` option of `autorun()`. The following code shows
    the fix:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复，我们可以将代码从`setTimeout()`中取出，并直接放入`autorun()`中。如果使用`setTimeout()`是为了添加一些延迟执行，我们可以使用`autorun()`的`delay`选项来实现。以下代码显示了修复：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Only observables that already exist will be tracked:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有已经存在的observable才会被跟踪：
- en: 'In the following example, we are dereferencing an observable (a computed property),
    which does not exist on the `item` at the time `autorun()` executes. Hence, MobX
    never tracks it. Later in the code, we are changing the `item.quantity`, resulting
    in a change in `item.description`, but `autorun()` still doesn''t execute:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在取消引用一个observable（一个计算属性），该属性在`autorun()`执行时并不存在于`item`上。因此，MobX从不跟踪它。在代码的后面，我们改变了`item.quantity`，导致`item.description`发生变化，但`autorun()`仍然不会执行：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An easy fix is to ensure the observable actually exists before `autorun()`
    executes. By changing the order of statements, we can get the desired behavior,
    as seen in the following snippet. In practice, you should declare upfront all
    the properties you will need. This helps MobX to track properties correctly when
    required, helps type-checkers (for example, TypeScript) ensure the correct properties
    are being used, and also expresses the intent clearly to the readers of your code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方法是确保在`autorun()`执行之前observable实际存在。通过改变语句的顺序，我们可以得到期望的行为，如下面的代码片段所示。在实践中，您应该预先声明所有需要的属性。这有助于MobX在需要时正确跟踪属性，有助于类型检查器（例如TypeScript）确保正确的属性被使用，并且还清楚地表达了代码读者的意图：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the snippet* before the fix*, if we had also read the `item.quantity` in `autorun()`,
    then this *tracking-function* would re-execute on changes to `item.quantity`.
    That happens as the observable property exists at the time the `autorun()` executes
    for the first time. The second time `autorun()` executes (due to change in `item.quantity`),
    `item.description` would also be available and MobX can start tracking that as
    well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复之前的代码片段中，如果我们在`autorun()`中也读取了`item.quantity`，那么这个*跟踪函数*会在`item.quantity`发生变化时重新执行。这是因为observable属性在`autorun()`首次执行时存在。第二次`autorun()`执行（由于`item.quantity`的变化），`item.description`也将可用，MobX也可以开始跟踪它。
- en: 'One exception to the previous rule is for Observable Maps where a dynamic key
    is also tracked:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个规则的一个例外是Observable Maps，其中还跟踪动态键：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code snippet, `autorun()` will re-execute since `twitterUrls`
    is an `observable.map`, which tracks the addition of new keys. Thus, the key, `Sara`,
    is still tracked even though it is non-existent at the time `autorun()` executes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`autorun()`将重新执行，因为`twitterUrls`是一个`observable.map`，它跟踪新键的添加。因此，即使在`autorun()`执行时它不存在，键`Sara`仍然被跟踪。
- en: In MobX 5, it can track *not-yet-existing* properties for all objects created
    using the `observable()` API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在MobX 5中，它可以跟踪使用`observable()`API创建的所有对象的*尚不存在的*属性。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The mental model for MobX apps is geared towards thinking about the *observable
    state*. This itself is divided into the *minimal core state* and a *derived state*.
    Derivations are how we handle the various projections of the core state onto the
    UI and places where we need to perform domain-specific operations. Before adding
    more core state, think about whether it can be rolled in as derived state. Only
    when that is not possible should you introduce new core state.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: MobX应用的思维模型是针对思考*可观察状态*的。这本身分为*最小核心状态*和*派生状态*。派生是我们如何处理核心状态在UI上的各种投影以及需要执行特定于领域的操作的地方。在添加更多核心状态之前，考虑它是否可以作为派生状态进行整合。只有在这种情况下，您才应该引入新的核心状态。
- en: We saw how an *async action* is quite similar to a regular *action* without
    much ceremony. The only caveat is when you have configured MobX to `enforceActions`.
    In that case, you have to wrap *state mutations* in the async code inside `runInAction()`.
    When there are several async parts within the action, **`flow()`** is a better
    option. It takes a generator function (denoted by `function*(){ }`) that is interspersed
    with `yield` to the various *promise-based* calls.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，*异步操作*与常规*操作*非常相似，没有太多的仪式感。唯一的注意事项是当您配置MobX为`enforceActions`时。在这种情况下，您必须在异步代码中的*状态变化*中使用`runInAction()`进行包装。当操作中有几个异步部分时，**`flow()`**是一个更好的选择。它采用一个生成器函数（用`function*(){
    }`表示），其中插入了对各种*基于promise*的调用的`yield`。
- en: '`reaction()` and `autorun()` offer extra options to control their behavior.
    They share most of the options, such as *name*, *delay*, and *onError*. `reaction()`
    has two more options: to control how comparisons are made on the data produced
    by the *tracking-function* (`equals`), and if the *effect-function* should be
    fired immediately after the first run of the *tracking-function* (`fireImmediately`).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`reaction()`和`autorun()`提供了额外的选项来控制它们的行为。它们共享大多数选项，例如*名称*、*延迟*和*onError*。`reaction()`还有两个选项：控制如何对*跟踪函数*产生的数据进行比较（`equals`），以及在*跟踪函数*的第一次运行后是否立即触发*效果函数*（`fireImmediately`）。'
- en: In [Chapter 6](part0101.html#30A8Q0-58c2559ca4304cecab9bc46f496bc070), *Handling
    Real-World Use Cases*, we can start exploring approaches to tackling various common
    scenarios with MobX. If the chapters until now seemed like *science*, the next
    one is *applied-science*!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0101.html#30A8Q0-58c2559ca4304cecab9bc46f496bc070)中，*处理真实用例*，我们可以开始探索使用MobX解决各种常见情况的方法。如果到目前为止的章节看起来像是*科学*，那么下一章就是*应用科学*！
