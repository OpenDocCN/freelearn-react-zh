- en: Implementing Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Redux
- en: 'In this chapter, we''ll go step by step through the process of adding Redux
    to our app. We''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步介绍将Redux添加到我们的应用程序的过程。我们将涵盖以下教程：
- en: Installing Redux and preparing our project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Redux并准备我们的项目
- en: Defining actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义动作
- en: Defining reducers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义减速器
- en: Setting up the store
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置存储
- en: Communicating with a remote API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与远程API通信
- en: Connecting the store to the views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存储连接到视图
- en: Storing offline content using Redux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux存储离线内容
- en: Showing network connectivity status
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示网络连接状态
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: At some point during the development of most applications, we'll need a better
    way to handle the state of the overall app. This will ease sharing data across
    components and provide a more robust architecture for scaling our app in the future.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序的开发过程中，我们都需要更好地处理整个应用程序的状态的方法。这将简化在组件之间共享数据，并为将来扩展我们的应用程序提供更健壮的架构。
- en: In order to get a better understanding of Redux, the structure of this chapter
    will differ from previous chapters, since we'll be creating one app through all
    of these recipes. Each recipe in this chapter will depend on the last recipe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Redux，本章的结构将与以前的章节不同，因为我们将通过所有这些教程创建一个应用程序。本章中的每个教程都将依赖于上一个教程。
- en: We will be building a simple app for displaying user posts, and we'll use a
    `ListView` component to display the data returned from the API. We'll be using
    the excellent mock data API we've used before located at [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个简单的应用程序来显示用户帖子，并使用`ListView`组件来显示从API返回的数据。我们将使用位于[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)的优秀模拟数据API。
- en: Installing Redux and preparing our project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Redux并准备我们的项目
- en: In this recipe, we'll install Redux in an empty application, and we'll define
    the basic folder structure of our app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将在一个空应用程序中安装Redux，并定义我们应用程序的基本文件夹结构。
- en: Getting started
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: We'll need a new empty app for this recipe. Let's call it `redux-app`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个新的空应用程序来完成这个教程。让我们称之为`redux-app`。
- en: 'We''ll also need two dependencies: `redux` for handling state management and `react-redux` for
    gluing together Redux and React Native. You can install them from the command
    line with yarn:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要两个依赖项：`redux`用于处理状态管理和`react-redux`用于将Redux和React Native粘合在一起。您可以使用yarn从命令行安装它们：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or you can use `npm`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用`npm`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: As part of this recipe, we'll build out the folder structure that the app will
    use. Let's add a `components` folder with an `Album` folder inside of it to hold
    the photo album component. We'll also need a `redux` folder to hold all of our
    Redux code.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为这个教程的一部分，我们将构建应用程序将使用的文件夹结构。让我们添加一个`components`文件夹，里面有一个`Album`文件夹，用来保存相册组件。我们还需要一个`redux`文件夹来保存所有Redux代码。
- en: Inside the `redux` folder, let's add an `index.js` file for Redux initialization.
    We also need a `photos` directory, with an `actions.js` file and a `reducer.js`
    file.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`redux`文件夹中，让我们添加一个`index.js`文件进行Redux初始化。我们还需要一个`photos`目录，里面有一个`actions.js`文件和一个`reducer.js`文件。
- en: 'For now, the `App.js` file will only contain an `Album` component, which we''ll
    define later:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，`App.js`文件将只包含一个`Album`组件，我们稍后会定义：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Getting started*, we installed the `redux` and `react-redux` libraries.
    The `react-redux` library contains the necessary bindings to integrate Redux with
    React. Redux is not exclusively designed to work with React. You can use Redux
    with any other JavaScript libraries out there. By using `react-redux`, we'll be
    able to seamlessly integrate Redux into our React Native application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在*入门*中，我们安装了`redux`和`react-redux`库。`react-redux`库包含了将Redux与React集成的必要绑定。Redux并不是专门设计用于与React一起工作的。您可以将Redux与任何其他JavaScript库一起使用。通过使用`react-redux`，我们将能够无缝地将Redux集成到我们的React
    Native应用程序中。
- en: 'In *step 2*, we created the main folders we''ll use for our app:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们创建了我们应用程序将使用的主要文件夹：
- en: The `components` folder will contain our app components. In this case, we're
    only adding one `Album` component to keep this recipe simple.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`文件夹将包含我们的应用程序组件。在这种情况下，我们只添加了一个`Album`组件，以使本教程简单。'
- en: The `redux` folder will contain all of the Redux related code (initialization,
    actions, and reducers).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux`文件夹将包含所有与Redux相关的代码（初始化、操作和减速器）。'
- en: 'In a medium to large app, you will probably want to separate your React Native
    components further. The React community standard is to split the app''s components
    into three separate types:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在中等到大型的应用程序中，您可能希望进一步分离您的React Native组件。React社区的标准是将应用程序的组件分为三种不同的类型：
- en: '`Components`: The community calls them presentational components. In simple
    terms, these are the kind of components that are not aware of any business logic
    or Redux actions. These components only receive data via props and should be reusable
    on any other project. A button or panel would be a perfect example of a presentational
    component.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Components`：社区称它们为展示性组件。简单来说，这些是不知道任何业务逻辑或Redux操作的组件。这些组件只通过props接收数据，并且应该可以在任何其他项目中重复使用。按钮或面板将是展示性组件的完美例子。'
- en: '`Containers`: These are components that directly receive data from Redux and
    are able to call actions. In here, we''ll define components such as a header that
    displays the logged in user. Usually, these components internally use presentational
    components.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Containers`：这些是直接从Redux接收数据并能够调用操作的组件。在这里，我们将定义诸如显示已登录用户的标题之类的组件。通常，这些组件在内部使用展示性组件。'
- en: '`Pages/Views`: These are the main modules in the app that use containers and
    presentational components.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages/Views`：这些是应用程序中使用容器和展示性组件的主要模块。'
- en: For more information on structuring your Redux powered components, I recommend
    the excellent article, *Structure your React-Redux project for scalability and
    maintainability*, at the following link*:*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有关构建Redux支持组件的更多信息，我建议阅读以下链接的优秀文章，*为可扩展性和可维护性构建您的React-Redux项目*：
- en: '[https://levelup.gitconnected.com/structure-your-react-redux-project-for-scalability-and-maintainability-618ad82e32b7](https://levelup.gitconnected.com/structure-your-react-redux-project-for-scalability-and-maintainability-618ad82e32b7)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://levelup.gitconnected.com/structure-your-react-redux-project-for-scalability-and-maintainability-618ad82e32b7](https://levelup.gitconnected.com/structure-your-react-redux-project-for-scalability-and-maintainability-618ad82e32b7)'
- en: 'We will also need to create a `redux/photos` folder. In this folder, we''ll
    create the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个`redux/photos`文件夹。在这个文件夹中，我们将创建以下内容：
- en: The `actions.js` file, which will contain all of the actions the app can perform.
    We will talk more about actions on the next recipe.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions.js`文件，其中将包含应用程序可以执行的所有操作。我们将在下一个教程中更多地讨论操作。'
- en: The `reducer.js` file, which will contain all the code managing the data in
    the Redux store. We will dig deeper into this subject in later recipes.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducer.js`文件，其中将包含管理Redux存储中数据的所有代码。我们将在以后的教程中更深入地探讨这个主题。'
- en: Defining actions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义操作
- en: An action is a payload of information that sends data to the store. Using these
    actions is the *only* way components can request or send data to the Redux store,
    which serves as the global state object for the entire app. An action is just
    a plain JavaScript object. We'll be defining functions that return these actions.
    A function that returns an action is called an action creator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个action是发送数据到store的信息载荷。使用这些actions是组件请求或发送数据到Redux store的*唯一*方式，Redux store作为整个应用程序的全局状态对象。一个action只是一个普通的JavaScript对象。我们将定义返回这些actions的函数。返回action的函数称为action
    creator。
- en: In this recipe, we'll create the actions to load the initial images for the
    gallery. During this recipe, we'll be adding hardcoded data, but later on, we'll
    request this data from an API to create a more realistic scenario.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建加载图库初始图片的actions。在这个教程中，我们将添加硬编码的数据，但以后，我们将从API请求这些数据，以创建更真实的场景。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's continue working on the code from the previous recipe. Make sure to follow
    those steps in order to have Redux installed and build out the folder structure
    that we'll use for this project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在上一个教程中的代码上工作。确保按照这些步骤安装Redux并构建我们将在此项目中使用的文件夹结构。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll need to define types for each the action. Open the `redux/photos/actions.js`
    file. Action types are defined as constants that can later be referenced in actions
    and reducers, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为每个action定义类型。打开`redux/photos/actions.js`文件。action类型被定义为常量，以便稍后在actions和reducers中引用，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s create our first action creator. Every action needs a `type` property
    to define it, and actions will often have a `payload` property of data to pass
    along with the action. In this recipe, we''re hardcoding a mock API response made
    up of an array of two photo objects, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的第一个action creator。每个action都需要一个`type`属性来定义它，而且actions通常会有一个`payload`属性，用于传递数据。在这个教程中，我们将硬编码一个由两个照片对象组成的模拟API响应，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will need an action creator for each action we want the app to be able to
    execute, and we want this app to be able to add and remove images. First, let''s
    add the `addBookmark` action creator, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要为每个我们希望应用程序能够执行的action创建一个action creator，并且我们希望这个应用程序能够添加和删除图片。首先，让我们添加`addBookmark`
    action creator，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Likewise, we''ll need another action creator for removing photos:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们还需要另一个用于删除照片的action creator：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we defined the action's type to indicate what it does, which in
    this case is fetch images. We use a constant since it will be used in multiple
    places, including action creators, reducers, and tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们定义了action的类型来指示它的作用，这种情况下是获取图片。我们使用常量，因为它将在多个地方使用，包括action creators、reducers和测试。
- en: In *step 2*, we declared an action creator. Actions are simple JavaScript objects
    that define an event that happens in our app that will affect the state of the
    app. We use actions to interact with data that lives in the Redux store.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们声明了一个action creator。Actions是简单的JavaScript对象，定义了在我们的应用程序中发生的事件，这些事件将影响应用程序的状态。我们使用actions与Redux存储中的数据进行交互。
- en: 'There''s only one single requirement: each action must have a `type` property.
    In addition, an action will often include a `payload` property that holds data
    relevant to the action. In this case, we are using an array of photo objects.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个单一的要求：每个action必须有一个`type`属性。此外，一个action通常会包括一个`payload`属性，其中包含与action相关的数据。在这种情况下，我们使用了一个照片对象的数组。
- en: An action is valid as long as the `type` property is defined. If we want to
    send anything else, it is a common convention to use the `payload` property as
    popularized by the flux pattern. However, the name property isn't inherently special.
    We could name this `params` or `data` and the behavior would remain the same.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`type`属性被定义，一个action就是有效的。如果我们想发送其他内容，使用`payload`属性是一种常见的约定，这是flux模式所推广的。然而，name属性并不是固有特殊的。我们可以将其命名为`params`或`data`，行为仍然相同。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Currently, we have defined the action creators, which are simple functions that
    return actions. In order to use them, we need to use the `dispatch` method provided
    by the Redux `store`. We will learn more about the store in later recipes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经定义了动作创建者，它们是简单的返回动作的函数。为了使用它们，我们需要使用Redux `store`提供的`dispatch`方法。我们将在后面的配方中了解更多关于store的内容。
- en: Defining reducers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义reducers
- en: At this point, we have created a few actions for our app. As discussed earlier,
    actions define that something should happened, but we haven't created anything
    for putting the action into motion. That's where reducers come in. Reducers are
    functions that define how an action should affect the data in the Redux `store`.
    All accessing of data in the `store` happens in a reducer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的应用创建了一些动作。正如前面讨论的，动作定义了应该发生的事情，但我们还没有为执行动作创建任何内容。这就是reducers的作用。Reducers是定义动作如何影响Redux
    `store`中的数据的函数。在reducer中访问`store`中的数据。
- en: Reducers receive two parameters: `state` and `action`. The `state` parameter
    represents the global state of the app, and the `action` parameter is the action
    object being used by the reducer. Reducers return a new `state`  parameter reflecting
    the changes that are associated with a given `action`  parameter. In this recipe,
    we'll introduce a reducer for fetching the photos by using the actions we defined
    in the previous recipe.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers接收两个参数：`state`和`action`。`state`参数表示应用的全局状态，`action`参数是reducer使用的动作对象。Reducers返回一个新的`state`参数，反映了与给定`action`参数相关的更改。在这个配方中，我们将介绍一个用于通过在前一个配方中定义的动作来获取照片的reducer。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe depends on the previous recipe, *Defining actions**.* Be sure to
    start from the beginning of this chapter to avoid any problems or confusion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方依赖于前一个配方*定义动作*。确保从本章的开头开始，以避免任何问题或混淆。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening the `photos/reducer.js` file and importing all of the
    action types we defined in the previous recipe, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`photos/reducer.js`文件开始，并导入我们在前一个配方中定义的所有动作类型，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll define an initial state object for the state in this reducer. It has
    a `photos` property initialized to an empty array for the currently loaded photos,
    as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为这个reducer中的状态定义一个初始状态对象。它有一个`photos`属性，初始化为一个空数组，用于当前加载的照片，如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now define the `reducer` function. It''ll receive two parameters, the
    current state and the action that has been dispatched, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义`reducer`函数。它将接收两个参数，当前状态和已经被分发的动作，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: React Native components can also have a `state` object, but that is an entirely
    separate `state` from that which Redux uses. In this context, `state` refers to
    the global state stored in the Redux `store`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: React Native组件也可以有一个`state`对象，但这是一个完全独立于Redux使用的`state`。在这个上下文中，`state`指的是存储在Redux
    `store`中的全局状态。
- en: 'State is immutable, so instead of manipulating state, inside the reducer function,
    we need to return a new state for the current action, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是不可变的，所以在reducer函数内部，我们需要返回当前动作的新状态，而不是操纵状态，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to add a new bookmark to the array, all we need to do is get the payload
    of the action and include it in the new array. We can use the spread operator
    to spread the current photos array on `state`, then add `action.payload` to the
    new array, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将新的书签添加到数组中，我们只需要获取操作的有效负载并将其包含在新数组中。我们可以使用展开运算符在`state`上展开当前的照片数组，然后将`action.payload`添加到新数组中，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to remove an item from the array, we can use the filter method,
    as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想从数组中删除一个项目，我们可以使用filter方法，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final step is to combine all of the reducers that we have. In a larger
    app, you will likely have reason to break your reducers into separate files. Since
    we''re only using one reducer, this step is technically optional, but it illustrates
    how multiple reducers can be combined together with Redux''s `combineReducers`
    helper. Let''s use it in the `redux/index.js` file, which we''ll also use to initiate
    the Redux store in the next recipe, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将我们拥有的所有reducer组合在一起。在一个更大的应用程序中，您可能有理由将您的reducer拆分成单独的文件。由于我们只使用一个reducer，这一步在技术上是可选的，但它说明了如何使用Redux的`combineReducers`助手将多个reducer组合在一起。让我们在`redux/index.js`文件中使用它，我们还将在下一个示例中用它来初始化Redux存储，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 1*, we imported all of the action types that we declared in the previous
    recipe. We use these types to determine what action should be taken and how `action.payload`
    should affect the Redux state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们导入了在上一个示例中声明的所有操作类型。我们使用这些类型来确定应该采取什么操作以及`action.payload`应该如何影响Redux状态。
- en: In *step 2*, we defined the initial state of the `reducer` function. For now,
    we only need an empty array for our photos, but we could add other properties
    to the state, such as Boolean properties of `isLoading` and `didError` to track
    loading and error states. These can, in turn, be used to update the UI during
    and in response to `async` actions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们定义了`reducer`函数的初始状态。目前，我们只需要一个空数组来存储我们的照片，但我们可以向状态添加其他属性，例如`isLoading`和`didError`的布尔属性来跟踪加载和错误状态。这些可以反过来用于在`async`操作期间和响应`async`操作时更新UI。
- en: 'In *step 3*, we defined the `reducer` function, which receives two parameters:
    the current state and the action that is being dispatched. We set the initial
    state to `initialState` if we are not provided with one. This way, we can ensure
    that the photos array exists at all times within the app, which will help in avoiding
    errors in cases where actions get dispatched that don''t affect the Redux state.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们定义了`reducer`函数，它接收两个参数：当前状态和正在分派的操作。如果没有提供初始状态，我们将初始状态设置为`initialState`。这样，我们可以确保照片数组始终存在于应用程序中，这将有助于避免在分派不影响Redux状态的操作时出现错误。
- en: In *step 4*, we defined an action for fetching photos. Remember that state is
    never directly manipulated. If the action's type matches the case, a new state
    object is created by combining the current `state.photos` array with the incoming
    photos on `action.payload`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了一个用于获取照片的操作。请记住，状态永远不会被直接操作。如果操作的类型与case匹配，那么通过将当前的`state.photos`数组与`action.payload`上的传入照片组合在一起，将创建一个新的状态对象。
- en: The `reducer` function should be pure. This means there shouldn't be side effects
    on any of the input values. Mutating the state or the action is bad practice and
    should always be avoided. A mutation can lead to inconsistent data or not triggering
    a render correctly. Also, in order to prevent side effects, we should avoid executing
    any AJAX requests inside the reducer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducer`函数应该是纯的。这意味着任何输入值都不应该有副作用。改变状态或操作是不好的做法，应该始终避免。突变可能导致数据不一致或无法正确触发渲染。此外，为了防止副作用，我们应该避免在reducer内部执行任何AJAX请求。'
- en: In *step 5*, we created the action for adding a new element to the photos array,
    but instead of using `Array.push`, we are returning a new array and appended the
    incoming element to the last position to avoid mutating the original array on
    the state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们创建了向photos数组添加新元素的action，但我们没有使用`Array.push`，而是返回一个新数组，并将传入的元素附加到最后一个位置，以避免改变状态中的原始数组。
- en: In *step 6*, we added an action for removing the bookmark from the state. The
    easiest way to do this is by using the `filter` method so we can ignore the element
    with the ID that was received on the action's payload.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们添加了一个从状态中删除书签的action。这样做的最简单方法是使用`filter`方法，这样我们就可以忽略在action的payload中收到的ID对应的元素。
- en: 'In *step 7*, we use the `combineReducers` function to merge all of the reducers
    into a single global state object that will be saved in the store. This function
    will call each reducer with the key in the state that corresponds to that reducer;
    this function is exactly the same as the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们使用`combineReducers`函数将所有的reducers合并成一个单一的全局状态对象，该对象将保存在store中。这个函数将使用与reducer对应的状态中的键调用每个reducer；这个函数与下面的函数完全相同：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The photos reducer has only been called on the part of the state that cares
    about photos. This will help you avoid managing all state data in a single reducer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: photos reducer只被调用了关心photos的状态的部分。这将帮助你避免在单个reducer中管理所有状态数据。
- en: Setting up the Redux store
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Redux store
- en: The Redux store is responsible for updating the information that is calculated
    on the state inside reducers. It is a single global object, which can be accessed
    via the store's `getState` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Redux store负责更新reducers内部计算的状态信息。它是一个单一的全局对象，可以通过store的`getState`方法访问。
- en: In this recipe, we'll tie together the actions and the reducer we created in
    previous recipes. We will use the existing actions to affect data that lives in
    the store. We will also learn how to log changes on the state by subscribing to
    the store changes. This recipe serves more as a proof of concept of how actions,
    reducers, and the store work together. We'll dive deeper into how Redux is more
    commonly used within apps later in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将把之前创建的actions和reducer联系在一起。我们将使用现有的actions来影响存储在store中的数据。我们还将学习如何通过订阅store的更改来记录状态的变化。这个食谱更多地作为一个概念的证明，说明了actions、reducers和store是如何一起工作的。我们将在本章后面更深入地了解Redux在应用程序中更常见的用法。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s open the `redux/index.js` file and import the `createStore` function
    from `redux`, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`redux/index.js`文件，并从`redux`中导入`createStore`函数，如下所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating the store is extremely simple; all we need to do is call the function
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建store非常简单；我们只需要调用函数
- en: 'imported in *step 1* and send the reducers as the first parameter, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中导入并将reducers作为第一个参数发送，如下所示：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s it! We''ve set up the store, so now let''s dispatch some actions. The
    next steps in this recipe will be removed from the final project since they''re
    for testing our setup. Let''s start by importing the action creators we would
    like to dispatch:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！我们已经设置好了store，现在让我们分发一些actions。这个食谱中的下一步将从最终项目中删除，因为它们是用来测试我们的设置。让我们首先导入我们想要分发的action
    creators：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before dispatching any actions, let''s subscribe to the store, which will allow
    us to listen to any changes that occur in the store. For our current purposes,
    we only need to `console.log` the result of `store.getState()`, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分发任何actions之前，让我们订阅store，这将允许我们监听store中发生的任何更改。对于我们当前的目的，我们只需要`console.log`
    `store.getState()`的结果，如下所示：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s dispatch some actions and see the resulting state in the Developer console:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分发一些actions，并在开发者控制台中查看结果状态：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to add a new bookmark, we need to dispatch the `addBookmark` action
    creator with the photos object as the parameter:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加一个新的书签，我们需要使用照片对象作为参数来分派`addBookmark`操作创建者：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To remove an item, we pass along the `id` of the photo we want to remove to
    the action creator, since this is what the reducer is using to find the item that
    should be deleted:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除一个项目，我们将要删除的照片的`id`传递给操作创建者，因为这是减速器用来查找应该被删除的项目的内容：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After executing all of these actions, we can stop listening to changes on the
    store by running the unsubscribe function we created in *step 4* when we subscribed
    to the store, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行完所有这些操作后，我们可以通过运行我们在*步骤4*中订阅store时创建的取消订阅函数来停止监听store上的更改，如下所示：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to import the `redux/index.js` file into the `App.js` file, which will
    run all of the code in this recipe so we can see the related `console.log` messages
    in the Developer console:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`redux/index.js`文件导入到`App.js`文件中，这将运行本示例中的所有代码，以便我们可以在开发者控制台中看到相关的`console.log`消息：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 3*, we imported the action creators we created in the earlier recipe, *Defining
    actions*. Even though we don't yet have a UI, we can use the Redux store and observe
    the changes as they happen. All it takes is calling an action creator and then
    dispatching the resulting action.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们导入了我们在之前的示例*定义操作*中创建的操作创建者。即使我们还没有UI，我们也可以使用Redux存储并观察更改的发生。只需调用一个操作创建者，然后分派生成的操作即可。
- en: In *step 5*, we called the `dispatch` method from the `store` instance. `dispatch`
    takes an action, which is created by the `loadBookmarks` action creator. The reducer
    will be called in turn, which will set the new photos on the state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们从`store`实例中调用了`dispatch`方法。`dispatch`接受一个由`loadBookmarks`操作创建者创建的操作。然后将依次调用减速器，这将在状态上设置新的照片。
- en: Once we have our UI in place, we'll dispatch the actions in a similar fashion
    from our components, which will update the state, ultimately triggering a re-render
    of the component, displaying the new data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的UI就位，我们将以类似的方式从我们的组件中分发操作，这将更新状态，最终触发组件的重新渲染，显示新数据。
- en: Communicating with a remote API
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与远程API通信
- en: We are currently loading the bookmarks from hardcoded data in the action. In
    a real app, we're much more likely to be getting data back from an API. In this
    recipe, we'll use a Redux middleware to help with the process of fetching data
    from an API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前正在从操作中的硬编码数据中加载书签。在真实的应用程序中，我们更有可能从API中获取数据。在这个示例中，我们将使用Redux中间件来帮助从API中获取数据的过程。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be using `axios` to make all AJAX requests. Install
    it with `npm`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`axios`来进行所有的AJAX请求。使用`npm`安装它：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or you can install it with `yarn`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用`yarn`安装它：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For this recipe, we''ll be using the Redux middleware, `redux-promise-middleware`.
    Install the package with `npm`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用Redux中间件`redux-promise-middleware`。使用`npm`安装该软件包：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or you can install it with `yarn`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用`yarn`安装它：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This middleware will create and automatically dispatch three related actions
    for each AJAX request made in our app: one when a request begins, one when a request
    succeeds, and one for when a request fails. Using this middleware, we are able
    to define an action creator that returns an action object with a *promise* for
    a payload. In our case, we''ll be creating the `async` action, `FETCH_PHOTOS`,
    whose payload is an API request. The middleware will create and dispatch an action
    of the `FETCH_PHOTOS_PENDING` type. When the request resolves, the middleware
    will create and dispatch either an action of the `FETCH_PHOTOS_FULFILLED` type with
    the resolved data as the `payload` if the request was successful or an action
    of the `FETCH_PHOTOS_REJECTED` type with the error as a `payload` if the request
    failed.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件将为我们应用程序中进行的每个AJAX请求创建并自动分派三个相关的动作：一个是在请求开始时，一个是在请求成功时，一个是在请求失败时。使用这个中间件，我们能够定义一个返回带有*promise*负载的动作创建者。在我们的情况下，我们将创建`async`动作`FETCH_PHOTOS`，其负载是一个API请求。中间件将创建并分派一个`FETCH_PHOTOS_PENDING`类型的动作。当请求解析时，中间件将创建并分派一个`FETCH_PHOTOS_FULFILLED`类型的动作，如果请求成功，则将解析的数据作为`payload`，如果请求失败，则将错误作为`payload`的`FETCH_PHOTOS_REJECTED`类型的动作。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s start by adding the new middleware to our Redux store. In the `redux/index.js`
    file, let''s add the Redux method, `applyMiddleware`. We''ll also add the new
    middleware we just installed, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先将新的中间件添加到我们的Redux存储中。在`redux/index.js`文件中，让我们添加Redux方法`applyMiddleware`。我们还将添加我们刚刚安装的新中间件，如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the call to `createStore` that we defined previously, we can pass in `applyMiddleware`
    as the second parameter. `applyMiddleware` takes one parameter, which is the middleware
    we want to use, `promiseMiddleware`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前定义的`createStore`调用中，我们可以将`applyMiddleware`作为第二个参数传递。`applyMiddleware`接受一个参数，即我们要使用的中间件`promiseMiddleware`：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Unlike some other popular Redux middleware solutions such as `redux-thunk`, `promiseMiddleware`
    must be invoked when it is passed to `applyMiddleware`. It is a function that
    returns the middleware.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些流行的Redux中间件解决方案（如`redux-thunk`）不同，`promiseMiddleware`在传递给`applyMiddleware`时必须被调用。它是一个返回中间件的函数。
- en: 'We''re going to be making real API requests in our actions now, so we need
    to import `axios` into `redux/photos/actions`. We''ll also add the API''s base
    URL. We are using the same dummy data API we used in previous chapters, hosted
    at [http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com),
    as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在我们的动作中进行真正的API请求，因此我们需要将`axios`导入到`redux/photos/actions`中。我们还将添加API的基本URL。我们使用的是前几章中使用的相同的虚拟数据API，托管在[http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com)，如下所示：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we''ll update our action creators. We''ll first update the types we need
    for handling AJAX requests, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的动作创建者。我们将首先更新我们处理AJAX请求所需的类型，如下所示：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Instead of returning dummy data as `payload` for this action, we''ll return
    a `GET` request. Since this is a `Promise`, it will trigger our new middleware.
    Also, notice how the action''s type is `FETCH_PHOTOS`. This will cause the middleware
    to automatically create `FETCH_PHOTOS_PENDING`, `FETCH_PHOTOS_FULFILLED` with
    a `payload` of resolved data when successful, and `FETCH_PHOTOS_REJECTED` with
    a `payload` of the error that occurred, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其为这个动作返回虚拟数据作为`payload`，我们将返回一个`GET`请求。由于这是一个`Promise`，它将触发我们的新中间件。另外，请注意动作的类型是`FETCH_PHOTOS`。这将导致中间件自动创建`FETCH_PHOTOS_PENDING`，`FETCH_PHOTOS_FULFILLED`，如果成功则带有解析数据的`payload`，以及`FETCH_PHOTOS_REJECTED`，带有发生的错误的`payload`，如下所示：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just like the `FETCH_PHOTOS` action, we''ll be making use of the same middleware
    provided types for the `ADD_PHOTO` action, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`FETCH_PHOTOS`动作一样，我们将利用相同的中间件提供的类型来处理`ADD_PHOTO`动作，如下所示：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The action creator itself will no longer just return the passed in photo as
    the `payload`, but instead will pass a `POST` request promise for adding the image
    via the API, as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: action creator本身将不再只返回传入的照片作为`payload`，而是将通过API传递一个`POST`请求的promise来添加图片，如下所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can follow the same pattern to convert the `REMOVE_PHOTO` action into an
    AJAX request that uses the API to *delete* a photo. Like the other two action
    creators for `ADD_PHOTO` and `FETCH_PHOTOS`, we''ll define the action types for
    each action, then return the delete `axios` request as the action''s `payload`.
    Since we''ll need `photoId` in the reducer when we remove the image object from
    the Redux store, we also pass that along as an object on the action''s `meta` property,
    as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按照相同的模式将`REMOVE_PHOTO`动作转换为使用API进行*删除*照片的AJAX请求。像`ADD_PHOTO`和`FETCH_PHOTOS`这两个action
    creator一样，我们将为每个动作定义动作类型，然后将删除`axios`请求作为动作的`payload`返回。由于在我们从Redux存储中删除图像对象时，我们将需要`photoId`在reducer中，因此我们还将其作为动作的`meta`属性上的对象传递，如下所示：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to revisit our reducers to adjust the expected payload. In `redux/reducers.js`,
    we''ll start by importing all of the action types we''ll be using, and we''ll
    update `initialState`. For reasons that will be apparent in the next recipe, let''s
    rename the array of photos on the `state` object to `loadedPhotos`, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要重新审视我们的reducers以调整预期的payload。在`redux/reducers.js`中，我们将首先导入我们将使用的所有动作类型，并更新`initialState`。由于在下一个步骤中将会显而易见的原因，让我们将`state`对象上的照片数组重命名为`loadedPhotos`，如下所示：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the reducer itself, update each case to take the `FULFILLED` variation of
    the base action: `FETCH_PHOTOS` becomes `FETCH_PHOTOS_FULFILLED`, `ADD_PHOTOS`
    becomes `ADD_PHOTOS_FULFILLED`, and `REMOVE_PHOTOS` becomes `REMOVE_PHOTOS_FULFILLED`.
    We''ll also update all of the references to the photos array of `state` from `photos`
    to `loadedPhotos`.  When using `axios`, all response objects will contain a `data`
    parameter that holds the actual data received from the API, which means we''ll
    also need to update all references of `action.payload` to `action.payload.data`.
    And in the `REMOVE_PHOTO_FULFILLED` reducer, we can no longer find `photoId` at `action.payload.id`,
    which is why we passed `photoId` on the action''s `meta` property in *step 8*,
    therefore `action.payload.id` becomes `action.meta.photoId`, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在reducer本身中，更新每个case以采用基本动作的`FULFILLED`变体：`FETCH_PHOTOS`变为`FETCH_PHOTOS_FULFILLED`，`ADD_PHOTOS`变为`ADD_PHOTOS_FULFILLED`，`REMOVE_PHOTOS`变为`REMOVE_PHOTOS_FULFILLED`。我们还将更新所有对`state`的`photos`数组的引用，将其从`photos`更新为`loadedPhotos`。在使用`axios`时，所有响应对象都将包含一个`data`参数，其中包含从API接收到的实际数据，这意味着我们还需要将所有对`action.payload`的引用更新为`action.payload.data`。在`REMOVE_PHOTO_FULFILLED`
    reducer中，我们无法再在`action.payload.id`中找到`photoId`，这就是为什么我们在*步骤8*中在动作的`meta`属性上传递了`photoId`，因此`action.payload.id`变为`action.meta.photoId`，如下所示：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 2*, we applied the middleware that was installed in the *Getting started*
    section. As mentioned before, this middleware will allow us to make just one action
    creator for AJAX actions that automatically creates individual action creators
    for the `PENDING`, `FULFILLED`, and `REJECTED` request states.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们应用了在*入门*部分安装的中间件。如前所述，这个中间件将允许我们为自动创建`PENDING`、`FULFILLED`和`REJECTED`请求状态的单个动作创建AJAX动作的动作创建者。
- en: In *step 5*, we defined the `fetchPhotos` action creator. You'll recall from
    the previous recipes that actions are plain JavaScript objects. Since we defined
    a Promise on the action's payload property, `redux-promise-middleware` will intercept
    this action and automatically create the three associated actions for the three
    possible request states.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了`fetchPhotos`动作创建者。您会回忆起前面的食谱，动作是普通的JavaScript对象。由于我们在动作的payload属性上定义了一个Promise，`redux-promise-middleware`将拦截此动作并自动为三种可能的请求状态创建三个关联的动作。
- en: In *step 7* and *step 8*, we defined the `addPhoto` action creator and the `removePhoto`
    action creator which, just like `fetchPhotos`, have an AJAX request as the action
    payload.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*和*步骤8*中，我们定义了`addPhoto`动作创建器和`removePhoto`动作创建器，就像`fetchPhotos`一样，它们的操作负载是一个AJAX请求。
- en: By utilizing this middleware, we are able to avoid repeating the same boilerplate
    over and over for making different AJAX requests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个中间件，我们能够避免重复使用相同的样板来进行不同的AJAX请求。
- en: In this recipe, we only handled the success conditions of the AJAX requests
    made in the app. It would be wise in a real app to also handle the error states
    represented with actions types ending in `_REJECTED`. This will be a great place
    to handle an error by saving it to the Redux store, so that the view can display
    error information when it occurs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只处理了应用程序中进行的AJAX请求的成功条件。在真实的应用程序中，明智的做法是还要处理以`_REJECTED`结尾的操作类型表示的错误状态。这将是一个处理错误的好地方，通过将其保存到Redux存储器中，以便在发生错误时视图可以显示错误信息。
- en: Connecting the store to the view
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将存储器连接到视图
- en: So far, we have set up the state, we have included middleware, and we've defined
    actions, action creators, and reducers for interacting with a remote API. However,
    we are not able to show any of this data on the screen. In this recipe, we'll
    enable our component to access the store that we have created.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了状态，包括了中间件，并为与远程API交互定义了动作、动作创建器和减速器。然而，我们无法在屏幕上显示任何这些数据。在这个配方中，我们将使我们的组件能够访问我们创建的存储器。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe depends on all of the previous ones, so make sure to follow each
    recipe preceding this one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方依赖于之前的所有配方，所以确保按照本配方之前的每个配方进行操作。
- en: In the first recipe of this chapter, we installed the `react-redux` library
    along with our other dependencies. In this recipe, we are finally going to make
    use of it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个配方中，我们安装了`react-redux`库以及其他依赖项。在这个配方中，我们终于要开始使用它了。
- en: 'We''ll also be using a third-party library for generating random color hexes,
    which we''ll use to request colored images from the placeholder image service
    at [https://placehold.it/](https://placehold.it/). Before we begin, install `randomcolor`
    with `npm`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用第三方库来生成随机颜色十六进制值，我们将使用它来从占位图像服务[https://placehold.it/](https://placehold.it/)请求彩色图像。在开始之前，使用`npm`安装`randomcolor`：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or you can install it with `yarn`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您也可以使用`yarn`安装它：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by wiring the Redux store to the React Native app in `App.js`.
    We''ll start with the imports, importing `Provider` from `react-redux` and the
    store we created earlier. We''ll also import the `Album` component we''ll be defining
    shortly, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将Redux存储器连接到React Native应用程序的`App.js`开始。我们将从导入开始，从`react-redux`导入`Provider`和我们之前创建的存储器。我们还将导入我们即将定义的`Album`组件，如下所示：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It''s the job of  the `Provider` to connect our Redux store to the React Native
    app so that the app''s components can communicate with the store. `Provider` should
    be used to wrap the entire app, and since this app lives in the `Album` component,
    we''ll wrap the `Album` component with the `Provider` component. `Provider` takes
    a `store` prop, where we''ll pass in our Redux store. The app and the store are
    wired:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Provider`的工作是将我们的Redux存储器连接到React Native应用程序，以便应用程序的组件可以与存储器通信。`Provider`应该用于包装整个应用程序，由于此应用程序位于`Album`组件中，我们将`Album`组件与`Provider`组件一起包装。`Provider`接受一个`store`属性，我们将传入我们的Redux存储器。应用程序和存储器已连接：'
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s turn to the `Album` component. The component will live at `components/Album/index.js`.
    We''ll start with the imports. We''ll import the `randomcolor` package for generating
    random color hexes, as mentioned in the *Getting started* section. We''ll also
    import `connect` from `react-redux`, and the action creators we defined in previous
    recipes. `connect` will wire our app to the Redux store, and we can then use the
    action creators to affect the store''s state, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转向`Album`组件。该组件将位于`components/Album/index.js`。我们将从导入开始。我们将导入`randomcolor`包以生成随机颜色十六进制值，如*入门*部分所述。我们还将从`react-redux`中导入`connect`，以及我们在之前的示例中定义的action
    creators。`connect`将连接我们的应用程序到Redux存储，并且我们可以使用action creators来影响存储的状态，如下所示：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s create the `Album` class, however, instead of directly exporting `Album`
    as the `default` export, we''ll use `connect` to wire `Album` to the store. Note
    that `connect` is called with two sets of parentheses and that the component is
    passed into the second set, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`Album`类，但是，我们不会直接将`Album`作为`default`导出，而是使用`connect`将`Album`连接到存储。请注意，`connect`使用了两组括号，并且组件被传递到了第二组括号中，如下所示：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first set of parentheses in a call to `connect` takes two function parameters:
    `mapStateToProps` and `mapDispatchToProps`. We''ll define `mapStateToProps` first,
    which takes `state` as a parameter. This `state` is our global Redux state object
    containing all of our data. The function returns an object of the pieces of `state`
    that we want to use in our component. In our case, we just need the `loadedPhotos`
    property from the `photos` reducer. By setting this value to `photos` in the return
    object, we can expect `this.props.photos` to be the value stored in `state.photos.loadedPhotos`.
    And it will change automatically when the Redux store is updated:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`connect`时，第一组括号接受两个函数参数：`mapStateToProps`和`mapDispatchToProps`。我们将首先定义`mapStateToProps`，它以`state`作为参数。这个`state`是我们的全局Redux状态对象，包含了所有的数据。该函数返回一个包含我们想在组件中使用的`state`片段的对象。在我们的情况下，我们只需要从`photos`
    reducer中的`loadedPhotos`属性。通过将这个值设置为返回对象中的`photos`，我们可以期望`this.props.photos`是存储在`state.photos.loadedPhotos`中的值。当Redux存储更新时，它将自动更改：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Similarly, the `mapDispatchToProps` function will map our action creators to
    the component''s props as well. The function receives the Redux method, `dispatch`,
    which is used to execute an action creator. We''ll map the execution of each action
    creator to a key of the same name, so that `this.props.fetchPhotos()` will execute `dispatch(fetchPhotos())`,
    and so on, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`mapDispatchToProps`函数也将我们的action creators映射到组件的props。该函数接收Redux方法`dispatch`，用于执行action
    creator。我们将每个action creator的执行映射到相同名称的键上，这样`this.props.fetchPhotos()`将执行`dispatch(fetchPhotos())`，依此类推，如下所示：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we''ve got our Redux store wired to our component, let''s create the
    component itself. We can make use of the `componentDidMount` life cycle hook to
    fetch our photos, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将Redux存储连接到了我们的组件，让我们创建组件本身。我们可以利用`componentDidMount`生命周期钩子来获取我们的照片，如下所示：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will also need a method for adding photos. Here, we''ll use the `randomcolor`
    package (imported as `randomColor` by convention) to create an image with the
    [placehold.it](http://placehold.it) service. The generated color string comes
    back with a hash prefixing the hex value, which the request to the image service
    doesn''t want, so we can simply remove it with a `replace` call. To add the photo,
    we just call the `addPhoto` function mapped to `props`, passing in the new `photo`
    object, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个添加照片的方法。在这里，我们将使用`randomcolor`包（按照惯例导入为`randomColor`）来使用[placehold.it](http://placehold.it)服务创建一张图片。生成的颜色字符串带有一个哈希前缀的十六进制值，而图片服务的请求不需要这个前缀，所以我们可以简单地使用`replace`调用来移除它。要添加照片，我们只需调用映射到`props`的`addPhoto`函数，传入新的`photo`对象，如下所示：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will also need a `removePhoto` function. All this function needs to do is
    call the `removePhoto` function that has been mapped to `props`, passing in the
    ID of the photo to be removed, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`removePhoto`函数。这个函数所需要做的就是调用已经映射到`props`的`removePhoto`函数，并传入要删除的照片的ID，如下所示：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The template for the app will need a `TouchableOpacity` button for adding photos,
    a `ScrollView` for holding all of the images in a scrollable list, and all of
    our images. Each `Image` component will also be wrapped in a `TouchableOpacity`
    component for calling the `removePhoto` method when an image is pressed, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的模板将需要一个`TouchableOpacity`按钮用于添加照片，一个`ScrollView`用于容纳所有图像的可滚动列表，以及所有我们的图像。每个`Image`组件还将包装在一个`TouchableOpacity`组件中，以在按下图像时调用`removePhoto`方法，如下所示：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we''ll add styles so that the app has a layout, as follows. There''s
    nothing here we haven''t covered many times before:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加样式，以便应用程序具有布局，如下所示。这里没有我们之前没有多次涵盖过的内容：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The app is complete! Clicking on the Add Photo button will add a new photo
    to the beginning of the list of images, and pressing an image will remove it.
    Note, since we are using a dummy data API, the `POST` and `DELETE` requests will
    return proper responses for the given action. However, no data is actually added
    or deleted to the database. This means that the image list will reset if the app
    is refreshed, and that you can expect errors if you attempt to delete any photos
    you''ve just added with the Add Photo button. Feel free to connect this app to
    a real API and database to see the expected results:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已完成！单击“添加照片”按钮将在图像列表的开头添加一个新照片，并按下图像将删除它。请注意，由于我们使用的是虚拟数据API，因此`POST`和`DELETE`请求将返回给定操作的适当响应。但是，实际上并没有向数据库添加或删除任何数据。这意味着如果应用程序被刷新，图像列表将重置，并且如果您尝试使用“添加照片”按钮添加的任何照片，您可以期望出现错误。随时将此应用程序连接到真实的API和数据库以查看预期结果：
- en: '![](assets/46c604eb-1e47-4f34-af62-5854ca99c453.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46c604eb-1e47-4f34-af62-5854ca99c453.png)'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 4*, we used the `connect` method provided by `react-redux` to empower
    the `Album` component with a connection to the Redux store we've been working
    on this entire chapter. The call to `connect` returns a function that is immediately
    executed via the second set of parentheses. By passing the `Album` component into
    this returning function, `connect` glues the component and the store together.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们使用了`react-redux`提供的`connect`方法，为`Album`组件赋予了与我们在整个章节中一直在使用的Redux存储库的连接。对`connect`的调用返回一个函数，该函数立即通过第二组括号执行。通过将`Album`组件传递到此返回函数中，`connect`将组件和存储库粘合在一起。
- en: In *step 5*, we defined the `mapStateToProps` function. The first parameter
    in this function is `state` from the Redux store, which is injected into the function
    by `connect`. Whatever keys are defined in the object returned from `mapStateToProps`
    will be properties on the component's `props`. The value of these props will be
    subscribed to `state` in the Redux store, so that any change affecting these pieces
    of `state` will be automatically updated within the component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了`mapStateToProps`函数。此函数中的第一个参数是Redux存储库中的`state`，它由`connect`注入到函数中。从`mapStateToProps`返回的对象中定义的任何键都将成为组件`props`上的属性。这些props的值将订阅Redux存储库中的`state`，因此任何影响这些`state`片段的更改都将在组件内自动更新。
- en: While `mapStateToProps` will map `state` in the Redux store to the component
    props, `mapDispatchToProps` will map the *action creators* to the component props.
    In *step 6*, we defined this function. It has the special Redux method, `dispatch`,
    injected into it for calling action creators that live in the store. `mapDispatchToProps`
    returns an object, mapping the `dispatch` calls for actions to the components
    props at the specified keys.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps` 将 Redux 存储中的 `state` 映射到组件的 props，而 `mapDispatchToProps`
    将 *action creators* 映射到组件的 props。在 *步骤 6* 中，我们定义了这个函数。它具有特殊的 Redux 方法 `dispatch`，用于调用存储中的
    action creators。`mapDispatchToProps` 返回一个对象，将 actions 的 `dispatch` 调用映射到组件的 props
    上指定的键。'
- en: In *step 7*, we created the `componentDidMount` method. All the component needs
    to do to get the photos it needs while mounting is to call the action creator
    mapped to `this.props.fetchPhotos`. That's all! The `fetchPhotos` action creator
    will be dispatched. The `fetchPhoto` action returned from the action creator will
    be processed by the `redux-promise-middleware` we applied in a previous recipe
    since the `payload` property of this action has a Promise stored on it in the
    form of an `axios` AJAX request. The middleware will intercept the action, process
    the request, and send a new action to the reducers with the resolved data on the `payload`
    property. If it was a successful request, the action with the `FETCH_PHOTOS_FULFILLED`
    type will be dispatched with the resolved data, and if not, the `FETCH_PHOTOS_REJECTED`
    action will be dispatched with the error as `payload`. On success, the case in
    the reducer for handling `FETCH_PHOTOS_FULFILLED` will execute, `loadedPhotos`
    will be updated in the store, and in turn, `this.props.photos` will also be updated.
    Updating the component props will trigger a re-render, and the new data will be
    displayed on the screen.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中，我们创建了 `componentDidMount` 方法。组件在挂载时所需的所有照片只需调用映射到 `this.props.fetchPhotos`
    的 action creator 即可。就是这样！`fetchPhotos` action creator 将被派发。由于 action creator 返回的
    `fetchPhoto` action 具有一个 Promise 存储在其 `payload` 属性中，这个 Promise 是以 `axios` AJAX
    请求的形式存储的，因此我们在之前的示例中应用了 `redux-promise-middleware`。中间件将拦截该 action，处理请求，并发送一个带有解析数据的新
    action 到 reducers 的 `payload` 属性。如果请求成功，将派发带有解析数据的 `FETCH_PHOTOS_FULFILLED` 类型的
    action，如果不成功，将派发带有错误作为 `payload` 的 `FETCH_PHOTOS_REJECTED` action。在成功时，处理 `FETCH_PHOTOS_FULFILLED`
    的 reducer 中的情况将执行，`loadedPhotos` 将在存储中更新，进而 `this.props.photos` 也将被更新。更新组件的 props
    将触发重新渲染，并且新数据将显示在屏幕上。
- en: In *step 8* and *step 9*, we followed the same pattern to define `addPhoto`
    and `removePhoto`, which call the action creators of the same name. The action
    produced by the action creators are handled by the middleware, the proper reducer
    handles the resulting action, and if the `state` in the Redux store changes, all
    subscribed props will be automatically updated!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 8* 和 *步骤 9* 中，我们遵循相同的模式来定义 `addPhoto` 和 `removePhoto`，它们调用同名的 action creators。action
    creators 产生的 action 由中间件处理，适当的 reducer 处理生成的 action，如果 Redux 存储中的 `state` 发生变化，所有订阅的
    props 将自动更新！
- en: Storing offline content using Redux
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 存储离线内容
- en: Redux is an excellent tool for keeping track of an app's state while it it's
    running. But what if we have data that we need to store without using an API?
    For instance, we could save the state of a component so that when a user closes
    and reopens the app, the previous state of that component can be restored, allowing
    us to persist a piece of an app's persistent across sessions. Redux data persistence
    could also be useful for caching information to avoid calling the API more than
    necessary. You can refer to the *Masking the application upon network connection
    loss* recipe in [Chapter 8](b41f8c20-f817-4b29-992b-18f8bcd6f071.xhtml), *Working
    with Application Logic and Data*, for more information on how to detect and handle
    network connectivity status.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个很好的工具，可以在应用运行时跟踪应用的状态。但是如果我们有一些数据需要在不使用API的情况下存储怎么办？例如，我们可以保存组件的状态，这样当用户关闭并重新打开应用时，该组件的先前状态可以被恢复，从而允许我们在会话之间持久化应用的一部分。Redux数据持久化也可以用于缓存信息，以避免不必要地调用API。您可以参考[第8章](b41f8c20-f817-4b29-992b-18f8bcd6f071.xhtml)中的*在网络连接丢失时屏蔽应用*教程，了解如何检测和处理网络连接状态的更多信息。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'This recipe depends on the previous ones, so make sure to follow along with
    all of the previous recipes. In this recipe, we''ll be using the `redux-persist`
    package to persist the data in our app''s Redux store. Install it with `npm`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程依赖于之前的教程，所以一定要跟着之前的所有教程一起进行。在这个教程中，我们将使用`redux-persist`包来持久化我们应用的Redux存储中的数据。用`npm`安装它：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or you can install it with `yarn`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以用`yarn`安装它：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by adding the dependencies we''ll need in `redux/index.js`. The `storage`
    method we''re importing from `redux-persist` here will use React Native''s `AsyncStorage`
    method to store Redux data between sessions, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`redux/index.js`中添加我们需要的依赖项。我们在这里从`redux-persist`导入的`storage`方法将使用React
    Native的`AsyncStorage`方法在会话之间存储Redux数据，如下所示：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll be using a simple `config` object for configuring our `redux-persist`
    instance. `config` requires a `key` property for the key used to store the data
    with `AsyncStore` and a storage property that takes the `storage` instance, as
    follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的`config`对象来配置我们的`redux-persist`实例。`config`需要一个`key`属性来存储数据与`AsyncStore`的键，并且需要一个storage属性，该属性接受`storage`实例，如下所示：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll use the `persistReducer` method we imported in *step 1*. This method
    takes the `config` object we created in *step 2 *as the first argument and our
    reducers as the second:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们在*步骤1*中导入的`persistReducer`方法。这个方法将我们在*步骤2*中创建的`config`对象作为第一个参数，将我们的reducers作为第二个参数：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let''s update our store to use the new `persistedReducer` method. Also
    note how we no longer export `store` as the default export, since we''ll need
    two exports from this file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的存储以使用新的`persistedReducer`方法。还要注意，我们不再将`store`作为默认导出，因为我们需要从这个文件中导出两个内容：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The second export we need from this file is `persistor`. `persistor` will work
    to persist the Redux store between sessions. We can create `persistor` by calling
    the `persistStore` method and passing in `store`, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从这个文件中需要的第二个导出是`persistor`。`persistor`将在会话之间持久化Redux存储。我们可以通过调用`persistStore`方法并传入`store`来创建`persistor`，如下所示：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that we''ve got both `store` and `persistor` as exports from `redux/index.js`,
    we''re ready to apply them in `App.js`. We''ll start by importing them, and we''ll
    import the `PersistGate` component from `redux-persist`. `PersistGate` will ensure
    that our cached Redux store is loaded before any components are loaded:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们从`redux/index.js`中得到了`store`和`persistor`作为导出，我们准备在`App.js`中应用它们。我们将从中导入它们，并从`redux-persist`中导入`PersistGate`组件。`PersistGate`将确保我们缓存的Redux存储在任何组件加载之前加载：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s update the `App` component to use `PersistGate`. The component takes
    two props: the imported `persistor` prop and a `loading` prop. We''ll be passing `null`
    to the `loading` prop, but if we had a loading indicator component, we could pass
    this in, and `PersistGate` would display this loading indicator as data is restored,
    as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新`App`组件以使用`PersistGate`。该组件接受两个属性：导入的`persistor`属性和一个`loading`属性。我们将向`loading`属性传递`null`，但如果我们有一个加载指示器组件，我们可以将其传递进去，`PersistGate`会在数据恢复时显示这个加载指示器，如下所示：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to test the persistence of our Redux store, let''s adjust the `componentDidMount`
    method in the `Album` component. We''ll delay the call to `fetchPhotos` for two
    seconds, so that we can see the saved data before it is fetched again from the
    API, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的Redux存储的持久性，让我们调整`Album`组件中的`componentDidMount`方法。我们将延迟调用`fetchPhotos`两秒钟，这样我们就可以在从API再次获取数据之前看到保存的数据，如下所示：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Depending on what kind of data you're persisting, this kind of functionality
    could be applied to a number of situations, including persisting user data and
    app state, even after the app's been closed. It can also be used to improve the
    offline experience of an app, caching API requests if they can't be made right
    away and providing users with data filled views.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您要持久化的数据类型，这种功能可以应用于许多情况，包括持久化用户数据和应用状态，甚至在应用关闭后。它还可以用于改善应用的离线体验，如果无法立即进行API请求，则缓存API请求，并为用户提供填充数据的视图。
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 2*, we created the config object for configuring `redux-persist`. The
    object is only required to have the `key` and `store` properties, but also supports
    quite a few others. You can see all of the options this config takes via the type
    definition hosted here: [https://github.com/rt2zz/redux-persist/blob/master/src/types.js#L13-L27](https://github.com/rt2zz/redux-persist/blob/master/src/types.js#L13-L27).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们创建了用于配置`redux-persist`的配置对象。该对象只需要具有`key`和`store`属性，但也支持其他许多属性。您可以通过此处托管的类型定义查看此配置接受的所有选项：[https://github.com/rt2zz/redux-persist/blob/master/src/types.js#L13-L27](https://github.com/rt2zz/redux-persist/blob/master/src/types.js#L13-L27)。
- en: In *step 7*, we used the `PersistGate` component, which is how the documentation
    recommends delaying rendering until restoring persisted data is complete. If we
    have a loading indicator component, we can pass it to the `loading` prop for being
    displayed while data is restored.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们使用了`PersistGate`组件，这是文档建议的延迟渲染直到恢复持久化数据完成的方法。如果我们有一个加载指示器组件，我们可以将其传递给`loading`属性，以便在数据恢复时显示。
