- en: Taking Your First Steps with React
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 用React迈出第一步
- en: Hello, readers!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，读者们！
- en: This book assumes that you already know what React is and what problems it can
    solve for you. You may have written a small/medium application with React, and
    you want to improve your skills and answer all of your open questions. You should
    know that React is maintained by the developers at Facebook and hundreds of contributors
    within the JavaScript community. React is one of the most popular libraries for
    creating UIs, and it is well known to be fast, thanks to its smart way of working
    with the **Document Object Model** (**DOM**). It comes with JSX, a new syntax
    for writing markup in JavaScript, which requires you to change your thinking regarding
    the separation of concerns. It has many cool features, such as server-side rendering,
    which gives you the power to write universal applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假定您已经知道React是什么以及它可以为您解决什么问题。您可能已经用React编写了一个小/中型应用程序，并且希望提高自己的技能并回答所有未解决的问题。您应该知道React由Facebook的开发人员和JavaScript社区内的数百名贡献者维护。React是创建UI的最受欢迎的库之一，由于其与**文档对象模型**（**DOM**）的智能工作方式而闻名。它带有JSX，这是一种在JavaScript中编写标记的新语法，这需要您改变有关关注点分离的思维。它具有许多很酷的功能，例如服务器端渲染，这使您有能力编写通用应用程序。
- en: 'In this first chapter, we will go through some basic concepts that are essential
    to master in order to use React effectively, but are straightforward enough for
    beginners to figure out:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些基本概念，这些概念对于有效使用React至关重要，但对于初学者来说也足够简单易懂：
- en: The difference between imperative and declarative programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式编程和声明式编程之间的区别
- en: React components and their instances, and how React uses elements to control
    the UI flow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件及其实例，以及React如何使用元素来控制UI流程
- en: How React changed the way we build web applications, enforcing a different new
    concept of separation of concerns, and the reasons behind its unpopular design
    choice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React如何改变了我们构建Web应用程序的方式，强制执行了一种不同的关注点分离的新概念，以及其不受欢迎设计选择背后的原因
- en: Why people feel JavaScript fatigue, and what you can do to avoid the most common
    errors developers make when approaching the React ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么人们感到JavaScript疲劳，以及在接近React生态系统时开发人员常犯的最常见错误，您可以做些什么来避免这些错误
- en: How TypeScript changed the game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript如何改变了游戏
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow this book, you need to have some minimal experience using
    the terminal to run a few Unix commands. Also, you need to install Node.js. You
    have two options. The first one is to download Node.js directly from the official
    website, [https://nodejs.org](https://nodejs.org), and the second option (recommended)
    is to install **Node Version Manager** (**NVM**) from [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循本书，您需要具有一些使用终端运行几个Unix命令的最小经验。此外，您需要安装Node.js。您有两个选项。第一个是直接从官方网站[https://nodejs.org](https://nodejs.org)下载Node.js，第二个选项（推荐）是从[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)安装**Node
    Version Manager**（**NVM**）。
- en: 'If you decide to go with NVM, you can install any version of Node.js you want
    and switch the versions with the `nvm install` command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用NVM，您可以安装任何您想要的Node.js版本，并使用`nvm install`命令切换版本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you have installed the different versions, you can switch them by using
    the  `nvm use`  command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了不同版本后，您可以使用`nvm use`命令切换它们：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, you can specify a default `node` version by running the following
    command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行以下命令指定默认的`node`版本：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In short, here is a list of the requirements to complete the chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下是完成本章所需的要求列表：
- en: '**Node.js (12+)**: [https://nodejs.org](https://nodejs.org)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js (12+)**: [https://nodejs.org](https://nodejs.org)'
- en: '**NVM**: [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NVM**：[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)'
- en: '**VS Code**: [https://code.visualstudio.com](https://code.visualstudio.com)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS Code**：[https://code.visualstudio.com](https://code.visualstudio.com)'
- en: '**TypeScript**: [https://www.npmjs.com/package/typescript](https://www.npmjs.com/package/typescript)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**：[https://www.npmjs.com/package/typescript](https://www.npmjs.com/package/typescript)'
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中找到本章的代码：[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition)。
- en: Differentiating between declarative and imperative programming
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分声明性和命令式编程
- en: When reading the React documentation or blog posts about React, you will have
    undoubtedly come across the term  **declarative**. One of the reasons why React
    is so powerful is that it enforces a declarative programming paradigm.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读React文档或关于React的博文时，你肯定会遇到“**声明性**”这个术语。React之所以如此强大的原因之一是它强制执行声明性编程范式。
- en: Therefore, to master React, it is essential to understand what declarative programming
    means and what the main differences between imperative and  declarative  programming
    are. The easiest way to approach this is to think about imperative programming
    as a way of describing how things work, and declarative programming as a way of
    describing what you want to achieve.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要精通React，了解声明性编程的含义以及命令式和声明式编程之间的主要区别是至关重要的。最简单的方法是将命令式编程视为描述事物如何工作的方式，将声明式编程视为描述你想要实现的方式。
- en: 'Entering a bar for a beer is a real-life example in the imperative world, where
    normally you will give the following instructions to the bartender:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 进入酒吧喝啤酒是命令式世界中的一个现实例子，通常你会给酒吧员以下指示：
- en: Find a glass and collect it from the shelf.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找一个玻璃杯并从架子上拿下来。
- en: Place the glass under the tap.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把玻璃杯放在龙头下面。
- en: Pull down the handle until the glass is full.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉下把手直到玻璃杯满了。
- en: Hand me the glass.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递给我玻璃杯。
- en: In the declarative world, you would just say "Can I have a beer, please?"
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明性世界中，你只需要说“我可以要一杯啤酒吗？”
- en: The declarative approach assumes that the bartender already knows how to serve
    a beer, an important aspect of the way declarative programming works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性方法假设酒吧员已经知道如何倒啤酒，这是声明性编程工作方式的一个重要方面。
- en: 'Let''s move into a JavaScript example. Here we will write a simple function
    that, given an array of lowercase strings, returns an array with the same strings
    in uppercase:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个JavaScript的例子。在这里，我们将编写一个简单的函数，给定一个小写字符串数组，返回一个相同字符串的大写数组：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An imperative function to solve the problem would be implemented as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的命令式函数将实现如下：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First of all, an empty array to contain the result is created. Then, the function
    loops through all the elements of the input array and pushes the uppercase values
    into the empty array. Finally, the output array is returned.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个空数组来包含结果。然后，函数循环遍历输入数组的所有元素，并将大写值推入空数组中。最后，返回输出数组。
- en: 'A  declarative  solution would be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性解决方案如下：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The items of the input array are passed to a `map` function that returns a
    new array containing the uppercase values. There are some significant differences
    to note: the former example is less elegant and it requires more effort to be
    understood. The latter is terser and easier to read, which makes a huge difference
    in big code bases, where maintainability is crucial.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组的项目被传递给一个`map`函数，该函数返回一个包含大写值的新数组。有一些重要的区别需要注意：前面的例子不够优雅，需要更多的努力才能理解。后者更简洁，更易读，在大型代码库中会产生巨大的差异，可维护性至关重要。
- en: Another aspect worth mentioning is that in the declarative example, there is
    no need to use variables, nor to keep their values updated during the execution.
    Declarative programming tends to avoid creating and mutating a state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得一提的方面是，在声明式的例子中，无需使用变量，也无需在执行过程中更新它们的值。声明式编程倾向于避免创建和改变状态。
- en: 'As a final example, let''s see what it means for React to be declarative. The
    problem we will try to solve is a common task in web development: creating a toggle
    button.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，让我们看看React作为声明式的含义。我们将尝试解决的问题是Web开发中的常见任务：创建一个切换按钮。
- en: Imagine a simple UI component such as a toggle button. When you click it, it
    turns green (on) if it was previously gray (off), and switches to gray (off) if
    it was previously green (on).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的UI组件，比如一个切换按钮。当您点击它时，如果之前是灰色（关闭），它会变成绿色（打开），如果之前是绿色（打开），它会变成灰色（关闭）。
- en: 'The imperative way of doing this would be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的命令式方式如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is imperative because of all the instructions needed to change the classes.
    In contrast, the declarative approach using React would be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要改变类的所有指令，这是命令式的。相比之下，使用React的声明式方法如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In declarative programming, developers only describe what they want to achieve,
    and there's no need to list all the steps to make it work. The fact that React
    offers a declarative approach makes it easy to use, and consequently, the resulting
    code is simple, which often leads to fewer bugs and more maintainability.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，开发人员只描述他们想要实现的内容，无需列出所有步骤来使其工作。React提供声明式方法使其易于使用，因此生成的代码简单，通常会导致更少的错误和更易维护性。
- en: In the next section, you will learn how React elements work and you will get
    more context on how `props` are being passed on a React component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解React元素的工作原理，并且将更多地了解`props`如何在React组件中传递。
- en: How React elements work
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React元素的工作原理
- en: This book assumes that you are familiar with components and their instances,
    but there is another object you should know about if you want to use React effectively
    – the element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您熟悉组件及其实例，但如果您想有效地使用React，还有另一个对象您应该了解——元素。
- en: Whenever you call  `createClass`, extend  `Component`, or declare a stateless
    function, you are creating a component. React manages all the instances of your
    components at runtime, and there can be more than one instance of the same component
    in memory at a given point in time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您调用`createClass`，扩展`Component`或声明一个无状态函数时，您都在创建一个组件。React在运行时管理所有组件的实例，并且在给定时间点内可以存在同一组件的多个实例。
- en: As mentioned previously, React follows a  declarative  paradigm, and there's
    no need to tell it how to interact with the DOM; you declare what you want to
    see on the screen, and React does the job for you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React遵循声明式范式，无需告诉它如何与DOM交互；您声明要在屏幕上看到什么，React会为您完成这项工作。
- en: 'As you might have already experienced, most other UI libraries work the other
    way round: they leave the responsibility of keeping the interface updated to the
    developer, who has to manage the creation and destruction of the DOM elements
    manually.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经经历过的那样，大多数其他UI库的工作方式正好相反：它们将保持界面更新的责任留给开发人员，开发人员必须手动管理DOM元素的创建和销毁。
- en: To control the UI flow, React uses a particular type of object, called an **element**,
    which describes what has to be shown on the screen. These immutable objects are
    much simpler  compared  to the components and their instances and contain only
    the information that is strictly needed to represent the interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制UI流程，React使用一种特殊类型的对象，称为**元素**，它描述了在屏幕上显示什么。这些不可变的对象与组件及其实例相比要简单得多，并且只包含严格需要表示界面的信息。
- en: 'The following is an example of an element:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个元素的示例：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Elements have `type`, which is the most important attribute, and some properties.
    There is also a particular property, called  `children`, that is optional and  represents  the
    direct descendant of the element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 元素有`type`，这是最重要的属性，还有一些属性。还有一个特殊的属性，称为`children`，它是可选的，代表元素的直接后代。
- en: '`type` is important because it tells React how to  deal  with the element itself.
    If `type`  is a string, the element represents a  DOM node, while if `type` is
    a function, the element is a  component.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`很重要，因为它告诉React如何处理元素本身。如果`type`是一个字符串，那么该元素代表一个DOM节点，而如果`type`是一个函数，那么该元素是一个组件。'
- en: 'DOM elements and components can be nested with each other as follows, to represent
    the render tree:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: DOM元素和组件可以相互嵌套，以表示渲染树：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the type of the element is a function, React calls the function, passing
    `props` to get back the underlying elements. It keeps on performing the same operation
    recursively on the result until it gets a tree of DOM nodes that React can render
    on the screen. This process is called **reconciliation**, and it is used by both
    React DOM and React Native to create the UIs of their respective platforms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素的类型是一个函数时，React调用该函数，传递`props`以获取底层元素。它继续对结果进行相同的递归操作，直到获得一个DOM节点树，React可以在屏幕上渲染。这个过程称为**协调**，它被React
    DOM和React Native用来创建各自平台的UI。
- en: React is a game-changer, so at the beginning, the React syntax might seem weird
    to you, but once you understand how it works, you will love it, and for this,
    you need to unlearn everything you know so far.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个改变游戏规则的技术，所以一开始，React的语法可能对你来说很奇怪，但一旦你理解了它的工作原理，你会喜欢它，为此，你需要忘掉你到目前为止所知道的一切。
- en: Unlearning everything
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忘掉一切
- en: Using React for the first time usually requires an open mind because it is a
    new way of designing web and mobile applications. React tries to innovate the
    way we build UIs following a path that breaks most of the well-known best practices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用React通常需要开放的思维，因为这是一种设计Web和移动应用程序的新方式。React试图创新我们构建UI的方式，打破了大多数众所周知的最佳实践。
- en: In the last two decades, we learned that the separation of concerns is important,
    and we used to think about it as separating the logic from the templates. Our
    goal has always been to write the JavaScript and the HTML in different files.
    Various templating solutions have been created to help developers achieve this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，我们学到了关注点的分离是重要的，并且我们曾经认为这是将逻辑与模板分离。我们的目标一直是将JavaScript和HTML写在不同的文件中。已经创建了各种模板解决方案来帮助开发人员实现这一目标。
- en: The problem is that most of the time, that kind of separation is just an illusion
    and the truth is that the JavaScript and the HTML are tightly coupled, no matter
    where they live.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，大多数时候，这种分离只是一种幻觉，事实上JavaScript和HTML是紧密耦合的，无论它们在哪里。
- en: 'Let''s see an example of a template:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个模板的例子：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding snippet is taken from the Mustache website, one of the most popular
    templating systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段摘自Mustache网站，这是最流行的模板系统之一。
- en: The first row tells Mustache to loop  through  a collection of items. Inside
    the loop, there is some conditional logic to check whether the  `#first`  and
    `#link`  properties exist and, depending on their values, a different piece of
    HTML is rendered. Variables are wrapped in curly braces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉Mustache循环遍历一组项目。在循环内部，有一些条件逻辑来检查`＃first`和`＃link`属性是否存在，并根据它们的值呈现不同的HTML片段。变量用花括号括起来。
- en: If your application only has  to display some variables, a templating library
    could represent a good solution, but when it comes to starting to work with complex
    data structures, things change. Templating systems and their **Domain-Specific
    Language** (**DSL**) offer a subset of features, and they try to provide the functionalities
    of a real programming language without reaching the same level of completeness.
    As shown in the example, templates highly depend on the models they receive from
    the logic layer to display the information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序只需要显示一些变量，模板库可能是一个很好的解决方案，但当涉及开始处理复杂的数据结构时，情况就会改变。模板系统及其**特定领域语言**（**DSL**）提供了一组功能，并试图提供一个真正编程语言的功能，但没有达到相同的完整性水平。正如示例所示，模板高度依赖于它们从逻辑层接收的模型来显示信息。
- en: On the other hand, JavaScript interacts with the DOM elements rendered by the
    templates to update the UI, even if they are loaded from separate files. The same
    problem applies to styles – they are defined in a different file, but they are
    referenced in the templates, and the CSS selectors follow the structure of the
    markup, so it is almost impossible to change one without breaking the other, which
    is the definition of **coupling**. That is why the classic separation of concerns
    ended up being more the separation of technologies, which is, of course, not a
    bad thing, but it doesn't solve any real problems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JavaScript与模板呈现的DOM元素进行交互，以更新UI，即使它们是从不同的文件加载的。同样的问题也适用于样式 - 它们在不同的文件中定义，但在模板中引用，并且CSS选择器遵循标记的结构，因此几乎不可能更改一个而不破坏另一个，这就是**耦合**的定义。这就是为什么经典的关注点分离最终更多地成为技术分离，这当然不是一件坏事，但它并没有解决任何真正的问题。
- en: React  tries to move a step forward by putting the  templates  where they belong
    – next to the logic. The reason it does that is  that React  suggests you organize
    your applications by composing small bricks called  components. The framework
    should not tell you how to separate the  concerns  because every application has
    its own, and only the developers should decide how to limit the boundaries of
    their applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: React试图向前迈进一步，将模板放在它们应该在的地方 - 靠近逻辑。它这样做的原因是，React建议您通过组合称为组件的小模块来组织应用程序。框架不应告诉您如何分离关注点，因为每个应用程序都有自己的关注点，只有开发人员应该决定如何限制其应用程序的边界。
- en: The component-based approach drastically changes the way we write web applications,
    which is why the classic concept of separation of concerns is gradually being
    taken over by a much more modern structure. The paradigm enforced by React is
    not new, and it was not invented by its creators, but React has contributed to
    making the concept mainstream and, most importantly, popularized it in such a
    way that it is easier to understand for developers with different levels of expertise.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的方法彻底改变了我们编写Web应用程序的方式，这就是为什么传统的关注点分离概念逐渐被更现代的结构所取代的原因。React强制执行的范式并不新鲜，也不是由其创作者发明的，但React已经促使这个概念变得更加流行，并且最重要的是，使其更容易被不同水平的开发人员理解。
- en: 'Rendering of a React component looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染React组件看起来像这样：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We all agree that it seems a bit weird in the beginning, but that is just because
    we are not used to that kind of syntax. As soon as we learn it and we realize
    how powerful it is, we understand its potential. Using JavaScript for both logic
    and templating not only helps us separate our concerns in a better way, but it
    also gives us more power and more expressivity, which is what we need to build
    complex UIs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都同意，开始时似乎有点奇怪，但那只是因为我们不习惯那种语法。一旦我们学会了它，意识到它有多么强大，我们就能理解它的潜力。在逻辑和模板中使用JavaScript不仅有助于更好地分离我们的关注点，而且还赋予我们更多的权力和更多的表现力，这正是我们构建复杂UI所需要的。
- en: That is why even if the idea of mixing JavaScript and HTML sounds weird in the
    beginning, it is vital to give React 5 minutes. The best way to get started with
    new technology is to try it on a small side project and see how it goes. In general,
    the right approach is always to be ready to unlearn everything and change your
    mindset if the long-term benefits are worth it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么即使在开始时混合JavaScript和HTML的想法听起来很奇怪，但至关重要的是给React 5分钟。开始使用新技术的最佳方法是在一个小的副项目上尝试并看看效果如何。总的来说，正确的方法始终是准备好忘掉一切，如果长期利益值得的话，改变你的思维方式。
- en: 'There is another concept that is pretty controversial and hard to accept, and
    that the engineers behind React are trying to push to the community: moving the
    styling logic inside the component, too. The end goal is to encapsulate every
    single technology used to create our components and separate the concerns according
    to their domain and functionalities.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个概念是相当有争议的，也很难接受，那就是React背后的工程师们试图向社区推动的：也将样式逻辑移至组件内部。最终目标是封装用于创建我们组件的每个单一技术，并根据其领域和功能分离关注点。
- en: 'Here is an example of a style object taken from the  React  documentation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从React文档中提取的样式对象的示例：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This set of solutions, where developers use JavaScript to write their styles,
    is known as `#CSSinJS`, and we will talk about it extensively in *Chapter 8, Making
    Your Components Look Beautiful*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这套解决方案中，开发人员使用JavaScript来编写他们的样式，被称为`#CSSinJS`，我们将在*第8章《让您的组件看起来美丽》*中对此进行广泛讨论。
- en: In the next section, we will see how to avoid JavaScript fatigue, which is caused
    by the large number of configurations that are needed to run a React application
    (webpack mainly).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到如何避免JavaScript疲劳，这是由运行React应用程序所需的大量配置（主要是webpack）引起的。
- en: Understanding JavaScript fatigue
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JavaScript疲劳
- en: There is a prevailing opinion that  React  consists of a vast set of technologies
    and tools, and if you want to use it, you are forced to deal with package managers,
    transpilers, module bundlers, and an  infinite  list of different libraries. This
    idea is so widespread and shared among people  that  it has been clearly defined,
    and has been given the name  **JavaScript fatigue***.*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种普遍的观点认为，React由大量的技术和工具组成，如果你想使用它，就不得不处理包管理器、转译器、模块捆绑器和无限的不同库列表。这个想法是如此普遍并且在人们中间共享，以至于它已经被明确定义，并被命名为**JavaScript疲劳**。
- en: It is not hard to understand the reasons behind this. All the repositories and
    libraries in the React ecosystem are made using shiny new technologies, the latest
    version of JavaScript, and the most advanced techniques and paradigms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这背后的原因并不难。React生态系统中的所有存储库和库都是使用全新的技术、最新版本的JavaScript和最先进的技术和范例制作的。
- en: Moreover, there is a massive number of React boilerplate on GitHub, each with
    tens of dependencies to offer solutions for any problems. It is straightforward
    to think that all these tools are required to start using React, but this is far
    from the truth. Despite this common way of thinking, React is a pretty tiny library,
    and it can be used inside any page (or even inside JSFiddle) in the same way everyone
    used to use jQuery or Backbone, just by including the script on the page before
    the closing `body` element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在GitHub上有大量的React样板，每个样板都有数十个依赖项，以解决任何问题。很容易认为启动使用React需要所有这些工具，但事实远非如此。尽管有这种常见的思维方式，React是一个非常小的库，可以像以前使用jQuery或Backbone一样在任何页面（甚至在JSFiddle中）使用，只需在页面中包含脚本即可。
- en: 'There are two scripts because React is split into two packages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个脚本是因为React被分成了两个包：
- en: '`react`: Implements the core features of the library'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react`：实现了库的核心功能'
- en: '`react-dom`: Contains all the browser-related features'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-dom`：包含所有与浏览器相关的功能'
- en: The reason behind this is that the core package is used to support different
    targets, such as React DOM in browsers and React Native on mobile devices. Running
    a  React  application inside a single HTML page does not require any package manager
    or complex operation. You can just download the distribution bundle and host it
    yourself (or use [https://unpkg.com/](https://unpkg.com/)), and you are ready
    to get started with React and its features in a few minutes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的原因是核心包用于支持不同的目标，比如浏览器中的React DOM和移动设备上的React Native。在单个HTML页面中运行React应用程序不需要任何包管理器或复杂的操作。您只需下载分发包并自行托管（或使用[https://unpkg.com/](https://unpkg.com/)），就可以在几分钟内开始使用React及其功能。
- en: 'Here are the URLs to be included in the HTML to start using React:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在HTML中包含的URL，以开始使用React：
- en: '[https://unpkg.com/react@17.0.1/umd/react.production.min.js](https://unpkg.com/react@17.0.1/umd/react.production.min.js)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unpkg.com/react@17.0.1/umd/react.production.min.js](https://unpkg.com/react@17.0.1/umd/react.production.min.js)'
- en: '[https://unpkg.com/react-dom@17.0.1/umd/react-dom.production.min.js](https://unpkg.com/react-dom@17.0.1/umd/react-dom.production.min.js)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unpkg.com/react-dom@17.0.1/umd/react-dom.production.min.js](https://unpkg.com/react-dom@17.0.1/umd/react-dom.production.min.js)'
- en: If we add the core React library only, we cannot use JSX because it is not a
    standard language supported by the browser; but the whole point is to start with
    the bare minimum set of features and add more functionalities as soon as they
    are needed. For a simple UI, we could just use  `createElement` (`_jsx` on React
    17) and only when we start building something more complex can we include a transpiler
    to enable JSX and convert it into JavaScript. As soon as the app grows a bit more,
    we may need a router to handle different pages and views, and we can include that
    as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只添加核心React库，我们无法使用JSX，因为它不是浏览器支持的标准语言；但整个重点是从最少的功能集开始，并在需要时添加更多功能。对于简单的UI，我们可以只使用`createElement`（在React
    17中为`_jsx`），只有当我们开始构建更复杂的东西时，才能包含转译器以启用JSX并将其转换为JavaScript。一旦应用程序稍微增长，我们可能需要一个路由器来处理不同的页面和视图，我们也可以包含它。
- en: At some point, we may want to load data from some API endpoints, and if the
    application keeps growing, we will reach the point where we need some external
    dependencies to abstract complex operations. Only  at  that very moment should
    we introduce a package manager. Then, the time will come to split our application
    into separate modules and organize our files in the right way. At that point,
    we should start thinking about using a module bundler.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，我们可能想要从一些API端点加载数据，如果应用程序不断增长，我们将达到需要一些外部依赖来抽象复杂操作的地步。只有在那个时刻，我们才应该引入一个包管理器。然后，到了分离我们的应用程序为单独模块并以正确方式组织我们的文件的时候。在那时，我们应该开始考虑使用模块捆绑器。
- en: Following this simple approach, there's no fatigue. Starting with a boilerplate
    that has 100 dependencies and tens of  `npm`  packages of which we know nothing
    is the best way to get lost. It is important to note that every programming-related
    job (and  frontend  engineering in particular) requires continuous learning. It
    is the nature of the web to evolve at a breakneck pace and change according to
    the needs of both users and developers. This is the way our environment has worked
    since the beginning and is what makes it very exciting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种简单的方法，就不会感到疲劳。从具有100个依赖项和数十个我们一无所知的`npm`包的样板开始是迷失的最佳方式。重要的是要注意，每个与编程相关的工作（特别是前端工程）都需要不断学习。网络以惊人的速度发展并根据用户和开发人员的需求进行变化，这是我们的环境自始至终的工作方式，也是使其非常令人兴奋的原因。
- en: As we gain experience working on the web, we learn that we cannot master everything
    and we should find the right way to keep ourselves updated to avoid fatigue. We
    are able to follow all the new trends without jumping into the new libraries for
    the sake of  it  unless we have time for a side project.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在网络上工作的经验增加，我们学会了不能掌握一切，我们应该找到保持自己更新的正确方法以避免疲劳。我们能够跟上所有新趋势，而不是为了新库而跳进去，除非我们有时间做一个副业项目。
- en: It is astonishing how, in the JavaScript world, as soon as a specification is
    announced or drafted, someone in the community implements it as a transpiler plugin
    or a polyfill, letting everyone else play with it while the browser vendors agree
    and start supporting it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，在JavaScript世界中，一旦规范被宣布或起草，社区中就会有人将其实现为转译器插件或填充物，让其他人可以在浏览器供应商同意并开始支持之前使用它。
- en: This is something that makes JavaScript and the browser a completely different
    environment compared to any other language or platform. The downside of it is
    that things change quickly, but it is just a matter of finding the right balance
    between betting on new technologies versus staying safe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使JavaScript和浏览器与任何其他语言或平台完全不同的东西。它的缺点是事物变化很快，但只是要找到押注新技术与保持安全之间的正确平衡。
- en: In any case, Facebook developers care a lot about the **Developer Experience**
    (**DX**), and they listen carefully to the community. So, even if it is not true
    that to use React we are required to learn hundreds of different tools, they realized
    that people were feeling the fatigue and they released a CLI tool that makes it
    incredibly easy to scaffold and run a real React application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，Facebook的开发人员非常关心**开发者体验**（**DX**），他们仔细倾听社区的意见。因此，即使使用React并不需要学习数百种不同的工具，他们意识到人们感到疲劳，于是发布了一个CLI工具，使创建和运行真正的React应用程序变得非常容易。
- en: 'The only requirement is to use a  `node.js/npm`  environment and install the
    CLI tool globally as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的要求是使用`node.js/npm`环境，并全局安装CLI工具，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the executable is installed, we can use it to create our application,
    passing a folder name:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当可执行文件安装后，我们可以使用它来创建我们的应用程序，传递一个文件夹名称：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we move into the folder of our application with  `cd hello-world`,
    and we just run the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入我们应用程序的文件夹`cd hello-world`，然后运行以下命令：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Magically, our application is running with a single dependency, but with all
    the features needed to build a complete React application using the most advanced
    techniques. The following screenshot shows the default page of an application
    created with `create-react-app`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 神奇的是，我们的应用程序只依赖一个依赖项，但具有构建完整React应用程序所需的所有功能。以下截图显示了使用`create-react-app`创建的应用程序的默认页面：
- en: '![](assets/946a0deb-dac3-4f19-ae7e-62b6fb2e7e00.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/946a0deb-dac3-4f19-ae7e-62b6fb2e7e00.png)'
- en: This is basically your first React application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是您的第一个React应用程序。
- en: Introducing TypeScript
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍TypeScript
- en: '**TypeScript** is a typed superset of JavaScript that is compiled to JavaScript,
    which means **TypeScript** is **JavaScript** with some additional features. TypeScript
    was designed by Anders Hejlsberg (the designer of C#) at Microsoft and is open
    source.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript**是JavaScript的一个有类型的超集，它被编译成JavaScript，这意味着**TypeScript**是带有一些额外功能的**JavaScript**。TypeScript是由微软的Anders
    Hejlsberg（C#的设计者）设计的，并且是开源的。'
- en: Let's see what the features of TypeScript are and how to convert JavaScript
    to TypeScript.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看TypeScript的特性以及如何将JavaScript转换为TypeScript。
- en: TypeScript features
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript特性
- en: 'This section will try to summarize the most important features you should be
    taking advantage of:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将尝试总结您应该利用的最重要的特性：
- en: '**TypeScript is JavaScript**: Any JavaScript code you write will work with
    TypeScript, which means if you already know how to use JavaScript basically you
    have all you need to do TypeScript; you just need to learn how to add types to
    your code. All the TypeScript code is transformed into JavaScript at the end.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript就是JavaScript**：您编写的任何JavaScript代码都将与TypeScript一起工作，这意味着如果您已经知道如何基本使用JavaScript，您基本上已经具备了使用TypeScript所需的一切；您只需要学习如何向代码添加类型。最终，所有TypeScript代码都会转换为JavaScript。'
- en: '**JavaScript is TypeScript**:This just means that you can rename any valid
    `.js` file with the `.ts` extension, and it will work.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript就是TypeScript**：这意味着您可以将任何有效的`.js`文件重命名为`.ts`扩展名，它将可以工作。'
- en: '**Error checking**: TypeScript compiles the code and checks for errors, which
    helps a lot to highlight errors before we run our code.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检查**：TypeScript编译代码并检查错误，这有助于在运行代码之前突出显示错误。'
- en: '**Strong typing**: By default, JavaScript is not strongly typed. With TypeScript,
    you can add types to all your variables and functions, and you can even specify
    the returned value types.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强类型**：默认情况下，JavaScript不是强类型的。使用TypeScript，您可以为所有变量和函数添加类型，甚至可以指定返回值类型。'
- en: '**Object-oriented programming supported**: It supports concepts such as classes,
    interfaces, inheritance, and so on.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持面向对象编程**：它支持诸如类、接口、继承等概念。'
- en: Converting JavaScript code into TypeScript
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将JavaScript代码转换为TypeScript
- en: In this section, we will see how to transform some JavaScript code into TypeScript.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到如何将一些JavaScript代码转换为TypeScript。
- en: 'Let''s suppose we have to check whether a word is a palindrome. The JavaScript
    code for this algorithm will be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要检查一个单词是否是回文。这个算法的JavaScript代码如下：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can name this file `palindrome.ts`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此文件命名为`palindrome.ts`。
- en: As you can see, we are receiving a `string` variable (`word`), and we are returning
    a `boolean` value, so how will this be translated to TypeScript?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们接收一个`string`变量（`word`），并返回一个`boolean`值，那么这将如何转换为TypeScript呢？
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You're probably thinking great, I just specified the `string` type as `word`
    and `boolean` type to the function returned value, but now what?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想到，我刚刚指定了`string`类型作为`word`，并且将`boolean`类型指定为函数返回值，但现在呢？
- en: 'If you try to run the function with some value that is different from a string,
    you will get a TypeScript error:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用与字符串不同的某个值运行函数，您将收到TypeScript错误：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, if you try to pass a number to the function, you will get the following
    error:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您尝试将数字传递给函数，您将收到以下错误：
- en: '![](assets/131bd7c8-9e32-44ab-9c50-650ed2758157.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/131bd7c8-9e32-44ab-9c50-650ed2758157.png)'
- en: That's why TypeScript is very useful because it will force you to be more strict
    and explicit with your code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么TypeScript非常有用，因为它将强制您对代码更加严格和明确。
- en: Types
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: 'In the last example, we saw how to specify some primitive types for our function
    parameter and returned value, but you''re probably  wondering how you can describe
    an object or array with more details. **Types** can help us to describe our objects
    or arrays in a better way. For example, let''s suppose you want to describe a
    `User` type to save the information into the database:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们看到了如何为函数参数和返回值指定一些原始类型，但您可能想知道如何以更详细的方式描述对象或数组。**类型**可以帮助我们以更好的方式描述我们的对象或数组。例如，假设您想描述一个`User`类型以将信息保存到数据库中：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We get the following error if you forget to add one of the nodes or put an
    invalid value in one of them:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记添加其中一个节点或在其中一个节点中放入无效值，您将收到以下错误：
- en: '![](assets/11bdeec1-e67c-4181-9d37-004b0c1a8057.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11bdeec1-e67c-4181-9d37-004b0c1a8057.png)'
- en: 'If you need optional nodes, you can always put a `?` next to the name of the
    node, as shown in the following code block:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要可选节点，您可以在节点名称旁边始终放置`?`，如以下代码块所示：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can name `type` as you want, but a good practice to follow is to add a prefix
    of `T`, so, for example, the `User` type will become `TUser`. In this way, you
    can quickly recognize that it is `type` and you don't get confused thinking it
    is a class or a React component.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要命名`type`，但遵循的一个良好实践是添加`T`的前缀，因此，例如，`User`类型将变为`TUser`。这样，您可以快速识别它是`type`，并且不会混淆认为它是类或React组件。
- en: Interfaces
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: '**Interfaces** are very similar to types and sometimes developers don''t know
    the differences between them. Interfaces can be used to describe the shape of
    an object or function signature just like types, but the syntax is different:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**与类型非常相似，有时开发人员不知道它们之间的区别。接口可用于描述对象或函数签名的形状，就像类型一样，但语法不同：'
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can name an interface as you want, but a good practice to follow is to add
    a prefix of `I`, so, for example, the `User` interface will become `IUser`. In
    this way, you can quickly recognize that it is an interface and you don't get
    confused thinking it is a class or a React component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要命名接口，但遵循的一个良好实践是添加`I`的前缀，因此，例如，`User`接口将变为`IUser`。这样，您可以快速识别它是接口，而不会混淆认为它是类或React组件。
- en: An interface can also  be extended, implemented, and merged.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以扩展、实现和合并。
- en: Extending
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展
- en: 'An interface or type can also  be extended, but again the syntax will differ,
    as shown in the following code block:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接口或类型也可以扩展，但语法将有所不同，如以下代码块所示：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, by using the `&` character, you can extend a type, while you
    extend an interface using the `extends`  keyword.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用`&`字符，您可以扩展类型，而使用`extends`关键字扩展接口。
- en: Implementing
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: 'A class can implement an interface or type alias in the same exact way. But
    it cannot implement (or extend) a type alias that names a union type, for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以以完全相同的方式实现接口或类型别名。但它不能实现（或扩展）命名为联合类型的类型别名，例如：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you write that code, you will get the following error in your editor:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写该代码，您将在编辑器中收到以下错误：
- en: '![](assets/00a5e85f-aca1-4b88-a3a2-d4ea0190bc33.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00a5e85f-aca1-4b88-a3a2-d4ea0190bc33.png)'
- en: As you can see, you are not able to implement a union type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您无法实现联合类型。
- en: Declaration merging
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明合并
- en: 'Unlike a type, an interface can be defined multiple times and will be treated
    as a single interface (all declarations will be merged), as shown in the following
    code block:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型不同，接口可以被多次定义，并且将被视为单个接口（所有声明将被合并），如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is very useful when you need to extend your interfaces in different scenarios
    by just re-defining the same interface.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要通过重新定义相同的接口在不同场景下扩展接口时，这非常有用。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this first chapter, we have learned some basic concepts that are very important
    for following the rest of the book, and that are crucial to working with React
    daily. We now know how to write declarative code, and we have a clear understanding
    of the difference between the components we create and the elements that React
    uses to display their instances on the screen.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些对于接下来的书非常重要的基本概念，这些概念对于每天使用React非常关键。我们现在知道如何编写声明式代码，并且清楚地理解了我们创建的组件与React用来在屏幕上显示它们的实例之间的区别。
- en: We learned the reasons behind the choice of locating logic and templates together,
    and why that unpopular decision has been a big win for React. We went through
    the reasons why it is common to feel fatigued in the JavaScript ecosystem, but
    we have also seen how to avoid those problems by following an iterative approach.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了将逻辑和模板放在一起的选择背后的原因，以及为什么这个不受欢迎的决定对React来说是一个巨大的胜利。我们通过了解在JavaScript生态系统中感到疲劳是很常见的原因，但我们也看到了如何通过迭代方法来避免这些问题。
- en: We learned how to use TypeScript to create some basic types and interfaces.
    Finally, we have seen what the new  `create-react-app`  CLI is, and we are now
    ready to start writing some real code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用TypeScript来创建一些基本类型和接口。最后，我们看到了新的 `create-react-app` CLI是什么，现在我们准备开始编写一些真正的代码。
- en: In the next chapter, you will learn how to use JSX/TSX code and apply very useful
    configurations to improve your code style.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用JSX/TSX代码，并应用非常有用的配置来改进您的代码风格。
