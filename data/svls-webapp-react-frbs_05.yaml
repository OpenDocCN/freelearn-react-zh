- en: User Profile and Access Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户个人资料和访问管理
- en: 'In the last chapter, we saw how we can use the Firebase with the react-redux
    application. We also explored Redux in detail and saw how and when we need to
    use Redux in our React app, and Firebase Realtime Database will give us the Realtime seat
    booking status in our application. In this chapter, we will go through Firebase
    Admin SDK, which provides a user management API to read and write Realtime Database
    data with full admin privileges. So we will create an admin page for our application
    where we have the ability to perform the actions such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何在react-redux应用程序中使用Firebase。我们还详细探讨了Redux，并了解了在我们的React应用程序中何时以及为何需要使用Redux，以及Firebase实时数据库将在我们的应用程序中提供实时的座位预订状态。在本章中，我们将介绍Firebase
    Admin SDK，它提供了一个用户管理API，以完全的管理员权限读取和写入实时数据库数据。因此，我们将为我们的应用程序创建一个管理员页面，在这个页面上我们有能力执行以下操作：
- en: Creating new users
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新用户
- en: User search engine where we can search the users by different criteria
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户搜索引擎，我们可以按不同的标准搜索用户
- en: List of all the users
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户的列表
- en: Accessing the user metadata, which includes the account creation date and last
    sign-in date for the particular user
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问用户元数据，其中包括特定用户的帐户创建日期和最后登录日期
- en: Deleting the users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除用户
- en: Updating the user information without having to sign in as the user
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新用户信息，而无需以用户身份登录
- en: Verifying emails
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证电子邮件
- en: Changing a user's email without sending an email notification to revoke these
    changes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改用户的电子邮件地址，而不发送电子邮件通知以撤销这些更改
- en: Creating a new user with a phone number and changing the user's phone number
    without sending SMS verification
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有电话号码的新用户，并更改用户的电话号码而不发送短信验证
- en: First, we need to do the setup of Firebase Admin SDK in Node.js environment
    to perform the preceding actions as an admin.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Node.js环境中设置Firebase Admin SDK以作为管理员执行上述操作。
- en: Setting up Firebase Admin SDK
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Firebase Admin SDK
- en: For using Firebase Admin SDK, we'll need a Firebase project where we have service
    account to communicate with the Firebase services and a configuration file that
    includes the service account's credentials.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Firebase Admin SDK，我们需要一个Firebase项目，其中有服务账户与Firebase服务通信，并包含服务账户凭据的配置文件。
- en: 'To configure the Firebase Admin SDK, follow these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Firebase Admin SDK，请按照以下步骤进行：
- en: 'Log in to [Firebase Console,](https://console.firebase.google.com) select the
    `<project_name>` project, and click on the setting icon in Project Overview:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[Firebase控制台](https://console.firebase.google.com)，选择`<project_name>`项目，并点击项目概述中的设置图标：
- en: '![](Images/6dbddc16-0b9f-4c88-b596-9ab9097fd3b6.png)Overview tab'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6dbddc16-0b9f-4c88-b596-9ab9097fd3b6.png)概述选项卡'
- en: Go to the Service Accounts tab inside Project Settings.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到项目设置中的服务帐户选项卡。
- en: 'Click on the GENERATE PRIVATE KEY button at the bottom of Firebase admin section;
    it will generate the JSON file that contains the service account credentials:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Firebase管理部分底部的GENERATE PRIVATE KEY按钮；它将生成包含服务账户凭据的JSON文件：
- en: '![](Images/a9b3f3ce-9a6c-4db4-8e6d-3fd5d526047d.png)This JSON file contains
    very sensitive information about your service account and private encryption key.
    So never share and store it in a public repository; keep it confidential. If we
    lose this file because of any reason then, we can generate it again, and we''ll
    no longer access Firebase Admin SDK with the old file.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a9b3f3ce-9a6c-4db4-8e6d-3fd5d526047d.png)这个JSON文件包含了关于您的服务账户和私人加密密钥的非常敏感的信息。因此，永远不要分享和存储在公共存储库中；保持它的机密性。如果因为任何原因我们丢失了这个文件，那么我们可以再次生成它，并且我们将不再使用旧文件访问Firebase
    Admin SDK。'
- en: Firebase CLI
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase CLI
- en: Firebase provides a command-line interface, which provides a variety of tools
    to create, manage, view, and deploy Firebase projects. Using Firebase CLI, we
    can easily deploy and host our application on production grade static hosting,
    and it is automatically served by HTTPS and backed by global CDN in one single
    command.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase提供了一个命令行界面，提供了各种工具来创建、管理、查看和部署Firebase项目。使用Firebase CLI，我们可以轻松地在生产级静态托管上部署和托管我们的应用程序，并且它会自动通过全球CDN提供HTTPS服务。
- en: Installation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: Before the installation, ensure that we have installed Node.js 4.0+ on our machine.
    If not installed, then download the latest version of Node.js 8 "LTS" from [https://nodejs.org](https://nodejs.org) Once
    we're done with the installation, we can download the Firebase CLI from `npm` (node
    package manager).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装之前，请确保我们在计算机上安装了Node.js 4.0+。如果尚未安装，请从[https://nodejs.org](https://nodejs.org)下载Node.js
    8的最新版本“LTS” 安装完成后，我们可以从`npm`（node包管理器）下载Firebase CLI。
- en: 'Run this command to install Firebase CLI globally on your system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令在您的系统上全局安装Firebase CLI：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To verify the installation, run the following command; it prints the Firebase
    CLI version if it''s installed properly on your system:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证安装，请运行以下命令；如果在您的系统上正确安装了Firebase CLI，它将打印Firebase CLI版本：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Firebase Admin Integration
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase Admin集成
- en: 'Now that we''ve successfully installed Firebase CLI, let''s copy the existing
    application code from [Chapter 3](dede285d-2924-4fcf-a208-57337e4b853f.xhtml)*,
    Authentication with Firebase*, to the new directory in [Chapter 5](5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml)*,
    User Profile and Access Management*. Here, we''ll initialize the Firebase app
    and run the following command to log in to the Firebase console before initializing
    the app:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功安装了Firebase CLI，让我们将现有应用程序代码从[第3章](dede285d-2924-4fcf-a208-57337e4b853f.xhtml)*，使用Firebase进行身份验证*复制到[第5章](5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml)*，用户配置文件和访问管理*的新目录中。在这里，我们将初始化Firebase应用程序，并运行以下命令在初始化应用程序之前登录到Firebase控制台：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you are successfully logged in to the Firebase console, run the following
    command to initialize the project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功登录到Firebase控制台，请运行以下命令初始化项目：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once we run this command, it will prompt you to select the Firebase feature,
    project, and directory folder (relative to your project directory) that will contain
    `hosting` assets to be uploaded with the `firebase deploy` command (by default,
    it is public).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，它将提示您选择Firebase功能、项目和目录文件夹（相对于您的项目目录），该文件夹将包含要与`firebase deploy`命令一起上传的`hosting`资产（默认情况下为public）。
- en: '![](Images/c1236563-8911-47e8-9e00-22b8a8ccc48a.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c1236563-8911-47e8-9e00-22b8a8ccc48a.png)'
- en: We can also add features later on in our project, and it's also possible to
    associate multiple projects with the same directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在项目中随后添加功能，并且也可以将多个项目与同一目录关联。
- en: 'Once Firebase initialization is complete, run the following command to install
    the project dependencies and then build the project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Firebase初始化完成，请运行以下命令安装项目依赖项，然后构建项目：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To run our application locally to verify before deploying to the production,
    run the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在部署到生产环境之前在本地验证我们的应用程序，请运行以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will start the server locally from build directory or whatever the name
    you have defined in the `firebase.json` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从构建目录或您在`firebase.json`文件中定义的名称启动本地服务器：
- en: '![](Images/e8cc4c0c-5618-44ff-972a-2b88373591d4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e8cc4c0c-5618-44ff-972a-2b88373591d4.png)'
- en: This is what our folder structure looks like after firebase initialization using
    the firebase CLI.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的文件夹结构在使用Firebase CLI初始化后的样子。
- en: Using the Firebase Admin Auth API with React
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase Admin Auth API与React
- en: The Firebase Admin SDK will give us the power to integrate your own server using
    the Firebase Auth API. With Firebase Admin SDK, we can manage our application
    users such as `View`, `Create`, `Update`, and `Delete` without requiring a user's
    credentials or manage authentication tokens without going to Firebase Admin Console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK将使我们能够使用Firebase Auth API集成自己的服务器。使用Firebase Admin SDK，我们可以管理我们的应用程序用户，如`查看`，`创建`，`更新`和`删除`，而无需用户的凭据或管理身份验证令牌而无需转到Firebase
    Admin控制台。
- en: To implement this, we will create Admin Panel in our existing React application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在现有的React应用程序中创建管理面板。
- en: 'Here''s the list of features we''ll integrate into our Admin Panel using Firebase
    Admin SDK:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将使用Firebase Admin SDK集成到我们的管理面板中的功能列表：
- en: Create and verify the custom token
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和验证自定义令牌
- en: User Level Access Roles with Custom user claims
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有自定义用户声明的用户级访问角色
- en: View list of app users
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看应用用户列表
- en: Fetch user profile
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户个人资料
- en: '`Create`, `Delete`, and `Update` the user information'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建`，`删除`和`更新`用户信息'
- en: Resolve the Ticket status
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决工单状态
- en: Initializing the Admin SDK
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Admin SDK
- en: As we saw, Firebase admin SDK is only supported in Node.Js, so we'll create
    a new project with npm init and install the firebase admin from the `npm` package.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Firebase admin SDK仅在Node.Js中受支持，因此我们将使用npm init创建一个新项目，并从`npm`包中安装firebase
    admin。
- en: 'Run the following command to install firebase admin and save it in your `package.json`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令安装firebase admin并将其保存在您的`package.json`中：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Copy the following snippet in your JS file and initialize the SDK; we have
    added the reference to the JSON file that we downloaded from the Firebase Admin
    Service account:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段复制到您的JS文件中并初始化SDK；我们已经添加了从Firebase Admin服务帐户下载的JSON文件的引用：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we'll just create Restful API to interact with client App to access Admin
    SDK features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将只需创建Restful API与客户端应用程序交互以访问Admin SDK功能。
- en: 'Run this command to start the node admin server:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令启动节点管理员服务器：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It will start the local server on a different port, such as `http://localhost:3001`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在不同端口上启动本地服务器，例如`http://localhost:3001`。
- en: Creating and verifying custom token
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和验证自定义令牌
- en: The Firebase Admin SDK provides us an ability to authenticate the user with
    an external mechanism such as LDAP server, or third-party OAuth provider, which
    Firebase doesn't support, such as Instagram or LinkedIn. We can do all these things
    with Firebase custom tokens method, which is built-in Admin SDK, or we can use
    any third-party JWT libraries.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK为我们提供了使用外部机制（如LDAP服务器或第三方OAuth提供程序）对用户进行身份验证的能力，Firebase不支持这些机制，如Instagram或LinkedIn。我们可以使用Firebase内置的Admin
    SDK中的自定义令牌方法来执行所有这些操作，或者我们可以使用任何第三方JWT库。
- en: Let's see how we can create and validate token with Admin SDK.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Admin SDK创建和验证令牌。
- en: 'For creating a custom token, we must have a valid `uid`, which we need to pass
    in the `createCustomToken()` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义令牌，我们必须有一个有效的`uid`，我们需要在`createCustomToken()`方法中传递它：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding function, we have `uid` from client side when the user signs
    in with username and password, and if the credentials are valid, we''ll return
    custom JWT (JSON Web Token) from the server that can be used by a client device
    to authenticate with Firebase:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，当用户使用用户名和密码登录时，我们从客户端获取`uid`，如果凭据有效，我们将从服务器返回自定义JWT（JSON Web Token），客户端设备可以使用它来与Firebase进行身份验证：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once it's authenticated, this identity will be used for accessing Firebase services
    like Firebase Realtime Database and Cloud Storage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦经过身份验证，此身份将用于访问Firebase服务，如Firebase实时数据库和云存储。
- en: 'If need be, we can also add some additional fields to be included in the custom
    token. Consider this code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们还可以添加一些附加字段以包含在自定义令牌中。考虑这段代码：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These additional fields will be available in the `auth/request.auth` object
    in security rules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些附加字段将在安全规则中的`auth/request.auth`对象中可用。
- en: 'Once the token is generated and received by the react method, we''ll authenticate
    the user to the app by passing the custom token to the Firebase `signInWithCustomToken()`
    method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦令牌生成并被React方法接收，我们将通过将自定义令牌传递给Firebase的`signInWithCustomToken()`方法来对用户进行应用程序身份验证：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After the successful authentication, the user signed in to our application with
    account specified by the `uid`, which we included in creating the custom token
    method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成功验证后，用户使用我们在创建自定义令牌方法中包含的`uid`指定的帐户登录到我们的应用程序。
- en: In the same way, the other Firebase authentication methods works like `signInWithEmailAndPassword()`
    and `signInWithCredential()`, and the `auth/request.auth` object will be available
    in Firebase Realtime database security rules with the user `uid`. In the preceding
    example, we specified why to generate the custom token.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，其他Firebase身份验证方法的工作方式类似于`signInWithEmailAndPassword()`和`signInWithCredential()`，并且`auth/request.auth`对象将在Firebase实时数据库安全规则中与用户`uid`一起可用。在前面的示例中，我们指定了为什么生成自定义令牌。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the same way, we can also access the additional passed objects, which are
    available in `auth.token` and `request.auth.token`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还可以访问其他传递的附加对象，这些对象在`auth.token`和`request.auth.token`中可用：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Firebase can also provide us the way to get the `uid` once the user logged into
    the app; it creates a corresponding ID token that uniquely identifies them, and
    we can send this token to the server for verifying and give them access to several
    resources of the application. For example, when we create a custom backend server
    to communicate with an app, we might need to identify the currently signed-in
    user on that server securely using HTTPS.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase还可以为我们提供一种获取`uid`的方法，一旦用户登录到应用程序中，它会创建一个唯一标识他们的相应ID令牌，我们可以将此令牌发送到服务器进行验证，并允许他们访问应用程序的多个资源。例如，当我们创建一个自定义后端服务器与应用程序通信时，我们可能需要使用HTTPS安全地识别当前登录的用户。
- en: 'To retrieve the ID token from Firebase, ensure that the user has signed in
    to the application, and we can use the following method to retrieve the ID token
    in your react application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Firebase中检索ID令牌，请确保用户已登录到应用程序，并且我们可以使用以下方法在您的React应用程序中检索ID令牌：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once we have this ID token, we can send this JWT (JSON Web Token) to backend
    server Firebase Admin SDK or any third-party library to validate it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个ID令牌，我们可以将这个JWT（JSON Web Token）发送到后端服务器的Firebase Admin SDK或任何第三方库进行验证。
- en: 'For validating and decoding the ID token, Firebase Admin SDK has a built-in
    `verifyIdToken(idToken)` method; if the provided token is not expired, valid,
    and properly signed, this method returns the decoded ID token:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证和解码ID令牌，Firebase Admin SDK具有内置的`verifyIdToken(idToken)`方法；如果提供的令牌未过期、有效且经过正确签名，该方法将返回解码的ID令牌：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's extend our existing application where the user can see only those
    tickets that they have submitted, and we'll also give the ability to the user
    to update the existing profile. We'll also create an admin panel in React and,
    based on the role, we show the admin UI to the user.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展我们现有的应用程序，用户只能看到他们提交的那些票证，并且我们还将给用户更新现有个人资料的能力。我们还将在React中创建一个管理员面板，并根据角色向用户显示管理员UI。
- en: Custom claims for admin access and security rules
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于管理员访问和安全规则的自定义声明
- en: As we saw earlier, Firebase Admin SDK supports defining custom attributes with
    the token. These custom attributes give the ability to define different levels
    of access, including role-based control to the app, which is enforced in an application's
    security rules.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Firebase Admin SDK支持在令牌中定义自定义属性。这些自定义属性使我们能够定义不同级别的访问权限，包括基于角色的应用程序安全规则中强制执行的访问控制。
- en: 'We need to define the user roles in the following common cases:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在以下常见情况下定义用户角色：
- en: Giving a user the admin role for accessing the resources
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户分配管理员角色以访问资源
- en: Assigning different groups to the user
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户分配不同的组
- en: Giving a user multi-level access such as Paid, Regular user, Managers, Support
    Team, and such
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供多级访问权限，例如付费用户、普通用户、经理、支持团队等
- en: 'We can also define the rules based on the database where we need give limited
    access, such as we have database node `helpdesk/tickets/all`, where all the data
    tickets'' data can be accessed. However, we want only the admin user to be able
    to see the all the tickets. To achieve this objective more efficiently, verify
    the email ID and add the custom user claim named admin with the following Realtime
    Database rule:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据数据库定义规则，限制访问，例如我们有数据库节点`helpdesk/tickets/all`，所有数据票务数据都可以被访问。但是，我们只希望管理员用户能够查看所有票务。为了更有效地实现这一目标，验证电子邮件ID并添加名为admin的自定义用户声明到以下实时数据库规则中：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Do not confuse Custom claims with Custom Authentication and Firebase Authentication.
    It applies to users already signed in with supported providers (Email/Password,
    Github, Google, Facebook, phone, and such), but custom authentication is used
    when we use different authentication, which is not supported by Firebase. For
    example, a user signed in with Firebase Auth's Email/Password provider can have
    access control defined using custom claims.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将自定义声明与自定义身份验证和Firebase身份验证混淆。它适用于已使用受支持提供程序（电子邮件/密码、Github、Google、Facebook、电话等）登录的用户，但当我们使用Firebase不支持的不同身份验证时，将使用自定义身份验证。例如，使用Firebase
    Auth的电子邮件/密码提供程序登录的用户可以使用自定义声明定义访问控制。
- en: Adding custom claim with Admin SDK
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Admin SDK添加自定义声明
- en: 'In the Firebase Admin SDK, we can apply custom claims using the `setCustomUserClaims()`
    method, which comes built-in with Firebase:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase Admin SDK中，我们可以使用`setCustomUserClaims()`方法应用自定义声明，该方法内置于Firebase中：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Verifying custom claim with Admin SDK sending the app
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Admin SDK发送应用程序验证自定义声明
- en: 'Firebase Admin SDK also provides us the method to verify the token using the
    `verifyIdToken()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK还为我们提供了使用`verifyIdToken()`方法验证令牌的方法：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also check whether the custom claim is available or not in the user
    object:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查用户对象中是否有自定义声明可用：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's see how we can implement this in our existing application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在我们现有的应用程序中实现这一点。
- en: 'First, let''s create a restful API in the Node Admin SDK backend server:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Node Admin SDK后端服务器中创建一个restful API：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I have manually created one admin user with `harmeet@adminhelpdesk.com` in Firebase
    Console with help of admin SDK; we need to verify and add the custom claims for
    admin.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用管理SDK在Firebase控制台中手动创建了一个名为`harmeet@adminhelpdesk.com`的管理员用户；我们需要验证并为管理员添加自定义声明。
- en: 'Now, open `App.JSX` and add the following code snippet; set the initial state
    of the application based on the role:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`App.JSX`并添加以下代码片段；根据角色设置应用程序的初始状态：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, calling the preceding API in the `componentWillMount()` component lifecycle
    method we need to get the `idToken` from user object from `firebase.auth().onAuthStateChanged((user))`
    and send it to the server for verification:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`componentWillMount()`组件生命周期方法中调用上述API，我们需要从`firebase.auth().onAuthStateChanged((user))`中获取用户对象的`idToken`并将其发送到服务器进行验证：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we are using the `fetch` API to send the HTTP request.
    It's similar to XMLHttpRequest, but it has the new feature and is more powerful.
    Based on the response, we are setting the state of the component and registering
    the component into the router.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`fetch` API发送HTTP请求。它类似于XMLHttpRequest，但具有新功能并且更强大。根据响应，我们设置组件的状态并将组件注册到路由器中。
- en: 'This is how our router component looks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的路由组件的样子：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here''s the list of components that we are registering and rendering admin
    component if the user is an admin:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们正在注册和渲染管理员组件的组件列表，如果用户是管理员：
- en: '`AppUser`: To get the list of user for application, which is also responsible
    for deleting the user and searching the user by different criteria'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppUser`：获取应用程序用户列表，还负责删除用户和按不同标准搜索用户。'
- en: '`Tickets`: To see the list of all tickets and change the status of the ticket'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tickets`：查看所有票证列表并更改票证状态'
- en: '`NewUserForm`: To add the new user to the application'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新用户表单：将新用户添加到应用程序
- en: We are performing the preceding operation with Node.js Firebase Admin SDK server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Node.js Firebase Admin SDK服务器执行上述操作。
- en: Create a folder with the name of `admin` and create a file in it, called `getAllUser.jsx`.
    In that, we will create a React component, which is responsible for fetching and
    displaying the list of the user into UI; we'll also add the functionality of searching
    the user by different criteria, such as email ID, phone number, and more.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`admin`的文件夹，并在其中创建一个名为`getAllUser.jsx`的文件。在其中，我们将创建一个React组件，负责获取并显示用户列表到UI；我们还将添加按不同标准搜索用户的功能，例如电子邮件ID，电话号码等。
- en: 'In the `getAllUser.jsx` file, this is how our render method looks:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getAllUser.jsx`文件中，我们的渲染方法如下：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have also added the table in the `render` method to display the list of
    users:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`render`方法中添加了表格来显示用户列表：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the table body, which is displaying the list of users with action buttons,
    and now we need to call the users API in the `componentDidMount()` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示用户列表的表格主体，并且现在我们需要在`componentDidMount()`方法中调用用户API：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, we need to call other APIs to delete, View User Profile, and search:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要调用其他API来删除、查看用户资料和搜索：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For searching, Firebase Admin SDK has built-in methods: `getUserByEmail()`
    and `getUserByPhoneNumber()`. We can implement these in the same way as `delete()`
    and `fetch()`, which we created in the Firebase Admin API:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于搜索，Firebase Admin SDK具有内置方法：`getUserByEmail()`和`getUserByPhoneNumber()`。我们可以以与我们在Firebase
    Admin API中创建`delete()`和`fetch()`相同的方式实现这些方法：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Look at the following `node.js` API Code Snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下`node.js` API代码片段：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we''ll create an API to call the preceding functions based on the user''s
    request:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个API来根据用户的请求调用上述功能：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s take a quick look at our application in browser, see how it looks,
    and try to log in with admin user:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速查看一下我们在浏览器中的应用程序，看看它的外观，并尝试使用管理员用户登录：
- en: '![](Images/a4873eb7-5463-463b-994b-c62447fe695b.png)A screenshot of our application
    when logged in with admin credentials; the purpose is to show the UI and console
    when we log in as admin'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a4873eb7-5463-463b-994b-c62447fe695b.png)使用管理员凭据登录时我们应用程序的屏幕截图；目的是展示我们作为管理员登录时的UI和控制台'
- en: 'That looks amazing! Just take a look at the preceding screenshot; it''s showing
    different navigation for admin, and if you can see in the console, it''s showing
    the token with custom claim object, which we added to this user to admin access:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！只需看一下上述屏幕截图；它显示了管理员的不同导航，如果您可以在控制台中看到，它显示了带有自定义声明对象的令牌，我们将其添加到此用户以获得管理员访问权限：
- en: '![](Images/2cf2b4d3-ed80-4b8d-9b02-e376ed3ccc36.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2cf2b4d3-ed80-4b8d-9b02-e376ed3ccc36.png)'
- en: It looks great! We can see the users of the application with action button and
    search UI.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！我们可以看到应用程序的用户列表和搜索UI。
- en: Now, consider that we delete the user from the listing and, at the same time
    that user session is active and using the application. In this scenario, we need
    to manage the session for the user and give the prompt to reauthenticate, because
    every time the user logs in, the user credentials are sent to the Firebase Authentication
    backend and exchanged for a Firebase ID token (a JWT) and refresh token.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到我们从列表中删除了用户，并且与此同时用户会话仍处于活动状态并正在使用应用程序。在这种情况下，我们需要管理用户的会话，并提示其重新进行身份验证，因为每次用户登录时，用户凭据都会被发送到Firebase身份验证后端，并交换为Firebase
    ID令牌（JWT）和刷新令牌。
- en: 'These are the common scenarios where we need to manage the session of the user:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要管理用户会话的常见情况：
- en: User is deleted
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户被删除
- en: User is disabled
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已禁用
- en: Email address and password changed
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址和密码已更改
- en: The Firebase Admin SDK also gives the ability to revoke the specific user session
    using the `revokeRefreshToken()` method. It revokes active refresh tokens of a
    given user. If we reset the password, Firebase Authentication backend automatically
    revokes the user token.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK还提供了使用`revokeRefreshToken()`方法吊销特定用户会话的能力。它吊销给定用户的活动刷新令牌。如果我们重置密码，Firebase身份验证后端会自动吊销用户令牌。
- en: 'Refer to the following code snippet of Firebase Cloud Function to revoke the
    user based on a specific `uid`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下Firebase Cloud Function代码片段，根据特定的`uid`来吊销用户：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we know, Firebase ID tokens are stateless JWT, which can only be verified
    by sending the request to Firebase Authentication backend server to check whether
    the token's status is revoked or not. For this reason, performing this check on
    your server is very costly and adds the extra effort, requiring an extra network
    request load. We can avoid this network request by setting up Firebase Rules that
    check for revocation, rather than sending the request to the Firebase Admin SDK.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Firebase ID令牌是无状态的JWT，只能通过向Firebase身份验证后端服务器发送请求来验证令牌的状态是否被吊销。因此，在服务器上执行此检查非常昂贵，并增加了额外的工作量，需要额外的网络请求负载。我们可以通过设置Firebase规则来检查吊销而不是发送请求到Firebase
    Admin SDK来避免这种网络请求。
- en: 'This is the normal way to declare the rules with no client access to write
    to store revocation time per user:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是声明规则的正常方式，没有客户端访问来写入存储每个用户的吊销时间：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, if we want to allow only unrevoked and authenticated users to access
    the protected data, we must have the following rule configured:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只想允许未被吊销和经过身份验证的用户访问受保护的数据，我们必须配置以下规则：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Any time a user's refresh on browser tokens are revoked, the `tokensValidAfterTime`
    UTC timestamp is saved in the database node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的浏览器刷新令牌被吊销时，`tokensValidAfterTime` UTC时间戳将保存在数据库节点中。
- en: When a user's ID token is to be verified, the additional check boolean flag
    has to be passed to the `verifyIdToken()` method. If the user's token is revoked,
    the user should be signed out from the app or asked to reauthenticate using reauthentication
    APIs provided by the Firebase Authentication client SDKs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当要验证用户的ID令牌时，必须传递附加检查布尔标志到`verifyIdToken()`方法。如果用户的令牌被吊销，用户应该从应用程序中注销或要求使用Firebase身份验证客户端SDK提供的重新验证API重新进行身份验证。
- en: 'For example, we created one method above `setCustomClaims` in that method;
    just add the following code inside the `catch` method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在上面创建了一个名为`setCustomClaims`的方法；只需在`catch`方法中添加以下代码：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Also, if the token is revoked, send the notification to the client app to reauthenticate.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果令牌被吊销，发送通知给客户端应用程序重新进行身份验证。
- en: 'Consider this example for email/password Firebase authentication providers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑此示例用于电子邮件/密码Firebase身份验证提供程序：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s click on the All Tickets link to see the list of tickets submitted
    by all the users:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们点击“所有工单”链接，查看所有用户提交的工单列表：
- en: '![](Images/ce3522d9-11bf-4664-b1c6-938d6382eda0.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/ce3522d9-11bf-4664-b1c6-938d6382eda0.png)
- en: As an admin user, we can change the status of the ticket that will get updated
    in Firebase Realtime Database. Now if you click on Create New User, it will display
    the form to add user information.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理员用户，我们可以更改在Firebase实时数据库中更新的票的状态。现在，如果您单击“创建新用户”，它将显示表单以添加用户信息。
- en: 'Let''s create one new component and add the following code to the render method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新组件，并将以下代码添加到渲染方法中：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On `handleSubmitEvent(e)`, we need to call the `createNewUser()` Firebase admin
    SDK method, passing the form data into it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleSubmitEvent(e)`中，我们需要调用`createNewUser()` Firebase管理员SDK方法，并将表单数据传递给它：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Start the server again and open the application in your browser. Let''s try
    to create the new user in our application with admin credentials:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器并在浏览器中打开应用程序。让我们尝试使用管理员凭据在我们的应用程序中创建新用户：
- en: '![](Images/2297a1c2-7209-403c-98a4-4c4e70cafc82.png)Create New User component;
    the purpose of the image is to show the alert message when we fill the form and
    submit to the Firebase to create a new user'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/2297a1c2-7209-403c-98a4-4c4e70cafc82.png)创建新用户组件；图像的目的是在我们填写表单并提交到Firebase以创建新用户时显示警报消息
- en: That looks awesome; we have successfully created the new user in our application
    and returned the automatic generated `uid` by Firebase for a new user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒；我们已成功在我们的应用程序中创建了新用户，并返回了Firebase为新用户生成的自动生成的`uid`。
- en: 'Now, let''s move on further and log in with a normal user:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并用普通用户登录：
- en: '![](Images/4291694b-264e-4053-bb7a-089264cf20f7.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/4291694b-264e-4053-bb7a-089264cf20f7.png)
- en: If you take a look at the preceding screenshot, once we logged into the app
    using any Firebase Auth provider, on the dashboard, it shows all the tickets of
    the users, but it should only display the ones associated with this email ID.
    For this, we need to change the data structure and Firebase node ref.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下前面的屏幕截图，一旦我们使用任何Firebase Auth提供程序登录到应用程序中，在仪表板上，它会显示用户的所有票，但它应该只显示与此电子邮件ID相关联的票。为此，我们需要更改数据结构和Firebase节点引用。
- en: This is the most important part of the application where we need to plan how
    data will be saved and retrieved to make the process as easy as possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序最重要的部分，我们需要计划如何保存和检索数据，以使过程尽可能简单。
- en: How data is structured in a JSON tree
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON树中的数据结构
- en: In Firebase Realtime Database, all data is stored as JSON objects, which is
    a cloud-hosted JSON tree. When we add data to the database, it becomes a node
    in the existing JSON structure with an associated key, which is autogenerated
    by Firebase. We can also provide our own custom keys, such as user IDs or any
    semantic names, or they can be provided using the `push()` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase实时数据库中，所有数据都存储为JSON对象，这是一个托管在云中的JSON树。当我们向数据库添加数据时，它将成为现有JSON结构中的一个节点，并带有一个关联的键，该键由Firebase自动生成。我们还可以提供自定义键，例如用户ID或任何语义名称，或者可以使用`push()`方法提供它们。
- en: 'For example, in our Helpdesk Application, we are storing the tickets at a path,
    such as `/helpdesk/tickets`; now we''ll replace this with `/helpdesk/tickets/$uid/$ticketKey`.
    Take a look at the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的Helpdesk应用程序中，我们将票存储在路径上，例如`/helpdesk/tickets`；现在我们将其替换为`/helpdesk/tickets/$uid/$ticketKey`。看一下以下代码：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is how data structure looks for creating and retrieving the tickets from
    the database:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从数据库创建和检索票的数据结构：
- en: '![](Images/a27fade9-e4cf-496d-a8f7-da4de1b74766.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/a27fade9-e4cf-496d-a8f7-da4de1b74766.png)
- en: In the preceding image, the highlighted node is `$uid`, which belongs to the
    user who has submitted the ticket.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，突出显示的节点是`$uid`，它属于提交了票的用户。
- en: 'This is how our full code looks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完整代码的样子：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open the browser and submit the ticket again; now look at the ticket dashboard:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并重新提交票证；现在查看票证仪表板：
- en: '![](Images/e3732548-510b-4d4e-809f-2f9522eed0f0.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/e3732548-510b-4d4e-809f-2f9522eed0f0.png)
- en: It looks great! Now the user can only see the tickets they have submitted. In
    the next chapter, we'll see how we can apply security rules and common security
    threats in our data in the database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！现在用户只能看到他们提交的票证。在下一章中，我们将看到如何在数据库中应用安全规则和常见安全威胁。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter explained how we can configure and initialize the Firebase Admin
    SDK to create our app backend in NodeJS. It also explained how we can manage our
    app users using User Management API of Firebase Admin without going to Firebase
    Console, such as the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何配置和初始化Firebase Admin SDK来在NodeJS中创建我们的应用后端。它还解释了如何使用Firebase Admin的用户管理API来管理我们的应用用户，而无需转到Firebase控制台，例如以下内容：
- en: '`Create`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: '`Delete`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: '`Update`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: '`Remove`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Firebase Admin SDK gives us the power to create and verify the Custom JWT tokens,
    which allow the user to authenticate with any provider, even if it's not available
    in the Firebase Auth Providers list. It also gives you the power to manage the
    user's session in case of any change in user information, such as the user is
    deleted, disabled, the email address or password is changed, and more.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK赋予我们创建和验证自定义JWT令牌的能力，这允许用户使用任何提供者进行身份验证，即使它不在Firebase身份验证提供者列表中。它还赋予您在用户信息发生任何更改时管理用户会话的能力，例如用户被删除、禁用、电子邮件地址或密码发生更改等。
- en: We also learned how we can control the access to custom claims. This helps us
    provide the ability to implement role-based access control to give users different
    levels of access (roles), in Firebase apps.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何控制对自定义声明的访问。这有助于我们实现基于角色的访问控制，以在Firebase应用中为用户提供不同级别的访问权限（角色）。
- en: In the next chapter, we will learn the database security risks and the checklist
    to prevent such threats. We will also see the security part of Firebase Realtime
    Database and the Firebase Realtime Database Rules language.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习数据库安全风险以及预防此类威胁的检查表。我们还将看到Firebase实时数据库的安全部分和Firebase实时数据库规则语言。
