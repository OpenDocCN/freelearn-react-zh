- en: Data Transfer Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据传输模式
- en: In this chapter, we will learn how to send and receive data in the React Native
    application. Firstly, we will make our application more dynamic and dependent
    on the backend servers. You will learn about the Thunk pattern, which fits into
    Flux really neatly. Then, we will dive into a more advanced library, redux-saga,
    which is based on an effect pattern. Both of the solutions will enable our application
    to seamlessly exchange data with the server. I will also give you a little introduction
    to more advanced communication patterns, such as `HATEOAS` and `GraphQL`. Although
    those two patterns are rarely crucial for a React Native developer, you will find
    it much easier to understand if, one day, those patterns become popular within
    the React Native world too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在React Native应用程序中发送和接收数据。首先，我们将使我们的应用程序更加动态，并且依赖于后端服务器。您将了解到Thunk模式，它非常适合Flux。然后，我们将深入研究一个更高级的库，redux-saga，它基于效果模式。这两种解决方案都将使我们的应用程序能够与服务器无缝交换数据。我还会给您一点关于更高级通信模式的介绍，比如`HATEOAS`和`GraphQL`。尽管这两种模式对于React
    Native开发人员来说很少是关键的，但如果有一天这些模式在React Native世界中变得流行，您会发现理解起来更容易。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何做以下事情：
- en: Create a fake API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个假的API
- en: Fetch data from the backend and store it in the application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从后端获取数据并将其存储在应用程序中
- en: Design action creators and decouple fetching logic from the containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计动作创建者并将获取逻辑与容器解耦
- en: Use Redux Thunk to conditionally dispatch actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux Thunk来有条件地分发动作
- en: Write your own iterators and generators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的迭代器和生成器
- en: Benefit from sagas that heavily rely on generators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从大量依赖于生成器的saga中受益
- en: Preparation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to test various APIs without relying on external sources, we will create
    our own local API. You do not need to know any backend language, nor how to expose
    an API. In this chapter, we will use a special library that builds an API based
    on the JSON file that we provide.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不依赖外部来源的情况下测试各种API，我们将创建我们自己的本地API。您不需要了解任何后端语言，也不需要知道如何公开API。在本章中，我们将使用一个特殊的库，该库根据我们提供的JSON文件构建API。
- en: So far, we have made a neat application displaying tasks. Now, instead of loading
    the local data file, let's use our own REST API. Clone the task application to
    start. (I will be using code from example two in the directory for [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml),
    *Store Patterns**.*)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经制作了一个漂亮的应用程序来显示任务。现在，我们不再加载本地数据文件，而是使用我们自己的REST API。克隆任务应用程序以开始。（我将使用[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)中示例二的代码目录，*存储模式*。）
- en: '**Representational State Transfer** (**REST**) is a set of rules that put constraints
    on web services. One of the crucial requirements is statelessness, which guarantees
    the server will not store the client''s data, but instead rely only on the request
    data. This should be sufficient enough to send a reply to the client.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表述性状态转移**（**REST**）是对Web服务施加约束的一组规则。其中一个关键要求是无状态性，这保证了服务器不会存储客户端的数据，而是仅依赖于请求数据。这应该足以向客户端发送回复。'
- en: In order to create a fake API, we will use the `json-server` library. The library
    expects a JSON file; most examples call it `db.json`. Based on the file, the library
    creates a static API that sends data on requests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个假的API，我们将使用`json-server`库。该库需要一个JSON文件；大多数示例都将其称为`db.json`。根据该文件，该库创建一个静态API，以响应请求发送数据。
- en: 'Let''s start by installing the library with the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用以下命令安装库开始：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you prefer to avoid `global`, please remember to provide a relative path
    to the `node_modules/json-server/bin` in the following scripts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢避免使用`global`，请记住在以下脚本中提供`node_modules/json-server/bin`的相对路径。
- en: 'The JSON file for the library should look like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 库的JSON文件应该如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Luckily, our `tasks.json` file fits this requirement. We can now launch our
    local server. Open `package.json` and add a new script called `server`, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的`tasks.json`文件符合这个要求。我们现在可以启动我们的本地服务器。打开`package.json`并添加一个名为`server`的新脚本，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can now type `yarn run server` to launch it. The data will be exposed at `http://localhost:3000/tasks`.
    Simply access the URL with your browser to check if it works. A correctly set
    up server should print data like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以输入`yarn run server`来启动它。数据将在`http://localhost:3000/tasks`上公开。只需使用浏览器访问URL以检查是否有效。正确设置的服务器应该打印出以下数据：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now proceed further to learn how to work with endpoints.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进一步学习如何使用端点。
- en: Fetching data with the built-in function
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置函数获取数据
- en: To begin, let's start with something fairly basic. React Native implements the
    Fetch API, which is nowadays a standard for making REST API calls.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一些相当基础的东西开始。React Native实现了Fetch API，这在现在是用于进行REST API调用的标准。
- en: Refactoring to activity indicator
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构为活动指示器
- en: Currently, we have a default task list being loaded from the file in `taskReducer.js`.
    To be honest, loading from either the file or API can be time consuming. It will
    be better initially to set the task list to empty the array and provide feedback
    to the user with a spinner or text message, informing them that the data is being
    loaded. We will implement this along with the change to the Fetch API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在`taskReducer.js`文件中从文件加载了默认的任务列表。老实说，从文件或API加载都可能耗时。最好最初将任务列表设置为空数组，并通过旋转器或文本消息向用户提供反馈，告知他们数据正在加载。我们将在使用Fetch
    API时实现这一点。
- en: 'First, remove data import from the file in the reducer. Change the declaration
    from the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从reducer中的文件中删除数据导入。将声明更改为以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And replace it with the code in this snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 并用此片段中的代码替换它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Loading data from a file is also a side effect and should undergo similarly
    restrictive patterns to data fetching. Don't be fooled by the previous implementation
    that we used to synchronously load data. This shortcut was taken only to concentrate
    on the specific learning material.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件加载数据也是一种副作用，并且应该遵循与数据获取类似的限制模式。不要被我们以前用于同步加载数据的实现所愚弄。这个快捷方式只是为了集中在特定的学习材料上。
- en: 'Launch the application to see an empty list. Let''s now add a loading indicator,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序以查看空列表。现在让我们添加一个加载指示器，如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In some cases, where the loading is taking a long time, you will need to handle
    a more complex scenario: the data is loading, but the user may still add tasks
    in the meantime. In the previous implementation, the task would not be shown until
    the data is retrieved from the server. The easy fix for this is to always show
    tasks if we have any, regardless of the `isLoading` prop, which would mean that
    some other data is expected:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果加载时间很长，你需要处理一个更复杂的情况：数据正在加载，但用户可能同时添加任务。在以前的实现中，直到从服务器检索到数据之前，任务才会显示出来。这个简单的解决方法是，如果我们有任何任务，无论`isLoading`属性如何，都始终显示任务，这意味着期望有其他一些数据：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we have a loading indicator that is shown based on the `isLoading` prop,
    we need to think about other states that our fetching process may produce.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个根据`isLoading`属性显示的加载指示器，我们需要考虑我们的获取过程可能产生的其他状态。
- en: Handling error scenarios
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误情况
- en: 'Fetch, in most use cases, will require three states:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Fetch将需要三种状态：
- en: '**START**: A fetch start, which should cause `isLoading` to be `true`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**：开始获取，应导致`isLoading`为`true`'
- en: '**SUCCESS**: Data was fetched successfully'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功**：成功获取数据'
- en: '**ERROR**: Fetch could not retrieve data; an appropriate error message should
    be shown'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：Fetch无法检索数据；应显示适当的错误消息'
- en: 'The last state we need to handle is error. There are a few approaches to this
    with respect to user experience guidelines:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的最后一个状态是错误。在用户体验指南方面，有几种方法可以处理这个问题：
- en: Displaying an error message within the list—this provides a clear message for
    those who care about the data in the table. It may include a clickable link or
    a button to retry. You may mix this approach with the ones that follow.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中显示错误消息 - 这为那些关心表中数据的人提供了一个清晰的消息。它可能包括一个可点击的链接或一个重试按钮。您可以将此方法与后续的方法混合使用。
- en: Displaying a floating notification about the failure—this shows the message
    about the error in one of the corners. The message may disappear after a few seconds.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败时显示浮动通知 - 这在一个角落显示有关错误的消息。消息可能在几秒钟后消失。
- en: Displaying an error modal—this stops the user to notify them about the error;
    it may contain actions such as retry, and dismiss.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示错误模态 - 这会阻止用户通知他们有关错误；它可能包含重试和解除等操作。
- en: 'The approach I would like to take here is the first one. It is fairly easy
    to implement—we need to add an `error` prop and, based on it, display a message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里采取的方法是第一种。这种方法相当容易实现 - 我们需要添加一个“error”属性，并根据它显示消息：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Naive stateful component fetching
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天真的有状态组件获取
- en: 'Now, let''s fetch some data and make our markup fully usable. First, we will
    follow the approach for beginners in React: using `fetch` in one of the stateful
    components. In our case, it will be `App.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一些数据并使我们的标记完全可用。首先，我们将遵循React初学者的方法：在一个有状态组件中使用`fetch`。在我们的情况下，它将是`App.js`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This approach has a number of disadvantages. First, it does not follow the
    Fetch API documentation. Let''s read this crucial quote:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些缺点。首先，它不遵循Fetch API文档。让我们阅读这个关键的引用：
- en: '"The Promise returned from fetch won’t reject on HTTP error status even if
    the response is an HTTP 404 or 500\. Instead, it will resolve normally (with ok status
    set to false), and it will only reject on network failure or if anything prevented
    the request from completing."'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “从fetch返回的Promise不会在HTTP错误状态下拒绝，即使响应是HTTP 404或500。相反，它将正常解析（ok状态设置为false），并且只有在网络故障或任何阻止请求完成时才会拒绝。”
- en: '- *Fetch API documentation, available at:*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '- *可用的Fetch API文档：*'
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)。'
- en: As you can see, the preceding implementation lacks HTTP error handling.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的实现缺乏HTTP错误处理。
- en: The second issue is state duplication, where we maintain a Redux state, but
    then copy tasks to the local component state, and even override it with what has
    been fetched. We could be more concerned about what we have in the tasks already
    by concatenating both arrays, and find a way to avoid storing the tasks again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是状态重复，我们维护了一个Redux状态，但然后将任务复制到本地组件状态，并甚至用已获取的内容覆盖它。我们可能更关心我们已经在任务中的内容，通过连接两个数组，并找到一种避免再次存储任务的方法。
- en: Also, if the Redux state changes, then the previous component will entirely
    neglect the update. This is too bad—let's find a way to fix this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果Redux状态发生变化，那么先前的组件将完全忽略更新。这太糟糕了，让我们找到一种解决方法。
- en: The Thunk pattern and Redux Thunk
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thunk模式和Redux Thunk
- en: In this section, we will learn about the **Thunk pattern** and how to use it
    with the **Redux Thunk** library. To begin, we will need to refactor our naive
    and faulty implementation from the previous section to one using Redux.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习**Thunk模式**以及如何在**Redux Thunk**库中使用它。首先，我们需要重构上一节中的天真和有缺陷的实现，改为使用Redux。
- en: Lifting the state to Redux
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态提升到Redux
- en: 'Instead of relying on the component state, let''s lift it to a Redux store.
    Pay attention to the `Immutable.Map` we use here. Also, the `ADD_TASK` action
    is now using the `update` function from `Immutable.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖组件状态，让我们将其提升到Redux存储中。注意我们在这里使用的`Immutable.Map`。此外，`ADD_TASK`动作现在使用`Immutable.js`的`update`函数：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we have changed the reducer, we need to fix the stateful component. Instead
    of having its own state, it should delegate to the Redux store through actions.
    However, we will implement these actions later on:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经改变了减速器，我们需要修复有状态的组件。它不应该有自己的状态，而是通过动作委托给Redux存储。然而，我们将稍后实现这些动作：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is wise to move fetching logic to a separate service. This will enable other
    components to share the same function once they need to trigger fetch too. This
    is your homework.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将获取逻辑移动到单独的服务是明智的。这将使其他组件在需要触发获取时共享相同的功能。这是你的作业。
- en: Instead of `componentDidMount`, you could dispatch actions to a constructor.
    This, however, could create the temptation to refactor to the function component.
    This would be a disaster, as you would start fetching on every re-render. Also, `componentDidMount`
    is safer for us, as in case of any computations that could slow down the application
    in context of the actions, we are 100% sure that the user can already see `ActivityIndicator`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将动作分派到构造函数而不是依赖于`componentDidMount`。然而，这可能会引发重构为函数组件的诱惑。这将是一场灾难，因为你将在每次重新渲染时开始获取。此外，`componentDidMount`对我们来说更安全，因为在动作的上下文中，如果有任何可能减慢应用程序的计算，我们可以100%确定用户已经看到`ActivityIndicator`。
- en: 'Now, move to the actions implementation. You should be able to write them on
    your own. In case of any trouble, see  `src / Chapter 6 / Example 3 / src / data
    / TaskActions.js`. We will now focus on extending the reducer. This is quite some
    work, as we need to handle all three action types: `FETCH_START`, `FETCH_COMPLETE`,
    and `FETCH_ERROR`, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到动作的实现。你应该能够自己编写它们。如果遇到任何问题，请参阅`src / Chapter 6 / Example 3 / src / data
    / TaskActions.js`。现在我们将专注于扩展减速器。这是相当多的工作，因为我们需要处理所有三种动作类型：`FETCH_START`，`FETCH_COMPLETE`和`FETCH_ERROR`，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is basically it. In the end, you will also need to update views to use
    a new structure, `Immutable.Map`, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上就是这样。最后，你还需要更新视图以使用新的结构`Immutable.Map`，如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are a few improvements to be made to this code. I will not touch on them
    right now, as those are advanced topics and involve more general JavaScript functional
    programming concepts. You will learn about lenses and selectors in [Chapter 8](c5f12b5a-17f8-4cfe-8e0b-5c54713c4288.xhtml),
    *JavaScript and ECMAScript Patterns*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要进行一些改进。我现在不会触及它们，因为那些是高级主题，涉及更一般的JavaScript函数式编程概念。你将在[第8章](c5f12b5a-17f8-4cfe-8e0b-5c54713c4288.xhtml)中学习有关镜头和选择器的内容，*JavaScript和ECMAScript模式*。
- en: Benefits of refactoring to Redux
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构为Redux的好处
- en: It may be tricky to see the benefits of the previous refactor. Some of these
    refactors shine only days after you make them. Take, for example, the need to
    re-fetch the tasks on a given event. This event happens in a completely different
    part of the app and is not connected to the task list. In the naive implementation,
    you would need to deal with the update process and keep everything up to date.
    You would also need to expose a `fetch` function to another component. This would
    tightly couple those two. Disaster. Instead, as you can see, you would likely
    prefer to duplicate fetching logic to the second separated component. Again, you
    would end up with code duplication. Therefore, you would create a parent service
    shared by those two components. Unfortunately, the fetching is tightly coupled
    with the state, hence you would move state to the service as well. Then, you would
    make some hacks, such as using closure to store the data within the service. As
    you can see, this is a smooth solution to these problems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很难看到先前重构的好处。其中一些重构可能在几天后才会显现出来。例如，需要在特定事件上重新获取任务。此事件发生在应用程序的完全不同部分，并且与任务列表无关。在天真的实现中，您需要处理更新过程并保持一切更新。您还需要向另一个组件公开`fetch`函数。这将紧密耦合这两者。灾难。相反，正如您所看到的，您可能更喜欢将获取逻辑复制到第二个独立的组件中。再次，您最终会出现代码重复。因此，您将创建一个由这两个组件共享的父服务。不幸的是，获取与状态紧密耦合，因此您还将状态移动到服务中。然后，您将进行一些技巧，例如使用闭包在服务中存储数据。正如您所看到的，这是这些问题的一个平稳解决方案。
- en: When using the Redux store, however, you have one centralized state that is
    updated only through reducers. Fetching is sending data to the reducers using
    carefully designed actions. Fetch can be performed in a separated service that
    is shared by the components that need to fetch tasks. We will now introduce a
    library that makes all of these things cleaner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Redux存储时，您只有一个通过reducer更新的集中状态。获取是使用精心设计的操作将数据发送到reducer。获取可以在一个单独的服务中执行，该服务由需要获取任务的组件共享。现在，我们将介绍一个使所有这些事情更清洁的库。
- en: Using Redux Thunk
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux Thunk
- en: 'In classic Redux, with no middleware, you cannot dispatch something that is
    not a pure object. With Redux Thunk, you can delay the dispatch by dispatching
    a function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的Redux中，没有中间件，您无法调度不是纯对象的东西。使用Redux Thunk，您可以通过调度函数延迟调度：
- en: '"Redux Thunk middleware allows you to write action creators that return a function
    instead of an action. The thunk can be used to delay the dispatch of an action,
    or to dispatch only if a certain condition is met. The inner function receives
    the store methods dispatch and getState as parameters."'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '"Redux Thunk中间件允许您编写返回函数而不是操作的操作创建者。thunk可以用于延迟操作的调度，或者仅在满足某些条件时进行调度。内部函数接收存储方法`dispatch`和`getState`作为参数。"'
- en: '- Redux Thunk official documentation, available at:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '- Redux Thunk官方文档，网址：'
- en: '[https://github.com/reduxjs/redux-thunk](https://github.com/reduxjs/redux-thunk).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/reduxjs/redux-thunk](https://github.com/reduxjs/redux-thunk)。'
- en: 'For instance, you can dispatch a function. Such a function has two arguments:
    `dispatch` and `getState`. This function does not reach the Redux reducers yet.
    It only delays the old-fashioned Redux dispatch until necessary checks are performed,
    for instance, checks based on current state. Once we are ready to dispatch, we
    use the `dispatch` function provided as a `function` argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以调度一个函数。这样的函数有两个参数：`dispatch`和`getState`。这个函数尚未到达Redux reducer。它只延迟了老式的Redux调度，直到进行必要的检查，例如基于当前状态的检查。一旦我们准备好调度，我们就使用作为`function`参数提供的`dispatch`函数：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the previous section, I pointed out that the `fetch` call could be a separate
    function. If you haven''t done the homework, here is an example refactor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我指出`fetch`调用可以是一个单独的函数。如果你还没有做作业，这里是一个重构的例子：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, our so-called `ActionCreators` are tightly coupled to `dispatch`,
    and therefore not only create actions, but also `dispatch`. Let''s loosen their
    responsibilities by removing dispatching:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们所谓的`ActionCreators`与`dispatch`紧密耦合，因此不仅创建动作，还有`dispatch`。让我们通过移除dispatch来放松它们的责任：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to make sure to dispatch the preceding actions to the relevant
    places. This can be achieved by passing to `dispatch`, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保将前面的动作分发到相关的位置。可以通过以下方式实现：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For those experienced in programming, this step may look a little like we are
    repeating ourselves. We are duplicating function parameters and the only thing
    we gain is the invocation of dispatch. We can fix this with functional patterns.
    Such improvements will be made as part of [Chapter 8](c5f12b5a-17f8-4cfe-8e0b-5c54713c4288.xhtml), *JavaScript
    and ECMAScript Patterns*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有编程经验的人来说，这一步可能看起来有点像我们在重复自己。我们在重复函数参数，唯一得到的是调用分发。我们可以用函数模式来解决这个问题。这些改进将作为《第8章》*JavaScript和ECMAScript模式*的一部分进行。
- en: Additionally, please note that in this book, I'm not writing many tests. Once
    you make writing tests a habit, you will quickly appreciate such easily testable
    code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，在这本书中，我没有写很多测试。一旦你养成了写测试的习惯，你就会很快欣赏到这种易于测试的代码。
- en: 'Having done this, we can now adjust our container component, as shown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以调整我们的容器组件，如下所示：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Okay, this is a great refactor, but where is Redux Thunk? This is a very good
    question. I did prolong this example on purpose. In many React and React Native
    projects, I see overuse of Redux Thunk and other libraries. I don't want you to
    be another developer who does not understand the purpose of Redux Thunk and abuses
    the power that it gives.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个很好的重构，但Redux Thunk在哪里？这是一个非常好的问题。我故意延长了这个例子。在许多React和React Native项目中，我看到了对Redux
    Thunk和其他库的过度使用。我不希望你成为另一个不理解Redux Thunk目的并滥用其功能的开发人员。
- en: Redux Thunk primarily lets you decide to dispatch conditionally. The access
    to `dispatch` through the Thunk function is not something extraordinary. The main
    benefit is the second argument, `getState`. This lets you access the current state
    and decide based on the values there.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Thunk主要让你有条件地决定是否要分发。通过Thunk函数访问`dispatch`并不是什么特别的事情。主要的好处是第二个参数`getState`。这让你可以访问当前状态，并根据那里的值做出决定。
- en: Such powerful tools may lead you to create impure reducers. How? Instead of
    creating a real reducer, you would create a **setter reducer**, working similarly
    to the set function in classes. Such a reducer would be invoked only to set the
    value; however, the value would be computed in the Thunk function, using the `getState`
    function. This is completely anti-pattern and may lead to a serious breaking of
    race conditions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样强大的工具可能会导致你创建不纯的reducer。怎么会呢？你会创建一个**setter reducer**，它的工作方式类似于类中的set函数。这样的reducer只会被调用来设置值；然而，值将在Thunk函数中计算，使用`getState`函数。这完全是反模式，可能会导致严重的竞争条件破坏。
- en: Now that we know the dangers, let's move on to the real usages of Thunks. Imagine
    a situation where you would like to make a decision conditionally. How would you
    access the state to make an `if` statement? This gets complicated once we use
    the `connect()` function in Redux. The `mapDispatchToProps` function that we pass
    to `connect` does not have access to the state. But we need it, so here comes
    a valid usage of Redux Thunk.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了危险，让我们继续讨论Thunk的真正用途。想象一种情况，您希望有条件地做出决定。如何访问状态以进行`if`语句？一旦我们在Redux中使用`connect()`函数，这就变得复杂起来。我们传递给`connect`的`mapDispatchToProps`函数无法访问状态。但我们需要它，这就是Redux
    Thunk的一个有效用法。
- en: 'The following is good to know: how would we make an escape hatch if we could
    not use Redux Thunk? We could pass part of the state to the `render` function,
    and then invoke the original function with the expected state. The `if` statement
    could be done with a regular `if` in JSX. This could, however, lead to serious
    performance issues.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要知道的：如果我们不能使用Redux Thunk，我们如何制作一个逃生舱？我们可以将部分状态传递给`render`函数，然后使用预期的状态调用原始函数。`if`语句可以在JSX中使用常规的`if`。然而，这可能会导致严重的性能问题。
- en: It's time to use Redux Thunk in our case. You may have noticed that our dataset
    does not contain IDs. This is a huge problem if we fetch tasks two times, as we
    have no mechanism to tell which tasks have been added and which are already present
    in our UI. The current approach of adding all of the fetched tasks would lead
    to task duplication. The first prevention mechanism for our broken architecture
    is to stop the fetch if `isLoading` is `true`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的情况下使用Redux Thunk了。您可能已经注意到我们的数据集不包含ID。如果我们两次获取任务，这将是一个巨大的问题，因为我们没有机制告诉哪些任务已经添加，哪些已经存在于我们的UI中。当前的方法是添加所有获取到的任务，这将导致任务重复。我们破碎架构的第一个预防机制是在`isLoading`为`true`时停止获取。
- en: A real-life scenario would either use IDs or refresh all the tasks on fetch.
    If so, `ADD_TASK` would need to guarantee changes in the backend server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中的情况要么使用ID，要么在获取时刷新所有任务。如果是这样，`ADD_TASK`需要保证后端服务器中的更改。
- en: 'In the era of Progressive Web Apps, we need to stress this problem even further.
    Take the case where a connection is lost before adding a new task. If your UI
    adds the task locally and schedules a backend update, once the network connection
    is resolved you may run into a race condition: this means that tasks are being
    refreshed before your `ADD_TASK` update is propagated in the backend system. As
    a result, you would end up with a task list that will not contain the added task
    until you refetch all tasks from the backend. This may be extremely misleading
    and should not happen in any financial institution.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在渐进式Web应用程序时代，我们需要进一步强调这个问题。考虑一种情况，即在添加新任务之前失去连接。如果您的UI在本地添加任务并安排后端更新，一旦网络连接解决，您可能会遇到竞争条件：这意味着任务在`ADD_TASK`更新在后端系统中传播之前被刷新。结果，您最终会得到一个任务列表，其中不包含添加的任务，直到您从后端重新获取所有任务。这可能是非常误导人的，不应该发生在任何金融机构中。
- en: 'Let''s implement this naive prevention mechanism to illustrate the capabilities
    of Redux Thunk. First, install the library with the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这种天真的预防机制来说明Redux Thunk的能力。首先，使用以下命令安装库：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we need to apply `thunk` middleware to Redux, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将`thunk`中间件应用到Redux中，如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From now on, we can dispatch functions. Let''s now fix our `fetch` function
    to avoid multiple requests:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以调度函数。现在让我们修复我们的`fetch`函数，以避免多次请求：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this is quite a simple use case. Please use Redux Thunk wisely
    and do not abuse the power that it gives you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是一个非常简单的用例。请明智地使用Redux Thunk，不要滥用它给您带来的力量。
- en: Understanding the Thunk pattern
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Thunk模式
- en: Thunk is another pattern that isn't specific to React or Redux. Actually, it
    is used quite widely in many hardcore solutions, such as compilers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Thunk是另一种模式，不特定于React或Redux。实际上，在许多复杂的解决方案中，如编译器，它被广泛使用。
- en: 'Thunk is a pattern that delays evaluation until it cannot be avoided. One of
    the beginner examples that explains this is simple addition. An example is shown
    here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Thunk是一种延迟评估的模式，直到无法避免为止。解释这一点的初学者示例之一是简单的加法。示例如下：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some more complex usages, for instance, in functional languages, may rely on
    this pattern throughout the entire language. Hence, computations are performed
    only when the end application layer needs them. Usually, no ahead-of-time computations
    are performed, as such optimizations are the responsibility of the developer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更复杂的用法，例如在函数式语言中，可能会在整个语言中依赖于这种模式。因此，计算只有在最终应用层需要它们时才执行。通常情况下，不会进行提前计算，因为这样的优化是开发人员的责任。
- en: The saga pattern and Redux Saga
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传说模式和Redux Saga
- en: 'So far, we can perform simple API calls using `fetch`, and we know how to organize
    our code to be reusable. In some areas, however, we could do better if our application
    required it. Before we dive in Redux Saga, I want to introduce two new patterns:
    iterator and generator.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用`fetch`执行简单的API调用，并且知道如何组织我们的代码以实现可重用性。然而，在某些领域，如果我们的应用程序需要，我们可以做得更好。在深入研究Redux
    Saga之前，我想介绍两种新模式：迭代器和生成器。
- en: '"Processing each of the items in a collection is a very common operation. JavaScript
    provides a number of ways of iterating over a collection, from simple for loops
    to map and filter. Iterators and Generators bring the concept of iteration directly
    into the core language and provide a mechanism for customizing the behavior of for...ofloops."'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “处理集合中的每个项目是一个非常常见的操作。JavaScript提供了许多迭代集合的方法，从简单的for循环到map和filter。迭代器和生成器直接将迭代的概念引入核心语言，并提供了自定义for...of循环行为的机制。”
- en: '- JavaScript guide on MDN web docs at:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '- MDN web文档上的JavaScript指南：'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators).
    [](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators).
    [](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
- en: Introduction to the iterator pattern
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式简介
- en: The iterator, as the name suggests, lets you iterate over a collection. To be
    able to do so, the collection needs to implement an iterable interface. In JavaScript,
    there are no interfaces, hence the iterator simply implements a single function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，迭代器允许您遍历集合。为了能够这样做，集合需要实现一个可迭代接口。在JavaScript中，没有接口，因此迭代器只是实现了一个函数。
- en: '"An object is an iterator when it knows how to access items from a collection
    one at a time, while keeping track of its current position within that sequence.
    In JavaScript an iterator is an object that provides a next method which returns
    the next item in the sequence. This method returns an object with two properties: done and value."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象知道如何一次从集合中访问项目，并在该序列内跟踪其当前位置时，该对象就是一个迭代器。在JavaScript中，迭代器是一个提供next方法的对象，该方法返回序列中的下一个项目。此方法返回一个具有两个属性的对象：done和value。
- en: '- JavaScript guide on MDN web docs'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '- MDN web文档上的JavaScript指南'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
- en: 'The following is an example of such a function from MDN web docs:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MDN web文档中此类函数的示例：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The generator pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器模式
- en: Generators are similar to iterators; here, however, you iterate over carefully
    designed breakpoints within a function. A generator returns an iterator. The returned
    iterator iterates over the mentioned breakpoints and, each time, returns some
    value from the function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器类似于迭代器；然而，在这里，你会在函数内部精心设计的断点上进行迭代。生成器返回一个迭代器。返回的迭代器在提到的断点上进行迭代，并且每次从函数中返回一些值。
- en: 'To signal that the function is a generator, we use a special `*****` sign,
    for instance, `function* idGenerator()`. Please find an example generator function
    in the following snippet. Generators use the `yield` keyword to return the current
    iteration step value. The iterator will resume in the next line if its `next()`
    function is invoked, as seen here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示该函数是一个生成器，我们使用特殊的`*****`符号，例如，`function* idGenerator()`。请在以下代码片段中找到一个示例生成器函数。生成器使用`yield`关键字来返回当前迭代步骤的值。如果调用了它的`next()`函数，迭代器将在下一行恢复，就像这样：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we create a `generator` function. The `Generator` function expects one
    argument. Based on the argument provided, the generator knows when to stop generating
    new numbers. After the function, we create an example number iterator and iterate
    over its values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`generator`函数。`Generator`函数期望一个参数。根据提供的参数，生成器知道何时停止生成新的数字。在函数之后，我们创建一个示例数字迭代器并迭代其值。
- en: Redux Saga
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux Saga
- en: Redux Saga rely heavily on the generator pattern. Thanks to this approach, we
    can decouple side effects entirely into sagas that act as if they were a separate
    thread. It is convenient and provides a few advantages to Thunk functions in the
    long run. Some of those rely on composability, with sagas being easy to test and
    giving cleaner flows to execute asynchronous code. All of these may sound unclear
    right now, so let's dive in to get a better understanding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Saga在很大程度上依赖于生成器模式。由于这种方法，我们可以将副作用完全解耦到行为就像是一个独立线程的sagas中。这是方便的，并且从长远来看，相对于Thunk函数提供了一些优势。其中一些依赖于可组合性，sagas易于测试，并提供更清晰的流程来执行异步代码。现在这些可能听起来不清楚，所以让我们深入了解一下。
- en: 'This book does not touch much on React, Redux, and React Native testing. This
    topic would lengthen this book significantly and, I believe, deserves a  separate
    book. However, I will stress how important it is to test your code. This information
    box is to remind you about testing in Redux Sagas. In different places on the
    internet (GitHub, forums, Stack Overflow) I have seen this mentioned over and
    over again: sagas are much easier to test than Thunks. Check this on your own—you
    will not regret it.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不涉及太多关于React、Redux和React Native的测试。这个主题会让本书变得很长，我认为它值得有一本单独的书。然而，我会强调测试代码的重要性。这个信息框是为了提醒你在Redux
    Sagas中进行测试。在互联网的不同地方（GitHub、论坛、Stack Overflow）我一遍又一遍地看到这个提到：sagas比Thunks更容易测试。你可以自己验证一下，你不会后悔的。
- en: First, do the beginner steps of installing the library and applying the middleware.
    These steps can be found in the official Redux Saga README file, available at
    [https://redux-saga.js.org/](https://redux-saga.js.org/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，完成安装库和应用中间件的初学者步骤。这些步骤可以在官方的Redux Saga README文件中找到，网址为[https://redux-saga.js.org/](https://redux-saga.js.org/)。
- en: 'It''s time to create the first saga and add it to our `rootSaga.` Do you remember
    the case with fetching tasks? They could be requested from many places (many decoupled
    widgets or features). The approach of saga is similar to our previous solutions,
    so let''s see how it can be implemented in the following example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建第一个saga并将其添加到我们的`rootSaga`中了。还记得获取任务的情况吗？它们可以从许多地方（许多解耦的小部件或功能）请求。saga的方法与我们之前的解决方案类似，所以让我们看看它如何在以下示例中实现：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our `fetchTasks` saga is really simple: first, it fetches tasks, then checks
    if an error happened, and either dispatches an error event or a successful event
    with the fetched data attached.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fetchTasks` saga非常简单：首先，它获取任务，然后检查是否发生了错误，然后要么分派一个带有获取的数据附加的错误事件，要么分派一个成功事件。
- en: 'How do we trigger the `fetchTasks` saga? To convince you why sagas are powerful,
    let''s even push it further. Let''s say our code base is decoupled and a few features
    will request tasks at almost the same time. How do we prevent multiple fetch task
    jobs being triggered? Redux Saga library has a ready-made solution for this: the `throttle` function.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何触发`fetchTasks` saga？为了说服你saga的强大之处，让我们更进一步。假设我们的代码库是解耦的，一些功能几乎同时请求任务。我们如何防止触发多个获取任务的作业？Redux
    Saga库为此提供了现成的解决方案：`throttle`函数。
- en: '"throttle(ms, pattern, saga, ...args) Spawns a saga on an action dispatched
    to the Store that matches pattern. After spawning a task it''s still accepting
    incoming actions into the underlaying buffer, keeping at most 1 (the most recent
    one), but in the same time holding up with spawning new task for ms milliseconds
    (hence its name - throttle). Purpose of this is to ignore incoming actions for
    a given period of time while processing a task."'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '"throttle(ms, pattern, saga, ...args) 在与模式匹配的存储器上分派一个动作，然后在生成任务后，它仍然接受传入的动作到底层缓冲区，最多保留1个（最近的一个），但同时在ms毫秒内不生成新任务（因此它的名称是
    - throttle）。其目的是在处理任务时忽略一定时间内的传入动作。"'
- en: '- Official Redux Saga documentation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '- 官方Redux Saga文档:'
- en: '[https://redux-saga.js.org/docs/api/](https://redux-saga.js.org/docs/api/).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux-saga.js.org/docs/api/](https://redux-saga.js.org/docs/api/).'
- en: 'Our use case will be very straightforward:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用例非常简单：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `fetchTasks` function will be executed on the `TASK_FETCH_START` event.
    For two seconds, the same event will not cause another `fetchTasks` function execution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchTasks`函数将在`TASK_FETCH_START`事件上执行。在两秒内，相同的事件不会导致另一个`fetchTasks`函数的执行。'
- en: That's it. One of the last few things is to add the preceding saga to `rootSaga`.
    This is not a very interesting part but, if you are curious, I recommend you check
    the full example in the code repository, available at [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。最后的几件事之一是将前面的saga添加到`rootSaga`中。这不是一个非常有趣的部分，但是如果你感兴趣，我建议你在代码存储库中查看完整的示例，该示例可在[https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native)上找到。
- en: Redux Saga benefits
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux Saga的好处
- en: In more complex applications with well defined routines, Redux Saga outshines
    Redux Thunk. Once you run into a need to cancel, rerun, or reply to part of the
    flow, it is not immediately obvious how these can be done using Thunks or plain
    Redux. With composable sagas and well-maintained iterators, you can do it with
    ease. Even the official documentation provides recipes for such problems. (See
    the *Further reading* section at the end of this chapter for reference.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中，具有明确定义的例程，Redux Saga比Redux Thunk更出色。一旦你遇到需要取消、重新运行或回复流程的一部分，就不会立即明显地知道如何使用Thunk或纯Redux来完成这些操作。使用可组合的saga和良好维护的迭代器，你可以轻松地完成这些操作。即使官方文档也提供了这些问题的解决方案。（有关参考，请参阅本章末尾的*进一步阅读*部分。）
- en: The dark side of such a powerful library is its problematic usage in brownfield
    applications. Such applications, with features possibly written in a promise-based
    or Thunk fashion, may require a significant refactor in order to be used with
    sagas with the ease found in greenfield apps. For instance, it is not so easy
    to call a saga from the Thunk function, nor you can wait on the dispatched function
    as you would on the promise within sagas. There are probably good hacks to connect
    both worlds, but is it really worth it?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个强大库的阴暗面在于它在旧应用程序中的使用可能会出现问题。这些应用程序可能以基于promise或Thunk的方式编写功能，可能需要进行重大重构才能与在新应用程序中找到的与sagas的使用方式相匹配。例如，从Thunk函数调用saga并不容易，也不能像在sagas中等待分发的函数那样等待promise。可能有很好的方法来连接这两个世界，但真的值得吗？
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused heavily on networking patterns and the side effects
    that come along with them. We went through simple patterns and then used the available
    tools on the market. You have learned about the Thunk pattern, along with iterator
    and generator patterns. All three of these patterns will be useful in your future
    programming career, whether it is in React Native or not.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们重点关注了网络模式和随之而来的副作用。我们经历了简单的模式，然后使用了市场上可用的工具。您已经了解了Thunk模式，以及迭代器和生成器模式。这三种模式在您未来的编程生涯中都将非常有用，无论是在React
    Native中还是其他地方。
- en: As for the React ecosystem, you have learned the basics of the Redux Thunk and
    Redux Saga libraries. Both of them solve some of the challenges that come with
    large scale applications. Use them wisely and bear in mind all of the warnings
    I have placed within this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 至于React生态系统，您已经了解了Redux Thunk和Redux Saga库的基础知识。它们都解决了大规模应用程序所面临的一些挑战。明智地使用它们，并牢记我在本章中提出的所有警告。
- en: Now that we know how to display data, style it, and fetch it, we are ready to
    learn some application building patterns. Namely, in the next chapter, you will
    learn navigational patterns. In React Native, there are plenty of solutions to
    these problems and I'm more than happy to teach you how to choose the one that
    matches your project's needs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何显示数据，样式化数据和获取数据，我们已经准备好学习一些应用程序构建模式。特别是在下一章中，您将学习导航模式。在React Native中，有很多解决这些问题的解决方案，我很乐意教您如何选择与您项目需求匹配的解决方案。
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Writing Tests—Redux Official Documentation:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试-Redux官方文档：
- en: '[https://redux.js.org/recipes/writing-tests](https://redux.js.org/recipes/writing-tests).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/recipes/writing-tests](https://redux.js.org/recipes/writing-tests).'
- en: 'Implementing Undo History—Redux Official Documentation:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现撤销历史-Redux官方文档：
- en: '[https://redux.js.org/recipes/implementing-undo-history](https://redux.js.org/recipes/implementing-undo-history).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/recipes/implementing-undo-history](https://redux.js.org/recipes/implementing-undo-history).'
- en: 'Server rendering—Redux Official Documentation:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器渲染-Redux官方文档：
- en: '[https://redux.js.org/recipes/server-rendering](https://redux.js.org/recipes/server-rendering).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/recipes/server-rendering](https://redux.js.org/recipes/server-rendering).'
- en: 'Normalizing state—Redux Official Documentation:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范化状态-Redux官方文档：
- en: '[https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape).'
- en: This is important in the context of networking patterns. Some of your data that
    is fetched from backend systems will need to be normalized.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这在网络模式的背景下非常重要。从后端系统获取的一些数据将需要进行规范化处理。
- en: 'Async actions—Redux Official Documentation:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步操作-Redux官方文档：
- en: '[https://redux.js.org/advanced/async-actions](https://redux.js.org/advanced/async-actions).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/advanced/async-actions](https://redux.js.org/advanced/async-actions).'
- en: 'Redux Saga recipes—Redux Saga Official Documentation:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Saga食谱-Redux Saga官方文档：
- en: '[https://redux-saga.js.org/docs/recipes/](https://redux-saga.js.org/docs/recipes/).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux-saga.js.org/docs/recipes/](https://redux-saga.js.org/docs/recipes/)。'
- en: This resource is particularly valuable for its recipes for throttling, debouncing,
    and undo using sagas.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源特别有价值，因为它提供了使用saga进行节流、去抖动和撤销的食谱。
- en: 'Redux Saga channels – Redux Saga Official Documentation:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Saga通道-Redux Saga官方文档：
- en: '"Until now we''ve used the take and put effects to communicate with the Redux
    Store. Channels generalize those Effects to communicate with external event sources
    or between Sagas themselves. They can also be used to queue specific actions from
    the Store."'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “到目前为止，我们已经使用‘take’和‘put’效果与Redux Store进行通信。通道将这些效果泛化为与外部事件源或Sagas之间进行通信。它们还可以用于从Store中排队特定的操作。”
- en: '- Redux Saga Official Documentation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '- Redux Saga官方文档：'
- en: '[https://redux-saga.js.org/docs/advanced/Channels.html](https://redux-saga.js.org/docs/advanced/Channels.html).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redux-saga.js.org/docs/advanced/Channels.html](https://redux-saga.js.org/docs/advanced/Channels.html)。'
- en: 'Idiomatic redux thoughts on Thunks, sagas, abstraction, and reusability:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Thunk、saga、抽象和可重用性的惯用redux思想：
- en: '[https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/](https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/](https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/)。'
- en: 'Resources library: React Redux Links/Redux Side effects:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源库：React Redux链接/Redux副作用：
- en: '[https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md](https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md](https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md)。'
- en: 'A Saga on Sagas:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Saga的Saga：
- en: '"The term *saga* is commonly used in discussions of CQRS to refer to a piece
    of code that coordinates and routes messages between bounded contexts and aggregates.
    However, [...] we prefer to use the term *process manager* to refer to this type
    of code artifact."'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: “术语‘saga’通常在CQRS讨论中用来指代协调和路由有界上下文和聚合之间的消息的一段代码。然而，[...]我们更倾向于使用术语‘过程管理器’来指代这种类型的代码构件。”
- en: 'A Saga on Sagas - Microsoft Docs:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Saga的Saga-Microsoft文档：
- en: '[https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591569(v=pandp.10)](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591569(v=pandp.10)).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591569(v=pandp.10)](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591569(v=pandp.10))。'
- en: 'GraphQL—another approach to side effects. GraphQL is a query language for your
    API, both on the frontend and backend side. Find out more here:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL-另一种处理副作用的方法。GraphQL是一个用于API的查询语言，既可以用于前端，也可以用于后端。在这里了解更多：
- en: '[https://graphql.org/learn/](https://graphql.org/learn/).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://graphql.org/learn/](https://graphql.org/learn/)。'
- en: 'Redux Observable—a Thunk and sagas competitor. Introduces Reactive Programming
    patterns:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Observable-Thunk和saga的竞争对手。介绍了响应式编程模式：
- en: '[https://github.com/redux-observable/redux-observable](https://github.com/redux-observable/redux-observable).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/redux-observable/redux-observable](https://github.com/redux-observable/redux-observable)。'
- en: 'Please also check out RxJS, a reactive programming library for JavaScript:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还请查看RxJS，这是JavaScript的响应式编程库：
- en: '[https://github.com/reactivex/rxjs](https://github.com/reactivex/rxjs).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/reactivex/rxjs](https://github.com/reactivex/rxjs)。'
- en: 'Representational State Transfer :'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表述性状态转移：
- en: '[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)。'
- en: 'HATEOAS (a component of the REST architecture):'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS（REST架构的一个组件）：
- en: '[https://en.wikipedia.org/wiki/HATEOAS](https://en.wikipedia.org/wiki/HATEOAS).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: https://en.wikipedia.org/wiki/HATEOAS
