- en: Cleaning Up Your Code
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 清理您的代码
- en: This chapter assumes that you already have experience with JSX and you want
    to improve your skills to use it effectively. To use JSX/TSX without any problems
    or unexpected behaviors, it is essential to understand how it works under the
    hood, and the reasons why it is a useful tool for building UIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经有了JSX的经验，并且希望提高使用它的技能。要想毫无问题地使用JSX/TSX，理解其内部工作原理以及构建UI的有用工具的原因是至关重要的。
- en: Our goal is to write clean JSX/TSX code, maintain it, and know where it comes
    from, how it gets translated to JavaScript, and what features it provides.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写干净的JSX/TSX代码，维护它，并了解它的来源，它是如何被转换为JavaScript的，以及它提供了哪些特性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is JSX and why should we use it?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是JSX，为什么我们应该使用它？
- en: What is Babel and how can we use it to write modern JavaScript code?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel是什么，我们如何使用它来编写现代JavaScript代码？
- en: The main features of JSX and the differences between HTML and JSX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX的主要特性以及HTML和JSX之间的区别
- en: Best practices to write JSX in an elegant and maintainable way
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以优雅和可维护的方式编写JSX的最佳实践
- en: How linting, and ESLint in particular, can make our JavaScript code consistent
    across applications and teams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: linting以及特别是ESLint如何使我们的JavaScript代码在应用程序和团队之间保持一致。
- en: The basics of functional programming and why following a functional paradigm
    will make us write better React components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的基础以及为什么遵循函数式范式会让我们编写更好的React组件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Using JSX
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSX
- en: In the previous chapter, we saw how React changes the concept of separation
    of concerns, moving the boundaries inside components. We also learned how  React  uses
    the elements returned by the components to display the UI on the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了React如何改变关注点分离的概念，将边界移到组件内部。我们还学习了React如何使用组件返回的元素来在屏幕上显示UI。
- en: Let's now look at how we can declare our elements inside our components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在组件内部声明我们的元素。
- en: 'React provides two ways to define our elements. The first one is by using JavaScript
    functions, and the second one is by using JSX, an optional XML-like syntax. The
    following is a screenshot of the examples section of the official React.js website
    ([https://reactjs.org/#examples](https://reactjs.org/#examples)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了两种定义元素的方式。第一种是使用JavaScript函数，第二种是使用JSX，一种可选的类似XML的语法。以下是官方React.js网站示例部分的截图（[https://reactjs.org/#examples](https://reactjs.org/#examples)）：
- en: '![](assets/c47b0f53-2804-4466-b2e2-74e4f74880ff.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c47b0f53-2804-4466-b2e2-74e4f74880ff.png)'
- en: To begin with, JSX is one of the main reasons why people fail to approach React,
    because looking at the examples on the home page and seeing JavaScript mixed with
    HTML for the first time can seem strange to most of us.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，JSX是人们失败接触React的主要原因之一，因为第一次看到主页上的示例并且看到JavaScript与HTML混合在一起可能对我们大多数人来说都会感到奇怪。
- en: As soon as we get used to it, we realize that it is very convenient, precisely
    because it is similar to HTML and looks very familiar to anyone who  has  already
    created UIs on the web. The opening and closing tags make it easier to represent
    nested trees of elements, something that would have been unreadable and hard to
    maintain using plain JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们习惯了它，我们就会意识到它非常方便，因为它类似于HTML，并且对于已经在Web上创建过UI的人来说非常熟悉。开放和闭合标签使得表示嵌套的元素树变得更容易，使用纯JavaScript将会变得难以阅读和难以维护。
- en: Let's take a look at JSX in more detail in the following sub-sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下子章节中更详细地了解JSX。
- en: Babel 7
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babel 7
- en: To use JSX (and some features of ES6) in our code, we  have  to install the
    new Babel 7\. Babel is a popular JavaScript compiler widely adopted within the
    React community.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中使用JSX（和一些ES6的特性），我们必须安装新的Babel 7。Babel是一个流行的JavaScript编译器，在React社区广泛使用。
- en: First of all, it is important to clearly  understand  the problems it can solve
    for us and why we need to add a step to our process. The reason is that we want
    to use features of the language that have not yet been added in the browser, our
    target environment. Those advanced features make our code cleaner for developers,
    but the browser cannot understand and execute it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是清楚地了解它可以为我们解决的问题，以及为什么我们需要在我们的流程中添加一步。原因是我们想要使用语言的特性，这些特性尚未添加到浏览器，我们的目标环境。这些高级特性使我们的代码对开发人员更清晰，但浏览器无法理解和执行它。
- en: The solution is to write our scripts in JSX and ES6 and, when we are ready to
    ship, we compile the sources into ES5, the standard specification implemented
    in major browsers today.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在JSX和ES6中编写我们的脚本，当我们准备好发布时，我们将源代码编译成ES5，这是今天主要浏览器中实现的标准规范。
- en: Babel can compile ES6 code into ES5 JavaScript, as well as compile JSX into
    JavaScript functions. This process is called  **transpilation**  because it compiles
    the source into a new source rather than into an executable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Babel可以将ES6代码编译成ES5 JavaScript，还可以将JSX编译成JavaScript函数。这个过程被称为**转译**，因为它将源代码编译成新的源代码，而不是可执行文件。
- en: 'In older versions of Babel 6.x, you installed the `babel-cli` package and you
    got `babel-node` and `babel-core`, and now everything is separated: `@babel/core`,
    `@babel/cli`, `@babel/node`, and so on.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧的Babel 6.x版本中，您安装了`babel-cli`包，并获得了`babel-node`和`babel-core`，现在一切都分开了：`@babel/core`，`@babel/cli`，`@babel/node`等等。
- en: 'To install Babel, we need to install  `@babel/core`  and  `@babel/node` as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Babel，我们需要安装`@babel/core`和`@babel/node`如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you do not want to install it globally (developers usually tend to avoid
    this), you can install Babel locally to a project and run it through an `npm`  script,
    but for this chapter, a global instance is fine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想全局安装它（开发人员通常倾向于避免这样做），您可以将Babel安装到项目中并通过`npm`脚本运行它，但在本章中，全局实例就可以了。
- en: 'When the installation is complete, we can run the following command to compile
    any JavaScript file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以运行以下命令来编译任何JavaScript文件：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One of the reasons why Babel is so powerful is because it is highly configurable.
    Babel is just a tool to transpile a source file into an output file, but to apply  some  transformations,
    we need to configure it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Babel之所以如此强大的原因之一是因为它是高度可配置的。Babel只是一个将源文件转译为输出文件的工具，但要应用一些转换，我们需要对其进行配置。
- en: 'Luckily, there are some very useful presets of configurations that we can easily
    install and use:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些非常有用的预设配置，我们可以轻松安装和使用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the installation is complete, we create a configuration file called `.babelrc`
    in the `root` folder, and put the following lines into it to tell Babel to use
    those presets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们在`root`文件夹中创建一个名为`.babelrc`的配置文件，并将以下行放入其中，告诉Babel使用这些预设：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From this point on, we can write ES6 and JSX in our source files and execute
    the output files in the browser.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们可以在我们的源文件中编写ES6和JSX，并在浏览器中执行输出文件。
- en: Creating our first element
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个元素
- en: 'Now that our  environment  has been set up to support JSX, we can dive into
    the most basic example: generating a  `div`  element. This is how you would create
    a  `div` element with the `_jsx` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经设置好支持JSX，我们可以深入最基本的例子：生成一个`div`元素。这是您使用`_jsx`函数创建`div`元素的方式：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the JSX for creating a `div` element:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于创建`div`元素的JSX：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It looks similar to regular HTML.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来类似于常规HTML。
- en: The big difference is that we are writing the markup inside a  `.js`  file,
    but it is  important  to note that JSX is only syntactic sugar, and it gets  transpiled  into
    JavaScript before being executed in the browser.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别在于我们在`.js`文件中编写标记，但重要的是要注意JSX只是语法糖，在在浏览器中执行之前会被转译成JavaScript。
- en: In fact, our  `<div />` element is translated into `_jsx('div', {})`  when we
    run Babel, which is something we should always keep in mind when we write our
    templates.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我们运行Babel时，我们的`<div />`元素被翻译成`_jsx('div', {})`，这是我们在编写模板时应该牢记的事情。
- en: In React 17, `React.createElement('div')` is deprecated, now internally using
    `react/jsx-runtime` to render the JSX, meaning that we will have something such
    as `_jsx('div', {})`. Basically, this means that you don't need to import the
    React object anymore in order to write JSX code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在React 17中，`React.createElement('div')`已被弃用，现在内部使用`react/jsx-runtime`来渲染JSX，这意味着我们将得到类似`_jsx('div',
    {})`的东西。基本上，这意味着您不再需要导入React对象来编写JSX代码。
- en: DOM elements and React components
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM元素和React组件
- en: With JSX, we can create both  HTML  elements and React components; the only  difference  is
    whether or not they start with a capital letter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSX，我们可以创建HTML元素和React组件；唯一的区别是它们是否以大写字母开头。
- en: 'For example, to render an HTML button, we use  `<button />`, while to render
    the  `Button`  component, we use  `<Button />`. The first button is  transpiled  into
    the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要渲染一个HTML按钮，我们使用`<button />`，而要渲染`Button`组件，我们使用`<Button />`。第一个按钮被转译成如下：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second one is transpiled into the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个被转译成如下：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference here is that in the first call, we are passing the type of the
    DOM element as a string, while in the second call, we are passing the component
    itself, which means that it should exist in the scope to work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于，在第一个调用中，我们将DOM元素的类型作为字符串传递，而在第二个调用中，我们传递的是组件本身，这意味着它应该存在于作用域中才能工作。
- en: As you may have noticed, JSX supports self-closing tags, which are pretty good
    for keeping the code terse and do not require us to repeat unnecessary tags.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，JSX支持自闭合标签，这对保持代码简洁非常有用，并且不需要我们重复不必要的标签。
- en: Props
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'JSX is very convenient when your DOM elements or React components have props.
    Using XML is pretty easy to set attributes on elements:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的DOM元素或React组件具有props时，JSX非常方便。使用XML很容易在元素上设置属性：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The equivalent in JavaScript would be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中的等价物如下：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is far less readable, and even with only a couple of attributes, it is
    harder to read without a bit of reasoning.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码可读性差得多，即使只有几个属性，没有一点推理就很难阅读。
- en: Children
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子元素
- en: 'JSX  allows you to define children to describe the tree of elements and compose
    complex UIs. A basic example is a link with text inside it, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JSX允许您定义子元素以描述元素树并组合复杂的UI。一个基本的例子是带有文本的链接，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This would be transpiled into the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转译成如下：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our link can be enclosed inside a `div` element for some layout requirements,
    and the JSX snippet to achieve that is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的链接可以被包含在`div`元素中以满足一些布局要求，实现这一目的的JSX片段如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The JavaScript equivalent is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript等价物如下：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It should now be clear how the *XML-like* syntax of JSX makes everything more
    readable and maintainable, but it is always important to know the JavaScript parallel
    to our JSX has control over the creation of elements. The good part is that we
    are not limited to having elements as children of elements, but we can use JavaScript
    expressions, such as functions or variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了JSX的*类似XML*的语法如何使一切更易读和易维护，但重要的是要知道我们的JSX的JavaScript并行对元素的创建有控制。好处是我们不仅限于将元素作为元素的子元素，而是可以使用JavaScript表达式，比如函数或变量。
- en: 'To do this, we have to enclose the expression within curly braces:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须用花括号括起表达式：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The same applies to non-string attributes, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于非字符串属性，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you see, any variable or function should be enclosed with curly braces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，任何变量或函数都应该用花括号括起来。
- en: Differences with HTML
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与HTML的不同
- en: So far, we have looked at the similarities between JSX and HTML. Let's now look
    at the little differences between them and the reasons they exist.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了JSX和HTML之间的相似之处。现在让我们看看它们之间的小差异以及存在的原因。
- en: Attributes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: We must always keep in mind that JSX is not a  standard  language and that it
    gets transpiled into JavaScript. Because of this, some attributes cannot be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终记住JSX不是一种标准语言，它被转译成JavaScript。因此，某些属性无法使用。
- en: 'For example, instead of  `class`, we have to use  `className`, and instead
    of  `for`, we have to use  `htmlFor`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们必须使用`className`代替`class`，并且必须使用`htmlFor`代替`for`，如下所示：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reason for this is that `class` and `for` are reserved words in JavaScript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`class`和`for`在JavaScript中是保留字。
- en: Style
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: A pretty significant difference is the way the `style` attribute works. We will
    look at how to use it in more detail in *Chapter 8, Making Your Components Look
    Beautiful*, but now we will focus on the way it works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当重要的区别是`style`属性的工作方式。我们将在*第8章，使您的组件看起来漂亮*中更详细地讨论如何使用它，但现在我们将专注于它的工作方式。
- en: 'The `style` attribute does not accept a CSS string as the HTML parallel does,
    but it expects a JavaScript object where the style names are *camelCased*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`属性不接受CSS字符串，而是期望一个JavaScript对象，其中样式名称是*驼峰式*的：'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, you can pass an object to the `style` prop, meaning you can
    even  have your styles in a separate variable if you want:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以将一个对象传递给`style`属性，这意味着你甚至可以将你的样式放在一个单独的变量中。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the best way to have better control of your inline styles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制内联样式的最佳方式。
- en: Root
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根
- en: One important difference with HTML worth  mentioning  is that since JSX elements
    get translated into JavaScript functions, and you cannot return two functions
    in JavaScript, whenever you have multiple elements at the same level, you are
    forced to wrap them in a parent.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML的一个重要区别是，由于JSX元素被转换为JavaScript函数，并且在JavaScript中不能返回两个函数，所以每当您在同一级别有多个元素时，您被迫将它们包装在一个父元素中。
- en: 'Let''s look at a simple example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives us the following error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们以下错误：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, the following works:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下内容有效：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before, React forced you to return an element wrapped with an `<div>` element
    or any other tag; since React 16.2.0, it is possible to return an array directly
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，React强制你返回一个包裹在`<div>`元素或任何其他标签中的元素；自React 16.2.0以来，可以直接返回一个数组，如下所示：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or you can even  return a string directly, as shown in the following code block:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你甚至可以直接返回一个字符串，就像下面的代码块所示：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, React now has a new feature called `Fragment` that also works as a special
    wrapper for elements. It can be specified with `React.Fragment`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React现在有一个名为`Fragment`的新功能，它也可以作为元素的特殊包装器。它可以用`React.Fragment`来指定：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or you can use empty tags (`<></>`):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用空标签（`<></>`）：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Fragment` won''t render anything visible on the DOM; it is just a helper tag
    to wrap your React elements or components.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment`不会在DOM上呈现任何可见的内容；它只是一个辅助标签，用于包装您的React元素或组件。'
- en: Spaces
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空格
- en: There's one thing that could be a little bit tricky in the beginning and, again,
    it  concerns  the fact that we should always keep in mind that JSX is not HTML,
    even if it has XML-like syntax. JSX handles the spaces between text and elements
    differently from HTML, in a way that's counter-intuitive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事情可能在开始时会有点棘手，再次强调的是，我们应该始终记住JSX不是HTML，即使它具有类似XML的语法。JSX处理文本和元素之间的空格与HTML不同，这种方式是违反直觉的。
- en: 'Consider the following snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下片段：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a browser that interprets HTML, this code would give you `My name is Carlos`,
    which is exactly what we expect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释HTML的浏览器中，这段代码会给你`My name is Carlos`，这正是我们所期望的。
- en: 'In JSX, the same code would be rendered as `MynameisCarlos`, which is because
    the three nested lines get transpiled as individual children of the `div` element,
    without taking the spaces into account. A common solution to get the same output
    is putting a space explicitly between the elements, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中，相同的代码将被呈现为`MynameisCarlos`，这是因为三个嵌套的行被转译为`div`元素的单独子元素，而不考虑空格。获得相同输出的常见解决方案是在元素之间明确放置一个空格，如下所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you may have noticed, we are using an empty string wrapped inside a JavaScript
    expression to force the compiler to apply a space between the elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们正在使用一个空字符串包裹在JavaScript表达式中，以强制编译器在元素之间应用空格。
- en: Boolean attributes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔属性
- en: A couple  more  things are worth mentioning before really starting regarding
    the way you define Boolean attributes in JSX. If you set an attribute without
    a value, JSX assumes that its value is `true`, following the same behavior as
    the HTML  `disabled`  attribute, for example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正开始之前，还有一些事情值得一提，关于在JSX中定义布尔属性的方式。如果您设置一个没有值的属性，JSX会假定它的值是`true`，遵循与HTML `disabled`属性相同的行为，例如。
- en: 'This means that if we want to set an attribute to `false`, we have to declare
    it explicitly as false:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们想将属性设置为`false`，我们必须明确声明它为false：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is another example of the Boolean attribute:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个布尔属性的例子：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This can be confusing in the beginning, because we may think that omitting an
    attribute would mean `false`, but it is not like that. With React, we should always
    be explicit to avoid confusion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在开始时会让人困惑，因为我们可能会认为省略属性意味着`false`，但事实并非如此。在React中，我们应该始终明确以避免混淆。
- en: Spread attributes
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展属性
- en: An important feature is the  **spread attribute**  operator (`...`), which comes
    from the rest/spread properties for ECMAScript proposal, and is very convenient
    whenever we want to pass all the attributes of a JavaScript object to an element.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特性是**扩展属性**运算符（`...`），它来自于ECMAScript提案的rest/spread属性，非常方便，每当我们想要将JavaScript对象的所有属性传递给一个元素时。
- en: A common practice that leads to fewer bugs is not to pass entire JavaScript
    objects down to children by reference, but to use their primitive values, which
    can be easily validated, making components more robust and error-proof.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 减少错误的一种常见做法是不通过引用将整个JavaScript对象传递给子级，而是使用它们的原始值，这样可以轻松验证，使组件更健壮和防错。
- en: 'Let''s see how it works:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code gets transpiled into the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码被转译成了以下内容：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Template literals
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文字
- en: '**Templates literals** are string literals allowing embedded expressions. You
    can use multiline strings and string interpolation features with them.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板文字**是允许嵌入表达式的字符串文字。您可以使用多行字符串和字符串插值功能。'
- en: 'Template literals are enclosed by the backtick (`` ``) character instead of
    double or single quotes. Also, template literals can contain placeholders. You
    can add them using the dollar sign and curly braces (`${expression}`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文字由反引号（`` ``）字符而不是双引号或单引号括起来。此外，模板文字可以包含占位符。您可以使用美元符号和大括号（`${expression}`）添加它们：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Common patterns
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见模式
- en: Now that we know how JSX works and can master it, we are ready to see how to
    use it in the right way following some useful conventions and techniques.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了JSX的工作原理并且可以掌握它，我们准备好看看如何按照一些有用的约定和技巧正确使用它。
- en: Multiline
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多行
- en: Let's start with a very simple one. As stated previously, one of the  main  reasons
    we should prefer JSX over React's  `_jsx` function is because of its XML-like
    syntax, and because balanced opening and closing tags are perfect to represent
    a tree of nodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的开始。如前所述，我们应该更喜欢JSX而不是React的 `_jsx` 函数的一个主要原因是它的类似XML的语法，以及平衡的开放和闭合标签非常适合表示节点树。
- en: 'Therefore, we should try to use it in the right way and get the most out of
    it. One example is as follows; whenever we have nested elements, we should always
    go multiline:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，我们应该尝试以正确的方式使用它并充分利用它。一个例子如下；每当我们有嵌套元素时，我们应该总是多行： '
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is preferable to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下方式更可取：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The exception is if the children are not elements such as text or variables.
    In that case, it makes sense to remain on the same line and avoid adding noise
    to the markup, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是如果子元素不是文本或变量等元素。在这种情况下，保持在同一行并避免向标记添加噪音是有意义的，如下所示：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Always remember to wrap your elements inside parentheses when you write them
    on multiple lines. JSX always gets replaced by functions, and functions written
    on a new line can give you an unexpected result because of automatic semicolon
    insertion. Suppose, for example, that you are returning JSX from your render method,
    which is how you create UIs in React.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在多行上编写元素时，请记住始终将它们包装在括号中。JSX总是被函数替换，而在新行上编写的函数可能会因为自动分号插入而给您带来意外的结果。例如，假设您从render方法中返回JSX，这就是您在React中创建UI的方式。
- en: 'The following example works  fine  because the  `div` element is on the same
    line as the `return`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例工作正常，因为 `div` 元素与 `return` 在同一行上：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following, however, is not right:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下是不正确的：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The reason for this is that you would then have the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是您将会得到以下结果：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is why you have to wrap the statement in parentheses, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么您必须将语句包装在括号中，如下所示：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Multi-properties
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多属性
- en: A common problem in writing JSX comes  when  an element has multiples attributes.
    One solution is to write all the attributes on the same line, but this would lead
    to very long lines that we do not want in our code (see the following section
    for how to enforce coding style guides).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写JSX时常见的问题是元素具有多个属性。一种解决方法是将所有属性写在同一行上，但这会导致我们的代码中出现非常长的行（请参阅下一节了解如何强制执行编码样式指南）。
- en: 'A common solution is to write each attribute on a new line, with one level
    of indentation, and then align the closing bracket with the opening tag:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的解决方案是将每个属性写在新行上，缩进一级，然后将闭合括号与开放标签对齐：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Conditionals
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: Things get more interesting  when  we start working with  **conditionals**,
    for example, if we want to render some components only when certain conditions
    are matched. The fact that we can use JavaScript in our conditions is a big plus,
    but there are many different ways to express conditions in JSX, and it is important
    to understand the benefits and problems of each one of these to write code that
    is both readable and maintainable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用**条件语句**时，事情变得更有趣，例如，如果我们只想在某些条件匹配时渲染一些组件。我们可以在条件中使用JavaScript是一个很大的优势，但在JSX中表达条件的方式有很多不同，了解每一种方式的好处和问题对于编写既可读又易于维护的代码是很重要的。
- en: Suppose we want to show a logout button only if the user is currently logged
    in to our application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想在用户当前登录到我们的应用程序时显示一个注销按钮。
- en: 'A simple snippet to start with is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的起步代码如下：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This works, but it is not very readable, especially if there are multiple components
    and multiple conditions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是可以的，但不够易读，特别是如果有多个组件和多个条件。
- en: 'In JSX, we can use an inline condition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中，我们可以使用内联条件：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This works because if the condition is `false`, nothing gets rendered, but if
    the condition is `true`, the  `createElement`  function of `LoginButton`  gets
    called, and the element is returned to  compose  the resulting tree.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果条件是`false`，则不会渲染任何内容，但如果条件是`true`，则会调用`LoginButton`的`createElement`函数，并将元素返回以组成最终的树。
- en: 'If the condition has an alternative (the classic  `if...else`  statement) and
    we want, for example, to show a logout button if the user is logged in and a login
    button otherwise, we can use JavaScript''s  `if...else` statement as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件有一个备选项（经典的`if...else`语句），并且我们想要，例如，如果用户已登录则显示一个注销按钮，否则显示一个登录按钮，我们可以使用JavaScript的`if...else`语句如下：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Alternatively, and better still, we can use a ternary condition that makes
    the code more compact:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的方法是使用一个使代码更加紧凑的三元条件：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can find the ternary condition used in popular repositories, such as the
    Redux  real-world example ([https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28](https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28)),
    where the ternary is used to show a Loading label if the component is fetching
    the data, or Load More inside a button depending on the value of the `isFetching`
    variable:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一些流行的代码库中找到三元条件的使用，比如 Redux 的真实世界示例（[https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28](https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28)），在这里，三元条件用于在组件获取数据时显示一个“加载中”标签，或者根据`isFetching`变量的值在按钮内显示“加载更多”：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s now look at the best solution for when things get more complicated and,
    for example, we have to check more than one variable to determine whether to render
    a component or not:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当事情变得更加复杂时的最佳解决方案，例如，当我们需要检查多个变量以确定是否渲染一个组件时：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this case, it is clear that using the inline condition is a good solution,
    but the readability is strongly impacted. Instead, we can create a helper function
    inside our component and use it in JSX to verify the condition:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用内联条件是一个好的解决方案，但可读性受到了严重影响。相反，我们可以在组件内创建一个辅助函数，并在JSX中使用它来验证条件：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, this change makes the code more readable and the condition more
    explicit. If you look at this code in 6 months, you will still find it clear just
    by reading the name of the function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这种改变使得代码更易读，条件更加明确。如果你在6个月后看这段代码，仅仅通过函数名就能清楚地理解。
- en: 'The same applies to computed properties. Suppose you have two single properties
    for currency and value. Instead of creating the price string inside `render`,
    you can create a function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性也是一样。假设你有两个单一属性用于货币和价值。你可以创建一个函数来创建价格字符串，而不是在 `render` 中创建它：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is better because it is isolated and you  can  easily test it if it contains
    logic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更好，因为它是隔离的，如果包含逻辑，你可以很容易地测试它。
- en: Going back to conditional statements, other solutions require using external
    dependencies. A good practice is to avoid external dependencies as much as we
    can to keep our bundle smaller, but it may be worth it in this particular case
    because improving the readability of our templates is a big win.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回到条件语句，其他解决方案需要使用外部依赖。一个很好的做法是尽可能避免外部依赖，以使我们的捆绑包更小，但在这种特殊情况下可能是值得的，因为提高我们模板的可读性是一个很大的胜利。
- en: 'The first solution is  `render-if`, which we can install with the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案是 `render-if`，我们可以通过以下方式安装它：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can then easily use it in our projects, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在我们的项目中轻松使用它，如下所示：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we wrap our conditions inside the  `renderIf`  function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的条件包装在 `renderIf` 函数中。
- en: The utility function that gets returned can be used as a function that receives
    the JSX markup to be shown when the condition is `true`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的实用函数可以作为一个接收JSX标记的函数来使用，当条件为 `true` 时显示。
- en: One goal is to never add too much logic inside our components. Some of them
    will require a bit of it, but we should try to keep them as simple as possible
    so that we can easily spot and fix errors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个目标是永远不要在我们的组件中添加太多逻辑。其中一些组件将需要一点逻辑，但我们应该尽量保持它们尽可能简单，这样我们就可以很容易地发现和修复错误。
- en: We should at least try to keep the  `renderIf` method as clean as  possible  and
    to do that, we can use another utility library, called  `react-only-if`, which
    lets us write our components as if the condition is  always  `true` by setting
    the conditional function using a **Higher-Order Component** (**HOC**).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少应该尽量保持 `renderIf` 方法尽可能干净，为了做到这一点，我们可以使用另一个实用程序库，称为 `react-only-if`，它让我们编写我们的组件，就好像条件总是为
    `true` 一样，通过使用**高阶组件**（**HOC**）设置条件函数。
- en: We will talk about HOCs extensively in  *Chapter 4*,  *Exploring Popular Composition
    Patterns*, but for now, you just need to know that they are functions that receive
    a component and return an enhanced one by adding some properties or modifying
    their behavior.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第四章* *探索流行的组合模式* 中广泛讨论HOCs，但现在，你只需要知道它们是接收一个组件并通过添加一些属性或修改其行为来返回一个增强的组件的函数。
- en: 'To use the library, we need to install it as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该库，我们需要按照以下方式安装它：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once it is installed, we can use it in our apps in the following way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以在我们的应用程序中以以下方式使用它：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see here, there is no logic at all inside the component itself.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，组件本身没有任何逻辑。
- en: We pass the condition as the first parameter of the  `onlyIf`  function, and
    when the condition is matched, the component is rendered.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将条件作为 `onlyIf` 函数的第一个参数传递，当条件匹配时，组件被渲染。
- en: The function used to validate the condition receives the props, state, and context
    of the component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证条件的函数接收组件的props、state和context。
- en: In this way, we avoid polluting our component with conditionals so that it is
    easier to understand and reason about.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就避免了用条件语句污染我们的组件，这样更容易理解和推理。
- en: Loops
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: A very common operation in UI development is to  display  lists of items. When
    it comes to showing lists, using JavaScript as a template language is a very good
    idea.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: UI开发中一个非常常见的操作是显示项目列表。在显示列表时，使用JavaScript作为模板语言是一个非常好的主意。
- en: If we write a function that returns an array inside our JSX template, each element
    of the array gets compiled into an element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在JSX模板中编写一个返回数组的函数，数组的每个元素都会被编译成一个元素。
- en: As we have seen before, we can use any JavaScript expressions inside curly braces,
    and the most common way to generate an array of elements, given an array of objects,
    is to use  `map`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，我们可以在花括号中使用任何JavaScript表达式，给定一个对象数组，生成一个元素数组的最常见方法是使用`map`。
- en: Let's dive into a real-world example. Suppose you have a list of users, each
    one with a name property attached to it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一个真实的例子。假设你有一个用户列表，每个用户都有一个附加的名字属性。
- en: 'To create an unordered list to show the users, you can do the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个无序列表来显示用户，你可以这样做：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This snippet is incredibly simple and incredibly powerful at the same time,
    where the power of HTML and JavaScript converge.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单，同时也非常强大，HTML和JavaScript的力量在这里汇聚。
- en: Control statements
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制语句
- en: Conditionals and loops are very  common  operations in UI templates, and you
    may feel wrong using the JavaScript ternary or the `map` function to perform them.
    JSX has been built in such a way that it only abstracts the creation of the elements,
    leaving the logic parts to real JavaScript, which is great except that sometimes,
    the code becomes less clear.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 条件和循环在UI模板中是非常常见的操作，你可能觉得使用JavaScript的三元运算符或`map`函数来执行它们是错误的。JSX被构建成只抽象了元素的创建，将逻辑部分留给了真正的JavaScript，这很好，除了有时候，代码变得不够清晰。
- en: In general, we aim to remove all the logic from our components, and especially
    from our render methods, but sometimes we have to show and hide elements according
    to the state of the application, and very often we have to loop through collections
    and arrays.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们的目标是从组件中移除所有的逻辑，特别是从渲染方法中移除，但有时我们必须根据应用程序的状态显示和隐藏元素，而且我们经常必须循环遍历集合和数组。
- en: 'If you feel that using JSX for that kind of operation will make your code more
    readable, there is a Babel plugin available to do just that:  `jsx-control-statements`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得使用JSX进行这种操作会使你的代码更易读，那么有一个可用的Babel插件可以做到：`jsx-control-statements`。
- en: This follows the same philosophy as JSX, and it does not add any real functionality
    to the language; it is just syntactic sugar that gets compiled into JavaScript.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循与JSX相同的哲学，不会向语言添加任何真正的功能；它只是一种被编译成JavaScript的语法糖。
- en: Let's see how it works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。
- en: 'First of all, we have to install it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装它：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once it is installed, we have to add it to the list of our Babel plugins in
    our `.babelrc` file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们必须将它添加到我们的`.babelrc`文件中的Babel插件列表中：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: From now on, we can use the syntax provided by the plugin and Babel will transpile
    it together with the  common  JSX syntax.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以使用插件提供的语法，Babel将把它与常见的JSX语法一起转译。
- en: 'A conditional statement written using the plugin looks like the following snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该插件编写的条件语句如下所示：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This gets transpiled into a ternary expression as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这被转译成了一个三元表达式，如下所示：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `If` component is great, but if, for some reason, you have nested conditions
    in your render method, it can easily become messy and hard to follow. This is
    where the `Choose` component comes in handy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`If`组件很棒，但是如果由于某种原因，你在渲染方法中有嵌套的条件，它很容易变得混乱和难以理解。这就是`Choose`组件派上用场的地方：'
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Please note that the preceding code gets transpiled into multiple ternaries.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码被转译成了多个三元运算符。
- en: 'Finally, there is a  component  (always remember that we are not talking about
    real components but just syntactic sugar) to manage the loops that is also very
    convenient:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个组件（永远记住我们不是在谈论真正的组件，而只是语法糖）来管理循环，也非常方便：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding code gets transpiled into a `map` function – no magic there.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码被转译成了一个`map`函数 - 没有什么魔术。
- en: 'If you are used to using  **linters**, you might  wonder  why the linter is
    not complaining about that code. The `user` variable does not exist before the
    transpilation, nor is it wrapped in a function. To avoid those linting errors,
    there is another plugin to install:  `eslint-plugin-jsx-control-statements`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯使用**linters**，你可能会想知道为什么linter没有对那段代码进行投诉。在转译之前，`user`变量并不存在，也没有被包裹在一个函数中。为了避免这些linting错误，还有另一个要安装的插件：`eslint-plugin-jsx-control-statements`。
- en: If you did not understand the previous sentence, don't worry; we will talk about
    linting in the upcoming section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解上一句话，不用担心；我们将在接下来的部分讨论linting。
- en: Sub-rendering
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子渲染
- en: It is worth stressing that we always  want  to keep our components very small
    and our render methods very clean and simple.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们始终希望保持我们的组件非常小，我们的渲染方法非常干净和简单。
- en: However, that is not an easy goal, especially when you are creating an application
    iteratively, and in the first iteration, you are not sure exactly how to split
    the components into smaller ones. So, what should we be doing when the `render`
    method becomes too big to maintain? One solution is to split it into smaller functions
    in a way that lets us keep all the logic in the same component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个容易的目标，特别是当您迭代地创建一个应用程序时，在第一次迭代中，您并不确定如何将组件拆分成更小的组件。那么，当`render`方法变得太大而无法维护时，我们应该做些什么呢？一个解决方案是将其拆分成更小的函数，以便让我们将所有逻辑保留在同一个组件中。
- en: 'Let''s look at an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is not always considered best practice because it seems more obvious to
    split the component into smaller ones. However, sometimes it helps to keep the
    render  method  cleaner. For example, in the Redux real-world examples, a sub-render
    method is used to render the *load more* button.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是被认为是最佳实践，因为将组件拆分成更小的组件似乎更明显。然而，有时候这有助于保持渲染方法的清晰。例如，在Redux的真实示例中，使用子渲染方法来渲染*load
    more*按钮。
- en: Now that we are JSX power users, it is time to move on and see how to follow
    a style guide within our code to make it consistent.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们是JSX的高级用户，现在是时候继续前进，看看如何在我们的代码中遵循样式指南，使其保持一致。
- en: Styling code
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码样式
- en: In this section, you will learn how to implement EditorConfig and ESLint to
    improve your code quality by validating your code style. It is important to have
    a standard  code style in your team and avoid using different code styles.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何实现EditorConfig和ESLint，通过验证您的代码风格来提高代码质量。在团队中拥有标准的代码风格并避免使用不同的代码风格是很重要的。
- en: EditorConfig
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditorConfig
- en: '**EditorConfig** helps developers to maintain consistent coding styles between
    different IDEs.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorConfig**帮助开发人员在不同的IDE之间保持一致的编码风格。'
- en: EditorConfig is supported by a lot of editors. You can check whether your editor
    is supported or not on the official website, [https://www.editorconfig.org](https://www.editorconfig.org).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: EditorConfig受许多编辑器支持。您可以在官方网站[https://www.editorconfig.org](https://www.editorconfig.org)上检查您的编辑器是否受支持。
- en: 'You need to create a file called `.editorconfig` in your `root` directory –
    the configuration I use is this one:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的`root`目录中创建一个名为`.editorconfig`的文件 - 我使用的配置是这样的：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can affect all the files with `[*]`, and specific files with `[.extension]`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以影响所有文件`[*]`，以及特定文件`[.extension]`。
- en: Prettier
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prettier
- en: '**Prettier** is an opinionated code formatter, supported by many languages
    that can be integrated with most editors. This plugin is really useful because
    you can format the code on saving and you don''t need to discuss the code style
    in code reviews, which will save you a lot of time and energy.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prettier**是一种主观的代码格式化工具，支持许多语言，并可以集成到大多数编辑器中。这个插件非常有用，因为您可以在保存代码时格式化代码，而无需在代码审查中讨论代码风格，这将节省您大量的时间和精力。'
- en: 'If you work with Visual Studio Code, you have to install the Prettier extension
    first:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Visual Studio Code，首先必须安装Prettier扩展：
- en: '![](assets/7a10a5dd-0c4b-43fc-837d-f95b014dd3c4.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a10a5dd-0c4b-43fc-837d-f95b014dd3c4.png)'
- en: 'Then, if you want to configure the option to format when you save a file, you
    need to go to Settings, search `Format on Save`, and check that option:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您想配置选项以在保存文件时进行格式化，您需要转到设置，搜索`Format on Save`，并检查该选项：
- en: '![](assets/f1a9fade-d007-40df-a295-54f736f126d2.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f1a9fade-d007-40df-a295-54f736f126d2.png)'
- en: 'This will affect all your projects because it is a global setting. If you want
    to apply this option just in a specific project, you have to create a `.vscode`
    folder inside your project and a `settings.json` file with the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将影响您所有的项目，因为这是一个全局设置。如果您只想在特定项目中应用此选项，您需要在项目内创建一个`.vscode`文件夹和一个带有以下代码的`settings.json`文件：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then you can configure the options you want in your `.prettierrc` file – this
    is the configuration I normally use:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在`.prettierrc`文件中配置您想要的选项-这是我通常使用的配置：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This will help you or your team to standardize the code style.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您或您的团队标准化代码风格。
- en: ESLint
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESLint
- en: We always try to write the  best  code possible, but sometimes errors happen,
    and spending a few hours catching a bug due to a typo is very frustrating. Luckily,
    some tools can help us check the correctness of our code as soon as we type it.
    These tools are not able to tell us whether our code is going to do what it's
    supposed to do, but they can help us to avoid syntactical errors.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是尽量写出最好的代码，但有时会出现错误，花几个小时捕捉由于拼写错误而导致的错误非常令人沮丧。幸运的是，一些工具可以帮助我们在输入代码时检查代码的正确性。这些工具无法告诉我们我们的代码是否会按预期运行，但它们可以帮助我们避免语法错误。
- en: If you come from a static language, such as C#, you are used to getting that
    kind of warning inside your IDE. Douglas Crockford  made linting popular in JavaScript
    with JSLint (initially released in 2002) a few years ago; then we had JSHint,
    and finally, the de facto standard in the React world nowadays is  ESLint.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自静态语言，比如C#，您习惯于在IDE中获得这种警告。几年前，Douglas Crockford在JavaScript中使用JSLint（最初于2002年发布）使linting变得流行；然后我们有了JSHint，最后，现在在React世界中的事实标准是ESLint。
- en: '**ESLint** is an open-source project released in 2013 that became popular thanks
    to the fact that it is highly configurable and extensible.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESLint**是一个于2013年发布的开源项目，因为它高度可配置和可扩展而变得流行。'
- en: In the JavaScript ecosystem, where libraries and techniques change very quickly,
    it is crucial to have a tool that can be easily extended with plugins, and rules
    that can be enabled and disabled when needed. Most importantly, nowadays we use
    transpilers, such as Babel, and experimental features that are not part of the
    standard version of JavaScript, so we need to be able to tell our linter which
    rules we are following in our source files. Not only does a linter help us to
    make fewer errors, or at least find those errors sooner, but it enforces some
    common coding style guides, which is important especially in big teams with many
    developers, each one with their favorite coding style.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript生态系统中，库和技术变化非常快，拥有一个可以轻松通过插件进行扩展的工具以及可以在需要时启用和禁用规则是至关重要的。最重要的是，现在我们使用转译器，比如Babel，以及不属于JavaScript标准版本的实验性功能，因此我们需要能够告诉我们的代码检查工具我们在源文件中遵循哪些规则。代码检查工具不仅帮助我们减少错误，或者至少更早地发现这些错误，而且强制执行一些常见的编码风格指南，这在拥有许多开发人员的大团队中尤为重要，每个开发人员都有自己喜欢的编码风格。
- en: It is very hard to read the code in a code base where different files, or even
    various functions, are written using inconsistent styles. For that reason, let's
    look at ESLint in more detail.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用不一致的风格编写不同文件甚至不同函数的代码库中，很难阅读代码。因此，让我们更详细地了解一下ESLint。
- en: Installation
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'First of all, we have to install ESLint and some plugins as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装ESLint和一些插件，如下所示：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the executable is installed, we can run it with the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦可执行文件安装完成，我们可以使用以下命令运行它：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The output will tell us if there are errors within the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会告诉我们文件中是否有错误。
- en: When we install and run it for the first time, we do not see any errors because
    it is completely configurable and it does not come with any default rules.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次安装和运行它时，我们不会看到任何错误，因为它是完全可配置的，不带有任何默认规则。
- en: Configuration
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'Let''s start configuring ESLint. It can be configured using a  `.eslintrc`  file
    that  lives  in the root folder of the project. To add some rules, let''s create
    a  `.eslintrc` file configured for TypeScript and add one basic rule:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始配置ESLint。可以使用项目根目录中的`.eslintrc`文件进行配置。要添加一些规则，让我们创建一个为TypeScript配置的`.eslintrc`文件并添加一个基本规则：
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This configuration file needs a bit of explanation:  `"semi"`  is the name
    of the rule and  `[2, "never"]`  is the value. It is not very intuitive the first
    time you see it.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件需要一点解释：“semi”是规则的名称，“[2，“never”]”是值。第一次看到它时并不是很直观。
- en: 'ESLint rules have three levels that determine the severity of the problem:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint规则有三个级别，确定问题的严重程度：
- en: '`off` (or `0`): The rule is disabled.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭（或0）：规则被禁用。
- en: '`warn` (or `1`): The rule is a warning.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告（或1）：规则是一个警告。
- en: '`error` (or `2`): The rule throws an error.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误（或2）：规则会抛出错误。
- en: We are using the `2` value because we want ESLint to throw an error every time
    our code does not follow the rule. The second parameter tells ESLint that we want
    the semicolon to never be used (the opposite is  *always).* ESLint and its plugins
    are very well documented, and for any single rule, you can find the description
    of the rule and some examples of when it passes and when it fails.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用值为2是因为我们希望ESLint在我们的代码不遵循规则时抛出错误。第二个参数告诉ESLint我们不希望使用分号（相反的是*always*）。ESLint及其插件都有非常好的文档，对于任何单个规则，您都可以找到规则的描述以及一些示例，说明何时通过何时失败。
- en: 'Now create an `index.ts` file with the following content:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`index.ts`的文件，内容如下：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we run  `eslint index.js`, we get the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行“eslint index.js”，我们会得到以下结果：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is great; we set up the linter and it is helping us follow our first rule.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒；我们设置了代码检查工具，它帮助我们遵循第一个规则。
- en: 'Here are other rules that I prefer to turn off or change:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我喜欢关闭或更改的其他规则：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Git Hooks
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git钩子
- en: To avoid having  unlinted  code in our repository, what we can do is add ESLint
    at one point of our process using Git Hooks. For example, we can use `husky` to
    run our linter in a Git Hook called `pre-commit`, and it is also useful to run
    our unit tests on the Hook called `pre-push`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在我们的存储库中有未经过lint处理的代码，我们可以在我们的过程的某个时候使用Git钩子添加ESLint。例如，我们可以使用`husky`在名为`pre-commit`的Git钩子中运行我们的linter，还可以在名为`pre-push`的钩子上运行我们的单元测试。
- en: 'To install `husky`, you need to run the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`husky`，您需要运行以下命令：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, in our `package.json` file, we can add this node to configure the tasks
    we want to run in the Git Hooks:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`package.json`文件中，我们可以添加这个节点来配置我们想要在Git钩子中运行的任务：
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There is a special option (flag) for the ESlint command called `--fix` – with
    this option, ESLint will try to fix all our linter errors automatically (not all
    of them). Be careful with this option because sometimes it can affect a little
    bit of our code style. Another useful flag is `--ext` to specify the extensions
    of the files we want to validate, in this case just the `.tsx` and `.ts` files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ESlint命令有一个特殊的选项（标志）叫做`--fix` - 使用这个选项，ESlint将尝试自动修复所有我们的linter错误（不是所有）。请注意这个选项，因为有时它可能会影响我们的代码风格。另一个有用的标志是`--ext`，用于指定我们想要验证的文件的扩展名，在这种情况下只有`.tsx`和`.ts`文件。
- en: In the next section, you will learn about how **Functional Programming** (**FP**)
    works and topics such as first-class objects, purity, immutability, currying,
    and composition.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解**函数式编程**（**FP**）的工作原理以及一级对象、纯度、不可变性、柯里化和组合等主题。
- en: Functional programming
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'Apart from following the best practices when we write JSX  and  using a linter
    to enforce consistency and find errors earlier, there is one more thing we can
    do to clean up our code: follow an FP style.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在编写JSX时遵循最佳实践并使用linter来强制一致性并更早地发现错误之外，我们还可以做一件事来清理我们的代码：遵循FP风格。
- en: As discussed in *Chapter 1*, *Taking Your First Steps with React*, React has
    a declarative programming approach that makes our code more readable. FP is a
    declarative paradigm, where side effects are avoided and data is considered immutable
    to make the code easier to maintain and reason about.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第1章*中所讨论的，React采用了一种声明式的编程方法，使我们的代码更易读。FP是一种声明式的范式，其中避免副作用，并且数据被视为不可变，以使代码更易于维护和理解。
- en: Don't consider the following sub-sections as an exhaustive guide to FP; it is
    only an introduction to get started with some concepts that are commonly used
    in React of which you should be aware.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将以下子部分视为FP的详尽指南；这只是一个介绍，让您了解React中常用的一些概念。
- en: '**First-class functions**'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**一级函数**'
- en: JavaScript has first-class functions because they are treated like any other
    variable, meaning you can pass a function as a parameter to other functions, or
    it can be returned by another function and be assigned as a value to a variable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有一级函数，因为它们被视为任何其他变量，这意味着您可以将函数作为参数传递给其他函数，或者它可以被另一个函数返回并分配为变量的值。
- en: This allows us to introduce the concept of  **Higher-Order Functions** (**HoFs**).
    HoFs are functions that take a function as a parameter, and optionally some other
    parameters, and  return  a function. The returned function is usually enhanced
    with some special behaviors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够介绍**高阶函数**（**HoFs**）的概念。 HoFs是接受函数作为参数的函数，并且可能还有一些其他参数，并返回一个函数。返回的函数通常具有一些特殊的行为。
- en: 'Let''s look at an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, a function is adding two numbers that enhance a function that logs all
    the parameters and then executes the original function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个函数正在添加两个数字，增强一个记录所有参数然后执行原始函数的函数。
- en: This concept is pretty important to understand because in the React world, a
    common pattern is to use HOCs to treat our components as functions, and to enhance
    them with common behaviors. We will see HOCs and other patterns in *Chapter 4*,
    *Exploring Popular Composition Patterns*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个概念非常重要，因为在React世界中，一个常见的模式是使用HOCs将我们的组件视为函数，并用常见的行为增强它们。我们将在*第4章*，*探索流行的组合模式*中看到HOCs和其他模式。
- en: Purity
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯度
- en: An important aspect of FP is to write pure functions. You  will  encounter this
    concept very often in the React ecosystem, especially if you look into libraries
    such as Redux.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: FP的一个重要方面是编写纯函数。在React生态系统中，您会经常遇到这个概念，特别是如果您研究Redux等库。
- en: What does it mean for a function to be pure?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数纯是什么意思？
- en: A function is pure when there are no side effects, which means that the function
    does not change anything that is not local to the function itself.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数没有副作用时，函数就是纯的，这意味着函数不会改变任何不属于函数本身的东西。
- en: For example, a function that changes the state of an application, or modifies
    variables defined in the upper scope, or a function that touches external entities,
    such as the **Document Object Model** (**DOM**), is considered impure. Impure
    functions are harder to debug, and most of the time it is not possible to apply
    them multiple times and expect to get the same result.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个改变应用程序状态的函数，或者修改在上层作用域中定义的变量的函数，或者触及外部实体，比如**文档对象模型**（**DOM**）的函数被认为是不纯的。不纯的函数更难调试，大多数情况下不可能多次应用它们并期望得到相同的结果。
- en: 'For example, the following function is pure:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数是纯的：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It can be run multiple times, always getting the same result, because nothing
    is stored anywhere and nothing gets modified.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以多次运行，始终得到相同的结果，因为没有任何东西被存储，也没有任何东西被修改。
- en: 'The following function is not pure:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数不是纯的：
- en: '[PRE74]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Running `add(1)` twice, we get two different results. The first time we get
    `1`, but the second time we get `2`, even if we call the same function with the
    same parameter. The reason we get that behavior is that the global state gets
    modified after every execution.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`add(1)`两次，我们得到两个不同的结果。第一次得到`1`，但第二次得到`2`，即使我们用相同的参数调用相同的函数。我们得到这种行为的原因是全局状态在每次执行后都被修改。
- en: Immutability
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: We have seen how to write pure functions that don't  mutate  the state, but
    what if we need to change the value of a variable? In FP, a function, instead
    of changing the value of a variable, creates a new  variable  with a new value
    and returns it. This way of working with data is called  **immutability**.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何编写不改变状态的纯函数，但是如果我们需要改变变量的值怎么办？在FP中，一个函数不是改变变量的值，而是创建一个新的带有新值的变量并返回它。这种处理数据的方式被称为**不可变性**。
- en: An immutable value is a value that cannot be changed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变值是一个不能被改变的值。
- en: 'Let''s look at an example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding function doesn't follow immutability because it changes the value
    of the given array. Again, if we call the same function twice, we get different
    results.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数不遵循不可变性，因为它改变了给定数组的值。同样，如果我们两次调用相同的函数，我们会得到不同的结果。
- en: 'We can change the preceding function to make it immutable using  `concat`,
    which returns a new array without modifying the given one:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变前面的函数，使用`concat`使其不可变，返回一个新的数组而不修改给定的数组：
- en: '[PRE76]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: After we have run the function twice, `myArr` still has its original value.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行函数两次后，`myArr`仍然保持其原始值。
- en: Currying
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: A common technique in FP is  currying.  **Currying**  is the  process  of converting
    a function that takes multiple arguments into a function one argument at a time
    and returning  another  function. Let's look at an example to clarify the concept.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: FP中的一个常见技术是柯里化。**柯里化**是将接受多个参数的函数转换为一次接受一个参数并返回另一个函数的过程。让我们看一个例子来澄清这个概念。
- en: Let's start with the  `add`  function we have seen before and transform it into
    a curried function.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前看到的 `add` 函数开始，并将其转换为柯里化函数。
- en: 'Say we have the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下代码：
- en: '[PRE77]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can instead define the function as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改为以下方式定义函数：
- en: '[PRE78]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We use it in the following way:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式使用它：
- en: '[PRE79]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This is a pretty convenient way of writing functions because, since the first
    value is stored after the application of the first parameter, we can reuse the
    second function multiple times.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编写函数的一种非常方便的方式，因为在应用第一个参数后，第一个值被存储，我们可以多次重复使用第二个函数。
- en: Composition
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: Finally, an important concept in FP that  can  be applied to React is **composition**.
    Functions (and components) can be combined to produce new functions with more
    advanced features and properties.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，FP中一个重要的概念可以应用到React中，那就是**组合**。函数（和组件）可以组合在一起，产生具有更高级功能和属性的新函数。
- en: 'Consider the following functions:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数：
- en: '[PRE80]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'These functions can be composed together to create a new function that adds
    two numbers and then doubles the result:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以组合在一起创建一个新的函数，该函数将两个数字相加，然后将结果加倍：
- en: '[PRE81]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Following this paradigm, we end up with small, simple, testable pure functions
    that can be composed together.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这个范式，我们最终得到了小型、简单、可测试的纯函数，可以组合在一起。
- en: FP and UIs
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP和UI
- en: The last step is to learn how we  can  use FP to build UIs, which is what we
    use React for.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是学习如何使用FP来构建UI，这正是我们使用React的目的。
- en: 'We  can  think about a UI as a function to which the state of the application
    is applied as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将UI视为一个函数，将应用程序的状态应用如下：
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We expect this function to be idempotent so that it returns the same UI given
    the same state of the application.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这个函数是幂等的，这样它在应用程序的相同状态下返回相同的UI。
- en: Using React, we create our  UIs  using components we  can  consider functions,
    as we will see in the following chapters.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React，我们使用组件来创建我们的UI，我们可以将其视为函数，正如我们将在接下来的章节中看到的。
- en: Components  can  be composed to form the final UI, which is a property of FP.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以组合在一起形成最终的UI，这是FP的一个特性。
- en: There are a lot of similarities in the way we build UIs with React and the principles
    of FP, and the more we are aware of it, the better our code will be.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React构建UI的方式和FP的原则中有很多相似之处，我们越了解，我们的代码就会越好。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned a great deal about how JSX works and how to use
    it in the right way in our components. We started from the basics of the syntax
    to create a solid knowledge base that will enable us to master JSX and its features.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了关于JSX的工作原理以及如何在组件中正确使用它的很多知识。我们从语法的基础开始，创建了一个坚实的知识基础，使我们能够掌握JSX及其特性。
- en: In the second part, we looked at how to configure Prettier and how ESLint and
    its plugins can help us find problems faster and enforce a consistent style guide
    across our code base.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们看了如何配置Prettier以及ESLint及其插件如何帮助我们更快地发现问题，并强制执行一致的代码风格指南。
- en: Finally, we went through the basics of FP to understand the important concepts
    to use when writing a React application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过FP的基础知识来理解在编写React应用程序时使用的重要概念。
- en: Now that our code is clean, we are ready to start digging deeper into React
    and learn how to write truly reusable components in the next chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码已经整洁，我们准备在下一章深入学习React，并学习如何编写真正可重用的组件。
