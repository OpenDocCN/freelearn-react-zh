- en: Optimizing Test-Driven React Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化测试驱动的React开发
- en: 'Perhaps, one of the most important tools in the React ecosystem is Jest—a test
    runner and unit test library for testing your React components. Jest was designed
    to overcome challenges faced with other test frameworks like Jasmine, and was
    created with React development in mind. With powerful testing tools like Jest,
    you''re better equipped to let your unit tests influence the design of your React
    components. In this chapter, you''ll learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，React生态系统中最重要的工具之一是Jest——用于测试React组件的测试运行器和单元测试库。Jest旨在克服其他测试框架（如Jasmine）面临的挑战，并且是针对React开发而创建的。有了像Jest这样强大的测试工具，您更有能力让您的单元测试影响React组件的设计。在本章中，您将学到：
- en: The overarching design philosophy of Jest and what this means for React developers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest的总体设计理念及其对React开发者的意义
- en: Running Jest unit tests in a `create-react-app` environment and in a standalone
    React environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`create-react-app`环境和独立的React环境中运行Jest单元测试
- en: Writing effective unit tests and suites using the Jest API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest API编写有效的单元测试和测试套件
- en: Running Jest unit tests in your code editor and integrating tests into your
    development server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中运行Jest单元测试并将测试集成到您的开发服务器中
- en: The driving philosophy of Jest
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jest的驱动理念
- en: In the previous chapter, you learned that the `create-react-app` tool was created
    to make developing React applications easier. It does so by eliminating upfront
    configuration—you go straight to building components. Jest was created with the
    same purpose in mind, eliminating the upfront boilerplate that you would typically
    have to create just to start writing tests. In addition to removing the initial
    unit test configuration factor, Jest has some other tricks up its sleeve. Let's
    go over some of the driving principles of testing with Jest.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解到`create-react-app`工具是为了使开发React应用程序更容易而创建的。它通过消除前期配置来实现这一目的——您直接开始构建组件。Jest也是出于同样的目的而创建的，它消除了您通常需要创建的前期样板，以便开始编写测试。除了消除初始单元测试配置因素之外，Jest还有一些其他技巧。让我们来看看使用Jest进行测试的一些驱动原则。
- en: Mock everything except the application code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟除应用程序代码之外的所有内容
- en: 'The last thing you want to spend time on is testing someone else''s code. Yet,
    sometimes you''re forced to do exactly that. For example, let''s say that you
    want to test a function that makes a `fetch()` call to some HTTP API. Another
    example: your React component uses some library to help set and manipulate its
    state.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你最不想花时间测试别人的代码。然而，有时你被迫这样做。例如，假设您想测试一个调用某个HTTP API的`fetch()`函数。另一个例子：您的React组件使用某个库来帮助设置和操作其状态。
- en: In both of these examples, there's code that you didn't implement that's being
    run when your unit tests run. You definitely don't want to reach out to an external
    system over HTTP. You definitely don't want to make sure that the state of your
    component is being set correctly based on the output of functions from another
    library. For the code that we don't want to test, Jest provides a powerful mock
    system. But you need to draw a line somewhere—you can't mock every little thing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，有一些您没有实现的代码在运行您的单元测试时被执行。您绝对不希望通过HTTP与外部系统联系。您绝对不希望确保您的组件状态是根据另一个库的函数输出正确设置的。对于我们不想测试的代码，Jest提供了一个强大的模拟系统。但是您需要在某个地方划清界限——您不能模拟每一个小事物。
- en: 'Here''s an illustration of a component and its dependencies:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个组件及其依赖项的示例：
- en: '![](Images/409c52f1-1a46-4eae-a4d0-0c6cc1957722.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/409c52f1-1a46-4eae-a4d0-0c6cc1957722.png)'
- en: There are three libraries that this component requires in order to function.
    You probably don't want to unit test this component as is, because you would also
    be testing the functionality of three other libraries. The libraries that you
    don't want to run during unit testing can be mocked using Jest. You don't have
    to mock every library, and for some, mocking them may be more trouble than they're
    worth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件需要三个库才能正常运行。你可能不想按原样对这个组件进行单元测试，因为这样你也会测试其他三个库的功能。你不想在单元测试期间运行的库可以使用Jest进行模拟。你不必对每个库进行模拟，对一些库来说，模拟它们可能会带来更多麻烦。
- en: 'For example, let''s say that **Lib C** in this scenario is a date library.
    Do you really need to mock it, or could you actually use the values it produces
    in component tests? A date library is pretty low level, so it''s probably stable
    and it probably poses very little risk to the functioning of your unit test. On
    the other hand, the higher the level of the library and the more work that it
    does, the more problematic it is for your unit tests. Let''s take a look at how
    this looks if you decided to use Jest to mock **Lib A** and **Lib B**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设在这种情况下**Lib C**是一个日期库。你真的需要对它进行模拟吗，还是你实际上可以在组件测试中使用它产生的值？日期库是相当低级的，所以它可能是稳定的，对你的单元测试的功能可能造成非常小的风险。另一方面，库的级别越高，它所做的工作越多，对你的单元测试就越有问题。让我们看看如果你决定使用Jest来模拟**Lib
    A**和**Lib B**会是什么样子：
- en: '![](Images/0b3ee051-6f68-4083-8f0e-8f8f1952a0f3.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0b3ee051-6f68-4083-8f0e-8f8f1952a0f3.png)'
- en: If you tell Jest that you want to mock implementations of **Lib A** and **Lib
    B**, it can use the actual modules and automatically create an object that your
    tests can use. So, with very little effort on your part, you can mock dependencies
    that pose challenges to testing your code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你告诉Jest你想要模拟**Lib A**和**Lib B**的实现，它可以使用实际的模块并自动创建一个对象供你的测试使用。因此，几乎不费吹灰之力，你就可以模拟那些对测试你的代码构成挑战的依赖关系。
- en: Isolate tests and run in parallel
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离测试并并行运行
- en: Jest makes it easy to isolate your unit tests in a sandboxed environment. In
    other words, side-effects from running one test cannot impact the results of other
    tests. Each time a test run completes, the global environment is automatically
    reset for the next. Since tests are standalone and their execution order doesn't
    matter, Jest runs tests in parallel. This means that even if you have hundreds
    of unit tests you can run them frequently without the fear of having to wait.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jest使得在一个沙盒环境中隔离你的单元测试变得容易。换句话说，运行一个测试的副作用不能影响其他测试的结果。每次测试运行完成后，全局环境会自动重置为下一个测试。由于测试是独立的，它们的执行顺序并不重要，Jest会并行运行测试。这意味着即使你有数百个单元测试，你也可以频繁地运行它们，而不必担心等待的问题。
- en: 'Here''s an illustration of how Jest runs tests in parallel, in their own isolated
    environment:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Jest如何在它们自己的隔离环境中并行运行测试的示例：
- en: '![](Images/fe1e3a8d-c7d8-499f-b765-972d6212107a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fe1e3a8d-c7d8-499f-b765-972d6212107a.png)'
- en: The best part is that Jest handles scaling processes up for you. For example,
    if you're just starting out and your project only has a handful of unit tests,
    Jest isn't going to spawn, for example, eight parallel processes. It will just
    run them in a single process. The key thing for you to remember is that unit tests
    are their own universe with no interference from other universes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是Jest会为你处理扩展进程的问题。例如，如果你刚刚开始，你的项目只有少数几个单元测试，Jest不会生成八个并行进程。它只会在一个进程中运行它们。你需要记住的关键是，单元测试是它们自己的宇宙，不受其他宇宙的干扰。
- en: Tests should feel natural
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应该感觉自然
- en: Jest makes it easy to get started with running your tests, but what about writing
    tests? The API exposed by Jest makes it easy to write tests that don't have a
    lot of moving parts. The API documentation ([https://facebook.github.io/jest/docs/en/api.html](https://facebook.github.io/jest/docs/en/api.html))
    is organized into sections that make it easy to find what you need. For example,
    if you're writing a test and you need to validate an expectation, you can find
    the functions that you need in the *Expect* section of the API docs. Or, you might
    need help configuring a mock function—the *Mock Functions* section of the API
    docs has everything you need on this topic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Jest让你很容易开始运行你的测试，但是写测试呢？Jest提供的API使得编写没有太多复杂部分的测试变得容易。API文档（[https://facebook.github.io/jest/docs/en/api.html](https://facebook.github.io/jest/docs/en/api.html)）被组织成易于查找所需内容的部分。例如，如果你正在编写一个测试并且需要验证一个期望值，你可以在API文档的*Expect*部分找到你需要的函数。或者，你可能需要帮助配置一个模拟函数——API文档的*Mock
    Functions*部分包含了你在这个主题上需要的一切。
- en: Another area where Jest really stands out is when you need to test asynchronous
    code. This typically involves working with promises. The Jest API makes it easy
    to expect specific values from resolved or rejected promises without having to
    write a ton of async boilerplate. It's the little things like this that make writing
    unit tests for Jest feel like a natural extension of the actual application code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Jest真正脱颖而出的另一个领域是当你需要测试异步代码时。这通常涉及使用promise。Jest API使得在不必写大量异步样板的情况下，轻松期望解析或拒绝的promise返回特定值变得容易。正是这些小细节使得为Jest编写单元测试感觉像是实际应用代码的自然延伸。
- en: Running tests
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: The Jest command-line tools are all you need to run your unit tests. There are
    a number of ways that the tool can be used. First, you'll learn how to invoke
    the test runner from a `create-react-app` environment and how to use the interactive
    watch mode options. Then, you'll learn how to run Jest in a standalone environment
    without the help of `create-react-app`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Jest命令行工具是运行单元测试所需的全部。工具有多种使用方式。首先，你将学习如何在`create-react-app`环境中调用测试运行器以及如何使用交互式观察模式选项。然后，你将学习如何在没有`create-react-app`帮助的情况下在独立环境中运行Jest。
- en: Running tests using react-scripts
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-scripts运行测试
- en: When you create your React application using `create-react-app`, you're ready
    to run tests right away. In fact, as part of the boilerplate code that's created
    for you, a unit test for the `App` component is created. This test is added so
    that Jest will find a test that it can run. It doesn't actually test anything
    meaningful in your application, so you'll probably delete it once more tests are
    added.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`create-react-app`创建你的React应用时，你可以立即运行测试。实际上，在为你创建的样板代码中，已经为`App`组件创建了一个单元测试。这个测试被添加以便Jest能够找到一个可以运行的测试。它实际上并没有测试你的应用中的任何有意义的东西，所以一旦添加更多测试，你可能会删除它。
- en: 'Additionally, `create-react-app` adds the appropriate script to your `package.json`
    file to run your tests. You can just run the following command in your Terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`create-react-app`会在你的`package.json`文件中添加适当的脚本来运行你的测试。你可以在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will actually invoke the `test` script from `react-scripts`. This will
    invoke Jest, which runs any tests that it finds. In this case, since you''re working
    with a fresh project, it will only find the one test that `create-react-app` creates.
    Here''s what the output of running this test looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会调用`react-scripts`中的`test`脚本。这将调用Jest，运行它找到的任何测试。在这种情况下，因为你正在使用一个新项目，它只会找到`create-react-app`创建的一个测试。运行这个测试的输出如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The test that was run lives in the `App.test.js` module—all Jest tests should
    have `test` somewhere in their filename. A good convention to follow is `ComponentName.test.js`.
    Then, you can see a list of tests that were run in this module, how long they
    took, and whether they passed or failed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的测试位于`App.test.js`模块中——所有的Jest测试文件名中都应该包含`test`。一个好的约定是`ComponentName.test.js`。然后，你可以看到在这个模块中运行的测试列表，它们花费了多长时间，以及它们是否通过或失败。
- en: At the bottom, Jest prints out summary information of the run. This is often
    a good starting point because if all your tests are passing, you might not care
    about any other output. On the other hand when a test fails, the more information,
    the better.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，Jest打印出了运行的摘要信息。这通常是一个很好的起点，因为如果你的所有测试都通过了，你可能不会关心任何其他输出。另一方面，当一个测试失败时，信息越多越好。
- en: 'The `test` script from `react-scripts` invokes Jest in watch mode. This means
    that you can choose which tests are actually run when files are changed. Here''s
    what the menu looks like on the command line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-scripts`中的`test`脚本以观察模式调用Jest。这意味着当文件发生更改时，你可以选择实际运行哪些测试。在命令行中，菜单看起来像这样：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When Jest is running in watch mode, the process doesn't exit as soon as all
    tests complete. Instead, it watches your test and component files for changes
    and runs tests when changes are detected. These options allow you to fine-tune
    which tests are run when changes take place. The `p` and `t` options are only
    useful if you have thousands of tests and many of them are failing. These options
    are useful to drill down and find the offending component as it's developed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jest以观察模式运行时，进程不会在所有测试完成后立即退出。相反，它会监视你的测试和组件文件的更改，并在检测到更改时运行测试。这些选项允许你在发生更改时微调运行哪些测试。`p`和`t`选项只有在你有成千上万个测试并且其中许多测试失败时才有用。这些选项对于深入了解并找到正在开发的有问题的组件非常有用。
- en: 'By default, when a change is detected by Jest, only associated tests are run.
    For example, changing the test or the component will result in the test being
    run again. With `npm test` running in your Terminal, let''s open up `App.test.js`
    and make a small change to the test:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当Jest检测到更改时，只有相关的测试会被运行。例如，更改测试或组件将导致测试再次运行。在你的终端中运行`npm test`，让我们打开`App.test.js`并对测试进行小小的更改：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can just change the name of the test so that it looks like the following,
    and then save the file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以只需更改测试的名称，使其看起来像下面这样，然后保存文件：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, take a look at your Terminal where you left Jest running in watch mode:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下你的终端，你在那里让Jest以观察模式运行：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Jest detected the change in your unit test and ran it, producing the updated
    console output. Now let''s introduce a new component and a new test and see what
    happens. First, you''ll implement a `Repeat` component that looks like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Jest检测到了你的单元测试的更改，并运行它，生成了更新的控制台输出。现在让我们引入一个新的组件和一个新的测试，看看会发生什么。首先，你将实现一个`Repeat`组件，看起来像下面这样：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This component takes a `times` property, which is used to determine how many
    times to repeat the `value` property. Here''s how the `Repeat` component is used
    by the `App` component:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件接受一个`times`属性，用于确定重复`value`属性的次数。下面是`Repeat`组件被`App`组件使用的方式：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you were to view this application, you would see the string `React!` rendered
    five times on the page. Your component works as expected, but let''s make sure
    that we add a unit test before committing your new component. Create a `Repeat.test.js`
    file that looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个应用程序，你会在页面上看到字符串`React!`被渲染了五次。你的组件按预期工作，但在提交新组件之前，让我们确保添加一个单元测试。创建一个名为`Repeat.test.js`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is actually the same unit test used for the `App` component. It doesn''t
    test much other than that the component can render without triggering some sort
    of error. Now Jest has two component tests to run: one for `App` and the other
    one for `Repeat`. If you look at the console output for Jest, you''ll see that
    both tests are run:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是用于`App`组件的相同单元测试。它除了组件可以渲染而不触发某种错误之外，没有太多测试内容。现在Jest有两个组件测试要运行：一个是`App`，另一个是`Repeat`。如果你查看Jest的控制台输出，你会看到两个测试都被运行了：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pay attention to the last line in this output. The default watch mode of Jest
    is to look for files that haven''t been committed to source control and that have
    been saved. By ignoring components and tests that have been committed, you know
    that they haven''t changed, so running those tests would be pointless. Let''s
    try changing the `Repeat` component and see what happens (you don''t actually
    have to change anything, just saving the file is enough to trigger Jest):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中的最后一行。Jest的默认监视模式是查找尚未提交到源代码控制的文件，并已保存的文件。通过忽略已提交的组件和测试，你知道它们没有改变，因此运行这些测试是没有意义的。让我们尝试更改`Repeat`组件，看看会发生什么（实际上你不需要更改任何内容，只需保存文件就足以触发Jest）：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Why is the `App` test running? It's committed and hasn't been changed. The issue
    is that since `App` depends on `Repeat`, changes to the `Repeat` component could
    cause `App` tests to fail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`App`测试会运行？它已经提交并且没有改变。问题在于，由于`App`依赖于`Repeat`，对`Repeat`组件的更改可能会导致`App`测试失败。
- en: 'Let''s introduce another component and test, except that this time we won''t
    introduce any dependencies importing the new component. Create a `Text.js` file
    and save it with the following component implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入另一个组件和测试，不过这次我们不会引入任何依赖导入新组件。创建一个`Text.js`文件，并保存以下组件实现：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This `Text` component will just render whatever child element or text that
    is passed to it. It''s a contrived component, but that doesn''t matter. Now let''s
    write a test that will verify that the component returns the value as expected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Text`组件只会渲染传递给它的任何子元素或文本。这是一个人为的组件，但这并不重要。现在让我们编写一个测试，验证组件返回预期的值：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `toEqual()` assertion passes when the value returned by `Text()` is equal
    to the `children` value. When you save this test, take a look at the Jest console
    output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEqual()`断言在`Text()`返回的值等于`children`值时通过。当你保存这个测试时，看一下Jest控制台输出：'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that you have a test that doesn't have any dependencies, Jest will run it
    on its own. The other two tests are checked into Git, so it knows that these tests
    do not need to run. You would never commit something that doesn't pass a unit
    test, right?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个没有任何依赖的测试，Jest会自行运行它。其他两个测试已经提交到Git，所以它知道这些测试不需要运行。你永远不会提交不能通过单元测试的东西，对吧？
- en: 'Let''s make this test fail now and see what happens. Change the `Test` component
    so that it looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们让这个测试失败，看看会发生什么。将`Test`组件更改为以下内容：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will fail the test because it is expecting the component function to return
    the value passed to the `children` property. Now if you go back to the Jest console,
    the output should look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致测试失败，因为它期望组件函数返回传递给`children`属性的值。现在如果你回到Jest控制台，输出应该是这样的：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test failed, as you knew it would. What's interesting is that once again,
    this was the only test that was run because nothing else has changed according
    to Git. The benefit to you is that once you have hundreds of tests, you don't
    need to wait for all of them to run before a failing test for the component that
    you're currently working can run.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了，正如你所知道的。有趣的是，这又是唯一运行的测试，因为根据Git，没有其他东西发生变化。对你有利的是，一旦你有了数百个测试，你就不需要等待所有测试都运行完毕，才能运行当前正在工作的组件的失败测试。
- en: Running tests using standalone Jest
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用独立的Jest运行测试
- en: The `test` script from `react-scripts` that you just learned about in the previous
    section is a great tool to have running in the background while you're building
    your application. It gives you immediate feedback as you implement components
    and unit tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中你刚刚了解到的`react-scripts`中的`test`脚本是一个很好的工具，可以在你构建应用程序时在后台运行。它在你实现组件和单元测试时给出了即时的反馈。
- en: Other times, you just want to run all tests and have the process exit as soon
    as the result output is printed. For example, if you're integrating Jest output
    into a continuous integration process or if you just want to see test results
    run once, you can run Jest directly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他时候，你只想运行所有的测试，并在打印结果输出后立即退出进程。例如，如果你正在将Jest输出集成到持续集成流程中，或者如果你只想看一次测试结果，你可以直接运行Jest。
- en: 'Let''s try running Jest on its own. Make sure that you''re in your project
    directory still and that you''ve stopped the `npm test` script from running. Now
    just run:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试单独运行Jest。确保你仍然在项目目录中，并且已经停止了`npm test`脚本的运行。现在只需运行：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Rather than running Jest in watch mode, this command simply attempts to run
    all of your tests, prints the result output, and then exits. However, there seems
    to be a problem with this approach. Running Jest like this results in errors:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与在观察模式下运行Jest不同，这个命令只是尝试运行所有的测试，打印结果输出，然后退出。然而，这种方法似乎存在问题。像这样运行Jest会导致错误：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is because the `test` script from `react-scripts` sets up a lot of things
    for us, including all of the Jest configuration necessary to parse and execute
    JSX. Given that we have this tool available to us, let's just use it rather than
    go through the headache of trying to configure Jest from scratch. Remember, your
    goal is to run Jest once—not in watch mode.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`react-scripts`中的`test`脚本为我们设置了很多东西，包括解析和执行JSX所需的所有Jest配置。鉴于我们有这个工具可用，让我们使用它，而不是试图从头开始配置Jest。记住，你的目标是只运行一次Jest，而不是在观察模式下运行。
- en: 'It turns out that the `test` script from `react-scripts` is ready to handle
    continuous integration environments. If it finds a `CI` environment variable,
    it won''t run Jest in watch mode. Let''s try this out by exporting this variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`react-scripts`中的`test`脚本已经准备好处理持续集成环境。如果它发现`CI`环境变量，它就不会在观察模式下运行Jest。让我们尝试通过导出这个变量来验证一下：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now when you run `npm test`, everything works as expected. The process exits
    when everything is finished:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行`npm test`时，一切都按预期进行。当一切都完成时，进程退出：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can then unset this environment variable when you''re done:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成后，可以取消这个环境变量：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of the time, you'll probably just use Jest in watch mode. But in case you
    need to quickly run your tests in a short-lived process, you can temporarily enter
    continuous integration mode.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你可能只会在观察模式下使用Jest。但是，如果你需要在短暂的进程中快速运行测试，你可以暂时进入持续集成模式。
- en: Writing Jest tests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Jest测试
- en: Now that you know how to run Jest, let's write some unit tests. We'll cover
    the basics as well as the more advanced features of Jest available for testing
    React apps. We'll start organizing your tests into suites and the basic assertions
    available in Jest. Then, you'll create your first mock module and work with asynchronous
    code. Lastly, we'll use Jest's snapshotting mechanism to help test React component
    output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何运行Jest了，让我们写一些单元测试。我们将涵盖Jest可用于测试React应用的基础知识以及更高级的功能。我们将开始将你的测试组织成套件，并介绍Jest中的基本断言。然后，你将创建你的第一个模拟模块并处理异步代码。最后，我们将使用Jest的快照机制来帮助测试React组件的输出。
- en: Organizing tests using suites
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套件组织测试
- en: 'Suites are the main organizational unit of your tests. Suites aren''t a Jest
    requirement—the test that `create-react-app` creates does not include a suite:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 套件是你的测试的主要组织单元。套件不是Jest的要求——`create-react-app`创建的测试不包括套件：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `it()` function declares a unit test that passes or fails. When you''re
    just getting your project started and you only have a few tests, there''s no need
    for suites. Once you have several tests, it''s time to start thinking about organization.
    Think of a suite as a container that you can put your tests in. You can have several
    of these containers that organize your tests however you see fit. Typically, a
    suite corresponds to a source module. Here''s how you declare suites:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`it()`函数声明了一个通过或失败的单元测试。当你刚开始项目并且只有少数测试时，不需要套件。一旦你有了多个测试，就是时候开始考虑组织了。把套件看作是一个容器，你可以把你的测试放进去。你可以有几个这样的容器，以你认为合适的方式组织你的测试。通常，一个套件对应一个源模块。以下是如何声明套件：'
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `describe()` function is used here to declare a suite called `BasicSuite`.
    Within the suite, we have several unit tests declared. Using `describe()`, you
    can organize your tests so that related tests are grouped together in the test
    result output.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`describe()`函数声明了一个名为`BasicSuite`的测试套件。在套件内部，我们声明了几个单元测试。使用`describe()`，你可以组织你的测试，使相关的测试在测试结果输出中被分组在一起。
- en: 'However, your tests will grow unwieldy fast if suites are the only mechanism
    available to organize your tests. The reason is that you will typically have more
    than one test per class, method, or function located within a module. So you need
    a way to say which part of code the test actually belongs to. The good news is
    that you can nest calls to `describe()` to provide the necessary organization
    for your suite:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果套件是唯一可用于组织测试的机制，你的测试将很快变得难以管理。原因是通常一个类、方法或函数位于一个模块中会有多个测试。因此，你需要一种方法来说明测试实际上属于代码的哪一部分。好消息是你可以嵌套调用`describe()`来为你的套件提供必要的组织：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The outermost `describe()` call declares the test suite, which corresponds to
    some top-level unit of code, such as a module. The inner calls to `describe()`
    correspond to smaller code units, such as methods and functions. This way, you
    can easily write several unit tests for a given piece of code while avoiding confusion
    about what's actually being tested.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的`describe()`调用声明了测试套件，对应于一些顶层的代码单元，比如一个模块。对`describe()`的内部调用对应于更小的代码单元，比如方法和函数。这样，你可以轻松地为给定的代码片段编写多个单元测试，同时避免对实际被测试的内容产生困惑。
- en: 'Let''s take a look at some detailed output for the test suite that you''ve
    just created. To do so, run the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下你刚刚创建的测试套件的详细输出。为此，请运行以下命令：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first set of double dashes tells `npm` to pass any arguments that follow
    to the `test` script. Here''s what you''ll see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组双破折号告诉`npm`将后面的任何参数传递给`test`脚本。以下是你将看到的内容：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Under `NestedSuite`, you can see that `state` is the code that's being tested
    and that two tests have passed. Same is the case with `props` and `render()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NestedSuite`下，你可以看到`state`是被测试的代码，并且有两个测试通过了。`props`和`render()`也是一样的情况。
- en: Basic assertions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本断言
- en: Assertions in your unit tests are created using Jest's expectation API. These
    functions trigger unit test failures when the expectations of your code aren't
    met. The output of test failures when using this API shows you what was expected
    to happen in addition to what actually happened. This seriously cuts down the
    amount of time you spend chasing down values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，使用 Jest 的期望 API 创建断言。当代码的期望未达到时，这些函数会触发单元测试失败。使用此 API 时，测试失败的输出会显示您期望发生的事情以及实际发生的事情。这严重减少了您追踪值所花费的时间。
- en: Basic equality
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本相等
- en: 'You can assert that two values are the same by using the `toBe()` expectation
    method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `toBe()` 期望方法来断言两个值相同：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the first test, you're expecting `true` to equal `true`. Then, you're negating
    this expectation in the next line using the `.not` property. If this were a real
    unit test, you wouldn't have to prove the opposite of an assertion that you've
    just made like this—I'm doing this to illustrate some of your options.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，您期望 `true` 等于 `true`。然后，在下一行使用 `.not` 属性否定这个期望。如果这是一个真正的单元测试，您不必像这样证明您刚刚做出的断言的相反情况——我这样做是为了说明您的一些选择。
- en: In the second test, we're performing the same assertions but with `false` as
    the expectation value. The `toBe()` method uses strict equality to compare its
    values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们执行相同的断言，但期望值为 `false`。`toBe()` 方法使用严格相等来比较其值。
- en: Approximate equality
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近似相等
- en: There are times where checking for the exact value of something in your code
    makes no difference and could be more work than is worthwhile. For example, you
    might only need to make sure that a value is present. You might also need to perform
    the inverse—to make sure that there is no value. Something versus nothing in JavaScript
    terminology is **truthy** versus **falsy**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在代码中检查某些东西的确切值并没有什么区别，而且可能比值得的工作更多。例如，您可能只需要确保某个值存在。您可能还需要执行相反的操作——确保没有值。在
    JavaScript 术语中，某物与无物是“真值”与“假值”。
- en: 'To check for truthy or falsy values in your Jest unit tests, you would use
    the `isTruthy()` or `isFalsy()` methods respectively:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Jest 单元测试中检查真值或假值，您将分别使用 `isTruthy()` 或 `isFalsy()` 方法：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The value `1` isn't true, but it evaluates to `true` when used in the context
    of a Boolean comparison. Likewise, an empty string evaluates to `false`, so it's
    considered falsy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `1` 不是 true，但在布尔比较的上下文中使用时，它会计算为 `true`。同样，空字符串计算为 `false`，因此被视为假值。
- en: Value equality
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值相等
- en: When working with objects and arrays, checking for equality can be painful.
    You typically can't use strict equality because you're comparing references, which
    are always different. If it's the values that you're trying to compare, you need
    to iterate over the object or collection and compare the values, keys, and indexes
    individually.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理对象和数组时，检查相等可能很痛苦。通常您不能使用严格相等，因为您在比较引用，而引用总是不同的。如果您要比较的是值，您需要逐个迭代对象或集合并比较值、键和索引。
- en: 'Since no one in their right mind wants to do all of this work to perform a
    simple test. Jest provides the `toEqual()` method, which compares object properties
    and array values for you:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有人在理智的头脑中想要做所有这些工作来执行简单的测试。Jest 提供了 `toEqual()` 方法，它可以为您比较对象属性和数组值：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Every object and array in this example are unique references. Yet, the two objects
    and the two arrays are equal in terms of their properties and values. The `toEqual()`
    method checks for value equality. After this, I'm showing that `toBe()` is not
    what you want—this returns `false` because it's comparing references.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的每个对象和数组都是唯一的引用。然而，这两个对象和两个数组在其属性和值方面是相等的。`toEqual()` 方法检查值的相等性。之后，我要展示
    `toBe()` 不是你想要的——这会返回 `false`，因为它在比较引用。
- en: Values in collections
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合中的值
- en: 'There are way more assertion methods available in Jest than I have room to
    cover in this book. I encourage you to take a look at the *Expect* section of
    the Jest API docs: [https://facebook.github.io/jest/docs/en/expect.html](https://facebook.github.io/jest/docs/en/expect.html).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 中有比我在这本书中介绍的断言方法更多。我鼓励你查看 Jest API 文档中的 *Expect* 部分：[https://facebook.github.io/jest/docs/en/expect.html](https://facebook.github.io/jest/docs/en/expect.html)。
- en: 'The last two assertion methods I want to go over with you are `toHaveProperty()`
    and `toContain()`. The former tests that an object has a given property while
    the latter checks that an array contains a given value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要和你讨论的最后两个断言方法是 `toHaveProperty()` 和 `toContain()`。前者测试对象是否具有给定属性，而后者检查数组是否包含给定值：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `toHaveProperty()` method is useful when you need to check if an object
    has a particular property value. The `toContain()` method is useful when you need
    to check if an array has a particular value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要检查对象是否具有特定属性值时，`toHaveProperty()` 方法非常有用。当你需要检查数组是否具有特定值时，`toContain()`
    方法非常有用。
- en: Working with mocks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟
- en: When you write unit tests, you're testing your own code. At least that's the
    idea. In reality, this is more difficult than it sounds because your code will
    inevitably use a library of some sort. This is code that you do not want to test.
    The problem with writing unit tests that call other libraries is that they often
    need to reach out to the network or the filesystem. You definitely don't want
    false positives as a result of side-effects from other libraries.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写单元测试时，你是在测试自己的代码。至少这是理论上的想法。实际上，这比听起来更困难，因为你的代码不可避免地会使用某种库。这是你不想测试的代码。编写调用其他库的单元测试的问题在于它们通常需要访问网络或文件系统。你绝对不希望由于其他库的副作用而产生误报。
- en: Jest provides a powerful mocking mechanism that's easy to use. You give Jest
    the path to a module that you want to mock, and it handles the rest. In some cases,
    you don't need to provide a mock implementation. In other cases, you need to handle
    parameters and return values in the same way as the original module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供了一个强大的模拟机制，使用起来很容易。你给 Jest 提供要模拟的模块的路径，它会处理剩下的事情。在某些情况下，你不需要提供模拟实现。在其他情况下，你需要以与原始模块相同的方式处理参数和返回值。
- en: 'Let''s say you''ve created a `readFile()` function that looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了一个如下所示的 `readFile()` 函数：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function requires the `readFile()` function from the `fs` module. It returns
    a promise that is resolved when the callback function that's passed to `readFile()`
    is called, unless there's an error.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要来自 `fs` 模块的 `readFile()` 函数。它返回一个 promise，在传递给 `readFile()` 的回调函数被调用时解析，除非出现错误。
- en: 'Now you would like to write a unit test for this function. You want to make
    assertions like:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想为这个函数编写一个单元测试。你想做出如下断言：
- en: Does it call `fs.readFile()`?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否调用了 `fs.readFile()`？
- en: Does the returned promise resolve with the correct value?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的 promise 是否以正确的值解析？
- en: Does the returned promise reject when the callback passed to `fs.readFile()`
    receives an error?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递给 `fs.readFile()` 的回调接收到错误时，返回的 promise 是否被拒绝？
- en: You can perform all of these assertions without relying on the actual implementation
    of `fs.readFile()` by mocking it with Jest. You don't have to make any assumptions
    about external factors; you only care that your code works the way that you expect
    it to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用Jest对其进行模拟来执行所有这些断言，而不必依赖于`fs.readFile()`的实际实现。您不必对外部因素做任何假设；您只关心您的代码是否按照您的预期工作。
- en: 'So let''s take a shot at implementing some tests for this function that use
    a mocked `fs.readFile()` implementation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试为使用模拟的`fs.readFile()`实现的此函数实施一些测试：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The mocked version of the `fs` module is created by calling `jest.mock('fs')`.
    Note that you actually import the real `fs` module before mocking it and that
    it's mocked before any tests actually use it. In each test, we're creating a custom
    implementation of `fs.readFile()`. By default, functions mocked by Jest won't
    actually do anything. Rarely will this suffice for testing most things. The beauty
    of mocks is that you control the outcome of the library that your code uses, and
    your test assertions make sure that your code handles everything accordingly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`jest.mock('fs')`来创建`fs`模块的模拟版本。请注意，在模拟之前实际导入了真实的`fs`模块，并且在任何测试实际使用它之前就已经模拟了它。在每个测试中，我们都在创建`fs.readFile()`的自定义实现。默认情况下，Jest模拟的函数实际上不会执行任何操作。这很少足以测试大多数事情。模拟的美妙之处在于您可以控制代码使用的库的结果，并且您的测试断言确保您的代码相应地处理一切。
- en: You provide the implementation by passing it as a function to the `mockImplementation()`
    method. But before you do this, always make sure that you call `mockReset()` to
    clear any stored information about the mock, like how many times it was called.
    For example, the first test has the assertion `expect(fs.readFile).toHaveBeenCalled()`.
    You can pass a mock function to `expect()` and Jest provides methods that know
    how to work with them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其作为函数传递给`mockImplementation()`方法来提供实现。但在这样做之前，一定要确保调用`mockReset()`来清除有关模拟的任何存储信息，比如它被调用的次数。例如，第一个测试有断言`expect(fs.readFile).toHaveBeenCalled()`。您可以将模拟函数传递给`expect()`，Jest提供了知道如何与它们一起工作的方法。
- en: 'The same pattern can be followed for similar functions. Here''s the counterpart
    to `readFile()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类似的功能，可以遵循相同的模式。这是`readFile()`的对应函数：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There''s two important differences between `readFile()` and `writeFile()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile()`和`writeFile()`之间有两个重要的区别：'
- en: The `writeFile()` function accepts a second parameter for the data to write
    to the file. This parameter is also passed to `fs.writeFile()`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeFile()`函数接受第二个参数，用于写入文件的数据。这个参数也传递给`fs.writeFile()`。'
- en: The `writeFile()` function doesn't resolve a value whereas `readFile()` resolves
    the file data that's been read.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeFile()`函数不会解析值，而`readFile()`会解析已读取的文件数据。'
- en: 'These two differences have implications for the mock implementations that you
    create. Let''s take a look at them now:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个差异对您创建的模拟实现有影响。现在让我们来看看它们：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `data` parameter needs to be part of the mock implementation now; otherwise,
    there'd be no way to access the `cb` parameter and call the callback.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`data`参数需要成为模拟实现的一部分；否则，将无法访问`cb`参数并调用回调函数。
- en: In both the `readFile()` and `writeFile()` tests, you have to deal with asynchronicity.
    This is why we're performing assertions within a `then()` callback. The `done()`
    function that is passed in from `it()` is called when we're done with the test.
    If you forget to call `done()`, the test will hang and eventually timeout and
    fail.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`readFile()`和`writeFile()`测试中，您必须处理异步性。这就是为什么我们在`then()`回调中执行断言的原因。从`it()`传入的`done()`函数在测试完成时被调用。如果您忘记调用`done()`，测试将挂起并最终超时和失败。
- en: Unit test coverage
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试覆盖率
- en: 'Jest comes with built-in support for test coverage reporting. It''s nice to
    have this included as part of your test framework because not all of them have
    this support. If you want to see what your test coverage looks like, simply pass
    the `--coverage` option when starting Jest as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 自带对测试覆盖报告的支持。将这包含在测试框架中是很好的，因为并非所有测试框架都支持这一点。如果你想看看你的测试覆盖率是什么样子，只需在启动 Jest
    时传递 `--coverage` 选项即可：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you do this, tests are run as normal. Then, the coverage tool inside Jest
    will figure out how well your tests cover your source, and will produce a report
    that looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，测试会像平常一样运行。然后，Jest 内部的覆盖工具会计算你的测试覆盖源代码的程度，并生成一个报告，看起来像这样：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to bring your coverage numbers up, take a look at the `Uncovered
    Lines` column in the report. The other columns tell you what type of code is covered
    by tests: statements, branches, and functions.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提高你的覆盖率，看看报告中的 `Uncovered Lines` 列。其他列告诉你测试覆盖的代码类型：语句、分支和函数。
- en: Asynchronous assertions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步断言
- en: Jest anticipates that you'll have asynchronous code to test. This is why it
    provides APIs to make this aspect of writing unit tests feel natural. In the previous
    section, we wrote tests that performed assertions within a `then()` callback and
    called `done()` when all of the asynchronous testing was completed. In this section,
    we're going to look at another approach.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 预期你会有异步代码需要测试。这就是为什么它提供了 API 来使编写单元测试中的这一方面感觉自然。在前一节中，我们编写了在 `then()` 回调中执行断言并在所有异步测试完成时调用
    `done()` 的测试。在本节中，我们将看另一种方法。
- en: 'Jest allows you to return promise expectations from your unit test functions
    and will handle them accordingly. Let''s refactor the `readFile()` tests that
    you wrote in the previous section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 允许你从单元测试函数中返回 promise 期望，并会相应地处理它们。让我们重构一下你在前一节中编写的 `readFile()` 测试：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the tests return promises. When a promise is returned, Jest will wait for
    it to resolve before the results of the test are captured. You can also pass `expect()`
    a promise and use the `resolves` and `rejects` objects to perform your assertions.
    This way, you don't have to rely on the `done()` function to indicate that the
    asynchronous portion of your test is complete.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试返回的是 promises。当返回一个 promise 时，Jest 会等待它解析完成，然后才捕获测试结果。你也可以传递一个 promise 给
    `expect()`，并使用 `resolves` 和 `rejects` 对象来执行断言。这样，你就不必依赖 `done()` 函数来指示测试的异步部分已经完成了。
- en: The `rejects` object is particularly valuable here. It's important to make sure
    that functions reject as expected. But without `rejects`, it's impossible to do
    this. In the previous version of this test, if your code resolved for some reason
    when it was supposed to reject, there's no way to detect this. Now if this happens,
    using `rejects` causes the test to fail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`rejects` 对象在这里特别有价值。确保函数按预期拒绝是很重要的。但如果没有 `rejects`，这是不可能做到的。在这个测试的先前版本中，如果你的代码因某种原因解析了，而本应拒绝，那就无法检测到这一点。现在，如果发生这种情况，使用
    `rejects` 会导致测试失败。'
- en: React component snapshots
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 组件快照
- en: React components render output. Naturally, you want part of your component unit
    tests to ensure that the correct output is created. One approach is to render
    the component to a JS-based DOM, and then to perform individual assertions on
    the rendered output. This would be a painful test writing experience to say the
    least.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件会渲染输出。自然地，你希望组件单元测试的一部分是确保正确的输出被创建。一种方法是将组件渲染到基于 JS 的 DOM 中，然后对渲染输出执行单独的断言。至少可以说，这将是一个痛苦的测试编写体验。
- en: Snapshot testing allows you to generate a *snapshot* of rendered component output.
    Then, each time your test runs, the output is compared to the snapshot. If something
    looks different, the test fails.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试允许你生成渲染组件输出的*快照*。然后，每次运行测试时，输出会与快照进行比较。如果有什么看起来不同，测试就会失败。
- en: 'Let''s modify the default test for the `App` component that `create-react-app`
    adds for you to make it use snapshot testing. Here''s what the original test looked
    like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`create-react-app`为你添加的`App`组件的默认测试，使其使用快照测试。这是原始测试的样子：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This test isn''t actually verifying anything about the content that''s rendered—just
    that an error isn''t thrown. If you were to make a change that resulted in something
    unexpected, you would never know about it. Here''s the snapshotting version of
    the same test:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试实际上并没有验证渲染的内容——只是没有抛出错误。如果你做出了导致意外结果的更改，你将永远不会知道。这是相同测试的快照版本：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before this test would run, I had to install the `react-test-renderer` package:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个测试之前，我必须安装`react-test-renderer`包：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Maybe this will be added to `create-react-app` some day. In the meantime, you'll
    have to remember to install it. Then, your test can import the test renderer and
    use it to create a JSON tree. This is a representation of the rendered component
    content. Next, you expect the tree to match the snapshot that is created the first
    time this test runs, using the `toMatchSnapshot()` assertion.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有一天这将被添加到`create-react-app`中。与此同时，你需要记得安装它。然后，你的测试可以导入测试渲染器并使用它来创建一个JSON树。这是渲染组件内容的表示。接下来，你期望这个树与第一次运行此测试时创建的快照匹配，使用`toMatchSnapshot()`断言。
- en: This means that the first time the test is run, it will always pass because
    this is when the snapshot is first created. Snapshot files are artifacts that
    should be committed to your project's source control system, just like the unit
    test source itself. This way, other folks who work on the project will have a
    snapshot file to work with when they run your tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一次运行测试时，它总是会通过，因为这是第一次创建快照。快照文件是应该提交到项目的源代码控制系统的工件，就像单元测试源代码本身一样。这样，项目中的其他人在运行你的测试时就会有一个快照文件可供使用。
- en: What's misleading about snapshot testing is that it gives the impression that
    you can't actually change components to produce different output. Well, this is
    in fact true—changing the output produced by components will result in failed
    snapshot tests. This isn't a bad thing, though, as it forces you to look at what
    your components are rendering with every change you make.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于快照测试的误解在于它给人的印象是你实际上不能改变组件以产生不同的输出。事实上，这是真的——改变组件产生的输出会导致快照测试失败。不过，这并不是一件坏事，因为它迫使你在每次更改时查看你的组件渲染的内容。
- en: 'Let''s change the `App` component so that it adds emphasis to the word `started`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`App`组件，使其对单词`started`添加强调。
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now if you run your test, you get a failure that looks something like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行你的测试，你会得到一个类似这样的失败：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Wow! This is useful. A unified diff shows you exactly what changed with the
    component output. You can look at this output and decide that this is exactly
    the change that you expected to see, or that you''ve made a mistake and you need
    to go fix it. Once you''re happy with the new output, you can update the stored
    snapshot by passing an argument to the `test` script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这很有用。统一的差异显示了组件输出的确切变化。你可以查看这个输出，并决定这正是你期望看到的变化，或者你犯了一个错误，需要去修复它。一旦你对新的输出满意，你可以通过向`test`脚本传递参数来更新存储的快照：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will update the stored snapshot before running your tests and any failed
    snapshot tests will now pass since they meet their output expectations:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行测试之前更新存储的快照，任何失败的快照测试现在都将通过，因为它们符合其输出期望：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Jest tells you that a snapshot was updated before running any tests, the result
    of passing the `--updateSnapshot` argument.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Jest告诉您在运行任何测试之前快照已更新，通过传递`--updateSnapshot`参数来实现。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about Jest. You learned that the key driving principles
    of Jest are creating effective mocks, test isolation and parallel execution, and
    ease of use. You then learned that `react-scripts` makes running your unit tests
    even easier by providing some basic configuration to use with Jest.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Jest。您了解到Jest的关键驱动原则是创建有效的模拟、测试隔离和并行执行，以及易用性。然后，您了解到`react-scripts`通过提供一些基本配置使运行单元测试变得更加容易。
- en: When running Jest, you saw that watch mode is the default when running Jest
    via `react-scripts`. Watch mode is especially useful when you have lots of tests
    that don't need to run every time you make a source change—only relevant tests
    are executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Jest时，您会发现通过`react-scripts`运行Jest时，观察模式是默认模式。观察模式在有许多不需要在每次源代码更改时运行的测试时特别有用，只有相关的测试会被执行。
- en: Next, you performed some basic assertions in your unit tests. Then, you created
    a mock for the `fs` module and performed assertions on the mocked functions to
    ensure that they're being used as expected. You then evolved these tests to make
    use of the inherent asynchronous capabilities of Jest. Unit test coverage reporting
    is built into Jest, and you learned how to view this report by passing an additional
    argument.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您在单元测试中执行了一些基本断言。然后，您为`fs`模块创建了一个模拟，并对模拟函数进行断言，以确保它们被预期使用。然后，您进一步发展了这些测试，以利用Jest的固有异步能力。单元测试覆盖报告内置在Jest中，您学会了如何通过传递额外的参数来查看此报告。
- en: In the next chapter, you'll learn how to create type-safe components using Flow.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用Flow创建类型安全的组件。
