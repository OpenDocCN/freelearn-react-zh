- en: MobX and Hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX和Hooks
- en: In the previous chapter, we learned about Redux and how to use Redux in combination
    with Hooks. We also learned how to migrate existing Redux applications to a Hook-based
    solution. Furthermore, we learned about the trade-offs of using Reducer Hooks
    versus Redux, and when to use either one of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Redux以及如何将Redux与Hooks结合使用。我们还学习了如何将现有的Redux应用迁移到基于Hook的解决方案。此外，我们还了解了使用Reducer
    Hooks与Redux的权衡，以及何时使用其中之一。
- en: In this chapter, we are going to learn how to use MobX in combination with Hooks.
    We are going to start by learning how to handle state with MobX, then move on
    to using MobX with Hooks. Furthermore, we will learn how to migrate an existing
    MobX application to Hooks. Finally, we are going to discuss the pros and cons
    of using MobX. By the end of this chapter, you will fully understand how to write
    MobX applications using Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将MobX与Hooks结合使用。我们将首先学习如何使用MobX处理状态，然后转而使用Hooks与MobX。此外，我们还将学习如何将现有的MobX应用迁移到Hooks。最后，我们将讨论使用MobX的利弊。通过本章的学习，您将完全了解如何使用Hooks编写MobX应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning what MobX is and how it works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解MobX是什么以及它是如何工作的
- en: Handling state with MobX
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MobX处理状态
- en: Using MobX with Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks与MobX
- en: Migrating a MobX application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移MobX应用
- en: Learning about the trade-offs of MobX
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解MobX的权衡
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: The code for this chapter can be found in the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter13).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter13)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    you write the code yourself in order to be able to learn and understand it properly.
    However, if you run into any issues, you can always refer to the code example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行提供的代码示例。重要的是您自己编写代码，以便能够正确学习和理解它。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始本章。
- en: What is MobX?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是MobX？
- en: MobX takes a different approach than Redux. Rather than applying restrictions
    to make state changes predictable, it aims to automatically update anything that
    is derived from the application state. Rather than dispatching actions, in MobX
    we can directly modify the state object and MobX will take care of updating anything
    that uses the state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MobX采用了与Redux不同的方法。它不是施加限制以使状态变化可预测，而是旨在自动更新从应用程序状态派生的任何内容。与分派动作不同，在MobX中，我们可以直接修改状态对象，MobX将负责更新使用状态的任何内容。
- en: 'The MobX life cycle works as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的生命周期如下：
- en: 'Events (such as `onClick`) invoke actions, which are the only things that can
    modify state:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件（如`onClick`）调用动作，这是唯一可以修改状态的东西：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'State is observable, and should not contain redundant or derivable data. State
    is very flexible—it can contain classes, arrays, references, or it can even be
    a graph:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是可观察的，不应包含冗余或可推导的数据。状态非常灵活 - 它可以包含类、数组、引用，甚至可以是图：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Computed values are derived from state through a pure function. These will
    be automatically updated by MobX:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算值是通过纯函数从状态派生出来的。这些将被MobX自动更新：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Reactions are like computed values, but they can also produce a side effect
    instead of a value, such as updating the user interface in React:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应就像计算值，但它们也可以产生副作用，而不是一个值，比如在React中更新用户界面：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see a visualization of the MobX life cycle in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图表中看到MobX的生命周期可视化：
- en: '![](assets/980b2234-8ff9-4bb6-8d22-4447522b692a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/980b2234-8ff9-4bb6-8d22-4447522b692a.png)'
- en: Visualization of the MobX life cycle
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MobX生命周期的可视化
- en: MobX and React work very well together. Whenever MobX detects that state has
    changed, it will cause a re-render of the appropriate components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: MobX和React非常搭配。每当MobX检测到状态已经改变，它将导致适当的组件重新渲染。
- en: Unlike Redux, there are not many restrictions to learn about in order to use
    MobX. We only need to learn about a handful of core concepts, such as observables,
    computed values, and reactions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与Redux不同，使用MobX并不需要学习很多限制。我们只需要了解一些核心概念，比如可观察值、计算值和反应。
- en: Now that we know about the MobX life cycle, let's move on to handling state
    with MobX in practice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了MobX的生命周期，让我们继续实践中使用MobX处理状态。
- en: Handling state with MobX
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MobX处理状态
- en: The best way to learn about MobX is by using it in practice and seeing how it
    works. So, let's start by porting our ToDo application from [Chapter 11](cf5ec080-00ae-46a8-afa0-46f5c7b3b259.xhtml), *Migrating
    from React Class Components*, to MobX. We start by copying the code example from `Chapter11/chapter11_2/`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 了解MobX最好的方法是在实践中使用它并看看它是如何工作的。所以，让我们从[第11章](cf5ec080-00ae-46a8-afa0-46f5c7b3b259.xhtml)的ToDo应用程序开始，*从React类组件迁移*到MobX。我们首先要做的是从`Chapter11/chapter11_2/`复制代码示例。
- en: Installing MobX
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MobX
- en: 'The first step is to install MobX and MobX React, via `npm`. Execute the following
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过`npm`安装MobX和MobX React。执行以下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that MobX and MobX React are installed, we can start setting up the store.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在MobX和MobX React都安装好了，我们可以开始设置存储了。
- en: Setting up the MobX store
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MobX存储
- en: After installing MobX, it is time to set up our MobX store. The store will store
    all state, and the related computed values and actions. It is usually defined
    with a class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完MobX后，现在是时候设置我们的MobX存储了。存储将存储所有状态，以及相关的计算值和操作。通常使用类来定义。
- en: 'Let''s define the MobX store now:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义MobX存储：
- en: Create a new `src/store.js` file.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/store.js`文件。
- en: 'Import the `observable`, `action`, and `computed` decorators, as well as the
    `decorate` function from MobX. These will be used to tag various functions and
    values in our store:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MobX导入`observable`、`action`和`computed`装饰器，以及`decorate`函数。这些将用于标记存储中的各种函数和值：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also import the `fetchAPITodos` and `generateID` functions from our API code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要从我们的API代码中导入`fetchAPITodos`和`generateID`函数：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we define the store by using a class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过使用一个类来定义存储：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this store, we store a `todos` array, and the `filter` string value. These
    two values are observables. We are going to tag them as such later on:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个存储中，我们存储了一个`todos`数组和`filter`字符串值。这两个值都是可观察的。我们将在稍后将它们标记为这样：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With a special project setup, we could use an experimental JavaScript feature,
    known as **decorators**, to tag our values as observables by writing `@observable
    todos = []`. However, this syntax is not supported by `create-react-app`, since
    it is not part of the JavaScript standard yet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过特殊的项目设置，我们可以使用一个实验性的JavaScript特性，称为**装饰器**，通过编写`@observable todos = []`来将我们的值标记为可观察的。然而，这种语法不受`create-react-app`支持，因为它还不是JavaScript标准的一部分。
- en: 'Next, we define a computed value in order to get all of the filtered `todos`
    from our store. The function will be similar to the one that we had in `src/App.js`,
    but now we will use `this.filter` and `this.todos`. Again, we have to tag the
    function as `computed` later on. MobX will automatically trigger this function
    when needed, and store the result until the state that it depends on changes:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个计算值，以便从我们的store中获取所有经过过滤的`todos`。该函数将类似于我们在`src/App.js`中的函数，但现在我们将使用`this.filter`和`this.todos`。同样，我们必须稍后将该函数标记为`computed`。MobX将在需要时自动触发此函数，并存储结果，直到它所依赖的状态发生变化。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we define our actions. We start with the `fetch` action. As before, we
    have to tag our action functions with the `action` decorator at a later point.
    In MobX, we can directly modify our state by setting `this.todos`. Because the
    `todos` value is observable, any changes to it will be automatically tracked by
    MobX:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义我们的动作。我们从`fetch`动作开始。与以前一样，我们必须稍后使用`action`装饰器标记我们的动作函数。在MobX中，我们可以通过设置`this.todos`直接修改我们的状态。因为`todos`值是可观察的，对它的任何更改都将被MobX自动跟踪：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we define our `addTodo` action. In MobX, we do not use immutable values,
    so we should not create a new array. Instead, we always modify the existing `this.todos`
    value:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了`addTodo`动作。在MobX中，我们不使用不可变的值，因此不应创建新数组。相反，我们总是修改现有的`this.todos`值：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, MobX takes a more imperative approach, where values are directly
    modified, and MobX automatically keeps track of the changes. We do not need to
    use the rest/spread syntax to create new arrays; instead, we modify the existing
    state array directly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，MobX采用更加命令式的方法，直接修改值，MobX会自动跟踪更改。我们不需要使用rest/spread语法来创建新数组；相反，我们直接修改现有状态数组。
- en: 'Next up is the `toggleTodo` action. Here, we loop through all of the `todos`
    and modify the item with a matching `id`. Note how we can modify items within
    an array, and the change will still be tracked by MobX. In fact, MobX will even
    notice that only one value of the array has changed. In combination with React,
    this means that the list component will not re-render; only the item component
    of the item that changed is going to re-render. Please note that for this to be
    possible, we have to split up our components appropriately, such as making separate
    list and item components:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`toggleTodo`动作。在这里，我们循环遍历所有的`todos`并修改具有匹配`id`的项目。请注意，我们可以修改数组中的项目，并且更改仍将被MobX跟踪。事实上，MobX甚至会注意到数组中只有一个值已经改变。结合React，这意味着列表组件不会重新渲染；只有更改的项目组件将重新渲染。请注意，为了实现这一点，我们必须适当地拆分组件，例如制作单独的列表和项目组件：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `for (let .. of ..) {` construct will loop through all items of an array,
    or any other iterable value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`for (let .. of ..) {`结构将循环遍历数组的所有项目，或任何其他可迭代的值。'
- en: 'Now, we define the `removeTodo` action. First, we find the `index` of the `todo`
    item that we want to remove:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义了`removeTodo`动作。首先，我们找到要删除的`todo`项目的`index`：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we use `splice` to remove one element—starting from the `index` of the
    found element. This means that we cut out the item with the given `id` from our
    array:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`splice`来删除一个元素——从找到的元素的`index`开始。这意味着我们从数组中剪切具有给定`id`的项目：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last action that we define, is the `filterTodos` action. Here, we simply
    set the `this.filter` value to the new filter:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义的最后一个动作是`filterTodos`动作。在这里，我们只需将`this.filter`值设置为新的过滤器：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have to decorate our store with the various decorators that we
    mentioned earlier. We do this by calling the `decorate` function on our store
    class and passing an object mapping values and methods to decorators:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须使用我们之前提到的各种装饰器来装饰我们的store。我们通过在我们的store类上调用`decorate`函数并传递一个将值和方法映射到装饰器的对象来实现这一点：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start with the `todos` and `filter` values, which are observables:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从可观察的`todos`和`filter`值开始：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we decorate the `computed` value*—*`filteredTodos`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们装饰`computed`值*—*`filteredTodos`：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Last but not least, we decorate our actions:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们装饰我们的动作：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, our MobX store is decorated properly and ready to be used!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的MobX存储已经正确装饰并准备好使用！
- en: Defining the Provider component
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Provider组件
- en: We could now initialize the store in our `App` component, and pass it down to
    all of the other components. However, it is a better idea to use React Context.
    That way, we can access the store from anywhere in our app. MobX React offers
    a `Provider` component, which provides the store in a context.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`App`组件中初始化存储，并将其传递给所有其他组件。然而，更好的做法是使用React Context。这样，我们可以在应用程序的任何地方访问存储。MobX
    React提供了一个`Provider`组件，它在上下文中提供存储。
- en: 'Let''s get started using the `Provider` component now:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始使用`Provider`组件：
- en: 'Edit `src/index.js`, and import the `Provider` component from `mobx-react`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/index.js`，并从`mobx-react`中导入`Provider`组件：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, import the `TodoStore` from our `store.js` file:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从我们的`store.js`文件中导入`TodoStore`：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we create a new instance of the `TodoStore` class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`TodoStore`类的一个新实例：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we have to adjust the first argument to `ReactDOM.render()`, in order
    to wrap the `App` component with the `Provider` component:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须调整`ReactDOM.render()`的第一个参数，以便用`Provider`组件包装`App`组件：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unlike Redux, with MobX, it is possible to provide multiple stores in our app.
    However, here, we only provide one store, and we call it `todoStore`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与Redux不同，使用MobX可以在我们的应用程序中提供多个存储。然而，在这里，我们只提供一个存储，并将其称为`todoStore`。
- en: Now, our store is initialized and ready to be used in all other components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的存储已经初始化并准备在所有其他组件中使用。
- en: Connecting components
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接组件
- en: Now that our MobX store is available as a context, we can start connecting our
    components to it. To do so, MobX React provides the `inject` higher-order component,
    which we can use to inject the store into our components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的MobX存储作为上下文可用，我们可以开始将我们的组件连接到它。为此，MobX React提供了`inject`高阶组件，我们可以用它将存储注入到我们的组件中。
- en: 'In this section, we are going to connect the following components to our MobX
    store:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将把以下组件连接到我们的MobX存储中：
- en: '`App`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App`'
- en: '`TodoList`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`'
- en: '`TodoItem`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoItem`'
- en: '`AddTodo`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTodo`'
- en: '`TodoFilter`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoFilter`'
- en: Connecting the App component
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接App组件
- en: We are going to start by connecting our `App` component, where we will use the
    `fetch` action to fetch all `todos` from our API, when the app initializes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从连接我们的`App`组件开始，在那里我们将使用`fetch`动作从我们的API中获取所有`todos`。
- en: 'Let''s connect the `App` component now:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`App`组件：
- en: 'Edit `src/App.js`, and import the `inject` function from `mobx-react`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并从`mobx-react`中导入`inject`函数：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, wrap the `App` component with `inject`. The `inject` function is used
    to inject the store (or multiple stores) as props to the component:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用`inject`包装`App`组件。`inject`函数用于将存储（或多个存储）作为props注入到组件中：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is possible to specify multiple stores in the `inject` function, as follows:
    `inject(''todoStore'', ''otherStore'')`. Then, two props will be injected: `todoStore`
    and `otherStore`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`inject`函数中可以指定多个存储，如下所示：`inject('todoStore', 'otherStore')`。然后，将注入两个props：`todoStore`和`otherStore`。
- en: 'Now that we have the `todoStore` available, we can use it to call the `fetch`
    action within our Effect Hook:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`todoStore`，我们可以在Effect Hook中调用`fetch`动作：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now remove the `filteredTodos` Memo Hook, the handler functions, the
    `StateContext.Provider` component, and all of the props that we passed down to
    the other components:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以删除`filteredTodos` Memo Hook、处理函数、`StateContext.Provider`组件以及我们传递给其他组件的所有props：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, our `App` component will fetch `todos` from the API, and then they will
    be stored in the `TodoStore`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`App`组件将从API获取`todos`，然后它们将被存储在`TodoStore`中。
- en: Connecting the TodoList component
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接TodoList组件
- en: After storing the `todos` in our store, we can get them from the store, and
    then we can list all of the todo items in the `TodoList` component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`todos`存储在我们的存储中后，我们可以从存储中获取它们，然后我们可以在`TodoList`组件中列出所有的待办事项。
- en: 'Let''s connect the `TodoList` component now:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`TodoList`组件：
- en: 'Edit `src/TodoList.js` and import the `inject` and `observer` functions:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoList.js`并导入`inject`和`observer`函数：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remove all context-related imports and Hooks.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有与上下文相关的导入和Hooks。
- en: 'As before, we use the `inject` function to wrap the component. Additionally,
    we now wrap our component with the `observer` function. The `observer` function
    tells MobX that this component should re-render when the store updates:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前一样，我们使用`inject`函数来包装组件。此外，我们现在用`observer`函数包装我们的组件。`observer`函数告诉MobX，当存储更新时，这个组件应该重新渲染：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now use the `filteredTodos` computed value from our store, to list all
    todo items with the filter applied. To make sure that MobX can still track when
    changes to the `item` object occur, we *do not* use the spread syntax here. If
    we used the spread syntax, all of the todo items would re-render, even if only
    one changed:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用存储中的`filteredTodos`计算值，以列出所有应用了过滤器的待办事项。为了确保MobX仍然可以跟踪`item`对象发生的更改，我们在这里*不*使用扩展语法。如果我们使用了扩展语法，所有的待办事项都会重新渲染，即使只有一个发生了变化：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, our app will already list all of the todo items. However, we cannot toggle
    or remove the todo items yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已经列出了所有的待办事项。但是，我们还不能切换或删除待办事项。
- en: Connecting the TodoItem component
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接TodoItem组件
- en: To be able to toggle or remove todo items, we have to connect the `TodoItem`
    component. We also define the `TodoItem` component as an observer, so that MobX
    knows it will have to re-render the component when the `item` object changes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够切换或删除待办事项，我们必须连接`TodoItem`组件。我们还将`TodoItem`组件定义为观察者，以便MobX知道它将在`item`对象更改时重新渲染组件。
- en: 'Let''s connect the `TodoItem` component now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`TodoItem`组件：
- en: 'Edit `src/TodoItem.js`, and import the `inject` and `observer` functions from `mobx-react`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoItem.js`，并从`mobx-react`中导入`inject`和`observer`函数：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, wrap the `TodoItem` component with `inject` and `observer`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用`inject`和`observer`包装`TodoItem`组件：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now use destructuring of the `item` object within the component. As
    it is defined as an observer, MobX will be able to track changes to the `item`
    object, even after destructuring:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在组件内部使用`item`对象的解构。由于它被定义为观察者，MobX将能够在解构后跟踪`item`对象的更改：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we have the `todoStore` available, we can use it to adjust our handler
    functions, and to call the corresponding actions:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`todoStore`，我们可以使用它来调整我们的处理函数，并调用相应的动作：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, our `TodoItem` component will call the `toggleTodo` and `removeTodo` actions
    from our `todoStore`, so we can now toggle and remove the todo items!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`TodoItem`组件将调用`todoStore`中的`toggleTodo`和`removeTodo`动作，所以我们现在可以切换和删除待办事项！
- en: Connecting the AddTodo component
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接AddTodo组件
- en: To be able to add new todo items, we have to connect the `AddTodo` component.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够添加新的待办事项，我们必须连接`AddTodo`组件。
- en: 'Let''s connect the `AddTodo` component now:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接`AddTodo`组件：
- en: 'Edit `src/AddTodo.js` and import the `inject` function from `mobx-react`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/AddTodo.js`并从`mobx-react`中导入`inject`函数：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, wrap the `AddTodo` component with `inject`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用`inject`包装`AddTodo`组件：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have the `todoStore` available, we can use it to adjust our handler
    function, and to call the `addTodo` action:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`todoStore`，我们可以使用它来调整我们的处理函数，并调用`addTodo`动作：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, our `AddTodo` component will call the `addTodo` action from our `todoStore`,
    so we can now add new todo items!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`AddTodo`组件将调用我们的`todoStore`中的`addTodo`动作，所以我们现在可以添加新的待办事项！
- en: Connecting the TodoFilter component
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接TodoFilter组件
- en: Lastly, we have to connect the `TodoFilter` component in order to be able to
    select different filters. We also want to show the currently selected filter,
    so this component needs to be an `observer`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须连接`TodoFilter`组件，以便能够选择不同的过滤器。我们还希望显示当前选定的过滤器，因此这个组件需要是一个`observer`。
- en: 'Let''s connect the `TodoFilter` component now:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在连接`TodoFilter`组件：
- en: 'Edit `src/TodoFilter.js` and import the `inject` and `observer` functions:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoFilter.js`并导入`inject`和`observer`函数：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We use the `inject` and `observer` functions to wrap the component:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`inject`和`observer`函数来包装组件：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now adjust our handler function to call the `filterTodos` action from the
    store:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们调整我们的处理函数，以调用存储中的`filterTodos`动作：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we adjust the `style` object to use the `filter` value from `todoStore`,
    in order to check whether the filter is currently selected:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调整`style`对象，以使用`todoStore`中的`filter`值，以检查过滤器当前是否被选中：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Furthermore, we can now get rid of passing down the props in the `FilterItem`
    component. Remove the following parts that are marked in bold:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们现在可以摆脱在`FilterItem`组件中传递props。删除以下用粗体标记的部分：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we can select new filters, which will be marked as selected, in bold. The
    todo list will also automatically be filtered, because MobX detects a change in
    the `filter` value, which causes the `filteredTodos` computed value to update,
    and the `TodoList` observer component to re-render.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择新的过滤器，它们将被标记为选定，并以粗体显示。待办事项列表也将自动过滤，因为MobX检测到`filter`值的变化，导致`filteredTodos`计算值更新，并且`TodoList`观察者组件重新渲染。
- en: Example code
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter13/chapter13_1` folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter13/chapter13_1`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using MobX with Hooks
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MobX和Hooks
- en: In the previous section, we learned how to use MobX with React. As we have seen,
    to be able to connect our components to the MobX store, we need to wrap them with
    the `inject` function, and in some cases, also with the `observer` function. Instead
    of using these higher-order components to wrap our components, since the release
    of v6 of `mobx-react`, we can also use Hooks to connect our components to the
    MobX store. We are now going to use MobX with Hooks!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何在React中使用MobX。正如我们所见，为了能够将我们的组件连接到MobX存储，我们需要使用`inject`函数将它们包装起来，并且在某些情况下，还需要使用`observer`函数。自从`mobx-react`的v6版本发布以来，我们可以使用Hooks来连接我们的组件到MobX存储，而不是使用这些高阶组件来包装我们的组件。我们现在要使用MobX和Hooks！
- en: Defining a store Hook
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个存储Hook
- en: First of all, we have to define a Hook in order to access our own store. As
    we have learned before, MobX uses React Context to provide, and inject, state
    into various components. We can get the `MobXProviderContext` from `mobx-react` and
    create our own custom context Hook in order to access all stores. Then, we can
    create another Hook, to specifically access our `TodoStore`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义一个Hook以便访问我们自己的存储。正如我们之前学到的，MobX使用React Context来提供和注入状态到各种组件中。我们可以从`mobx-react`中获取`MobXProviderContext`并创建我们自己的自定义上下文Hook以便访问所有存储。然后，我们可以创建另一个Hook，专门访问我们的`TodoStore`。
- en: 'So, let''s begin defining a store Hook:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始定义一个存储Hook：
- en: Create a new `src/hooks.js` file.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks.js`文件。
- en: 'Import the `useContext` Hook from `react`, and the `MobXProviderContext` from
    `mobx-react`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`react`中导入`useContext` Hook，以及从`mobx-react`中导入`MobXProviderContext`：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we define and export a `useStores` Hook, which returns a Context Hook
    for the `MobXProviderContext`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义并导出一个`useStores` Hook，它返回一个用于`MobXProviderContext`的Context Hook：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we define a `useTodoStore` Hook, which gets the `todoStore` from our
    previous Hook, and then returns it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个`useTodoStore` Hook，它从我们之前的Hook中获取`todoStore`，然后返回它：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we have a general Hook, to access all stores from MobX, and a specific
    Hook to access the `TodoStore`. If we need to, we can also define more Hooks for
    other stores at a later point.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个通用的Hook，可以访问MobX的所有stores，以及一个特定的Hook来访问`TodoStore`。如果需要的话，我们也可以在以后定义更多的Hooks来访问其他stores。
- en: Upgrading components to Hooks
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级组件到Hooks
- en: After creating a Hook to access our store, we can use it instead of wrapping
    our components with the `inject` higher-order component function. In the upcoming
    sections, we will see how we can use Hooks to upgrade our various components.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Hook来访问我们的store后，我们可以使用它来代替用`inject`高阶组件函数包装我们的组件。在接下来的部分中，我们将看到如何使用Hooks来升级我们的各种组件。
- en: Using Hooks for the App component
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为App组件使用Hooks
- en: We are going to start by upgrading our `App` component. It is possible to gradually
    refactor components so that they use Hooks instead. We do not need to refactor
    every component at once.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从升级我们的`App`组件开始。逐渐重构组件，使其使用Hooks是可能的。我们不需要一次性重构每个组件。
- en: 'Let''s use Hooks for the `App` component now:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`App`组件使用Hooks：
- en: 'Edit `src/App.js` and remove the following `import` statement:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`并删除以下`import`语句：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, import the `useTodoStore` Hook from our `hooks.js` file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从我们的`hooks.js`文件中导入`useTodoStore` Hook：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, remove the `inject` function that is wrapping the `App` component, and
    remove all props. The `App` function definition should now look as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除包装`App`组件的`inject`函数，并删除所有props。`App`函数定义现在应该如下所示：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, use our Todo Store Hook to get the `todoStore` object:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用我们的Todo Store Hook来获取`todoStore`对象：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, our app still works in the same way as before! However, we are
    now using Hooks in the `App` component, which makes the code much more clean and
    concise.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的应用程序仍然以与以前相同的方式工作！然而，我们现在在`App`组件中使用Hooks，这使得代码更加清晰和简洁。
- en: Using Hooks for the TodoList component
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`TodoList`组件使用Hooks
- en: Next, we are going to upgrade our `TodoList` component. Additionally, we are
    also going to use the `useObserver` Hook, which replaces the `observer` higher-order
    component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将升级我们的`TodoList`组件。此外，我们还将使用`useObserver` Hook，它替换了`observer`高阶组件。
- en: 'Let''s use Hooks for the `TodoList` component now:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`TodoList`组件使用Hooks：
- en: 'Edit `src/TodoList.js`, and remove the following import statement:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoList.js`，并删除以下导入语句：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, import the `useObserver` Hook from `mobx-react` and the `useTodoStore` Hook
    from our `hooks.js` file:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从`mobx-react`中导入`useObserver` Hook，以及从我们的`hooks.js`文件中导入`useTodoStore` Hook：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, remove the `inject` and `observer` functions that are wrapping the `TodoList`
    component, and also remove all props. The `TodoList` function definition should
    now look as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除包装`TodoList`组件的`inject`和`observer`函数，并且也删除所有props。`TodoList`函数定义现在应该如下所示：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Again, we use the Todo Store Hook to get the `todoStore` object:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们使用Todo Store Hook来获取`todoStore`对象：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we wrap the returned elements with the `useObserver` Hook. Everything
    within the Observer Hook will be recomputed when the state that is used within
    the Hook changes:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用`useObserver` Hook包装返回的元素。在Observer Hook中的所有内容将在Hook中使用的状态发生变化时重新计算：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In our case, MobX will detect that the observer that was defined via the `useObserver` Hook
    depends on `todoStore.filteredTodos`, and `filteredTodos` depends on the `filter`
    and `todos` values. As a result, the list will be re-rendered whenever either
    the `filter` value or the `todos` array changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，MobX将检测到通过`useObserver` Hook定义的观察者依赖于`todoStore.filteredTodos`，而`filteredTodos`依赖于`filter`和`todos`值。因此，每当`filter`值或`todos`数组发生更改时，列表将重新渲染。
- en: Using Hooks for the TodoItem component
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`TodoItem`组件使用Hooks
- en: Next, we are going to upgrade the `TodoItem` component, which will be a similar
    process to what we did with the `TodoList` component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将升级`TodoItem`组件，这将是与`TodoList`组件相似的过程。
- en: 'Let''s use Hooks for the `TodoItem` component now:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`TodoItem`组件使用Hooks：
- en: 'Edit `src/TodoItem.js` and remove the following `import` statement:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoItem.js`并删除以下`import`语句：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, import the `useObserver` Hook from `mobx-react`, and the `useTodoStore` Hook
    from our `hooks.js` file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从`mobx-react`中导入`useObserver` Hook，从我们的`hooks.js`文件中导入`useTodoStore` Hook：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, remove the `inject` and `observer` functions that are wrapping the `TodoItem`
    component, and also remove the `todoStore` prop. The `TodoItem` function definition
    should now look as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除包裹`TodoItem`组件的`inject`和`observer`函数，也删除`todoStore`属性。`TodoItem`函数定义现在应该如下所示：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we have to remove the destructuring (the code in bold) because our whole
    component is not defined as observable anymore, so MobX will not be able to track
    the changes to the `item` object:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须删除解构（粗体代码），因为我们整个组件不再被定义为可观察的，因此MobX将无法跟踪`item`对象的更改：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, use the Todo Store Hook to get the `todoStore` object:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用Todo Store Hook来获取`todoStore`对象：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we have to adjust the handler functions so that they use `item.id` instead
    of `id` directly. Please note that we assume that the `id` does not change, therefore,
    it is not wrapped within an Observer Hook:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须调整处理函数，使其直接使用`item.id`而不是`id`。请注意，我们假设`id`不会改变，因此它不会被包裹在Observer Hook中：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we wrap the `return` statement with an Observer Hook and do the destructuring
    there. This ensures that changes to the `item` object are tracked by MobX, and
    that the component will re-render accordingly when the properties of the object
    change:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用Observer Hook包裹`return`语句并在那里进行解构。这确保了MobX会跟踪`item`对象的更改，并且当对象的属性更改时，组件将相应地重新渲染：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, our `TodoItem` component is properly connected to the MobX store.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`TodoItem`组件已经正确连接到MobX存储。
- en: 'If the `item.id` property changes, we would have to wrap the handler functions,
    and the `return` function, within a single `useObserver` Hook, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`item.id`属性发生更改，我们将不得不将处理函数和`return`函数包裹在单个`useObserver` Hook中，如下所示：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we cannot wrap the handler functions and the `return` statement in
    separate Observer Hooks, because then the handler functions would only be defined
    within the closure of the first Observer Hook. This would mean that we would not
    be able to access the handler functions from within the second Observer Hook.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能将处理函数和`return`语句分别包裹在单独的Observer Hooks中，因为这样处理函数将只在第一个Observer Hook的闭包内定义。这意味着我们将无法从第二个Observer
    Hook内访问处理函数。
- en: Next, we are going to continue to upgrade our components by using Hooks for
    the `AddTodo` component.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续通过使用Hooks来升级`AddTodo`组件的组件。
- en: Using Hooks for the AddTodo component
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`AddTodo`组件使用Hooks
- en: 'We repeat the same upgrade process as we did in the `App` component for the
    `AddTodo` component, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复与`App`组件中相同的升级过程，用于`AddTodo`组件，如下所示：
- en: 'Edit `src/AddTodo.js` and remove the following `import` statement:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/AddTodo.js`并删除以下`import`语句：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, import the `useTodoStore` Hook from our `hooks.js` file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从我们的`hooks.js`文件中导入`useTodoStore` Hook：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, remove the `inject` function that is wrapping the `AddTodo` component,
    and also remove all props. The `AddTodo` function definition should now look as
    follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除包装`AddTodo`组件的`inject`函数，也删除所有props。`AddTodo`函数定义现在应该如下所示：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, use the Todo Store Hook to get the `todoStore` object:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用Todo Store Hook来获取`todoStore`对象：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, our `AddTodo` component is connected to the MobX store and we can move
    on to upgrading the `TodoFilter` component.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`AddTodo`组件已连接到MobX存储，我们可以继续升级`TodoFilter`组件。
- en: Using Hooks for the TodoFilter component
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks来处理`TodoFilter`组件
- en: For the `TodoFilter` component, we are going to use a similar process to the
    one that we used for the `TodoList` component. We are going to use our `useTodoStore` Hook
    and the `useObserver` Hook.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TodoFilter`组件，我们将使用类似于我们用于`TodoList`组件的过程。我们将使用我们的`useTodoStore` Hook和`useObserver`
    Hook。
- en: 'Let''s use Hooks for the `TodoFilter` component now:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`TodoFilter`组件使用Hooks：
- en: 'Edit `src/TodoFilter.js` and remove the following `import` statement:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoFilter.js`并删除以下`import`语句：
- en: '[PRE67]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, import the `useObserver` Hook from `mobx-react`, and the `useTodoStore` Hook
    from our `hooks.js` file:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从`mobx-react`导入`useObserver` Hook，以及从我们的`hooks.js`文件中导入`useTodoStore` Hook：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, remove the `inject` and `observer` functions that are wrapping the `TodoFilterItem`
    component, and also remove the `todoStore` prop. The `TodoFilterItem` function
    definition should now look as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除包装`TodoFilterItem`组件的`inject`和`observer`函数，也删除`todoStore` prop。`TodoFilterItem`函数定义现在应该如下所示：
- en: '[PRE69]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Again, we use the Todo Store Hook to get the `todoStore` object:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们使用Todo Store Hook来获取`todoStore`对象：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, we wrap the `style` object with the `useObserver` Hook. Remember,
    everything within the Observer Hook will be re-computed when the state that is
    used within the Hook changes:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`useObserver` Hook将`style`对象包装起来。请记住，Observer Hook内的所有内容都将在Hook中使用的状态发生变化时重新计算：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this case, the `style` object will be re-computed whenever the `todoStore.filter`
    value changes, which will cause the element to re-render, and change the font
    weight when a different filter is selected.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当`todoStore.filter`值发生变化时，`style`对象将被重新计算，这将导致元素重新渲染，并在选择不同的过滤器时更改字体加粗。
- en: Example code
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter13/chapter13_2` folder.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter13/chapter13_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using the local store Hook
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地存储Hook
- en: In addition to providing global stores to store application-wide state, MobX
    also provides local stores to store local state. To create a local store, we can
    use the `useLocalStore` Hook.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供全局存储以存储应用程序范围的状态外，MobX还提供了本地存储以存储本地状态。要创建本地存储，我们可以使用`useLocalStore` Hook。
- en: 'We are now going to implement the Local Store Hook in the `AddTodo` component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`AddTodo`组件中实现Local Store Hook：
- en: 'Edit `src/AddTodo.js` and import the `useLocalStore` Hook, as well as the `useObserver` Hook
    from `mobx-react`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/AddTodo.js`并导入`useLocalStore` Hook，以及从`mobx-react`导入`useObserver` Hook：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, remove the following State Hook:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，删除以下State Hook：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Replace it with a Local Store Hook:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 用本地存储Hook替换它：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this local store, we can define state values, computed values, and actions.
    The `useLocalStore` Hook will automatically decorate values as observable, getter
    functions (the `get` prefix) as computed values, and normal functions as actions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个本地存储中，我们可以定义状态值、计算值和动作。`useLocalStore` Hook将自动将值装饰为可观察的，getter函数（`get`前缀）作为计算值，普通函数作为动作。
- en: 'We start with a `value` state for the `input` field:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`input`字段的`value`状态开始：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, we define a computed value, which will tell us whether the add button
    should be `disabled` or not:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个计算值，它将告诉我们添加按钮是否应该被`disabled`：
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we define the actions. The first action updates the `value` from an input
    event:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义动作。第一个动作从输入事件更新`value`：
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, we define another action to update the `value` from a simple string:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义另一个动作来更新`value`，从一个简单的字符串：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we can adjust the input handler function, and call the `updateFromInput`
    action:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以调整输入处理函数，并调用`updateFromInput`动作：
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We also have to adjust the `handleAdd` function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整`handleAdd`函数：
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we wrap the elements with a `useObserver` Hook, in order to make sure
    that the `input` field value gets updated when it changes, and we adjust the `disabled`
    and `value` props:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用`useObserver` Hook包装元素，以确保`input`字段的值在更改时得到更新，并调整`disabled`和`value`属性：
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, our `AddTodo` component uses a local MobX store in order to handle its
    input value, and to disable/enable the button. As you can see, with MobX, it is
    possible to use multiple stores, for local as well as global states. The hard
    part is deciding how to split up and group your stores in a way that makes sense
    for the given application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`AddTodo`组件使用一个本地MobX存储来处理其输入值，并禁用/启用按钮。如你所见，使用MobX，可以使用多个存储，用于本地和全局状态。难点在于决定如何分割和分组你的存储，以使其对给定应用程序有意义。
- en: Example code
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter13/chapter13_3` folder.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter13/chapter13_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Migrating a MobX application
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移MobX应用程序
- en: In the previous section, we learned how to replace MobX higher-order components,
    such as `inject` and `observer` in existing MobX applications with Hooks. Now,
    we are going to learn how to migrate local state to Hooks in existing MobX applications.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何用Hooks替换现有MobX应用程序中的MobX高阶组件，如`inject`和`observer`。现在，我们将学习如何将现有MobX应用程序中的本地状态迁移到Hooks中。
- en: 'An existing MobX application can be migrated to a Hook-based solution by following
    three steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下三个步骤，可以将现有的MobX应用程序迁移到基于Hook的解决方案：
- en: Using a State Hook for simple local state
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用State Hook处理简单的本地状态
- en: Using the `useLocalState` Hook for complex local state
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useLocalState` Hook处理复杂的本地状态
- en: Keeping global state in separate MobX stores
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局状态保留在单独的MobX存储中
- en: We have already learned how to use a State Hook in the early chapters of this
    book. State Hooks make sense for simple state, such as the current state of a
    checkbox.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在本书的早期章节中使用State Hook。State Hooks对于简单的状态，比如复选框的当前状态，是有意义的。
- en: We have already learned how to use the `useLocalState` Hook in this chapter.
    We can use the Local State Hook for complex local state, such as complex forms
    where multiple fields interact with each other. Then, we can replace multiple
    State and Effect Hooks with a single Local State Hook and computed values and
    actions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中学习了如何使用`useLocalState` Hook。我们可以使用本地状态Hook处理复杂的本地状态，比如多个字段相互交互的复杂表单。然后，我们可以用单个本地状态Hook替换多个State和Effect
    Hooks以及计算值和动作。
- en: Lastly, global state should be stored in separate MobX stores, such as the `TodoStore`,
    which we defined in this chapter. In MobX, multiple stores can be created and
    passed down to components using the `Provider` component. We can then create a
    separate custom Hook for each of the stores.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，全局状态应该存储在单独的MobX存储中，例如在本章中定义的`TodoStore`。在MobX中，可以创建多个存储并使用`Provider`组件传递给组件。然后我们可以为每个存储创建一个单独的自定义Hook。
- en: The trade-offs of MobX
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX的权衡取舍
- en: 'To wrap up, let''s summarize the pros and cons of using MobX in a web application.
    First, let''s start with the positives:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，让我们总结在Web应用程序中使用MobX的利弊。首先，让我们从积极方面开始：
- en: It provides a simple way of dealing with state changes
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种简单的处理状态变化的方式
- en: Less boilerplate code is required
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更少的样板代码
- en: It offers flexibility in how our application code is structured
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了灵活性，可以结构化我们的应用程序代码
- en: Multiple global and local stores can be used
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用多个全局和本地存储
- en: It makes the `App` component much simpler (it offloads state management and
    actions to MobX)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使`App`组件更简单（它将状态管理和操作转移到MobX）
- en: MobX is perfect for small—and large projects—that deal with complex state changes,
    and state that is used across many components.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: MobX非常适合处理复杂状态变化和在许多组件中使用的状态的小型和大型项目。
- en: 'However, there are also downsides to using MobX:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用MobX也有缺点：
- en: State changes could happen anywhere, not just in a single store
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变化可能发生在任何地方，不仅仅是在单个存储中
- en: Its flexibility means that it is possible to structure the project in a bad
    way, which could cause errors or bugs
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的灵活性意味着可能以不好的方式构建项目，这可能会导致错误或缺陷
- en: MobX requires a wrapper component (`Provider`) in order to connect the app to
    the store, if we want to get all the features (we could directly import and use
    the MobX store, but it would break features such as server-side rendering)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX需要一个包装组件（`Provider`）来连接应用程序到存储，如果我们想要获得所有功能（我们可以直接导入和使用MobX存储，但这将破坏诸如服务器端渲染之类的功能）
- en: If state changes are simple, and only local state within components is needed,
    MobX should not be used. In that case, a State or a Reducer Hook might be enough.
    With Reducer and State Hooks, there is no need for wrapper components in order
    to connect our app to the store.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态变化很简单，并且只需要组件内部的本地状态，就不应该使用MobX。在这种情况下，状态或Reducer Hook可能足够了。使用Reducer和State
    Hooks，我们不需要包装组件来连接我们的应用程序到存储。
- en: Flexibility is a good thing, but it can also cause us to structure a project
    badly. However, MobX provides a project called `mobx-state-tree`, which allows
    us to make our MobX applications more structured and enforce a certain kind of
    architecture. More information can be found on the project page in the following
    GitHub repository: [https://github.com/mobxjs/mobx-state-tree](https://github.com/mobxjs/mobx-state-tree).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性是一件好事，但它也可能导致我们不好地构建项目。然而，MobX提供了一个名为`mobx-state-tree`的项目，它允许我们使我们的MobX应用程序更有结构并强制执行某种类型的架构。更多信息可以在以下GitHub存储库的项目页面中找到：[https://github.com/mobxjs/mobx-state-tree](https://github.com/mobxjs/mobx-state-tree)。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first learned what MobX is, which elements it consists of,
    and how they work together. Then, we learned how to use MobX for state management
    in practice. We also learned how to connect a MobX store to React components,
    by using the `inject` and `observer` higher-order components. Next, we replaced
    the higher-order components with Hooks, which made our code much more clean and
    concise. We also learned how to use a Local Store Hook to deal with complex local
    state in MobX. Finally, we learned how to migrate an existing MobX application
    to Hooks, and we recapped what the trade-offs of using MobX are.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了MobX是什么，它由哪些元素组成，以及它们如何一起工作。然后，我们学习了如何在实践中使用MobX进行状态管理。我们还学习了如何将MobX存储与React组件连接起来，使用`inject`和`observer`高阶组件。接下来，我们用Hooks替换了高阶组件，使我们的代码更加清晰简洁。我们还学习了如何使用Local
    Store Hook处理MobX中复杂的本地状态。最后，我们学习了如何将现有的MobX应用迁移到Hooks，并总结了使用MobX的权衡。
- en: This chapter marks the end of this book. In this book, we started out with a
    motivation to use Hooks. We learned that there are common problems in React apps
    that cannot be easily solved without Hooks. Then, we created our first component
    using Hooks and compared it to a class-component-based solution. Next, we learned
    about various Hooks in depth, starting with the State Hook, which is the most
    ubiquitous of them all. We also learned about solving common problems with Hooks,
    such as conditional Hooks and Hooks in loops.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书的结束。在本书中，我们从动机开始使用Hooks。我们了解到在React应用中有一些常见问题，如果没有Hooks，很难解决。然后，我们使用Hooks创建了我们的第一个组件，并将其与基于类的组件解决方案进行了比较。接下来，我们深入学习了各种Hooks，从最常见的State
    Hook开始。我们还学习了如何使用Hooks解决常见问题，例如条件性Hooks和循环中的Hooks。
- en: After learning about the State Hook in depth, we developed a small blog app
    using Hooks. We then learned about Reducer Hooks, Effect Hooks, and Context Hooks,
    in order to be able to implement more features in our app. Next, we learned how
    to request resources efficiently using Hooks. Furthermore, we learned how to prevent
    unnecessary re-rendering with `React.memo`, and how to implement lazy-loading
    with React Suspense. Then, we implemented routes in our blog app, and we learned
    how Hooks can make dynamic routing much easier.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入学习了State Hook之后，我们使用Hooks开发了一个小型博客应用。然后，我们学习了Reducer Hooks、Effect Hooks和Context
    Hooks，以便能够在我们的应用中实现更多功能。接下来，我们学习了如何使用Hooks有效地请求资源。此外，我们学习了如何使用`React.memo`防止不必要的重新渲染，以及如何使用React
    Suspense实现延迟加载。然后，我们在我们的博客应用中实现了路由，并学习了Hooks如何使动态路由变得更加容易。
- en: We also learned about various Hooks that are provided by the community, which
    make dealing with input fields, various data structures, responsive design, and
    undo/redo functionality so much easier. Furthermore, we learned about the rules
    of Hooks, how to create our own custom Hooks, and how interactions between Hooks
    work. Toward the end, we learned how to effectively migrate from existing class-component-based
    apps, to a Hook-based solution. Finally, we learned how to use Hooks with Redux
    and MobX, and how to migrate existing Redux and MobX applications to Hooks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了社区提供的各种Hooks，这些Hooks使处理输入字段、各种数据结构、响应式设计和撤销/重做功能变得更加容易。此外，我们学习了Hooks的规则，如何创建我们自己的自定义Hooks，以及Hooks之间的交互方式。最后，我们学习了如何有效地从现有的基于类的应用迁移到基于Hooks的解决方案。最后，我们学习了如何将Hooks与Redux和MobX一起使用，以及如何将现有的Redux和MobX应用迁移到Hooks。
- en: Now that we have learned about Hooks in depth, we are ready to use them in our
    applications! We have also learned how to migrate existing projects to Hooks,
    so we can start doing that now. I hope you enjoyed learning about React Hooks,
    and that you are looking forward to implementing Hooks in your applications! I
    am sure that using Hooks will make coding much more enjoyable for you, just like
    they did for me.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入了解了Hooks，我们准备在我们的应用程序中使用它们！我们还学会了如何将现有项目迁移到Hooks，所以我们现在可以开始做这个。我希望你喜欢学习React
    Hooks，并且期待在你的应用程序中实现Hooks！我相信使用Hooks会让编码对你来说更加愉快，就像对我一样。
- en: Questions
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们在本章学到的内容，请尝试回答以下问题：
- en: Which elements form the MobX life cycle?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些元素构成MobX生命周期？
- en: Which decorators does MobX provide?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobX提供哪些装饰器？
- en: How can we connect components to MobX?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将组件连接到MobX？
- en: Which Hooks does MobX provide?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobX提供哪些Hooks？
- en: How can we access the MobX store using Hooks?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Hooks访问MobX存储？
- en: Can we store local state using MobX?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用MobX存储本地状态吗？
- en: How should we go about migrating an existing MobX application to Hooks?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该如何将现有的MobX应用程序迁移到Hooks？
- en: What are the advantages of using MobX?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MobX的优点是什么？
- en: What are the disadvantages of using MobX?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MobX有哪些缺点？
- en: When should MobX not be used?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时不应该使用MobX？
- en: Further reading
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following reading material:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章学习的概念更多信息感兴趣，请查看以下阅读材料：
- en: An introduction to MobX from the official MobX docs: [https://mobx.js.org/getting-started.html](https://mobx.js.org/getting-started.html)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自官方MobX文档的MobX简介：[https://mobx.js.org/getting-started.html](https://mobx.js.org/getting-started.html)
- en: The official MobX docs: [https://mobx.js.org](https://mobx.js.org)
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方MobX文档：[https://mobx.js.org](https://mobx.js.org)
- en: A video course on the basics of MobX: [https://egghead.io/lessons/react-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react](https://egghead.io/lessons/react-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于MobX基础知识的视频课程：[https://egghead.io/lessons/react-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react](https://egghead.io/lessons/react-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react)
- en: The official MobX React docs: [https://mobx-react.js.org/](https://mobx-react.js.org/)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方MobX React文档：[https://mobx-react.js.org/](https://mobx-react.js.org/)
- en: The `mobx` project on GitHub: [https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的`mobx`项目：[https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx)
- en: The `mobx-react` project on GitHub: [https://github.com/mobxjs/mobx-react](https://github.com/mobxjs/mobx-react)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的`mobx-react`项目：[https://github.com/mobxjs/mobx-react](https://github.com/mobxjs/mobx-react)
- en: The `mobx-state-tree` project on GitHub: [https://github.com/mobxjs/mobx-state-tree](https://github.com/mobxjs/mobx-state-tree)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的`mobx-state-tree`项目：[https://github.com/mobxjs/mobx-state-tree](https://github.com/mobxjs/mobx-state-tree)
