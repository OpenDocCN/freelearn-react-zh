- en: Interacting with GraphQL APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GraphQL API交互
- en: GraphQL is an open source web API language for reading and writing data that
    is maintained by Facebook. It allows the client to specify exactly what data is
    returned and request multiple data areas in a single request. This efficiency
    and flexibility makes it a compelling alternative to a REST API. GraphQL also
    supports both reading and writing data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是由Facebook维护的用于读取和写入数据的开源Web API语言。它允许客户端指定返回的数据，并在单个请求中请求多个数据区域。这种效率和灵活性使其成为REST
    API的一个引人注目的替代方案。GraphQL还支持读取和写入数据。
- en: In this chapter, we'll start by experimenting with some GraphQL queries against
    GitHub to get familiar with the syntax by using the *GitHub GraphQL API* explorer.
    We'll explore how we both read and write GraphQL data and how to specify exactly
    the way we want the data in the response returned to us.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始尝试针对GitHub进行一些GraphQL查询，以熟悉使用*GitHub GraphQL API*资源管理器的语法。我们将探讨如何读取和写入GraphQL数据，以及如何精确指定我们希望在响应中返回的数据方式。
- en: We'll then consume the GitHub GraphQL server in a React and TypeScript application
    to build a little app that searches for a GitHub repository and returns some information
    about it. We'll use our knowledge from the last chapter on `axios` to interact
    with the GitHub GraphQL server to start off with. We'll then switch to using Apollo,
    which is a client library that makes interacting with GraphQL servers a breeze.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在React和TypeScript应用程序中使用GitHub GraphQL服务器，构建一个小应用程序，该应用程序搜索GitHub存储库并返回有关其的一些信息。我们将使用上一章关于`axios`的知识与GitHub
    GraphQL服务器进行交互。然后我们将转而使用Apollo，这是一个使与GraphQL服务器交互变得轻而易举的客户端库。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: GraphQL query and mutation syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL查询和变异语法
- en: Using axios as a GraphQL client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用axios作为GraphQL客户端
- en: Using Apollo GraphQL client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apollo GraphQL客户端
- en: Working with cached data in Apollo
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apollo中使用缓存数据
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We use the following technologies in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用以下技术：
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和** `npm`：TypeScript和React依赖于这些。我们可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装它们。如果我们已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要在Visual
    Studio Code中安装 TSLint (by egamma) 和 Prettier (by Estben Petersen) 扩展。'
- en: '**GitHub**: We''ll need a GitHub account. We can sign up at the following link
    if we haven''t got an account: [https://github.com/join](https://github.com/join).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**：我们需要一个GitHub账户。如果我们还没有账户，可以在以下链接注册：[https://github.com/join](https://github.com/join)。'
- en: '**GitHub GraphQL API Explorer**: We''ll use this tool to play with the syntax
    of GraphQL queries and mutations. The tool is at [https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub GraphQL API Explorer**：我们将使用此工具来玩转GraphQL查询和变异的语法。该工具位于[https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/)。'
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/10-GraphAPIs](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/10-GraphAPIs).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/10-GraphAPIs](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/10-GraphAPIs)上找到。
- en: GraphQL query and mutation syntax
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL查询和变异语法
- en: In this section, we'll use the GitHub GraphQL API explorer to start to get familiar
    with the syntax for interacting with a GraphQL server, starting with reading data
    in the next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用GitHub GraphQL API资源浏览器开始熟悉与GraphQL服务器交互的语法，从下一节开始阅读数据。
- en: Reading GraphQL data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读GraphQL数据
- en: In order to read GraphQL data, we make what is called a query. In this section,
    we'll start by covering the basic GraphQL syntax and move on to how to include
    nested objects in a query result, and then how we can create reusable queries
    by allowing parameters to be passed into them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取GraphQL数据，我们进行所谓的查询。在本节中，我们将首先介绍基本的GraphQL语法，然后讨论如何在查询结果中包含嵌套对象，以及如何通过允许传递参数来创建可重用的查询。
- en: Basic query
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本查询
- en: 'In this section, we''ll use the GitHub GraphQL API explorer to get information
    about our GitHub user account:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用GitHub GraphQL API资源浏览器来获取有关我们的GitHub用户帐户的信息：
- en: 'Let''s open the following URL in a browser to open the tool:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在浏览器中打开以下URL以打开工具：
- en: '[https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/)。'
- en: We will need to be signed in to our GitHub account if we aren't already.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有登录GitHub帐户，我们将需要登录。
- en: 'In the panel in the top-left corner, let''s enter the following and click the
    Execute Query button:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角的面板中，让我们输入以下内容，然后点击执行查询按钮：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is our first GraphQL query. Here are some key points:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个GraphQL查询。以下是一些关键点：
- en: We prefix a query with the `query` keyword. This is actually optional.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`query`关键字作为查询的前缀。这实际上是可选的。
- en: '`viewer` is the name of the object we want to get.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewer`是我们想要获取的对象的名称。'
- en: '`name` is a field within `viewer` that we want to return.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是我们想要返回的`viewer`中的一个字段。'
- en: 'The query result will appear on the right-hand side:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果将显示在右侧：
- en: '![](assets/e28c0b49-4f11-4210-95b6-0f3054189947.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e28c0b49-4f11-4210-95b6-0f3054189947.png)'
- en: The data we requested is returned as a JSON object. The JSON contains a `data`
    object that contains a `viewer` object containing the `name` field. The `name`
    value should be our name, since this is the name stored in our GitHub account.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求的数据以JSON对象的形式返回。JSON包含一个包含`name`字段的`viewer`对象的`data`对象。`name`的值应该是我们的名字，因为这是存储在我们的GitHub帐户中的名字。
- en: 'On the right-hand side of the results pane there is a Docs link. If we click
    this link, a Documentation Explorer appears:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果窗格的右侧有一个文档链接。如果我们点击这个链接，会出现一个文档资源浏览器：
- en: '![](assets/7cbedebe-ec72-4b09-943f-c263da3b8b0f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7cbedebe-ec72-4b09-943f-c263da3b8b0f.png)'
- en: If we then click on the Query link, all the objects are shown that can be queried,
    including `viewer`, which is the one we just queried. If we click into this, we
    see all the fields that are available within `viewer`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击查询链接，将显示可以查询的所有对象，包括`viewer`，这是我们刚刚查询的对象。如果我们点击进入这个对象，我们将看到`viewer`中可用的所有字段。
- en: 'Let''s add `avatarUrl` to our query, as this is an additional field available
    to us:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`avatarUrl`添加到我们的查询中，因为这是我们可以使用的另一个字段：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, we simply add the `avatarUrl` field inside the `viewer` object with a carriage
    return between the `name` and `avatarUrl` fields. If we execute the query, we
    see `avatarUrl` added to the JSON result. This should be a path to an image of
    us.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需在`name`和`avatarUrl`字段之间加上一个换行符，将`avatarUrl`字段添加到`viewer`对象中。如果我们执行查询，我们将看到`avatarUrl`添加到JSON结果中。这应该是我们的图像的路径。
- en: So, we are already seeing how flexible GraphQL is with being able to specify
    exactly which fields we want returned in the response. In the next section, we'll
    take this further by specifying the nested objects we want to return.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了GraphQL的灵活性，可以精确指定我们希望在响应中返回哪些字段。在下一节中，我们将进一步指定我们希望返回的嵌套对象。
- en: Returning nested data
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回嵌套数据
- en: 'Let''s make a far more complex query in this section. We''ll search for a GitHub
    repository, return information about it, including the number of stars it has
    and the last issues that have been raised as a nested array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本节中进行更复杂的查询。我们将搜索GitHub存储库，返回有关它的信息，包括它拥有的星星数量以及最近提出的问题作为嵌套数组：
- en: 'Let''s start by entering the following query and executing it:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始输入以下查询并执行它：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time, we are asking for the `repository` object, but passing two parameters
    for the `owner` and `name` of the repository. We are asking for the `name` and
    `description` of the repository to be returned.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们要求`repository`对象，但传递了`owner`和`name`存储库的两个参数。我们要求返回存储库的`name`和`description`。
- en: 'We see that the repository and fields we asked for are returned:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到返回了我们请求的存储库和字段：
- en: '![](assets/820b1074-0293-4302-9c53-61794fbc8f16.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/820b1074-0293-4302-9c53-61794fbc8f16.png)'
- en: 'Let''s now request the number of stars against the repository. To do this,
    we ask for the `totalCount` field within the `stargazers` nested object:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们请求存储库的星星数量。为此，我们要求`stargazers`嵌套对象中的`totalCount`字段：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we execute the query, we see these results returned:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行查询，我们会看到返回的结果：
- en: '![](assets/66b94c04-5c0b-48b1-8c09-29d091fb8cdd.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/66b94c04-5c0b-48b1-8c09-29d091fb8cdd.png)'
- en: 'Let''s now add an alias to `totalCount` within `stargazers`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们给`stargazers`中的`totalCount`添加一个别名：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we execute the query, we see the stars count is returned against the alias
    we specified:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行查询，我们会看到星星数量返回到我们指定的别名：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s move on to requesting the last `5` issues within the repository:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续请求存储库中的最后`5`个问题：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We request the `issues` object by passing `5` into the last parameter. We then
    request an `edges` object containing a `node` object that in turn contains the
    issue fields we are interested in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`5`传递到最后一个参数来请求`issues`对象。然后，我们请求包含我们感兴趣的问题字段的`edges`对象中的`node`对象。
- en: So, what are the `edges` and `node` objects? Why can't we just request the fields
    we want directly? Well, this structure is in place to facilitate cursor-based
    pagination.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`edges`和`node`对象是什么？为什么我们不能直接请求我们想要的字段？嗯，这种结构是为了方便基于游标的分页。
- en: If we execute the query, we get the last `5` issues included in our result.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行查询，我们会得到结果中包含的最后`5`个问题。
- en: So, GraphQL allows us to make a single web request for different bits of data
    returning just the fields we require. Doing a similar thing with the GitHub REST
    API would probably require multiple requests and we'd get a lot more data than
    we need returned to us. It is these types of queries where GraphQL shines over
    REST.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GraphQL允许我们为不同的数据部分进行单个网络请求，只返回我们需要的字段。使用GitHub REST API进行类似的操作可能需要多个请求，并且我们会得到比我们需要的更多的数据。在这些类型的查询中，GraphQL比REST更出色。
- en: Query parameters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询参数
- en: 'The query we have just made is hardcoded to get data for a specific repository.
    In this section, we''ll define variables in the query, which essentially allow
    parameters to be passed into it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚进行的查询是硬编码的，用于获取特定存储库的数据。在本节中，我们将在查询中定义变量，这些变量基本上允许将参数传递给它：
- en: 'We can add query variables in parentheses after the `query` keyword, separated
    by commas. Each parameter is defined by declaring its name with its type after
    a semicolon. This is similar to defining parameters in a TypeScript function with
    type annotations. The variable names need to be prefixed with `$`. The `!` after
    the type signifies that this is required. So, in our case, both variables are
    required in order for the query to be executed. The variables can then be referenced
    within the query, which, in our case, is where we request the repository object:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`query`关键字后的括号中添加查询变量，用逗号分隔。每个参数都通过在分号后声明其类型来定义其名称。这类似于在TypeScript函数中使用类型注释定义参数。变量名需要以`$`为前缀。类型后面的`!`表示这是必需的。因此，在我们的情况下，为了执行查询，这两个变量都是必需的。然后可以在查询中引用这些变量，在我们的例子中，这是我们请求存储库对象的地方：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before we execute the query, we need to specify the variable values. We do
    this in the Query Variables pane in the bottom-left corner in a JSON object:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行查询之前，我们需要指定变量值。我们在左下角的查询变量窗格中以JSON对象的形式进行此操作：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we execute the query, we get the results for the repository we asked for:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们执行查询，我们将得到我们请求的存储库的结果：
- en: '![](assets/d36c468d-b097-46fb-84b8-70003a910a11.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d36c468d-b097-46fb-84b8-70003a910a11.png)'
- en: We are now getting comfortable with reading data from a GraphQL server. But
    how can we create new data items or update data? We'll find out in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经开始习惯从GraphQL服务器中读取数据。但是我们如何创建新的数据项或更新数据呢？我们将在下一节中找到答案。
- en: Writing GraphQL data
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写GraphQL数据
- en: 'Let''s turn our attention to writing to a GraphQL server now. We do this with
    what are called mutations. In this section, we''ll create a `mutation` to add
    a GitHub star to a repository:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向写入GraphQL服务器。我们可以通过所谓的mutations来实现这一点。在本节中，我们将创建一个`mutation`来向存储库添加GitHub星标：
- en: 'In order to star a repository, we need the repository `id`. So, let''s add
    this to the query we have been working on to get this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了收藏一个存储库，我们需要存储库的`id`。因此，让我们将这个添加到我们一直在工作的查询中：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s copy the `id` that is returned in the result. The `id` for the React
    repository is the shown in the following:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制结果中返回的`id`。React存储库的`id`如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now write our first `mutation`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以写我们的第一个`mutation`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are some key points on this `mutation`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个`mutation`的一些关键点：
- en: We prefix a mutation with the `mutation` keyword.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用`mutation`关键字作为前缀来定义一个mutation。
- en: We put parameters to be passed into the `mutation` after the `mutation` keyword
    in parentheses. In our case, we have a single parameter for the repository `id`
    we want to star.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要传递给`mutation`的参数放在`mutation`关键字后面的括号中。在我们的例子中，我们为要收藏的存储库`id`设置了一个参数。
- en: '`addStar` is the `mutation` function we are calling, which has a parameter
    called `input` that we need to pass to it.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addStar`是我们正在调用的`mutation`函数，它有一个名为`input`的参数，我们需要传递给它。'
- en: '`input` is actually an object that has a field called `starrableId` we need
    to include. The value of this is the repository `id` we want to star, so we set
    it to our repository `id` variable `$repoId`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`实际上是一个对象，其中包含一个名为`starrableId`的字段，我们需要包含它。其值是我们要收藏的存储库`id`，因此我们将其设置为我们的存储库`id`变量`$repoId`。'
- en: After the `mutation` parameters, we can specify what we want returned in the
    response. In our case, we want to return the number of stars on the repository.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`mutation`参数之后，我们可以指定我们希望在响应中返回什么。在我们的例子中，我们希望返回存储库上的星星数量。
- en: 'We can specify the parameter value for the repository `id` in the Query Variables
    pane:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在查询变量窗格中指定存储库`id`的参数值：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we execute the `mutation`, the star will be added to the repository and
    the new total number of stars will be returned:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们执行`mutation`，星星将被添加到存储库中，并且新的总星星数量将被返回：
- en: '![](assets/752ea09d-7729-43ef-b88a-b1ad8cb04a40.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/752ea09d-7729-43ef-b88a-b1ad8cb04a40.png)'
- en: We have a good grasp on both GraphQL queries and mutations now. In the next
    section, we'll start to interact with a GraphQL server from a React and TypeScript
    app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对GraphQL查询和变异都有了很好的掌握。在下一节中，我们将开始从React和TypeScript应用程序与GraphQL服务器进行交互。
- en: Using axios as a GraphQL client
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios作为GraphQL客户端
- en: Interacting with a GraphQL server is done via HTTP. We learned in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml),* Interacting
    with Restful APIs*, that `axios` is a great HTTP client. So, in this chapter,
    we'll cover how to interact with a GraphQL server using `axios`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与GraphQL服务器的交互是通过HTTP完成的。我们在[第9章](c4badffb-0c23-40cc-878c-8b598d427227.xhtml)中学到，*与Restful
    API交互*，`axios`是一个很好的HTTP客户端。因此，在本章中，我们将介绍如何使用`axios`与GraphQL服务器进行交互。
- en: To help us learn, we'll create a React and TypeScript app to return information
    about our GitHub account. So, our first tasks are to get a token that will give
    us access to query the GitHub GraphQL server and scaffold a React and TypeScript
    app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们学习，我们将创建一个React和TypeScript应用程序来返回有关我们GitHub帐户的信息。因此，我们的第一个任务是获取一个令牌，以便我们可以访问查询GitHub
    GraphQL服务器并搭建一个React和TypeScript应用程序。
- en: Getting a GitHub personal access token
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成GitHub个人访问令牌
- en: 'The GitHub GraphQL server requires a bearer token for us to interact with it.
    So, let''s go and generate a personal access token:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub GraphQL服务器需要一个令牌才能与其进行交互。所以，让我们去生成一个个人访问令牌：
- en: Let's sign in to our GitHub account and go to our Settings page by opening the
    menu under our avatar and choosing Settings.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们登录到我们的GitHub帐户，并通过打开头像下的菜单并选择设置来进入我们的设置页面。
- en: In the left-hand menu, we then need to choose the Developer settings option.
    This will take us to the Developer settings page.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，我们需要选择开发者设置选项。这将带我们到开发者设置页面。
- en: We can then choose the Personal access tokens option in the left-hand menu.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在左侧菜单中选择个人访问令牌选项。
- en: We will then see a Generate new token button that we can click to generate our
    bearer token. We will likely be prompted to input our password after clicking
    the button.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将看到一个生成新令牌的按钮，我们可以点击它来生成我们的令牌。点击按钮后，我们可能会被提示输入密码。
- en: Before the token is generated, we are asked to specify the scopes. Let's enter
    a token description, tick repo and user, and then click the Generate token button.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成令牌之前，我们被要求指定范围。让我们输入一个令牌描述，选中repo和user，然后点击生成令牌按钮。
- en: The token is then generated and displayed in the page for us to copy and use
    in our React app.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后生成的令牌将显示在页面上供我们复制并在我们的React应用程序中使用。
- en: Now that we have our bearer token, let's scaffold a React and TypeScript app
    in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了我们的令牌，让我们在下一节中搭建一个React和TypeScript应用程序。
- en: Creating our app
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'We''ll follow the usual steps for scaffolding a React and TypeScript app:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照通常的步骤来搭建一个React和TypeScript应用程序：
- en: 'Let''s open Visual Studio Code in a folder of our choice and open the terminal.
    Let''s enter the following command to create a new React and TypeScript project:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们选择的文件夹中打开Visual Studio Code并打开终端。让我们输入以下命令来创建一个新的React和TypeScript项目：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json`
    is less than `16.7.0-alpha.0`, then we can install this version using the following
    command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的React版本至少需要是`16.7.0-alpha.0`版本。我们可以在`package.json`文件中检查这一点。如果`package.json`中的React版本小于`16.7.0-alpha.0`，那么我们可以使用以下命令安装这个版本：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the project is created, let''s add TSLint as a development dependency
    to our project, along with some rules that work well with React and Prettier:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，让我们将TSLint作为开发依赖项添加到我们的项目中，并添加一些适用于React和Prettier的规则：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now add a `tslint.json` file containing some rules:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个包含一些规则的`tslint.json`文件：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we open `App.tsx`, there is a linting error. So, let''s resolve this by
    adding `public` as the modifier on the `render` method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果打开`App.tsx`，会出现一个linting错误。所以，让我们通过在`render`方法上添加`public`作为修饰符来解决这个问题：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can install `axios` using `npm`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`npm`安装`axios`：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s start our app running before we continue with the developments:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续开发之前，让我们先启动我们的应用程序：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s do a little more in our app before we make our first GraphQL query in
    `axios`. Let''s create a new file called `Header.tsx` in the `src` directory containing
    the following `import`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们使用`axios`进行第一个GraphQL查询之前，让我们在`src`目录中创建一个名为`Header.tsx`的新文件，其中包含以下`import`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This component will eventually contain our name and avatar from GitHub.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件最终将包含我们从GitHub获取的姓名和头像。
- en: 'Let''s return nothing from our `Header` component for the time being:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时让我们的`Header`组件返回空值：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s go back to `App.tsx` and import the `Header` component we have just
    created:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们回到`App.tsx`，并导入我们刚刚创建的`Header`组件：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now adjust the JSX in `App.tsx`, including our `Header` component:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以调整`App.tsx`中的JSX，包括我们的`Header`组件：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As our final task in this section, let''s change the `App-Header` CSS class
    in `App.css` so that the header isn''t so tall:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为本节的最后一个任务，让我们在`App.css`中更改`App-Header`的CSS类，以便标题不那么高：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Querying the GraphQL server
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询GraphQL服务器
- en: 'Now that we have our React and TypeScript project in place, let''s make a GraphQL
    query using `axios`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的React和TypeScript项目，让我们使用`axios`进行GraphQL查询：
- en: 'In `Header.tsx`, we''ll start by creating two interfaces for the GraphQL query
    response and the viewer data within it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Header.tsx`中，我们将首先为GraphQL查询响应和其中的viewer数据创建两个接口：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s create some state within our `Header` component for the `viewer`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Header`组件中创建一些状态变量用于`viewer`：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It''s nearly time to make the GraphQL query. We are going to do this when the
    component has just been mounted. We can use the `useEffect` function to do this:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候进行GraphQL查询了。我们将在组件刚刚挂载时进行这个操作。我们可以使用`useEffect`函数来实现这一点：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We pass an empty array as the second parameter so that the query only executes
    when the component is mounted and not on each render.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个空数组作为第二个参数传递，这样查询只会在组件挂载时执行，而不是在每次渲染时执行。
- en: 'Let''s use `axios` then to make the GraphQL query:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们使用`axios`进行GraphQL查询：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that we are doing an HTTP `POST` even though we are reading data. GraphQL
    requires us to use an HTTP `POST` because the details of the query are in the
    request body.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们正在读取数据，但我们正在进行HTTP `POST`。GraphQL要求我们使用HTTP `POST`，因为查询的细节在请求体中。
- en: We are also using the interface we used earlier, `IQueryResult`, for the response
    data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在使用之前使用的接口`IQueryResult`来处理响应数据。
- en: 'As mentioned earlier, we need to pass our bearer token in the HTTP Authorization
    header. So, let''s do that:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们需要在HTTP授权标头中传递我们的令牌。所以，让我们这样做：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, we need to substitute in our real bearer token that we obtained earlier
    from GitHub.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要用我们之前从GitHub获取的真实令牌来替换。
- en: 'We aren''t handling the response yet, so let''s do that and set the `viewer`
    state variable:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有处理响应，所以让我们设置`viewer`状态变量：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have the data in state from the GraphQL query, let''s render our
    avatar and name along with our app title:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经从GraphQL查询中获取了数据，让我们渲染我们的头像和姓名以及我们的应用程序标题：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s add the avatar CSS class we just referenced into `App.css`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将刚刚引用的头像CSS类添加到`App.css`中：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we look at the running app, we should see our avatar and name in our app
    header:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，应该在应用程序标题中看到我们的头像和姓名：
- en: '![](assets/5c79a089-47eb-4047-a948-bf5126dc206f.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c79a089-47eb-4047-a948-bf5126dc206f.png)'
- en: So, we've just interacted with a GraphQL server using an HTTP library. All GraphQL
    requests are made using the HTTP POST method, even for reading data. All GraphQL requests
    are made to the same endpoint as well. The resource we want data from isn't in
    the URL, it's in the request body. So, whilst we can use an HTTP library, like
    `axios`, for querying GraphQL servers, it feels a little strange.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚使用了一个HTTP库与GraphQL服务器进行交互。所有GraphQL请求都是使用HTTP POST方法进行的，即使是用于读取数据的请求也是如此。所有GraphQL请求也都是发送到同一个端点。我们想要从中获取数据的资源不在URL中，而是在请求体中。因此，虽然我们可以使用HTTP库，比如`axios`，来查询GraphQL服务器，但感觉有点奇怪。
- en: In the next section, we'll look at a GraphQL client that will help us query
    a GraphQL server in a more natural way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下一个GraphQL客户端，它将帮助我们以更自然的方式查询GraphQL服务器。
- en: Using Apollo GraphQL client
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo GraphQL客户端
- en: Apollo client is a client library for interacting with GraphQL servers. It has
    many benefits over using a generic HTTP library like `axios`, such as being able
    to read and write data declaratively with React components right in our JSX and
    having caching switched on right out of the box.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo客户端是一个用于与GraphQL服务器交互的客户端库。它比使用通用HTTP库如`axios`有许多优点，比如能够在我们的JSX中以声明方式读写数据，并且开箱即用地启用缓存。
- en: In this section, we'll refactor what we built in the last section with `axios`
    to use Apollo, and then extend our app a little more to include a GitHub repository
    search.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构上一节中使用`axios`构建的内容，以使用Apollo，并且稍微扩展我们的应用程序以包括GitHub仓库搜索。
- en: Installing Apollo client
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Apollo客户端
- en: Our first job is to install Apollo into our project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项工作是将Apollo安装到我们的项目中。
- en: 'To add Apollo client to our project, let''s install the following packages
    via `npm`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将Apollo客户端添加到我们的项目中，让我们通过`npm`安装以下包：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`apollo-boost` contains everything we need to set up our Apollo client'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-boost`包含了我们设置Apollo客户端所需的一切'
- en: '`react-apollo` contains React components we are going to use to interact with
    the GraphQL server'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-apollo`包含了我们将用来与GraphQL服务器交互的React组件'
- en: '`graphql` is a core package that we''ll use to parse GraphQL queries'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql`是一个核心包，我们将用它来解析GraphQL查询'
- en: 'We''ll also install some TypeScript types as well for `graphql`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为`graphql`安装一些TypeScript类型：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to make sure TypeScript includes the `es2015` and `esNext` libraries
    when it compiles our code. So, let''s add the following `lib` field to `tsconfig.json`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保TypeScript在编译我们的代码时包含`es2015`和`esNext`库。因此，让我们在`tsconfig.json`中添加以下`lib`字段：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We now have everything in place to start interacting with the GitHub GraphQL
    server with Apollo.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始使用Apollo与GitHub GraphQL服务器进行交互了。
- en: Migrating from axios to Apollo
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从axios迁移到Apollo
- en: Now that we have installed all the Apollo bits and pieces, let's migrate our
    `axios` code to Apollo.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有Apollo的部分，让我们将我们的`axios`代码迁移到Apollo。
- en: Adding an Apollo provider
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Apollo提供程序
- en: 'We are going to start in `App.tsx`, where we will define our Apollo client
    and *provide* it to all the components beneath the `App` in the component hierarchy:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`App.tsx`开始，在那里我们将定义我们的Apollo客户端并*提供*给`App`组件层次结构下的所有组件：
- en: 'In `App.tsx`, let''s import `apollo-boost`, along with the `ApolloProvider`
    component from `react-apollo`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.tsx`中，让我们导入`apollo-boost`，以及从`react-apollo`导入`ApolloProvider`组件：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Just above the `App` class component, let''s create our `ApolloClient`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`类组件的上方，让我们创建我们的`ApolloClient`：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Obviously, we need to substitute in our real bearer token we obtained earlier
    from GitHub.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要用我们之前从GitHub获取的真实令牌来替换它。
- en: 'The last step is to use the `ApolloProvider` component to provide the `ApolloClient`
    we have created to all the other components in our app. We do this by putting
    `ApolloProvider` as the root component and passing it our `ApolloClient` object:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用`ApolloProvider`组件将我们创建的`ApolloClient`提供给应用中的所有其他组件。我们通过将`ApolloProvider`作为根组件，并将`ApolloClient`对象传递给它来实现这一点：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that the `ApolloClient` is set up, we can start interacting with the GraphQL
    server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`ApolloClient`已经设置好了，我们可以开始与GraphQL服务器进行交互了。
- en: Using the query component to query GraphQL
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查询组件查询GraphQL
- en: 'We are now going to use the `Query` component to get our GitHub name and avatar,
    replacing the `axios` code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要使用`Query`组件来获取我们的GitHub姓名和头像，替换`axios`代码：
- en: 'Let''s start by removing the `axios` import statement and instead of having
    the following imports:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先删除`axios`导入语句，而不是有以下导入：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our `IViewer` interface will remain the same, but we need to tweak our `IQueryResult`
    interface slightly:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`IViewer`接口将保持不变，但我们需要稍微调整我们的`IQueryResult`接口：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are going to define our GraphQL query next:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要定义我们的GraphQL查询：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, we set the query to a `GET_VIEWER` variable and we have defined our query
    in a template literal. However, the `gql` function just before the template literal
    is a little odd. Shouldn't the template literal be in parentheses? This is actually
    called a tagged template literal, where the `gql` function from the core GraphQL
    library parses the template literal next to it. We end up with a query in `GET-VIEWER`
    that Apollo can use and execute.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将查询设置为`GET_VIEWER`变量，并在模板文字中定义了我们的查询。然而，在模板文字之前的`gql`函数有点奇怪。模板文字不应该在括号中吗？实际上，这被称为标记模板文字，其中来自核心GraphQL库的`gql`函数解析其旁边的模板文字。我们最终得到了一个Apollo可以使用和执行的`GET-VIEWER`中的查询。
- en: 'We are now going to start to define our query. We can define our query directly
    in JSX using the `Query` component from `react-apollo`. However, in order to add
    some type safety, we are going to create a new component called `GetViewerQuery`
    that inherits from `Query` and defines the result type as a generic parameter:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在要开始定义我们的查询。我们可以直接在JSX中使用`react-apollo`中的`Query`组件定义我们的查询。然而，为了增加一些类型安全性，我们将创建一个名为`GetViewerQuery`的新组件，该组件继承自`Query`并将结果类型定义为泛型参数：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We don't need any state anymore, so we can remove the `viewer` and `setViewer`
    variables.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要任何状态，所以我们可以删除`viewer`和`setViewer`变量。
- en: We can also remove the `useEffect` function call that makes the `axios` query
    because we are going to do our query in JSX now.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以删除使用`useEffect`函数调用`axios`查询的部分，因为我们现在要在JSX中进行查询。
- en: 'So, let''s use our `GetViewerQuery` component to invoke our query:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们使用我们的`GetViewerQuery`组件来调用我们的查询：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We pass the `GetViewerQuery` component our query we created earlier in a `query`
    prop.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将我们之前创建的查询作为`query`属性传递给`GetViewerQuery`组件。
- en: The query result is returned in the children function of `GetViewerQuery`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询结果在`GetViewerQuery`的children函数中返回。
- en: The children function argument contains an object containing the data in a `data`
    property. We destructure this data into a `data` variable.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: children函数参数包含一个包含`data`属性中数据的对象。我们将这些数据解构到一个`data`变量中。
- en: If there isn't any data, we escape early and return `null`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有任何数据，我们会提前退出并返回`null`。
- en: If we have data, we then return the JSX for our avatar and name referencing
    the `data` property.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有数据，然后返回我们的头像和姓名的JSX，引用`data`属性。
- en: If we look at our running app, it should look exactly the same as the `axios`
    version. We may need to `npm start` the app again if it's showing an error.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们正在运行的应用程序，它应该与`axios`版本完全相同。如果显示错误，我们可能需要再次`npm start`应用程序。
- en: 'There''s other information that we can get from the children function argument.
    One piece of useful information is whether the data is being loaded. Let''s use
    this to display a loading message:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从children函数参数中获取其他信息。一个有用的信息是数据是否正在加载。让我们使用这个来显示一个加载消息：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another useful piece of information that we can get from the children function
    argument is information about an error that has occurred. Let''s use this to display
    the error message, if there is one:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从children函数参数中获取的另一个有用的信息是有关发生的错误的信息。让我们使用这个来显示错误消息，如果有的话：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This Apollo implementation is really elegant. It's clever how the `Query` component
    makes the web request at the correct point in the component lifecycle and allows
    us to feed the rest of the component tree the data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Apollo实现真的很优雅。`Query`组件如何在组件生命周期的正确时刻进行网络请求，并允许我们向其余的组件树提供数据，真是聪明。
- en: In the next section, we'll continue to enhance our app with Apollo.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续使用Apollo来增强我们的应用程序。
- en: Adding a repository search component
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个仓库搜索组件
- en: 'In this section, we''ll add a component to search for a GitHub repository and
    return some information about it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将添加一个组件来搜索GitHub仓库并返回一些关于它的信息：
- en: 'Let''s start by creating a new file called `RepoSearch.tsx` containing the
    following imports:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`RepoSearch.tsx`的新文件，其中包含以下导入：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We are going to take in `ApolloClient` as a prop. So, let''s add an interface
    for that:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以`ApolloClient`作为prop传入。因此，让我们为此添加一个接口：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we''ll scaffold our component:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将搭建我们的组件：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s reference this in our `App` component, now in `App.tsx`, by first importing
    it:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`App.tsx`中引用这个，首先导入它：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can now add this under the app header passing in `ApolloClient`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将其添加到应用程序标题下，传入`ApolloClient`：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our repository `search` component is nicely set up now. In the next, section
    we can implement a search form.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仓库`search`组件现在已经很好地设置好了。在下一节中，我们可以实现一个搜索表单。
- en: Implementing the search form
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现搜索表单
- en: 'Let''s implement a search form that allows the user to supply an organization
    name and repository name:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个搜索表单，允许用户提供组织名称和仓库名称：
- en: 'Back in `RepoSearch.tsx`, let''s start to define the state for the search fields,
    starting with the interface:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`RepoSearch.tsx`，让我们开始定义搜索字段的状态，从接口开始：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can create a variable to hold our `search` state, along with a function
    to set it:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个变量来保存我们的`search`状态，以及一个设置它的函数：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s define the `search` form in our JSX:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在JSX中定义`search`表单：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We've referenced a few bits that aren't implemented yet. So, we'll implement
    this one by one.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引用了一些尚未实现的部分。因此，我们将逐一实现这些。
- en: 'Let''s add the `repo-search` class we referenced in `App.css`. We''ll also
    style the labels and inputs along with the Search button as well:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加在`App.css`中引用的`repo-search`类。我们还将为标签和输入以及搜索按钮添加样式：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, let''s implement the input change handlers that simply update the `search`
    state:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现简单更新`search`状态的输入更改处理程序：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The final bit we need to implement is the `search` handler:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一部分是`search`处理程序：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We call `preventDefault` on the event argument to stop a full postback occurring.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在事件参数上调用`preventDefault`来阻止发生完整的后退。
- en: So, that's the search form started. We'll implement the GraphQL query in the
    next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，搜索表单已经开始了。我们将在下一节中实现GraphQL查询。
- en: Implementing the search query
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现搜索查询
- en: 'We are now at the point where we need to make the GraphQL query to do the actual
    search:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到了需要进行GraphQL查询来实际搜索的地步：
- en: 'Let''s start by creating an interface for the repository data we expect to
    get back from the query:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先为我们期望从查询中获取的仓库数据创建一个接口：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is the structure we got back from the GitHub GraphQL Explorer in an earlier
    section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前的部分中从GitHub GraphQL Explorer中得到的结构。
- en: 'We are going to need a default value for this state. So, let''s define this:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要为这个状态设置一个默认值。所以，让我们定义这个：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can also define an interface for the query result as a whole:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以为整个查询结果定义一个接口：
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we can create the query itself using a tagged template literal:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用标记模板字面量来创建查询本身：
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is the query we made in the GitHub GraphQL Explorer in an earlier section.
    Unlike our previous queries, this one has parameters that we'll need to include
    when we execute the query a little later.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前的部分中在GitHub GraphQL Explorer中进行的查询。与以前的查询不同，这个查询有一些参数，我们需要在稍后执行查询时包含这些参数。
- en: 'We need to store the data we get from the query in state. So, let''s create
    a state variable called `repo`, along with a function to set it:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将从查询中获取的数据存储在状态中。所以，让我们创建一个名为`repo`的状态变量，以及一个设置它的函数：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We are also going to store any problems with the `search` in state as well:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在状态中存储`search`的任何问题：
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s update the `handleSearch` arrow function to clear any search error state
    before we do the `search`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新`handleSearch`箭头函数，在进行`search`之前清除任何搜索错误状态：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s go on and use `ApolloClient` passed in as a prop to make the query:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用作为属性传递的`ApolloClient`来进行查询：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There is more work to do here, though. First, we need to pass in the `query`
    parameters for the organization name and repository name from the values we have
    in our `search` state:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里还有更多的工作要做。首先，我们需要从我们在`search`状态中拥有的值中传递`query`参数，用于组织名称和仓库名称：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now it''s time to handle the response in the `then` method and set the `repo`
    state to the data in the response:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在`then`方法中处理响应并将`repo`状态设置为响应中的数据了：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will also handle any errors in the `catch` method and update the `searchError`
    state:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在`catch`方法中处理任何错误，并更新`searchError`状态：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If we try a `search` in the running app, the query will be made okay, but we
    are not showing the results yet. Let's do that in the next section.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行的应用中尝试进行`search`，查询将会正常进行，但我们还没有显示结果。让我们在下一部分中做这件事。
- en: Rendering the search result
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染搜索结果
- en: 'Let''s render the data we have got from the repository query:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们渲染从仓库查询中获取的数据：
- en: 'Let''s render the repository name with its number of stars, along with its
    description, under the `search` form if we have a search result:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有搜索结果，让我们在`search`表单下渲染仓库名称及其星数以及描述：
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We''ll also render the last `5` repository issues:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将渲染最后的`5`个仓库问题：
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If a problem has occurred, let''s render the error message we have captured
    in state:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现问题，让我们渲染在状态中捕获的错误消息：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s add a bit of CSS in `App.css` for the title of the repository in the
    search result:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`App.css`中为搜索结果中的仓库标题添加一些CSS：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we search for a repository, we should now see information about the repository
    rendered:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索一个仓库，现在应该看到有关仓库的信息被渲染出来：
- en: '![](assets/9c544071-6f5f-4299-b1fe-60604a62c400.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c544071-6f5f-4299-b1fe-60604a62c400.png)'
- en: We are now getting comfortable querying a GraphQL server with Apollo. In the
    next section, we'll tackle mutations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经可以使用Apollo舒适地查询GraphQL服务器了。在下一部分，我们将处理变异。
- en: Implementing a mutation with Apollo
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo实现变异
- en: 'Let''s allow users to star a GitHub repository in our app. This will involve
    sending a `mutation` via Apollo:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们允许用户在我们的应用中为GitHub仓库加星。这将涉及通过Apollo发送一个`mutation`：
- en: 'First, let''s import the `Mutation` component from `react-apollo`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从`react-apollo`中导入`Mutation`组件：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now let''s create the `mutation`. The is the same query we executed in the
    GitHub GraphQL Explorer earlier:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建`mutation`。这是我们之前在GitHub GraphQL Explorer中执行的相同查询：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the JSX, under where we render the description, let''s place the `Mutation`
    component:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX中，在我们渲染描述的地方，让我们放置`Mutation`组件：
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We only render the `mutation` if the `viewer` hasn't already starred the repository
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在`viewer`还没有给存储库添加星标时，我们才渲染`mutation`
- en: The `Mutation` component takes in the mutation we just defined along with the
    variables, which is the repository `id` in our case
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mutation`组件接受我们刚刚定义的mutation以及变量，这在我们的情况下是存储库的`id`'
- en: 'The `Mutation` component has a children function that gives us access to the
    `addStar` function. So, let''s render a Star! button that calls `addStar` when
    clicked:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mutation`组件有一个children函数，它给了我们访问`addStar`函数的权限。因此，让我们渲染一个Star!按钮，当点击时调用`addStar`：'
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `Mutation` component also tells us when the `mutation` is being executed
    via a `loading` property in a second argument in the children function. Let''s
    use this to disable the button and inform the user that the star is being added:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mutation`组件还告诉我们`mutation`正在执行，通过children函数的第二个参数中的`loading`属性。让我们使用这个来禁用按钮，并通知用户星标正在被添加：'
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `Mutation` component also tells us when there is an error. So, let''s use
    this and render the error if one happens:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mutation`组件还告诉我们是否有错误。因此，让我们使用这个并在发生错误时渲染错误：'
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If we try to add a star to a repository, the star should be successfully added.
    We can go to the GitHub repository in [github.com](http://github.com) to verify
    this.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试给存储库添加星标，星标应该会成功添加。我们可以去GitHub存储库的[github.com](http://github.com)验证这一点。
- en: So, we are really getting to grips with Apollo now that we've implemented both
    queries and a `mutation`. There is one thing that was a little odd, though, that
    we may have spotted. The number of stars doesn't update in our app after we star
    a repository. Even if we search for the repository again, the number of stars
    is the number before we started it. However, if we refresh the browser and search
    for the repository again, we do get the correct number of stars. So, what's going
    on here? We'll find out in the next section.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了查询和`mutation`，我们真正掌握了Apollo。不过，有一件事情有点奇怪，也许我们已经注意到了。在我们给存储库添加星标后，应用程序中星标的数量没有更新。即使我们再次搜索存储库，星标的数量仍然是我们开始之前的数量。但是，如果我们刷新浏览器并再次搜索存储库，我们会得到正确的星标数量。那么，这是怎么回事呢？我们将在下一节中找出答案。
- en: Working with cached data in Apollo
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apollo中使用缓存数据
- en: We ended the last section with a bit of a mystery. Why aren't we getting the
    up-to-date number of stars in a repository `search` after we've started it? The
    answer is that Apollo caches the repository data after the initial `search`. When
    the same query is executed, it gets the results from its cache, rather than getting
    the data from the GraphQL server.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节结束时留下了一个谜。为什么我们在开始搜索后没有得到存储库`search`的最新星标数量？答案是Apollo在初始`search`后缓存了存储库数据。当执行相同的查询时，它会从缓存中获取结果，而不是从GraphQL服务器获取数据。
- en: 'Let''s double-check that this is the case:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次确认一下：
- en: 'Let''s go to our app and open Developer tools on the Network tab and clear
    any previous requests:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开应用程序并在网络选项卡上打开开发者工具，并清除之前的请求：
- en: '![](assets/d4bd5ab2-fc05-49c9-a31f-82612fa19b0d.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d4bd5ab2-fc05-49c9-a31f-82612fa19b0d.png)'
- en: 'Let''s do a search. We''ll see a couple of requests to the GitHub GraphQL server:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行一次搜索。我们会看到向GitHub GraphQL服务器发出了几个请求：
- en: '![](assets/0230f74a-065e-4dbc-97e3-304efea83194.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0230f74a-065e-4dbc-97e3-304efea83194.png)'
- en: Under the Developer tools, Network tab, let's clear the requests, and then in
    our app let's click the Search button again. We'll see that no network requests
    will be made, but the data is rendered. So, the data must be coming from a local
    cache.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发者工具中，网络选项卡，让我们清除请求，然后在我们的应用程序中再次点击搜索按钮。我们会看到没有网络请求被发出，但数据被渲染出来。所以，数据一定是来自本地缓存。
- en: So, our `ApolloClient` that we configured using `apollo-boost` automatically
    caches queries in an in-memory cache. In the next section, we'll learn how to
    clear the cache so that our app shows the correct number of stars after a repository
    has been starred.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们使用`apollo-boost`配置的`ApolloClient`会自动将查询缓存到内存中。在下一节中，我们将学习如何清除缓存，以便我们的应用程序在仓库被加星后显示正确的星星数量。
- en: Clearing the caching using refetchQueries
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`refetchQueries`清除缓存
- en: 'We need a way of clearing the cached query result after a `mutation` has happened.
    One way of doing this is to use the `refetchQueries` prop on the `Mutation` component:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutation`发生后，我们需要一种清除缓存查询结果的方法。一种方法是在`Mutation`组件上使用`refetchQueries`属性：
- en: 'Let''s give this a go. The `refetchQueries` prop takes in an array of objects
    that contain the queries with the corresponding variable values that should be
    removed from the cache:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试一试。`refetchQueries`属性接受一个包含应该从缓存中移除的具有相应变量值的查询对象数组：
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If we star a repository now, the number of stars doesn't update straight away.
    However, if the Search button is pressed, the stars are updated.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在给一个仓库加星标，星星的数量不会立即更新。然而，如果按下搜索按钮，星星就会更新。
- en: So, the cache was cleared but the experience still isn't ideal. Ideally, we
    want the number of stars to be updated immediately after the Star! button is clicked.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，缓存已经清除，但是体验仍然不理想。理想情况下，我们希望在点击“Star！”按钮后立即更新星星的数量。
- en: If we think through what we have just done, we are trying to bypass the cache.
    However, the cache is in place to help our app perform well.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考刚才做的事情，我们正在试图绕过缓存。然而，缓存的存在是为了帮助我们的应用程序表现良好。
- en: So, this approach doesn't feel great. The user experience still isn't ideal,
    and we have just made our app less performant. There must be a better way! We'll
    explore a different approach in the next section.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这种方法并不理想。用户体验仍然不理想，我们刚刚使我们的应用程序性能下降了。一定有更好的方法！我们将在下一节中探索另一种方法。
- en: Updating the cache after a Mutation
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mutation后更新缓存
- en: 'Let''s think through the problem one more time:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次仔细思考一下问题：
- en: We have some information about a repository in a cache that includes the number
    of stars it has.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在缓存中有关于仓库的一些信息，包括它拥有的星星数量。
- en: When we star the repository, we want to see that the number of stars has been
    incremented by one.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们给仓库加星标时，我们希望看到星星的数量增加了一个。
- en: What if we could just increment the number of stars in the cache by one? This
    should hopefully resolve the problem.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们可以在缓存中将星星的数量增加一个，那会怎么样？这应该能解决问题。
- en: 'So, let''s give this a go and update the cache after the `mutation` has finished:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们尝试一下，在`mutation`完成后更新缓存：
- en: First, let's remove the `refetchQueries` prop we implemented in the last section.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们移除上一节中实现的`refetchQueries`属性。
- en: 'There is an `update` prop on the `Mutation` component that we can leverage
    to update the cache. So, let''s start to implement this:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mutation`组件上有一个`update`属性，我们可以利用它来更新缓存。所以，让我们开始实现这个功能：'
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'So, we need to implement an arrow function that updates the cache that is available
    as an argument:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，我们需要实现一个箭头函数，更新可用作参数的缓存：
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: So, the cache has a `readQuery` function that we can use to get the cached data.
    If no data is found in the cache then we can exit the function without doing anything
    else.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，缓存有一个`readQuery`函数，我们可以使用它来获取缓存的数据。如果在缓存中找不到数据，那么我们可以退出函数而不做其他事情。
- en: 'So, now that we have the data from the cache, we can increment the number of
    stars. To do this, we create a new object and spread the props from the cached
    repository into it and overwrite it with the incremented number of stars and the
    fact that the viewer has starred the repository:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们从缓存中获取了数据，我们可以增加星星的数量。为此，我们创建一个新对象，并将缓存存储库的属性扩展到其中，并用增加的星星数量和查看者已经为存储库加星的事实覆盖它：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can then update the cache with its `writeQuery` function. We pass in the
    query with the variable values and the new data to store in the cache:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用其`writeQuery`函数更新缓存。我们传入带有变量值的查询和要存储在缓存中的新数据：
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There''s one more job to do, which is to update the `repo` state so that the
    number of stars updates immediately onscreen:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一件事要做，那就是更新`repo`状态，以便星星的数量立即在屏幕上更新：
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: That should be it. If we try to star a repository in our app again, we should
    see that the number of stars is immediately incremented.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。如果我们再次尝试在应用程序中为存储库加星，我们应该会看到星星的数量立即增加。
- en: Caching is one of the great features that Apollo gives us out-of-the-box. The
    `update` prop on the `Mutation` component gives us a precise way to update our
    cache. The `refetchQueries` prop on the `Mutation` component is a more heavy-handed
    and less efficient way of forcing a cache to be updated.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是Apollo提供的伟大功能之一。`Mutation`组件上的`update`属性为我们提供了一种精确更新缓存的方式。`Mutation`组件上的`refetchQueries`属性是一种更粗暴且效率低下的强制更新缓存的方式。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'GraphQL shines over REST because it allows us to efficiently get the data we
    need in the shape we need with far less effort. The GitHub GraphQL Explorer is
    a great tool for getting comfortable with the syntax. There are two main types
    of requests we can make to a GraphQL server:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL比REST更出色，因为它允许我们以更少的努力有效地获取所需的数据。GitHub GraphQL Explorer是一个很好的工具，可以让我们熟悉语法。我们可以向GraphQL服务器发出两种主要类型的请求：
- en: We can execute a `query` to read data
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以执行`query`来读取数据
- en: We can execute a `mutation` to write data
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以执行`mutation`来写入数据
- en: Queries allow us to specify the objects and fields we want in the response.
    We can rename them by using aliases. We can parameterize a query by defining variables.
    We can give variables types and specify whether each one is required or not with `!`
    at the end. There are query features that we didn't cover in this chapter, such
    as conditionally including fields and the powerful paging capability. In summary,
    it's an extremely powerful query language!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 查询允许我们指定响应中需要的对象和字段。我们可以使用别名来重命名它们。我们可以通过定义变量来参数化查询。我们可以给变量类型，并在末尾使用`!`来指定每个变量是否是必需的。本章中我们没有涵盖的查询功能还有条件包含字段和强大的分页功能。总之，这是一种非常强大的查询语言！
- en: Mutations share some of the same features as queries, such as being able to
    pass parameters into them. It's great how we get to control what data is included
    in the response as well.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 变异与查询有一些相同的特性，比如能够向它们传递参数。我们可以控制响应中包含的数据，这真是太棒了。
- en: GraphQL operates over HTTP with HTTP `POST` requests to a single URL. The HTTP
    body contains the query or `mutation` information. We can use an HTTP client to
    interact with a GraphQL server, but we'll probably be more productive with a library
    like Apollo that is built specifically to interact with GraphQL servers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL通过HTTP运行，使用HTTP `POST`请求到单个URL。HTTP正文包含查询或`mutation`信息。我们可以使用HTTP客户端与GraphQL服务器交互，但使用专门与GraphQL服务器交互的Apollo等库可能会更有效率。
- en: React Apollo is a set of React bits and pieces that work with the core Apollo
    library. It gives us nice `Query` and `Mutation` React components for including
    queries and mutations right in our JSX, making our code arguably easier to read.
    Before we can use these components, we need to set up our `ApolloClient` object
    with the URL to the GraphQL server and any credentials. We also need to include
    an `ApolloProvider` component high in our component tree, above all the components
    that need GraphQL data.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: React Apollo是一组与核心Apollo库配合使用的React组件。它为我们提供了很好的`Query`和`Mutation`React组件，用于在我们的JSX中包含查询和变更，使我们的代码更易于阅读。在我们使用这些组件之前，我们需要设置我们的`ApolloClient`对象，包括GraphQL服务器的URL和任何凭据。我们还需要在我们的组件树的顶部包含一个`ApolloProvider`组件，高于所有需要GraphQL数据的组件。
- en: Caching is switched on out-of-the-box when we scaffold our project with `apollo-boost`.
    The `Mutation` component gives us `update` and `refetchQueries` props to manage
    cache updates.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`apollo-boost`搭建项目时，缓存默认开启。`Mutation`组件给了我们`update`和`refetchQueries`属性来管理缓存更新。
- en: All in all, GraphQL is a very productive way to interact with backends, and
    it works really nicely with React and TypeScript apps.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，GraphQL是与后端交互的一种非常高效的方式，它与React和TypeScript应用程序非常配合。
- en: So, we've learned many different aspects of React and TypeScript in this book
    so far. One big topic that we haven't covered yet is how we can robustly test
    the apps we build. We'll cover this in the next chapter.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们在这本书中学到了许多关于React和TypeScript的不同方面。一个我们尚未涉及的重要主题是如何对我们构建的应用进行健壮的测试。我们将在下一章中介绍这个主题。
- en: Questions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let''s have a go at some questions to test our knowledge on what we have just
    learned:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些问题，来测试我们刚刚学到的知识：
- en: In the GitHub GraphQL Explorer, create a query to return the last five open
    issues in the React project. Return the issue title and the URL in the response.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub GraphQL Explorer中，创建一个查询，返回React项目中最后五个未解决的问题。在响应中返回问题标题和URL。
- en: Enhance the last query and make the number of issues that are returned a parameter
    and make this default to five.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强最后一个查询，并使返回的问题数量成为一个参数，并将其默认设置为五。
- en: Create a `mutation` in the GitHub GraphQL Explorer to unstar a starred repository.
    The `mutation` should take a required repository `id` in as a parameter.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub GraphQL Explorer中创建一个`mutation`来取消对一个已标星的存储库的标星。`mutation`应该以一个必需的存储库`id`作为参数。
- en: What part of the HTTP request does the GraphQL query go in?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL查询的哪一部分放在HTTP请求中？
- en: What part of the HTTP request does the GraphQL `mutation` go in?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL `mutation`的哪一部分放在HTTP请求中？
- en: How can we make the response from the `react-apollo` `Query` component type
    safe?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使`react-apollo`的`Query`组件的响应类型安全？
- en: Is caching on or off by default when you scaffold a project with `react-boost`?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`react-boost`搭建项目时，默认情况下是否开启缓存？
- en: What prop can we use on the `Mutation` component to update the local cache?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`Mutation`组件上使用哪个属性来更新本地缓存？
- en: Further reading
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links are good resources of further information on GraphQL in
    general, along with React and Apollo:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是关于GraphQL、React和Apollo的进一步信息的好资源：
- en: The GraphQL docs are at [https://graphql.org/learn/](https://graphql.org/learn/)
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL文档位于[https://graphql.org/learn/](https://graphql.org/learn/)
- en: The Apollo docs are at [https://www.apollographql.com/docs/](https://www.apollographql.com/docs/)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo文档位于[https://www.apollographql.com/docs/](https://www.apollographql.com/docs/)
- en: The React section of the Apollo docs is at [https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo文档中关于React部分的链接是[https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)
