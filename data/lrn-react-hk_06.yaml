- en: Using the Reducer and Effect Hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的博客应用中使用Reducer和Effect Hooks
- en: 'After developing our own blog application using the State Hook, we are now
    going to learn about two other very important Hooks that are provided by React:
    the **Reducer** and **Effect** Hooks. We are first going to learn when we should
    use a Reducer Hook instead of a State Hook. Then, we learn how to turn an existing
    State Hook into a Reducer Hook in order to get a grasp on the concept in practice.
    Next, we are going to learn about Effect Hooks and what they are used for. Finally,
    we are going to implement them in our blog application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用State Hook开发我们自己的博客应用之后，我们现在要学习React提供的另外两个非常重要的Hooks：**Reducer**和**Effect** Hooks。我们首先要学习何时应该使用Reducer
    Hook而不是State Hook。然后，我们学习如何将现有的State Hook转换为Reducer Hook，以便在实践中掌握这个概念。接下来，我们将学习Effect
    Hooks以及它们的用途。最后，我们将在我们的博客应用中实现它们。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning about the differences between Reducer Hooks and State Hooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习有关Reducer Hooks和State Hooks之间的区别
- en: Implementing Reducer Hooks in our blog app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的博客应用中实现Reducer Hooks
- en: Using Effect Hooks in our blog app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的博客应用中使用Effect Hooks
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: 'The code for this chapter can be found on the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter04)[.](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter04)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter04)[.](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter04)
- en: 'Check out the following video to see the code in action:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    you write the code yourself in order for you to be able to learn and understand
    properly. However, if you run into any issues, you can always refer to the code
    example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行提供的代码示例。重要的是您自己编写代码，以便能够正确学习和理解。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始本章。
- en: Reducer Hooks versus State Hooks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducer Hooks与State Hooks
- en: In the previous chapter, we learned about dealing with local and global states.
    We used State Hooks for both cases, which is fine for simple state changes. However,
    when our state logic becomes more complicated, we are going to need to ensure
    that we keep the state consistent. In order to do so, we should use a Reducer
    Hook instead of multiple State Hooks, because it is harder to maintain synchronicity
    between multiple State Hooks that depend on each other. As an alternative, we
    could keep all state in one State Hook, but then we have to make sure that we
    do not accidentally overwrite parts of our state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何处理本地和全局状态。我们对两种情况都使用了State Hooks，这对于简单的状态更改是可以的。然而，当我们的状态逻辑变得更加复杂时，我们需要确保保持状态一致。为了做到这一点，我们应该使用Reducer
    Hook而不是多个State Hooks，因为很难在彼此依赖的多个State Hooks之间保持同步。作为替代方案，我们可以将所有状态保存在一个State
    Hook中，但然后我们必须确保不会意外地覆盖我们状态的部分。
- en: Problems with the State Hook
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: State Hook的问题
- en: 'The State Hook already supports passing complex objects and arrays to it, and
    it can handle their state changes perfectly well. However, we are always going
    to have to change the state directly, which means that we need to use a lot of
    spread syntax, in order to make sure that we are not overwriting other parts of
    the state. For example, imagine that we have a state object like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: State Hook已经支持向其传递复杂对象和数组，并且可以很好地处理它们的状态变化。然而，我们总是需要直接改变状态，这意味着我们需要使用大量的扩展语法，以确保我们不会覆盖状态的其他部分。例如，想象一下，我们有一个这样的状态对象：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we want to change the filter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要改变过滤器：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we simply ran the preceding code, we would be removing the `expandPosts`
    part of our state! So, we need to do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地运行前面的代码，我们将删除状态的`expandPosts`部分！所以，我们需要做以下操作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we wanted to change the `fromDate` filter to a different date, we would
    need to use spread syntax twice, to avoid removing the `byAuthor` filter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要将`fromDate`过滤器更改为不同的日期，我们需要两次使用扩展语法，以避免删除`byAuthor`过滤器：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But, what happens if we do this when the `filter` state is still a string?
    We are going to get the following result:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们在`filter`状态仍然是字符串时这样做会发生什么？我们将得到以下结果：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What? Why are there suddenly three new keys—`0`, `1`, and `2`? This is because
    spread syntax also works on strings, which are spread in such a way that each
    letter gets a key, based on its index in the string.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？为什么突然出现了三个新键—`0`、`1`和`2`？这是因为扩展语法也适用于字符串，它们以这样的方式扩展，即每个字母根据其在字符串中的索引获得一个键。
- en: As you can imagine, using spread syntax and changing the state object directly
    can become very tedious for larger state objects. Furthermore, we always need
    to make sure that we do not introduce any bugs, and we need to check for bugs
    in multiple places all across our app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，对于较大的状态对象，使用扩展语法和直接改变状态对象会变得非常繁琐。此外，我们总是需要确保我们不会引入任何错误，并且需要在应用程序的各个地方检查错误。
- en: Actions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: Instead of changing the state directly, we could make a function that deals
    with state changes. Such a function would only allow state changes via certain
    actions, such as a `CHANGE_FILTER` or a `TOGGLE_EXPAND` action.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接改变状态，我们可以创建一个处理状态变化的函数。这样的函数只允许通过特定操作来改变状态，比如`CHANGE_FILTER`或`TOGGLE_EXPAND`操作。
- en: Actions are simply objects that have a `type` key, telling us which action we
    are dealing with, and additional keys more closely describing the action.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 操作只是具有`type`键的对象，告诉我们我们正在处理哪个操作，并且更详细地描述操作的其他键。
- en: 'The `TOGGLE_EXPAND` action is quite simple. It is simply an object with the
    action `type` defined:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`TOGGLE_EXPAND`操作非常简单。它只是一个定义了`type`的对象：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `CHANGE_FILTER` action could deal with the complex state changes that we
    had problems with earlier, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHANGE_FILTER`操作可以处理我们之前遇到的复杂状态变化问题，如下所示：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second, third, and fourth actions would change the `filter` state from
    a string to an object, and then set the respective key. If the object already
    exists, we would simply adjust the keys that were defined in the action. After
    each action, the state would change as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二、第三和第四个操作将把`filter`状态从字符串更改为对象，然后设置相应的键。如果对象已经存在，我们只需调整在操作中定义的键。每个操作后，状态将如下更改：
- en: '`{ expandPosts: true, filter: ''all'' }`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ expandPosts: true, filter: ''all'' }`'
- en: '`{ expandPosts: true, filter: **{** fromDate: ''2019-04-29'' **}** }`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ expandPosts: true, filter: **{** fromDate: ''2019-04-29'' **}** }`'
- en: '`{ expandPosts: true, filter: { fromDate: ''2019-04-29'', byAuthor: ''Daniel
    Bugl'' } }`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ expandPosts: true, filter: { fromDate: ''2019-04-29'', byAuthor: ''Daniel
    Bugl'' } }`'
- en: '`{ expandPosts: true, filter: { fromDate: ''2019-04-30'', byAuthor: ''Daniel
    Bugl'' } }`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{ expandPosts: true, filter: { fromDate: ''2019-04-30'', byAuthor: ''Daniel
    Bugl'' } }'
- en: 'Now, take a look at the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下以下代码：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we dispatched another action, as in the preceding code, then the state would
    go back to being the `all` string, as it was in the initial state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分派了另一个action，就像前面的代码一样，那么状态将回到初始状态中的“all”字符串。
- en: Reducers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: Now, we still need to define the function that handles these state changes.
    Such a function is known as a reducer function. It takes the current `state` and
    `action` as arguments, and returns a new state.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们仍然需要定义处理这些状态变化的函数。这样的函数被称为reducer函数。它以当前的“state”和“action”作为参数，并返回一个新的state。
- en: If you are aware of the Redux library, you will already be very familiar with
    the concept of state, actions, and reducers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Redux库，您可能已经非常熟悉状态、actions和reducers的概念。
- en: 'Now, we are going to define our `reducer` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要定义我们的“reducer”函数：
- en: 'We start with the function definition of our `reducer`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从我们的“reducer”的函数定义开始：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we check for `action.type` using a `switch` statement:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`switch`语句检查`action.type`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are going to handle the `TOGGLE_EXPAND` action, where we simply toggle
    the current `expandPosts` state:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们要处理“TOGGLE_EXPAND”动作，我们只是切换当前的“expandPosts”状态：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we are going to handle the `CHANGE_FILTER` action. Here, we first need
    to check if `all` is set to `true`, and, in that case, simply set our `filter`
    to the `''all''` string:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要处理“CHANGE_FILTER”动作。在这里，我们首先需要检查“all”是否设置为“true”，在这种情况下，只需将我们的“filter”设置为“'all'”字符串：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we have to handle the other `filter` options. First, we check if the `filter` variable
    is already an `object`. If not, we create a new one. Otherwise, we use the existing
    object:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须处理其他“filter”选项。首先，我们检查“filter”变量是否已经是一个“object”。如果不是，我们创建一个新的。否则，我们使用现有的对象：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we define the handlers for the various filters, allowing for multiple
    filters to be set at once, by not immediately returning the new `state`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义各种过滤器的处理程序，允许同时设置多个过滤器，而不是立即返回新的“state”：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we return the new `state`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回新的“state”：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the `default` case, we throw an error, because this is an unknown action:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“default”情况，我们抛出错误，因为这是一个未知的动作：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Throwing an error in the default case is different to what is best practice
    with Redux reducers, where we would simply return the current state in the default
    case. Because React Reducer Hooks do not store all state in one object, we are
    only going to handle certain actions for certain state objects, so we can throw
    an error for unknown actions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认情况下抛出错误与Redux reducers的最佳实践不同，在那里我们只会在默认情况下返回当前状态。因为React Reducer Hooks不会将所有状态存储在一个对象中，我们只会处理特定状态对象的某些动作，所以我们可以对未知的动作抛出错误。
- en: Now, our `reducer` function has been defined, and we can move on to defining
    the Reducer Hook.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的“reducer”函数已经定义，我们可以继续定义Reducer Hook。
- en: The Reducer Hook
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducer Hook
- en: 'Now that we have defined actions and the `reducer` function, we can create
    a Reducer Hook from the `reducer`. The signature for the `useReducer` Hook is
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了actions和“reducer”函数，我们可以从“reducer”创建一个Reducer Hook。`useReducer` Hook的签名如下：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The only thing that we still need to define is the `initialState`; then we
    can define a Reducer Hook:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一还需要定义的是“initialState”；然后我们可以定义一个Reducer Hook：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can access the state by using the `state` object that was returned
    from the Reducer Hook, and dispatch actions via the `dispatch` function, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用从Reducer Hook返回的“state”对象来访问状态，并通过“dispatch”函数分派actions，如下所示：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we want to add additional options to the action, we simply add them to the
    action object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要向action添加其他选项，我们只需将它们添加到action对象中：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see, dealing with state changes using actions and reducers is much
    easier than having to adjust the state object directly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用操作和减速器处理状态变化比直接调整状态对象要容易得多。
- en: Implementing Reducer Hooks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Reducer Hooks
- en: After learning about actions, reducers, and the Reducer Hook, we are going to
    implement them in our blog app. Any existing State Hook can be turned into a Reducer
    Hook, when the state object or state changes become too complex.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了操作、减速器和Reducer Hook之后，我们将在我们的博客应用程序中实现它们。当状态对象或状态变化变得太复杂时，任何现有的State Hook都可以转换为Reducer
    Hook。
- en: If there are multiple `setState` functions that are always called at the same
    time, it is a good hint that they should be grouped together in a single Reducer
    Hook.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个`setState`函数总是同时调用，这是它们应该在一个单独的Reducer Hook中分组的一个很好的提示。
- en: Global state is usually a good candidate for using a Reducer Hook, rather than
    a State Hook, because global-state changes can happen anywhere in the app. Then,
    it is much easier to deal with actions, and update the state-changing logic only
    in one place. Having all the state-changing logic in one place makes it easier
    to maintain and fix bugs, without introducing new ones by forgetting to update
    the logic everywhere.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态通常是使用Reducer Hook的一个很好的候选，而不是State Hook，因为全局状态的变化可以发生在应用程序的任何地方。然后，在一个地方处理操作并仅更新状态变化逻辑会更容易。将所有状态变化逻辑放在一个地方使得更容易维护和修复错误，而不会因忘记在所有地方更新逻辑而引入新错误。
- en: We are now going to turn some of the existing State Hooks in our blog app into
    Reducer Hooks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将一些现有的State Hooks在我们的博客应用程序中转换为Reducer Hooks。
- en: Turning a State Hook into a Reducer Hook
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将State Hook转换为Reducer Hook
- en: 'In our blog app, we have two global State Hooks, which we are going to replace
    with Reducer Hooks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客应用程序中，我们有两个全局State Hooks，我们将用Reducer Hooks替换它们：
- en: '`user` state'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`状态'
- en: '`posts` state'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`posts`状态'
- en: We start by replacing the `user` State Hook.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先替换`user` State Hook。
- en: Replacing the user State Hook
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换用户State Hook
- en: We are going to start with the `user` State Hook, because it is simpler than
    the `posts` State Hook. Later on, the `user` state will contain complex state
    changes, so it makes sense to use a Reducer Hook here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`user` State Hook开始，因为它比`posts` State Hook更简单。以后，`user`状态将包含复杂的状态变化，因此在这里使用Reducer
    Hook是有意义的。
- en: First, we are going to define our actions, then we are going to define the reducer
    function. Finally, we are going to replace the State Hook with a Reducer Hook.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义我们的操作，然后我们将定义减速器函数。最后，我们将用Reducer Hook替换State Hook。
- en: Defining actions
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义操作
- en: We start by defining our actions, as these will be important when defining the
    reducer function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的操作，因为在定义减速器函数时，这些操作将很重要。
- en: 'Let''s define the actions now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义操作：
- en: 'First, we are going to need an action to allow a user to log in, by providing
    a `username` value and a `password` value:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个操作来允许用户通过提供`username`值和`password`值来登录：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we are also going to need a `REGISTER` action, which, in our case, is
    going to be similar to the `LOGIN` action, because we did not implement any registration
    logic yet:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们还需要一个`REGISTER`操作，在我们的情况下，它将类似于`LOGIN`操作，因为我们还没有实现任何注册逻辑：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we are going to need a `LOGOUT` action, which is simply going to log
    out the currently logged-in user:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将需要一个`LOGOUT`操作，它只是简单地注销当前登录的用户：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we have defined all the required user-related actions and we can move on
    to defining the reducer function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了所有必需的与用户相关的操作，我们可以继续定义减速器函数了。
- en: Defining the reducer
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义减速器
- en: Next, we define a reducer function for the `user` state. For now, we are going
    to place our reducers in the `src/App.js` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`user`状态定义一个减速器函数。现在，我们将把我们的减速器放在`src/App.js`文件中。
- en: Later on, it might make sense to create a separate `src/reducers.js` file, or
    even a separate `src/reducers/` directory, with separate files for each reducer
    function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以后，创建一个单独的`src/reducers.js`文件，甚至是一个单独的`src/reducers/`目录，为每个reducer函数创建单独的文件可能是有意义的。
- en: 'Let''s start defining the `userReducer` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义`userReducer`函数：
- en: 'In the `src/App.js` file, before the `App` function definition, create a `userReducer`
    function for the `user` state:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`文件中，在`App`函数定义之前，为`user`状态创建一个`userReducer`函数：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, we use a `switch` statement for the `action` type:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们对动作类型使用`switch`语句：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we handle the `LOGIN` and `REGISTER` actions, where we set the `user`
    state to the given `username` value. In our case, we simply return the `username` value
    from the `action` object for now:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们处理`LOGIN`和`REGISTER`动作，将`user`状态设置为给定的`username`值。在我们的情况下，我们暂时只是从`action`对象中返回`username`值：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we handle the `LOGOUT` action, where we set the state to an empty string:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们处理`LOGOUT`动作，将状态设置为空字符串：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we throw an error when we encounter an unhandled action:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当遇到未处理的动作时，我们会抛出一个错误：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, the `userReducer` function is defined, and we can move on to defining the
    Reducer Hook.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`userReducer`函数已经定义，我们可以继续定义Reducer Hook。
- en: Defining the Reducer Hook
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Reducer Hook
- en: After defining the actions and the reducer function, we are going to define
    the Reducer Hook, and pass its state and the dispatch function to the components
    that need it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 定义完动作和reducer函数后，我们将定义Reducer Hook，并将其状态和dispatch函数传递给需要它的组件。
- en: 'Let''s start implementing the Reducer Hook:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现Reducer Hook：
- en: 'First, we have to import the `useReducer` Hook, by adjusting the following
    `import` statement in `src/App.js`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过调整`src/App.js`中的以下`import`语句来导入`useReducer` Hook：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Edit `src/App.js`, and remove the following State Hook:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，移除以下State Hook：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Replace the preceding State Hook with a Reducer Hook—the initial state is an
    empty string, as we had it before:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用Reducer Hook替换前面的State Hook——初始状态是一个空字符串，就像以前一样：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, pass the `user` state and the `dispatchUser` function to the `UserBar`
    component, as a `dispatch` prop:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`user`状态和`dispatchUser`函数作为`dispatch`属性传递给`UserBar`组件：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We do not need to modify the `CreatePost` component, as we are only passing
    the `user` state to it, and that part did not change.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要修改`CreatePost`组件，因为我们只是将`user`状态传递给它，而这部分没有改变。
- en: 'Next, we edit the `UserBar` component in `src/user/UserBar.js`, and replace
    the `setUser` prop with the `dispatch` function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编辑`src/user/UserBar.js`中的`UserBar`组件，并用`dispatch`函数替换`setUser`属性：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can edit the `Login` component in `src/user/Login.js`, and replace
    the `setUser` function with the `dispatch` function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编辑`src/user/Login.js`中的`Login`组件，并用`dispatch`函数替换`setUser`函数：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we replace the call to `setUser` with a call to the `dispatch` function,
    dispatching a `LOGIN` action:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用`dispatch`函数替换了对`setUser`的调用，派发一个`LOGIN`动作：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We could also make functions that return actions—so-called action creators.
    Instead of manually creating the action object every time, we could simply call
    `loginAction('username')` instead, which returns the corresponding `LOGIN` action
    object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建返回动作的函数，即所谓的动作创建者。我们可以简单地调用`loginAction('username')`，而不是每次手动创建动作对象，它会返回相应的`LOGIN`动作对象。
- en: 'We repeat the same process for the `Register` component in `src/user/Register.js`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`src/user/Register.js`中的`Register`组件中重复相同的过程：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we also repeat the same process for the `Logout` component in `src/user/Logout.js`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们也在`src/user/Logout.js`中的`Logout`组件中重复相同的过程：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, our app should work the same way as before, but it uses the Reducer Hook
    instead of a simple State Hook!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用应该和以前一样工作，但是它使用了Reducer Hook而不是简单的State Hook！
- en: Replacing the posts State Hook
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换posts State Hook
- en: It also makes sense to use a Reducer Hook for the `posts` state, because, later
    on, we are going to have features that can be used to delete and edit posts, so
    it makes a lot of sense to keep these complex state changes contained. Let's now
    get started replacing the posts State Hook with a Reducer Hook.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Reducer Hook来处理`posts`状态也是有道理的，因为以后我们会有一些功能可以用来删除和编辑帖子，所以将这些复杂的状态变化封装起来是很有意义的。现在让我们开始用Reducer
    Hook替换posts State Hook。
- en: Defining actions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义操作
- en: 'Again, we start by defining actions. At the moment, we are only going to consider
    a `CREATE_POST` action:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们首先定义操作。目前，我们只考虑`CREATE_POST`操作：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That is the only action we are going to need for posts, at the moment.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目前需要的唯一操作。
- en: Defining the reducer
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义reducer
- en: 'Next, we are going to define the reducer function in a similar way that we
    did for the `user` state:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以与`user`状态相似的方式定义reducer函数：
- en: 'We start by editing `src/App.js`, and defining the reducer function there.
    The following code defines the `postsReducer` function:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编辑`src/App.js`，在那里定义reducer函数。以下代码定义了`postsReducer`函数：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this function, we are going to handle the `CREATE_POST` action. We first
    create a `newPost` object, and then we insert it at the beginning of the current
    `posts` state by using spread syntax, in a similar way to how we did it in the
    `src/post/CreatePost.js` component earlier:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将处理`CREATE_POST`操作。我们首先创建一个`newPost`对象，然后使用扩展语法将其插入到当前`posts`状态的开头，类似于我们之前在`src/post/CreatePost.js`组件中所做的方式：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For now, this will be the only action that we handle in this reducer, so we
    can now define the `default` statement:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，这将是我们在这个reducer中处理的唯一操作，所以我们现在可以定义`default`语句：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the `postsReducer` function is defined, and we can move on to creating
    the Reducer Hook.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`postsReducer`函数已经定义，我们可以继续创建Reducer Hook。
- en: Defining the Reducer Hook
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Reducer Hook
- en: 'Finally, we are going to define and use the Reducer Hook for the `posts` state:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义并使用`posts`状态的Reducer Hook：
- en: 'We start by removing the following State Hook in `src/App.js`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在`src/App.js`中删除以下State Hook：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We replace it with the following Reducer Hook:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下Reducer Hook替换它：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we pass the `dispatchPosts` function to the `CreatePost` component, as
    a `dispatch` prop:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`dispatchPosts`函数作为`dispatch`属性传递给`CreatePost`组件：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we edit the `CreatePost` component in `src/post/CreatePost.js`, and replace
    the `setPosts` function with the `dispatch` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编辑`src/post/CreatePost.js`中的`CreatePost`组件，并用`dispatch`函数替换`setPosts`函数：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we use the `dispatch` function in the `handleCreate` function:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`handleCreate`函数中使用`dispatch`函数：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, the `posts` state also uses a Reducer Hook instead of a State Hook, and
    it works in the same way as before! However, if we want to add more logic for
    managing posts, such as searching, filtering, deleting, and editing, later on,
    it will be much easier to do so.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`posts`状态也使用Reducer Hook而不是State Hook，并且与以前的方式一样工作！然而，如果以后我们想要添加更多逻辑来管理帖子，比如搜索、过滤、删除和编辑，那么这将更容易做到。
- en: Example code
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for using Reducer Hooks in our blog app can be found in the
    `Chapter04/chapter4_1` folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客应用程序中使用Reducer Hook的示例代码可以在`Chapter04/chapter4_1`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Merging Reducer Hooks
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并Reducer Hook
- en: 'Currently, we have two different dispatch functions: one for the `user` state,
    and one for the `posts` state. In our case, it makes sense to combine the two
    reducers into one, which then calls further reducers, in order to deal with the
    sub-state.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有两个不同的dispatch函数：一个用于`user`状态，一个用于`posts`状态。在我们的情况下，将这两个reducers合并成一个是有意义的，然后调用进一步的reducers来处理子状态。
- en: This pattern is similar to the way in which reducers work in Redux, where we
    only have one object containing the whole state tree of the application, which
    in the case of the global state, makes sense. However, for complex local state
    changes, it might make more sense to keep the reducers separate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式类似于Redux中reducer的工作方式，其中我们只有一个包含整个应用程序状态树的对象，在全局状态的情况下是有意义的。然而，对于复杂的局部状态更改，将reducers保持分开可能更有意义。
- en: 'Let''s start merging our reducer functions into one reducer function. While
    we are at it, let''s refactor all the reducers into a `src/reducers.js` file,
    in order to keep the `src/App.js` file more readable:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将我们的reducer函数合并成一个reducer函数。在此过程中，让我们将所有reducers重构到`src/reducers.js`文件中，以使`src/App.js`文件更易读：
- en: Create a new `src/reducers.js` file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/reducers.js`文件。
- en: 'Cut the following code from the `src/App.js` file, and paste it into the `src/reducers.js`
    file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/App.js`文件中剪切以下代码，并粘贴到`src/reducers.js`文件中：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Edit `src/reducers.js`, and define a new reducer function below the existing
    reducer functions, called `appReducer`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/reducers.js`，并在现有的reducer函数下面定义一个新的reducer函数，名为`appReducer`：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this `appReducer` function, we are going to call the other two reducer functions,
    and return the full state tree:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`appReducer`函数中，我们将调用另外两个reducer函数，并返回完整的状态树：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Edit `src/App.js`, and import the `appReducer` there:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并在那里导入`appReducer`：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we remove the following two Reducer Hook definitions:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们移除以下两个Reducer Hook定义：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We replace the preceding Reducer Hook definitions with a single Reducer Hook
    definition for the `appReducer`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用`appReducer`的单一Reducer Hook定义替换前面的Reducer Hook定义：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we extract the `user` and `posts` values from our `state` object, using
    destructuring:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用解构从我们的`state`对象中提取`user`和`posts`的值：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we still need to replace the `dispatchUser` and `dispatchPosts` functions
    that we passed to the other components with the `dispatch` function:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们仍然需要用`dispatch`函数替换我们传递给其他组件的`dispatchUser`和`dispatchPosts`函数：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see, now there is only one `dispatch` function, and a single state
    object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，现在只有一个`dispatch`函数和一个单一的状态对象。
- en: Ignoring unhandled actions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略未处理的actions
- en: 'However, if we try logging in now, we are going to see an error from the `postsReducer`.
    This is because we are still throwing an error on unhandled actions. In order
    to avoid this, we have to instead ignore unhandled actions, and simply return
    the current state:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在尝试登录，我们将会看到来自`postsReducer`的错误。这是因为我们仍然在未处理的actions上抛出错误。为了避免这种情况，我们必须忽略未处理的actions，简单地返回当前状态：
- en: 'Edit the `userReducer` and `postsReducer` functions in `src/reducers.js`, and
    remove the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`src/reducers.js`中的`userReducer`和`postsReducer`函数，并移除以下代码：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Replace the preceding code with a `return` statement that returns the current
    `state`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个`return`语句替换前面的代码，该语句返回当前的`state`：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we can see, now our app still works in exactly the same way as before, but
    we are using a single reducer for our whole app state!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，现在我们的应用程序仍然以与以前完全相同的方式工作，但我们正在使用一个单一的reducer来处理整个应用程序状态！
- en: Example code
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for using a single Reducer Hook in our blog app can be found
    in the `Chapter04/chapter4_2` folder.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们博客应用程序中使用单一Reducer Hook的示例代码可以在`Chapter04/chapter4_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行“npm install”以安装所有依赖项，然后运行“npm start”启动应用程序，然后在浏览器中访问“http://localhost:3000”（如果没有自动打开）。
- en: Using Effect Hooks
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Effect Hooks
- en: The last essential Hook that we are going to be using frequently is the Effect
    Hook. Using the Effect Hook, we can perform side effects from our components,
    such as fetching data when the component mounts or updates.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常使用的最后一个重要Hook是Effect Hook。 使用Effect Hook，我们可以从我们的组件执行副作用，例如在组件挂载或更新时获取数据。
- en: In the case of our blog, we are going to implement a feature that updates the
    title of our web page when we log in, so that it contains the username of the
    currently logged-in user.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客案例中，我们将实现一个功能，当我们登录时更新我们网页的标题，以便包含当前登录用户的用户名。
- en: Remember componentDidMount and componentDidUpdate?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记得componentDidMount和componentDidUpdate吗？
- en: 'If you have worked with React before, you have probably used the `componentDidMount`
    and `componentDidUpdate` life cycle methods. For example, we can set the document
    `title` to a given prop as follows, using a React class component. In the following
    code section, the life cycle method is highlighted in bold:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过React，您可能已经使用了“componentDidMount”和“componentDidUpdate”生命周期方法。 例如，我们可以使用React类组件将文档“title”设置为给定的prop，如下所示。
    在下面的代码部分中，生命周期方法用粗体标出：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This works fine. However, when the `title` prop updates, the change does not
    get reflected in the title of our web page. To solve this problem, we need to
    define the `componentDidUpdate` life cycle method (new code in bold), as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。 但是，当“title”prop更新时，更改不会反映在我们网页的标题中。 为了解决这个问题，我们需要定义“componentDidUpdate”生命周期方法（新代码用粗体标出），如下所示：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You might have noticed that we are writing almost the same code twice; therefore,
    we could create a new method to deal with updates to `title`, and then call it
    from both life cycle methods. In the following code section, the updated code
    is highlighted in bold:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们几乎写了相同的代码两次；因此，我们可以创建一个新方法来处理“title”的更新，然后从两个生命周期方法中调用它。 在下面的代码部分中，更新的代码用粗体标出：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, we still need to call `this.updateTitle()` twice. When we update the
    code later on, and, for example, pass an argument to `this.updateTitle()`, we
    always need to remember to pass it in both calls to the method. If we forget to
    update one of the life cycle methods, we might introduce bugs. Furthermore, we
    need to add an `if` condition to `componentDidUpdate`, in order to avoid calling
    `this.updateTitle()` when the `title` prop did not change.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们仍然需要两次调用“this.updateTitle()”。 当我们稍后更新代码时，例如，向“this.updateTitle()”传递参数时，我们始终需要记住在两次调用方法时传递它。
    如果我们忘记更新其中一个生命周期方法，可能会引入错误。 此外，我们需要在“componentDidUpdate”中添加一个“if”条件，以避免在“title”prop未更改时调用“this.updateTitle()”。
- en: Using an Effect Hook
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Effect Hook
- en: In the world of Hooks, the `componentDidMount` and `componentDidUpdate` life
    cycle methods are combined in the `useEffect` Hook, which—when not specifying
    a dependency array—triggers whenever any props in the component change.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hooks的世界中，“componentDidMount”和“componentDidUpdate”生命周期方法在“useEffect”Hook中合并在一起，当不指定依赖数组时，会在组件中的任何prop更改时触发。
- en: 'So, instead of using a class component, we can now define a function component
    with an Effect Hook, which does the same thing as before. The function passed
    to the Effect Hook is called "effect function":'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以使用Effect Hook定义一个带有Effect Hook的函数组件，它与以前的功能相同。 传递给Effect Hook的函数称为“effect函数”：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And that's all we need to do! The Hook that we have defined will call our effect
    function every time any props change.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的一切！ 我们定义的Hook将在任何prop更改时调用我们的effect函数。
- en: Trigger effect only when certain props change
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅在某些props更改时触发效果
- en: 'If we want to make sure that our effect function only gets called when the
    `title` prop changes, for example, for performance reasons, we can specify which
    values should trigger the changes, as a second argument to the `useEffect` Hook:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要确保我们的效果函数只在`title` prop发生变化时才被调用，例如出于性能原因，我们可以指定应该触发更改的值，作为`useEffect`
    Hook的第二个参数：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And this is not just restricted to props, we can use any value here, even values
    from other Hooks, such as a State Hook or a Reducer Hook:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这不仅限于props，我们可以在这里使用任何值，甚至来自其他Hooks的值，比如State Hook或Reducer Hook：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we can see, using an Effect Hook is much more straightforward than using
    life cycle methods when dealing with changing values.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用Effect Hook比使用生命周期方法处理变化的值要简单得多。
- en: Trigger effect only on mount
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅在挂载时触发效果
- en: 'If we want to replicate the behavior of only adding a `componentDidMount` life
    cycle method, without triggering when the props change, we can do this by passing
    an empty array as the second argument to the `useEffect` Hook:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要复制仅添加`componentDidMount`生命周期方法的行为，而不在props更改时触发，我们可以通过将空数组作为`useEffect`
    Hook的第二个参数来实现这一点：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Passing an empty array means that our effect function will only trigger once
    when the component mounts, and it will not trigger when props change. However,
    instead of thinking about the mounting of components, with Hooks, we should think
    about the dependencies of effects. In this case, the effect does not have any
    dependencies, which means it will only trigger once. If an effect has dependencies
    specified, it will trigger again when any of the dependencies change.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个空数组意味着我们的效果函数只会在组件挂载时触发一次，并且不会在props更改时触发。然而，与其考虑组件的挂载，使用Hooks，我们应该考虑效果的依赖关系。在这种情况下，效果没有任何依赖关系，这意味着它只会触发一次。如果一个效果有指定的依赖关系，当任何依赖关系发生变化时，它将再次触发。
- en: Cleaning up effects
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理效果
- en: 'Sometimes effects need to be cleaned up when the component unmounts. To do
    so, we can return a function from the effect function of the Effect Hook. This
    returned function works similarly to the `componentWillUnmount` life cycle method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时效果在组件卸载时需要清理。为此，我们可以从Effect Hook的效果函数中返回一个函数。这个返回的函数类似于`componentWillUnmount`生命周期方法：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The code marked in bold above is called the cleanup function. The cleanup function
    will be called when the component unmounts and before running the effect again.
    This avoids bugs when, for example, the `updateTime` prop changes. In that case,
    the previous effect will be cleaned up and a new interval with the updated `updateTime` value
    will be defined.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上面加粗的代码被称为清理函数。清理函数将在组件卸载时调用，并在再次运行效果之前调用。这可以避免bug，例如`updateTime` prop发生变化。在这种情况下，先前的效果将被清理，并且将使用更新的`updateTime`值定义一个新的间隔。
- en: Implementing an Effect Hook in our blog app
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的博客应用程序中实现一个Effect Hook
- en: Now that we have learned how the Effect Hook works, we are going to use it in
    our blog app, to implement the title changing when we log in/log out (when the
    `user` state changes).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了Effect Hook的工作原理，我们将在我们的博客应用程序中使用它，以在登录/注销时实现标题更改（当`user`状态发生变化时）。
- en: 'Let''s get started implementing an Effect Hook in our blog app:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的博客应用程序中实现一个Effect Hook：
- en: 'Edit `src/App.js`, and import the `useEffect` Hook:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并导入`useEffect` Hook：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After defining our `useReducer` Hook and the state destructuring, define a
    `useEffect` Hook that adjusts the `document.title` variable, based on the `username` value:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了我们的`useReducer` Hook和状态解构之后，定义一个`useEffect` Hook，根据`username`值调整`document.title`变量：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the user is logged in, we set the `document.title` to `<username> - React
    Hooks Blog`. We use template strings for this, which allow us to include variables,
    or JavaScript expressions, in a string via the `${ }` syntax. Template strings
    are defined using [PRE66]
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已登录，我们将`document.title`设置为`<username> - React Hooks Blog`。我们使用模板字符串，允许我们通过`${
    }`语法在字符串中包含变量或JavaScript表达式。模板字符串使用[PRE66]定义
- en: if (user) {
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: if (user) {
- en: document.title = `${user} - React Hooks Blog`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: document.title = `${user} - React Hooks Blog`
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '} else {'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: document.title = 'React Hooks Blog'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: document.title = 'React Hooks Blog'
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '}, [user])'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '}, [user])'
- en: '```'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we start our app now, we can see that the `document.title` gets set to `React
    Hooks Blog`, because the Effect Hook triggers when the `App` component mounts,
    and the `user` value is not defined yet:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动我们的应用程序，我们可以看到`document.title`被设置为`React Hooks Blog`，因为Effect Hook在`App`组件挂载时触发，而`user`值尚未定义：
- en: '![](assets/7e34bb73-64d7-4c65-8d7e-6d6f6628f317.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e34bb73-64d7-4c65-8d7e-6d6f6628f317.png)'
- en: 'The effect of our Effect Hook: changing the web page title'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Effect Hook的效果：改变网页标题
- en: 'After logging in with `Test User`, we can see that the `document.title` changes
    to `Test User - React Hooks Blog`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Test User`登录后，我们可以看到`document.title`更改为`Test User - React Hooks Blog`：
- en: '![](assets/7cb775dc-c5c3-4469-a41f-acb25f83e14f.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7cb775dc-c5c3-4469-a41f-acb25f83e14f.png)'
- en: The effect of our Effect Hook re-triggering, after the user value changes
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Effect Hook重新触发的效果，用户值更改后
- en: As we can see, our Effect Hook re-triggers successfully after the `user` value
    changes!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的Effect Hook在`user`值更改后成功重新触发！
- en: Example code
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for implementing Effect Hooks in our blog app can be found
    in the `Chapter04/chapter4_3` folder.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客应用程序中实现Effect Hooks的示例代码可以在`Chapter04/chapter4_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。 '
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first learned about actions, reducers, and Reducer Hooks.
    We also learned when we should use Reducer Hooks instead of State Hooks. Then,
    we replaced our existing global State Hooks for the `user` and `posts` states,
    with two Reducer Hooks. Next, we merged the two Reducer Hooks into a single app
    Reducer Hook. Finally, we learned about Effect Hooks, and how they can be used
    instead of `componentDidMount` and `componentDidUpdate`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了actions、reducers和Reducer Hooks。我们还学习了何时应该使用Reducer Hooks而不是State
    Hooks。然后，我们用两个Reducer Hooks替换了现有的全局State Hooks，用于`user`和`posts`状态。接下来，我们将两个Reducer
    Hooks合并为一个单一的app Reducer Hook。最后，我们学习了Effect Hooks，以及它们如何可以代替`componentDidMount`和`componentDidUpdate`。
- en: In the next chapter, we are going to learn about React context, and how to use
    it with Hooks. Then, we are going to add Context Hooks to our app, in order to
    avoid having to pass down props over multiple layers of components.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于React context，以及如何在Hooks中使用它。然后，我们将向我们的应用程序添加Context Hooks，以避免在多个组件层中传递props。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章学到的内容，请尝试回答以下问题：
- en: What are the common problems with State Hooks?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: State Hooks有哪些常见问题？
- en: What are actions?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是actions？
- en: What are reducers?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是reducer？
- en: When should we use a Reducer Hook instead of a State Hook?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用Reducer Hook而不是State Hook？
- en: Which steps are needed in order to turn a State Hook into a Reducer Hook?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将State Hook转换为Reducer Hook需要哪些步骤？
- en: How can we create actions more easily?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更轻松地创建actions？
- en: When should we merge Reducer Hooks?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该合并Reducer Hooks？
- en: What do we need to watch out for when merging Reducer Hooks?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合并Reducer Hooks时需要注意什么？
- en: What is the equivalent of an Effect Hook in class components?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类组件中，等效于Effect Hook的是什么？
- en: What are the advantages of using an Effect Hook, versus class components?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Effect Hook与类组件相比有哪些优势？
- en: Further reading
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have explored
    in this chapter, take a look at the following reading material:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章探讨的概念更感兴趣，可以查阅以下阅读材料：
- en: Official docs regarding the Reducer Hook: [https://reactjs.org/docs/hooks-reference.html#usereducer](https://reactjs.org/docs/hooks-reference.html#usereducer)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Reducer Hook的官方文档：[https://reactjs.org/docs/hooks-reference.html#usereducer](https://reactjs.org/docs/hooks-reference.html#usereducer)
- en: Official docs and tips for using Effect Hooks: [https://reactjs.org/docs/hooks-effect.html](https://reactjs.org/docs/hooks-effect.html)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档和使用Effect Hooks的技巧：[https://reactjs.org/docs/hooks-effect.html](https://reactjs.org/docs/hooks-effect.html)
- en: '*Learning Redux* published by *Pa**ckt* for more in-depth information about
    actions, reducers, and managing the app state:[https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Learning Redux* 由 *Pa**ckt* 出版，提供有关操作、减速器和管理应用状态的更深入信息：[https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)'
