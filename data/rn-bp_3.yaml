- en: Car Booking App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汽车预订应用
- en: In the previous chapters, we set the focus on feature development rather than
    in building a user interface by delegating the styling of our apps to UI libraries
    such as `native-base`. In this chapter, we are going to do the opposite and spend
    more time in building custom UI components and screens.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们将重点放在功能开发上，而不是在构建用户界面上，将我们应用的样式委托给UI库，如`native-base`。在本章中，我们将做相反的事情，花更多的时间来构建自定义UI组件和屏幕。
- en: The app we will build is a car booking app in which the user can select the
    location in which he/she wants to be picked up and the type of car she wants to
    book for the ride. Since we want to focus on the user interface, our app will
    only have two screens and a little state management is needed. Instead, we will
    dive deeper into aspects such as animations, component's layout, using custom
    fonts, or displaying external images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的应用是一个汽车预订应用，用户可以选择想要被接送的位置以及想要预订的车辆类型。由于我们想要专注于用户界面，我们的应用只会有两个屏幕，并且需要一些状态管理。相反，我们将更深入地研究诸如动画、组件布局、使用自定义字体或显示外部图像等方面。
- en: 'The app will be available for iOS and Android devices, and since all the user
    interface will be custom made, 100% of the code will be reused between both platforms.
    We will only use two external libraries:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用将适用于iOS和Android设备，由于所有用户界面都将是定制的，因此代码的100%将在两个平台之间重复使用。我们只会使用两个外部库：
- en: '`React-native-geocoder`: This will translate coordinates into human-readable
    locations'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- `React-native-geocoder`：这将把坐标转换为人类可读的位置'
- en: '`React-native-maps`: This will easily display the maps and the markers showing
    the locations for the bookable cars'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- `React-native-maps`：这将轻松显示地图和显示可预订汽车位置的标记'
- en: Due to its nature, most of the car booking apps put their complexity in the
    backend code to connect drivers with riders effectively. We will skip this complexity
    and mock all that functionality in the app itself to focus on building beautiful
    and usable interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其性质，大多数汽车预订应用将其复杂性放在后端代码中，以有效地连接司机和乘客。我们将跳过这种复杂性，并在应用程序本身中模拟所有这些功能，以便专注于构建美观和可用的界面。
- en: Overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: When building mobile apps, we need to make sure we reduce the interface complexity
    to the minimum, as it's often punishing to present the user intrusive manuals
    or tooltips once the app is open. It is a good practice to make our app self-explanatory,
    so the user can understand the usage just by going through the app screens. That's
    why using standard components such as drawer menus or standard lists is always
    a good idea, but is not always possible (as it happens in our current app) due
    to the kind of data we want to present to the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建移动应用程序时，我们需要确保将界面复杂性降至最低，因为一旦应用程序打开，向用户呈现侵入式手册或工具提示通常是有害的。让我们的应用自解释是一个好习惯，这样用户就可以通过浏览应用屏幕来理解使用方法。这就是为什么使用标准组件，如抽屉菜单或标准列表，总是一个好主意，但并非总是可能的（就像我们当前的应用中发生的情况），因为我们想要向用户呈现的数据类型。
- en: 'In our case, we put all the functionality in the main screen plus in a modal
    box. Let''s take a look at what the app will look like on iOS devices:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将所有功能放在主屏幕和一个模态框中。让我们来看看这款应用在iOS设备上的样子：
- en: '![](Images/3b60528e-707c-4170-bc36-c41da3500304.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b60528e-707c-4170-bc36-c41da3500304.png)'
- en: 'The background on our main screen is the maps component itself where we will
    show all the available cars as markers in the map. On the maps, we will display
    three components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主屏幕的背景是地图组件本身，我们将在地图中显示所有可用的汽车作为标记。在地图上，我们将显示三个组件：
- en: The pickup location box displaying the selected pickup location
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 选择位置框，显示所选的接送位置'
- en: The location pin, which can be dragged around the maps to select a new location
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 位置图钉，可以在地图上拖动以选择新位置'
- en: 'The selector for the kind of car the user wants to book. We will display three
    options: ECONOMY, SPECIAL, and SUPERIOR'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户想要预订的汽车类型的选择器。我们将显示三个选项：经济型，特别型和高级型
- en: 'Since most of the components are custom built, this screen will look very similar
    in any Android device:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数组件都是自定义构建的，因此此屏幕在任何Android设备上看起来都非常相似：
- en: '![](Images/8880df9a-f99d-44ff-99c7-febbba8e5f7e.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8880df9a-f99d-44ff-99c7-febbba8e5f7e.png)'
- en: The main difference between the iOS and the Android version will be the map
    component. While iOS will use Apple maps by default, Android uses Google Maps.
    We will leave this setup as each platform has its own map component optimized,
    but it's good to know that we can switch the iOS version to use Google Maps just
    by configuring our component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Android版本之间的主要区别将是地图组件。虽然iOS将默认使用Apple地图，但Android使用Google地图。我们将保留此设置，因为每个平台都有其自己优化的地图组件，但值得知道的是，我们可以通过配置我们的组件将iOS版本切换到使用Google地图。
- en: 'Once the user has selected a pickup location, we will display a modal box to
    confirm the booking and contact the nearest driver for pickup:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了取货地点，我们将显示一个模态框来确认预订并联系最近的司机接送。
- en: '![](Images/83e52b8a-aa1a-4ffb-8038-1674d218a04e.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/83e52b8a-aa1a-4ffb-8038-1674d218a04e.png)'
- en: 'As it happened with the main screen, this screen uses custom components: we
    even decided to create our own animated activity indicator. Because of this, the
    Android version will look very similar:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与主屏幕一样，此屏幕使用自定义组件：我们甚至决定创建自己的动画活动指示器。因此，Android版本将看起来非常相似：
- en: '![](Images/e0509761-3ae7-411e-b42d-3950dd862706.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e0509761-3ae7-411e-b42d-3950dd862706.png)'
- en: Since our app won't be connected to any external API, it should be seen as a
    mere display of the visual capabilities of React Native, although it could be
    easily extended by adding a state management library and a matching API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序不会连接到任何外部API，它应该被视为React Native的视觉能力的纯粹展示，尽管可以通过添加状态管理库和匹配的API轻松扩展。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using maps in our app
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用地图
- en: Style sheets in React Native
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native中的样式表
- en: Flexbox in React Native
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native中的Flexbox
- en: Using external images in a React Native app
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React Native应用程序中使用外部图像
- en: Adding custom fonts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: Animations in React Native
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native中的动画
- en: Using modals
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模态框
- en: Working with shadows and opacity
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理阴影和不透明度
- en: Setting up the folder structure
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `carBooking` and will be available for iOS and Android devices:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用React Native的CLI初始化一个React Native项目。 该项目将被命名为`carBooking`，并将适用于iOS和Android设备：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this app, there is only one screen so that the folder structure for the
    code should be very straightforward. Since we will be using external images and
    fonts, we will organize these resources in two separate folders: `img` and `fonts`,
    both under the root folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，只有一个屏幕，因此代码的文件夹结构应该非常简单。由于我们将使用外部图像和字体，我们将这些资源组织在两个单独的文件夹中：`img`和`fonts`，都在根文件夹下：
- en: '![](Images/0053ce62-8087-4ee6-a811-f71a3793b29a.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0053ce62-8087-4ee6-a811-f71a3793b29a.jpg)'
- en: The images and fonts used to build this app can be downloaded freely from some
    image and font sock websites. The name of the font we will use is *Blair ITC*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建此应用程序的图像和字体可以从一些图像和字体库网站免费下载。我们将使用的字体名称是*Blair ITC*。
- en: 'We also stored the following images inside the `img` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将以下图像存储在`img`文件夹中：
- en: '`car.png`: A simple drawing of a car to represent the bookable cars on the
    map.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car.png`：一辆汽车的简单图画，用于表示地图上可预订的汽车。'
- en: '`class.png`: The silhouette of a car to show inside the class selection button.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class.png`：一辆汽车的轮廓，显示在类别选择按钮内部。'
- en: '`classBar.png`: The bar in which the class selection button will be slid to
    change the class.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classBar.png`：用于滑动更改班级选择按钮的栏。'
- en: '`loading.png`: Our custom spinner. It will be stored as a static image and
    animated through the code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading.png`：我们自定义的旋转器。它将被存储为静态图像，并通过代码进行动画处理。'
- en: 'Finally, let''s take a look at our `package.json` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们的`package.json`文件：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We only use two npm modules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用两个npm模块：
- en: '`react-native-geocoder`: This translates coordinates into human-readable locations'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-geocoder`：这将坐标转换为可读的位置'
- en: '`react-native-maps`: This easily displays the maps and the markers showing
    the locations for the bookable cars'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-maps`：这可以轻松显示地图和显示可预订汽车位置的标记'
- en: In order to allow the app to use custom fonts, we need to make sure they are
    accessible from the native side. For that, we need to add a new key to `package.json`
    named `rnpm`. This key will store an array of `assets` in which we will define
    our `fonts` folder. During build time, React Native will copy the fonts to a location
    from where they will be available natively and therefore usable within our code.
    This is only required by fonts and some special resources, but not by images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序使用自定义字体，我们需要确保它们可以从本机端访问。为此，我们需要在`package.json`中添加一个名为`rnpm`的新键。这个键将存储一个`assets`数组，在其中我们将定义我们的`fonts`文件夹。在构建时，React
    Native将把字体复制到一个位置，从那里它们将在本机端可用，因此可以在我们的代码中使用。这仅对字体和一些特殊资源是必需的，但不适用于图像。
- en: Files and folders created by React Native's CLI
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由React Native的CLI创建的文件和文件夹
- en: Let's take the chance of having a simple folder structure in this app to show
    what other files and folders are created by React Native's CLI when initializing
    a project through `react-native init <projectName>`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这个应用程序中的简单文件夹结构来展示通过`react-native init <projectName>`初始化项目时React Native的CLI创建的其他文件和文件夹。
- en: __tests__/
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __测试__/
- en: React Native's CLI includes Jest as a developer dependency and, to get testing
    started, it includes a folder named `__tests__`, in which all tests can be stored.
    By default, React Native's CLI adds one test file: `index.js` , representing the
    initial set of tests. Developers can add later tests for any components in the
    app. React Native also adds a `test` script in our `package.json`, so we can run `npm
    run test` from the very first moment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的CLI包括Jest作为开发人员依赖项，并且为了开始测试，它包括一个名为`__tests__`的文件夹，其中可以存储所有测试。默认情况下，React
    Native的CLI添加一个测试文件：`index.js`，代表初始一组测试。开发人员可以为应用程序中的任何组件添加后续测试。React Native还在我们的`package.json`中添加了一个`test`脚本，因此我们可以从一开始就运行`npm
    run test`。
- en: Jest is ready to be used with every project initialized through the CLI and
    it's definitely the easiest option when it comes to testing React components,
    although it is also possible to use other libraries such as Jasmine or Mocha.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Jest已准备好与通过CLI初始化的每个项目一起使用，当涉及到测试React组件时，它绝对是最简单的选择，尽管也可以使用其他库，如Jasmine或Mocha。
- en: android/ and ios/
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: android/和ios/
- en: These two folders hold the built app for both platforms natively. This means
    that we can find our `.xcodeproj` and `.java` files in here. Every time we need
    to make changes to the native code of our app, we will need to modify some files
    in these two directories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件夹分别保存了两个平台的原生构建应用程序。这意味着我们可以在这里找到我们的`.xcodeproj`和`.java`文件。每当我们需要对应用程序的本机代码进行更改时，我们都需要修改这两个目录中的一些文件。
- en: 'The most common reasons to find and modify files in these folders are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件夹中查找和修改文件的最常见原因是：
- en: Modify permissions (push notifications, access to location services, access
    to compass, and many more) by changing `Info.plist` (iOS) or `AndroidManifest.xml` (Android)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改`Info.plist`（iOS）或`AndroidManifest.xml`（Android）来修改权限（推送通知，访问位置服务，访问指南针等）
- en: Change the build settings for any platform
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改任何平台的构建设置
- en: Add API keys for native libraries
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为原生库添加API密钥
- en: Add or modify native libraries to be used from our React Native code
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或修改原生库，以便从我们的React Native代码中使用
- en: node_modules/
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: node_modules/
- en: This folder should be familiar to most of the JavaScript developers who worked
    with npm as it is where npm stores all the modules marked as a dependency in our
    project. It is not common to have the necessity to modify anything inside this
    folder, as everything should be handled through npm's CLI and our `package.json`
    file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹对大多数使用npm的JavaScript开发人员来说应该很熟悉，因为npm将所有标记为项目依赖项的模块存储在这里。在这个文件夹内修改任何内容的必要性并不常见，因为一切都应该通过npm的CLI和我们的`package.json`文件来处理。
- en: Files in the root folder
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件夹中的文件
- en: 'React Native''s CLI creates a number of files in the root directory of our
    project; let''s take a look at the most important ones:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的CLI在项目的根目录中创建了许多文件；让我们来看看最重要的文件：
- en: '`.babelrc`: Babel is the default library in React Native to compile our JavaScript
    files containing JSX and ES6 (for example, syntax into plain JavaScript capable
    to be understood by most of the JavaScript engines). Here, we can modify the configuration
    for this compiler so we can, for example, use the `@` syntax for decorators as
    it was done in the first versions of React.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.babelrc`：Babel是React Native中用于编译包含JSX和ES6（例如，语法的JavaScript文件的默认库，可以转换为大多数JavaScript引擎能够理解的普通JavaScript）。在这里，我们可以修改这个编译器的配置，例如，我们可以使用`@`语法作为装饰器，就像在React的最初版本中所做的那样。'
- en: '`.buckconfig`: Buck is the build system used by Facebook. This file is used
    to configure the building process when using Buck.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.buckconfig`：Buck是Facebook使用的构建系统。这个文件用于配置使用Buck时的构建过程。'
- en: '`.watchmanconfig`: Watchman is a service that watches the files in our project
    to trigger a rebuild anytime something changes in them. In this file, we can add
    some configuration options such as directories, which should be ignored.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.watchmanconfig`：Watchman是一个监视项目中文件的服务，以便在文件发生变化时触发重新构建。在这个文件中，我们可以添加一些配置选项，比如应该被忽略的目录。'
- en: '`app.json`: This file is used by the `react-native eject` command to configure
    the native apps. It stores the name that identifies the app in each platform and
    also the name that will be displayed on the home screen of the device when the
    app is installed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.json`：这个文件被`react-native eject`命令用来配置原生应用程序。它存储了在每个平台上标识应用程序的名称，以及在设备的主屏幕上安装应用程序时将显示的名称。'
- en: '`yarn.lock`: The `package.json` file describes the intended versions desired
    by the original author, while `yarn.lock` describes the last-known-good configuration
    for a given application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn.lock`：`package.json`文件描述了原始作者期望的版本，而`yarn.lock`描述了给定应用程序的最后已知的良好配置。'
- en: react-native link
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: react-native link
- en: Some apps depend on libraries with native capabilities which, before React Native
    CLI, required developers to copy native library files into the native projects.
    This was a cumbersome and repetitive project until `react-native link` came to
    the rescue. In this chapter we will use it to copy library files from `react-native-maps`
    and to link custom fonts from our `/fonts` folder to the compiled app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序依赖具有原生能力的库，在React Native CLI之前，开发人员需要将原生库文件复制到原生项目中。这是一个繁琐和重复的工作，直到`react-native
    link`出现才得以解救。在本章中，我们将使用它来从`react-native-maps`复制库文件，并将自定义字体从我们的`/fonts`文件夹链接到编译后的应用程序。
- en: By running `react-native link` in our project's root folder we will trigger
    the linking steps which will result in those native capabilities and resources
    to be accessible from our React Native code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目的根文件夹中运行`react-native link`，我们将触发链接步骤，这将使那些原生能力和资源可以从我们的React Native代码中访问。
- en: Running the app in the simulator
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模拟器中运行应用程序
- en: 'Having the dependencies in the `package.json` file and all the initial files
    in place, we can run the following command (in the root folder of our project)
    to finish the installation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中具有依赖项并且所有初始文件就位后，我们可以运行以下命令（在项目的根文件夹中）来完成安装：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, all the dependencies should be installed in our project. Once npm finishes
    installing all dependencies, we can start our app in the iOS simulator:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有依赖项都应该安装在我们的项目中。一旦npm完成安装所有依赖项，我们就可以在iOS模拟器中启动我们的应用程序：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or in the Android emulator using the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Android模拟器中使用以下命令：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When React Native detects the app is running in a simulator, it enables a developer
    toolset available through a hidden menu, which can be accessed through the shortcuts
    *command* + *D* on iOS or *command* + *M* on Android (on Windows C*trl* should be
    used instead of *command*). This is how the developer menu looks like in iOS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当React Native检测到应用程序在模拟器中运行时，它会通过一个隐藏菜单启用开发人员工具集，可以通过快捷键*command* + *D*（在iOS上）或*command*
    + *M*（在Android上，Windows上应使用*Crtl*而不是*command*）访问。这是iOS中开发人员菜单的样子：
- en: '![](Images/ca86bd23-ab53-45fb-9b9b-88a40471d7a0.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ca86bd23-ab53-45fb-9b9b-88a40471d7a0.png)'
- en: 'And this is how it looks like in the Android simulator:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Android模拟器中的样子：
- en: '![](Images/91050c83-c0e0-4ae1-bf22-dfbaf6c3e5b7.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/91050c83-c0e0-4ae1-bf22-dfbaf6c3e5b7.png)'
- en: The developer menu
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员菜单
- en: In the process of building an app in React Native, the developer will have debugging
    needs. React Native fulfills these needs with the ability to remotely debug our
    apps in Chrome developer's tools or external applications such as React Native
    Debugger. Errors, logs, and even React components can be debugged easily as in
    a normal web environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建React Native应用程序的过程中，开发人员将需要调试。React Native通过能够在Chrome开发者工具或外部应用程序（如React
    Native Debugger）中远程调试我们的应用程序来满足这些需求。错误、日志甚至React组件都可以像在普通的Web环境中一样轻松地进行调试。
- en: 'On top of that, React Native provides a way to automatically reload our app
    each time a change is done saving the developers the task of manually reloading
    the app (which can be achieved by pressing *command* + *R* or *Ctrl* + *R*). There
    are two options when we set our app for automatic reloading:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React Native提供了一种自动重新加载应用程序的方式，每次进行更改时都会重新加载应用程序，从而节省了开发人员手动重新加载应用程序的任务（可以通过按*command*
    + *R*或*Ctrl* + *R*来实现）。当我们为自动重新加载设置应用程序时，有两个选项：
- en: Live reload detects any changes we make in the app's code and resets the app
    to its initial state after reloading.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时重新加载检测到我们在应用程序代码中进行的任何更改，并在重新加载后将应用程序重置为其初始状态。
- en: Hot reload also detects changes and reloads the app, but keeps the current state
    of the app. This is really useful when we are implementing user flows to save
    the developer to repeat each step in the flow (for example, logging in or registering
    test users)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热重载还可以检测更改并重新加载应用程序，但保持应用程序的当前状态。当我们正在实现用户流程以节省开发人员重复每个步骤时（例如，登录或注册测试用户）时，这非常有用。
- en: Finally, we can start the performance monitor to detect possible performance
    issues when performing complex operations such as animations or mathematical calculations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启动性能监视器来检测执行复杂操作（如动画或数学计算）时可能出现的性能问题。
- en: Creating our app's entry point
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们应用程序的入口点
- en: 'Let''s start our app''s code by creating the entry point for our app: `index.js`
    . We import `src/main.js` in this file to use a common root component for our
    code base. Moreover, we will register the app with the name `carBooking`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建我们应用程序的入口点`index.js`来开始我们的应用程序代码。我们在这个文件中导入`src/main.js`，以便为我们的代码库使用一个公共根组件。此外，我们将使用名称`carBooking`注册应用程序：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s start building our `src/main.js` by adding a map component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加地图组件来开始构建我们的`src/main.js`：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of using libraries for styling, we will create our own styles using
    `StyleSheet`, a React Native API, which serves as an abstraction similar to CSS
    style sheets. With `StyleSheet`, we can create a style sheet from an object (through
    the `create` method), which can be used in our components by referring to each
    style by its ID.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`StyleSheet`来创建自己的样式，而不是使用样式库，`StyleSheet`是一个类似于CSS样式表的抽象的React Native
    API。使用`StyleSheet`，我们可以从对象中创建样式表（通过`create`方法），然后通过引用每个样式的ID在我们的组件中使用它们。
- en: This way, we can reuse the style code and make the code more readable as we
    will be using meaningful names to refer to each style (for example, `<Text style={styles.title}>Title
    1</Text>`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以重用样式代码，并使代码更易读，因为我们将使用有意义的名称来引用每个样式（例如，`<Text style={styles.title}>Title
    1</Text>`）。
- en: 'At this point, we will only create a style referred by the key `fullScreenMap` and
    make it as an absolute position by covering the fullscreen size by adding `top`,
    `bottom`, `left`, and `right` coordinates to zero. On top of this, we need to
    add some styling to our container view to ensure it fills the whole screen: `{flex:
    1}`. Setting `flex` to `1`, we want our view to fill all the space its parent
    occupies. Since this is the main view, `{flex: 1}` will take over the whole screen.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '在这一点上，我们只会创建一个由键`fullScreenMap`引用的样式，并通过将`top`、`bottom`、`left`和`right`坐标添加到零来将其设置为绝对位置，覆盖全屏大小。除此之外，我们需要为我们的容器视图添加一些样式，以确保它填满整个屏幕：`{flex:
    1}`。将`flex`设置为`1`，我们希望我们的视图填满其父级占用的所有空间。由于这是主视图，`{flex: 1}`将占据整个屏幕。'
- en: For our map component, we will use `react-native-maps`, an open module created
    by Airbnb using native maps capabilities for Google and Apple maps. `react-native-maps`
    is a very flexible module, really well maintained, and fully featured so that
    it has become the *de facto* maps module for React Native. As we will see later
    in this chapter, `react-native-maps` requires the developer to run `react-native
    link` in order for it to work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的地图组件，我们将使用`react-native-maps`，这是由Airbnb创建的一个开放模块，利用了Google和Apple地图的本地地图功能。`react-native-maps`是一个非常灵活的模块，得到了很好的维护，并且功能齐全，因此它已经成为React
    Native的*事实标准*地图模块。正如我们将在本章后面看到的，`react-native-maps`要求开发人员运行`react-native link`才能正常工作。
- en: 'Apart from the style, the `<MapView/>` component will take  `initialRegion`
    as a property to centre the map in a specific set of coordinates, which should
    be the current location of the user. For consistency reasons, we will locate the
    center of the map in San Francisco where we will also place some bookable cars:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了样式，`<MapView/>`组件将以`initialRegion`作为属性，将地图居中在特定的坐标上，这应该是用户当前位置。出于一致性原因，我们将把地图的中心定位在旧金山，在那里我们还将放置一些可预订的汽车：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have added an array of `carLocations` to be shown on the map as markers.
    Inside our `render` function, we will iterate over this array and place the corresponding `<MapView.Marker/>`
    in the provided coordinates. Inside each marker, we will add the image of the
    car rotating it by a specific number of degrees, so they match the streets directions. Rotating
    images must be done with the `Animated` API, which will be better explained later
    in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个`carLocations`数组，以便在地图上显示为标记。在我们的`render`函数中，我们将遍历这个数组，并在提供的坐标中放置相应的`<MapView.Marker/>`。在每个标记内，我们将添加汽车的图像，并将其旋转特定角度，以使其与街道方向匹配。旋转图像必须使用`Animated`API完成，这将在本章后面更好地解释。
- en: 'Let''s add a new property in our state to store a human-readable position for
    the location in which the map is centered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的状态中添加一个新属性，用于存储地图所居中的位置的可读位置：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To fill this state variable, we also created a function `_onRegionChange`, which
    uses the `react-native-geocoder` module. This module uses Google Maps reverse
    geocoding services to translate some coordinates into a human-readable location.
    Because it's a Google Service, we might need to add an API key in order to authenticate
    our app with the service. All the instructions to get this module fully installed
    can be found at its repository URL [https://github.com/airbnb/react-native-maps/blob/master/docs/installation.md](https://github.com/airbnb/react-native-maps/blob/master/docs/installation.md).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这个状态变量，我们还创建了一个名为`_onRegionChange`的函数，它使用`react-native-geocoder`模块。该模块使用Google
    Maps的逆地理编码服务将一些坐标转换为可读的位置。因为这是一个Google服务，我们可能需要添加一个API密钥来验证我们的应用程序与该服务的身份。可以在其存储库URL中找到完全安装此模块的所有说明[https://github.com/airbnb/react-native-maps/blob/master/docs/installation.md](https://github.com/airbnb/react-native-maps/blob/master/docs/installation.md)。
- en: We want this state variable to be available from the first mount of the main
    component, so we will call `_onRegionChange` in `componentDidMount` so that the
    name of the initial location is also stored in the state. Moreover, we will add
    the `onRegionChange` property on our `<MapView/>` to ensure the name of the location
    is recalculated every time the map is moved to show a different region, so we
    always have the name of the location in the center of the map in our `position`
    state variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个状态变量从主组件的第一个挂载就可用，所以我们将在`componentDidMount`中调用`_onRegionChange`，以便初始位置的名称也存储在状态中。此外，我们将在我们的`<MapView/>`上添加`onRegionChange`属性，以确保位置的名称在地图移动到显示不同区域时重新计算，这样我们总是可以在我们的`position`状态变量中拥有地图中心的位置名称。
- en: 'As a final step on this screen, we will add all the subviews and another function
    to confirm the booking request:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为屏幕的最后一步，我们将添加所有子视图和另一个函数来确认预订请求：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We added four subviews:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了四个子视图：
- en: '`LocationSearch`: The component in which we will show the user the location
    that is centered on the map so she can know the name of the location she is exactly
    requesting the pickup.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationSearch`：在这个组件中，我们将向用户显示地图中心的位置，以便她可以知道她确切请求接送的位置的名称。'
- en: '`LocationPin`: A pinpointing to the center of the map, so the user can see
    on the map where she will request the pickup. It will also display a button to
    confirm the pickup.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationPin`：一个指向地图中心的图钉，这样用户可以在地图上看到她将要请求接送的位置。它还将显示一个确认接送的按钮。'
- en: '`ClassSelection`: A bar where the user can select the type of car for the pickup
    (economy, special, or superior).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassSelection`：用户可以在其中选择接送车辆类型（经济、特殊或高级）的条形图。'
- en: '`ConfirmationModal`: The modal displaying the confirmation of the request.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfirmationModal`：显示请求确认的模态框。'
- en: The `_onBookingRequest` method will be responsible for bringing the confirmation
    modal up when a booking is requested.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`_onBookingRequest`方法将负责在请求预订时弹出确认模态框。'
- en: Adding images to our app
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加图像
- en: 'React Native deals with images in a similar way as websites do: images should
    be placed in a folder inside the projects folder structure, and then they can
    be referenced from the `<Image />` (or `<Animated.Image />`) by the `source` property.
    Let''s see an example from our app:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: React Native处理图像的方式与网站类似：图像应放在项目文件夹结构内的一个文件夹中，然后可以通过`<Image/>`（或`<Animated.Image/>`）的`source`属性引用它们。让我们看一个来自我们应用程序的例子：
- en: '`car.png`: This is placed inside the `img/` folder in the root of our project'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car.png`：这个文件放在我们项目根目录的`img/`文件夹中'
- en: 'Then the image will be displayed by creating an `<Image/>` component using
    the `source` property:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，通过使用`source`属性创建一个`<Image/>`组件来显示图像：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the `source` property doesn't accept a string, but a  `require('../img/car.png')`.
    This is a special case in React Native and may change in future versions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`source`属性不接受字符串，而是`require('../img/car.png')`。这在React Native中是一个特殊情况，可能会在将来的版本中更改。
- en: LocationSearch
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocationSearch
- en: 'This should be a simple textbox displaying the human-readable name of the location
    in which the map is centered. Let''s take a look at the code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是一个简单的文本框，显示地图中心的可读名称。让我们看一下代码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It receives only one property: `value` (the name of the location to be displayed).
    If it''s not set, it will display a spinner to show activity.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它只接收一个属性：`value`（要显示的位置名称）。如果未设置，它将显示一个旋转器以显示活动。
- en: Because there are many different styles to be applied in this component, it's
    beneficial to use the `StyleSheet` API to organize the styles in a key/value object
    and refer it from our `render` method. This separation between logic and style
    helps in readability of the code and also enables code reuse as the styles can
    be cascaded down to child components.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此组件中需要应用许多不同的样式，因此最好使用`StyleSheet` API将样式组织在键/值对象中，并从我们的`render`方法中引用它。逻辑和样式之间的分离有助于代码的可读性，还可以使代码重用，因为样式可以级联到子组件。
- en: Aligning elements
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐元素
- en: 'React Native uses Flexbox for setting up the layout of the elements in an app. This
    is mostly straightforward, but sometimes it can be confusing when it comes to
    aligning elements as there are four properties that can be used for this purpose:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: React Native使用Flexbox来设置应用程序中元素的布局。这通常很简单，但有时在对齐元素时可能会令人困惑，因为有四个属性可用于此目的：
- en: '`justifyContent`: It defines the alignment of the child elements through the
    main axis'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`justifyContent`：它定义了子元素沿着主轴的对齐方式'
- en: '`alignItems`: It defines the alignment of the child elements through the cross-axis'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignItems`：它定义了子元素沿着交叉轴的对齐方式'
- en: '`alignContent`: It aligns a flex container''s lines within when there is extra
    space in the cross-axis'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignContent`：当交叉轴上有额外空间时，它会对齐flex容器的行'
- en: '`alignSelf`: It allows the default alignment (or the one specified by `alignItems`)
    to be overridden for individual flex items'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignSelf`：它允许覆盖单个flex项的默认对齐方式（或由`alignItems`指定的对齐方式）'
- en: The first three properties should be assigned to the container element, while
    the fourth one will be applied to a child element in case we want to override
    the default alignment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个属性应分配给容器元素，而第四个属性将应用于子元素，以便在需要覆盖默认对齐方式时使用。
- en: 'In our case, we only want one element (the title) to be center aligned so we
    can use `alignSelf: ''center''`. Later in this chapter, we will see other uses for
    the different `align` properties.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的情况下，我们只希望一个元素（标题）居中对齐，因此我们可以使用`alignSelf: ''center''`。在本章的后面，我们将看到不同的`align`属性的其他用途。'
- en: LocationPin
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocationPin
- en: 'In this section, we will focus on building the pinpointing to the center of
    the map to visually confirm the pickup location. This pin also contains a button,
    which can be used to trigger a pickup request:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于构建指向地图中心的标记，以直观确认取货位置。此标记还包含一个按钮，可用于触发取货请求：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This component is again very light in terms of functionality, but has a lot
    of custom style. Let's dive into some of the style details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就功能而言，这个组件再次非常轻量级，但具有许多自定义样式。让我们深入了解一些样式细节。
- en: flexDirection
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flexDirection
- en: 'By default, React Native and Flexbox stack elements vertically:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Native和Flexbox会垂直堆叠元素：
- en: '![](Images/c5c3d64c-719f-48ba-946a-848bbac061a3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5c3d64c-719f-48ba-946a-848bbac061a3.png)'
- en: 'For the banner in our pin, we want to stack every element horizontally after
    each other as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的标记中的横幅，我们希望将每个元素水平堆叠在一起，如下所示：
- en: '![](Images/55123e3b-a34e-4653-a40f-0074b5150823.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/55123e3b-a34e-4653-a40f-0074b5150823.png)'
- en: 'This can be achieved by adding the following styles to the containing element `flexDirection:
    ''row''`. The other valid options for `flexDirection` are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '这可以通过向包含元素添加以下样式来实现`flexDirection: ''row''`。`flexDirection`的其他有效选项是：'
- en: row-reverse
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: row-reverse
- en: '`column` (default)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`（默认）'
- en: '`column-reverse`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column-reverse`'
- en: Dimensions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尺寸
- en: 'One of the first lines of code in this component extracts the height and the
    width from the device into two variables:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中的代码的第一行从设备中提取高度和宽度到两个变量中：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Obtaining the height and width of the device enables us developers to absolute
    position some elements being confident they will show properly aligned. For example,
    we want the banner of our pin to be aligned in the center of the screen, so it
    points to the center of the map. We can do this by adding `{top: (height/2), left:
    (width/2)}` to the `banner` style in our style sheet. Of course, that would align
    the upper-left corner, so we need to subtract half the size of the banner to each
    property to ensure it gets centered in the middle of the element. This trick can
    be used whenever we need to align an element that is not relative to any other
    in the components tree although it is recommended to use relative positioning
    when possible.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '获取设备的高度和宽度使我们开发人员能够绝对定位一些元素，确信它们将正确对齐显示。例如，我们希望我们的图钉的横幅对齐在屏幕中央，所以它指向地图的中心。我们可以在样式表中的`banner`样式中添加`{top:
    (height/2), left: (width/2)}`来实现这一点。当然，这会将其对齐到左上角，所以我们需要从每个属性中减去横幅大小的一半，以确保它在元素的中间得到居中。每当我们需要对齐一个与组件树中的任何其他元素无关的元素时，都可以使用这个技巧，尽管在可能的情况下建议使用相对定位。'
- en: Shadows
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影
- en: 'Let''s set focus on our banner''s style, specifically on the `shadows` properties:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于我们横幅的样式，特别是`shadows`属性：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to add a shadow to a component, we need to add four properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给组件添加阴影，我们需要添加四个属性：
- en: '`shadowColor`: This adds the hexadecimal or RGBA value of the color we want
    for our component'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowColor`：这添加了我们组件所需的颜色的十六进制或RGBA值'
- en: '`shadowOffset`: This shows how far we want our shadow to be casted'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowOffset`：这显示了我们希望阴影投射多远'
- en: '`shadowRadius`: This shows the value of the radius in the corner of our shadow'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowRadius`：这显示了阴影在角落的半径值'
- en: '`shadowOpacity`: This shows how dark we want our shadow to be'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowOpacity`：这显示了我们希望阴影有多深'
- en: That's it for our `LocationPin` component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`LocationPin`组件的全部内容。
- en: ClassSelection
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类选择
- en: 'In this component, we will explore the `Animated` API in React Native to get
    started with animations. Moreover, we will use custom fonts to improve the user
    experience and increase the feeling of customization in our app:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们将探索React Native中的`Animated` API，以开始使用动画。此外，我们将使用自定义字体来改善用户体验，并增加我们应用程序中的定制感：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This simple component is made out of five sub components:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的组件由五个子组件组成：
- en: '`classBar`: This is an image showing the bar and the stop points for each class'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classBar`：这是显示条和每个类的停靠点的图像'
- en: '`classButton`: This is the round button, which will be moved to the selected
    class once the user presses a specific class'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classButton`：这是圆形按钮，一旦用户按下特定的类，它将移动到所选的类'
- en: '`classButtonContainer`: This is the touchable component detecting what class
    the user wants to select'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classButtonContainer`：这是可触摸组件，用于检测用户想要选择的类'
- en: '`classLabel`: These are titles for each class to be displayed on top of the
    bar'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classLabel`：这些是每个类的标题，将显示在条的顶部'
- en: Let's start by taking a look at the styles as we can find a new property for
    image components: `resizeMode`, which determines how to resize the image when
    the frame doesn't match the raw image dimensions. From the five possible values
    (`cover`, `contain`, `stretch`, `repeat`, and `center`), we chose `contain` as
    we want to scale the image uniformly (maintain the image's aspect ratio) so that
    both dimensions of the image will be equal to or less than the corresponding dimension
    of the view. We are using these properties both in `classBar` and `classButtonImage` being
    the two images we will need to resize in this view.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从样式开始，因为我们可以在图像组件中找到一个新的属性：`resizeMode`，它确定当框架与原始图像尺寸不匹配时如何调整图像大小。从五种可能的值（`cover`，`contain`，`stretch`，`repeat`和`center`）中，我们选择了`contain`，因为我们希望均匀缩放图像（保持图像的纵横比），以便图像的两个尺寸都等于或小于视图的相应尺寸。我们在`classBar`和`classButtonImage`中都使用了这些属性，这是我们在这个视图中需要调整大小的两个图像。
- en: Adding custom fonts
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: React Native includes a long list of cross-platform fonts available by default.
    The list of fonts can be checked on [https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: React Native默认包含一长串跨平台字体。字体列表可以在[https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts)上查看。
- en: Nevertheless, adding custom fonts is a common need when developing apps, especially
    when designers are involved, so we will use our car booking app as a playground
    to test this functionality.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，添加自定义字体是开发应用程序时的常见需求，特别是涉及到设计师时，因此我们将使用我们的汽车预订应用程序作为测试这一功能的场所。
- en: 'Adding custom fonts to our app is a three steps task:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义字体到我们的应用程序是一个三步任务：
- en: Add the font file (`.ttf`) into a folder inside our project. We used `fonts/`
    for this app.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字体文件（.ttf）添加到项目内的一个文件夹中。我们在这个应用程序中使用了`fonts/`。
- en: 'Add the following lines to our `package.json`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到我们的`package.json`：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following command in a terminal:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s it, React Native''s CLI will handle the insertion of the `fonts` folder
    and its files inside the iOS and Android project at once. Our fonts will be available
    by their font name (which may not be the same as the filename). In our case, we
    have `fontFamily: ''Blair ITC''` in our style sheet.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '就是这样，React Native的CLI将一次性处理`fonts`文件夹及其文件的插入到iOS和Android项目中。我们的字体将通过它们的字体名称（可能与文件名不同）可用。在我们的情况下，我们在样式表中有`fontFamily:
    ''Blair ITC''`。'
- en: 'We can now modify our `classLabel` style in the `ClassSelection` component
    to include the new font:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改`ClassSelection`组件中的`classLabel`样式，以包含新的字体：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Animations
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: React Native's `Animated` API is designed to make it very easy to concisely
    express a wide variety of interesting animation and interaction patterns in a
    very performant way. Animated focuses on declarative relationships between inputs
    and outputs, with configurable transforms in between, and simple `start`/`stop`
    methods to control time-based animation execution.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的`Animated` API旨在以高性能的方式，简洁地表达各种有趣的动画和交互模式。动画侧重于输入和输出之间的声明关系，中间有可配置的转换，并且有简单的`start`/`stop`方法来控制基于时间的动画执行。
- en: 'What we want to do in our app is to move the `classButton` to a specific location
    whenever the user presses the class she wants to book. Let''s take a closer look
    at how we are using this API in our app:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中要做的是，当用户按下她想要预订的班级时，将`classButton`移动到特定位置。让我们更仔细地看看我们在应用程序中如何使用这个API：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this movement to happen correctly, we need to wrap the `classButtonImage`
    in `Animated.View` and provide an initial `Animated.Value` to it as a left coordinate.
    We will use `this.state.classButtonPosition` for this matter so that we can change
    it when the user selects a specific class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种移动正确发生，我们需要将`classButtonImage`包装在`Animated.View`中，并为其提供一个初始的`Animated.Value`作为左坐标。我们将使用`this.state.classButtonPosition`来做到这一点，这样当用户选择特定的类别时我们可以改变它。
- en: 'We are ready to start our animation. It will be triggered by the `_onClassChange`
    method, as it is the one invoked when the user presses `classButtonContainer`
    (`<TouchableOpacity/>`). This method is calling the `Animated.timing` function
    passing two parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备开始我们的动画。它将由`_onClassChange`方法触发，因为当用户按下`classButtonContainer`（`<TouchableOpacity/>`）时，它被调用。这个方法调用`Animated.timing`函数传递两个参数：
- en: The animated value to drive (`this.state.classButtonPosition`)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动动画的动画值（`this.state.classButtonPosition`）
- en: An object containing the end value and the duration of the animation
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含动画的结束值和持续时间的对象
- en: Invoking `Animated.timing` will result in an object containing the `start()`
    method, which we call right away to start the animation. React Native will then
    know that the `left` coordinate of the `Animated.View` needs to be slowly changed
    according to the provided parameters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Animated.timing`将导致一个包含`start()`方法的对象，我们立即调用它来启动动画。然后React Native将知道`Animated.View`的`left`坐标需要根据提供的参数慢慢改变。
- en: As this may feel a bit overcomplicated for a simple move animation, it allows
    a wide range of customization as chaining animations or modifying the easing functions.
    We will see a rotation animation later in this chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能对于简单的移动动画来说有点复杂，但它允许广泛的定制，如链接动画或修改缓动函数。我们将在本章后面看到旋转动画。
- en: ConfirmationModal
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConfirmationModal
- en: 'Our last component is a modal view, which will be opened once the user has
    pressed on the SET PICKUP LOCATION button on the location pin. We will display
    the modal and a custom activity indicator, which will use a complex animation
    setup to continuously rotate in its position:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个组件是一个模态视图，当用户按下“设置取货位置”按钮时，它将被打开。我们将显示模态和自定义活动指示器，它将使用复杂的动画设置来持续在其位置旋转：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this component, we are using the `<Modal />` component available in React
    Native to take advantage of its fade animation and visibility capabilities. The
    property `this.props.visible` will drive the visibility of this component as it
    is the parent who is aware of the pickup request from the user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，我们使用React Native中可用的`<Modal />`组件来利用其淡入淡出动画和可见性功能。属性`this.props.visible`将驱动此组件的可见性，因为它是知道用户的取货请求的父组件。
- en: Let's focus again on animations as we want to do a more complex setup for the
    spinner showing activity. We want to display an endless rotating animation, so
    we need to systematically call our `start()` animation method. In order to achieve
    this, we created a `cycleAnimation()` method, which is called on the component
    mount (to get the animation started) and from the `Animated.timing` returned object as
    it is passed as a callback to be invoked every time the animation ends.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次专注于动画，因为我们想为显示活动的旋转器做一个更复杂的设置。我们想要显示一个无休止的旋转动画，所以我们需要系统地调用我们的`start()`动画方法。为了实现这一点，我们创建了一个`cycleAnimation()`方法，它在组件挂载时被调用（以启动动画），并且从返回的`Animated.timing`对象中调用，因为它作为回调传递以在每次动画结束时被调用。
- en: 'We are also using `Animated.sequence` to concatenate two animations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`Animated.sequence`来连接两个动画：
- en: Moving from 0 degrees to 360 (in one second using a linear easing)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0度移动到360度（在一秒钟内使用线性缓动）
- en: Moving from 360 degrees to 0 (in 0 seconds)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从360度移动到0度（在0秒内）
- en: This is required to repeat the first animation over at the end of each cycle.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了在每个周期结束时重复第一个动画。
- en: Finally, we defined a variable named `interpolatedRotateAnimation` to store
    the interpolation from 0 degrees to 360, so it can be passed to the `transform`/`rotate`
    style defining what are going to be the available rotation values when animating
    our `Animated.Image`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个名为`interpolatedRotateAnimation`的变量，用于存储从0度到360度的插值，因此可以将其传递给`transform`/`rotate`样式，定义了在动画我们的`Animated.Image`时可用的旋转值。
- en: 'As an experiment, we can try and change loading.png with an alternative image
    and see how it gets animated. This can be easily achieved by replacing the source
    prop in our <Animated.Image /> component:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，我们可以尝试用替代图像更改loading.png，并看看它如何被动画化。这可以通过替换我们的<Animated.Image />组件中的源属性轻松实现。
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Using UI libraries such as `native-base` or `react-native-elements` saves a
    lot of time and maintenance hassle when we need to build apps, but the results
    end up having a standard flavor, which is not always desirable in terms of user
    experience. That's why learning how to manipulate the style of our apps is always
    a good idea, especially on teams where the design is provided by UX specialists
    or app designers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如`native-base`或`react-native-elements`之类的UI库在构建应用程序时节省了大量时间和维护麻烦，但结果最终呈现出一种标准风格，这在用户体验方面并不总是理想的。这就是为什么学习如何操纵我们应用程序的样式总是一个好主意，特别是在由UX专家或应用程序设计师提供设计的团队中。
- en: In this chapter, we took a deep look into the folders and files created by React
    Native's CLI when initializing a project. Moreover, we familiarized ourselves
    with the developer menu and its debugging functionalities.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了使用React Native的CLI初始化项目时创建的文件夹和文件。此外，我们熟悉了开发人员菜单及其调试功能。
- en: When building our app we set the focus on the layouts and component styling,
    but also on how to add and manipulate animations to make our interface more appealing
    to the user. We took a look at Flexbox layout system and how to stack and center
    elements in our components. API's such as dimensions were used to retrieve the
    device width and height to perform positioning tricks on some components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序时，我们专注于布局和组件样式，还学习了如何添加和操纵动画，使我们的界面对用户更具吸引力。我们研究了Flexbox布局系统以及如何在组件中堆叠和居中元素。诸如尺寸之类的API被用来检索设备的宽度和高度，以在某些组件上执行定位技巧。
- en: You learned how to add fonts and images into our app and how to show them to
    improve the user experience.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何将字体和图像添加到我们的应用程序中，并如何显示它们以改善用户体验。
- en: Now that we know how to build more custom interfaces, let's build in the next
    chapter an image sharing app in which design plays a key role.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何构建更多定制的界面，让我们在下一章中构建一个图像分享应用程序，其中设计起着关键作用。
