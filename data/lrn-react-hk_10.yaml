- en: Using Community Hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用社区Hooks
- en: In the previous chapter, we implemented routing using the Navi library. We started
    by implementing pages, then defining routes and static links. Finally, we implemented
    dynamic links and accessed route information using Hooks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Navi库实现了路由。我们首先实现了页面，然后定义了路由和静态链接。最后，我们实现了动态链接，并使用Hooks访问了路由信息。
- en: In this chapter, we are going to learn about various Hooks that are provided
    by the React community. These Hooks can be used to simplify input handling, and
    implement React life cycles in order to simplify migration from React class components.
    Furthermore, there are Hooks that implement various behaviors such as timers,
    checking if the client is online, hover and focus events, and data manipulation.
    Finally, we are going to learn about responsive design and implementing undo/redo functionality
    using Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习由React社区提供的各种Hooks。这些Hooks可以用于简化输入处理，并实现React生命周期，以简化从React类组件迁移。此外，还有一些实现各种行为的Hooks，例如定时器、检查客户端是否在线、悬停和焦点事件以及数据操作。最后，我们将学习响应式设计，并使用Hooks实现撤销/重做功能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Simplifying input handling using the Input Hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Input Hook简化输入处理
- en: Implementing React life cycles with Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks实现React生命周期
- en: Learning about various useful Hooks (`usePrevious`, timer, online, focus, hover,
    and data manipulation Hooks)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习各种有用的Hooks（`usePrevious`、定时器、在线、焦点、悬停和数据操作Hooks）
- en: Implementing responsive design with Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks实现响应式设计
- en: Implementing undo/redo functionality and debouncing with Hooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks实现撤销/重做功能和去抖动
- en: Learning where to find other Hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在哪里找到其他的Hooks
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了一个相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: The code for this chapter can be found on the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter08)[.](https://github.com/PacktPublishing/Hands-On-Web-Development-with-Hooks/tree/master/Chapter08)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter08)[.](https://github.com/PacktPublishing/Hands-On-Web-Development-with-Hooks/tree/master/Chapter08)
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    you write the code yourself in order to be able to learn and understand properly.
    However, if you run into any issues, you can always refer to the code example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行提供的代码示例。重要的是您自己编写代码，以便能够正确地学习和理解。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始这一章。
- en: Exploring the input handling Hook
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索输入处理Hook
- en: A very common use case when dealing with Hooks, is to store the current value
    of an `input` field using State and Effect Hooks. We have already done this many
    times throughout this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Hooks时，一个非常常见的用例是使用State和Effect Hooks存储`input`字段的当前值。在本书中，我们已经多次这样做了。
- en: 'The `useInput` Hook greatly simplifies this use case, by providing a single
    Hook that deals with the `value` variable of an `input` field. It works as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`useInput` Hook极大地简化了这种用例，通过提供一个处理`input`字段的`value`变量的单个Hook。它的工作方式如下：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code will bind an `onChange` handler function and `value` to the `input`
    field. This means that whenever we enter text into the `input` field, the `value`
    will automatically be updated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将绑定一个`onChange`处理函数和`value`到`input`字段。这意味着每当我们在`input`字段中输入文本时，`value`将自动更新。
- en: 'Additionally, there is a function that will clear the `input` field. This `clear`
    function is also returned from the Hook:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一个函数可以清除`input`字段。这个`clear`函数也是从Hook中返回的：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Calling the `clear` function will set the `value` to an empty value, and clear
    all text from the `input` field.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`clear`函数将把`value`设置为空值，并清除`input`字段中的所有文本。
- en: 'Furthermore, the Hook provides two ways to bind an `input` field:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该Hook提供了两种绑定`input`字段的方式：
- en: '`bindToInput`: Binds the `value` and `onChange` props to an `input` field using `e.target.value` as
    the `value` argument for the `onChange` function. This is useful when dealing
    with HTML `input` fields.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindToInput`：将`value`和`onChange`属性绑定到`input`字段，使用`e.target.value`作为`onChange`函数的`value`参数。在处理HTML`input`字段时非常有用。'
- en: '`bind`: Binds the `value` and `onChange` props to an `input` field using only `e` as
    the value for the `onChange` function. This is useful for React components that
    directly pass the value to the `onChange` function.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`：将`value`和`onChange`属性绑定到`input`字段，仅使用`e`作为`onChange`函数的值。这对于直接将值传递给`onChange`函数的React组件非常有用。'
- en: 'The `bind` and `bindToInput` objects can be used with the spread operator,
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`和`bindToInput`对象可以与扩展运算符一起使用，如下所示：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, for the `input` field we can use the `{...bindToInput}` props
    to assign the `value` and `onChange` functions. For `ToggleButton`, we need to
    use the `{...bind}` props instead, because we are not dealing with input events
    here, and the value is directly passed to the change handler (not via `e.target.value`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，对于`input`字段，我们可以使用`{...bindToInput}`属性来分配`value`和`onChange`函数。对于`ToggleButton`，我们需要使用`{...bind}`属性，因为这里我们不处理输入事件，并且值直接传递给change处理程序（而不是通过`e.target.value`）。
- en: Now that we have learned about the Input Hook, we can move on to implementing
    it in our blog app.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Input Hook，我们可以继续在我们的博客应用中实现它。
- en: Implementing Input Hooks in our blog app
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的博客应用中实现Input Hooks
- en: Now that we have learned about the Input Hook, and how it simplifies dealing
    with the `input` field state, we are going to implement Input Hooks in our blog
    app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Input Hook，以及它如何简化处理`input`字段状态，我们将在我们的博客应用中实现Input Hooks。
- en: 'First, we have to install the `react-hookedup` library in our blog app project:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在我们的博客应用项目中安装`react-hookedup`库。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are now going to implement Input Hooks in the following components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在以下组件中实现Input Hooks：
- en: The `Login` component
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Login`组件'
- en: The `Register` component
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Register`组件'
- en: The `CreatePost` component
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatePost`组件'
- en: Let's get started implementing Input Hooks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现Input Hooks。
- en: The Login component
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Login`组件'
- en: 'We have two `input` fields in the `Login` component: the Username and Password fields.
    We are now going to replace the State Hooks with Input Hooks.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Login`组件中有两个`input`字段：用户名和密码字段。我们现在将用Input Hooks替换State Hooks。
- en: 'Let''s start implementing Input Hooks in the `Login` component now:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始在`Login`组件中实现Input Hooks：
- en: 'Import the `useInput` Hook at the beginning of the `src/user/Login.js` file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/Login.js`文件的开头导入`useInput` Hook：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we remove the following `username` State Hook:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们移除以下`username` State Hook：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is replaced with an Input Hook, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它被替换为Input Hook，如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since we are using two Input Hooks, in order to avoid name collisions, we are
    using the rename syntax (`{ from: to }`) in object destructuring to rename the
    `value` key to `username`, and `bindToInput` key to `bindUsername`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们使用了两个输入钩子，为了避免名称冲突，我们在对象解构中使用重命名语法（`{ from: to }`）将`value`键重命名为`username`，将`bindToInput`键重命名为`bindUsername`。'
- en: 'We also remove the following `password` State Hook:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还移除以下`password`状态钩子：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is replaced with an Input Hook, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它被输入钩子替换，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now remove the following handler functions:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以移除以下处理函数：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, instead of passing the `onChange` handlers manually, we use the bind
    objects from the Input Hooks:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们不再手动传递`onChange`处理程序，而是使用输入钩子中的绑定对象：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The login functionality will still work in exactly the same way as before, but
    we are now using the much more concise Input Hook, instead of the generic State
    Hook. We also do not have to define the same kind of handler function for each
    `input` field anymore. As we can see, using community Hooks can greatly simplify
    the implementation of common use-cases, such as input handling. We are now going
    to repeat the same process for the `Register` component.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能仍然与以前完全相同，但现在我们使用更简洁的输入钩子，而不是通用状态钩子。我们也不再需要为每个`input`字段定义相同类型的处理函数。正如我们所看到的，使用社区钩子可以极大地简化常见用例的实现，比如输入处理。现在我们将重复相同的过程用于`Register`组件。
- en: The Register component
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册组件
- en: 'The `Register` component works similarly to the `Login` component. However,
    it has three `input` fields: Username, Password, and Repeat Password.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`组件的工作方式类似于`Login`组件。但是，它有三个`input`字段：用户名、密码和重复密码。'
- en: 'Let''s implement Input Hooks in the `Register` component now:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`Register`组件中实现输入钩子：
- en: 'Import the `useInput` Hook at the beginning of the `src/user/Register.js` file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/Register.js`文件的开头导入`useInput`钩子：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we remove the following State Hooks:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们移除以下状态钩子：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'They are replaced with the corresponding Input Hooks:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被相应的输入钩子替换：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again, we can remove all of the handler functions:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以移除所有处理函数：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we replace all of the `onChange` handlers with the corresponding bind
    objects:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用相应的绑定对象替换所有的`onChange`处理程序：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The register functionality will also still work in the same way, but now using
    Input Hooks. Next up is the `CreatePost` component, where we are going to implement
    Input Hooks as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注册功能仍然以相同的方式工作，但现在使用输入钩子。接下来是`CreatePost`组件，我们也将在其中实现输入钩子。
- en: The CreatePost component
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帖子组件
- en: 'The `CreatePost` component uses two `input` fields: one for the `title`, and
    one for the `content`. We are going to replace both of them with Input Hooks.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreatePost`组件使用两个`input`字段：一个用于`title`，一个用于`content`。我们将用输入钩子替换它们。'
- en: 'Let''s implement Input Hooks in the `CreatePost` component now:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`CreatePost`组件中实现输入钩子：
- en: 'Import the `useInput` Hook at the beginning of the `src/user/CreatePost.js` file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/CreatePost.js`文件的开头导入`useInput`钩子：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we remove the following State Hooks:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们移除以下状态钩子：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We replace them with the corresponding Input Hooks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用相应的输入钩子替换它们：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Again, we can remove the following input handler functions:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以移除以下输入处理函数：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we replace all of the `onChange` handlers with the corresponding bind
    objects:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用相应的绑定对象替换所有的`onChange`处理程序：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The create post functionality will also work in the same way with Input Hooks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帖子功能也将以相同的方式与输入钩子一起工作。
- en: Example code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter08/chapter8_1` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter08/chapter8_1`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit [http://localhost:3000](http://localhost:3000) in
    your browser (if it does not open automatically).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行 `npm install` 以安装所有依赖项，然后运行 `npm start` 启动应用程序，然后在浏览器中访问 [http://localhost:3000](http://localhost:3000) （如果没有自动打开）。
- en: React life cycles with Hooks
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 生命周期与 Hooks
- en: As we have learned in the previous chapters, we can use the `useEffect` Hook to
    model most of React's life cycle methods. However, if you prefer dealing with
    React life cycle directly, instead of using Effect Hooks, there is a library called `react-hookedup`,
    which provides various Hooks, including Hooks for the various React life cycles.
    Additionally, the library provides a merging State Hook, which works similarly
    to `this.setState()` in React's class components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中学到的，我们可以使用 `useEffect` Hook 来模拟大部分 React 的生命周期方法。然而，如果你更喜欢直接处理 React
    生命周期，而不是使用 Effect Hooks，有一个名为 `react-hookedup` 的库，它提供了各种 Hooks，包括各种 React 生命周期的
    Hooks。此外，该库还提供了一个合并状态的 Hook，它的工作方式类似于 React 类组件中的 `this.setState()`。
- en: The useOnMount Hook
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useOnMount Hook
- en: 'The `useOnMount` Hook has a similar effect to the `componentDidMount` life
    cycle. It is used as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`useOnMount` Hook 与 `componentDidMount` 生命周期有类似的效果。它的使用方法如下：'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code will output mounted to the console when the component gets
    mounted (when the React component is rendered for the first time). It will not
    be called again when the component re-renders due to, for example, a prop change.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件挂载时（当 React 组件首次渲染时），上述代码将在控制台输出 mounted。例如，由于 prop 更改而导致组件重新渲染时，它不会再次被调用。
- en: 'Alternatively, we could just use a `useEffect` Hook with an empty array as
    the second argument, which will have the same effect:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用带有空数组作为第二个参数的 `useEffect` Hook，它将产生相同的效果：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, using an Effect Hook with an empty array as the second argument
    results in the same behavior as the `useOnMount` Hook or the `componentDidMount`
    life cycle method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用带有空数组作为第二个参数的 Effect Hook 会产生与 `useOnMount` Hook 或 `componentDidMount`
    生命周期方法相同的行为。
- en: The useOnUnmount Hook
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useOnUnmount Hook
- en: 'The `useOnUnmount` Hook has a similar effect to the `componentWillUnmount` life
    cycle. It is used as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`useOnUnmount` Hook 与 `componentWillUnmount` 生命周期有类似的效果。它的使用方法如下：'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code will output unmounting to the console when the component
    gets unmounted (before the React component is removed from the DOM).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件卸载时（在 React 组件从 DOM 中移除之前），上述代码将在控制台输出 unmounting。
- en: 'If you remember from [Chapter 4](6af201b4-073e-4911-8c3e-4d0256895702.xhtml), *Using
    the Reducer and Effect Hooks*, we can return a cleanup function from the `useEffect` Hook,
    which will be called when the component unmounts. This means that we could alternatively
    implement the `useOnMount` Hook using `useEffect`, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第4章](6af201b4-073e-4911-8c3e-4d0256895702.xhtml)中所学到的，我们可以从 `useEffect` Hook
    中返回一个清理函数，当组件卸载时将被调用。这意味着我们可以使用 `useEffect` 来实现 `useOnMount` Hook，如下所示：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, using the cleanup function that is returned from an Effect Hook,
    with an empty array as the second argument, has the same effect as the `useOnUnmount` Hook,
    or the `componentWillUnmount` life cycle method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，从 Effect Hook 返回的清理函数，带有空数组作为第二个参数，具有与 `useOnUnmount` Hook 或 `componentWillUnmount`
    生命周期方法相同的效果。
- en: The useLifecycleHooks Hook
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useLifecycleHooks Hook
- en: 'The `useLifecycleHooks` Hook combines the previous two Hooks into one. We can
    combine the `useOnMount` and `useOnUnmount` Hooks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLifecycleHooks` Hook 将前两个 Hook 结合为一个。我们可以将 `useOnMount` 和 `useOnUnmount` Hooks
    结合如下：'
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, we could use the two Hooks separately:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以分别使用这两个 Hooks：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if you have this kind of pattern, I would recommend simply using the `useEffect` Hook,
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有这种模式，我建议简单地使用`useEffect` Hook，如下所示：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using `useEffect`, we can put our whole effect into a single function, and then
    simply return a function for cleanup. This pattern is especially useful when we
    learn about making our own Hooks in the next chapters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useEffect`，我们可以将整个效果放入一个函数中，然后简单地返回一个清理函数。当我们在下一章学习如何制作自己的Hooks时，这种模式尤其有用。
- en: Effects make us think differently about React components. We do not have to
    think about the life cycle of a component at all. Instead, we think about effects,
    dependencies, and the cleanup of effects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 效果让我们以不同的方式思考React组件。我们根本不必考虑组件的生命周期。相反，我们考虑效果、依赖关系和效果的清理。
- en: The useMergeState Hook
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useMergeState Hook
- en: The `useMergeState` Hook works similarly to the `useState` Hook. However, it
    does not replace the current state, but instead merges the current state with
    the new state, just like `this.setState()` works in React class components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMergeState` Hook的工作方式类似于`useState` Hook。但是，它不会替换当前状态，而是将当前状态与新状态合并，就像在React类组件中的`this.setState()`一样。'
- en: 'The Merge State Hook returns the following objects:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Merge State Hook返回以下对象：
- en: '`state`: The current state'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：当前状态'
- en: '`setState`: A function to merge the current state with the given state object'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setState`：一个函数，用于将当前状态与给定的状态对象合并'
- en: 'For example, let''s consider the following component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下组件：
- en: 'First, we import the `useState` Hook:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`useState` Hook：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we define our app component and a State Hook with an object containing
    a `loaded` value and a `counter` value:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的应用组件和一个包含`loaded`值和`counter`值的对象的State Hook：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we define a `handleClick` function, where we set the new `state`, increasing
    the current `counter` value by `1`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`handleClick`函数，在其中设置新的`state`，将当前的`counter`值增加`1`：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we render the current `counter` value and a +1 button in order to
    increase the `counter` value by `1`. The button will be disabled if `state.loaded` is `false` or
    `undefined`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染当前的`counter`值和一个+1按钮，以便将`counter`值增加`1`。如果`state.loaded`为`false`或`undefined`，按钮将被禁用：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, we have a simple counter app, showing the current count and a
    +1 button. The +1 button will only be enabled when the `loaded` value is set to `true`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们有一个简单的计数器应用，显示当前计数和一个+1按钮。只有当`loaded`值设置为`true`时，+1按钮才会启用。
- en: If we now click on the +1 button, `counter` will increase from `0` to `1`, but
    the button will get disabled, because we have overwritten the current `state` object
    with a new `state` object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在点击+1按钮，`counter`将从`0`增加到`1`，但按钮将被禁用，因为我们已经用新的`state`对象覆盖了当前的`state`对象。
- en: 'To solve this problem, we would have to adjust the `handleClick` function as
    follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要调整`handleClick`函数如下：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, we could use the `useMergeState` Hook in order to avoid this
    problem altogether, and get the same behavior that we had with `this.setState()` in
    class components:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`useMergeState` Hook，以避免这个问题，并获得与在类组件中使用`this.setState()`相同的行为：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see, by using the `useMergeState` Hook, we can reproduce the same
    behavior that we had with `this.setState()` in class components. So, we do not
    need to use spread syntax anymore. However, often, it is better to simply use
    multiple State Hooks or a Reducer Hook instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过使用`useMergeState` Hook，我们可以复制在类组件中使用`this.setState()`时的相同行为。因此，我们不再需要使用扩展语法。然而，通常最好简单地使用多个State
    Hooks或Reducer Hook。
- en: Example code
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter08/chapter8_2` folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter08/chapter8_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it does not open automatically).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Various useful Hooks
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 各种有用的Hooks
- en: In addition to life cycle Hooks, `react-hookedup` also provides Hooks for timers,
    checking the network status, and various other useful Hooks for dealing with,
    for example, arrays and input fields. We are now going to cover the rest of the
    Hooks that `react-hookedup` provides.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生命周期Hooks之外，`react-hookedup`还提供了用于计时器、检查网络状态以及处理其他有用的Hooks，例如数组和输入字段的Hooks。我们现在将介绍`react-hookedup`提供的其余Hooks。
- en: 'These Hooks are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Hooks如下：
- en: The `usePrevious` Hook, to get the previous value of a Hook or prop
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usePrevious` Hook，用于获取Hook或prop的先前值'
- en: Timer Hooks, to implement intervals and timeouts
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器Hooks，用于实现间隔和超时
- en: The `useOnline` Hook, to check whether the client has an active internet connection
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useOnline` Hook，用于检查客户端是否有活动的互联网连接'
- en: Various data manipulation Hooks for dealing with booleans, arrays, and counters
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理布尔值、数组和计数器的各种数据操作Hooks
- en: Hooks to deal with focus and hover events
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理焦点和悬停事件的Hooks
- en: The usePrevious Hook
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`usePrevious` Hook'
- en: 'The `usePrevious` Hook is a simple Hook that lets us get the previous value
    of a prop or Hook value. It will always store and return the previous value of
    any given variable, and it works as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`usePrevious` Hook是一个简单的Hook，让我们获取prop或Hook值的先前值。它将始终存储并返回任何给定变量的先前值，并且工作方式如下：'
- en: 'First, we import the `useState` and `usePrevious` Hooks:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`useState`和`usePrevious` Hooks：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we define our `App` component, and a Hook in which we store the current
    `count` state:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的`App`组件，并在其中存储当前`count`状态的Hook：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we define the `usePrevious` Hook, passing the `count` value from the State
    Hook to it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义`usePrevious` Hook，将State Hook中的`count`值传递给它：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `usePrevious` Hook works with any variable, including component props and
    values from other Hooks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`usePrevious` Hook适用于任何变量，包括组件props和其他Hooks的值。'
- en: 'Next, we define a handler function, which will increase `count` by `1`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个处理函数，它将通过`1`增加`count`：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we render the previous value of `count`, the current value of `count`,
    and a button to increase `count`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染`count`的先前值，`count`的当前值以及一个增加`count`的按钮：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The previously defined component will first show Count was and is 0 now., because
    the default value for the Previous Hook is `null`. When clicking the button once,
    it will show the following: Count was 0 and is 1 now..'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 先前定义的组件将首先显示Count was and is 0 now.，因为Previous Hook的默认值是`null`。单击按钮一次后，将显示以下内容：Count
    was 0 and is 1 now.。
- en: Timer Hooks
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器Hooks
- en: The `react-hookedup` library also provides Hooks for dealing with timers. If
    we simply create a timer using `setTimeout` or `setInterval` in our component,
    it will get instantiated again every time the component is re-rendered. This not
    only causes bugs and unpredictability, but can also cause a memory leak if the
    old timers are not freed properly. Using timer Hooks, we can avoid these problems
    completely, and easily use intervals and timeouts.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-hookedup`库还提供了用于处理计时器的Hooks。如果我们在组件中简单地使用`setTimeout`或`setInterval`创建计时器，那么每次组件重新渲染时都会重新实例化。这不仅会导致错误和不可预测性，而且如果旧的计时器没有正确释放，还可能导致内存泄漏。使用计时器Hooks，我们可以完全避免这些问题，并轻松地使用间隔和超时。'
- en: 'The following timer Hooks are provided by the library:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供以下计时器Hooks：
- en: The `useInterval` Hook, which is used to define `setInterval` timers (timers
    that trigger multiple times) in React components
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useInterval` Hook，用于在React组件中定义`setInterval`计时器（多次触发的计时器）'
- en: The `useTimeout` Hook, which is used to define `setTimeout` timers (timers that
    trigger only once after a certain amount of time)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useTimeout` Hook用于定义`setTimeout`定时器（在一定时间后仅触发一次的定时器）'
- en: The useInterval Hook
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useInterval` Hook'
- en: 'The `useInterval` Hook can be used just like `setInterval`. We are now going
    to implement a small counter that counts the number of seconds since mounting
    the component:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`useInterval` Hook可以像`setInterval`一样使用。我们现在将实现一个小计数器，用于计算自组件挂载以来的秒数：'
- en: 'First, import the `useState` and `useInterval` Hooks:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`useState`和`useInterval` Hooks：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we define our component and a State Hook:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的组件和一个State Hook：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we define the `useInterval` Hook, which is going to increase the `count`
    by `1` every `1000` ms, which is equal to `1` second:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`useInterval` Hook，它将每1000毫秒增加`1`，相当于`1`秒：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we display the current `count` value:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示当前的`count`值：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, we could use an Effect Hook in combination with `setInterval`,
    instead of the `useInterval` Hook, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用Effect Hook与`setInterval`结合，而不是`useInterval` Hook，如下所示：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we can see, the `useInterval` Hook makes our code much more concise and easily
    readable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`useInterval` Hook使我们的代码更加简洁和易读。
- en: useTimeout Hook
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useTimeout` Hook'
- en: 'The `useTimeout` Hook can be used just like `setTimeout`. We are now going
    to implement a component that triggers after `10` seconds have passed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTimeout` Hook可以像`setTimeout`一样使用。现在我们将实现一个在经过`10`秒后触发的组件：'
- en: 'First, import the `useState` and `useTimeout` Hooks:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`useState`和`useTimeout` Hooks：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we define our component and a State Hook:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的组件和一个State Hook：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we define the `useTimeout` Hook, which is going to set `ready` to `true`, after `10000`
    ms (`10` seconds):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`useTimeout` Hook，它将在`10000`毫秒（`10`秒）后将`ready`设置为`true`：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we display whether we are ready or not:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示我们是否准备好了：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alternatively, we could use an Effect Hook in combination with `setTimeout`,
    instead of the `useTimeout` Hook, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用Effect Hook与`setTimeout`结合，而不是`useTimeout` Hook，如下所示：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we can see, the `useTimeout` Hook makes our code much more concise and easily
    readable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`useTimeout` Hook使我们的代码更加简洁和易读。
- en: The Online Status Hook
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线状态 Hook
- en: In some web apps, it makes sense to implement an offline mode; for example,
    if we want to be able to edit and save drafts for posts locally, and sync them
    to the server whenever we are online again. To be able to implement this use case,
    we can use the `useOnlineStatus` Hook.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些Web应用中，实现离线模式是有意义的；例如，如果我们希望能够在本地编辑和保存帖子草稿，并在再次在线时将它们同步到服务器。为了实现这种用例，我们可以使用`useOnlineStatus`
    Hook。
- en: 'The Online Status Hook returns an object with an `online` value, which contains `true`
    if the client is online; otherwise, it contains `false`. It works as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在线状态 Hook返回一个带有`online`值的对象，如果客户端在线则包含`true`；否则包含`false`。它的工作原理如下：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The previous component will display You are online!, when an internet connection
    is available, or You are offline!, otherwise.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组件将在有网络连接时显示“您在线！”，否则显示“您离线！”。
- en: 'We could then use a Previous Hook, in combination with an Effect Hook, in order
    to sync data to the server when we are online again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Previous Hook，结合Effect Hook，以便在我们再次在线时将数据同步到服务器：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we have an Effect Hook that triggers whenever the value of `online` changes.
    It then checks whether the previous value of `online` was `false`, and the current
    one is `true`. If that is the case, it means we were offline, and are now online
    again, so we need to sync our updated data to the server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个Effect Hook，每当`online`的值发生变化时触发。然后它检查先前的`online`值是否为`false`，当前值是否为`true`。如果是这种情况，这意味着我们先前是离线的，现在又在线了，所以我们需要将更新的数据同步到服务器。
- en: As a result, our app will show an alert displaying syncing data when we go offline
    and then online again.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们离线然后再次在线时，我们的应用将显示一个显示同步数据的警报。
- en: Data manipulation Hooks
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据操作 Hook
- en: The `react-hookedup` library provides various utility Hooks for dealing with
    data. These Hooks simplify dealing with common data structures and provide an
    abstraction over the State Hook.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-hookedup`库提供了处理数据的各种实用 Hook。这些 Hook 简化了处理常见数据结构，并提供了对 State Hook 的抽象。'
- en: 'The following data manipulation Hooks are provided:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了以下数据操作 Hook：
- en: 'The `useBoolean` Hook: To deal with toggling boolean values'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useBoolean` Hook：处理切换布尔值'
- en: 'The `useArray` Hook: To deal with handling arrays'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useArray` Hook：处理数组'
- en: 'The `useCounter` Hook: To deal with counters'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCounter` Hook：处理计数器'
- en: The useBoolean Hook
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useBoolean Hook
- en: The `useBoolean` Hook is used to deal with toggling boolean values (`true`/`false`),
    and provides functions to set the value to `true`/`false`, and a `toggle` function
    to toggle the value.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`useBoolean` Hook 用于处理切换布尔值（`true`/`false`），并提供了将值设置为`true`/`false`的函数，以及一个`toggle`函数来切换值。'
- en: 'The Hook returns an object with the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该 Hook 返回一个具有以下内容的对象：
- en: '`value`: The current value of the boolean'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：布尔值的当前值'
- en: '`toggle`: A function to toggle the current value (sets `true` if currently
    `false`, and `false` if currently `true`)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toggle`：一个用于切换当前值的函数（如果当前为`false`，则设置为`true`，如果当前为`true`，则设置为`false`）'
- en: '`setTrue`: Sets the current value to `true`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTrue`：将当前值设置为`true`'
- en: '`setFalse`: Sets the current value to `false`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFalse`：将当前值设置为`false`'
- en: 'The Boolean Hook works as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值 Hook 的工作方式如下：
- en: 'First, we import the `useBoolean` Hook from `react-hookedup`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`react-hookedup`中导入`useBoolean` Hook：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we define our component and the Boolean Hook, which returns an object
    with the `toggle` function and `value`. We pass `false` as the default value:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的组件和布尔值 Hook，它返回一个具有`toggle`函数和`value`的对象。我们将`false`作为默认值传递：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we render a button, which can be turned on/off:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染一个按钮，可以打开/关闭：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The button will initially be rendered with the text off. When clicking the button,
    it will show the text on. When clicking again, it will be off again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮最初将以文本“关闭”呈现。单击按钮时，它将显示文本“打开”。再次单击时，它将再次关闭。
- en: The useArray Hook
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useArray Hook
- en: The `useArray` Hook is used to easily deal with arrays, without having to use
    the rest/spread syntax.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`useArray` Hook 用于轻松处理数组，而无需使用其余/扩展语法。'
- en: 'The Array Hook returns an object with the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Array Hook 返回一个具有以下内容的对象：
- en: '`value`: The current array'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：当前数组'
- en: '`setValue`: Sets a new array as the value'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValue`：将新数组设置为值'
- en: '`add`: Adds a given element to the array'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：将给定元素添加到数组中'
- en: '`clear`: Removes all elements from the array'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`：从数组中移除所有元素'
- en: '`removeIndex`: Removes an element from the array by its index'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeIndex`：通过索引从数组中移除元素'
- en: '`removeById`: Removes an element from the array by its `id` (assuming that
    the elements in the array are objects with an `id` key)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeById`：通过其`id`（假设数组中的元素是具有`id`键的对象）从数组中移除元素'
- en: 'It works as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式如下：
- en: 'First, we import the `useArray` Hook from `react-hookedup`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`react-hookedup`中导入`useArray` Hook：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we define the component and the Array Hook, with the default value of `[''one'',
    ''two'', ''three'']`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义组件和 Array Hook，并将默认值设置为`['one', 'two', 'three']`：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we display the current array as JSON:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将当前数组显示为 JSON：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we display a button to `add` an element:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们显示一个`add`按钮来添加一个元素：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we display a button to remove the first element by index:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们显示一个通过索引删除第一个元素的按钮：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we add a button to `clear` all elements:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个`clear`按钮来清除所有元素：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we can see, using the `useArray` Hook makes dealing with arrays much simpler.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用`useArray` Hook使处理数组变得更简单。
- en: The useCounter Hook
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useCounter Hook
- en: The `useCounter` Hook can be used to define various kinds of counters. We can
    define a lower/upper limit, specify whether the counter should loop or not, and
    specify the step amount by which we increase/decrease the counter. Furthermore,
    the Counter Hook provides functions in order to increase/decrease the counter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCounter` Hook可以用来定义各种类型的计数器。我们可以定义下限/上限，指定计数器是否应该循环，以及指定我们增加/减少计数器的步长。此外，Counter
    Hook提供了函数来增加/减少计数器。'
- en: 'It accepts the following configuration options:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受以下配置选项：
- en: '`upperLimit`: Defines the upper limit (maximum value) of our counter'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upperLimit`：定义计数器的上限（最大值）'
- en: '`lowerLimit`: Defines the lower limit (minimum value) of our counter'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerLimit`：定义计数器的下限（最小值）'
- en: '`loop`: Specifies whether the counter should loop (for example, when the maximum
    value is reached, we go back to the minimum value)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`：指定计数器是否应该循环（例如，当达到最大值时，我们回到最小值）'
- en: '`step`: Sets the default step amount for the increase and decrease functions'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`：设置增加和减少函数的默认步长'
- en: 'It returns the following object:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下对象：
- en: '`value`: The current value of our counter.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：我们计数器的当前值。'
- en: '`setValue`: Sets the current value of our counter.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValue`：设置计数器的当前值。'
- en: '`increase`: Increases the value by a given step amount. If no amount is specified,
    then the default step amount is used.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increase`：按给定的步长增加值。如果未指定数量，则使用默认步长。'
- en: '`decrease`: Decreases the value by a given step amount. If no amount is specified,
    then the default step amount is used.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decrease`：按给定的步长减少值。如果未指定数量，则使用默认步长。'
- en: 'The Counter Hook can be used as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Counter Hook可以如下使用：
- en: 'First, we import the `useCounter` Hook from `react-hookedup`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`react-hookedup`中导入`useCounter` Hook：
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we define our component and the Hook, specifying `0` as the default value.
    We also specify `upperLimit`, `lowerLimit`, and `loop`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的组件和Hook，指定`0`作为默认值。我们还指定`upperLimit`，`lowerLimit`和`loop`：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we render the current value and two buttons to `increase`/`decrease`
    the value:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染当前值和两个按钮来`increase`/`decrease`值：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we can see, the Counter Hook makes implementing counters much simpler.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Counter Hook使得实现计数器变得更加简单。
- en: Focus and Hover Hooks
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 焦点和悬停Hooks
- en: Sometimes, we want to check whether the user has hovered over an element or
    focused on an `input` field. To do so, we can use the Focus and Hover Hooks that
    are provided by the `react-hookedup` library.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要检查用户是否悬停在元素上或者聚焦在`input`字段上。为了做到这一点，我们可以使用`react-hookedup`库提供的Focus和Hover
    Hooks。
- en: 'The library provides two Hooks for these features:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该库为这些特性提供了两个Hooks：
- en: 'The `useFocus` Hook: To handle focus events (for example, a selected `input`
    field)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useFocus` Hook：处理焦点事件（例如，选择的`input`字段）'
- en: 'The `useHover` Hook: To deal with hover events (for example, when hovering
    the mouse pointer over an area)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useHover` Hook：处理悬停事件（例如，当鼠标指针悬停在一个区域上时）'
- en: The useFocus Hook
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useFocus Hook
- en: 'In order to know whether an element is currently focused, we can use the `useFocus` Hook
    as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道一个元素当前是否聚焦，我们可以使用`useFocus` Hook如下：
- en: 'First, we import the `useFocus` Hook:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`useFocus` Hook：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we define our component and the Focus Hook, which returns the `focused`
    value and a `bind` function, to bind the Hook to an element:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的组件和Focus Hook，它返回`focused`值和一个`bind`函数，将Hook绑定到一个元素：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we render an `input` field, and bind the Focus Hook to it:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染一个`input`字段，并将Focus Hook绑定到它：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As we can see, the Focus Hook makes it much easier to handle focus events. There
    is no need to define our own handler functions anymore.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Focus Hook使得处理焦点事件变得更加容易。不再需要定义我们自己的处理函数了。
- en: The useHover Hook
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useHover Hook
- en: 'In order to know whether the user is currently hovering over an element, we
    can use the `useHover` Hook, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道用户当前是否悬停在元素上，我们可以使用`useHover` Hook，如下所示：
- en: 'First, we import the `useHover` Hook:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`useHover` Hook：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we define our component and the Hover Hook, which returns the `hovered` value
    and a `bind` function, to bind the Hook to an element:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的组件和Hover Hook，它返回`hovered`值和一个`bind`函数，将Hook绑定到元素：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, we render an element, and bind the Hover Hook to it:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染一个元素，并将Hover Hook绑定到它：
- en: '[PRE68]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As we can see, the Hover Hook makes it much easier to handle hover events. There
    is no need to define our own handler functions anymore.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Hover Hook使处理悬停事件变得更加容易。不再需要定义自己的处理程序函数。
- en: Example code
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter08/chapter8_3` folder.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter08/chapter8_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it does not open automatically).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果不会自动打开）。
- en: Responsive design with Hooks
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks实现响应式设计
- en: In web apps, it is often important to have a responsive design. Responsive design
    makes your web app render well on various devices and window/screen sizes. Our
    blog app might be viewed on a desktop, a mobile phone, a tablet, or maybe even
    a very large screen, such as a TV.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，拥有响应式设计通常很重要。响应式设计使您的Web应用程序在各种设备和窗口/屏幕尺寸上呈现良好。我们的博客应用可能在桌面上、手机上、平板上，甚至可能在非常大的屏幕上（如电视）上查看。
- en: Often, it makes the most sense to simply use CSS media queries for responsive
    design. However, sometimes that is not possible, for example, when we render elements
    within a canvas or **Web Graphics Library** (**WebGL**). Sometimes, we also want
    to use the window size in order to decide whether to load a component or not,
    instead of simply rendering it and then hiding it via CSS later.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于响应式设计，最合理的方法是简单地使用CSS媒体查询。然而，有时这是不可能的，例如，当我们在画布或Web图形库（WebGL）中渲染元素时。有时，我们还希望根据窗口大小决定是否加载组件，而不是简单地渲染它，然后通过CSS隐藏它。
- en: 'The `@rehooks/window-size` library provides the `useWindowSize` Hook, which
    returns the following values:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`@rehooks/window-size`库提供了`useWindowSize` Hook，返回以下值：'
- en: '`innerWidth`: Equal to the `window.innerWidth` value'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerWidth`：等同于`window.innerWidth`的值'
- en: '`innerHeight`: Equal to the `window.innerHeight` value'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerHeight`：等同于`window.innerHeight`的值'
- en: '`outerWidth`: Equal to the `window.outerWidth` value'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outerWidth`：等同于`window.outerWidth`的值'
- en: '`outerHeight`: Equal to the `window.outerHeight` value'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outerHeight`：等同于`window.outerHeight`的值'
- en: 'To show the difference between `outerWidth`/`outerHeight`, and `innerWidth`/`innerHeight`,
    take a look at the following diagram:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示`outerWidth`/`outerHeight`和`innerWidth`/`innerHeight`之间的区别，请查看以下图表：
- en: '![](assets/e6736ca3-dd77-471b-a220-3600c450612d.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e6736ca3-dd77-471b-a220-3600c450612d.png)'
- en: Visualization of the window width/height properties
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口宽度/高度属性的可视化
- en: As we can see, `innerHeight` and `innerWidth` specify the innermost part of
    the browser window, while `outerHeight` and `outerWidth` specify the full dimensions
    of the browser window, including the URL bar, scroll bars, and so on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`innerHeight`和`innerWidth`指定了浏览器窗口的最内部部分，而`outerHeight`和`outerWidth`指定了浏览器窗口的完整尺寸，包括URL栏、滚动条等。
- en: We are now going to hide components based on the window size in our blog app.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将根据博客应用中的窗口大小隐藏组件。
- en: Responsively hiding components
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式隐藏组件
- en: In our blog app, we are going to hide the `UserBar` and `ChangeTheme` components
    completely when the screen size is very small so that, when reading a post on
    a mobile phone, we can focus on the content.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客应用中，当屏幕尺寸非常小时，我们将完全隐藏`UserBar`和`ChangeTheme`组件，这样在手机上阅读文章时，我们可以专注于内容。
- en: 'Let''s get started implementing the Window Size Hook:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现Window Size Hook：
- en: 'First, we have to install the `@rehooks/window-size` library:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装`@rehooks/window-size`库：
- en: '[PRE69]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we import the `useWindowSize` Hook at the start of the `src/pages/HeaderBar.js`
    file:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`src/pages/HeaderBar.js`文件的开头导入`useWindowSize` Hook：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we define the following Window Size Hook after the existing Context Hooks:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在现有的Context Hooks之后，我们定义以下Window Size Hook：
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the window width is smaller than `640` pixels, we assume that the device
    is a mobile phone:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果窗口宽度小于`640`像素，我们假设设备是手机：
- en: '[PRE72]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, we only show the `ChangeTheme` and `UserBar` components when we are
    not on a mobile phone:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，只有在不是手机上时，我们才显示ChangeTheme和UserBar组件：
- en: '[PRE73]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we now resize our browser window to a width smaller than `640` pixels, we
    can see that the `ChangeTheme` and `UserBar` components will not be rendered anymore:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在调整浏览器窗口的宽度小于`640`像素，我们可以看到`ChangeTheme`和`UserBar`组件将不再被渲染：
- en: '![](assets/ee54d2cd-debb-48a1-8f05-15847cf17193.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee54d2cd-debb-48a1-8f05-15847cf17193.png)'
- en: Hiding the ChangeTheme and UserBar components on smaller screen sizes
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的屏幕尺寸上隐藏ChangeTheme和UserBar组件
- en: Using the Window Size Hook, we can avoid rendering elements on smaller screen
    sizes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Window Size Hook，我们可以避免在较小的屏幕尺寸上渲染元素。
- en: Example code
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter08/chapter8_4` folder.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter08/chapter8_4`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it does not open automatically).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Undo/Redo with Hooks
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks进行撤消/重做
- en: In some apps, we want to implement undo/redo functionality, which means that
    we can go back and forth in the state of our app. For example, if we have a text
    editor in our blog app, we want to provide a feature to undo/redo changes. If
    you learned about Redux, you might already be familiar with this kind of functionality.
    Since React now provides a Reducer Hook, we can reimplement the same functionality
    using only React. The `use-undo` library provides exactly this functionality.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些应用中，我们希望实现撤消/重做功能，这意味着我们可以在应用的状态中前进和后退。例如，如果我们在博客应用中有一个文本编辑器，我们希望提供撤消/重做更改的功能。如果你了解Redux，你可能已经熟悉这种功能。由于React现在提供了Reducer
    Hook，我们可以只使用React重新实现相同的功能。`use-undo`库正好提供了这种功能。
- en: 'The `useUndo` Hook takes the default `state` object as an argument, and returns
    an array with the following contents: `[ state, functions ]`.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`useUndo` Hook接受默认的`state`对象作为参数，并返回一个包含以下内容的数组：`[ state, functions ]`。'
- en: 'The `state` object looks as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`对象如下所示：'
- en: '`present`: The current state'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`present`：当前状态'
- en: '`past`: Array of past states (when we undo, we go here)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`past`：过去状态的数组（当我们撤消时，我们会回到这里）'
- en: '`future`: Array of future states (after undoing, we can redo to go here)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future`：未来状态的数组（撤消后，我们可以重做到这里）'
- en: 'The `functions` object returns various functions to interact with the Undo
    Hook:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions`对象返回与Undo Hook交互的各种函数：'
- en: '`set`: Sets the current state, and assigns a new value to `present`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`：设置当前状态，并为`present`分配一个新值。'
- en: '`reset`: Resets the current state, clears the `past` and `future` arrays (undo/redo
    history), and assigns a new value to `present`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`：重置当前状态，清除`past`和`future`数组（撤消/重做历史记录），并为`present`分配一个新值。'
- en: '`undo`: Undoes to the previous state (goes through the elements of the `past` array).'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undo`：撤销到先前的状态（遍历`past`数组的元素）。'
- en: '`redo`: Redoes to the next state (goes through the elements of the `future` array).'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redo`：重做到下一个状态（遍历`future`数组的元素）。'
- en: '`canUndo`: Equals `true` if it is possible to do an undo action (`past` array
    not empty).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canUndo`：如果可以执行撤销操作（`past`数组不为空），则为`true`。'
- en: '`canRedo`: Equals `true` if it is possible to do a redo action (`future` array
    not empty).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canRedo`：如果可以执行重做操作（`future`数组不为空），则为`true`。'
- en: We are now going to implement undo/redo functionality in our post editor.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在我们的文章编辑器中实现撤销/重做功能。
- en: Implementing Undo/Redo in our post editor
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的文章编辑器中实现撤销/重做
- en: 'In the simple post editor of our blog app, we have a `textarea` where we can
    write the contents of a blog post. We are now going to implement the `useUndo` Hook
    there, so that we can undo/redo any changes that we made to the text:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们博客应用的简单文章编辑器中，我们有一个`textarea`，我们可以在其中编写博客文章的内容。现在我们将在那里实现`useUndo` Hook，这样我们就可以撤销/重做对文本所做的任何更改：
- en: 'First, we have to install the `use-undo` library via `npm`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过`npm`安装`use-undo`库：
- en: '[PRE74]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we import the `useUndo` Hook from the library in `src/post/CreatePost.js`:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`src/post/CreatePost.js`中从库中导入`useUndo` Hook：
- en: '[PRE75]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we define the Undo Hook by replacing the current `useInput` Hook. Remove
    the following line of code:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过替换当前的`useInput` Hook来定义Undo Hook。删除以下代码行：
- en: '[PRE76]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Replace it with the `useUndo` Hook, as follows. We set the default state to
    `''''`. We also save the state to `undoContent`, and get the `setContent`, `undo`,
    and `redo` functions, as well as the `canUndo` and `canRedo` values:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用`useUndo` Hook替换它，如下所示。我们将默认状态设置为`''`。我们还将状态保存到`undoContent`，并获取`setContent`、`undo`和`redo`函数，以及`canUndo`和`canRedo`值：
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we assign the `undoContent.present` state to the `content` variable:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将`undoContent.present`状态分配给`content`变量：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we define a new handler function in order to update the `content` value
    using the `setContent` function:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个新的处理函数，以便使用`setContent`函数更新`content`值：
- en: '[PRE79]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, we have to replace the `bindContent` object with the `handleContent`
    function, as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须用`handleContent`函数替换`bindContent`对象，如下所示：
- en: '[PRE80]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we define buttons to Undo/Redo our changes, after the `textarea` element:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`textarea`元素之后定义按钮来撤销/重做我们的更改：
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It is important that `<button>` elements in a `<form>` element have a `type`
    attribute defined. If the `type` attribute is not defined, buttons are assumed
    to be `type="submit"`, which means that they will trigger the `onSubmit` handler
    function when clicked.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<form>`元素中，`<button>`元素具有定义的`type`属性是很重要的。如果未定义`type`属性，则假定按钮的`type`为`"submit"`，这意味着当点击时它们将触发`onSubmit`处理函数。
- en: Now, after entering text we can press Undo to remove one character at a time,
    and Redo to add the characters again. Next, we are going to implement debouncing,
    which means that our changes will only be added to the undo history after a certain
    amount of time, not after every character that we entered.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在输入文本后，我们可以按Undo逐个删除一个字符，然后按Redo再次添加字符。接下来，我们将实现去抖动，这意味着我们的更改只会在一定时间后添加到撤销历史记录中，而不是在每输入一个字符后。
- en: Debouncing with Hooks
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks进行去抖动
- en: As we have seen in the previous section, when we press Undo, it undoes a single
    character at a time. Sometimes, we do not want to store every change in our undo
    history. To avoid storing every change, we need to implement debouncing, which
    means that the function that stores our `content` to the undo history is only
    called after a certain amount of time.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所看到的，当我们按下Undo时，它会逐个撤销一个字符。有时，我们不希望将每个更改都存储在我们的撤销历史记录中。为了避免存储每个更改，我们需要实现去抖动，这意味着将我们的`content`存储到撤销历史记录的函数只在一定时间后才会被调用。
- en: 'The `use-debounce` library provides the `useDebounce` Hook, which can be used,
    as follows, for simple values:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`use-debounce`库提供了`useDebounce` Hook，可以用于简单值，如下所示：'
- en: '[PRE82]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now, if we change the text via `setText`, the `text` value will be updated instantly,
    but the `value` variable will only be updated after `1000` ms (`1` second).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们通过`setText`更改文本，`text`值将立即更新，但`value`变量将在`1000`毫秒（`1`秒）后更新。
- en: 'However, for our use case, this is not enough. We are going to need debounced
    callbacks in order to implement debouncing in combination with `use-undo`. The `use-debounce` library
    also provides the `useDebouncedCallback` Hook, which can be used as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的用例来说，这还不够。我们需要去抖动回调来结合`use-undo`实现去抖动。`use-debounce`库还提供了`useDebouncedCallback`
    Hook，可以如下使用：
- en: '[PRE83]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, if we call `debouncedSet('text')`, the `text` value will be updated after
    `1000` ms (`1` second). If `debouncedSet` is called multiple times, the timeout
    will get reset every time, so that only after `1000` ms of no further calls to
    the `debouncedSet` function, the `setText` function will be called. Next, we are
    going to move on to implementing debouncing in our post editor.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`debouncedSet('text')`，`text`值将在`1000`毫秒（`1`秒）后更新。如果多次调用`debouncedSet`，超时时间将每次重置，因此只有在`1000`毫秒内没有进一步调用`debouncedSet`函数时，才会调用`setText`函数。接下来，我们将继续实现帖子编辑器中的去抖动。
- en: Debouncing changes in our post editor
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的帖子编辑器中去抖动变化
- en: 'Now that we have learned about debouncing, we are going to implement it in
    combination with the Undo Hook in our post editor, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了去抖动，我们将在帖子编辑器中与撤销Hook结合实现它，如下所示：
- en: 'First, we have to install the `use-debounce` library via `npm`:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过`npm`安装`use-debounce`库：
- en: '[PRE84]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In `src/post/CreatePost.js`, first make sure that you import the `useState` Hook,
    if it is not imported already:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`src/post/CreatePost.js`中，首先确保导入`useState` Hook，如果尚未导入： '
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, import the `useDebouncedCallback` Hook from the `use-debounce` library:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从`use-debounce`库中导入`useDebouncedCallback` Hook：
- en: '[PRE86]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, before the Undo Hook, define a new State Hook, which we are going to use
    for the non-debounced value, to update the `input` field:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在撤销Hook之前，定义一个新的State Hook，我们将用它来更新`input`字段的非去抖动值：
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'After the Undo Hook, we remove the assignment of the `content` value. Remove
    the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撤销Hook之后，我们移除`content`值的赋值。移除以下代码：
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, after the Undo Hook, define the Debounced Callback Hook:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在撤销Hook之后，定义去抖动回调Hook：
- en: '[PRE89]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Within the Debounced Callback Hook, we define a function in order to set the
    content of the Undo Hook:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在去抖动回调Hook中，我们定义一个函数来设置撤销Hook的内容：
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We trigger the `setContent` function after `200` ms:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`200`毫秒后触发`setContent`函数：
- en: '[PRE91]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we have to define an Effect Hook, which will trigger whenever the undo
    state changes. In this Effect Hook, we cancel the current debouncing, and set
    the `content` value to the current `present` value:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义一个Effect Hook，每当撤销状态改变时触发。在这个Effect Hook中，我们取消当前的去抖动，并将`content`值设置为当前的`present`值：
- en: '[PRE92]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, we adjust the `handleContent` function in order to trigger the `setInput` function,
    as well as the `setDebounce` function:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调整`handleContent`函数以触发`setInput`函数和`setDebounce`函数：
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As a result, we instantly set the input `value`, but we do not store anything
    to the undo history yet. After the debouncing callback triggers (after `200` ms),
    we store the current value to the undo history. Whenever the undo state updates,
    for example, when we press the Undo/Redo buttons, we cancel the current debouncing
    to avoid overwriting the value after undoing/redoing. Then, we set the `content`
    value to the new `present` value of the Undo Hook.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们立即设置输入的`value`，但我们还没有将任何内容存储到撤销历史中。在去抖回调触发后（`200`毫秒后），我们将当前值存储到撤销历史中。每当撤销状态更新时，例如当我们按下撤销/重做按钮时，我们取消当前的去抖以避免在撤销/重做后覆盖值。然后，我们将`content`值设置为撤销Hook的新`present`值。
- en: 'If we now type some text into our editor, we can see that the Undo button only
    activates after a while. It then looks like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在编辑器中输入一些文本，我们会看到撤销按钮只有在一段时间后才会激活。然后它看起来像这样：
- en: '![](assets/79794e07-93c4-47d1-aab5-20011aa75eb8.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79794e07-93c4-47d1-aab5-20011aa75eb8.png)'
- en: Undo button activated after typing some text
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入一些文本后激活撤销按钮
- en: 'If we now press the Undo button, we can see that we will not undo character
    by character, but more text at once. For example, if we press Undo three times,
    we get the following result:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在按下撤销按钮，我们会看到我们不是逐个字符地撤销，而是一次撤销更多的文本。例如，如果我们按三次撤销，我们会得到以下结果：
- en: '![](assets/450730b4-94f3-4ccb-8f5c-ecf6ebdf9bdc.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/450730b4-94f3-4ccb-8f5c-ecf6ebdf9bdc.png)'
- en: Going back in time using the Undo button
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用撤销按钮回到过去
- en: As we can see, Undo/Redo and debouncing now work perfectly fine!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，撤销/重做和去抖现在都运行得很好！
- en: Example code
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter08/chapter8_5` folder.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter08/chapter8_5`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it does not open automatically).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果不会自动打开）。
- en: Finding other Hooks
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找其他Hooks
- en: There are many other Hooks that are provided by the community. You can find
    a searchable list of various Hooks on the following page: [https://nikgraf.github.io/react-hooks/.](https://nikgraf.github.io/react-hooks/)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他由社区提供的Hooks。您可以在以下页面上找到各种Hooks的可搜索列表：[https://nikgraf.github.io/react-hooks/.](https://nikgraf.github.io/react-hooks/)
- en: 'To give you an idea of which other Hooks are out there, the following features
    are provided by community Hooks. We now list a couple more interesting Hooks provided
    by the community. Of course, there are many more Hooks to be found:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解其他还有哪些Hooks，以下功能由社区提供的Hooks提供。我们现在列出了社区提供的一些更有趣的Hooks。当然，还有很多其他的Hooks可以找到：
- en: '`use-events` ([https://github.com/sandiiarov/use-events](https://github.com/sandiiarov/use-events)):
    Various JavaScript events that have been turned into Hooks, such as mouse position,
    touch events, clicking outside, and so on.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use-events` ([https://github.com/sandiiarov/use-events](https://github.com/sandiiarov/use-events))：各种JavaScript事件已经转换为Hooks，例如鼠标位置、触摸事件、点击外部等。'
- en: '`react-apollo-hooks` ([https://github.com/trojanowski/react-apollo-hooks](https://github.com/trojanowski/react-apollo-hooks)):
    Use Apollo Client (a caching **GraphQL** client) with React Hooks.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-apollo-hooks` ([https://github.com/trojanowski/react-apollo-hooks](https://github.com/trojanowski/react-apollo-hooks))：使用React
    Hooks与Apollo Client（一个缓存**GraphQL**客户端）。'
- en: '`react-use` ([https://github.com/streamich/react-use](https://github.com/streamich/react-use)):
    Various Hooks to deal with sensors (`useBattery`, `useIdle`, `useGeolocation`,
    and so on), UI (`useAudio`, `useCss`, `useFullscreen`, and so on), animations
    (`useSpring`, `useTween`, `useRaf`, and so on), and side effects (`useAsync`,
    `useDebounce`, `useFavicon`, and so on).'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-use` ([https://github.com/streamich/react-use](https://github.com/streamich/react-use))：处理传感器（`useBattery`，`useIdle`，`useGeolocation`等），UI（`useAudio`，`useCss`，`useFullscreen`等），动画（`useSpring`，`useTween`，`useRaf`等），以及副作用（`useAsync`，`useDebounce`，`useFavicon`等）的各种Hooks。'
- en: '`react-use-clipboard` ([https://github.com/danoc/react-use-clipboard](https://github.com/danoc/react-use-clipboard)):
    Clipboard functionality to copy text.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-use-clipboard` ([https://github.com/danoc/react-use-clipboard](https://github.com/danoc/react-use-clipboard))：复制文本的剪贴板功能。'
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first learned about the `react-hookedup` library. We used
    this library to simplify input handling with Hooks in our blog app. Then, we had
    a look at implementing various React life cycles with Hooks. Next, we covered
    various useful Hooks, such as the `usePrevious` Hook, Interval/Timeout Hooks,
    the Online Status Hook, data manipulation Hooks, and the Focus and Hover Hooks.
    Afterward, we covered responsive design using Hooks, by not rendering certain
    components on mobile phones. Finally, we learned about implementing undo/redo
    functionality and debouncing using Hooks.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了`react-hookedup`库。我们在博客应用中使用这个库来简化使用Hooks处理输入。然后，我们看了一下如何使用Hooks实现各种React生命周期。接下来，我们介绍了各种有用的Hooks，比如`usePrevious`
    Hook，Interval/Timeout Hooks，Online Status Hook，数据操作Hooks，以及Focus和Hover Hooks。之后，我们使用Hooks实现了响应式设计，不在手机上渲染某些组件。最后，我们学习了如何使用Hooks实现撤销/重做功能和防抖。
- en: Using community Hooks is a very important skill, as React only provides a handful
    of Hooks out of the box. In real applications, you will probably be using many
    Hooks that are provided by the community, from various libraries and frameworks.
    We also learned about various community Hooks that will make our life so much
    easier when writing React applications.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用社区Hooks是一项非常重要的技能，因为React只提供了一小部分Hooks。在实际应用中，你可能会使用许多由社区提供的Hooks，来自各种库和框架。我们还学习了一些社区提供的Hooks，这些Hooks在编写React应用时会让我们的生活变得更加轻松。
- en: In the next chapter, we will gain an in-depth knowledge about the rules of Hooks,
    which are important to know before we can start writing our own Hooks.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解Hooks的规则，这些规则在我们开始编写自己的Hooks之前是很重要的。
- en: Questions
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to recap what we have learned in this chapter, try answering the following
    questions:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章学到的内容，请尝试回答以下问题：
- en: Which Hook can we use to simplify input field handling?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个Hook来简化输入字段处理？
- en: How are the `componentDidMount` and `componentWillUnmount` life cycles implemented
    using Effect Hooks?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Effect Hooks来实现`componentDidMount`和`componentWillUnmount`生命周期？
- en: How can we use Hooks to get the behavior of `this.setState()`?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Hooks来实现`this.setState()`的行为？
- en: Why should we use timer Hooks instead of calling `setTimeout` and `setInterval`
    directly?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用定时器Hooks而不是直接调用`setTimeout`和`setInterval`？
- en: Which Hooks can we use to simplify dealing with common data structures?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些Hooks来简化处理常见数据结构？
- en: When should we use responsive design with Hooks, versus simply using CSS media
    queries?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用Hooks来实现响应式设计，而不是简单地使用CSS媒体查询？
- en: Which Hook can we use to implement undo/redo functionality?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个Hook来实现撤销/重做功能？
- en: What is debouncing? Why do we need to do it?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是防抖？为什么我们需要这样做？
- en: Which Hooks can we use for debouncing?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些Hooks来实现防抖？
- en: Further reading
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following reading material:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章学习的概念更多信息感兴趣，请查看以下阅读材料：
- en: '`react-hookedup` library documentation: [https://github.com/zakariaharti/react-hookedup](https://github.com/zakariaharti/react-hookedup)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-hookedup`库文档：[https://github.com/zakariaharti/react-hookedup](https://github.com/zakariaharti/react-hookedup)'
- en: '`window-size` library documentation: [https://github.com/rehooks/window-size](https://github.com/rehooks/window-size)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window-size`库文档：[https://github.com/rehooks/window-size](https://github.com/rehooks/window-size)'
- en: '`use-undo` library documentation: [https://github.com/xxhomey19/use-undo](https://github.com/xxhomey19/use-undo)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use-undo`库文档：[https://github.com/xxhomey19/use-undo](https://github.com/xxhomey19/use-undo)'
- en: '`use-debounce` library documentation: [https://github.com/xnimorz/use-debounce.](https://github.com/xnimorz/use-debounce)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use-debounce`库文档：[https://github.com/xnimorz/use-debounce.](https://github.com/xnimorz/use-debounce)'
- en: Collection of React Hooks: [https://nikgraf.github.io/react-hooks/](https://nikgraf.github.io/react-hooks/)
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks集合：[https://nikgraf.github.io/react-hooks/](https://nikgraf.github.io/react-hooks/)
- en: '*Learning Redux* book published by *Packt* for more in-depth information about
    undo/redo functionality: [https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Packt*出版的*Learning Redux*书籍，提供有关撤消/重做功能的更深入信息：[https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)
