- en: Interacting with RESTful APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与RESTful API交互
- en: Interacting with RESTful APIs is a very common task we need to do when building
    an app, and it always results in us having to write asynchronous code. So, to
    begin with in this chapter, we'll have a detailed look at asynchronous code in
    general.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与RESTful API交互是构建应用程序时我们需要做的非常常见的任务，它总是导致我们必须编写异步代码。因此，在本章的开始，我们将详细了解一般的异步代码。
- en: There are many libraries that we can use to help us interact with REST APIs.
    In this chapter, we'll look at both a native browser function and a popular open
    source library for interacting with REST APIs. We'll discover the additional features
    that the open source library has over the native function. We will also look at
    how we can interact with a REST API in both React class and function-based components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库可以帮助我们与REST API交互。在本章中，我们将看看原生浏览器函数和一个流行的开源库来与REST API交互。我们将发现开源库相对于原生函数的额外功能。我们还将看看如何在React类和基于函数的组件中与REST
    API交互。
- en: 'In this chapter, we''ll learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Writing asynchronous code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写异步代码
- en: Using fetch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fetch
- en: Using axios with class components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用axios与类组件
- en: Using axios with function components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用axios与函数组件
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We use the following technologies in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用以下技术：
- en: '**TypeScript playground**: This is a website at [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/)
    that allows us to play with asynchronous code without installing anything.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript playground**：这是一个网站，位于[https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/)，允许我们在不安装任何东西的情况下玩耍异步代码。'
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和** `npm`：TypeScript和React依赖于这些。我们可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装这些。如果我们已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**TypeScript**: This can be installed via `npm` with the following command
    in a terminal:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**：可以通过终端中的以下命令使用`npm`安装：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Visual Studio Code**. We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**。我们需要一个编辑器来编写我们的React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要在Visual
    Studio Code中安装 TSLint (by egamma) 和 Prettier (by Estben Petersen) 扩展。'
- en: '`jsonplaceholder.typicode.com`: We will use this online service to help us
    learn how to interact with a RESTful API.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonplaceholder.typicode.com`：我们将使用这个在线服务来帮助我们学习如何与RESTful API交互。'
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs.](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs.](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs)上找到
- en: Writing asynchronous code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写异步代码
- en: TypeScript code is executed synchronously by default, where each line of code
    is executed after each other. However, TypeScript code can also be asynchronous,
    which means things can happen independently of our code. Calling a REST API is
    an example of asynchronous code because the API request is handled outside of
    our TypeScript code. So, interacting with a REST API forces us to write asynchronous
    code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript代码默认是同步执行的，每行代码都会依次执行。然而，TypeScript代码也可以是异步的，这意味着事情可以独立于我们的代码发生。调用REST
    API就是异步代码的一个例子，因为API请求是在我们的TypeScript代码之外处理的。因此，与REST API交互会迫使我们编写异步代码。
- en: In this section, we'll take the time to understand the approaches we can take
    when writing asynchronous code before using them to interact with RESTful APIs.
    We'll start in the next section by looking at callbacks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将花时间了解在编写异步代码时可以采取的方法，然后再使用它们与RESTful API进行交互。我们将在下一节开始时看一下回调函数。
- en: Callbacks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: A callback is a function we pass as a parameter to an asynchronous function
    to call when the asynchronous function is complete. In the next section, we'll
    go through an example of writing asynchronous code with a callback.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是我们将作为参数传递给异步函数的函数，在异步函数完成时调用。在下一节中，我们将通过一个使用回调的异步代码示例进行说明。
- en: Callback execution
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调执行
- en: 'Let''s go through an example of using callbacks in asynchronous code in the
    TypeScript playground. Let''s enter the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在TypeScript播放器中通过一个使用回调的异步代码示例来进行说明。让我们输入以下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code calls the JavaScript `setTimeout` function, which is asynchronous. It
    takes in a callback as the first parameter and the number of milliseconds the
    execution should wait until the callback is executed as the second parameter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码调用了JavaScript的`setTimeout`函数，这是一个异步函数。它以回调作为第一个参数，并以执行应等待的毫秒数作为第二个参数。
- en: We use an arrow function as the callback function, where we set the `firstName` variable
    to "Fred" and output this to the console. We also log `firstName` in the console
    immediately after the call to `setTimeout`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用箭头函数作为回调函数，在其中将`firstName`变量设置为"Fred"并将其输出到控制台。我们还在调用`setTimeout`后立即在控制台中记录`firstName`。
- en: 'So, which `console.log` statement will get executed first? If we run the code
    and look at the console, we''ll see that the last line is executed first:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪个`console.log`语句会首先执行呢？如果我们运行代码并查看控制台，我们会看到最后一行首先执行：
- en: '![](assets/b9a54558-5be3-47a1-8921-2cd69f4933e2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b9a54558-5be3-47a1-8921-2cd69f4933e2.png)'
- en: The key point is that after `setTimeout` is called, execution carries on to
    the next line of code. Execution doesn't wait for the callback to be called. This
    can make code that includes callbacks harder to read than synchronous code, particularly
    when we have callbacks nested within callbacks. This is referred to as **callback
    hell** by many developers!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，在调用`setTimeout`之后，执行会继续到下一行代码。执行不会等待回调被调用。这可能会使包含回调的代码比同步代码更难阅读，特别是当我们在回调中嵌套回调时。许多开发人员称之为**回调地狱**！
- en: So, how do we handle errors in asynchronous callback code? We'll find out in
    the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理异步回调代码中的错误？我们将在下一节中找出答案。
- en: Handling callback errors
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理回调错误
- en: 'In this section, we are going to explore how we can handle errors when using
    callback code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在使用回调代码时如何处理错误：
- en: 'Let''s start by entering the following code in the TypeScript playground:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在TypeScript播放器中输入以下代码开始：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are again using `setTimeout` to experiment with callbacks. This time, we
    throw an error inside the callback. We are hoping to catch the error outside the
    callback using a `try / catch` around the `setTimeout` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`setTimeout`来尝试回调。这次，在回调函数内抛出一个错误。我们希望使用`try / catch`来捕获回调外部的错误，围绕`setTimeout`函数。
- en: 'If we run the code, we see that we don''t catch the error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们会发现我们没有捕获错误：
- en: '![](assets/08ffe4f4-0b57-4cc6-8d4b-ed7d664004bf.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/08ffe4f4-0b57-4cc6-8d4b-ed7d664004bf.png)'
- en: 'We must handle errors within the callback. So, let''s adjust our example to
    the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须在回调函数内处理错误。因此，让我们将我们的示例调整为以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, the `try / catch` is within the callback. We use a variable, `result`,
    to determine whether the callback was executed successfully, along with any error.
    The `IResult` interface gives us a nice bit of type safety with the result `variable`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`try / catch`在回调函数内。我们使用一个变量`result`来确定回调是否成功执行，以及任何错误。`IResult`接口为我们提供了对结果`变量`的良好类型安全性。
- en: 'If we run this code, we''ll see that we successfully handle the error:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将看到我们成功处理了错误：
- en: '![](assets/ec166585-af59-4cc9-b805-2cb395749311.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec166585-af59-4cc9-b805-2cb395749311.png)'
- en: So, handling errors along with reading callback-based code is a challenge. Luckily,
    there are alternative approaches that deal with these challenges, which we'll
    go through in the next sections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，处理错误以及读取基于回调的代码是一个挑战。幸运的是，有替代方法来处理这些挑战，我们将在接下来的部分中介绍。
- en: Promises
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: A promise is a JavaScript object that represents the eventual completion (or
    failure) of an asynchronous operation and its resulting value. We'll have a look
    at an example of consuming a promised-based function in the next section, followed
    by creating our own promised-based function after that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: promise是一个JavaScript对象，它代表异步操作的最终完成（或失败）及其结果值。接下来，我们将看一个消耗基于promise的函数的示例，然后创建我们自己的基于promise的函数。
- en: Consuming a promised-based function
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消耗基于promise的函数
- en: 'Let''s have a quick look at some code that exposes a promise-based API:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下一些暴露了基于promise的API的代码：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function is the native JavaScript `fetch` function for interacting with
    RESTful APIs
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数是用于与RESTful API交互的本机JavaScript `fetch`函数
- en: The function takes in a URL for the request
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数接受一个用于请求的URL。
- en: It has a `then` method to handle the response and reading of the response body
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个`then`方法来处理响应和读取响应主体
- en: It has a `catch` method to handle any errors
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个`catch`方法来处理任何错误
- en: The code execution flows down as we would read it. We also don't have to do
    any additional work in the `then` methods to handle errors. So, this is much nicer
    than working with callback-based asynchronous code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行流程与我们阅读的方式相同。我们还不必在`then`方法中做任何额外的工作来处理错误。因此，这比使用基于回调的异步代码要好得多。
- en: In the next section we'll create our own promised based function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建我们自己的基于promise的函数。
- en: Creating a promised based function
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基于promise的函数
- en: 'In this section, we''ll create a `wait` function to asynchronously wait a number
    of milliseconds that passed in as a parameter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个`wait`函数，以异步等待传递的毫秒数：
- en: 'Let''s enter the following into the TypeScript playground:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在TypeScript playground中输入以下内容：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function starts by returning a `Promise` object, which takes in the function
    that needs to be executed asynchronously as its constructor parameter
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数开始通过返回一个`Promise`对象，该对象将需要异步执行的函数作为其构造函数参数
- en: The `promise` function takes in a `resolve` parameter, which is a function that
    we call when the function has finished executing
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise`函数接受一个`resolve`参数，这是一个在函数执行完成时调用的函数'
- en: The promise function also takes in a `reject` parameter, which is a function
    that we call when the function errors
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: promise函数还接受一个`reject`参数，这是一个在函数出错时调用的函数
- en: Internally, we are using `setTimeout` with a callback to do the actual waiting
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，我们使用带有回调的`setTimeout`来进行实际的等待
- en: 'Let''s consume our promised-based `wait` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们消费我们基于promise的`wait`函数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function simply outputs the result or error to the console after waiting
    500 milliseconds.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数只是在等待500毫秒后将结果或错误输出到控制台。
- en: 'So, let''s give this a try and run it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试运行它：
- en: '![](assets/43ce9513-e1b1-4b0a-b4c4-b9f14206adf1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43ce9513-e1b1-4b0a-b4c4-b9f14206adf1.png)'
- en: As we can see, the output in the console indicates that the `then` method is
    executed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，控制台中的输出表明`then`方法被执行了。
- en: 'If we call the `wait` function with a parameter greater than 1000, the `catch`
    method should be invoked. Let''s give this a try:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们用大于1000的参数调用`wait`函数，`catch`方法应该被调用。让我们试一试：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As expected, the `catch` method is executed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`catch`方法被执行：
- en: '![](assets/5c3b5730-c747-4e17-9499-23f7a4c9461f.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c3b5730-c747-4e17-9499-23f7a4c9461f.png)'
- en: So, promises give us a nice way of writing asynchronous code. However, there's
    another approach that we have used a number of times earlier in this book. We'll
    go through this method in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，promise给了我们一种很好的编写异步代码的方式。然而，在本书的早期我们已经使用了另一种方法。我们将在下一节中介绍这种方法。
- en: async and await
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步和等待
- en: '`async` and `await` are two JavaScript keywords we can use to make asynchronous
    code read almost identically to synchronous code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`是两个JavaScript关键字，我们可以使用它们使异步代码的阅读几乎与同步代码相同：'
- en: 'Let''s look at an example of consuming our `wait` function we created in the
    last section by entering the following code into the TypeScript playground, after
    the `wait` function declaration:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一个例子，消费我们在上一节中创建的`wait`函数，将以下代码输入到TypeScript playground中，放在`wait`函数声明之后：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have created an arrow function called `someWork` that is marked as asynchronous
    with the `async` keyword.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`someWork`的箭头函数，并用`async`关键字标记为异步。
- en: We then call `wait` prefixed with the `await` keyword. This halts execution
    of the next line until `wait` has completed.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们调用带有`await`关键字前缀的`wait`。这会暂停下一行的执行，直到`wait`完成。
- en: The `try / catch` will catch any errors.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try / catch`将捕获任何错误。'
- en: So, the code is very similar to how you would write it in a synchronous manner.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码非常类似于您在同步方式下编写的方式。
- en: 'If we run this example, we get confirmation that the `console.log` statement
    in the `try` branch waited until the `wait` function had completely finished before
    executing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子，我们会得到确认，`try`分支中的`console.log`语句等待`wait`函数完全完成后才执行：
- en: '![](assets/0278f6b8-7431-4059-8cec-87efa7941022.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0278f6b8-7431-4059-8cec-87efa7941022.png)'
- en: 'Let''s change the wait to `1500` milliseconds:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将等待时间改为`1500`毫秒：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run this, we see that an error is raised and caught:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们会看到一个错误被引发并捕获：
- en: '![](assets/5af59f14-a6b6-44c0-bbe9-d6701cde368d.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5af59f14-a6b6-44c0-bbe9-d6701cde368d.png)'
- en: So, `async` and `await` make our code nice and easy to read. A bonus for using
    these in TypeScript is that the code can be transpiled to work in older browsers.
    So, for example, we can code with `async` and `await` and still support IE.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`async`和`await`使我们的代码易于阅读。在TypeScript中使用这些的一个好处是，代码可以被转译以在旧版浏览器中运行。例如，我们可以使用`async`和`await`编码，同时支持IE。
- en: Now that we have a good understanding of writing asynchronous code, we'll put
    this into practice when we interact with RESTful APIs in the following sections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对编写异步代码有了很好的理解，我们将在接下来的章节中将其付诸实践，当我们与RESTful API交互时。
- en: Using fetch
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch
- en: The `fetch` function is a native JavaScript function that we can use to interact
    with RESTful APIs. In this section, we'll go through some common RESTful API interactions
    using `fetch`, starting with getting data. Throughout this section, we are going
    to interact with the fantastic `JSONPlaceholder` REST API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`函数是一个原生的JavaScript函数，我们可以用它来与RESTful API交互。在本节中，我们将通过`fetch`进行一些常见的RESTful
    API交互，从获取数据开始。在本节中，我们将与出色的`JSONPlaceholder` REST API进行交互。'
- en: Getting data with fetch
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch获取数据
- en: In this section, we'll use `fetch` to get some posts from the `JSONPlaceholder` REST
    API, starting with a basic `GET` request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`fetch`从`JSONPlaceholder` REST API获取一些帖子，从基本的`GET`请求开始。
- en: Basic GET request
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的GET请求
- en: 'Let''s open up the TypeScript playground and enter the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开TypeScript playground并输入以下内容：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are some key points:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键点：
- en: The first parameter in the `fetch` function is the URL for the request
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`函数中的第一个参数是请求的URL'
- en: '`fetch` is a promised-based function'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`是一个基于承诺的函数'
- en: The first `then` method handles the response
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`then`方法处理响应
- en: The second `then` method handles when the body has been parsed as JSON
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`then`方法处理当响应体已解析为JSON时
- en: 'If we run the code, we should see an array of posts output to the console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，应该会在控制台输出一个帖子数组：
- en: '![](assets/be4bbc0d-04b2-4867-98f1-1ea1c4f9d7e6.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/be4bbc0d-04b2-4867-98f1-1ea1c4f9d7e6.png)'
- en: Getting response status
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取响应状态
- en: 'Very often, we need to check the status of the request. We can do this as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要检查请求的状态。我们可以这样做：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The response `status` property gives the HTTP status code of the response
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的`status`属性给出了响应的HTTP状态码
- en: The response `ok` property is a `boolean` and returns whether the HTTP status
    code is in the 200 range
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的`ok`属性是一个`boolean`，返回HTTP状态码是否在200范围内
- en: If we run the previous code, we get 200 and true output to the console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行先前的代码，我们会在控制台得到200和true的输出。
- en: 'Let''s try an example request where the post doesn''t exist:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个帖子不存在的示例请求：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we run the preceding code, we get 404 and false output to the console.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们会在控制台得到404和false的输出。
- en: Handling errors
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'As we would expect with a promised-based function, we handle errors in the
    `catch` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于承诺的函数，我们在`catch`方法中处理错误：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, the `catch` method doesn't catch responses that aren't in the 200 range.
    An example of this was in the previous example, where we got 404 in the response
    status code. So, an HTTP error status code can be handled in the first `then`
    method and not the `catch` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`catch`方法不会捕获不在200范围内的响应。在先前的示例中，我们得到了响应状态码为404。因此，HTTP错误状态码可以在第一个`then`方法中处理，而不是`catch`方法。
- en: So, what is the `catch` method for? The answer is to catch network errors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`catch`方法是用来做什么的？答案是捕获网络错误。
- en: So, that's how to get data using `fetch`. In the next section, we'll cover posting
    data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用`fetch`获取数据的方法。在下一节中，我们将介绍发布数据。
- en: Creating data with fetch
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch创建数据
- en: In this section, we'll use `fetch` to create some data with the `JSONPlaceholder` REST
    API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`fetch`来使用`JSONPlaceholder` REST API创建一些数据。
- en: Basic POST request
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的POST请求
- en: Creating data via a REST API usually involves using the HTTP `POST` method with
    the data we want to create in the request body.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过REST API创建数据通常涉及使用HTTP `POST`方法，并将要创建的数据放在请求体中。
- en: 'Let''s open up the TypeScript playground and enter the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开TypeScript playground并输入以下内容：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `fetch` call is largely the same as for getting data. The key difference
    is the second parameter, which is an options object that can contain the method
    and body for the request. Notice also that the body needs to be a `string`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`调用与获取数据的方式基本相同。关键区别在于第二个参数，它是一个包含请求的方法和主体的选项对象。还要注意主体需要是一个`string`。'
- en: If we run the preceding code, we get a 201 and an object containing the generated
    post ID in the console.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们将在控制台中得到201和包含生成的帖子ID的对象。
- en: Request HTTP headers
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求HTTP标头
- en: 'Very often, we need to include HTTP headers in the request. We can specify
    these in the `options` object in a `headers` property:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要在请求中包含HTTP标头。我们可以在`options`对象中的`headers`属性中指定这些内容：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Request headers can be used in this way for any HTTP method and not just an
    HTTP `POST`. For example, we can use this for a `GET` request as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请求标头可以用于任何HTTP方法，而不仅仅是HTTP `POST`。例如，我们可以用于`GET`请求如下：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, that's how to use `fetch` to post data to a REST API. In the next section,
    we'll look at changing data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是如何使用`fetch`向REST API发布数据。在下一节中，我们将看看如何更改数据。
- en: Changing data with fetch
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch更改数据
- en: In this section, we'll use `fetch` to change some data via a REST API.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`fetch`通过REST API更改一些数据。
- en: Basic PUT request
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的PUT请求
- en: 'A common way to change data is via a `PUT` request. Let''s open up the TypeScript
    playground and enter the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`PUT`请求通常更改数据。让我们打开TypeScript播放器并输入以下内容：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, the structure of a `fetch` call to do an HTTP `PUT` is very similar to a
    `POST` request. The only difference is that we specify the `method` property in
    the options object as `PUT`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，进行HTTP `PUT`的`fetch`调用的结构与`POST`请求非常相似。唯一的区别是我们在选项对象中指定`method`属性为`PUT`。
- en: If we run the preceding code, we get 200 and the updated `POST` object output
    to the console.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们将得到200和更新的`POST`对象输出到控制台。
- en: Basic PATCH request
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的PATCH请求
- en: 'Some REST APIs offer `PATCH` requests, which allow us to submit changes to
    a portion of a resource. Let''s open up the TypeScript playground and enter the
    following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些REST API提供`PATCH`请求，允许我们提交对资源部分的更改。让我们打开TypeScript播放器并输入以下内容：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, we are submitting a change to the title of the post with the `PATCH` HTTP
    method. If we run the preceding code, we get 200 and the updated post object output
    to the console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在使用`PATCH` HTTP方法提交对帖子标题的更改。如果我们运行上述代码，我们将得到200和更新的帖子对象输出到控制台。
- en: So, that's how to `PUT` and `PATCH` using `fetch`. In the next section, we'll
    delete some data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是如何使用`fetch`进行`PUT`和`PATCH`。在下一节中，我们将删除一些数据。
- en: Deleting data with fetch
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch删除数据
- en: 'Generally, we delete data via a `DELETE` HTTP method on a REST API. Let''s
    enter the following in the TypeScript playground:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过REST API上的`DELETE` HTTP方法删除数据。在TypeScript播放器中输入以下内容：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, we are requesting to delete a post with the `DELETE` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在请求使用`DELETE`方法删除帖子。
- en: If we run the preceding code, we get 200 output to the console.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们将在控制台中得到200的输出。
- en: So, we've learned how to interact with a RESTful API with the native `fetch`
    function. In the next section, we'll look at doing the same with a popular open
    source library and understanding its benefits over `fetch`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经学会了如何使用原生的`fetch`函数与RESTful API进行交互。在下一节中，我们将看看如何使用流行的开源库执行相同操作，并了解其相对于`fetch`的优势。
- en: Using axios with class components
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios与类组件
- en: '`axios` is a popular open source JavaScript HTTP client. We''re going to build
    a little React app that creates, reads, updates, and deletes posts from the `JSONPlaceholder`
    REST API. Along the way, we''ll discover some of the benefits of `axios` over
    `fetch`. Our first job in the next section is to install `axios`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios`是一个流行的开源JavaScript HTTP客户端。我们将构建一个小型的React应用程序，从`JSONPlaceholder` REST
    API中创建、读取、更新和删除帖子。在此过程中，我们将发现`axios`相对于`fetch`的一些优点。在下一节中，我们的第一个任务是安装`axios`。'
- en: Installing axios
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装axios
- en: 'Before we install `axios`, we are going to quickly create our little React
    app:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装`axios`之前，我们将快速创建我们的小型React应用程序：
- en: 'In a folder of our choice, let''s open Visual Studio Code and its Terminal and
    enter the following command to create a new React and TypeScript project:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们选择的文件夹中，让我们打开Visual Studio Code和它的终端，并输入以下命令来创建一个新的React和TypeScript项目：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json`
    is older than `16.7.0-alpha.0`, then we can install this version using the following
    command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的React版本至少需要是`16.7.0-alpha.0`版本。我们可以在`package.json`文件中检查这一点。如果`package.json`中的React版本旧于`16.7.0-alpha.0`，那么我们可以使用以下命令安装这个版本：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the project is created, let''s add TSLint as a development dependency
    to our project, along with some rules that work well with React and Prettier:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，让我们将TSLint作为开发依赖项添加到我们的项目中，以及一些与React和Prettier配合良好的规则：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s now add a `tslint.json` file containing some rules:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个包含一些规则的`tslint.json`文件：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we open `App.tsx`, there is a linting error. So, let''s resolve this by
    adding `public` as the modifier on the `render` method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们打开`App.tsx`，会有一个linting错误。所以，让我们通过在`render`方法上添加`public`修饰符来解决这个问题：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can install `axios` using NPM:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用NPM安装`axios`：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that `axios` has TypeScript types within it, so, we don't need to install
    them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`axios`中包含TypeScript类型，因此我们不需要安装它们。
- en: 'Let''s start our app running before we continue with development:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续开发之前，让我们先运行我们的应用程序：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The app will then start up and run in our browser. In the next section, we'll
    use axios to get posts from JSONPlaceholder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在浏览器中启动并运行。在下一节中，我们将使用axios从JSONPlaceholder获取帖子。
- en: Getting data with axios
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios获取数据
- en: In this section, we are going to render posts from `JSONPlaceholder` in the `App` component.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在`App`组件中呈现来自`JSONPlaceholder`的帖子。
- en: Basic GET request
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的GET请求
- en: 'We''ll start off by getting the posts using a basic GET request with `axios`,
    and then rendering them in an unordered list:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`axios`开始，使用基本的GET请求获取帖子，然后在无序列表中呈现它们：
- en: 'Let''s open `App.tsx` and add an import statement for `axios`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`App.tsx`并为`axios`添加一个导入语句：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s also create an interface for the posts that will come from JSONPlaceholder:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为从JSONPlaceholder获取的帖子创建一个接口：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are going to store the posts in state, so let''s add an interface for this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把帖子存储在状态中，所以让我们为此添加一个接口：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s then initialize the post-state to an empty array in a constructor:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在构造函数中将帖子状态初始化为空数组：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When getting data from a REST API, we usually do this in the `componentDidMount`
    life cycle method. So, let''s do this with `axios` to get our posts:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从REST API获取数据时，通常会在`componentDidMount`生命周期方法中进行。所以，让我们使用`axios`来获取我们的帖子：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We use the `get` function in `axios` to get data, which is a promised-based
    function like `fetch`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`axios`中的`get`函数来获取数据，这是一个类似于`fetch`的基于Promise的函数
- en: This is a generic function that accepts the response body type as a parameter
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个通用函数，它接受响应主体类型作为参数
- en: We pass the URL we are requesting as the parameter to the `get` function
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将我们请求的URL作为参数传递给`get`函数
- en: We can then handle the response in the `then` method
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们可以在`then`方法中处理响应
- en: We get access to the response body via the `data` property in the response object
    that is typed, as per the generic parameter
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过响应对象中的`data`属性获得对响应主体的访问权限，该对象是根据通用参数进行了类型化。
- en: 'So, straight away this is nicer than `fetch` in two ways:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这比`fetch`更好的两种方式：
- en: We can easily type the response
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松输入响应
- en: There is one step (rather than two) to get the response body
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一步（而不是两步）来获取响应主体
- en: 'Now that we have the posts in the component state, let''s render the posts
    in the `render` method. Let''s also remove the `header` tag:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经在组件状态中有了帖子，让我们在`render`方法中呈现帖子。让我们还删除`header`标签：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use the `posts` array's `map` function to display the posts in an unordered
    list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`posts`数组的`map`函数来显示帖子的无序列表。
- en: 'We reference a `posts` CSS class, so let''s add this to `index.css`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引用了一个`posts` CSS类，因此让我们将其添加到`index.css`中：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we look at the running app, it will now look like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，它现在将如下所示：
- en: '![](assets/c8ae59fc-f745-47d3-aca5-ce24e4911e01.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8ae59fc-f745-47d3-aca5-ce24e4911e01.png)'
- en: So, a basic `GET` request with `axios` is nice and easy. We need to use the
    `componentDidMount` life cycle method in a class component to make a REST API
    call that will have data from the response rendered.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`axios`进行基本的`GET`请求非常简单。我们需要在类组件中使用`componentDidMount`生命周期方法，以便进行REST API调用，该调用将从响应中呈现数据。
- en: How do we handle errors though? We'll cover this in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何处理错误呢？我们将在下一节中介绍这一点。
- en: Handling errors
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'Let''s adjust the URL in our request:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调整我们的请求中的URL：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we look at the running app, the posts are no longer being rendered.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，帖子将不再被呈现。
- en: 'We want to handle this situation and give the user some feedback. We can do
    this using a `catch` method:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望处理这种情况并给用户一些反馈。我们可以使用`catch`方法来做到这一点：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, unlike `fetch`, HTTP status error codes can be handled in the `catch` method.
    The error object argument in `catch` contains a `response` property containing
    information about the response, including the HTTP status code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与`fetch`不同，HTTP状态错误代码可以在`catch`方法中处理。`catch`中的错误对象参数包含一个包含有关响应的信息的`response`属性，包括HTTP状态代码。
- en: 'We just referenced a piece of state called `error` in the `catch` method. We''ll
    use this in the next step to render the error message. However, we first need
    to add this state to our interface and initialize it:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`catch`方法中引用了一个名为`error`的状态片段。我们将在下一步中使用它来呈现错误消息。但是，我们首先需要将此状态添加到我们的接口并进行初始化：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s then render the error if it contains a value:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果包含值，让我们呈现错误：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s add the `error` CSS class we just referenced to `index.css`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在将刚刚引用的`error` CSS类添加到`index.css`中：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we look at the running app now, we'll see Resource not found in red.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看正在运行的应用程序，我们将看到红色的资源未找到。
- en: 'Let''s now change the URL to a valid URL so that we can move on to looking
    at how we can include HTTP headers in the next section:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将URL更改为有效的URL，以便我们可以继续查看如何在下一节中包含HTTP标头：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, handling HTTP errors with `axios` is different than with `fetch`. We handle
    them in the first `then` method with `fetch`, whereas we handle them in the `catch`
    method with `axios`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`axios`处理HTTP错误与使用`fetch`不同。我们在`fetch`的第一个`then`方法中处理它们，而我们在`axios`的`catch`方法中处理它们。
- en: Request HTTP headers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求HTTP标头
- en: In order to include HTTP headers in the request, we need to add a second parameter
    to the `get` function, which can contain various options, including HTTP headers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在请求中包含HTTP标头，我们需要向`get`函数添加第二个参数，该参数可以包含各种选项，包括HTTP标头。
- en: 'Let''s add an HTTP header for the content type in our request:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的请求中添加一个内容类型的HTTP标头：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, we define the HTTP headers in an object in a property called `headers`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在一个名为`headers`的属性中的对象中定义了HTTP标头。
- en: If we look at the running app, it will be exactly the same. The JSONPlaceholder
    REST API doesn't require the content type, but other REST APIs that we interact
    with may do.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，它将完全相同。JSONPlaceholder REST API不需要内容类型，但我们与之交互的其他REST API可能需要。
- en: In the next section, we'll look at something that is not easily achieved in
    the `fetch` function, which is the ability to specify a timeout on the request.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看在`fetch`函数中很难实现的一些东西，即在请求上指定超时的能力。
- en: Timeouts
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: 'Timing out requests after a certain amount of time can improve the user experience
    in our app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定时间后超时请求可以改善我们应用的用户体验：
- en: 'Let''s add a timeout to our request:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们给我们的请求添加一个超时：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, adding a timeout to an `axios` request is super simple. We just add a `timeout`
    property to the options object with an appropriate number of milliseconds. We
    have specified just 1 millisecond, so that we can hopefully see the request timing
    out.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，向`axios`请求添加超时非常简单。我们只需在选项对象中添加一个`timeout`属性，并设置适当的毫秒数。我们已经指定了1毫秒，这样我们就可以希望看到请求超时。
- en: 'Let''s handle a timeout now in the `catch` method:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`catch`方法中处理超时：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, we check the `code` property in the caught error object in order to determine
    whether a timeout has occurred.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在捕获的错误对象中检查`code`属性，以确定是否发生了超时。
- en: If we look at the running app, we should get confirmation that a timeout has
    occurred with A timeout has occurred displayed in red.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，我们应该得到确认，即已发生超时，并显示为红色的超时已发生。
- en: 'Let''s now change the timeout to something more sensible so that we can move
    on to looking at how we can allow users to cancel requests in the next section:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将超时时间更改为更合理的值，这样我们就可以继续看看如何在下一节中允许用户取消请求：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Canceling requests
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消请求
- en: 'Allowing the user to cancel a request can improve the user experience in our
    app. We''ll do this with the help of `axios` in this section:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户取消请求可以改善我们应用的用户体验。在本节中，我们将借助`axios`来实现这一点：
- en: 'First, we are going to import the `CancelTokenSource` type from `axios`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`axios`中导入`CancelTokenSource`类型：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s add a cancel token and a loading flag to our state:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在状态中添加一个取消令牌和一个加载标志：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s initialize the loading state in the constructor:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在构造函数中初始化加载状态：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've defined the cancel token as optional so we don't need to initialize it
    in the constructor.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将取消令牌定义为可选的，因此我们不需要在构造函数中初始化它。
- en: 'Next, we''ll generate the cancel token source and add it to the state, just
    before we make the `GET` request:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将生成取消令牌源并将其添加到状态中，就在我们进行`GET`请求之前：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can then use the token in the GET request as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在GET请求中使用令牌：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can handle cancellations in the `catch` method as follows. Let''s also set
    the `loading` state to `false`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式在`catch`方法中处理取消。让我们还将`loading`状态设置为`false`：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, we use the `isCancel` function in `axios` to check if the request has been
    canceled.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`axios`中的`isCancel`函数来检查请求是否已被取消。
- en: 'While we are in the `componentDidMount` method, let''s set the `loading` state
    to `false` in the `then` method as well:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在`componentDidMount`方法中时，让我们在`then`方法中将`loading`状态设置为`false`：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `render` method, let''s add a Cancel button, which will allow the user
    to cancel the request:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法中，让我们添加一个取消按钮，允许用户取消请求：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s implement the Cancel button handler that we have just referenced:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现刚刚引用的取消按钮处理程序：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In order to cancel the request, the cancel method is called on the cancel token
    source.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了取消请求，在取消令牌源上调用取消方法。
- en: So, users can now cancel requests by clicking the Cancel button.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，用户现在可以通过点击取消按钮来取消请求。
- en: 'Now, this is going to be hard to test because the REST API we are using is
    really fast! So, in order to see a canceled request, let''s cancel it in the `componentDidMount`
    method immediately after the request is sent:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这将很难测试，因为我们正在使用的REST API非常快！因此，为了看到一个被取消的请求，让我们在`componentDidMount`方法中在请求发送后立即取消它：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we look at the running app, we should see verification that the request was
    cancelled by Request cancelled being displayed in red.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序，我们应该看到请求被取消的验证，显示为红色的“请求已取消”。
- en: So, `axios` makes it really easy to improve our app's user experience by adding
    the ability to cancel requests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`axios`使得通过添加取消请求的能力来改善我们应用的用户体验变得非常容易。
- en: Before we move on to the next section, wherein we look at using `axios` to create
    data, let's remove the line we just added to cancel the request immediately after
    it was made.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一节之前，我们将使用`axios`来创建数据，让我们删除刚刚添加的行，以便在请求后立即取消它。
- en: Creating data with axios
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios创建数据
- en: 'Let''s move on to creating data now. We are going to allow the user to enter
    a post title and body and save it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续创建数据。我们将允许用户输入帖子标题和正文并保存：
- en: 'Let''s first create a new state for the title and body:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先为标题和正文创建一个新的状态：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s initialize this new state as well:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也初始化这个新状态：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ll create an `input` and `textarea` to capture the post title and body
    from the user:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`input`和`textarea`来从用户那里获取帖子的标题和正文：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s implement the change handlers we have just referenced to update the
    state:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现刚刚引用的更改处理程序来更新状态：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can add a bit of CSS in `index.css` to make this all look reasonable:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`index.css`中添加一些CSS来使这一切看起来合理：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can also start work on the save click handler and `POST` the new post to
    the REST API using `axios`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以开始处理保存点击处理程序，并使用`axios`将新帖子`POST`到REST API：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can handle response using the `then` method:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`then`方法处理响应：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So, we concatenate the new post with the existing post to create a new posts
    array for the state.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将新的帖子与现有帖子连接起来，为状态创建一个新的帖子数组。
- en: The structure of the `post` function call is very similar to `get`.  In fact,
    we could add error handling, a timeout, and the ability to cancel the request
    in the same way as we did for `get`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`函数调用的结构与`get`非常相似。实际上，我们可以像对`get`一样添加错误处理、超时和取消请求的能力。'
- en: If we add a new post in the running app and click the Save button, we see it
    added to the bottom of the posts list.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行的应用程序中添加一个新帖子并单击“保存”按钮，我们会看到它添加到帖子列表的底部。
- en: Next up, we will allow users to update posts.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将允许用户更新帖子。
- en: Updating data with axios
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios更新数据
- en: 'Let''s move on to updating data now. We are going to allow the user to click
    an Update button in an existing post to change and save it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续更新数据。我们将允许用户点击现有帖子中的“更新”按钮来更改和保存它：
- en: 'Let''s first create an Update button in each list item in the posts:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在帖子列表中的每个列表项中创建一个“更新”按钮：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can now implement the Update button click handler, which sets the post being
    edited in the component state:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以实现“更新”按钮的点击处理程序，该处理程序将在组件状态中设置正在编辑的帖子：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In our existing save click handler, we need two branches of code now for the
    existing `POST` request and the `PUT` request we need to implement:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们现有的保存点击处理程序中，我们现在需要为现有的`POST`请求和我们需要实现的`PUT`请求编写两个代码分支：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s implement the `PUT` request now:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现`PUT`请求：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, we filter out and concatenate the updated post to create a new posts array
    for the state.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们过滤并连接更新的帖子，为状态创建一个新的帖子数组。
- en: The structure of the `put` function call is very similar to `get` and `post`. 
    Again, we could add error handling, a timeout, and the ability to cancel the request
    in the same way as we did for `get`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`put`函数调用的结构与`get`和`post`非常相似。同样，我们可以添加错误处理、超时和取消请求的能力，就像我们为`get`做的那样。'
- en: In the running app, if we click an Update button in a post, change the title
    and body, and click the Save button, we see it removed from where it was and added
    to the bottom of the posts list with the new title and body.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行的应用程序中，如果我们点击帖子中的“更新”按钮，更改标题和正文，然后点击“保存”按钮，我们会看到它从原来的位置移除，并以新的标题和正文添加到帖子列表的底部。
- en: If we want to `PATCH` a post, we can use the `patch` `axios` method. This has
    the same structure as `put` but instead of passing the whole object that is being
    changed, we can just pass the values that need updating.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要`PATCH`一个帖子，我们可以使用`patch` `axios`方法。这与`put`的结构相同，但是我们可以只传递需要更新的值，而不是传递整个被更改的对象。
- en: In the next section, we will allow users to delete posts.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将允许用户删除帖子。
- en: Deleting data with axios
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios删除数据
- en: 'Let''s move on to deleting data now. We are going to allow the user to click
    a Delete button in an existing post to delete it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续删除数据。我们将允许用户点击现有帖子中的“删除”按钮来删除它：
- en: 'Let''s first create a Delete button in each list item in the posts:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在帖子的每个列表项中创建一个“删除”按钮：
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now create the Delete button click handler:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建删除按钮的点击处理程序：
- en: '[PRE66]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: So, we use the `axios` `delete` method to make an HTTP `DELETE` request, which
    follows the same structure as the other methods.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`axios`的`delete`方法来发出HTTP的`DELETE`请求，其结构与其他方法相同。
- en: If we go to the running app, we should see a delete button in each post. If
    we click one of the buttons, we'll see it removed from the list after a short
    delay.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入运行的应用程序，我们应该在每个帖子中看到一个删除按钮。如果我们点击其中一个按钮，我们会在短暂的延迟后看到它从列表中移除。
- en: So, that concludes this section on `axios` with class components. We've seen
    that the `axios` functions are a little cleaner than `fetch`, and features such
    as the ability to have typed responses, timeouts, and request cancellation make
    it a popular choice for many developers. In the next section, we'll refactor the
    `App` component we have just implemented to be a function component.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就结束了关于使用类组件的`axios`的部分。我们已经看到，`axios`函数比`fetch`更清晰，而且具有诸如有类型的响应、超时和请求取消等功能，使其成为许多开发人员的首选。在下一节中，我们将重构刚刚实现的`App`组件为函数组件。
- en: Using axios with function components
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数组件中使用axios
- en: 'In this section, we''ll implement REST API calls using `axios` in a function
    component. We''ll refactor the `App` component we built in the last section:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在函数组件中使用`axios`实现REST API调用。我们将重构上一节中构建的`App`组件：
- en: 'First, we are going to declare a constant, called `defaultPosts` that is going
    to hold the default posts state we''ll use a little later. We''ll add this after
    the `IPost` interface and set this to an empty array:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将声明一个名为`defaultPosts`的常量，它将保存稍后将使用的默认帖子状态。我们将在`IPost`接口之后添加这个常量，并将其设置为空数组：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We'll remove the `IState` interface because the state will be structured as
    individual pieces of state now.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将删除`IState`接口，因为状态现在将被构造为各个状态片段。
- en: We'll also remove the previous `App` class component.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将删除之前的`App`类组件。
- en: 'Next, let''s start the `App` function component under the `defaultPosts` constant:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`defaultPosts`常量下开始`App`函数组件：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can now create the state for the posts, error, cancel token, loading flag,
    and posts being edited:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为帖子、错误、取消令牌、加载标志和正在编辑的帖子创建状态：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So, we use the `useState` function to define and initialize all these pieces
    of state.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`useState`函数来定义和初始化所有这些状态片段。
- en: 'We want to make the REST API call to get the posts when the component has first
    been mounted. We can use the `useEffect` function, after the lines where the state
    is defined, to do this passing of an empty array as the second parameter:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件首次挂载时，我们希望进行REST API调用以获取帖子。在状态定义的行之后，我们可以使用`useEffect`函数，将空数组作为第二个参数进行这样的操作：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s call the REST API to get the posts in the arrow function:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在箭头函数中调用REST API以获取帖子：
- en: '[PRE71]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s handle the response and set the post-state along with setting the loading
    state to `false`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们处理响应并设置帖子状态，同时将加载状态设置为`false`：
- en: '[PRE72]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s also handle any errors, setting the error state along with the loading
    state to `false`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也处理任何错误，将错误状态与加载状态设置为`false`：
- en: '[PRE73]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can move on to the event handlers now.  These are very similar to the class
    component implementation, with `const` replacing the `private` access modifier,
    as well as `this.state` and `this.setState` being replaced by the specific state
    variables and state setter functions. We''ll start with the Cancel button click
    handler:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续处理事件处理程序了。这些与类组件实现非常相似，只是用`const`替换了`private`访问修饰符，以及用特定的状态变量和状态设置函数替换了`this.state`和`this.setState`。我们将从取消按钮的点击处理程序开始：
- en: '[PRE74]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we can add the change handlers for the title and body inputs:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以为标题和正文输入添加更改处理程序：
- en: '[PRE75]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The Save button click handler is next:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是保存按钮的点击处理程序：
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s do the Update button next:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来让我们来处理更新按钮：
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The last handler is for the Delete button:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个处理程序是用于删除按钮：
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Our final task is to implement the return statement. Again, this is very similar
    to the class component `render` method, with references to `this` removed:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后任务是实现返回语句。同样，这与类组件的`render`方法非常相似，只是去掉了对`this`的引用：
- en: '[PRE79]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: That's it! Our function component that interacts with a REST API is complete.
    If we try this, it should behave exactly as it did before.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们与REST API交互的函数组件已经完成。如果我们尝试这样做，它应该与以前的行为完全一样。
- en: The main difference in terms of REST API interaction is that we use the `useEffect`
    function to make a REST API call to get data that needs to be rendered. We still
    do this when the component has been mounted, like we do in class-based components.
    It's just a different way of tapping into that component life cycle event.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在与REST API交互方面的主要区别在于，我们使用`useEffect`函数来进行REST API调用以获取需要呈现的数据。当组件已挂载时，我们仍然会这样做，就像在基于类的组件中一样。这只是一种不同的方式来利用组件的生命周期事件。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Callback-based asynchronous code can be difficult to read and maintain. Who's
    spent hours trying to track down the root cause of a bug in callback-based asynchronous
    code? Or just spent hours trying to understand what a piece of callback-based asynchronous
    code is trying to do? Thankfully, we now have alternative ways of writing asynchronous code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 基于回调的异步代码可能很难阅读和维护。谁花了几个小时来追踪回调式异步代码中错误的根本原因？或者只是花了几个小时来理解一段回调式异步代码试图做什么？幸运的是，现在我们有了编写异步代码的替代方法。
- en: Promise-based functions are a great improvement over callback-based asynchronous
    code because the code is a lot more readable and errors can be handled more easily.
    The `async` and `await` keywords arguably make reading asynchronous code even
    easier than promised-based function code because it is very close to what the
    synchronous equivalent would look like.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Promise的函数比基于回调的异步代码有了很大的改进，因为代码更易读，错误处理也更容易。`async`和`await`关键字可以说比基于Promise的函数代码更容易阅读异步代码，因为它非常接近同步等效代码的样子。
- en: Modern browsers have a nice function called `fetch` for interacting with REST
    APIs. This is a promised-based function allowing us to easily make a request and
    nicely manage the response.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器有一个名为`fetch`的很好的函数，用于与REST API进行交互。这是一个基于Promise的函数，允许我们轻松地发出请求并很好地管理响应。
- en: '`axios` is a popular alternative to `fetch`. The API is arguably cleaner and
    allows us to better handle HTTP error codes. Timeouts and canceling requests are
    also made very simple using `axios`. `axios` is also TypeScript-friendly, having
    types baked into the library. Having played with both `axios` and `fetch`, which
    is your favorite?'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios`是`fetch`的一种流行替代品。该API可以说更清晰，并且允许我们更好地处理HTTP错误代码。使用`axios`也可以非常简单地处理超时和取消请求。`axios`也非常友好于TypeScript，因为类型已经内置到库中。在使用过`axios`和`fetch`之后，你更喜欢哪一个？'
- en: We can interact with REST APIs in both class- and function-based components.
    When calling a REST API to get data to display in a first component render, we
    need to wait until just after the component has been mounted. In class components,
    we do this using the `componentDidMount` life cycle method. In function components,
    we do this using the `useEffect` function, passing an empty array as the second
    parameter. Having experienced interacting with REST APIs in both types of components,
    which component type are you going to use on your next React and TypeScript project?
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类组件和函数组件中与REST API进行交互。当调用REST API以获取数据以在第一个组件渲染中显示时，我们需要等到组件挂载后。在类组件中，我们使用`componentDidMount`生命周期方法来实现这一点。在函数组件中，我们使用`useEffect`函数，将空数组作为第二个参数传递。在两种类型的组件中都有与REST
    API交互的经验后，你会在下一个React和TypeScript项目中使用哪种组件类型？
- en: REST APIs aren't the only type of API we are likely going to need to interact
    with. GraphQL is a popular alternative API server. We'll learn how we can interact
    with GraphQL servers in the next chapter.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: REST API并不是我们可能需要交互的唯一类型的API。GraphQL是一种流行的替代API服务器。我们将在下一章学习如何与GraphQL服务器交互。
- en: Questions
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let''s answer the following questions to help our knowledge of what we have
    just learned stick:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回答以下问题，以帮助我们对刚学到的知识有更深刻的理解：
- en: What will the output be in the console if we ran the following code in a browser?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行以下代码，控制台会输出什么？
- en: '[PRE80]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Assuming that post `9999` doesn't exist, what would be the output in the console
    if we ran the following code in a browser?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设帖子`9999`不存在，如果我们在浏览器中运行以下代码，控制台会输出什么？
- en: '[PRE81]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If we did a similar exercise with `axios`, what would be the output in the console
    when running the following code?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们用`axios`做类似的练习，当运行以下代码时，控制台会输出什么？
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What is the benefit of using the native `fetch` over `axios`?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原生的`fetch`而不是`axios`有什么好处？
- en: How can we add a bearer token to the following `axios` request?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在以下`axios`请求中添加一个Bearer令牌？
- en: '[PRE83]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We are using the following `axios` `PUT` request to update a post title?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用以下`axios`的`PUT`请求来更新帖子标题？
- en: '[PRE84]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The body hasn't changed though—it's just the title we want to update. How can
    we change this to a `PATCH` request to make this REST call more efficient?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管身体没有改变，但我们只是想要更新标题。我们如何将这个转换为`PATCH`请求，以使这个REST调用更有效？
- en: We have implemented a function component to display a post. It uses the following
    code to get the post from a REST API?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经实现了一个函数组件来显示一个帖子。它使用以下代码从REST API获取帖子？
- en: '[PRE85]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: What is wrong with the preceding code?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有什么问题？
- en: Further reading
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links are good resources for further information on the topics
    we have covered in this chapter:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是本章涵盖的主题的进一步信息的好资源：
- en: More information about promises can be found at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 promises 的更多信息可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
    找到
- en: Additional information about `async` and `await` is at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `async` 和 `await` 的其他信息可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    找到
- en: More information about the `fetch` function can be found at [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `fetch` 函数的更多信息可以在 [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
    找到
- en: The `axios` GitHub page is at [https://github.com/axios/axios](https://github.com/axios/axios)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axios` 的 GitHub 页面在 [https://github.com/axios/axios](https://github.com/axios/axios)
    上'
