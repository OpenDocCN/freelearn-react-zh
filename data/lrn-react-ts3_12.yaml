- en: Answers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Chapter 1: TypeScript Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：TypeScript基础知识
- en: What are the five primitive types?
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪五种原始类型？
- en: '`string`: Represents a sequence of Unicode characters'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：表示Unicode字符序列'
- en: '`number`: Represents both integers and floating-point numbers'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`：表示整数和浮点数'
- en: '`boolean`: Represents a logical true or false'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`：表示逻辑真或假'
- en: '`undefined`: Represents a value that hasn''t been initialized yet'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`：表示尚未初始化的值'
- en: '`null`: Represents no value'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`：表示没有值'
- en: What will the inferred type be for the `flag`variable be in the following code?
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`flag`变量的推断类型将是什么？
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`flag` will be inferred as the `boolean` type.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag`将被推断为`boolean`类型。'
- en: What's the difference between an interface and a type alias?
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口和类型别名之间有什么区别？
- en: The main difference is that type aliases can't be extended or implemented from,
    like you can with interfaces.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于类型别名不能被扩展或实现，就像你可以使用接口一样。
- en: What is wrong with the following code?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是代码中的问题？
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The constructor requires `name` and `unitPrice` to be passed. Here are two ways
    to resolve the problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要传递`name`和`unitPrice`。以下是解决问题的两种方法。
- en: 'Pass the values in the constructor:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中传递值：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make the parameters optional:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使参数可选：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we want our TypeScript program to support IE11, what should the `--target` compiler
    option be?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们希望我们的TypeScript程序支持IE11，`--target`编译器选项应该是什么？
- en: This should be `es5` because IE11 only supports up to ES5 features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是`es5`，因为IE11只支持ES5功能。
- en: Is it possible to get the TypeScript compiler to transpile ES6 JavaScript files?
    If so, how?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可能让TypeScript编译器转译ES6 JavaScript文件？如果可以，怎么做？
- en: Yes! We can use the `--allowJS` setting to get the compiler to transpile JavaScript
    files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们可以使用`--allowJS`设置来让编译器转译JavaScript文件。
- en: How can we prevent`console.log()`statements from getting into our code?
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何防止`console.log()`语句进入我们的代码？
- en: 'We can use tslint and the `"no-console"` rule to enforce this. This would be
    the rule in `tslint.json`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用tslint和`"no-console"`规则来强制执行。这将是`tslint.json`中的规则：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Chapter 2: What is New in TypeScript 3
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：TypeScript 3中的新功能
- en: 'We have the following function that draws a point:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个绘制点的函数：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also have the following `point`variable:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下`point`变量：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How can we call the `drawPoint` function in a terse manner?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以简洁的方式调用`drawPoint`函数？
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to create another version of the `drawPoint` function that can call
    by passing the x, y, and z point values as parameters:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建`drawPoint`函数的另一个版本，可以通过传递x、y和z点值来调用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Internally in the implementation of `drawPoint` we draw the point from a tuple
    data type, `[number, number, number]`. How can we define the method parameter(s)
    with the required tuple?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawPoint`的实现内部，我们从元组数据类型`[number, number, number]`中绘制点。如何定义具有所需元组的方法参数？
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In your implementation of `drawPoint`, how can you make the `z` point optional?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`drawPoint`实现中，如何使`z`点可选？
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have a function called `getData` that calls a web API to get some data. The
    number of different API resources is still growing, so we''ve chosen to use `any` as
    the return type:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个名为`getData`的函数，调用Web API获取一些数据。不同的API资源数量仍在增长，所以我们选择使用`any`作为返回类型：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How can we make `getData`more type-safe by leveraging the `unknown` type?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过利用`unknown`类型使`getData`更加类型安全？
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What `build` flag can we use to determine which projects are out of date and
    need to be rebuilt without doing a rebuild?
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个`build`标志来确定哪些项目已过时并需要重建，而无需进行重建？
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Chapter 3:  Getting Started with React and TypeScript
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用React和TypeScript入门
- en: During development, what are the `TSLint` settings for allowing debugger statements
    and logging to the console?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发过程中，允许调试器语句和记录到控制台的`TSLint`设置是什么？
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In JSX, how can we display a button with a label from a prop called `buttonLabel`
    in a class component?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX中，如何在类组件中显示一个名为`buttonLabel`的prop的按钮标签？
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How can we make the `buttonLabel` prop optional and default to Do It?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使`buttonLabel`属性可选并默认为Do It？
- en: 'Use a `?` before the type annotation in the interface for the props:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口的类型注释之前使用`?`：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement a static `defaultProps` object at the top of the class component:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件的顶部实现一个静态`defaultProps`对象：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In JSX, how can we display the preceding button only if the state called `doItVisible`
    is true? Assume we already have a state type declared containing `doItVisible`
    and it has already been initialized in the constructor
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX中，如果名为`doItVisible`的状态为true，我们如何只显示前面的按钮？假设我们已经声明了一个包含`doItVisible`的状态类型，并且它已经在构造函数中初始化了。
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How would we create a click handler for this button?
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为这个按钮创建一个点击处理程序？
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have a state type declared containing `doItDisabled`. It has also been initialized
    in the constructor. How would we set this state to disable the Do it button after
    we click it?
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个包含`doItDisabled`的状态类型。它也在构造函数中初始化了。我们如何在点击后将此状态设置为禁用“Do it”按钮？
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the button is clicked when it is disabled, is the click handler still be
    invoked?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按钮被禁用后被点击，点击处理程序仍然会被调用吗？
- en: 'No'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不
- en: Which life cycle method would be used in a class component to add event handlers
    to a none React web component that lives in our React component?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类组件中，哪个生命周期方法会被用来给我们的React组件中的非React web组件添加事件处理程序？
- en: '`componentDidMount`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount`'
- en: Which life cycle method would we then use to remove this event handler?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们会使用哪个生命周期方法来移除这个事件处理程序？
- en: '`componentWillUnmount`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`'
- en: We have a function component called `Counter`. It needs to contain a piece of
    state called `count` and a function to update it called `setCount`. How can we
    define this state and default the initial count to 10?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个名为`Counter`的函数组件。它需要包含一个名为`count`的状态和一个名为`setCount`的更新函数。我们如何定义这个状态并将初始计数默认为10？
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding `Counter` component, we have a `decrement` function that needs
    to reduce `count` by 1:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的`Counter`组件中，我们有一个`decrement`函数，需要将`count`减1：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How can this be implemented?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如何实现？
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Chapter 4: Routing with React Router
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用React Router进行路由
- en: 'We have the following `Route` that shows a list of customers:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下显示客户列表的`Route`：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Will the `CustomersPage` component render when the page is `"/customers"`?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面是`"/customers"`时，`CustomersPage`组件会被渲染吗？
- en: 'Yes'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: Will the `CustomersPage` component render when the page is `"/customers/24322"`?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面是`"/customers/24322"`时，`CustomersPage`组件会被渲染吗？
- en: 'Yes'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: We only want the `CustomersPage` component to render when the path is `"/customers"`.
    How can we change the attributes on `Route` to achieve this?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只希望当路径是`"/customers"`时才渲染`CustomersPage`组件。我们如何改变`Route`上的属性来实现这一点？
- en: 'We can use the `exact` attribute:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`exact`属性：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What would be the `Route` that could handle the path `"/customers/24322"`?
    It should put `"24322"` in a route parameter called `customerId`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么样的`Route`可以处理路径`"/customers/24322"`？它应该将`"24322"`放在名为`customerId`的路由参数中：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can then use `RouteComponentProps` as the `CustomerPage` props type and get
    access to `customerId` via `props.match.params.``customerId`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以将`RouteComponentProps`作为`CustomerPage`的props类型，并通过`props.match.params.customerId`访问`customerId`。
- en: How can we catch paths that don't exist so that we can inform the user?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何捕获不存在的路径，以便通知用户？
- en: 'Make sure all the `Route` components are wrapped in a `Switch` component. We
    can then add a `Route` to a component that renders a not found message to the
    user as the last `Route` in Switch:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有的`Route`组件都包裹在一个`Switch`组件中。然后我们可以在Switch中添加一个渲染给用户一个未找到消息的组件作为最后一个`Route`：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How would we implement a `search` query parameter in `CustomersPage`? So, `"/customers/?search=Cool
    Company"` would show customers the name Cool Company.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在`CustomersPage`中实现一个`search`查询参数？因此，`"/customers/?search=Cool Company"`将显示名称为Cool
    Company的客户。
- en: 'First we need the props type to be `RouteComponentProps` in our class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的类中将props类型设置为`RouteComponentProps`：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can the use `URLSearchParams` to get the `search` query parameter and do
    the search in the `componentDidMount` life cycle method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`URLSearchParams`来获取`search`查询参数，并在`componentDidMount`生命周期方法中进行搜索：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After a while we decide to change the `"customer"` paths to `"clients"`. How
    can we implement this so that users can still use the existing `"customer"` paths
    but have the paths automatically redirect to the new `"client"` paths.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过了一会儿，我们决定将`"customer"`路径更改为`"clients"`。我们如何实现这一点，以便用户仍然可以使用现有的`"customer"`路径，但路径会自动重定向到新的`"client"`路径。
- en: 'We can use the `Redirect` component to redirect the old paths to the new paths:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Redirect`组件将旧路径重定向到新路径：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Chapter 5: Advanced Types
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：高级类型
- en: 'We have an interface that represents a course result as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个表示课程结果的接口如下：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use this interface as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用这个接口：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The grades can only be A, B, C, or D. How can we create a stronger typed version
    of the `grade` property in this interface?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 成绩只能是A、B、C或D。我们如何在这个接口的`grade`属性中创建一个更强类型的版本？
- en: 'We can use a union type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用联合类型：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have the following functions, which validate that numbers and strings are
    populated with a value:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下函数，用于验证数字和字符串是否具有值：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How can we combine these into a single function called `isPopulated` with signature
    overloads?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这些组合成一个名为`isPopulated`的单一函数，带有签名重载？
- en: 'We can use overload signatures and then a union type for `field` in the main
    function. We can then use the `typeof` type guard in the function to deal with
    the different branches of logic:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在主函数中使用重载签名，然后使用联合类型来处理`field`的不同分支逻辑：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How can we implement a more flexible version of the `isPopulated` function with
    generics?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用泛型实现一个更灵活的`isPopulated`函数版本？
- en: 'We can use a generic function with a `typeof` type guard for the special branch
    of code for strings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有`typeof`类型保护的通用函数来处理字符串的特殊代码分支：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have the follow type alias of stages:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个名为stages的类型别名：
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How can we programmatically turn this into the union type `'Pending' | 'Started'
    | 'Completed'`?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以编程方式将其转换为联合类型`'Pending' | 'Started' | 'Completed'`？
- en: 'We can use the `keyof` keyword:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`keyof`关键字：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have the following union type:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下联合类型：
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How can we programmatically create the following type?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以编程方式创建以下类型？
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can map the type as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式映射类型：
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Chapter 6: Component Patterns
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：组件模式
- en: What special property does React give us to access a components children?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React给我们提供了什么特殊属性来访问组件的子元素？
- en: A property called `children`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`children`的属性
- en: How many components can share state with React context?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少个组件可以共享React上下文的状态？
- en: As many components as we like that are under the provider component in the component hierarchy
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件层次结构中提供者组件下，我们可以有多少个组件？
- en: When consuming the React context, what pattern does it use to allow us to render
    our content with the context?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消费React上下文时，它使用什么模式允许我们使用上下文渲染我们的内容？
- en: The render props pattern
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染props模式
- en: How many render props can we have in a component?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件中可以有多少个渲染props？
- en: As many as we like
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多
- en: How many children props do we have in a component?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件中有多少个子元素props？
- en: '1'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'We only used `withLoader` on the product page. We have the following function
    in `ProductData.ts` to get all the products:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只在产品页面上使用了`withLoader`。我们在`ProductData.ts`中有以下函数来获取所有产品：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Can you use this to implement a loader spinner on the products page by consuming
    the `withLoader` HOC.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您能使用这个来通过使用“withLoader”HOC在产品页面上实现一个加载器旋转器吗？
- en: 'First we split `ProductPage` into a container and presentational component.
    The presentational component will render the product list exporting it wrapped
    in the `withLoader` HOC:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将“ProductPage”分成一个容器和一个展示组件。 展示组件将渲染产品列表，并将其导出为包裹在“withLoader”HOC中的组件：
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then can consume this in `ProductPage` as follows in its `render` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在“ProductPage”中使用它，如其“render”方法中所示：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Is it possible to create a loader spinner using the children props pattern?
    So, the consuming JSX would be something like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可能使用children props模式创建一个加载器旋转器？ 因此，消费JSX将类似于这样：
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If so, have a go at implementing it?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以的话，试着实现一下？
- en: 'Yes'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Chapter 7:  Working with Forms
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章：处理表单
- en: Extend our generic `Field` component to include a number editor using the native
    number input.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展我们的通用“Field”组件，使用原生数字输入包括一个数字编辑器。
- en: 'Firstly, add `"Number"` to the `type` prop:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在“type”属性中添加“Number”：
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Include the `"Number"` type when rendering the `input`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染“input”时包括“Number”类型：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implement an urgency field on the Contact Us form to indicate how urgent a response
    is. The field should be numeric.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“联系我们”表单上实现一个紧急性字段，以指示回复的紧急程度。 该字段应为数字。
- en: 'Add the following field immediately after the notes field:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在notes字段之后立即添加以下字段：
- en: '[PRE51]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Implement a new validator function in the generic `Form` component, that validates
    a number is between two other numbers.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通用“Form”组件中实现一个新的验证函数，验证一个数字是否在另外两个数字之间。
- en: 'Add the following function in `Form.tsx`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Form.tsx”中添加以下函数：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Implement a validation rule on the urgency field to ensure it is between 1 and
    10.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个紧急性字段的验证规则，以确保它在1到10之间。
- en: 'Firstly import the `between` validator into `ContactUs.tsx`:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先在“ContactUs.tsx”中导入“between”验证器：
- en: '[PRE53]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the rule on urgency in the `validationRules` prop in `ContactUs.tsx`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“ContactUs.tsx”中的“validationRules”属性中添加紧急性规则：
- en: '[PRE54]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our validation triggers when a users clicks in and out of a field without typing
    anything. How can we just trigger validation, still when a field loses focus but
    only when it has been changed? Have a go at an implementation for this.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在不输入任何内容的情况下点击并离开字段时，我们的验证会触发。 我们如何才能触发验证，当字段失去焦点但只有在它被更改时？ 尝试实现一下这个。
- en: 'We need to track whether a field has been touched in the form state:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要跟踪表单状态中的字段是否被触摸：
- en: '[PRE55]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We initialize the `touched` values for each field to `false` in the constructor:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在构造函数中将每个字段的“touched”值初始化为“false”：
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the `setValue` method, we update the `touched` value to `true` for the field
    being updated:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“setValue”方法中，我们更新正在更新的字段的“touched”值为“true”：
- en: '[PRE58]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the top of the validate method, we check whether the field has been touched
    and if not, we return an empty array to indicate the field is valid:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在validate方法的顶部，我们检查字段是否被触摸，如果没有，我们返回一个空数组来指示字段是有效的：
- en: '[PRE59]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Chapter 8: React Redux
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章：React Redux
- en: Is the `type` property in action objects required? And does this property need
    to be called `type`? Can we call it something else?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作对象中的“type”属性是必需的吗？ 这个属性需要被称为“type”吗？ 我们可以称它为其他名称吗？
- en: The `type` property is required in the action objects and must be called `type`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 操作对象中“type”属性是必需的，并且必须称为“type”。
- en: How many properties can the action object contain?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作对象可以包含多少属性？
- en: As many as we like! It needs to include at least one for the `type` property.
    It can then include as many other properties as we need in order for the reducer
    to change the state but this is generally lumped in one additional property. So,
    generally an action will have one or two properties.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有很多！它需要至少包括一个`type`属性。然后可以包括我们需要的其他属性，以便减少状态的改变，但这通常被合并在一个额外的属性中。因此，通常一个动作会有一个或两个属性。
- en: What is an action creator?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是动作创建者？
- en: An action creator is a function that returns an action object. Components invoke
    these functions in order to make a change to the state in the store.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者是返回动作对象的函数。组件调用这些函数以改变存储中的状态。
- en: Why did we need Redux Thunk in our Redux store in our React shop app?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在React商店应用程序的Redux存储中需要Redux Thunk？
- en: By default, a Redux store can't manage asynchronous action creators. Middleware
    needs to be added to the Redux store in order to facilitate asynchronous action
    creators. Redux Thunk is the middleware we added to do this.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Redux存储无法管理异步动作创建者。需要向Redux存储添加中间件以便促进异步动作创建者。Redux Thunk是我们添加的中间件来实现这一点。
- en: Could we have used something else other than Redux Thunk?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了Redux Thunk之外，我们还能用其他东西吗？
- en: Yes! We could have created our own middleware. There are other well-established
    libraries that we could have used as well, such as Redux Saga.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们可以创建自己的中间件。还有其他成熟的库，比如Redux Saga，我们也可以使用。
- en: In our `basketReducer` we have just implemented, why didn't we just use the `push` function
    to add the item to the basket state? What is wrong with the highlighted line?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们刚刚实现的`basketReducer`中，为什么我们不直接使用`push`函数将项目添加到篮子状态中？高亮显示的行有什么问题？
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This mutates the product's state directly and makes the function impure. This
    is because we have changed the state argument, which lives outside the scope of
    our function. Breaking this rule, in this case, results in the basket summary
    not incrementing on the rendered page when the Add to basket button is clicked.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接改变了产品的状态，并使函数变得不纯。这是因为我们改变了状态参数，它存在于函数范围之外。在这种情况下违反了这个规则，导致当单击“添加到篮子”按钮时，篮子摘要在渲染页面上不会增加。
- en: Chapter 9: Interacting with RESTful APIs
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：与RESTful API交互
- en: What will the output be in the console if we run the following code in a browser?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行以下代码，控制台会输出什么？
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We'd get a message saying that an uncaught error (Oops) has occurred. `The console.log` statement
    wouldn't be reached.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会收到一条消息，说发生了一个未捕获的错误（Oops）。`console.log`语句将不会被执行。
- en: 'Assuming that post 9999 doesn''t exist, what would be the output in the console if
    we ran the following code in a browser:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设帖子9999不存在，如果我们在浏览器中运行以下代码，控制台会输出什么：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![](assets/5e6e8f9f-dbfa-40f8-927c-05b97d901a61.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/5e6e8f9f-dbfa-40f8-927c-05b97d901a61.png)
- en: The key thing is that an HTTP error doesn't get handled in the `catch` method
    with the `fetch` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，使用`fetch`函数时，HTTP错误不会在`catch`方法中处理。
- en: If we did a similar exercise with `axios`, what would be the output in the console
    when running the following code?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`axios`进行类似的练习，运行以下代码时控制台会输出什么？
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![](assets/3d06e29a-9e9a-45e6-82e9-dcdaa2d86a29.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/3d06e29a-9e9a-45e6-82e9-dcdaa2d86a29.png)
- en: The key thing is that an HTTP error does get handled in the `catch` method with
     `axios`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，HTTP错误确实在`catch`方法中使用`axios`处理。
- en: What is a benefit of using the native `fetch` over `axios`?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本机`fetch`而不是`axios`的好处是什么？
- en: If we are targeting modern browsers (and not IE) and only require simple REST
    API interaction then `fetch` is arguably more favorable than `axios` because our
    code isn't dependent on third-party code.  It will also probably run a little
    faster because there is less non-native code being executed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是现代浏览器（而不是IE），并且只需要简单的REST API交互，那么`fetch`可能比`axios`更受欢迎，因为我们的代码不依赖于第三方代码。它也可能运行得更快，因为执行的非本地代码更少。
- en: How can we add a bearer token to the following `axios` request?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在以下`axios`请求中添加一个Bearer令牌？
- en: '[PRE65]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The second parameter is an object literal that has a `header` property that
    can contain HTTP headers for the request:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是一个对象文字，其中有一个`header`属性，可以包含请求的HTTP标头：
- en: '[PRE66]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We are using the following `axios` `PUT` request to update a post title:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用以下`axios`的`PUT`请求来更新帖子标题：
- en: '[PRE67]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The body hasn't changed though – it's just the title we want to update. How
    can we change this to a `PATCH` request to make this REST call more efficient?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管主体没有改变 - 我们只是想要更新标题。我们如何将其更改为`PATCH`请求，以使此REST调用更有效？
- en: '[PRE68]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We have implemented a function component to display a post. It uses the following
    code to get the post from a REST API:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经实现了一个函数组件来显示一个帖子。它使用以下代码从REST API获取帖子：
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: What is wrong with the preceding code?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有什么问题？
- en: 'The second parameter in the `useEffect` function is missing, which means the
    REST API will be called every time the component is rendered. An empty array should
    be supplied as the second parameter so that the REST API is only called on the
    first render:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`函数的第二个参数丢失，这意味着每次组件呈现时都会调用REST API。应该提供一个空数组作为第二个参数，以便REST API仅在第一次呈现时被调用：'
- en: '[PRE70]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Chapter 10: Interacting with GraphQL APIs
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：与GraphQL API交互
- en: 'In the GitHub GraphQL Explorer, create a query to return the last five open
    issues in the React project. Return the issue title and the URL in the response:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub GraphQL Explorer中，创建一个查询，返回React项目中最后五个未解决的问题。在响应中返回问题标题和URL：
- en: '[PRE71]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Enhance the last query, make the number of issues that is returned a parameter,
    and make this default to 5:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强最后一个查询，使返回的问题数量成为一个参数，并将其默认值设置为5：
- en: '[PRE72]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a mutation in the GitHub GraphQL Explorer to unstar a starred repository.
    The mutation should take a repository ID as a parameter:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub GraphQL Explorer中创建一个突变，取消对一个星标存储库的标记。该突变应该将存储库ID作为参数：
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: What part of the HTTP request does the GraphQL query go in?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL查询放在HTTP请求的哪一部分？
- en: The HTTP body
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP主体
- en: What part of the HTTP request does the GraphQL mutation go in?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL突变放在HTTP请求的哪一部分？
- en: The HTTP body
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP主体
- en: How can we make the response from the `react-apollo` `Query` component type
    safe?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使来自`react-apollo`的`Query`组件的响应类型安全？
- en: 'Create another component that extends `Query` passing in a type for the result
    as a generic parameter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个组件，扩展`Query`，将结果的类型作为泛型参数传入：
- en: '[PRE74]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We can then use the `MyQuery` component in our JSX.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在JSX中使用`MyQuery`组件。
- en: Is caching on or off by default when you scaffold a project with `react-boost`?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`react-boost`脚手架项目时，默认情况下是否启用缓存？
- en: 'On'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 开启
- en: What prop can we use on the `Mutation` component to update the local cache?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`Mutation`组件上使用哪个属性来更新本地缓存？
- en: The `update` prop.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`属性。'
- en: Chapter 11: Unit Testing with Jest
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：使用Jest进行单元测试
- en: Let's say we are implementing a Jest test and we have a variable called `result`, which
    we want to check isn't `null`. How can we do this with Jest matcher functions?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们正在实现一个Jest测试，并且有一个名为`result`的变量，我们想检查它不是`null`。我们如何使用Jest匹配器函数来实现这一点？
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s say we have variable called `person` that is of type `IPerson`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`person`的变量，类型为`IPerson`：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We want to check that the `person` variable is `{ id: 1, name: "bob" }`. How
    can we do this with Jest matcher functions?'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '我们想要检查`person`变量是否为`{ id: 1, name: "bob" }`。我们如何使用Jest匹配器函数来实现这一点？'
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Is it possible to carry out our check in the last question with a Jest snapshot
    test? If so how?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一题中，我们是否可以通过Jest快照测试来进行我们的检查？如果可以，如何进行？
- en: 'Yes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 是的：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We have implemented a component called `CheckList`, which renders text from
    an array in a list. Each list item has a checkbox so that the user can select
    list items. The component has a function prop called `onItemSelect` that is called
    when a user selects an item by checking the checkbox. We are implementing a test
    to verify that the `onItemSelect` prop works. The following line of code renders
    the component in the test:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个名为`CheckList`的组件，它从数组中以列表的形式呈现文本。每个列表项都有一个复选框，以便用户可以选择列表项。该组件有一个名为`onItemSelect`的函数prop，当用户通过选中复选框选择项目时会调用该函数。我们正在实施一个测试来验证`onItemSelect`prop是否起作用。以下代码行在测试中呈现组件：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How can we use a Jest mock function for `handleListItemSelect` and check that
    it is called?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用Jest模拟函数来检查`handleListItemSelect`是否被调用？
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the implementation of `SimpleList` in the last question, the `onItemSelect` function
    takes in a parameter called `item` which is the `string` value that the user has
    selected. In our test, let's pretend we have already simulated the user selecting
    `"Banana"` . How can we check the `onItemSelect` function was called with the
    item parameter being `"Banana"`?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一题中的`SimpleList`的实现中，`onItemSelect`函数接受一个名为`item`的参数，这是用户选择的`string`值。在我们的测试中，假设我们已经模拟用户选择了`"Banana"`。我们如何检查`onItemSelect`函数是否被调用，并且参数为`"Banana"`？
- en: '[PRE81]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the implementation of `SimpleList` in the last two questions, the text is
    displayed using a label that is tied to the checkbox is using the `for` attribute.
    How can we use functions in React Testing Library to firstly locate the `"Banana"`
    checkbox and then check it?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上两题中的`SimpleList`的实现中，文本是使用与复选框绑定的标签显示的，使用了`for`属性。我们如何使用React Testing Library中的函数来首先定位`"Banana"`复选框，然后对其进行检查？
- en: '[PRE82]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In this chapter, we found out the coverage was low in our code that rendered
    posts from the JSONPlaceholder REST API. One of the areas that wasn''t covered
    was handling HTTP error codes in the `componentDidMount` function when we get
    the posts from the REST API. Create a test to cover this area of code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，我们发现从JSONPlaceholder REST API渲染帖子的代码覆盖率很低。其中一个未覆盖的领域是在从REST API获取帖子时，在`componentDidMount`函数中处理HTTP错误代码。创建一个测试来覆盖这部分代码：
- en: '[PRE83]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A test ID needs to be added to the `App` component code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 需要向`App`组件代码添加一个测试ID：
- en: '[PRE84]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
