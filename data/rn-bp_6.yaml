- en: Messaging App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息应用
- en: One-to-one communication is the main use for mobile phones although, text messaging
    has been quickly replaced by direct messaging apps. In this chapter, we will build
    a messaging app in React Native with the support of Firebase, a mobile backend
    as a service that will free us from having to build a whole backend for our app.
    Instead, we will focus on handling the state of our app fully from the frontend.
    Of course, this may have security implications that need to be eventually tackled,
    but to keep the focus of this book on React Native's capabilities, we will stick
    with the approach of keeping all the logic inside our app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一通信是手机的主要用途，尽管短信已经很快被直接消息应用所取代。在本章中，我们将使用React Native和Firebase构建一个消息应用，Firebase是一个移动后端服务，可以使我们摆脱为应用构建整个后端的工作。相反，我们将专注于完全从前端处理应用的状态。当然，这可能会有安全方面的影响，需要最终解决，但为了保持本书对React
    Native功能的关注，我们将坚持在应用内部保留所有逻辑的方法。
- en: Firebase is a real-time database built on self-synching collections of data,
    it plays very well with MobX, so we will use it again for controlling the state
    of our app. But in this chapter, we will dive deeper as we will build larger data
    stores, which will be injected in our component tree through the `mobx-react`
    connectors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一个建立在自同步数据集合上的实时数据库，它与MobX非常搭配，所以我们将再次使用它来控制应用的状态。但在本章中，我们将更深入地挖掘，因为我们将构建更大的数据存储，这些数据将通过`mobx-react`连接器注入到我们的组件树中。
- en: We will build the app to be used both with iOS and Android having some platform-specific
    code for navigation (we will use tabbed navigation for iOS and drawer navigation
    for Android).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建该应用，使其可以在iOS和Android上使用，为导航编写一些特定于平台的代码（我们将在iOS上使用选项卡导航，在Android上使用抽屉导航）。
- en: To reduce the size of the code, in this chapter, we will set the focus on functionality
    rather than design. Most of the user interface will be plain and simple, but trying
    to keep usability in mind. Moreover, we will use a `react-native-gifted` chat
    for our chat screen--a pre-built React Native component to render chat rooms based
    on a list of messages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少代码的大小，在本章中，我们将专注于功能而不是设计。大部分用户界面将是简单明了的，但我们会尽量考虑可用性。此外，我们将在我们的聊天屏幕上使用`react-native-gifted`
    chat--一个预先构建的React Native组件，用于根据消息列表渲染聊天室。
- en: Overview
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: A messaging app requires more work than the apps we reviewed in previous chapters,
    as it needs a user management system comprising of logging in, registering, and
    logging out. We will reduce the complexity of building this system using Firebase
    as a backend. Together with its user management system, we will use their push
    notifications system to notify users when new messages are sent to them. Firebase
    also gives an analytics platform, a lambda functions service, and a storage system
    for free, but the feature we will take the most profit from is their real-time
    database. We will store our user's profile, messages, and chats data there.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 消息应用需要比我们在前几章中审查的应用更多的工作，因为它需要一个用户管理系统，包括登录、注册和退出登录。我们将使用Firebase作为后端来减少构建此系统的复杂性。除了用户管理系统，我们还将使用他们的推送通知系统，在新消息发送给用户时通知用户。Firebase还提供了分析平台、lambda函数服务和免费的存储系统，但我们将从中获益最多的功能是他们的实时数据库。我们将在那里存储用户的个人资料、消息和聊天数据。
- en: 'Let''s take a look at what our app will look like to have a mental image of
    the screens we will be building:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的应用将会是什么样子，以便心中有个印象，我们将要构建的屏幕：
- en: '![](Images/7328e6c2-0078-4b7b-bcfa-e96e749a29da.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7328e6c2-0078-4b7b-bcfa-e96e749a29da.png)'
- en: 'First screen will be a login/registration screen because we need our users
    to provide a name and some credentials to attach their device to a specific account,
    so they can receive push notifications for each message they need to receive.
    Both authentication methods are validated using Firebase''s API and would result
    in the chats screen when they are successful:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕将是登录/注册屏幕，因为我们需要用户提供姓名和一些凭据，以将他们的设备连接到特定帐户，这样他们就可以接收每条消息的推送通知。这两种身份验证方法都使用Firebase的API进行验证，成功后将显示聊天屏幕：
- en: '![](Images/a525bb6f-9022-4004-b99a-c726f0fc082f.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a525bb6f-9022-4004-b99a-c726f0fc082f.png)'
- en: 'When pressing a contact in the contacts list, the app will display the conversation
    with the selected contact in the chat screen:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在联系人列表中按下一个联系人时，应用程序将在聊天屏幕中显示与所选联系人的对话：
- en: '![](Images/9729a17b-e713-482a-a9b8-4cc6c7d19af1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9729a17b-e713-482a-a9b8-4cc6c7d19af1.png)'
- en: 'The chats screen will show up all the chats that were started for the logged
    in user. Initially, this screen will be empty as the user won''t have initiated
    any chats. To start a conversation, the user should go to the search screen in
    order to find some contacts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天屏幕将显示所有为登录用户启动的聊天。最初，这个屏幕将是空的，因为用户还没有开始任何聊天。要开始对话，用户应该去搜索屏幕以找到一些联系人：
- en: '![](Images/0385f83f-b196-44dd-9543-92b74b2b9eb5.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0385f83f-b196-44dd-9543-92b74b2b9eb5.png)'
- en: This is a simple screen where the user can enter the contact name to search
    for it in the database. If there is a match on the name of the contact; the user
    will be able to tap on it to get the conversation started. From that point on,
    the conversation will show in the chat screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的屏幕，用户可以在其中输入联系人姓名以在数据库中搜索。如果联系人的姓名匹配，用户将能够点击它开始对话。从那时起，对话将显示在聊天屏幕中。
- en: 'The last screen is the profile screen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个屏幕是个人资料屏幕：
- en: '![](Images/5e03b5e4-8945-4c4e-bcb1-087c85575919.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5e03b5e4-8945-4c4e-bcb1-087c85575919.png)'
- en: This screen is just a mean to log the current user out. When extending the app,
    we could add more features such as changing the avatar or the username.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕只是用来注销当前用户的。在扩展应用程序时，我们可以添加更多功能，比如更改头像或用户名。
- en: 'While the app will look very similar on Android, navigation will be replaced
    by a drawer from which all the screens will be available. Let''s take a look at
    the Android version:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安卓上的应用程序看起来非常相似，但导航将被抽屉取代，从抽屉中可以访问所有屏幕。让我们来看看安卓版本：
- en: '![](Images/c9a8db8a-c522-493e-9c1b-d5adeb8a31f3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c9a8db8a-c522-493e-9c1b-d5adeb8a31f3.png)'
- en: 'The login/registration screen has standard text input and button components
    for Android:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 登录/注册屏幕具有标准的文本输入和按钮组件用于安卓：
- en: '![](Images/c3032531-f6b3-4b07-b0eb-e3cb1f21bc27.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c3032531-f6b3-4b07-b0eb-e3cb1f21bc27.png)'
- en: 'Once the user logs in, he/she can navigate through all the screens by opening
    the drawer through the sliding finger gesture. The screen that opens by default
    after login is the chats screens where we will list the list of open conversations
    the user has:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后，可以通过滑动手指手势打开抽屉来浏览所有屏幕。默认登录后打开的屏幕是聊天屏幕，我们将列出用户拥有的所有打开对话的列表：
- en: '![](Images/9d64041f-16fd-4ed5-bf4f-8b52e7cacc61.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9d64041f-16fd-4ed5-bf4f-8b52e7cacc61.png)'
- en: 'From this screen, the user can press a specific conversation to list the messages
    on it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕上，用户可以按下特定的对话来列出其中的消息：
- en: '![](Images/15526fdd-df16-41c1-a055-ab14122f49a8.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15526fdd-df16-41c1-a055-ab14122f49a8.png)'
- en: 'The next screen is the search screen, which will be used to search for other
    users and start conversations with them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的屏幕是搜索屏幕，用于搜索其他用户并与他们开始对话：
- en: '![](Images/8c7259a1-9e7b-4491-a03b-f18e0f6f9a73.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8c7259a1-9e7b-4491-a03b-f18e0f6f9a73.png)'
- en: 'The last screen is the profile screen where the LOGOUT button can be found:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个屏幕是个人资料屏幕，可以在其中找到LOGOUT按钮：
- en: '![](Images/c275ce0e-2d78-4a68-8f94-34115a0cc9ee.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c275ce0e-2d78-4a68-8f94-34115a0cc9ee.png)'
- en: 'The app will work on both platforms in portrait and landscape mode out of the
    box:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将在横向和纵向模式下在两个平台上运行：
- en: '![](Images/b6098c83-2578-4a1d-8304-481ddc987cc2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b6098c83-2578-4a1d-8304-481ddc987cc2.png)'
- en: 'As we can imagine, this app will require of a powerful backend environment
    to store our users, messages, and statuses. Moreover, we will require a Push Notifications
    platform to notify users when they receive any messages. Since we are focusing
    in React Native in this book, we will delegate all this backend work to one of
    the most popular Mobile Backend as a Services (MBaaS) in the mobile world: Firebase'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以想象的那样，这个应用程序将需要一个强大的后端环境来存储我们的用户、消息和状态。此外，我们将需要一个推送通知平台，在用户收到任何消息时通知他们。由于本书专注于React
    Native，我们将把所有这些后端工作委托给移动世界中最流行的移动后端服务之一：Firebase。
- en: Before start coding, we will spend some time setting up our Firebase's push
    notifications service and real-time database to better understand what kind of
    data we will be dealing with in our app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，我们将花一些时间设置我们的Firebase推送通知服务和实时数据库，以更好地了解我们的应用程序将要处理的数据类型。
- en: 'In summary, we will go through the following topics in this chapter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，本章我们将涉及以下主题：
- en: Complex Redux in React Native
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native中的复杂Redux
- en: Firebase real-time database
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase实时数据库
- en: Firebase push notifications
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase推送通知
- en: Firebase user management
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase用户管理
- en: Forms
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: Let's start by reviewing the data models we will be using and how our app will
    connect with Firebase for syncing its data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下我们将使用的数据模型以及我们的应用程序如何与Firebase连接以同步其数据。
- en: Firebase
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase
- en: Firebase is a **Mobile Backend as a Service** (**MBaaS**), which means that
    it provides mobile developers with all the backend necessities, such as user management,
    no SQL database, and a push notification server. It integrates easily with React
    Native through an official node package, which brings the database connection
    for free. Unfortunately, Firebase doesn't offer a JavaScript SDK for their push
    notifications service, but there are several React Native libraries filling that
    gap by bridging Firebase's iOS and Java SDKs with a JavaScript interface. We will
    be using `react-native-fcm` as it is the most mature in its field.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一种**移动后端服务**（**MBaaS**），这意味着它为移动开发人员提供了所有后端必需品，如用户管理、无SQL数据库和推送通知服务器。它通过官方的node包轻松集成到React
    Native中，这为数据库连接提供了免费的服务。不幸的是，Firebase并没有为他们的推送通知服务提供JavaScript SDK，但有几个React Native库通过将Firebase的iOS和Java
    SDK与JavaScript接口进行桥接来填补这一空白。我们将使用`react-native-fcm`，因为它在这一领域最成熟。
- en: Before building an app on top of a Firebase MBaaS, you need to create a project
    for it. This is a free process that is explained in Firebase's website [https://firebase.google.com/](https://firebase.google.com/).
    Although this process is not directly related to React Native, it's a good starting
    point to understand how to set up and use a MBaaS for our apps. Most of the configuring
    can be finished in a matter of minutes just by following the tutorials available
    on Firebase's documentation site. The benefits of setting up this MBaaS make those
    minutes worth the time and initial hassle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase MBaaS上构建应用程序之前，您需要为其创建一个项目。这是一个免费的过程，可以在Firebase的网站[https://firebase.google.com/](https://firebase.google.com/)上找到解释。虽然这个过程与React
    Native没有直接相关，但这是一个很好的起点，可以帮助我们了解如何为我们的应用程序设置和使用MBaaS。通过遵循Firebase文档网站上提供的教程，大部分配置可以在几分钟内完成。设置这个MBaaS的好处使得这几分钟的时间和初始麻烦都是值得的。
- en: 'To set up Firebase and connect our app to the correct project, we need to use
    the `configuration for the web` snippet we can find in the Settings screen inside
    our Firebase project''s dashboard. We added this initialization snippet on `src/firebase.js`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Firebase并将我们的应用连接到正确的项目，我们需要使用在Firebase项目仪表板内的设置屏幕中找到的`web配置`片段。我们将此初始化片段添加到`src/firebase.js`中：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the project is set up, we can start taking a look at how our database is
    going to be structured.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置完成后，我们可以开始查看我们的数据库将如何被构建。
- en: Real-time database
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时数据库
- en: Firebase allows mobile developers to store and sync data between users and devices
    in real time using a cloud-hosted, noSQL database. Updated data syncs across connected
    devices in milliseconds and data remains available if your app goes offline, providing
    a great user experience regardless of network connectivity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase允许移动开发人员使用云托管的noSQL数据库在用户和设备之间存储和同步数据。更新后的数据在毫秒内同步到连接的设备上，如果应用程序离线，数据仍然可用，无论网络连接如何，都提供了良好的用户体验。
- en: 'Three data models come into the picture when thinking about the basic data
    a one-to-one communication app should handle:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑一对一通信应用程序应处理的基本数据时，涉及三个数据模型：
- en: '`users`: This will store avatars, names, and push notification tokens. There
    is no need to store authentication data here as it is handled through a different
    Firebase API (authentication API).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`：这将存储头像、名称和推送通知令牌。这里不需要存储身份验证数据，因为它是通过不同的Firebase API（身份验证API）处理的。'
- en: '`messages`: We will save each message on each chat room separately for easy
    retrieval using the chat room ID as a key.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messages`：我们将在每个聊天室中单独保存每条消息，以便使用聊天室ID作为键进行轻松检索。'
- en: '`chats`: All the information about the opened chats will be stored here.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chats`：所有有关已打开聊天的信息都将存储在这里。'
- en: 'To understand how we will request and use the data in our app, let''s see a
    gist of the example data we can actually use for testing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们将如何请求和使用我们应用程序中的数据，让我们看一下我们实际可以用于测试的示例数据的要点：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We organized our data in a way it will be easy for the messaging app to retrieve
    and synchronize. Instead of normalizing the data structure, we introduced some
    data duplication to increase speed during data retrieval and simplify the frontend
    code to the maximum.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一种易于消息应用程序检索和同步的方式组织我们的数据。我们没有对数据结构进行规范化，而是引入了一些数据重复，以增加数据检索速度，并将前端代码简化到最大程度。
- en: The `users` collection holds the users' data using the user ID as a key (`--user1--`,
    and `--user2--`). These user IDs are retrieved automatically by Firebase during
    registration/login. Each user has a notification token, which is an identifier
    for the device the user is logged in with the push notifications service. When
    the user logs out, the notifications token is removed, so messages sent to this
    user will be stored, but not notified to any device.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`users`集合使用用户ID作为键（`--user1--`和`--user2--`）保存用户数据。这些用户ID在注册/登录期间由Firebase自动检索。每个用户都有一个通知令牌，这是用户登录的设备的标识符，用于推送通知服务。当用户注销时，通知令牌将被删除，因此发送给该用户的消息将被存储，但不会通知到任何设备。'
- en: The `chats` collection stores each user's chat list by user ID. Each chat has
    its own ID (a concatenation of both user IDs) and will be duplicated as every
    user on that chat should have a copy of the chat data. In each copy, there is
    enough information for the other user to build up their chat screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`chats`集合通过用户ID存储每个用户的聊天列表。每个聊天都有自己的ID（两个用户ID的连接），并且将被复制，因为该聊天中的每个用户都应该有聊天数据的副本。在每个副本中，有足够的信息供另一个用户构建他们的聊天屏幕。'
- en: The `messages` collection is stored in a separate collection, which can be referenced
    by that ID. Each chat ID points to a list of messages (only one in this example)
    where all the data needed by the chat screen is stored. There is also some duplication
    in this collection as some user data is stored together with each message to reduce
    the number of requests needed when building a chat screen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages`集合存储在一个单独的集合中，可以通过该ID引用。每个聊天ID指向一个消息列表（在本例中只有一个），其中存储了聊天屏幕所需的所有数据。在这个集合中也存在一些重复，因为一些用户数据与每条消息一起存储，以减少构建聊天屏幕时所需的请求数量。'
- en: A full tutorial on how to read and write data in Firebase's real-time database
    can be found on their website ([https://firebase.google.com/docs/database/](https://firebase.google.com/docs/database/)),
    but we will take a quick look at the methods we will be using in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的网站上可以找到有关如何在Firebase的实时数据库中读写数据的完整教程（[https://firebase.google.com/docs/database/](https://firebase.google.com/docs/database/)），但是我们将快速浏览一下我们在本章中将使用的方法。
- en: Reading data from Firebase's database
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Firebase的数据库中读取数据
- en: 'There are two ways for retrieving data from Firebase''s database. The first
    one sets a listener that will be called every time the data changes, so we only
    need to set it up once for the entire lifetime of our app:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种从Firebase的数据库中检索数据的方法。第一种设置一个监听器，每当数据更改时都会被调用，因此我们只需要为我们应用程序的整个生命周期设置一次：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, in order to retrieve a snapshot of data, we need to call the
    `database()` method in our `firebaseApp` object (the one we created in our `src/firebase.js`
    file). Then, we will have a `database` object where we can call the `ref('<uri>')` on
    it passing the URI, where the data is stored. That will return a reference to
    the piece of data pointed by that URI. We can go for the `on('value', callback)`
    method, which will attach a callback passing the snapshot of data. Firebase always
    returns objects as snapshots, so we need to transform them into plain data ourselves.
    In this example, we want to retrieve an object with two keys (`name` and `avatar`),
    so we only need to call the `val()` method on the snapshot to retrieve a plain
    object containing the data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，为了检索数据的快照，我们需要在我们的`src/firebase.js`文件中创建的`firebaseApp`对象中调用`database()`方法。然后，我们将拥有一个`database`对象，我们可以在其上调用`ref('<uri>')`，传递数据存储的URI。这将返回一个由该URI指向的数据片段的引用。我们可以使用`on('value',
    callback)`方法，它将附加一个回调，传递数据的快照。Firebase总是将对象返回为快照，因此我们需要自己将它们转换为普通数据。在这个例子中，我们想要检索一个具有两个键（`name`和`avatar`）的对象，所以我们只需要在快照上调用`val()`方法来检索包含数据的普通对象。
- en: 'If we don''t need the retrieved data to be automatically synched every time
    it is updated, we could have used the `once()` method instead of `on()`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要检索的数据在每次更新时自动同步，我们可以使用`once()`方法代替`on()`：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The callback receiving snapshot will only be called once.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接收快照的回调只会被调用一次。
- en: Updating data in Firebase's database
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Firebase数据库中的数据
- en: 'Writing data in a Firebase database can also be done in two different ways:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase数据库中写入数据也可以通过两种不同的方式完成：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`update()` changes the object referenced by the supplied URI according to the
    keys and values passed as a parameter. The rest of the object is left intact.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`根据作为参数传递的键和值更改由提供的URI引用的对象。对象的其余部分保持不变。'
- en: 'On the other hand, `set()` will replace the object in the database with the
    one we provide as a parameter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`set()`将用我们提供的参数替换数据库中的对象：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, if we want to add a new snapshot of data but we want Firebase to generate
    an ID for it, we can use the `push` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想要添加一个新的数据快照，但是我们希望Firebase为其生成一个ID，我们可以使用`push`方法：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Authentication
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: We will use Firebase authentication services, so we don't need to worry about
    storing login credentials, handling forgotten passwords, or verifying emails on
    our side. These and other related tasks come for free with Firebase authentication
    services.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Firebase身份验证服务，因此我们不需要担心存储登录凭据、处理忘记的密码或验证电子邮件。 这些以及其他相关任务都可以通过Firebase身份验证服务免费完成。
- en: In order to activate login and registration through email and password, we need
    to enable this method as a session sign-in method in our Firebase dashboard. More
    information about how to do this can be found on Firebase's website at [https://firebase.google.com/docs/auth/web/password-auth](https://firebase.google.com/docs/auth/web/password-auth).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过电子邮件和密码激活登录和注册，我们需要在Firebase仪表板中将此方法作为会话登录方法启用。 有关如何执行此操作的更多信息，请访问Firebase网站上的[https://firebase.google.com/docs/auth/web/password-auth](https://firebase.google.com/docs/auth/web/password-auth)。
- en: 'In our app, we only need to use the provided Firebase SDK for login:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们只需要使用提供的Firebase SDK进行登录：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For registration, we can use the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于注册，我们可以使用以下代码：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All the token handling will be taken care of by Firebase, and we only need
    to add a listener to make sure our app is updated when the authentication status
    changes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有令牌处理将由Firebase处理，我们只需要添加一个监听器来确保我们的应用在身份验证状态更改时得到更新：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting up the folder structure
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `messagingApp` and will be available for iOS and Android devices:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用React Native的CLI初始化一个React Native项目。 该项目将被命名为`messagingApp`，并将可用于iOS和Android设备：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be using MobX to manage state in our app, so we will need a folder
    for our stores. The rest of the folder structure is standard to most React apps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MobX来管理我们应用的状态，因此我们将需要一个用于我们存储的文件夹。 其余的文件夹结构对大多数React应用程序来说是标准的：
- en: '![](Images/a7683572-2298-4276-b416-676f563b0335.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a7683572-2298-4276-b416-676f563b0335.png)'
- en: 'We need five screens (`Chats`, `Chat`, `Login`, `Profile`, and `Search`), a
    component (`ListItem`) and two stores (`chats` and `users`), which will be available
    through the `stores/index.js` file. There are also two helpers that we will be
    using to support our app:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要五个屏幕（`Chats`，`Chat`，`Login`，`Profile`和`Search`），一个组件（`ListItem`）和两个存储（`chats`和`users`），这些将通过`stores/index.js`文件可用。
    我们还将使用两个辅助程序来支持我们的应用：
- en: '`notifications.js`: All the logic related to push notifications will be stored
    in this file'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notifications.js`：与推送通知相关的所有逻辑将存储在此文件中'
- en: '`firebase.js`: This includes the configuration and initialization of Firebase
    SDK'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firebase.js`：这包括Firebase SDK的配置和初始化'
- en: 'Since we will be using MobX and several other dependencies, let''s take a look
    at our `package.json` file to understand what packages we will be using:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用MobX和其他几个依赖项，让我们查看一下我们的`package.json`文件，以了解我们将使用哪些包：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some of the npm packages we will be using are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的一些npm包是：
- en: '`firebase`: Firebase''s SDK for authentication and database connection'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firebase`：Firebase的身份验证和数据库连接的SDK'
- en: '`mobx`: MobX will handle our app state'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mobx`：MobX将处理我们的应用状态'
- en: '`react-native-fcm`: Firebase''s SDK for push messaging'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-fcm`：Firebase的推送消息SDK'
- en: '`react-native-gifted-chat`: A library for rendering chat rooms including date
    separation, avatars, and many other features'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-gifted-chat`：用于渲染聊天室的库，包括日期分隔、头像和许多其他功能'
- en: '`react-native-keyboard-aware-scroll-view`: A library that ensures the on-screen
    keyboard doesn''t hide any focused text input when working with forms'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-keyboard-aware-scroll-view`：一个库，确保在处理表单时屏幕键盘不会隐藏任何焦点文本输入'
- en: '`react-native-vector-icons`: We will use Font Awesome icons for this app'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-vector-icons`：我们将在此应用中使用Font Awesome图标'
- en: '`react-navigation`: We will have a drawer, a tabbed, and a stack navigator
    handling the screens in our app'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-navigation`：我们将有一个抽屉，一个选项卡和一个堆栈导航器来处理我们应用程序中的屏幕'
- en: '`babel-plugin-transform-decorators-legacy`: This library allows us to use decorators
    (with the legacy @ syntax) which is quite useful when working with MobX'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel-plugin-transform-decorators-legacy`：这个库允许我们使用装饰器（使用传统的@语法），在使用MobX时非常有用'
- en: 'After running `npm install`, we will have our app ready to start coding. As
    it happened in previous apps, the entry point for our messaging app will be the
    same code both in  `index.ios.js` for iOS and in `index.android.js` for Android:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install`后，我们的应用程序将准备好开始编码。与以前的应用程序一样，我们的消息应用程序的入口点将在`index.ios.js`（iOS）和`index.android.js`（Android）中是相同的代码：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a standard way to start up a React Native app working with MobX--a
    `<Provider />` is supplied as the root element to inject the two stores (`users`
    and `chats`) into the screens in our app. All the initializing and navigation
    logic has been deferred to the `src/main.js` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种使用MobX启动React Native应用程序的标准方式--`<Provider />`作为根元素提供，以将两个商店（`users`和`chats`）注入到我们应用程序的屏幕中。所有初始化和导航逻辑都已延迟到`src/main.js`文件中：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first thing we can see on the `src/main.js` file is that we will use different
    navigators, depending on which platform we are running the app: iOS will open
    a tabbed navigator, while Android will open a drawer-based navigator.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main.js`文件中我们可以看到的第一件事是，我们将使用不同的导航器，取决于我们运行应用程序的平台：iOS将打开一个选项卡导航器，而Android将打开一个基于抽屉的导航器。
- en: 'Then, we see a line we will be repeating in many components in our app:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到我们将在应用程序中的许多组件中重复的一行：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the way to tell MobX this component needs to receive the `users` store.
    MobX will then pass it as a prop to this component and therefore we can use all
    the methods and attributes it holds. In this case, we are interested in the `isLoggedIn`
    attribute to present the user with the `<Login />` screen if they are still not
    logged in. Since MobX will inject this attribute as a property in our component,
    the right way to access it will be `this.props.users.isLoggedIn`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是告诉MobX这个组件需要接收`users`商店的方式。然后MobX将其作为属性传递给这个组件，因此我们可以使用它所持有的所有方法和属性。在这种情况下，我们对`isLoggedIn`属性感兴趣，以便在用户尚未登录时向用户呈现`<Login
    />`屏幕。由于MobX将这个属性注入为我们组件的属性，访问它的正确方式将是`this.props.users.isLoggedIn`。
- en: Before continuing building components, let's take a look at the stores we will
    be using throughout this chapter to better understand what data and actions are
    available.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续构建组件之前，让我们看一下我们将在本章中使用的商店，以更好地了解可用的数据和操作。
- en: Users store
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户商店
- en: 'This store is responsible for holding all the data and logic surrounding users,
    but also helps the `chats` store initializing when a user is logged in:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个商店负责保存所有围绕用户的数据和逻辑，但也帮助`chats`商店在用户登录时初始化：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These are all the attributes and methods we need for this store. There are
    several flags (those attributes containing a verb in its -ing form) to note network
    activity. Let''s implement each method now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们在这个商店中需要的所有属性和方法。有几个标志（那些包含动词-ing形式的属性）需要注意网络活动。现在让我们实现每个方法：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Logging in with Firebase is as simple as calling `signInWithEmailAndPassword`
    on their authentication SDK. If the login is successful, we will initialize the
    notifications module to enable the device to receive push notifications. We will
    follow the opposite path on logout:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Firebase登录就像在他们的身份验证SDK上调用`signInWithEmailAndPassword`一样简单。如果登录成功，我们将初始化通知模块以使设备能够接收推送通知。在注销时，我们将遵循相反的路径：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the registration action, besides setting the appropriate flags for network
    activity, we need to validate the user entered a name, initialize the notifications,
    and store the name in the database:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册操作中，除了设置网络活动的适当标志之外，我们还需要验证用户输入了名称，初始化通知，并将名称存储在数据库中：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Setting the notification token is just a simple update in the database:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设置通知令牌只是数据库中的简单更新：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`searchUsers()` is not marked as `@action`, as it won''t modify the state of
    our app, but only search and return a list of users with the provided name in
    the database:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchUsers()`没有标记为`@action`，因为它不会修改我们应用程序的状态，而只是在数据库中搜索并返回具有提供的名称的用户列表：'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will return the result as a promise, due to the asynchronous nature of the
    request we are making.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行的请求的异步性质，我们将结果作为一个promise返回。
- en: 'Finally,` bindToFirebase()` will attach the attributes in this store to data
    snapshots in Firebase''s database. This method is called by the constructor, so
    it serves as initialization for the user data. It''s important to note that this
    data will be updated when the authentication status changed to always reflect
    the most up to date data for the user:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bindToFirebase()`将把此存储中的属性附加到Firebase数据库中的数据快照上。此方法由构造函数调用，因此它用作用户数据的初始化。重要的是要注意，当身份验证状态更改时，此数据将被更新，以始终反映用户的最新数据：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will store the listeners for the chat data (as `this.chatsBind`) and for
    the user data (as `this.userBind`), so we can remove them (by calling the `off()`
    method) before attaching new listeners on every `auth` state change.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将存储聊天数据的监听器（作为`this.chatsBind`）和用户数据的监听器（作为`this.userBind`），这样我们就可以在每次`auth`状态更改之前删除它们（通过调用`off()`方法），然后附加新的监听器。
- en: Chats store
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天存储
- en: 'This store is responsible for holding all the data and logic surrounding chats
    and messages, but it also helps the `chats` store initializing when a user is
    logged in:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储负责保存所有与聊天和消息相关的数据和逻辑，但它还有助于在用户登录时初始化`chats`存储：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will store the list of open chats the user has in `@observable list`. When
    a user selects one chat, we will download and synchronize the list of messages
    on that chat to `@observable selectedChatMessages`. Then, we will have a couple
    of flags to let the user know when we are downloading data from the Firebase database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`@observable list`中存储用户拥有的所有打开聊天的列表。当用户选择一个聊天时，我们将下载并同步该聊天上的消息列表到`@observable
    selectedChatMessages`。然后，我们将有一些标志，让用户知道我们正在从Firebase数据库下载数据。
- en: 'Let''s take a look at each method individually. We will start with `addMessages`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看每个方法。我们将从`addMessages`开始：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This method receives three parameters:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收三个参数：
- en: '`chatId`: The ID for the chat in which the messages will be added.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chatId`：要添加消息的聊天的ID。'
- en: '`contactId`: The ID for the user to whom we are sending the message. This will
    be used to send a notification to the user''s contact.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactId`：我们要发送消息的用户的ID。这将用于向用户的联系人发送通知。'
- en: '`messages`: This is an array with all the messages we want to add to the chat.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messages`：这是我们想要添加到聊天中的所有消息的数组。'
- en: We will loop through the list of messages, formatting the message the way we
    want to store it. Then, we will call the `set()` method on a database reference
    to save the new message in Firebase's database. Finally, we need to send the notification
    to our contact, so we retrieve their notifications token by querying the `users`
    collection by their `contactId`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环遍历消息列表，按照我们想要存储的方式格式化消息。然后，我们将在数据库引用上调用`set()`方法，将新消息保存在Firebase的数据库中。最后，我们需要向我们的联系人发送通知，所以我们通过查询`users`集合的`contactId`来检索他们的通知令牌。
- en: Sending notifications is normally handled by the backend, but since we are setting
    all the logic on the app itself, we need to build a function to send notifications.
    We have done this in our notifications `module: notifications.sendNotification(notificationsToken,
    data);`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '通常由后端处理发送通知，但由于我们正在将所有逻辑设置在应用程序本身上，因此我们需要构建一个发送通知的函数。我们已经在我们的通知`module: notifications.sendNotification(notificationsToken,
    data);`中完成了这个。'
- en: 'Let''s see what happens when we select a chat to display the messages for it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们选择一个聊天来显示它的消息时会发生什么：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The main piece of functionality here is attaching a listener to the messages/chat
    ID collection, which will sync the `this.selectedChatMessages` observable with
    the list of messages for the selected chat in the database. This means that every
    time a new message is stored in Firebase, `this.selectedChatMessages` will be
    synced to reflect it. This is how the `on()` method in the Firebase SDK works:
    we pass a callback, which we can use to synchronize the real-time database with
    our app''s state.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要功能是将监听器附加到消息/聊天ID集合，它将使用数据库中所选聊天的消息列表与`this.selectedChatMessages` observable同步。这意味着每当新消息存储在Firebase中时，`this.selectedChatMessages`将同步反映出来。这就是Firebase
    SDK中`on()`方法的工作原理：我们传递一个回调，我们可以使用它来将实时数据库与我们应用程序的状态同步。
- en: 'Adding a new chat will be done using the `add()` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add()`方法将添加新的聊天：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are building and returning a promise that will be resolved when the
    two chats (one per each user participating in the chat) are updated. These two
    database updates can be seen as the duplication of data, but it will also reduce
    the data structure complexity and therefore our code base readability.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在构建并返回一个承诺，当两个聊天（每个用户参与聊天一个）更新时将解决。这两个数据库更新可以看作是数据的复制，但它也将减少数据结构的复杂性，因此减少我们代码库的可读性。
- en: 'The last method in this store is `bindToFirebase()`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储中的最后一个方法是`bindToFirebase()`：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we saw in our `users` store, this method will be called when the user logs
    in and attaches a listener to the `chats/<userId>` snapshot of data to keep all
    the chats data synched with the database on the `this.list` attribute.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`users`存储中看到的，当用户登录并将监听器附加到`chats/<userId>`数据快照时，将调用此方法，以便将所有聊天数据与`this.list`属性上的数据库同步。
- en: 'As a convenience, we will group both stores in `src/stores/index.js`, so we
    can import them both on one line of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将两个存储都分组在`src/stores/index.js`中，这样我们可以在一行代码中导入它们。
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is all about the stores we will be using. As we can see, most of the business
    logic is handled here so it can be thoroughly tested. Let's move now to the helper
    we will use for notifications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将要使用的存储。正如我们所看到的，大部分业务逻辑都在这里处理，因此可以进行彻底的测试。现在让我们转到我们将用于通知的辅助程序。
- en: Push notifications using Firebase
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase进行推送通知
- en: Firebase incorporates a push notification service for iOS and Android, but it
    unfortunately doesn't provide any JavaScript on their SDK to use it. For this
    matter, an open source library was created bridging the Objective-C and Java SDKs
    into a React Native module: `react-native-fcm`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase集成了iOS和Android的推送通知服务，但不幸的是，它没有提供任何JavaScript SDK来使用它。为此，创建了一个开源库，将Objective-C和Java
    SDK桥接到React Native模块中：`react-native-fcm`。
- en: We won't cover the installation of this module in this book, as it's a changing
    process that can be better followed on its repository at [https://github.com/evollu/react-native-fcm.](https://github.com/evollu/react-native-fcm)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中涵盖此模块的安装，因为这是一个不断变化的过程，最好在其存储库上进行跟踪[https://github.com/evollu/react-native-fcm.](https://github.com/evollu/react-native-fcm)
- en: 'We decided to abstract the logic for this module on our `src/notifications.js`
    file to make it available for every component while keeping its maintainability.
    Let''s take a look at this file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定将此模块的逻辑抽象到我们的`src/notifications.js`文件中，以便在保持可维护性的同时为每个组件提供可用性。让我们来看一下这个文件：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are four functions exposed in this module:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块中公开了四个函数：
- en: '`init`: This requests the permission to receive push notifications (in case
    it was not yet granted) and requests the device token or refreshes it if changed.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`: 请求接收推送通知的权限（如果尚未授予），并请求设备令牌或在更改时刷新它。'
- en: '`onNotification`: This invokes a provided callback when a notification is received.
    In iOS, it also calls the appropriate methods on the notification to close the
    cycle.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNotification`: 当收到通知时，调用提供的回调函数。在iOS中，它还调用通知上的适当方法来关闭循环。'
- en: '`unbind`: This stops listening for push notifications.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unbind`: 停止监听推送通知。'
- en: '`sendNotification`: This formats and sends a push notification to a specific
    device using a provided notifications token.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendNotification`: 这将格式化并发送推送通知到特定设备，使用提供的通知令牌。'
- en: Sending notifications in Firebase can be done using their HTTP API, so we will
    use `fetch` for sending a `POST` request with the proper header and body data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase中发送通知可以使用他们的HTTP API，所以我们将使用`fetch`来发送带有适当标头和主体数据的`POST`请求。
- en: Now, we have all the logic we need to start building our screens and components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了构建屏幕和组件所需的所有逻辑。
- en: Login
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: The `<Login />` component heavily relies on the `users` store for logic, as
    it is mostly focused on rendering two forms for login and registration. All the
    validation for the forms is done by Firebase, so we only need to focus on rendering
    the UI elements and calling the proper store methods.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Login />`组件在逻辑上严重依赖于`users`存储，因为它主要用于呈现登录和注册两个表单。所有表单的验证都由Firebase完成，所以我们只需要专注于呈现UI元素和调用适当的存储方法。'
- en: In this screen, we will be using the `react-native-keyboard-aware-scroll` view,
    which is a module providing a self-scrolling `<Scrollview />`, which reacts to
    any focused `<TextInput />` so they are not hidden when the keyboard pops up.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕中，我们将使用`react-native-keyboard-aware-scroll`视图，这是一个提供自动滚动`<Scrollview />`的模块，它会对任何聚焦的`<TextInput
    />`做出反应，以便在键盘弹出时它们不会被隐藏。
- en: 'Let''s take a look at the code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We split the login screen in two forms: `<LoginForm />` and `<RegistrationForm
    />`. Both components need to be passed three props:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将登录屏幕分为两个表单：`<LoginForm />`和`<RegistrationForm />`。这两个组件都需要传递三个props：
- en: '`onPress`: What the component needs to do when the `Send` button is pressed.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPress`: 当按下“发送”按钮时组件需要执行的操作。'
- en: '`busy`: Are we waiting for remote data?'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`busy`: 我们是否在等待远程数据？'
- en: '`loginError`/`registrationError`: Description of the error that happened when
    logging/register (in case it happened).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginError`/`registrationError`: 登录/注册时发生的错误的描述（如果发生了）。'
- en: 'We are wrapping the whole screen in a `<KeyboardAwareScrollView />` to ensure
    no `<TextInput />` gets hidden by the keyboard when focused. Let''s take a look
    at the `LoginForm` now:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个屏幕包裹在`<KeyboardAwareScrollView />`中，以确保焦点时没有`<TextInput />`被键盘隐藏。现在让我们来看一下`LoginForm`：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the `<TextInput />` elements containing the email, we set the property `keyboardType='email-address'`
    so the `@` sign is easily accessible on the software keyboard. There are other
    options such as numeric keyboards, but we will only use `'email-address'` for
    this app.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含电子邮件的`<TextInput />`元素，我们设置了`keyboardType='email-address'`属性，以便`@`符号在软键盘上易于访问。还有其他选项，比如数字键盘，但我们只会在这个应用中使用`'email-address'`。
- en: 'Another useful prop on `<TextInput />` is `returnKeyType`. We set `returnKeyType=''next''`
    for those form inputs that are not the last ones to display the `Next` button
    in the keyboard so the user knows they can go to the next input by tapping that
    button. This prop is used in conjunction with a prop like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`<TextInput />`的另一个有用的属性是`returnKeyType`。我们为那些不是最后一个的表单输入设置`returnKeyType=''next''`，以便在键盘中显示`Next`按钮，这样用户就知道他们可以通过点击该按钮进入下一个输入。这个属性与以下属性一起使用：'
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`onSubmitEditing` is a `<TextInput />` prop that will be invoked when a user
    presses the `Return` or `Next` button on the keyboard. We are using it to focus
    on the next `<TextInput />`, which is quite user-friendly when dealing with forms.
    To get the reference for the next `<TextInput />` we use `ref`, which is not the
    safest way, but is good enough for simple forms. For this to work, we need to
    assign the corresponding `ref` to the next `<TextInput />`: `ref=''loginPassword''`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmitEditing`是一个`<TextInput />`属性，当用户在键盘上按下`Return`或`Next`按钮时将被调用。我们使用它来聚焦到下一个`<TextInput
    />`，在处理表单时非常用户友好。为了获取下一个`<TextInput />`的引用，我们使用`ref`，这并不是最安全的方式，但对于简单的表单来说已经足够好了。为了使其工作，我们需要将相应的`ref`分配给下一个`<TextInput
    />`：`ref=''loginPassword''`。'
- en: '`RegistrationForm` is a very similar form:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegistrationForm`是一个非常类似的表单：'
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Chats
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天
- en: 'This is the screen displaying the list of open chats. The special thing to
    note here is we are using a second navigator to display selected chats on top
    of the chats list. This means we need a `StackNavigator` in our `Chats` component
    that will contain two screens: `ChatList` and `Chat`. When a user taps on a chat
    from `ChatList`, `StackNavigator` will display the selected chat on top of `ChatList`
    making the list of chats available through a standard `< back` button in the header.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示打开聊天列表的屏幕。这里需要注意的特殊之处是，我们使用第二个导航器在聊天列表的顶部显示选定的聊天。这意味着我们的`Chats`组件中需要一个`StackNavigator`，其中包含两个屏幕：`ChatList`和`Chat`。当用户从`ChatList`中点击一个聊天时，`StackNavigator`将在`ChatList`的顶部显示选定的聊天，通过标题栏中的标准`<
    back`按钮使聊天列表可用。
- en: 'For listing the chats, we will use `<FlatList />`, a performant interface for
    rendering simple, flat lists, supporting the most of the features from `<ListView
    />`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列出聊天，我们将使用`<FlatList />`，这是一个用于呈现简单、平面列表的高性能界面，支持大多数`<ListView />`的功能：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first thing we notice is that we are injecting the `chats` store where the
    list of chats is saved: `@inject('chats') @observer`. We need this to build our
    `<FlatList />`, based on `this.props.chats.list`, but as the list of chats is
    an observable MobX object, we need to transform it using its `toJS()` method to
    make a JavaScript array out of it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是，我们正在注入`chats`存储，其中保存了聊天列表：`@inject('chats') @observer`。我们需要这样做来构建我们的`<FlatList
    />`，基于`this.props.chats.list`，但由于聊天列表是一个可观察的MobX对象，我们需要使用它的`toJS()`方法来将其转换为JavaScript数组。
- en: On the `componentWillMount()` function, we will invoke `onNotification` on the
    notifications module to open the corresponding chat every time the user presses
    a push notification on her device. Therefore, we will use the `navigate()` method
    on the navigator to open the proper chat screen including the name of the contact
    and her avatar.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`componentWillMount()`函数中，我们将在通知模块上调用`onNotification`，以便在用户每次按下设备上的推送通知时打开相应的聊天。因此，我们将在导航器上使用`navigate()`方法来打开适当的聊天屏幕，包括联系人的姓名和头像。
- en: ListItem
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListItem
- en: 'The list of chats relies on `<ListItem />` to render each specific chat within
    the list. This component is a custom UI class we created to reduce the `ChatList`
    component complexity:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天列表依赖于`<ListItem />`来呈现列表中的每个特定聊天。这个组件是我们创建的一个自定义UI类，用于减少`ChatList`组件的复杂性：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is little logic on this component as it only receives a prop named `onPress()`,
    which will be called when the `<ListItem />` is pressed, which, as we saw on this
    component's parent, will open the chat screen to show the list of messages on
    that specific chat. Let's take a look at the `chat` screen where all the messages
    for a specific chat are rendered.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件上有很少的逻辑，它只接收一个名为`onPress()`的prop，当`<ListItem />`被按下时将被调用，正如我们在这个组件的父组件中看到的，它将打开聊天屏幕，显示特定聊天中的消息列表。让我们来看看`chat`屏幕，那里渲染了特定聊天的所有消息。
- en: Chat
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chat
- en: 'To keep our code succinct and maintainable, we will use `GiftedChat` for rendering
    all the messages in a chat, but there is still some work we need to do to properly
    render this screen:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的代码简洁和可维护，我们将使用`GiftedChat`来渲染聊天中的所有消息，但是我们仍然需要做一些工作来正确渲染这个屏幕：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to inject some stores for our `<Chat />` component to work. This
    time, we need `users` and `chats` stores that will be available as props inside
    the component. This component also expects to receive two params from the navigator:
    `chatId` (the ID for the chat) and `contactId` (the ID for the person the user
    is chatting with).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的`<Chat />`组件注入一些存储。这一次，我们需要`users`和`chats`存储，它们将作为组件内的props可用。该组件还期望从导航器接收两个参数：`chatId`（聊天的ID）和`contactId`（用户正在聊天的人的ID）。
- en: When the component is getting ready to be mounted (`onComponentWillMount()`)
    we save the `chatId` and `contactId` in more convenient variables inside the component
    and call the `selectChat()` method on the `chats` store. This will trigger a request
    to Firebase database to fetch the messages for the selected chat, which will be
    synced through the `chats` store and is accessible to the component through `this.props.chats.selectedChatMessages`.
    MobX will also update a `downloadingChat` property to ensure we let the user know
    the data is being retrieved from Firebase.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件准备挂载（`onComponentWillMount()`）时，我们在组件内部保存`chatId`和`contactId`到更方便的变量中，并在`chats`存储上调用`selectChat()`方法。这将触发一个请求到Firebase数据库，以获取所选聊天的消息，这些消息将通过`chats`存储进行同步，并通过`this.props.chats.selectedChatMessages`在组件中访问。MobX还将更新一个`downloadingChat`属性，以确保我们让用户知道数据正在从Firebase中检索。
- en: Lastly, we need to add a `onSend()` function to `GiftedChat,` which will call
    the `addMessages()` method on the `chats` store to post the message to Firebase
    every time the `Send` button is pressed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为`GiftedChat`添加一个`onSend()`函数，它将在每次按下`发送`按钮时调用`chats`存储上的`addMessages()`方法，以将消息发布到Firebase。
- en: '`GiftedChat` helped us in largely reducing the amount of work we need to do
    in order to render the list of messages for a chat. On the other hand, we had
    to format the messages in the way `GiftedChat` requires and provide an `onSend()`
    function to be executed whenever we need a message posted to our backend.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`GiftedChat`在很大程度上帮助我们减少了为了渲染聊天消息列表而需要做的工作。另一方面，我们需要按照`GiftedChat`的要求格式化消息，并提供一个`onSend()`函数，以便在需要将消息发布到我们的后端时执行。'
- en: Search
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: 'The search screen is divided into two parts: a `<TextInput />` for the user
    to search a name and a `<FlatList />` to show the list of contacts found with
    the entered name:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索屏幕分为两部分：一个`<TextInput />`用于用户搜索姓名，一个`<FlatList />`用于显示输入姓名找到的联系人列表。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This component requires the injection of both stores (`users` and `chats`).
    The `users` store is used to invoke the `searchUsers()` method when the user hits
    the `Search` button. This method doesn't modify the state and therefore we need
    to provide a callback to receive the list of found users to finally set that list
    on the component's state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件需要注入两个存储（`users`和`chats`）。`users`存储用于在用户点击`搜索`按钮时调用`searchUsers()`方法。这个方法不会修改状态，因此我们需要提供一个回调来接收找到的用户列表，最终将该列表设置为组件的状态。
- en: 'The second store, `chats`, will be used to store the open chat in Firebase
    by calling `add()` from the `onPressUser()` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个存储`chats`将用于通过从`onPressUser()`函数调用`add()`在Firebase中存储打开的聊天：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `add()` method in the `chats` store requires two parameters to be passed:
    one per each user in the newly open chat. This data will be properly stored in
    Firebase, so both users will see the chat on their chat list in the app. After
    adding the new chat, we will navigate the app to the chats screen so the user
    can see if the addition was successful.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`chats`存储中的`add()`方法需要传递两个参数：每个用户在新打开的聊天中。这些数据将被正确存储在Firebase中，因此两个用户将在应用程序的聊天列表中看到聊天。添加新聊天后，我们将导航应用程序到聊天屏幕，以便用户可以看到添加是否成功。'
- en: Profile
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人资料
- en: 'The profile screen displays the user''s avatar, name, and a `Logout` button
    for signing out:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料屏幕显示用户的头像、姓名和“注销”按钮以退出登录：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The logout process is triggered by calling the `logout()` method on the `users`
    store. Since we controlled the authentication status in our `src/main.js` file,
    the app will automatically return to the Login or Register screen when the logout
    is successful.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注销过程是通过在`users`存储上调用`logout()`方法来触发的。由于我们在`src/main.js`文件中控制了身份验证状态，当注销成功时，应用程序将自动返回到登录或注册屏幕。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We covered several important topics for most of the modern enterprise apps:
    user management, data synchronization, complex app state, and handling forms.
    This is a complete app, which we manage to fix with a small code base and the
    help of MobX and Firebase.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了大多数现代企业应用程序的几个重要主题：用户管理、数据同步、复杂的应用程序状态和处理表单。这是一个完整的应用程序，我们设法用一个小的代码库和MobX和Firebase的帮助来修复它。
- en: Firebase is very capable of handling this app in production with a large number
    of users, but building our own backend system should not be a complex task, especially
    if we have experience in working with `socket.io` and real-time databases.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase非常有能力在生产中处理这个应用程序，拥有大量用户，但构建我们自己的后端系统不应该是一个复杂的任务，特别是如果我们有使用`socket.io`和实时数据库的经验。
- en: There are some aspects missing in this chapter such as handling security (which
    can be done fully within Firebase) or creating chat rooms for more than two users.
    In any case, these aspects fall out of React Native's environment, so they were
    intentionally left out.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节中有一些方面是缺失的，比如处理安全性（可以完全在Firebase内完成），或者为超过两个用户创建聊天室。无论如何，这些方面都超出了React Native的环境，所以它们被有意地省略了。
- en: After finishing this chapter, we should be able to build any app on top of Firebase
    and MobX as we covered the most used user cases on both pieces of technology.
    Of course, there are some more complex cases that were left out, but they can
    be easily learned by having a good understanding of the basics explained throughout
    this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们应该能够在Firebase和MobX之上构建任何应用程序，因为我们涵盖了这两种技术的最常用的用户案例。当然，还有一些更复杂的情况被省略了，但通过对本章中解释的基础知识有很好的理解，它们可以很容易地学会。
- en: 'In the next chapter, we will build a very different kind of app: a game written
    in React Native.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一种非常不同的应用程序：一个用React Native编写的游戏。
