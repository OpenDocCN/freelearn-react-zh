- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Before diving deep into the best practices to be followed while dealing with
    React and Firebase, let's recap what we have seen so far in the previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨在处理React和Firebase时应遵循的最佳实践之前，让我们回顾一下之前章节中我们所看到的内容。
- en: In the previous chapters, we saw Firebase account Setup, Firebase integration
    with ReactJs, Login Authentication With Firebase Auth Providers, Auth State management
    in React Component, Securing Data based on Role and Profile, Firebase integration
    with React-Redux, Firebase Cloud Messaging, Firebase Cloud Functions, and Using
    Firebase Admin SDK API with React Components, and I hope you have also enjoyed
    this journey. Now we know from where can we start and how to write the code, but
    the most important stuff is how can we write standard coding by following best
    practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看到了Firebase账户设置，Firebase与ReactJs的集成，使用Firebase身份验证提供程序进行登录认证，React组件中的身份验证状态管理，基于角色和配置文件的数据安全，Firebase与React-Redux的集成，Firebase云消息传递，Firebase云函数，以及在React组件中使用Firebase
    Admin SDK API，希望你也享受了这段旅程。现在我们知道从哪里开始以及如何编写代码，但最重要的是如何遵循最佳实践编写标准的代码。
- en: So when we create an application with React and Firebase, we need to ensure
    that the structure of your data in Firebase Database and passing the data into
    the react components is the most important part of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用React和Firebase创建应用程序时，我们需要确保Firebase数据库中数据的结构以及将数据传递到React组件中是应用程序中最重要的部分。
- en: In the development field, each developer has an individual opinion for following
    best practices, but I'm sharing with you what I have observed and experienced
    so far; you might have a different opinion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发领域中，每个开发人员对于遵循最佳实践都有自己的看法，但我将与您分享我迄今为止观察和经验到的内容；你可能有不同的看法。
- en: 'Here''s a list of topics that we''ll cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题列表：
- en: Best practices with Firebase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase的最佳实践
- en: Best practices with React and Redux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React和Redux的最佳实践
- en: Best practices with Firebase
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase的最佳实践
- en: In Firebase, we all know that data is stored in JSON tree format, which is synchronized
    in realtime to every connected device. So while building cross-platform applications
    (web, iOS, and Android) with Firebase, we can share one instance to all your apps
    to receive the latest updates with new data from Realtime Database. So when we
    add the data into the JSON tree, it becomes the node in the existing JSON Structure
    with an associated key, so we always need to plan how data will be saved to build
    a properly structured database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase中，我们都知道数据以JSON树格式存储，并且实时同步到每个连接的设备。因此，在使用Firebase构建跨平台应用程序（Web、iOS和Android）时，我们可以共享一个实例给所有应用程序，以接收来自实时数据库的最新更新和新数据。因此，当我们将数据添加到JSON树中时，它将成为现有JSON结构中的一个节点，并带有关联的键，因此我们始终需要计划如何保存数据以构建一个结构良好的数据库。
- en: Writing the data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入数据
- en: 'In Firebase, we have four methods available to write a data into the Firebase
    database:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase中，我们有四种方法可以将数据写入Firebase数据库：
- en: '| `set( )` | Write or replace data to a defined path, like `messages/tickets/<uid>`.
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `set( )` | 写入或替换数据到指定路径，比如 `messages/tickets/<uid>`。'
- en: '| `update( )` | Update to specific children of node without replacing the other
    child nodes. We can also use the update method to update the data into multiple
    locations. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `update( )` | 更新节点的特定子节点而不替换其他子节点。我们还可以使用update方法将数据更新到多个位置。'
- en: '| `push( )` | To add a list of data in the database, we can use the `push()`
    method; it generates a unique ID every time when it calls, such as `helpdesk/tickets/<unique-user-id>/<unique-ticket-id>`.
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `push( )` | 要在数据库中添加一系列数据，我们可以使用`push()`方法；每次调用时它都会生成一个唯一的ID，比如 `helpdesk/tickets/<unique-user-id>/<unique-ticket-id>`。'
- en: '| `transaction( )` | We can use this method when we are working with complex
    data that can be corrupted by concurrent updates such as incremental counters.
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `transaction( )` | 当我们处理可能会被并发更新破坏的复杂数据时，我们可以使用这种方法，比如增量计数器。'
- en: 'Now, let''s take a look at how data is structured in our helpdesk  application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的帮助台应用程序中的数据结构是如何构建的：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s take an example of the preceding data structure and use the `set()`
    method to store the data with autoincrementing integer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以前面的数据结构为例，使用`set()`方法存储具有自增整数的数据：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now if you see the preceding data structure, new tickets will be stored as `/tickets/1`.
    This will work if only a single user were adding tickets, but in our application,
    many users can add tickets at the same time. If two employees write to `/tickets/2`
    simultaneously, then one of the tickets will be deleted by the other. So this
    will not be recommended practices and always recommend to use the `push()` method
    to generate a unique ID (refer to the preceding data structure) when you are working
    with list of data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你看到前面的数据结构，新的票将被存储为`/tickets/1`。如果只有一个用户添加票，这将起作用，但在我们的应用程序中，许多用户可以同时添加票。如果两个员工同时写入`/tickets/2`，那么其中一个票将被另一个删除。因此，这不是推荐的做法，我们始终建议在处理数据列表时使用`push()`方法生成唯一ID（参考前面的数据结构）。
- en: Avoid nesting data
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免嵌套数据
- en: In Firebase Realtime Database, when you fetch the data from the JSON tree, we
    will also get all the child nodes of that specific node, because when we add the
    data into the JSON tree, it becomes the node in the existing JSON structure with
    an associated key. Firebase Realtime Database allows nesting data up to 32 levels
    deep, so when we give the access to someone to read or write access at a specific
    node, then we are also giving access of all the child nodes of under that node.
    Therefore, always the best practice is to keep our data structure as flat as possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase实时数据库中，当我们从JSON树中获取数据时，我们还将获取该特定节点的所有子节点，因为当我们将数据添加到JSON树中时，它就成为现有JSON结构中的一个节点，并带有关联的键。
    Firebase实时数据库允许嵌套数据深达32级，因此当我们授予某人在特定节点上的读取或写入权限时，我们也在给予该节点下所有子节点的访问权限。因此，始终最佳实践是尽可能保持我们的数据结构扁平化。
- en: 'Let me show you why nested data is bad; refer to the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向你展示为什么嵌套数据是不好的；请参考以下示例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this nested data structure, it's very difficult to iterate over the data.
    Even a simple operation like listing the names of products requires that the entire
    products tree, including all product list and types, be downloaded to the client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种嵌套数据结构，对数据进行迭代非常困难。即使是像列出产品名称这样的简单操作，也需要将整个产品树，包括所有产品列表和类型，下载到客户端。
- en: Flattern data structure
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flattern数据结构
- en: 'In Flattern structure, data was split into different paths; it could be easy
    to download only the required nodes, as needed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flattern结构中，数据被分成不同的路径；只需在需要时轻松下载所需的节点：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we had some lightly nested data (for example, details
    for each products are themselves objects with children), but we've also organized
    our data logically by how it will be iterated and read later. We have stored duplicate
    data to defining the relationship between objects; this is necessary to maintain
    the two-way, many-to-many, or one-to-many relationships for redundancy. It allows
    us to quickly and efficiently fetch mobiles, even when the list of products or
    products types scales into the millions, or when Firebase Rulesa and Security
    will prevent access to some of the records.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一些轻度嵌套的数据（例如，每个产品的详细信息本身就是带有子元素的对象），但我们还按照它们将来的迭代和读取方式逻辑地组织了我们的数据。我们存储了重复的数据来定义对象之间的关系；这对于维护双向、多对多或一对多的冗余关系是必要的。这使我们能够快速有效地获取手机，即使产品或产品类型的列表扩展到数百万，或者Firebase规则和安全性将阻止访问某些记录。
- en: It's now possible to iterate the list of products by only downloading a few
    bytes per product, quickly fetching metadata for displaying products in a UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过每个产品只下载少量字节来迭代产品列表，快速获取用于在UI中显示产品的元数据。
- en: After seeing the preceding flattern structure, if you are thinking that it is
    really okay to look up each record individually in Firebase, then yes it is, because
    Firebase internally uses web sockets and client libraries for incoming and outgoing
    requests for optimization. Even if we get tens of thousand records, this approach
    is still okay and perfectly reasonable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到前面的扁平结构后，如果您认为在Firebase中逐个查找每条记录是可以的，那么是的，因为Firebase内部使用网络套接字和客户端库进行传入和传出请求的优化。即使我们有数万条记录，这种方法仍然可以，并且非常合理。
- en: Always create the data structure that can scale in future when the app user
    grows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 始终创建可以在应用用户增长时扩展的数据结构。
- en: Avoid arrays
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用数组
- en: The Firebase documentation has already mentioned and cleared this topic to avoid
    using arrays in Firebase Database, but I want to highlight some of the use cases
    where you can use the Arrays for storing the data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase文档已经提到并澄清了这个话题，避免在Firebase数据库中使用数组，但我想强调一些使用数组存储数据的用例。
- en: 'Refer to the following points; if all the following are true, we can use Array
    to store the data in Firebase:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下几点；如果以下所有条件都成立，我们可以使用数组在Firebase中存储数据：
- en: If one client can write the data at a time
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个客户端一次只能写入数据
- en: For removing the keys, instead of using `.remove()`, we can save the array and
    splice it
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在删除键时，我们可以保存数组并进行切割，而不是使用`.remove()`
- en: We need to take care when referring to anything by array index (a mutable key)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过数组索引引用任何内容时，我们需要小心（可变键）
- en: Date object
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期对象
- en: When we talk about sorting and filtering the data in Firebase with `created_date`,
    ensure that you have added the `created_date` key in every object that you have
    created along with date timestamp, such as `ref.set(new Date().toString())` and
    `ref.set(new Date().getTime())`, because Firebase has not supported JavaScript
    date object type `(ref.set(new Date());)`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论在Firebase中对数据进行排序和过滤时，确保您在每个创建的对象中都添加了`created_date`键，以及日期时间戳，例如`ref.set(new
    Date().toString())`和`ref.set(new Date().getTime())`，因为Firebase不支持JavaScript日期对象类型（`ref.set(new
    Date());`）。
- en: Custom claims
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义声明
- en: Firebase Admin SDK provides the ability to add custom attributes in profile
    object; with the help of this, we can give user different access control, including
    role-based controls in the react-firebase app, so they are not designed to store
    additional data (such as profile and other custom data). We know that this looks
    like a very convenient way to do so, but it is strongly not recommended, as these
    claims are stored in the ID token and that impacts the performance issues, because
    all authenticated requests always contain a Firebase ID token corresponding to
    the signed in user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK提供了在配置文件对象中添加自定义属性的功能；借助这一功能，我们可以为用户提供不同的访问控制，包括在react-firebase应用中基于角色的控制，因此它们并不是用来存储额外的数据（如配置文件和其他自定义数据）。我们知道这看起来是一个非常方便的方法，但强烈不建议这样做，因为这些声明存储在ID令牌中，这会影响性能问题，因为所有经过身份验证的请求都包含与已登录用户对应的Firebase
    ID令牌。
- en: Custom claims are only for storing the data for controlling user access
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义声明仅用于存储控制用户访问的数据
- en: Custom claims are limited in size, so passing a custom claims greater than 1000
    bytes will throw an error
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义声明的大小受限，因此传递大于1000字节的自定义声明将引发错误
- en: Managing the user session
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户会话
- en: Manage the session for the user and give the prompt to reauthenticate, because
    every time when the user logged in, user credentials are sent to the Firebase
    Authentication backend and exchanged for a Firebase ID token (a JWT) and refresh
    token.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 管理用户会话并提示重新验证，因为每次用户登录时，用户凭据都会发送到Firebase身份验证后端并交换为Firebase ID令牌（JWT）和刷新令牌。
- en: 'These are the common scenarios where we need to manage the session of the user:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要管理用户会话的常见情况：
- en: User is deleted
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户被删除
- en: User is disabled
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户被禁用
- en: Email address and password changed
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址和密码更改
- en: The Firebase Admin SDK also gives the ability to revoke the specific user session
    using the `revokeRefreshToken()` method. It revokes active refresh tokens of a
    given user. If we reset the password, Firebase Authentication backend automatically
    revokes the user token.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Admin SDK还提供了使用`revokeRefreshToken()`方法撤销特定用户会话的能力。它会撤销给定用户的活动刷新令牌。如果重置密码，Firebase身份验证后端会自动撤销用户令牌。
- en: 'The following rule must be configured when any data requires authentication
    to access:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何数据需要身份验证才能访问时，必须配置以下规则：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Enabling offline capabilities in JavaScript
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中启用离线功能
- en: When we create Realtime Application with Firebase, we also need to monitor the
    connection when clients connect and disconnect with database.  Firebase provides
    a simple solution, which you can use to write to the database when a client disconnects
    from the Firebase Database servers. We can perform all operations such as writing,
    setting, updating, and removing can be performed upon a disconnection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Firebase创建实时应用程序时，还需要监视客户端与数据库的连接和断开连接。Firebase提供了一个简单的解决方案，可以在客户端从Firebase数据库服务器断开连接时写入数据库。我们可以在断开连接时执行所有操作，如写入、设置、更新和删除。
- en: 'Refer to this example `onDiscconnect()` method of Firebase:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Firebase的`onDisconnect()`方法示例：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also attach the callback function to ensure that the `onDisconnect()`
    method is attached properly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以附加回调函数以确保`onDisconnect()`方法被正确附加：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To cancel the `onDisconnect()` method, we can call `.cancel()` method `onDisconnectRef.cancel();`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消`onDisconnect()`方法，我们可以调用`.cancel()`方法`onDisconnectRef.cancel();`。
- en: For detecting the connection state, Firebase Realtime Database provides special
    location ` /.info/connected`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测连接状态，Firebase实时数据库提供了特殊位置`/.info/connected`。
- en: 'This is updated every time app connection state changes; it returns the boolean
    value to check whether the client connection state is connected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用连接状态更改时都会更新；它返回布尔值以检查客户端连接状态是否已连接：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Optimize database performance
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据库性能
- en: There are a few things where we also need to focus, such as Firebase Realtime
    Database performance in your app, to see how we can optimize your Realtime Database
    performance using different Realtime Database monitoring tools.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些需要关注的事项，比如在您的应用中优化Firebase实时数据库性能，以了解如何使用不同的实时数据库监控工具来优化您的实时数据库性能。
- en: Monitor Realtime Database
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控实时数据库
- en: 'We can collect the data of our Realtime Database''s performance through a few
    different tools:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一些不同的工具收集我们的实时数据库性能数据：
- en: '**High-level overview:** We can use the Firebase profiler tool for a list of
    unindexed queries and a realtime overview of read/write operations. For using
    the profiler tool, ensure that you have installed Firebase CLI and run the following
    command.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级概述：** 我们可以使用Firebase分析工具列出未索引的查询和实时读/写操作的概述。要使用分析工具，请确保已安装Firebase CLI并运行以下命令。'
- en: '**Billed usage estimate:** FIrebase usage metrics provide you your billed usage
    and high-level performance metrics in Firebase Console.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计费使用估计：** Firebase使用指标在Firebase控制台中提供您的计费使用和高级性能指标。'
- en: '**Detailed drilldown:** Stackdriver Monitoring tool provides you with a more
    granular look at how your database is performing over time.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细钻取：** Stackdriver监控工具为您提供了数据库随时间性能的更细粒度查看。'
- en: For more details about profiling, visit [https://firebase.google.com/docs/database/usage/profile](https://firebase.google.com/docs/database/usage/profile)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分析的更多详细信息，请访问[https://firebase.google.com/docs/database/usage/profile](https://firebase.google.com/docs/database/usage/profile)
- en: Improve performance by metric
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过指标改善性能
- en: 'Once you''ve gathered data, explore the following best practices and strategies
    based on the performance area you want to improve:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 收集数据后，根据您想要改进的性能领域，探索以下最佳实践和策略：
- en: '| **Metric** | **Description** | **Best practices** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **指标** | **描述** | **最佳实践** |'
- en: '| Load/Utilization | Optimize how much of your database''s capacity is in use
    processing requests at any given time (reflected in **Load** or **io/database_load**
    metrics). | Optimize your data structure ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))
    Shared data across databases ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '| 负载/利用率 | 优化数据库处理请求时的容量利用率（反映在**负载**或**io/database_load**指标中）。 | 优化数据结构（[https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure)）跨数据库共享数据（[https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data)）'
- en: Improve listener efficiency ([https://firebase.google.com/docs/database/usage/optimize#efficient-listeners](https://firebase.google.com/docs/database/usage/optimize#efficient-listeners))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提高监听器效率（[https://firebase.google.com/docs/database/usage/optimize#efficient-listeners](https://firebase.google.com/docs/database/usage/optimize#efficient-listeners)）
- en: Limit downloads with query-based rules *(*[https://firebase.google.com/docs/database/usage/optimize#query-rules](https://firebase.google.com/docs/database/usage/optimize#query-rules))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于查询的规则限制下载*(*[https://firebase.google.com/docs/database/usage/optimize#query-rules](https://firebase.google.com/docs/database/usage/optimize#query-rules))
- en: Optimize connections ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    |
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 优化连接（[https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections)）|
- en: '| Active connections | Balance the number of simultaneous and active connections
    to your database to stay under the 100,000-connection limit. | Shard data across
    databases ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))
    Reduce new connections ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 活动连接 | 平衡数据库的同时和活动连接数，以保持在 100,000 个连接限制以下。 | 在数据库之间分片数据 ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))
    减少新连接 ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    |'
- en: '| Outgoing bandwidth | If the downloads from your database seem higher than
    you want them to be, you can improve the efficiency of your read operations and
    reduce encryption overhead. | Optimize connections ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    Optimize your data structure ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '| 出站带宽 | 如果从数据库下载的数据量比您想要的要高，您可以提高读操作的效率并减少加密开销。 | 优化连接 ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    优化数据结构 ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))
    |'
- en: Limit downloads with query-based rules ([https://firebase.google.com/docs/database/usage/optimize#query-rules](https://firebase.google.com/docs/database/usage/optimize#query-rules))
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于查询的规则限制下载 ([https://firebase.google.com/docs/database/usage/optimize#query-rules](https://firebase.google.com/docs/database/usage/optimize#query-rules))
- en: Reuse SSL sessions ([https://firebase.google.com/docs/database/usage/optimize#ssl-sessions](https://firebase.google.com/docs/database/usage/optimize#ssl-sessions))
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重用 SSL 会话 ([https://firebase.google.com/docs/database/usage/optimize#ssl-sessions](https://firebase.google.com/docs/database/usage/optimize#ssl-sessions))
- en: Improve listener efficiency ([https://firebase.google.com/docs/database/usage/optimize#efficient-listeners](https://firebase.google.com/docs/database/usage/optimize#efficient-listeners))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提高监听器效率 ([https://firebase.google.com/docs/database/usage/optimize#efficient-listeners](https://firebase.google.com/docs/database/usage/optimize#efficient-listeners))
- en: Restrict access to data ([https://firebase.google.com/docs/database/usage/optimize#secure-data](https://firebase.google.com/docs/database/usage/optimize#secure-data))
    |
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 限制对数据的访问 ([https://firebase.google.com/docs/database/usage/optimize#secure-data](https://firebase.google.com/docs/database/usage/optimize#secure-data))
    |
- en: '| Storage | Ensure that you''re not storing unused data, or balance your stored
    data across other databases, and/or Firebase products to remain under quota. |
    Clean up unused data ([https://firebase.google.com/docs/database/usage/optimize#cleanup-storage](https://firebase.google.com/docs/database/usage/optimize#cleanup-storage))
    Optimize your data structure ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| 存储 | 确保您不存储未使用的数据，或者在其他数据库和/或 Firebase 产品之间平衡存储的数据，以保持在配额范围内。 | 清理未使用的数据
    ([https://firebase.google.com/docs/database/usage/optimize#cleanup-storage](https://firebase.google.com/docs/database/usage/optimize#cleanup-storage))
    优化数据结构 ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))'
- en: Shard data across databases ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库之间分片数据 ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))
- en: Use Firebase Storage ([https://firebase.google.com/docs/storage](https://firebase.google.com/docs/storage))
    |
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Firebase存储([https://firebase.google.com/docs/storage](https://firebase.google.com/docs/storage))
    |
- en: Source: [https://firebase.google.com/docs/database/usage/optimize](https://firebase.google.com/docs/database/usage/optimize)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://firebase.google.com/docs/database/usage/optimize](https://firebase.google.com/docs/database/usage/optimize)
- en: We can create multiple Realtime Database instances if we're using Blaze pricing
    plan; then, we can create multiple database instances in the same Firebase project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是Blaze定价计划，我们可以创建多个实时数据库实例；然后，我们可以在同一个Firebase项目中创建多个数据库实例。
- en: 'To edit and deploy rules from the Firebase CLI, follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Firebase CLI编辑和部署规则，请按照以下步骤进行：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ensure that you consistently edit and deploy rules from the same place.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您始终从同一位置编辑和部署规则。
- en: Connect your app to multiple database instances
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用连接到多个数据库实例
- en: 'Use the database reference to access data stored in secondary database instances.
    You can get the reference for a specific database instance by URL or app. If we
    don''t specify a URL in the `.database()` method, then we''ll get the reference
    for the app''s default database instance:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库引用来访问存储在辅助数据库实例中的数据。您可以通过URL或应用程序获取特定数据库实例的引用。如果我们在`.database()`方法中不指定URL，那么我们将获得应用程序的默认数据库实例的引用：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To see the list of Firebase Sample Projects, visit [https://firebase.google.com/docs/samples/](https://firebase.google.com/docs/samples/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Firebase示例项目列表，请访问[https://firebase.google.com/docs/samples/](https://firebase.google.com/docs/samples/)。
- en: To see the list of Firebase Libraries, refer to [https://firebase.google.com/docs/libraries/](https://firebase.google.com/docs/libraries/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Firebase库列表，请参考[https://firebase.google.com/docs/libraries/](https://firebase.google.com/docs/libraries/)。
- en: You can also subscribe to the [https://www.youtube.com/channel/UCP4bf6IHJJQehibu6ai__cg](https://www.youtube.com/channel/UCP4bf6IHJJQehibu6ai__cg) channel
    to get updated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以订阅[https://www.youtube.com/channel/UCP4bf6IHJJQehibu6ai__cg](https://www.youtube.com/channel/UCP4bf6IHJJQehibu6ai__cg)频道以获取更新。
- en: Best practices with React and Redux
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React和Redux的最佳实践
- en: Whenever we have components with dynamic functionality, data comes into the
    picture; the same way, in React, we have to deal with dynamic data, which seems
    easy but not every time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有具有动态功能的组件时，数据就会出现；同样，在React中，我们必须处理动态数据，这似乎很容易，但并非每次都是这样。
- en: Sounds confusing!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很混乱！
- en: It is easy but sometimes tough because, in React components, it’s easy to pass
    properties with many ways for building rendering tree from it, but there is not
    much clarity to update the view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易，但有时很困难，因为在React组件中，很容易通过多种方式传递属性来构建渲染树，但更新视图的清晰度不高。
- en: In the preceding chapters, this statement is clearly shown, so if you are still
    not clear, refer to those.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，这个声明已经清楚地显示出来了，所以如果你还不清楚，请参考那些。
- en: Use of Redux
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux的使用
- en: 'As we know, in SPAs (single page applications), when we have to contract with
    state and time, it will be difficult to handgrip state over time. Here, Redux
    helps a lot, how? This is because, in a JavaScript application, Redux is handling
    two states: one is Data state and another is UI state, and it’s a standard option
    for SPAs (single page applications). Moreover, bear in mind that Redux can be
    used with Angular or Jquery or React JavaScript libraries or frameworks.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在单页面应用程序（SPA）中，当我们必须处理状态和时间时，难以掌握状态随时间的变化。在这里，Redux非常有帮助，为什么？这是因为在JavaScript应用程序中，Redux处理两种状态：一种是数据状态，另一种是UI状态，它是单页面应用程序（SPA）的标准选项。此外，请记住，Redux可以与Angular或Jquery或React
    JavaScript库或框架一起使用。
- en: Difference between Redux and Flux
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux和Flux之间的区别
- en: Redux is a tool, whereas Flux is just a pattern that you can’t use, like plug
    and play or download it. I’m not denying that Redux has some influence from the
    Flux pattern, but as we can’t say, it 100% looks like Flux.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个工具，而Flux只是一个模式，你不能像即插即用或下载一样使用它。我并不否认Redux受到Flux模式的一些影响，但正如我们无法说它百分之百看起来像Flux一样。
- en: Let’s go ahead to refer to a few differences.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续参考一些区别。
- en: 'Redux follows three guiding principles, as shown, which will also cover the
    difference between Redux and Flux:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Redux遵循三个指导原则，如所示，这也将涵盖Redux和Flux之间的区别：
- en: '**Single store approach:** We saw in the earlier diagrams that Store is pretending
    as an "intermediary" for all kind of state modifications within application and
    Redux. It is controlling direct communication between two components through the
    Store, a single point of communication. Here, the difference between Redux and
    Flux is that Flux has multiple store approaches and Redux has a single store approach.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一存储器方法：** 我们在之前的图表中看到，存储器在应用程序和Redux中充当所有状态修改的“中间人”。它通过存储器控制两个组件之间的直接通信，是通信的单一点。在这里，Redux和Flux之间的区别在于Flux有多个存储器方法，而Redux有单一存储器方法。'
- en: '**Read-Only State:** In React applications, components cannot change state
    directly, but they have to dispatch change to Store through "actions". Here, Store
    is an object, and it has four methods, as shown:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**只读状态：** 在React应用程序中，组件不能直接改变状态，而是必须通过“动作”将改变分派给存储器。在这里，存储器是一个对象，它有四种方法，如下所示：'
- en: store.dispatch(action)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: store.dispatch(action)
- en: store.subscribe(listener)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: store.subscribe(listener)
- en: store.getState()
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: store.getState()
- en: replaceReducer(nextReducer)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: replaceReducer(nextReducer)
- en: '**Reducer Functions to change the State:** Reducer function will handle dispatching
    actions to change the state as Redux tool doesn’t allow direct communication between
    two components; so it will not only change the state but also, the dispatch action
    will be described for state change. Reducers here can be considered as pure-function.
    Here are a few characteristics to write reducer functions:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**改变状态的Reducer函数：** Reducer函数将处理分派动作以改变状态，因为Redux工具不允许两个组件直接通信；因此它不仅会改变状态，还会描述状态改变的分派动作。这里的Reducer可以被视为纯函数。以下是编写reducer函数的一些特点：'
- en: No outside database or network calls
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有外部数据库或网络调用
- en: Returns value based on its parameters
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于参数返回值
- en: Arguments are "immutable"
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数是“不可变的”
- en: The same argument returns the same value
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的参数返回相同的值
- en: Reducer functions are called pure-functions as they are purely doing nothing
    except returning a value based on their set parameters; it doesn’t have any other
    consequences. They are recommended to have a flat state. In Flux or Redux architecture,
    it’s always tough to deal with nested resources, which are from APIs' return,
    so it’s been recommended to have a flat state in your component, such as normalize.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer函数被称为纯函数，因为它们纯粹地根据其设置的参数返回值；它没有任何其他后果。建议它们具有扁平状态。在Flux或Redux架构中，处理来自API返回的嵌套资源总是很困难，因此建议在组件中使用扁平状态，例如normalize。
- en: '**Hint for pros: **`const data = normalize(response, arrayOf(schema.user)) 
    state = _.merge(state, data.entities)`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**专业提示：** `const data = normalize(response, arrayOf(schema.user))  state =
    _.merge(state, data.entities)`'
- en: Immutable React State
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变的React状态
- en: In flat state, we have the benefit of dealing with nested resource and in the
    Immutable object, we have the benefit of a declared state that cannot be modified.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在扁平状态中，我们可以处理嵌套资源，并且在不可变对象中，我们可以获得声明的状态不可修改的好处。
- en: 'The other benefit of the Immutable object is that with their reference level
    equality checks, we can have fabulous improved rendering performance. In Immutable,
    we have an example of `shouldComponentUpdate`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象的另一个好处是，通过它们的引用级别相等检查，我们可以获得出色的改进渲染性能。在不可变中，我们有一个`shouldComponentUpdate`的例子：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In JavaScript, use of Immutability Deep freeze node will help you to freeze
    a node before mutation, and then it will verify results. The following example
    shows the same logic:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，使用不可变性深冻结节点将帮助您在变异之前冻结节点，然后它将验证结果。以下示例显示了相同的逻辑：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I hope that the preceding examples would have made things clear about immutable
    JS''s use and benefits. It is also having a non-complicated way, but its use is
    very low:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望前面的例子已经清楚地说明了不可变JS的用途和好处。它也有一个不复杂的方式，但它的使用率非常低：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From my point of view, it’s very a fast and beautiful feature to be used.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这是一个非常快速和美丽的功能。
- en: React Routing
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React路由
- en: We have to use routing in client-side applications, and, for ReactJS also, we
    need one or the other routing library, so I recommend that you use react-router-dom
    instead of react-router.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在客户端应用程序中使用路由，并且对于ReactJS，我们还需要一个或另一个路由库，因此我建议您使用react-router-dom而不是react-router。
- en: '**Advantages:**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势：**'
- en: Views declaration in standardized structure help us to instantly understand
    what are our app views
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准化结构中声明视图可以帮助我们立即了解我们的应用视图是什么
- en: Using react-router-dom, we can easily handle the nested views and their progressive
    resolution of views
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用react-router-dom，我们可以轻松处理嵌套视图及其渐进式视图分辨率
- en: Using browsing history feature user can navigate backward/forward and restore
    the state of view
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览历史功能，用户可以向后/向前导航并恢复视图状态
- en: Dynamic Route matching
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由匹配
- en: CSS transitions on views when navigating
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航时视图上的CSS过渡
- en: Standardized app structure and behavior, useful when working in a team
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化的应用程序结构和行为，在团队合作时非常有用。
- en: 'Note: React router doesn’t provide any way to handle data-fetching. We need
    to use async-props or other React data fetching mechanism.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：React路由器没有提供处理数据获取的任何方式。我们需要使用async-props或其他React数据获取机制。
- en: 'It’s been seen that very few developers who are dealing with webpack know about
    code splitting of your application code in several files of JavaScript:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有开发人员知道如何在webpack中将应用程序代码拆分成多个JavaScript文件：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This split of code is necessary because each code is not useful to each user,
    and it’s not necessary to load that chunk of code in each page, which will be
    a burden for the browser, so to avoid such a situation, we should split our application
    into several chunks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的拆分是必要的，因为每个代码对每个用户都没有用，也没有必要在每个页面加载该代码块，这对浏览器来说是一种负担，因此为了避免这种情况，我们应该将应用程序拆分成几个块。
- en: Now, you will have a question like if we will have more chunks of code, we will
    have to have more HTTP requests and that will also affect performance, but with
    the help of HTTP/2multiplexed, your problem will be resolved. You can also combine
    your chunked code with chunk hashing, which will also optimize your browser cache
    ratio whenever you change your code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会有一个问题，比如如果我们有更多的代码块，我们将不得不有更多的HTTP请求，这也会影响性能，但借助HTTP/2多路复用，你的问题将得到解决。您还可以将分块代码与分块哈希结合使用，这样每当更改代码时，还可以优化浏览器缓存比例。
- en: JSX components
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX组件
- en: JSX is nothing, but, in simple words, it is just an extension of JavaScript
    syntax. Also, if you observe the syntax or structure of JSX, you will find that
    it's similar to XML coding. JSX is doing preprocessor footstep, which adds XML
    syntax to JavaScript. Though you can certainly use React without JSX, JSX makes
    react a lot more neat and elegant. Similar to XML, JSX tags are having tag name,
    attributes, and children and, in that, if an attribute value is enclosed in quotes,
    that value becomes a string.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JSX无非就是，简单来说，它只是JavaScript语法的扩展。此外，如果您观察JSX的语法或结构，您会发现它类似于XML编码。JSX正在执行预处理步骤，将XML语法添加到JavaScript中。虽然您当然可以在没有JSX的情况下使用React，但JSX使得React更加整洁和优雅。与XML类似，JSX标记具有标记名称，属性和子级，并且在其中，如果属性值用引号括起来，该值将成为字符串。
- en: JSX works similar to XML, with balanced opening and closing tags, and it helps
    make large trees at ease to read than “function calls” or “object literals”.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JSX的工作方式类似于XML，具有平衡的开放和关闭标签，并且有助于使大型树更容易阅读，而不是“函数调用”或“对象文字”。
- en: '**Advantages of using JSX in React**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**在React中使用JSX的优势**：'
- en: JSX is very simple to understand and think about than JavaScript functions
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX比JavaScript函数更容易理解和思考
- en: Markup of JSX is more acquainted to designer and the rest of your team
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX的标记更熟悉于设计师和您团队的其他成员
- en: Your markup becomes more semantic, structured and more meaningful
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的标记变得更语义化，结构化和更有意义
- en: How is it easy to visualize?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它有多容易可视化？
- en: As I said, the structure/syntax is easy to visualize/notice, which is intended
    to be more clear and readable in the JSX format as compared to JavaScript.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，结构/语法在JSX格式中更容易可视化/注意到，这意味着与JavaScript相比更清晰和可读。
- en: Semantics / structured syntax
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义/结构化语法
- en: In our applications, we can see how JSX syntax is easy to understand and visualize;
    behind this, there is a big reason of having semantic syntax structure. JSX, with
    pleasure, converts your JavaScript code into more semantic and meaningful structured
    markup. This consents you the benefit of declaring your component structure and
    information pour using an HTML-like syntax, knowing that it will transform into
    simple JavaScript functions. React outlines all the HTML elements you would expect
    in the React.DOM namespace. The good part is that it also allows you to use your
    own written, custom components within the markup.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们可以看到JSX语法易于理解和可视化；在其背后，有一个具有语义化语法结构的重要原因。JSX愉快地将您的JavaScript代码转换为更具语义和有意义的结构化标记。这使您能够声明组件结构和信息倾注使用类似HTML的语法，知道它将转换为简单的JavaScript函数。React概述了您在React.DOM命名空间中期望的所有HTML元素。好处是它还允许您在标记中使用您自己编写的自定义组件。
- en: Use of PropType in React component
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React组件中使用PropType
- en: 'In a React component, we can pass the properties from higher-level component,
    so knowledge of properties is a must, as it will give you more flexibility to
    extend your component and saves your time:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件中，我们可以从更高级别的组件传递属性，因此对属性的了解是必须的，因为这将使您能够更灵活地扩展组件并节省时间：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also validate your properties the way we can validate properties of
    Immutable JS with react immutable proptypes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以验证您的属性，就像我们可以使用react不可变proptypes验证不可变JS的属性一样。
- en: Benefit of higher-order components
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶组件的好处
- en: 'Higher-order components are nothing but extended versions of your original
    component:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件只是原始组件的扩展版本：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The main benefit of using them is that we can use it in multiple situations,
    for example, authentication or login validation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它的主要好处是我们可以在多种情况下使用它，例如身份验证或登录验证：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The other benefit is that with higher-order components, you can fetch data separately
    and set your logic to have your views in a simple way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，使用高阶组件，您可以单独获取数据并设置逻辑以简单地查看您的视图。
- en: Redux Architecture benefits
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux架构的好处
- en: 'Compared to other frameworks, it has more plus points:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他框架相比，它有更多的优点：
- en: It might not have any other way effects.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可能没有任何其他影响。
- en: As we know, binding is not needed because components can’t interact directly.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所知，不需要绑定，因为组件不能直接交互。
- en: States are managed globally, so less possibility of mismanagement.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是全局管理的，因此管理不当的可能性较小。
- en: Sometimes, for middleware, it would be difficult to manage other way effects.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，对于中间件，管理其他方式的影响可能会很困难。
- en: From the mentioned points, it's very clear that the Redux architecture is very
    powerful, and it has reusability as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述观点来看，Redux架构非常强大，而且具有可重用性。
- en: We can also use build React-Firebase application with the **ReactFire** library,
    with a few lines of JavaScript. We can integrate Firebase data into React apps
    via ReactFireMixin.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用ReactFire库构建React-Firebase应用程序，只需几行JavaScript。我们可以通过ReactFireMixin将Firebase数据集成到React应用程序中。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this last and final chapter of this book, we covered the best practices to
    be followed when working with React and Firebase. We also saw how we can monitor
    application performance with the use of different tools to reduce the number of
    bugs. We also talked about the importance of the structure of your data in Firebase
    Realtime database and discussed the dynamic data passing to React components.
    We also looked at other key factors, such as JSX, React Routing, and React PropTypes,
    which are the topmost usable elements in React App. We also learned that Redux
    helps a lot in maintaining the state of your **Single Page Applications** (**SPAs**).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们介绍了在使用React和Firebase时应遵循的最佳实践。我们还看到了如何使用不同的工具来监视应用程序性能，以减少错误的数量。我们还谈到了Firebase实时数据库中数据结构的重要性，并讨论了动态数据传递给React组件。我们还研究了其他关键因素，如JSX、React路由和React
    PropTypes，在React应用程序中是最常用的元素。我们还了解到Redux在维护**单页应用程序**（**SPAs**）的状态方面有很大帮助。
