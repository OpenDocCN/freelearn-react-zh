- en: Connecting React to Redux and Firebase
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将React连接到Redux和Firebase
- en: In [Chapter 3](dede285d-2924-4fcf-a208-57337e4b853f.xhtml), *Authentication
    with Firebase*, we saw how React components can be built and how they manage their
    own state. In this chapter, we will take a look at how to efficiently manage the
    application state. We will explore Redux in detail and see how and when we need
    to use Redux in our React app. We will also see how we can integrate all three—React,
    Redux, and Firebase—with a sample seat booking application. It will be a general
    seat booking app, and it can be used as any seat booking, such as bus seat booking,
    a stadium seat booking, or a theater seat booking, with some minor changes in
    the data structure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](dede285d-2924-4fcf-a208-57337e4b853f.xhtml)中，*使用Firebase进行身份验证*，我们看到了React组件如何构建以及它们如何管理自己的状态。在本章中，我们将看看如何高效地管理应用程序状态。我们将详细探讨Redux，并了解何时以及何时需要在我们的React应用程序中使用Redux。我们还将看到如何将React，Redux和Firebase集成到一个示例座位预订应用程序中。这将是一个通用的座位预订应用程序，并且可以用作任何座位预订，例如公交车座位预订，体育场座位预订或剧院座位预订，在数据结构中进行一些小的更改。
- en: 'Here''s a list of the topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题列表：
- en: React setup with React Starter Kit
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Starter Kit设置React
- en: Integration of Firebase Realtime Database and React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase实时数据库和React的集成
- en: Redux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux
- en: Integration of React, Redux, and Firebase Realtime Database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React，Redux和Firebase实时数据库的集成
- en: Seat Booking Application covering all the above concepts practically
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖上述所有概念的座位预订应用程序
- en: Let's set up our development environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置开发环境。
- en: To set up the React development environment, you will need to have node version
    6.0 or greater.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置React开发环境，您需要使用6.0或更高版本的node。
- en: React setup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React设置
- en: 'To set up our development environment, the first step will be the React setup.
    There are different options available to install React. If you already have an
    existing app and want to add React, you can install it using a package manager
    such as `npm` using this command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的开发环境，第一步将是React设置。有不同的选项可用于安装React。如果您已经有现有的应用程序并希望添加React，可以使用包管理器（如`npm`）使用以下命令进行安装：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, if you are starting a new project, the easiest way to get started
    is with the React Starter Kit. Just go to the Command Prompt and execute the following
    command to install the React Starter kit:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您要启动一个新项目，最简单的方法是使用React Starter Kit开始。只需转到命令提示符并执行以下命令以安装React Starter
    kit：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will install and set up the local development environment by downloading
    all the required dependencies. There are a number of benefits to have your development
    environment with node, such as optimized production builds, installing libraries
    using simple `npm` or `yarn` commands, and such.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将通过下载所有必需的依赖项来安装和设置本地开发环境。使用node拥有开发环境的许多好处，例如优化的生产构建，使用简单的`npm`或`yarn`命令安装库等。
- en: 'Once you have it installed, you can create your first app using the given command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以使用给定的命令创建您的第一个应用程序：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will create a frontend application and will not include any backend logic
    or integration. It is just frontend and hence you can integrate it with any backend
    technology or in your existing project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建一个前端应用程序，并不包括任何后端逻辑或集成。它只是前端，因此您可以将其与任何后端技术集成或集成到现有项目中。
- en: The preceding command will take a while to download all dependencies and create
    the project, so keep patience.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将花费一些时间来下载所有依赖项并创建项目，所以请耐心等待。
- en: 'Once the project is created, just go into that folder and run the server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，只需进入该文件夹并运行服务器：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the server is started, you can access the application at `http://localhost:3000`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，您可以在`http://localhost:3000`访问应用程序。
- en: 'The start kit is the best way to start with React. However, if you are an advanced
    user, you can manually configure your project by adding React dependencies using
    the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 起始套件是开始使用React的最佳方式。但是，如果您是高级用户，可以通过使用以下命令手动配置项目来添加React依赖项：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For this sample seat booking app, we will use the `create-react-app` command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例座位预订应用程序，我们将使用`create-react-app`命令。
- en: 'The project structure will look as follows if you see it in the Visual Code
    editor:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构将如下所示，如果您在Visual Code编辑器中查看：
- en: '![](Images/37f874ca-9617-45a8-9649-46267854875f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/37f874ca-9617-45a8-9649-46267854875f.png)'
- en: The created app structure is good enough to get started, but for our seat booking
    app, we will need to organize our source code in a better package structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的应用程序结构已经足够好了，但是对于我们的座位预订应用程序，我们需要以更好的包结构组织我们的源代码。
- en: 'So, we will create the different folders for actions, components, containers,
    and reducers, as shown in the following screenshot. For now, just focus on the
    `components` folder, because in that, we will put our React components. The rest
    of the folders are related to Redux, which we will see in the Redux section:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将为操作、组件、容器和减速器创建不同的文件夹，如下面的屏幕截图所示。现在，只关注`components`文件夹，因为在其中，我们将放置我们的React组件。其余的文件夹与Redux有关，我们将在Redux部分中看到：
- en: '![](Images/aec2a88f-30e4-4346-80ae-33af5243949d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aec2a88f-30e4-4346-80ae-33af5243949d.png)'
- en: It is very important to identify the components at the start of application
    development so that you can have a better code structure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的开始阶段识别组件非常重要，这样您就可以拥有更好的代码结构。
- en: 'Just to start with, we will have the following React components in our seat
    booking application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们的座位预订应用程序中将有以下React组件：
- en: '`Seat`: `Seat` Object and basic building block of the application'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seat`：`Seat`对象和应用程序的基本构建块'
- en: '`SeatRow`: It represents a row of seats'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SeatRow`：它表示一排座位'
- en: '`SeatList`: It represents the list of all seats'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SeatList`：它表示所有座位的列表'
- en: '`Cart`: It represents the cart that will have information on selected seats'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cart`：它表示将包含所选座位信息的购物车'
- en: Note that the design of components depends on the application complexity and
    data structure of the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，组件的设计取决于应用程序的复杂性和应用程序的数据结构。
- en: Let's start with our first component called Seat. This will be under the `components`
    folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的第一个组件开始，称为Seat。这将在`components`文件夹下。
- en: '`components/Seat.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/Seat.js`：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, an important thing to note is that we are using JSX syntax, which we already
    saw in [chapter 2](77d4d4ec-e6e1-47c4-8b2a-8c9620341ba7.xhtml), *Integrate React
    App with Firebase*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，需要注意的一件重要的事情是，我们正在使用JSX语法，这是我们在[第2章](77d4d4ec-e6e1-47c4-8b2a-8c9620341ba7.xhtml)中已经看到的，*将React应用程序与Firebase集成*。
- en: 'Here, we have defined the `Seat` component with three properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经定义了具有三个属性的`Seat`组件：
- en: '`number`: refers to the number or ID given to that seat'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`：指的是给该座位的编号或ID'
- en: '`price`: refers to the amount to be charged to book this seat'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price`：指的是预订此座位需要收取的金额'
- en: '`status`: refers to the seat status if it is booked or available'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：指的是座位状态，即已预订或可用'
- en: '`PropTypes` in React is used to validate the inputs your component receives;
    for example, the price should be a number and not a String. A warning will be
    shown in the JavaScript console if an invalid value is provided for a prop. For
    performance reasons, `PropTypes` checking will only take place in the development
    mode.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，`PropTypes`用于验证组件接收的输入；例如，价格应该是一个数字而不是一个字符串。如果为属性提供了无效值，JavaScript控制台将显示警告。出于性能原因，`PropTypes`检查只会在开发模式下进行。
- en: In our seat booking app, when a user selects a seat, we need to add it to the
    cart so that the user can check out/book the ticket(s). To do so, we need to handle
    an `onClick()` for a seat. For now, we are just printing a console statement in
    the click handler function, but we will need to write a logic to push the selected
    seats to the cart. We will look into it in the later section when we will integrate
    Redux in our app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的座位预订应用程序中，当用户选择座位时，我们需要将其添加到购物车中，以便用户可以结账/预订票。为此，我们需要处理座位的`onClick()`。目前，我们只是在点击处理程序函数中打印一个控制台语句，但是我们需要编写一个逻辑将所选座位推送到购物车中。当我们在应用程序中集成Redux时，我们将在后面的部分中进行研究。
- en: If any seat is already booked, obviously we won't allow the user to select it
    and hence based on the status, we are disabling seats if they are booked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何座位已经预订，显然我们不会允许用户选择它，因此基于状态，如果座位已预订，我们将禁用座位。
- en: Seat is our basic building block, and it will receive data from the parent component,
    which is the `SeatRow` component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 座位是我们的基本构建块，它将从父组件`SeatRow`接收数据。
- en: '`components/SeatRow.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/SeatRow.js`：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A `SeatRow` represents a row of seats. We are creating loosely coupled components
    that can be maintained easily and can be reused wherever required. Here, we are
    iterating the array of seats JSON data to render corresponding `Seat` objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeatRow`代表一排座位。我们正在创建松散耦合的组件，可以轻松维护并在需要时重用。在这里，我们正在迭代座位JSON数据数组，以渲染相应的`Seat`对象。'
- en: You can see in the preceding code block that we are validating our values using
    `PropTypes`. The `PropTypes.arrayOf` represents an array of Seats and `PropTypes.shape`
    represents the `Seat` object props.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的代码块中看到，我们正在使用`PropTypes`验证我们的值。`PropTypes.arrayOf`表示座位的数组，`PropTypes.shape`表示`Seat`对象的props。
- en: Our next component is the `SeatList` component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个组件是`SeatList`组件。
- en: '`components/SeatList.js`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/SeatList.js`：'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have defined a `SeatList` component with two properties:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`SeatList`组件，具有两个属性：
- en: '`title`: A title to be displayed for seat booking'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 用于座位预订的标题'
- en: '`children`: It represents the list of Seats'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`：它代表座位列表'
- en: 'There are two important things related to proptypes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与proptypes相关的两个重要事项：
- en: '`Proptypes.string.isRequired`: `isRequired` can be chained to ensure that you
    see a warning in the console if the data received is not valid.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proptypes.string.isRequired`：`isRequired`可以链接以确保如果接收到的数据无效，则在控制台中看到警告。'
- en: '`Proptypes.node`: Node represents that anything can be rendered: number, string,
    elements, or an array (or fragment) containing these types.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proptypes.node`：Node表示可以呈现任何内容：数字、字符串、元素或包含这些类型的数组（或片段）。'
- en: The next and final component in our app is `Cart`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的下一个和最终组件是`Cart`。
- en: '`components/Cart.js`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/Cart.js`：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our cart component will have a button called `Checkout` to book the tickets.
    It will also show the summary of the selected seats and total payment to be done.
    As of now, we are just putting a button and a label. We will modify it once we
    integrate Firebase and Redux in our app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的购物车组件将有一个名为`Checkout`的按钮来预订票。它还将显示所选座位的摘要和需要支付的总费用。目前，我们只是放置了一个按钮和一个标签。一旦我们在应用程序中集成Firebase和Redux，我们将对其进行修改。
- en: So, we have our presentational components ready. Now, let's integrate Firebase
    with our application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的展示组件已准备就绪。现在，让我们将Firebase与我们的应用程序集成。
- en: Integrating Firebase Realtime Database
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Firebase实时数据库
- en: It's time to integrate Firebase in our application. Though we have already seen
    the detailed description and features of Firebase Realtime Database in [Chapter
    2](77d4d4ec-e6e1-47c4-8b2a-8c9620341ba7.xhtml)*, Connecting React to Redux and
    Firebase, *we will see key concepts for JSON data architecture and best practices
    for the same. Firebase database stores data as a JSON tree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的应用程序中集成Firebase了。虽然我们已经在[第2章](77d4d4ec-e6e1-47c4-8b2a-8c9620341ba7.xhtml)中看到了Firebase实时数据库的详细描述和特性，*连接React到Redux和Firebase*，我们将看到JSON数据架构的关键概念和最佳实践。Firebase数据库将数据存储为JSON树。
- en: 'Take into consideration this example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The database uses a JSON tree, but data stored in the database can be represented
    as certain native types to help you write more maintainable code. As shown in
    the preceding example, we have created a tree structure like `seats > seat-#`.
    We are defining our own keys, such as `seat-1`, `seat-2`, and more, but if you
    use the `push` method, it will be autogenerated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库使用JSON树，但存储在数据库中的数据可以表示为某些原生类型，以帮助您编写更易维护的代码。如前面的例子所示，我们创建了一个类似`seats > seat-#`的树形结构。我们正在定义我们自己的键，比如`seat-1`，`seat-2`，等等，但如果您使用`push`方法，它将被自动生成。
- en: 'It is worth noting that Firebase Realtime Database data nesting can go up to
    32 levels deep. However, it is recommended that you avoid the nesting as much
    as possible and have the flat data structure. If you have a flattened data structure,
    it provides you with two main benefits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Firebase实时数据库数据嵌套可以达到32级深。然而，建议您尽量避免嵌套，并使用扁平化的数据结构。如果您有一个扁平化的数据结构，它将为您提供两个主要的好处：
- en: 'Load/Fetch data that is needed: You will fetch only the required data and not
    a complete tree, because in the case of a nested tree if you load a node, you
    will load all the children of that node too.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载/获取所需的数据：您将只获取所需的数据，而不是完整的树，因为在嵌套树的情况下，如果您加载一个节点，您将同时加载该节点的所有子节点。
- en: 'Security: You give limited access to data because in the case of a nested tree,
    if you give access to a parent node, it essentially means that you also grant
    access to the data under that node.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：您可以限制对数据的访问，因为在嵌套树的情况下，如果您给予对父节点的访问权限，这实际上意味着您也授予对该节点下数据的访问权限。
- en: 'The best practices here are as listed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最佳实践如下：
- en: Avoid Nested Data
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免嵌套数据
- en: Use Flatten data structures
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扁平化的数据结构
- en: Create Scalable Data
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可扩展的数据
- en: 'Let''s first create our Realtime Firebase database:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的实时Firebase数据库：
- en: '![](Images/9f0aa2aa-8870-49f5-9390-a237f5d58d8a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9f0aa2aa-8870-49f5-9390-a237f5d58d8a.png)'
- en: 'We can directly create this structure on Firebase console or create this JSON
    and import it in Firebase. We have the following structure to our data:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在Firebase控制台上创建这个结构，或者创建这个JSON并将其导入Firebase。我们的数据结构如下：
- en: 'Seats: Seats is our main node and contains a list of Seats'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 座位：座位是我们的主节点，包含一个座位列表
- en: 'Seat: Seat is an individual object that represents a seat with a unique number,
    price, and status'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 座位：座位是一个表示具有唯一编号、价格和状态的座位的单独对象
- en: We can design a three-level deep nested data structure, such as `seats > row
    > seat`, for our sample application, but as mentioned in the best practices earlier,
    we should design a flattened data structure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的示例应用程序设计一个三级深度嵌套的数据结构，比如`seats > row > seat`，但正如前面的最佳实践中所述，我们应该设计一个扁平化的数据结构。
- en: 'Now that we have our data designed, let''s integrate the Firebase in our application. In
    this application, instead of adding Fireabase dependency through URL, we will
    add its module using `npm`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设计好了我们的数据，让我们在应用程序中集成Firebase。在这个应用程序中，我们将使用`npm`添加它的模块，而不是通过URL添加Fireabase依赖项：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command will install Firebase module in our application, and we can import
    it using the following statement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在我们的应用程序中安装Firebase模块，我们可以使用以下语句导入它：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The import statement is ES6 feature, so if you are not aware of it, refer to
    ES6 documentation at [http://es6-features.org/](http://es6-features.org/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句是ES6的特性，所以如果你不了解它，请参考ES6文档[http://es6-features.org/](http://es6-features.org/)。
- en: We will put our DB related files in a folder called API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把与数据库相关的文件放在一个名为API的文件夹中。
- en: '`api/firebase.js`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`api/firebase.js`：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code will initialize the Firebase instance that can be used to
    connect to Firebase. For better separation of concern, we will also create a file
    called `service.js`, which will interact with our database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将初始化Firebase实例，该实例可用于连接Firebase。为了更好地关注点分离，我们还将创建一个名为`service.js`的文件，该文件将与我们的数据库交互。
- en: '`api/service.js`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`api/service.js`：'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this file, we have mainly defined two functions—`getSeats()` and `bookSelSeats()`—which
    are to read database for list of seats and update seats when user checks them out
    from the cart, respectively.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们主要定义了两个函数——`getSeats()`和`bookSelSeats()`——用于从数据库中读取座位列表和在用户从购物车中选中座位时更新座位。
- en: 'Firebase provides two methods—`on()` and `once()`—to read data at a path and
    listen for changes. There is a difference between the `on` and `once` methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase提供了两种方法——`on()`和`once()`——用于在路径上读取数据并监听更改。`on`和`once`方法之间有区别：
- en: 'The on method: It will listen for the data changes and will receive the data
    at the specified location in the database at the time of the event. Also, it doesn''t
    return a `Promise` object.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: on方法：它将监听数据更改，并在事件发生时接收数据库中指定位置的数据。此外，它不会返回`Promise`对象。
- en: 'The once method: It will be called only once and will not listen for changes.
    It will return a `Promise` object.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: once方法：它将仅被调用一次，并且不会监听更改。它将返回一个`Promise`对象。
- en: As we are using the once method, we get a `Promise` object returned to our component
    object, since the call from our component to the service will be async. You will
    understand it better in the following `App.js` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了once方法，所以我们得到一个返回到我们组件对象的`Promise`对象，因为从我们组件到服务的调用将是异步的。您将在接下来的`App.js`文件中更好地理解它。
- en: To read a static snapshot of the contents at a given path, we can use `value` event.
    This method is executed once when the listener is attached and every time the
    data changes including children. The event callback is passed a snapshot containing
    all data at that location, including child data. If there is no data, the snapshot
    returned is null.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取给定路径上内容的静态快照，我们可以使用`value`事件。当侦听器附加时，此方法仅执行一次，并且每次数据更改（包括子级）时都会执行。事件回调传递一个包含该位置的所有数据的快照，包括子数据。如果没有数据，则返回的快照为null。
- en: It is important to note that the `value` event will be fired every time the
    data is changed at the given path, including data changes in children. Hence,
    it is recommended that we attach the listener only at the lowest level needed
    to limit the snapshot size.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`value`事件将在给定路径上的数据每次更改时触发，包括子级的数据更改。因此，建议我们仅在需要限制快照大小的最低级别处附加侦听器。
- en: Here, we are getting the data from Firebase Realtime Database and get all the
    seats. Once we get the data, we create a JSON object according to the format we
    need and return it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在从Firebase实时数据库中获取数据并获取所有座位。一旦我们获取数据，我们根据需要的格式创建一个JSON对象并返回它。
- en: '`App.js` will be our container component and will look like the one that follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`将是我们的容器组件，并且将如下所示：'
- en: '`App.js`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we can see that the `App` component maintains the state. However, our
    goal is to separate the state management from our presentational component and
    use Redux for it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`App`组件维护着状态。然而，我们的目标是将状态管理与我们的展示组件分离，并使用Redux来管理状态。
- en: So, now we have all functional pieces ready, but how will it look without proper
    design and CSS. We have to design a seat layout that is user-friendly, so let's
    apply CSS. We have a file called `App.css` for the entire app. We can separate
    them out in different files if required.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经准备好了所有的功能模块，但如果没有适当的设计和CSS，它会是什么样子呢？我们必须设计一个用户友好的座位布局，所以让我们应用CSS。我们有一个名为`App.css`的整个应用程序文件。如果需要，我们可以将它们分开放在不同的文件中。
- en: '`App.css`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.css`：'
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are done with our minimal seat booking app. Yay! The following are the screenshots
    of the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的最小座位预订应用程序。耶！以下是应用程序的截图。
- en: 'The next screenshot shows the default layout where all the seats are available
    for booking:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了默认布局，所有座位都可以预订：
- en: '![](Images/903148b7-631c-40f9-aaa0-003a43cb1cef.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/903148b7-631c-40f9-aaa0-003a43cb1cef.png)'
- en: 'The following screenshot shows that the Booked tickets are marked as X, so
    the user can''t select them. It also shows that when a user selects a seat, it
    turns out to be red so that they can know which seats have been selected by them:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了已预订的票被标记为X，所以用户无法选择它们。它还显示了当用户选择一个座位时，它会变成红色，这样他们就知道他们选择了哪些座位：
- en: '![](Images/fcf1691c-713f-48d0-a225-8ca629b3bd8b.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fcf1691c-713f-48d0-a225-8ca629b3bd8b.jpg)'
- en: Finally, we have our seat booking app ready where we are loading data from Firebase
    database and showing them using React. However, after looking at the preceding
    screenshot, you must be thinking that though we have selected two seats, the cart
    is empty and is not showing any data of the seats. If you remember, we haven't
    written any logic in the `seat click handler` function to add the selected seats
    in cart and hence our cart remains empty.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的座位预订应用程序已经准备就绪，我们正在从Firebase数据库加载数据，并使用React显示它们。然而，看完前面的截图后，你一定会想，虽然我们已经选择了两个座位，但购物车是空的，没有显示任何座位的数据。如果你记得的话，我们还没有在`seat
    click handler`函数中编写任何逻辑来将选定的座位添加到购物车中，因此我们的购物车仍然是空的。
- en: So, now the question would be, since `Seat` and `Cart` components are not directly
    related to each other, how will a `Seat` component communicate with the `Cart`
    component? Let's find an answer to this question.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在的问题是，由于`Seat`和`Cart`组件之间没有直接关联，`Seat`组件如何与`Cart`组件进行通信？让我们找到这个问题的答案。
- en: When components are not related or are related but too far away in the hierarchy,
    we can use an external event system to notify anyone who wants to listen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件之间没有关联或者关联但在层次结构中太远时，我们可以使用外部事件系统来通知任何想要监听的人。
- en: Redux is a popular choice to handle the data and events in a React application.
    It's a *simplified *version of the Flux pattern. Let's explore Redux in detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是处理React应用程序中的数据和事件的流行选择。它是Flux模式的简化版本。让我们详细探讨一下Redux。
- en: What is Redux?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux是什么？
- en: In this technological era, since the requirements for web applications have
    become increasingly complicated, the state management of an application has a
    lot of challenges at the code level. For example, in Realtime applications, a
    lot of data is stored in the cache for faster retrieval apart from the data that
    is persisted in the database. Similarly, on the UI side, due to complex User Interfaces
    such as multiple tabs, multiple routes, pagination, filters, and breadcrumbs and
    more, application state management becomes a very difficult task.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术时代，由于Web应用程序的要求变得越来越复杂，应用程序的状态管理在代码层面上面临许多挑战。例如，在实时应用程序中，除了持久化在数据库中的数据外，还有很多数据存储在缓存中以加快检索速度。同样，在UI方面，由于复杂的用户界面，如多个选项卡、多个路由、分页、过滤器和面包屑等，应用程序状态管理变得非常困难。
- en: In any application, different components exist, which interact with each other
    to produce a particular output or a state. There will also be chances that this
    interaction is so complex that you lost control over the application state. For
    example, a component or a model updating another component or a model that in
    turn causes an update of another view. This type of code is difficult to manage.
    It becomes challenging to add a new feature or fix any bugs because you don't
    know when a small change will affect another working functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，存在不同的组件，它们相互交互以产生特定的输出或状态。也会有可能这种交互是如此复杂，以至于您失去了对应用程序状态的控制。例如，一个组件或模型更新另一个组件或模型，进而导致另一个视图的更新。这种类型的代码很难管理。添加新功能或修复错误变得具有挑战性，因为您不知道一个小改变何时会影响另一个正在工作的功能。
- en: To reduce such issues, libraries like React removed the direct DOM manipulation
    and also asynchrony. However, it is only applied to view or presentation layer.
    The state management of your data is up to the application developers. This is
    where Redux comes into the picture.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这种问题，像React这样的库移除了直接的DOM操作和异步性。然而，这仅适用于视图或表示层。数据的状态管理取决于应用程序开发人员。这就是Redux出现的原因。
- en: 'Redux is a framework that manages states in a JavaScript app. This is what
    the official site says:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个管理JavaScript应用程序状态的框架。这是官方网站上说的：
- en: Redux is a predictable state container for JavaScript apps.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是JavaScript应用程序的可预测状态容器。
- en: Redux attempts to make state mutations predictable by imposing certain restrictions
    on how and when updates can happen. We will see what these restrictions are and
    how they work shortly, but before that, let's understand the core concept of Redux.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Redux试图通过对状态变化施加一定的限制来使状态变化可预测。我们将很快看到这些限制是什么，以及它们是如何工作的，但在此之前，让我们先了解Redux的核心概念。
- en: 'Redux is very simple. When we talk about Redux, we need to remember three core
    terms: Store, Action, and Reducer. Here''s what they are:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Redux非常简单。当我们谈论Redux时，我们需要记住三个核心术语：存储器、动作和Reducer。以下是它们：
- en: '**Store**: The state of your application will be managed by Store, which is
    an object that maintains the application''s state tree. Remember that there should
    be a single Store in your Redux app. Also, due to imposed restrictions, you can''t
    directly manipulate or mutate the application store.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储器**：应用程序的状态将由存储器管理，它是一个维护应用程序状态树的对象。请记住，在Redux应用程序中应该只有一个存储器。此外，由于施加了限制，您不能直接操作或改变应用程序存储器。'
- en: '**Action**: To change something in your store, you need to dispatch an Action.
    An action is nothing but a plain JavaScript object that describes what has happened.
    Actions allow us to understand what is happening in the app and why and hence
    makes the state predictable.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作**：要更改存储器中的内容，您需要分派一个动作。动作只是一个描述发生了什么的普通JavaScript对象。动作使我们能够理解应用程序中正在发生的事情以及为什么，因此使状态可预测。'
- en: '**Reducer**: Finally, to glue actions and state together, we write a Reducer,
    which is a simple JavaScript function that takes state and action as arguments
    and returns the new state of the app.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Reducer**：最后，为了将动作和状态联系在一起，我们编写一个Reducer，它是一个简单的JavaScript函数，接受状态和动作作为参数，并返回应用程序的新状态。'
- en: 'Since we now have a basic understanding of Redux, let’s check the three fundamental
    principles of Redux, which are as listed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在对Redux有了基本的了解，让我们来看看Redux的三个基本原则，如下所列：
- en: '**Single source of truth**: A store is simply a state container. As mentioned,
    in your React App, there should be only a single store and hence it is considered
    as source of Truth. A single object tree also makes it easy to debug the app.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一真相来源**：存储器只是一个状态容器。如前所述，在您的React应用程序中，应该只有一个存储器，因此它被视为真相的来源。单一对象树也使得调试应用程序变得容易。'
- en: '**State is Read Only**: To change the state, application has to emit an Action
    that describes what has happened. No views or other functions can directly write
    to the state. This restriction prevents any unwanted state changes. Each action
    will be performed on a centralized object and in order so that we can get an up-to-date
    state at any point of time. As actions are just plain objects, we can debug and
    serialize them for testing purposes.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**状态是只读的**：要更改状态，应用程序必须发出描述发生了什么的操作。没有视图或其他函数可以直接写入状态。这种限制可以防止任何不需要的状态更改。每个操作都将在一个集中的对象上执行，并且按顺序执行，以便我们可以在任何时间点获得最新的状态。由于操作只是普通对象，我们可以对它们进行调试和序列化以进行测试。'
- en: '**Changes are made with Pure Functions**: To describe transformation of the
    state tree by dispatched actions, write Pure Functions/Reducers. What does the
    term Pure Function mean? A function is pure if it returns the same value every
    time a given set of arguments is passed to it. Pure functions do not modify their
    input arguments. Instead, they use the input to calculate a value and then return
    that calculated value. Our reducers are pure functions that take state and action
    as inputs and return new state and not the mutated state. You can have as many
    reducers as you want, and it is also recommended that you split big reducers to
    smaller reducers that can manage a specific part of your application tree. Reducers
    are JavaScript functions, so you can pass additional data to them. They can be
    built like common functions, which can be used across the application of Presentational
    and Container components.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**纯函数进行更改**：要描述通过分派操作来转换状态树，编写纯函数/减速器。纯函数是什么意思？如果一个函数在传递给它的一组参数时每次返回相同的值，那么它就是纯的。纯函数不会修改它们的输入参数。相反，它们使用输入来计算一个值，然后返回该计算出的值。我们的减速器是纯函数，它们将状态和操作作为输入，并返回新状态而不是变异状态。您可以拥有尽可能多的减速器，并且建议将大的减速器拆分为可以管理应用程序树特定部分的小的减速器。减速器是JavaScript函数，因此您可以向它们传递附加数据。它们可以像普通函数一样构建，可以在展示和容器组件的整个应用程序中使用。'
- en: Presentational and Container components
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示和容器组件
- en: In our application, Seat List is responsible of fetching the data and rendering
    it. This is okay and works well for small or sample applications, but with this,
    we lose a few benefits of React, one of which is reusability. `SeatList` can't
    be reused easily unless under the exact same circumstances, so what's the solution?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，座位列表负责获取数据并呈现它。这对于小型或示例应用程序来说是可以的，并且效果很好，但是这样做，我们失去了React的一些好处，其中之一是可重用性。`SeatList`除非在完全相同的情况下，否则无法轻松重用，那么解决方案是什么？
- en: We know that this kind of issue is common across different programming languages,
    and we have solutions in terms of Design Patterns. Similarly, the solution to
    our problem is a pattern called **Container Component pattern**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这种问题在不同的编程语言中很常见，并且我们在设计模式方面有解决方案。同样，我们问题的解决方案是一种称为**容器组件模式**的模式。
- en: So, instead of our React component, out Container component will take the responsibility
    of fetching the data and passing it to the corresponding subcomponent. In simple
    terms, a container fetches the data and then renders its subcomponent.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的容器组件将负责获取数据并将其传递给相应的子组件，而不是我们的React组件。简单来说，容器获取数据，然后呈现其子组件。
- en: React bindings for Redux has also accepted the idea of separation of **Presentational
    and Container components. **Presentational Components are concerned about how
    things will look to the user rather than being concerned about how things will
    work. Similarly, Container components are concerned about how things work rather
    than how things look.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: React与Redux的绑定也接受了**展示组件和容器组件的分离**的想法。**展示组件**关注的是如何呈现给用户的外观，而不是关注事物如何运作。同样，容器组件关注的是事物如何运作，而不是外观。
- en: 'Let''s look at the comparison in this table:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个表格中的比较：
- en: '| **Presentational Components** | **Container Components** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **展示组件** | **容器组件** |'
- en: '| Concerned about the user view or how things will look | Concerned about the
    data and how things will work |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: 关注用户视图或事物外观的人 | 关注数据和事物如何运作的人
- en: '| Get/read data from parent components as props | Are connected to Redux State
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 从父组件中获取/读取数据作为props | 与Redux状态连接'
- en: '| Have DOM markup and styles on their own | Very less or no DOM markup and
    no styles on their own |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 有自己的DOM标记和样式 | 很少或没有自己的DOM标记和样式'
- en: '| Rarely Stateful | Are often Stateful |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 很少有状态 | 经常有状态'
- en: '| Handwritten | Can be handwritten or generated by React Redux |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 手写 | 可以手写或由React Redux生成'
- en: 'As we now know the difference between Presentational and Container Components,
    we should know the benefits of this separation of concerns:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了展示组件和容器组件之间的区别，我们应该知道这种关注点分离的好处：
- en: Reusability of components
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的可重用性
- en: Can reduce the duplicate code and have more manageable applications
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以减少重复的代码，使应用程序更易管理
- en: Different teams, such as Designers and JS/Application developers can work parallelly
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的团队，比如设计师和JS/应用程序开发人员可以并行工作
- en: Before we start integrating Redux into our app, let's go through the basic building
    blocks and API of Redux.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将Redux集成到我们的应用程序之前，让我们先了解Redux的基本构建模块和API。
- en: Basics of Redux
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux的基础知识
- en: Redux is quite simple, so don't be afraid by just looking at the fancy terms
    such as Reducers, Actions, and such. We will go through the basic building blocks
    of Redux application, and you will also feel the same.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Redux相当简单，所以不要被Reducers、Actions等花哨的术语吓到。我们将介绍Redux应用程序的基本构建模块，你也会感到同样简单。
- en: Actions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: As we saw at the beginning of the chapter, an action is nothing but a plain
    JavaScript object that describes what has happened. To change the state is to
    emit an action that describes what has happened. Also, for store, actions are
    only the source of truth or information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所看到的，一个操作只不过是一个描述发生了什么的普通JavaScript对象。改变状态就是发出描述发生了什么的操作。此外，对于存储，操作只是真相或信息的来源。
- en: Here's an example action creator.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例操作创建者。
- en: 'Each action type should be defined as a constant:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每种操作类型都应该被定义为一个常量：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `type` of an action describes the kind of the action that has occurred.
    If your application is large enough, you may separate out the action types as
    string constants to a separate module/file and use it in actions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的“类型”描述了已发生的操作的种类。如果你的应用程序足够大，你可以将操作类型分离为字符串常量，放到一个单独的模块/文件中，并在操作中使用它。
- en: Now, you might be having a question—what should be the structure of my action
    ? We
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会有一个问题——我的操作应该是什么结构？我们
- en: have here type and then have directly added rows. The answer to your question
    is that except the type, you can have any structure of your action. However, there
    is a standard for defining an action.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有类型，然后直接添加了行。对于你的问题的答案是，除了类型，你可以有任何结构的操作。然而，有一个标准来定义一个操作。
- en: An action must be a JavaScript Object and must have a type property. Also, an
    action may have an error or payload property. The payload property can be any
    type of value. In the preceding example, `rows` represent a payload.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 动作必须是JavaScript对象，并且必须具有类型属性。此外，动作可能具有错误或有效负载属性。有效负载属性可以是任何类型的值。在前面的示例中，`rows`代表有效负载。
- en: Action creators
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作创建者
- en: Action creators are functions that create actions; for example, `function fetchSeats(){return{type:FETCH_SEATS,rows}}`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 操作创建者是创建动作的函数；例如，`function fetchSeats(){return{type:FETCH_SEATS,rows}}`。
- en: Actions often trigger a dispatch when invoked, for example, `dispatch(fetchSeats(seats))`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 操作通常在调用时触发分派，例如，`dispatch(fetchSeats(seats))`。
- en: Note that action creators can also be asynchronous and hence we need to handle
    async flow in our logic. It is an advanced topic and can be referred to on the
    Redux website.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操作创建者也可以是异步的，因此我们需要在逻辑中处理异步流。这是一个高级主题，可以在Redux网站上查阅。
- en: Reducers
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减速器
- en: Actions only specify what has happened but do not specify what is the effect
    of that action on the application state. The reducer function specifies how the
    application state is changed. It is a pure function that takes the two arguments—previous
    state and an action—and returns the next updated state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 动作只指定发生了什么，但不指定该动作对应用程序状态的影响是什么。减速器函数指定了应用程序状态如何更改。它是一个纯函数，接受两个参数——先前的状态和一个动作——并返回下一个更新的状态。
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Things you should **never** do inside a reducer:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您在减速器内部**绝对不要**做的事情：
- en: Modify its arguments
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改其参数
- en: API calls and routing
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API调用和路由
- en: Call other non-pure functions, for example, `Date.now()`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用其他非纯函数，例如，`Date.now()`
- en: In Redux, a single object represents the application state. So, before we write
    any code, it is very important to think and decide the structure of the application
    state object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux中，一个对象代表应用程序状态。因此，在编写任何代码之前，非常重要的是考虑和决定应用程序状态对象的结构。
- en: It is recommended that we keep our state object as normalized as possible and
    avoid nesting of objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 建议我们尽可能使我们的状态对象规范化，并避免对象的嵌套。
- en: Store
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店
- en: As described initially, the store is the main object that holds the application
    state tree. It's important to note that there will be a single store in a Redux
    application. When there is a requirement of splitting the data handling logic,
    you'll use the Reducer Composition pattern instead of creating many stores.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如最初所述，商店是保存应用程序状态树的主要对象。重要的是要注意，在Redux应用程序中将只有一个商店。当需要拆分数据处理逻辑时，您将使用Reducer
    Composition模式，而不是创建许多商店。
- en: 'The following methods are available for Store:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 商店有以下方法可用：
- en: '`getState()`: Gives the current state tree of the application'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`: 给出应用程序的当前状态树'
- en: '`dispatch(action)`: Used to dispatch an action'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch(action)`: 用于分派动作'
- en: '`subscribe(listener)`: Subscribe to the store changes'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(listener)`: 订阅商店更改'
- en: '`replaceReducer(nextReducer)`: It is an advanced API that replaces the currently
    used Reducer by Store'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceReducer(nextReducer)`: 这是一个高级API，用于替换商店当前使用的Reducer'
- en: Data flow
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: We have seen the core components of the Redux architecture. Now, let's understand
    how all these components actually work together. Redux architecture supports only
    single directional data flow, as illustrated in the following diagram. This means
    that all the data in an application passes through the defined workflow in a single
    direction, which makes the logic of your application more easy.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Redux架构的核心组件。现在，让我们了解所有这些组件实际上是如何一起工作的。Redux架构仅支持单向数据流，如下图所示。这意味着应用程序中的所有数据都通过单向定义的工作流程，使您的应用程序逻辑更加简单。
- en: '![](Images/50dda9ee-e249-413a-9f9c-166313267921.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/50dda9ee-e249-413a-9f9c-166313267921.jpg)'
- en: Advanced topics in Redux
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux中的高级主题
- en: Once you are through the basics, there are some advanced topics to go through,
    such as **React Router**, **Ajax and Async Actions**, and **Middleware**. We will
    not cover them here since they are out of the scope of this book. However, we
    will just look at the important topic of Middleware in brief.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您掌握了基础知识，还有一些高级主题需要学习，例如**React Router**、**Ajax和异步动作**和**中间件**。我们不会在这里涵盖它们，因为它们超出了本书的范围。但是，我们将简要讨论中间件这个重要主题。
- en: By default, Redux supports synchronous data flow only. To have asynchronous
    data flow, you will need to use Middleware. Middleware is nothing but a framework
    or library that provides a wrapper for your dispatch method and allows to pass
    functions and promises rather than just actions. Middleware is being used to mainly
    support asynchronous actions. There are many middlewares out there, such as redux-thunk
    for asynchronous actions. Middlewares are also useful for logging or crash reporting.
    We will also use redux-thunk in our application. To enhance `createStore()`, we
    need to use the `applyMiddleware(...middleware)` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Redux仅支持同步数据流。要实现异步数据流，您需要使用中间件。中间件只是一个为您的调度方法提供包装器并允许传递函数和承诺而不仅仅是动作的框架或库。中间件主要用于支持异步动作。有许多中间件，例如用于异步动作的redux-thunk。中间件还可用于日志记录或崩溃报告。我们还将在我们的应用程序中使用redux-thunk。要增强`createStore()`，我们需要使用`applyMiddleware(...middleware)`函数。
- en: Seat booking with Redux
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux进行座位预订
- en: Let's enhance our seat booking app by integrating the Redux.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成Redux来增强我们的座位预订应用程序。
- en: 'We can install React Bindings explicitly, using the following command, since
    they are not included in Redux by default:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以显式安装React绑定，使用以下命令，因为它们不是默认包含在Redux中的：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we will extend our seat booking app by integrating Redux. There will be
    a lot of changes as it will impact all of our components. Here, we will start
    with our entry point.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过集成Redux来扩展我们的座位预订应用程序。这将会对我们所有的组件产生很多变化。在这里，我们将从我们的入口点开始。
- en: '`src/index.js`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/index.js`：'
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s understand our code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们的代码：
- en: '`<Provide store>`: Makes the Redux Store available to the component hierarchy.
    Note that you cannot use `connect()` without wrapping a parent component in a
    provider.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Provide store>`：使Redux Store可用于组件层次结构。请注意，您不能在没有包装父组件的情况下使用`connect()`。'
- en: '`<SeatBookingApp>`: It is our parent component and will be defined under Container
    components package. It will have code similar to what we have in `App.js`, which
    we saw earlier.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<SeatBookingApp>`：这是我们的父组件，并将在容器组件包中定义。它将具有类似于我们之前在`App.js`中看到的代码。'
- en: '`Middleware`: It is like an interceptor in other languages that provides a
    third-party extension point between dispatching an action and the moment it reaches
    the reducer, for example, Logging or Logger. If you don''t apply a middleware,
    you would need to add loggers manually in all the actions and reducers.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件：它类似于其他语言中的拦截器，提供了在派发动作和达到减速器之间的第三方扩展点，例如日志记录或记录器。如果不应用中间件，您将需要在所有动作和减速器中手动添加记录器。
- en: '`applyMiddleware`: It tells Redux store how to handle and set up the middleware.
    Note the usage of a rest parameter (...middleware); it denotes that the `applyMiddleware`
    function accepts multiple arguments (any number) and can get them as an array.
    A key feature of Middleware is that multiple middleware can be combined together.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applyMiddleware`：它告诉Redux存储如何处理和设置中间件。请注意rest参数（...middleware）的使用；它表示`applyMiddleware`函数接受多个参数（任意数量）并可以将它们作为数组获取。中间件的一个关键特性是可以将多个中间件组合在一起。'
- en: We will also need to change our presentational components little bit as per
    Redux state management.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Redux状态管理，我们还需要稍微更改我们的展示组件。
- en: Let's start with Cart component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从购物车组件开始。
- en: '`components/Cart.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/Cart.js`:'
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our cart component receives a checkout function from the parent component that
    will dispatch checkout action along with seats, which are added in cart.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的购物车组件从父组件接收一个结账函数，该函数将分发结账操作以及添加到购物车中的座位。
- en: '`components/Seat.js`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/Seat.js`:'
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our Seat component receives its state from the parent component along with the `handleClick`
    function that dispatches the `ADD_TO_CART` action.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的座位组件从父组件接收其状态，以及分发`ADD_TO_CART`操作的`handleClick`函数。
- en: '`components/SeatList.js`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/SeatList.js`:'
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`SeatList` receives seats data from the container component.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeatList`从容器组件接收座位数据。'
- en: '`components/SeatRow.js`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`components/SeatRow.js`:'
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`SeatRow` receives all seats for that particular row.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeatRow`接收该特定行的所有座位。'
- en: Let's check our container components.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的容器组件。
- en: '`containers/SeatBookingApp.js`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`containers/SeatBookingApp.js`:'
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is our parent component and includes the other child container components:
    `SeatContainer` and `CartContainer`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它是我们的父组件，并包括其他子容器组件：`SeatContainer`和`CartContainer`。
- en: '`container/SeatCartContainer.js`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`container/SeatCartContainer.js`:'
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This container component will be interacting with the store and will pass data
    to child component—Cart.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器组件将与存储交互，并将数据传递给子组件 - 购物车。
- en: 'Let''s understand the code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解代码：
- en: '`mapStateToProps`: It is a function that will be called each time the Store
    is updated which means component is subscribed to store updates.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mapStateToProps`: 这是一个函数，每次存储更新时都会调用它，这意味着组件订阅了存储更新。'
- en: '`{bookSeats}`: It can be a function or an object that Redux provides so that
    container can easily pass that function to the child component on its props. We
    are passing the `bookSeats` function so that the `Checkout` button in the Cart
    component can call it.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{bookSeats}`: 它可以是Redux提供的一个函数或对象，以便容器可以轻松地将该函数传递给其子组件的props。我们传递`bookSeats`函数，以便购物车组件中的“结账”按钮可以调用它。'
- en: '`connect()`: Connects a React component to a Redux store.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect()`: 将React组件连接到Redux存储。'
- en: Let's see our next container—`SeatContainer`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个容器 - `SeatContainer`。
- en: '`containers/SeatContainer.js`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`containers/SeatContainer.js`:'
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As explained earlier for `CartContainer`, we will have a similar code structure
    for `SeatContainer`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于`CartContainer`，我们将为`SeatContainer`有类似的代码结构。
- en: Now, we will create a `constants` file that defines the constants for our `Actions`.
    Though you can directly define constants in the file where you have your action,
    it is a good practice to define the constants in a separate file as it is much
    easier to maintain the clean code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`constants`文件，定义我们的`Actions`的常量。虽然您可以直接在操作文件中定义常量，但将常量定义在单独的文件中是一个很好的做法，因为这样更容易维护清晰的代码。
- en: '`constants/ActionTypeConstants.js`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`constants/ActionTypeConstants.js`:'
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will have three actions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有三个操作：
- en: '`GET_SEATS`: To fetch the seats data from Firebase and populate on UI'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取座位：从Firebase获取座位数据并在UI上填充
- en: '`ADD_TO_CART`: To add the selected seats in user cart'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD_TO_CART`: 将选定的座位添加到用户购物车中'
- en: '`CHECKOUT`: Book the seats'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHECKOUT`: 预订座位'
- en: Let's define the actions in a file called `index.js`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为`index.js`的文件中定义操作。
- en: '`actions/index.js`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions/index.js`:'
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Actions** send data from your application to your store using the `dispatcher()`
    method. Here, we have two functions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**使用`dispatcher()`方法将数据从应用程序发送到存储。在这里，我们有两个函数：'
- en: '`fetchSeats()`: It is action creator, which creates the `GET_SEATS` action'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchSeats()`: 它是一个操作创建者，用于创建`GET_SEATS`操作'
- en: '`getAllSeats()`: It is actual action that dispatches data to store, which we
    get by calling the `getSeats()` method of our service'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAllSeats()`: 这是一个实际的操作，通过调用我们的服务的`getSeats()`方法获取数据并将其分发到存储中'
- en: 'Likewise, we can define our actions for the rest of the two actions: `ADD_TO_CART`
    and `CHECKOUT`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为另外两个操作定义我们的操作：`ADD_TO_CART`和`CHECKOUT`。
- en: Now, let's see the reducers. We will start with seats reducer.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看reducers。我们将从座位reducer开始。
- en: '`reducers/seats.js`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers/seats.js`：'
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s understand this piece of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解这段代码：
- en: '`combineReducers`: We have split our Reducer into different functions—`rowIds`
    and `seatRow`—and defined the root reducer as a function that calls the reducers
    managing different parts of the state and combines them into a single object'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineReducers`：我们将Reducer拆分为不同的函数——`rowIds`和`seatRow`——并将根reducer定义为调用管理状态不同部分的reducer的函数，并将它们合并为一个单一对象'
- en: Similarly, we will have cart reducer.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将有购物车reducer。
- en: '`reducers/cart.js`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers/cart.js`：'
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It exposes reducer functions related to cart operations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它公开了与购物车操作相关的reducer函数。
- en: Now, we will have a final combine reducer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将有一个最终的combine reducer。
- en: '`reducers/index.js`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers/index.js`：'
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is a `combineReducers` for seats and cart. It also exposes some common function
    to calculate total in cart and to get the seats added in cart. That's it. We have
    finally introduced Redux to manage our state of the application, and we have our
    seat booking app ready using React, Redux, and Firebase.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它是座位和购物车的`combineReducers`。它还公开了一些常用函数来计算购物车中的总数，以及获取购物车中添加的座位。就是这样。我们最终引入了Redux来管理我们应用程序的状态，并且使用React、Redux和Firebase准备好了我们的座位预订应用程序。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored React and Firebase in depth. We talked about the
    structure of the data in Firebase database and have seen that we should avoid
    data nesting as much as possible. We have also seen the usage of the `on` and
    `once` methods with respect to data reading and also the event called 'value',
    which gets fired when data changes in your database. We also went through the
    core concepts of Redux and saw how easy it is to use Redux for the state management
    of the application. We also looked at the difference between Presentational and
    Container components and how they should be designed. Then, we talked about the
    basics of Redux and also talked briefly about the advanced topics of Redux.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了React和Firebase。我们谈到了Firebase数据库中的数据结构，并且看到我们应该尽可能避免数据嵌套。我们还看到了关于数据读取的`on`和`once`方法以及在数据库中数据发生变化时触发的“value”事件。我们还学习了Redux的核心概念，并看到了使用Redux来管理应用程序状态有多么容易。我们还讨论了展示组件和容器组件之间的区别以及它们应该如何设计。然后，我们讨论了Redux的基础知识，也简要讨论了Redux的高级主题。
- en: Moreover, we created a seat booking application with the usage of all three—React,
    Redux and Firebase—and saw a real-life practical example of the smooth integration
    of all them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用了React、Redux和Firebase创建了一个座位预订应用程序，并看到了它们顺利集成的实际实例。
- en: In the next chapter, we will explore Firebase Admin SDK and see how to implement
    User and Access Management.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Firebase Admin SDK，并看看如何实现用户和访问管理。
