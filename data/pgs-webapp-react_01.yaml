- en: Creating Our App Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用结构
- en: Welcome to *Progressive Web Apps with React*!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*使用React构建渐进式Web应用*！
- en: This book will take you through the entire process of building a React application
    that also functions as a Progressive Web App. We'll cover not only the "how" of
    constructing such an application, but also highlight best practices and how to
    measure your application to ensure successful implementation of PWA features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将带您完成构建一个React应用程序，同时也作为渐进式Web应用程序的整个过程。我们将涵盖构建此类应用程序的“如何”，还将强调最佳实践以及如何衡量您的应用程序，以确保成功实施PWA功能。
- en: Progressive Web Apps are poised to become the future of web applications. They
    promise a bevy of additional functionality, such as push notifications and the
    ability to be installed, which pushes them into the realm of native iOS or Android
    apps. Additionally, a strong focus on performance (taking advantage of cutting-edge
    web technology) means that PWAs create apps that are fast for everyone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式Web应用程序有望成为Web应用程序的未来。它们承诺提供一系列额外功能，如推送通知和可安装性，将它们推向原生iOS或Android应用程序的领域。此外，对性能的强调（利用尖端的Web技术）意味着PWAs创建的应用程序对所有人都很快。
- en: We'll cover each facet of PWAs in depth, as well as the process of converting
    a regular web application into a progressive one. We'll also dive deep into React
    best practices, using libraries such as React Router.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入讨论PWAs的每个方面，以及将常规Web应用程序转换为渐进式应用程序的过程。我们还将深入研究React最佳实践，使用诸如React Router之类的库。
- en: To check your code for this and future chapters, you can view the completed
    project at [https://github.com/scottdomes/chatastrophe/](https://github.com/scottdomes/chatastrophe/).
    The repository includes branches for each chapter. Visit [https://github.com/scottdomes/chatastrophe/tree/chapter1](https://github.com/scottdomes/chatastrophe/tree/chapter1)
    for this chapter's final code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查本章和未来章节的代码，您可以在[https://github.com/scottdomes/chatastrophe/](https://github.com/scottdomes/chatastrophe/)上查看已完成的项目。该存储库包括每个章节的分支。访问[https://github.com/scottdomes/chatastrophe/tree/chapter1](https://github.com/scottdomes/chatastrophe/tree/chapter1)查看本章的最终代码。
- en: 'In this chapter, we will get started with the basic structure of our application.
    Here''s what we''ll cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将开始应用的基本结构。以下是我们将涵盖的内容：
- en: The use cases of Progressive Web Apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式Web应用的用例
- en: The basic user stories we want our app to fulfill
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的应用程序实现的基本用户故事
- en: The project structure and basic HTML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构和基本HTML
- en: Installing dependencies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装依赖
- en: Getting started with React
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用React
- en: First, let's set the scene for our application's journey.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们应用的旅程设定场景。
- en: Setting the scene
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设定场景
- en: One of your friends calls you on the phone, bursting with excitement about his
    latest start-up idea (you know the one). You patiently listen to his description,
    but respectfully decline to be a part of it. He's disappointed, but understands
    and promises to keep you updated on the project details. You murmur your assent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的一个朋友打电话给你，兴奋地谈论他最新的创业想法（你知道的那个）。你耐心地听他的描述，但尊敬地拒绝成为其中的一部分。他很失望，但理解并承诺会随时向你更新项目的详情。你咕哝着表示同意。
- en: A few months later, he meets you at your work and announces that he has found
    a group of serious investors, and he needs you to help him build the software
    he promised them. You again decline, but when discussing compensation, he mentions
    a number that you can't refuse. A week later, you're on a plane to San Francisco.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月后，他在你的工作地点见到你，并宣布他找到了一群认真的投资者，他需要你帮助他建立他向他们承诺的软件。你再次拒绝，但在讨论报酬时，他提到了一个你无法拒绝的数字。一周后，你坐飞机去了旧金山。
- en: In front of the investors (who are, to your surprise, a rapt audience), your
    friend guides you through the basics of the application. In between the buzzwords
    ("mass interconnection" and "global community"), you gather just enough to summarize
    the application in a sentence.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资者面前（令你惊讶的是，他们是一个全神贯注的观众），你的朋友向你介绍了应用程序的基础知识。在充斥着流行语（“大规模互联”和“全球社区”）之间，你收集到了足够的信息，可以用一句话总结这个应用程序。
- en: '"So, it''s a chat room… for everyone in the world… all at once…"'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “所以，这是一个聊天室…为世界上的每个人…一次…”
- en: Your friend smiles. "Yes."
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友微笑着说：“是的。”
- en: You're bewildered by the image of a million strangers all talking at once on
    the same application, in the same room, but the investors break into applause.
    As you head for the door, your friend again announces how they'd like to compensate
    you… citing an even higher number than before. You sit down.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你被一百万陌生人同时在同一个应用程序中交谈的画面所困惑，但投资者们却掌声雷动。当你走向门口时，你的朋友再次宣布他们想要补偿你…提到了比之前更高的数字。你坐下来。
- en: The problem
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '"The problem," your friend explains, "is that this chat room has to be for
    everyone."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “问题是，”你的朋友解释道，“这个聊天室必须是为每个人而设的。”
- en: '"Global community," you say with a knowing nod.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “全球社区，”你带着一个知情的点头说道。
- en: '"Exactly. Everyone. Even if they have terrible internet in some hut in the
    desert. They should be included."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “确切地说。每个人。即使他们在沙漠中的小屋里有糟糕的互联网。他们也应该被包括在内。”
- en: '"Mass interconnection," you add.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “大规模互联”，你补充道。
- en: '"Exactly! So it needs to be fast. And lightweight. And beautiful. And dynamic."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “确切地说！所以它需要快速。轻巧。美观。动态。”
- en: '"So everyone will be talking at once? Won’t that be-"'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “所以每个人都会同时交谈？那不会是-”
- en: '"A worldwide collective, yes."'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “一个全球性的集体，是的。”
- en: The other problem
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个问题
- en: '"The other problem," your friend declares, "is that our users will mostly be
    on their phones. On the go."'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “另一个问题，”你的朋友宣布道，“是我们的用户大多会使用手机。在路上。”
- en: '"So you want to do an iOS and Android app?"'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “所以你想做一个iOS和Android应用？”
- en: Your friend waves his hand. "No, no. No one downloads apps anymore. Especially
    in developing countries; that takes too much bandwidth. Remember, worldwide collective."
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友挥了挥手。“不，不。没人再下载应用了。尤其是在发展中国家；那需要太多带宽。记住，全球性的集体。”
- en: '"So a web app."'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: “所以是一个网页应用。”
- en: '"Yes. A web collective."'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “是的。一个网页集体。”
- en: Despite your best instincts, the project intrigues you. How do you craft a web
    application to be as fast as possible? How do you make it work under all network
    conditions? How do you make a chat application with all the conveniences of a
    native app, but for the web?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的直觉告诉你，这个项目很有趣。你如何设计一个网页应用程序尽可能快？如何使它在所有网络条件下工作？如何制作一个具有原生应用所有便利性的聊天应用，但是用于网页？
- en: You sigh and shake his hand. "Let's get to work."
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你叹了口气，握了握他的手。“让我们开始工作吧。”
- en: Beginning work
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始工作
- en: Welcome to the world of Progressive Web Applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到渐进式网页应用的世界。
- en: In the preceding scenario, the problems your friend was describing are exactly
    the problems **PWAs** (**Progressive Web Applications**) are crafted to solve.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情景中，你的朋友描述的问题正是**PWA**（渐进式网页应用）被设计解决的问题。
- en: The first problem is that many users will be visiting your web page under poor
    network conditions. They may be a Silicon Valley technocrat on their iPhone in
    a coffee shop with bad WiFi, or they may be a Bangladeshi villager in a remote
    location. Either way, they will not stick around if your site isn't optimized
    for them, for everyone.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是，许多用户将在较差的网络条件下访问你的网页。他们可能是硅谷的技术专家，在咖啡店里用iPhone，WiFi信号不好，或者他们可能是孟加拉国的村民在偏远地区。无论如何，如果你的网站对他们没有优化，他们就不会留下来。
- en: How fast your application loads--its performance--thus becomes an accessibility
    concern. PWAs solve this by loading quickly the first time, and even more quickly
    every time after that. We'll talk more about how they do so as the book progresses.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序加载速度有多快——它的性能——因此成为一个可访问性问题。PWA通过第一次快速加载，以及之后每次更快地加载来解决这个问题。随着本书的进展，我们将更多地讨论它们是如何做到的。
- en: Second, the installation process for mobile apps is an obstacle for users. It
    means that your users need to be extra committed to engaging with your application--enough
    to give up storage space and time, and expose themselves to the possibility of
    malicious and intrusive code, and that's before they even get the chance to try
    the app!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，移动应用程序的安装过程对用户来说是一个障碍。这意味着您的用户需要更加致力于使用您的应用程序——足够多以放弃存储空间和时间，并使自己暴露于恶意和侵入性代码的可能性之中，甚至在他们有机会尝试应用程序之前！
- en: What if we can provide the native app experience without the initial investment?
    PWAs are an attempt to bridge that gap. Again, we'll talk in subsequent chapters
    about how they do so, and how successful they actually are. However, these are
    both worthy challenges, and solving both will be a huge user experience win for
    our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以在没有初始投资的情况下提供原生应用程序体验会怎样？PWA试图弥合这一差距。同样，我们将在随后的章节中讨论它们是如何做到的，以及它们实际上有多成功。然而，这两者都是值得挑战的，并解决这两个问题将对我们的应用程序的用户体验产生巨大的影响。
- en: Why Progressive Web Apps?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择渐进式Web应用程序？
- en: Many static web pages do a fantastic job of performance. However, when all you
    need to do is render some HTML, CSS, and a smattering of JavaScript, it's less
    of a struggle to work well under all network conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多静态网页在性能方面做得非常出色。然而，当您只需要渲染一些HTML、CSS和少量JavaScript时，在各种网络条件下工作就不那么困难了。
- en: When we start talking about web applications--large, complex, JavaScript-based
    workhorses--performance becomes a significant challenge. Our frontend will have
    a lot of code. Our user needs to download all that code if they want to use our
    app to its fullest potential. How do we ensure that they're not staring at a blank
    loading screen for ten seconds, as 500 KB of JavaScript initializes?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始谈论Web应用程序——大型、复杂的、基于JavaScript的工作马——性能就成为一个重大挑战。我们的前端将有大量的代码。如果用户想要充分利用我们的应用程序，他们需要下载所有这些代码。我们如何确保他们不会在空白的加载屏幕前等待十秒，当500KB的JavaScript初始化时？
- en: Therefore, most of our performance enhancements will center around managing
    the JavaScript problem. This is especially true with React.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们大部分的性能增强将集中在解决JavaScript问题上。这在使用React时尤其如此。
- en: Why React?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择React？
- en: '**React** is quickly becoming the go-to solution for frontend web applications.
    Why? This is because it''s fast, elegant, and makes managing large applications
    easy.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**React**正在迅速成为前端Web应用程序的首选解决方案。为什么？因为它快速、优雅，并且使管理大型应用程序变得容易。'
- en: In other words, it makes complexity simple. There's no reason a PWA has to use
    React, though. PWAs can be any web app or site.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它使复杂性变得简单。当然，PWA不一定要使用React。PWA可以是任何Web应用程序或网站。
- en: React does have one major benefit--its component pattern, where UIs are split
    into distinct pieces. As we'll see, the component pattern lets us break our interface
    into small chunks of code to alleviate the preceding JavaScript downloading issue.
    However, other than that, any frontend framework will work just as well for a
    PWA.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: React确实有一个主要的好处——它的组件模式，其中UI被分割成不同的部分。正如我们将看到的，组件模式让我们将界面分解成小的代码块，以减轻之前的JavaScript下载问题。然而，除此之外，任何前端框架对于PWA来说都同样有效。
- en: The advantage of React is that it is a beautiful and fun way to build frontend
    applications. It's also an in-demand skill. If you pair knowledge of React with
    experience with PWAs, you'll be about as future-ready as one can be in the fast-moving
    web development world.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React的优势在于它是构建前端应用程序的一种美丽而有趣的方式。这也是一种需求技能。如果你将对React的了解与PWA的经验相结合，你将成为快速发展的Web开发世界中未来准备的人。
- en: A rose by any other name
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 换个名字也一样
- en: You tell your friend about your learnings on PWAs and React, but before you
    finish, he waves his hand and interrupts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你告诉你的朋友关于你在PWA和React上的学习，但在你结束之前，他挥了挥手打断了你。
- en: '"Yeah, yeah. Hey, what do you think the name should be?"'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，是的。嘿，你觉得名字应该是什么？”
- en: Once again, you're struck with the unnerving feeling that all of this was a
    mistake, that you never should have jumped on board this questionable venture,
    this potential catastrophe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，你被一种不安的感觉击中，觉得所有这一切都是一个错误，你永远不应该加入这个可疑的冒险，这个潜在的灾难。
- en: '"Chatastrophe," you blurt out.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “灾难性的对话”，你脱口而出。
- en: Your friend smiles and claps you on the back. "Brilliant. Okay, get Reacting
    or whatever!"
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友微笑着拍了拍你的背。“太棒了。好了，开始反应或者其他什么！”
- en: User stories
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户故事
- en: Before we begin building our app, let's take a deeper look at what exactly we
    want to achieve.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建应用程序之前，让我们更深入地了解我们到底想要实现什么。
- en: We can start with user stories. A user story is a description of a specific
    feature of an application, framed from the perspective of one of our users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从用户故事开始。用户故事是应用程序特定功能的描述，从我们用户的角度出发。
- en: 'Here''s the framework, as suggested by *Jon Dobrowolski*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由*Jon Dobrowolski*建议的框架：
- en: Users should be able to _____.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够_____。
- en: As a user, I want to do ___ because ____.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，我希望做___，因为____。
- en: Given that I'm doing ___, I should be able to ___ in order to ___.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我正在做___，我应该能够___以便___。
- en: 'Not all features require the whole framework, though. Let''s start with some
    basic examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有功能都需要整个框架。让我们从一些基本的例子开始：
- en: Users should be able to log in and out of the application
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够登录和退出应用程序
- en: Pretty straightforward. I don't think we need to add the justification for this,
    as it is a fairly basic feature.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相当简单。我认为我们不需要为此添加理由，因为这是一个非常基本的功能。
- en: 'Let''s move on to something more advanced:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向更高级的东西：
- en: Users should be able to view their messages even when offline
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在离线状态下查看他们的消息
- en: As a user, I want to be able to check my messages without needing an internet
    connection, because I may need to read them on the go
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我希望能够在不需要互联网连接的情况下检查我的消息，因为我可能需要在外出时阅读它们
- en: Given that I start the application without internet access, I should be able
    to view all past messages
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我在没有互联网访问的情况下启动应用程序，我应该能够查看所有过去的消息
- en: Let's cover some of the more basic functionality of the app. Users should be
    able to send and receive messages in real-time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看应用程序的一些更基本的功能。用户应该能够实时发送和接收消息。
- en: 'Real-time functionality will be key to our application. There''s no point in
    having chat unless it''s fast and fluid:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实时功能将是我们应用程序的关键。除非快速而流畅，否则聊天没有意义：
- en: Users should be able to view all messages by a given author
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够查看特定作者的所有消息
- en: As a user, I want to be able to view a list of all messages sent by a given
    user, because I may need to view their contribution to the conversation without
    the noise of others' messages
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我希望能够查看特定用户发送的所有消息列表，因为我可能需要查看他们在对话中的贡献，而不受其他消息的干扰
- en: Given that I click on a user's email, I should be taken to a profile view with
    all their messages
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我点击用户的电子邮件，我应该被带到一个包含他们所有消息的个人资料视图
- en: The profile view is a special feature you suggested to the client to manage
    the inevitable chaos of the main chat room.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料视图是您向客户建议管理主要聊天室不可避免的混乱的特殊功能。
- en: 'Let''s add a couple more PWA-specific user stories:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加几个更多的PWA特定用户故事：
- en: Users should receive push notifications when a message is sent by another user
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该在其他用户发送消息时收到推送通知
- en: As a user, I want to be constantly updated on the progress of the conversation,
    because I don't want to miss anything important
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我希望能够不断更新对话的进展，因为我不想错过任何重要的内容
- en: Given that the chat is not open or visible on my screen, I should receive notifications
    for each message sent by another user
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设聊天室在我的屏幕上没有打开或可见，我应该收到另一个用户发送的每条消息的通知
- en: 'And installing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并安装：
- en: Users should be able to install the app on their mobile device
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在他们的移动设备上安装应用程序
- en: As a user, I want to be able to open the application without navigating to the
    URL in my browser, because I want easy access to the chat room
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我希望能够打开应用程序，而不必在浏览器中导航到URL，因为我希望轻松访问聊天室
- en: Given that I have signed up to the chat for the first time, I should be prompted
    to install the app on my device
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我是第一次注册聊天，我应该被提示在我的设备上安装应用程序
- en: Don't worry about how we will achieve these goals; we'll cover that in due time.
    For now, let's just continue documenting what we want to do.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心我们将如何实现这些目标；我们将及时解决这个问题。现在，让我们继续记录我们想要做的事情。
- en: 'Our client was big on performance, so let''s specify some performance-specific
    goals:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户非常重视性能，所以让我们指定一些性能特定的目标：
- en: Users should be able to load the app in under 5 seconds, even under shaky network
    conditions
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在不稳定的网络条件下在5秒内加载应用程序
- en: As a user, I want to be able to interact with the app as quickly as possible,
    because I don't want to be stuck waiting for it to load
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我希望能够尽快与应用程序交互，因为我不想被困在等待加载的过程中
- en: Given that I have opened the application using a poor internet connection, I
    should still have it load in under 5 seconds
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我使用较差的互联网连接打开应用程序，我仍然应该在5秒内加载
- en: Load in under 5 seconds is still a bit vague in terms of what that means for
    our application. We'll revisit this story in more depth in the chapters on performance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在5秒内加载对于我们的应用程序来说仍然有点模糊。我们将在性能章节中更深入地重新讨论这个故事。
- en: The previously mentioned user stories cover the basic functionality of our app.
    Let's talk about the specific challenges these points present.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的用户故事涵盖了我们应用程序的基本功能。让我们谈谈这些要点所提出的具体挑战。
- en: Application challenges
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序挑战
- en: With each of the following, I encourage you to think about how you will solve
    these problems within the context of a web application. Hopefully, this will give
    you a better insight into what we try to achieve with PWAs, and the difficulties
    we face.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每一点，我鼓励您考虑如何在Web应用程序的背景下解决这些问题。希望这能让您更好地了解我们尝试通过PWA实现的目标以及我们面临的困难。
- en: Instant loading
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时加载
- en: With Progressive Web Apps, we aim to provide an experience that is closer to
    a native app (one downloaded from the Apple App Store, Google Play Store, or another
    app store) than your typical web application. One of the advantages native apps
    have, of course, is that all relevant files are predownloaded and installed, while
    each time a user visits a web application, they may have to download all the assets
    again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过渐进式Web应用程序，我们的目标是提供一种更接近原生应用程序（从Apple应用商店、Google Play商店或其他应用商店下载的应用程序）的体验，而不是您典型的Web应用程序。当然，原生应用程序的一个优势是所有相关文件都是预先下载和安装的，而每次用户访问Web应用程序时，他们可能需要重新下载所有资产。
- en: The solution? When the user first visits the page, download those assets and
    then save them for later (also known as caching). Then, when the user reopens
    the application, instead of downloading the files again over the internet (slow),
    we simply retrieve them from the user's device (fast).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案？当用户首次访问页面时，下载这些资产然后保存它们以备后用（也称为缓存）。然后，当用户重新打开应用程序时，我们不再通过互联网下载文件（慢），而是从用户设备中检索它们（快）。
- en: However, this only works for when the user revisits the application. For the
    initial visit, we still have to download everything. This situation is particularly
    precarious, because when the user first visits Chatastrophe, they're not yet sold
    on its value, and so, are likely to leave (for good) if loading takes too long.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅适用于用户再次访问应用程序的情况。对于初始访问，我们仍然需要下载所有内容。这种情况特别危险，因为当用户首次访问Chatastrophe时，他们还没有意识到其价值，所以如果加载时间太长，他们很可能会离开（永远）。
- en: We need to ensure that our assets are as optimized as possible, and we download
    as little as possible on that first visit, so that the user stays around.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的资产尽可能优化，并且在第一次访问时尽可能少地下载，以便用户留下来。
- en: In short, fast loading for the first visit, near-instant loading for every subsequent
    visit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，第一次访问快速加载，随后每次访问几乎立即加载。
- en: Push notifications
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送通知
- en: There's no point in a chat application without notifications! Again, we're trying
    to emulate what has traditionally been a native app feature--push notifications
    directly to the user's device.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有通知的聊天应用是没有意义的！再次强调，我们正在尝试模拟传统上是原生应用功能的内容--直接向用户设备推送通知。
- en: This problem is trickier than it might seem. Push notifications are only received
    when the app isn't open (that's the whole point, after all). So, if our web application
    isn't open and running, how can we possibly run the code to display a notification?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题比看起来要棘手。推送通知只有在应用程序没有打开时才会收到（毕竟这就是整个目的）。因此，如果我们的网络应用程序没有打开和运行，我们怎么可能运行代码来显示通知呢？
- en: The answer is to use a third-party service that is engineered to send notifications
    to registered devices. So, rather than the device receiving the message alerting
    its user, the device sending the message alerts our notification service, which
    then notifies all relevant devices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用一个专门设计用于向注册设备发送通知的第三方服务。因此，设备不再接收通知提醒其用户，而是设备发送消息通知我们的通知服务，然后通知所有相关设备。
- en: We also need a piece of code that is constantly "on"--always running and waiting
    to receive notifications from the third-party service and display them. This challenge
    only recently became solvable with web technology, and is one of the reasons PWAs
    are so exciting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一段代码，它始终处于“开启”状态，等待从第三方服务接收通知并显示它们。这个挑战最近才通过网络技术得以解决，也是PWA如此令人兴奋的原因之一。
- en: For now, don’t worry if this distinction doesn't "click" yet. We'll go into
    it in greater detail later. For now, the point is that push notifications will
    be an interesting challenge for our web application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这种区别还没有“点亮”你，不要担心。我们稍后会更详细地讨论这个问题。现在，重点是推送通知将是我们的网络应用程序的一个有趣挑战。
- en: Offline access
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线访问
- en: Even when our user isn't connected to the internet, they should be able to check
    past messages and navigate around our application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的用户没有连接到互联网，他们也应该能够查看过去的消息并在我们的应用程序中导航。
- en: The answer turns out to go hand-in-hand with the earlier discussion on instant
    loading. We simply need to cache everything our app needs to function, and then
    load that on demand; simply, of course, being the operative word.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 答案原来与之前关于即时加载的讨论密切相关。我们只需要缓存应用程序运行所需的所有内容，然后按需加载；当然，“简单”是关键词。
- en: Mobile-first design
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动优先设计
- en: For years, the big buzzword of web design has been responsive--websites that
    look just as good when scaled from desktop to mobile size.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Web设计的一个大热词一直是响应式——从桌面缩放到移动尺寸时看起来一样好的网站。
- en: PWAs are, in essence, responsive design on steroids, expanding design for mobile
    to every aspect of the app, from appearance to functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PWA本质上是对响应式设计的加强，将移动设计扩展到应用程序的各个方面，从外观到功能。
- en: However, at the end of the day, we need to ensure that our app looks great on
    every screen size. It also needs to look good under the restrictions we've already
    discussed. We can't rely too much on big background images or intense graphics.
    We need a simple and good-looking UI, engineered for both looks and performance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，归根结底，我们需要确保我们的应用在每种屏幕尺寸上都表现出色。它还需要在我们已经讨论过的限制条件下表现良好。我们不能过分依赖大背景图片或强烈的图形。我们需要一个简单而好看的UI，既注重外观又注重性能。
- en: Progressive enhancement
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐进增强
- en: The bottleneck of performance with any React application is downloading and
    running the JavaScript. Our entire application code will be contained in JavaScript
    files--and our app won't work until those are executed. That means our users may
    be stuck staring at a white screen (with zero functionality) until that JavaScript
    is ready to go.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何React应用程序的性能瓶颈都在于下载和运行JavaScript。我们整个应用程序的代码将包含在JavaScript文件中——直到这些文件被执行，我们的应用程序才能正常工作。这意味着我们的用户可能会被困在一个白屏上（没有任何功能），直到JavaScript准备就绪。
- en: '**Progressive enhancement** is a technique that aims to fix that problem. In
    essence, it means that a user''s experience should get progressively better as
    the application downloads, depending on the user''s browser. In other words, the
    application experience improves as time goes on (and more of the application downloads),
    and as a user''s software improves.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**渐进增强**是一种旨在解决这个问题的技术。本质上，它意味着用户的体验应该随着应用程序的下载而逐渐改善，取决于用户的浏览器。换句话说，随着时间的推移（和应用程序的下载量增加）以及用户软件的改进，应用程序体验会变得更好。'
- en: A user with the most modern browser, the fastest internet connection, and the
    application fully downloaded will have the best experience, but a user with an
    outdated browser, a shaky connection, and who just landed on the page will also
    have a quality experience.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有最先进的浏览器、最快的互联网连接和完全下载的应用程序的用户将获得最佳体验，但使用过时的浏览器、不稳定的连接并刚刚登陆页面的用户也将获得优质的体验。
- en: This means our `React.js` application needs to have some functionality without
    any JavaScript. This is a fun challenge.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`React.js`应用程序需要在没有任何JavaScript的情况下具有一些功能。这是一个有趣的挑战。
- en: Think of our UX as a series of layers, from good to fantastic, that we build
    up as time goes on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 把我们的用户体验想象成一系列层次，从好到极好，随着时间的推移逐渐完善。
- en: Let's get going
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始吧
- en: I hope the preceding overview has given you a specific idea of what we're trying
    to accomplish with this application, and also the roadblocks to achieving those
    aims. There are a lot of challenges, but as we work through our user stories,
    we'll deal with them one by one, until we have a fast and functional Progressive
    Web App.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前面的概述让您对我们尝试实现这个应用程序的目标有了具体的想法，也让您了解了实现这些目标的障碍。虽然有很多挑战，但当我们逐步完成用户故事时，我们将逐个解决它们，直到我们拥有一个快速且功能齐全的渐进式Web应用程序。
- en: 'With the challenges mentioned, you can see the general trend: good performance
    and user experience under any condition. Certainly a worthy goal, and exactly
    why PWA techniques are applicable to any web app; they simply promise a better
    experience for everyone.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上面提到的挑战，您可以看到一个普遍的趋势：在任何情况下都要有良好的性能和用户体验。这无疑是一个值得追求的目标，也正是为什么PWA技术适用于任何Web应用程序的原因；它们只是承诺为每个人提供更好的体验。
- en: Once we start building our application, we'll also see that solving these problems
    is still a challenge, but all very achievable with React.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始构建我们的应用程序，我们还将看到解决这些问题仍然是一个挑战，但使用React是完全可以实现的。
- en: The next step is to get everything set up for our application, and create our
    basic folder structure with HTML and CSS.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的应用程序设置一切，并使用HTML和CSS创建基本的文件夹结构。
- en: Our app skeleton
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用程序骨架
- en: 'First things first. Before we start building our React application, let''s
    get set up with the basic HTML and CSS--the skeleton of our application, if you
    will, upon which we will heap the React muscles:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情。在我们开始构建React应用程序之前，让我们先使用基本的HTML和CSS进行设置-我们应用程序的骨架，我们将在其上堆叠React肌肉：
- en: Open up your Terminal and switch to whichever directory you want to store your
    project in.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并切换到您想要存储项目的任何目录。
- en: 'Then, we''ll make our app directory with `mkdir chatastrophe`. Let''s go inside
    that folder, make another folder within it named **`public`**, and within **`public`**,
    **`touch index.html`**. If you''re on Windows, use **`type nul > index.html`**
    instead of **`touch`**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将用`mkdir chatastrophe`创建我们的应用程序目录。让我们进入该文件夹，在其中创建另一个名为**`public`**的文件夹，在**`public`**中创建**`touch
    index.html`**。如果您使用Windows，请使用**`type nul > index.html`**而不是**`touch`**：
- en: '![](../images/00005.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: Then, open up the whole `chatastrophe` folder in your text editor of choice.
    I'll be using **Sublime Text 3** for this tutorial. Open up the `index.html` file,
    and let's write some HTML!
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在您选择的文本编辑器中打开整个`chatastrophe`文件夹。我将在本教程中使用**Sublime Text 3**。打开`index.html`文件，让我们写一些HTML！
- en: Let's start with the basic HTML elements. Create a `<html>` tag, and within
    that, `<head>` and `<body>`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从基本的HTML元素开始。创建一个`<html>`标签，在其中是`<head>`和`<body>`。
- en: This wouldn't be a programming tutorial without a hello world, so within the
    body, let's put `Hello world!` within an `<h1>` tag.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不会是一个编程教程，如果没有一个hello world，在body中，让我们在`<h1>`标签中放置`Hello world!`。
- en: 'Then, open up `index.html` within your browser:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在浏览器中打开`index.html`：
- en: '![](../images/00006.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: Our goal by the end of the chapter is to display the exact same as the preceding
    illustration, but using React to render our `<h1>`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我们的目标是显示与前面的插图完全相同的内容，但使用React来渲染我们的`<h1>`。
- en: Why did we put our `index.html` inside the public folder? Well, our HTML is
    the first thing our users will download when they hit our page. They will download
    it exactly as we see it here. This is in sharp contrast to our React JavaScript,
    which will be transpiled (more on that in the next chapter) before being served
    to the client. Our React code, as we write it, will be private. Our HTML, as we
    write it, will be public.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们把我们的`index.html`放在public文件夹里？嗯，当用户访问我们的页面时，我们的HTML是他们将下载的第一件事。他们将完全按照我们在这里看到的方式下载它。这与我们的React
    JavaScript形成了鲜明对比，在被提供给客户端之前，它将被转译（在下一章中会详细介绍）。我们编写的React代码将是私有的。我们编写的HTML将是公开的。
- en: This is a distinction that will make more sense as we move into the React world,
    but for now, just know that the convention is to put HTML and static assets in
    the public folder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在我们进入React世界时会更有意义的区别，但现在，只需知道惯例是将HTML和静态资产放在public文件夹中即可。
- en: CSS and assets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS和资产
- en: Our good friend at the start-up (now dubbed Chatastrophe--what have you done?)
    has tapped a designer to provide some basic assets for us. These include a send
    icon for our chat box, and a logo for the application. You're not a fan of the
    style, but *c'est la vie*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在初创公司的好朋友（现在被称为Chatastrophe-你做了什么？）已经找了一位设计师为我们提供一些基本资产。这些包括用于我们聊天框的发送图标和应用程序的徽标。你不喜欢这种风格，但*这就是生活*。
- en: Let's go ahead and download the image files from [https://github.com/scottdomes/chatastrophe-assets](https://github.com/scottdomes/chatastrophe-assets).
    You can download them by clicking on the Clone or Download button, and then selecting
    Download as Zip. Then, unzip those into the `public` folder, in a new folder called
    `assets` (all asset files should thus be in `chatastrophe/public/assets`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去[https://github.com/scottdomes/chatastrophe-assets](https://github.com/scottdomes/chatastrophe-assets)下载图像文件。您可以通过单击克隆或下载按钮，然后选择下载为Zip来下载它们。然后，将它们解压缩到`public`文件夹中，一个名为`assets`的新文件夹中（因此所有资产文件应该在`chatastrophe/public/assets`中）。
- en: 'Before we continue, we can ensure that our assets look okay by testing them
    in our `index.html`. Above `<h1>`, let''s put in an `img` tag, with the `src`
    set to `/img/logo.png`, and an ID as `test-image`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们可以通过在`index.html`中测试它们来确保我们的资产看起来还不错。在`<h1>`上面，让我们放一个`img`标签，`src`设置为`/img/logo.png`，ID设置为`test-image`：
- en: '[PRE0]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s what it should look like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是这个样子的：
- en: '![](../images/00007.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: This is even more beautiful.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加美丽。
- en: The last thing we need to do is add our CSS. By the luck of the gods, all of
    our CSS has been mysteriously prepared for us, saving us the cumbersome task of
    styling our application. All we have to do is pull in `assets/app.css`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是添加我们的CSS。幸运的是，所有的CSS都已经神秘地为我们准备好了，省去了我们样式化应用的繁琐任务。我们所要做的就是引入`assets/app.css`。
- en: 'We include it in our `index.html` with a link tag:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过链接标签将其包含在我们的`index.html`中：
- en: '![](../images/00008.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: 'We should see an immediate change to our page. The background should be a gradiant,
    and the image should now have a slightly pulsing animation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该立即看到页面的变化。背景应该是一个渐变，图片现在应该有一个轻微的脉动动画：
- en: '![](../images/00009.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: It worked! That does it for our main assets. Let's move on to some improvements
    to our HTML.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！这就是我们的主要资产。让我们继续进行一些对我们的HTML的改进。
- en: Meta tags and favicons
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元标签和网站图标
- en: Our application will be mobile-first, as we have already discussed. To ensure
    that our HTML is fully optimized, let's add a bit more markup.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将是以移动设备为先的，正如我们已经讨论过的。为了确保我们的HTML完全优化，让我们添加一些更多的标记。
- en: 'First, let''s add a `DOCTYPE` declaration to the top of `index.html`. This
    tells the browser what kind of document to expect. In HTML 5 (the newest version
    of HTML), it always looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`index.html`的顶部添加一个`DOCTYPE`声明。这告诉浏览器可以期望什么样的文档。在HTML 5（最新版本的HTML）中，它总是这样的：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to add a meta tag for `viewport` width. It looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`viewport`宽度添加一个元标签。它看起来像这样：
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What does this do? Essentially, it tells the browser to display the web page
    at the same width as its screen. So, if the web page seems to be 960px and our
    device is 320px wide, rather than zooming out and showing the whole page, it'll
    instead squish all the content down until it's 320px.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是做什么的？基本上，它告诉浏览器以与其屏幕相同的宽度显示网页。因此，如果网页看起来是960px，而我们的设备宽度是320px，而不是缩小并显示整个页面，它会将所有内容压缩到320px。
- en: As you might expect, this is only a good idea if your website is responsive
    and able to adapt to a smaller size. However, since responsiveness is one of our
    main goals, let's do this from the start. Add this tag within the `<head>` of
    our document.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，只有当你的网站是响应式的并且能够适应较小的尺寸时，这才是一个好主意。然而，由于响应性是我们的主要目标之一，让我们从一开始就这样做。在我们文档的`<head>`中添加这个标记。
- en: 'A couple more tags to go! The character set we use on our web page can be encoded
    in a couple of different ways: **Unicode** and **ISO-8859-1**. You can look up
    these encodings for more information, but long story short, we''re using Unicode.
    Let''s add it like so, right below the previous `<meta>` tag:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个标签要添加！我们网页上使用的字符集可以用几种不同的方式进行编码：**Unicode**和**ISO-8859-1**。您可以查阅这些编码以获取更多信息，但长话短说，我们使用Unicode。让我们像这样添加它，就在前面的`<meta>`标签下面：
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While we''re at it, let''s add the language the HTML is in. On our existing
    `<html>` tag, add `lang="en"`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 趁热打铁，让我们添加HTML所在的语言。在我们现有的`<html>`标签上，添加`lang="en"`：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay, that about does it for HTML housekeeping. The last thing we need is a
    **favicon**, the little icon displayed next to the title in the browser tab. This
    is included in our assets bundle, so all we have to do is link it up (right underneath
    our `<meta>` tags):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，HTML的清理工作就到此为止。我们需要的最后一件事是一个**favicon**，这是显示在浏览器标签中标题旁边的小图标。这包含在我们的资产包中，所以我们只需要将其链接起来（就在我们的`<meta>`标签下面）：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your browser tab should now look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器标签现在应该是这样的：
- en: '![](../images/00010.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: With that, we're done!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们完成了！
- en: Next, we'll look at how we will include React in our project, and all the other
    dependencies we will need.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在我们的项目中包含React，以及我们将需要的所有其他依赖项。
- en: What is npm?
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm是什么？
- en: A React application is primarily JavaScript. If you have experience working
    with JavaScript, you know that the browser is perfectly capable of parsing and
    executing JavaScript on its own.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: React应用程序主要是JavaScript。如果您有使用JavaScript的经验，您就会知道浏览器完全能够解析和执行JavaScript。
- en: In most basic websites, we link to the JavaScript needed for the page in a `<script>`
    tag, and the browser downloads and runs it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基本网站中，我们会在`<script>`标签中链接到页面所需的JavaScript，然后浏览器会下载并运行它。
- en: We'll be doing something similar with our React application (with considerable
    complications; more on that in [Chapter 2](part0048.html#1DOR00-7dd7c66301294003b85168009fe95fa4)*,
    Getting Started with Webpack*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的React应用程序中做类似的事情（有相当复杂的情况；在[第2章](part0048.html#1DOR00-7dd7c66301294003b85168009fe95fa4)*，使用Webpack入门*中会详细介绍）。
- en: However, JavaScript is no longer confined to the browser. More and more applications
    are using JavaScript on the backend as well, with JavaScript running in its own
    environment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript不再局限于浏览器。越来越多的应用程序也在后端使用JavaScript，JavaScript在自己的环境中运行。
- en: Long story short, JavaScript is now everywhere, and the driving force behind
    this proliferation is `Node.js`, a JavaScript runtime library, which lets you
    run JavaScript outside of a browser environment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，JavaScript现在无处不在，这种普及的推动力是`Node.js`，一个JavaScript运行时库，它让您可以在浏览器环境之外运行JavaScript。
- en: Okay, this is exciting, but why does this matter for our React project?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很令人兴奋，但为什么这对我们的React项目很重要呢？
- en: Node also introduced the idea of packages to JavaScript. Packages are essentially
    third-party libraries of code that you can install to your application and then
    import and use where and when you need them. You can use packages even if your
    application is not a Node application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Node还引入了将包的概念引入到JavaScript中。包本质上是您可以安装到应用程序中的第三方代码库，然后在需要的地方导入和使用它们。即使您的应用程序不是Node应用程序，也可以使用包。
- en: React is one such package. Webpack, mentioned earlier, is another one. In short,
    in order to build a complex web application, we will inevitably rely on a lot
    of other people's code, so we need packages, and we need **Node's package manager**
    (shorthand **`npm`**) to install them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: React就是这样一个包。之前提到的Webpack是另一个包。简而言之，为了构建复杂的Web应用程序，我们将不可避免地依赖于许多其他人的代码，因此我们需要包，我们需要**Node的包管理器**（简称**`npm`**）来安装它们。
- en: We’ll also use `npm` to start up our application and do some basic tasks, but
    its primary purpose is to manage packages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`npm`来启动我们的应用程序并执行一些基本任务，但它的主要目的是管理包。
- en: Node setup
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node设置
- en: 'Okay, enough said. Let''s go ahead and install Node, which comes bundled with
    `npm`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，说得够多了。让我们继续安装Node，它已经捆绑了`npm`：
- en: 'Go to [https://nodejs.org](https://nodejs.org) and download the latest stable
    release of Node:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://nodejs.org](https://nodejs.org)并下载Node的最新稳定版本：
- en: '![](../images/00011.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: Here, I would choose v6.10.3, the one recommended for most users.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我会选择v6.10.3，这是大多数用户推荐的版本。
- en: 'Once that is installed, open up your terminal and run **`node -v`** just to
    confirm the installation:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，打开终端并运行**`node -v`**以确认安装：
- en: '![](../images/00012.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: You can also confirm that `npm` has been included by running `npm -v`*.*
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过运行`npm -v`*.*来确认`npm`已经包含在内。
- en: Just to reiterate, Node is a JavaScript runtime used to execute JavaScript outside
    of the browser, and `npm` is a method of managing modules of JavaScript code.
    We won't be working with Node directly in this book, but we will be using `npm`
    a lot.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，Node是一个JavaScript运行时，用于在浏览器之外执行JavaScript，而`npm`是一种管理JavaScript代码模块的方法。在本书中，我们不会直接使用Node，但我们会经常使用`npm`。
- en: The dark side of npm
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm的黑暗面
- en: In the past year, `npm` has come under fire for various reasons.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的一年里，`npm`因各种原因受到了批评。
- en: It can be slow (just try installing large packages over a poor Wi-Fi connection)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会很慢（尝试在较差的Wi-Fi连接上安装大型包）
- en: Its installation process can lead to different results for different developers
    on the same project
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的安装过程可能会导致不同开发人员在同一项目上获得不同的结果
- en: It doesn't work offline, even if you've downloaded the package before
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使您之前已经下载了包，它也无法离线工作
- en: In response to these issues, Facebook came out with a package manager called
    **Yarn.** Yarn is essentially a wrapper around `npm`, giving the same basic functionality
    with an extra layer of goodness. Let's go ahead and install it so that we can
    use it to manage our packages!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这些问题的回应，Facebook推出了一个名为**Yarn**的包管理器。Yarn本质上是`npm`的一个包装器，提供了相同的基本功能以及额外的好处。让我们安装它，以便可以使用它来管理我们的包！
- en: Visit [https://yarnpkg.com/en/docs/install](https://yarnpkg.com/en/docs/install)
    for installation instructions. For macOS, note that you'll need **Homebrew** (which
    is like `npm` for macOS packages--packages everywhere!), which you can get at
    [https://brew.sh/.](https://brew.sh/)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://yarnpkg.com/en/docs/install](https://yarnpkg.com/en/docs/install)获取安装说明。对于macOS，请注意您将需要**Homebrew**（这类似于macOS软件包的`npm`-软件包无处不在！），您可以在[https://brew.sh/.](https://brew.sh/)获取它。
- en: Project initiation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目初始化
- en: 'The next thing we need to do is initiate our application as an `npm` project.
    Let''s try it out, and then we''ll discuss why we needed to do so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是将我们的应用程序初始化为一个`npm`项目。让我们试一试，然后我们将讨论为什么需要这样做：
- en: Inside your `project` folder, in your terminal, type `yarn init` and hit enter.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`project`文件夹中，在终端中输入`yarn init`并按回车键。
- en: It’ll ask you a series of questions. The first one is the most important--the
    name of our application. It should just take the name of the current folder (`chatastrophe`).
    If it doesn't, just enter `chatastrophe`. From there, just hit enter to skip the
    rest of the questions, accepting the default answers. These questions would matter
    more if we were planning on publishing our own package, but we're not, so no worries!
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会问您一系列问题。第一个问题最重要--我们应用程序的名称。它应该只是当前文件夹的名称（`chatastrophe`）。如果不是，请输入`chatastrophe`。然后，只需按回车键跳过其余的问题，接受默认答案。如果我们打算发布自己的包，这些问题会更重要，但我们不打算，所以不用担心！
- en: If you take a look at your project folder after completing the yarn init, you'll
    notice that it added a `package.json` file with our project name and version.
    Our `package.json` is important, in that it will act as a list of our dependencies--the
    package we will install via `yarn`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在完成了yarn init后查看项目文件夹，你会注意到它添加了一个带有我们项目名称和版本的`package.json`文件。我们的`package.json`很重要，因为它将作为我们依赖项的列表--我们将通过`yarn`安装的包。
- en: Enough talking about dependencies, though, let's install our first one! What
    better choice than to install React?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，足够谈论依赖关系了，让我们安装我们的第一个！有什么比安装React更好的选择呢？
- en: Installing React
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装React
- en: Let’s try it by running `yarn add react@15.6.1` from within your `project` folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过在你的`project`文件夹中运行`yarn add react@15.6.1`来安装它。
- en: We're installing a specific version of React (15.6.1) to ensure compatibility
    with other dependencies, and to ensure that there are no unexpected problems as
    new versions are released.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在安装React的特定版本（15.6.1）以确保与其他依赖项的兼容性，并确保在发布新版本时没有意外问题。
- en: Once the installation is complete, you should see React added to our `package.json`
    under dependencies. You'll also see that `yarn` generated a `node_modules` folder
    and a `yarn.lock` file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你应该看到React添加到我们的`package.json`的依赖项中。你还会看到`yarn`生成了一个`node_modules`文件夹和一个`yarn.lock`文件。
- en: The `node_modules` folder is where all our packages will live. If you open it
    up, you can see that there are several folders already. We've not only installed
    React, but everything that React depends on--dependencies on dependencies.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules`文件夹是我们所有包的所在地。如果你打开它，你会看到已经有几个文件夹了。我们不仅安装了React，还安装了React所依赖的一切--依赖的依赖。'
- en: As you might imagine, the `node_modules` folder can get quite hefty. So, we
    don't check it into source control. When a new developer joins the team and downloads
    the project files, they can then install the dependencies independently, based
    on the `package.json`; this saves time and space.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，`node_modules`文件夹可能会变得相当庞大。因此，我们不会将其检入源代码控制。当新开发人员加入团队并下载项目文件时，他们可以根据`package.json`独立安装依赖项；这样可以节省时间和空间。
- en: However, we need to ensure that they get the same packages as everyone else,
    and the same version; this is where the `yarn.lock` file comes in.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要确保他们获得与其他人相同的包和相同的版本；这就是`yarn.lock`文件的作用。
- en: The previously mentioned setup ensures that we are ready to safely use third-party
    libraries. We have the `package.json`, `yarn.lock`, and `node_modules` folders
    in our project. Before we continue, let's ensure that adding React worked.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的设置确保我们已经准备好安全地使用第三方库。我们在项目中有`package.json`、`yarn.lock`和`node_modules`文件夹。在继续之前，让我们确保添加React成功了。
- en: Using React
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React
- en: Let's confirm that React is in our project by using it to render a simple element
    to our screen. This will be our first dipping of our feet into React, so go slow
    and ensure that you understand each step.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用它来向我们的屏幕渲染一个简单的元素来确认React是否在我们的项目中。这将是我们第一次尝试React，所以要慢慢来，确保你理解每一步。
- en: First, we need to import our React package (which we just installed with `yarn`)
    into our `index.html` so that we can use it there.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将我们刚刚用`yarn`安装的React包导入到我们的`index.html`中，以便我们可以在那里使用它。
- en: 'To do this, we add a `<script>` tag with the path to the main React file within
    our `node-modules` folder. This tag looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们在我们的`node-modules`文件夹中添加一个指向主React文件的`<script>`标签。这个标签看起来像这样：
- en: '[PRE6]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Place this in your `index.html`, at the bottom of the `body` tag (before the
    closing `</body>`).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个放在你的`index.html`中，放在`body`标签的底部（在闭合的`</body>`之前）。
- en: Okay, we have React! Let's use it to make a simple `<h1>` tag, just like the
    one we wrote in HTML.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们有了React！让我们用它来制作一个简单的`<h1>`标签，就像我们在HTML中写的那样。
- en: 'React has a function called `createElement` for this purpose. It takes three
    arguments: element type, something called props (more on that later), and the
    children (what goes inside the tag).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: React有一个名为`createElement`的函数来实现这一目的。它接受三个参数：元素类型，称为props的东西（稍后详细介绍），以及子元素（标记内部的内容）。
- en: 'For us, it looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，它看起来像这样：
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function call creates an element that looks as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用创建了一个如下所示的元素：
- en: '[PRE8]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To confirm that it will work, let''s `console.log` it out:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认它是否有效，让我们将其`console.log`出来：
- en: '[PRE9]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Reload `index.html`, then right-click or control-click and select Inspect to
    open up DevTools in Chrome and switch to the Console tab. There, we see our element…
    or not. Instead of the HTML output, we get something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载`index.html`，然后右键单击或按住Control键单击并选择Inspect以在Chrome中打开DevTools并切换到Console选项卡。在那里，我们看到我们的元素……或者没有。而不是HTML输出，我们得到了这样的东西：
- en: '![](../images/00013.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: This is not the HTML element we might have expected, but we can see that React
    has worked in its own way. We have a JavaScript object with a type field of `h1`.
    Let’s see whether we can transform this into an actual HTML tag on the screen.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们可能期望的HTML元素，但我们可以看到React以自己的方式工作。我们有一个JavaScript对象，其中有一个`h1`类型的字段。让我们看看是否可以将其转换为屏幕上的实际HTML标记。
- en: Welcome to ReactDOM
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到ReactDOM
- en: Here's a secret about React--it's a library for creating UIs, but not a library
    for rendering UIs. In itself, it has no mechanism for rendering a UI to the browser.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 关于React的一个秘密是，它是一个用于创建UI的库，但不是用于渲染UI的库。它本身没有渲染UI到浏览器的机制。
- en: Fortunately, the creators of React also have a package called **ReactDOM** for
    exactly this purpose. Let's install it and then see how it works.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React的创建者还有一个名为**ReactDOM**的包，专门用于这个目的。让我们安装它，然后看看它是如何工作的。
- en: First, we install it with **`yarn add react-dom@15.6.1`**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用**`yarn add react-dom@15.6.1`**来安装它。
- en: 'Then, require it in `index.html` in much the same way as React:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`index.html`中以与React类似的方式引入它：
- en: '[PRE10]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'ReactDOM has a function called `render`, which takes two arguments: the React
    element to be rendered to the screen (hey, we have that already!), and the HTML
    element it will be rendered inside.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ReactDOM有一个名为`render`的函数，它接受两个参数：要渲染到屏幕上的React元素（嘿，我们已经有了！），以及它将被渲染在其中的HTML元素。
- en: So, we have the first argument, but not the second. We need something in our
    existing HTML we can grab and hook into; ReactDOM will inject our React element
    inside of it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了第一个参数，但没有第二个。我们需要在我们现有的HTML中找到一些东西，可以抓取并连接到其中；ReactDOM将在其中注入我们的React元素。
- en: So, below our existing `<h1>` tag, create an empty `div` with the ID `root`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在现有的`<h1>`标记下面，创建一个ID为`root`的空`div`。
- en: Then, in our `ReactDOM.render` function, we’ll pass in the React element, and
    then use `document.getElementById` to grab our new `div`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`ReactDOM.render`函数中，我们将传入React元素，然后使用`document.getElementById`来获取我们的新`div`。
- en: 'Here''s what our `index.html` should look like:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index.html`应该如下所示：
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reload the page, and you should see `'Hello from React!'` text in the middle
    of the screen!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面，你应该在屏幕中间看到`'Hello from React!'`的文本！
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Success!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: We will be diving deeper (much, much deeper) into both ReactDOM and React in
    the next few chapters. We'll learn how to create elements in a much more intuitive
    way, and also how React makes building UIs a dream.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将深入（更深入）学习ReactDOM和React。我们将学习如何以更直观的方式创建元素，以及React如何使构建UI成为一种梦想。
- en: For now, we have our project skeleton ready to go—the basis of our future application.
    Great work!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经准备好了项目的框架，这是我们未来应用的基础。干得好！
- en: Our next step is to finish the last stage of preparation, and take a deep look
    at one of our most important dependencies--a tool called Webpack.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是完成准备的最后阶段，并深入研究我们最重要的依赖之一——一个名为Webpack的工具。
