- en: Type Checking Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查模式
- en: To be able to leave your application working and forget about any troubles,
    you need a way to make sure that all parts of your application match each other.
    Languages built on top of JavaScript or ECMAScript, such as Flow or TypeScript,
    bring type systems to your application. Thanks to these, you will know that no
    one is sending the wrong data to your functions or components. We have already
    used `PropTypes` for assertions in components. Now we will apply this concept
    to any JavaScript variable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够让你的应用程序正常工作并忘记任何麻烦，你需要一种方法来确保应用程序的所有部分相互匹配。建立在JavaScript或ECMAScript之上的语言，如Flow或TypeScript，为你的应用程序引入了类型系统。由于这些，你将知道没有人会向你的函数或组件发送错误的数据。我们已经在组件中使用了`PropTypes`进行断言。现在我们将把这个概念应用到任何JavaScript变量上。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: The basics of type systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统的基础
- en: How to assign types to functions and variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为函数和变量分配类型
- en: What contract tests are; for instance, the Pact test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 契约测试是什么；例如，Pact测试
- en: Generics and union types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型和联合类型
- en: Tips on how to solve type problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决类型问题的技巧
- en: How type systems use nominal and structural typing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统如何使用名义和结构化类型
- en: Introduction to types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型介绍
- en: In ECMAScript, we have seven implicit types. Six of them are primitives.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript中，我们有七种隐式类型。其中六种是原始类型。
- en: 'The six data types that are primitives are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 六种原始数据类型如下：
- en: Boolean.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值。
- en: Number.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字。
- en: String.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串。
- en: Null.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值。
- en: Undefined.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义。
- en: Symbol—a unique identifier introduced in ECMAScript. Its purpose is to guarantee
    uniqueness. This is used commonly as a unique key in objects.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号——ECMAScript中引入的唯一标识符。其目的是确保唯一性。这通常用作对象中的唯一键。
- en: The seventh type is objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第七种类型是对象。
- en: Functions and arrays are also objects. Generally, anything that is not a primitive
    type is an object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和数组也是对象。通常，任何不是原始类型的东西都是对象。
- en: Whenever you assign a value to a variable, the type is automatically determined.
    Based on the type, there are some rules that apply.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你给一个变量赋值时，类型会自动确定。根据类型，会有一些规则适用。
- en: Primitive function arguments are passed by value. Objects are passed by reference.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数参数是按值传递的。对象是按引用传递的。
- en: Every variable is stored in memory in the form of zeros and ones. Passing by
    value means that the called function parameter will be copied. This means the
    creation of a new object that has a new reference. Passing by reference means
    passing just the reference to the object—if somebody makes changes to the referenced
    memory, then it will affect everyone who uses this reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都以零和一的形式存储在内存中。按值传递意味着被调用的函数参数将被复制。这意味着创建一个具有新引用的新对象。按引用传递意味着只传递对象的引用——如果有人对引用的内存进行更改，那么会影响使用这个引用的所有人。
- en: 'Let''s look at the examples of the mechanism of passing by value:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下按值传递机制的例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `num` variable has not been changed because, on function call, the value
    was copied. The `x` variable referenced a completely new variable in the memory.
    Let''s now look at a similar example, but with an object:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`num`变量没有被改变，因为在函数调用时，该值被复制了。`x`变量引用了内存中的一个全新变量。现在让我们看一个类似的例子，但是使用对象：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This time, we passed the `numObj` object to the function. It has been passed
    by reference, and so was not copied. When we changed the `obj` variable, it affected
    `numObj` externally.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将`numObj`对象传递给了函数。它是按引用传递的，所以没有被复制。当我们改变`obj`变量时，它会对`numObj`产生外部影响。
- en: However, when we invoke the preceding functions, we do not check the types.
    By default, we can pass anything. If our function cannot handle the passed variable,
    then it will break with some kind of error.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们调用前面的函数时，我们没有检查类型。默认情况下，我们可以传递任何东西。如果我们的函数无法处理传递的变量，那么它将以某种错误中断。
- en: 'Let''s have a look at the hidden and unexpected behavior that may occur with
    usage of the `increase` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在使用`increase`函数时可能发生的隐藏和意外行为：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `increase` function computes `51` when we add `"5"` and `1`. This is how
    JavaScript works—it does implicit type conversion to be able to perform an operation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`"5"`和`1`相加时，`increase`函数计算出`51`。这就是JavaScript的工作原理——它进行隐式类型转换以执行操作。
- en: 'Do we have a way to prevent this and save developers from accidental mistakes?
    Yes, we can do a runtime check to reassess that the variable is of a certain type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有办法防止这种情况并避免开发人员的意外错误吗？是的，我们可以进行运行时检查，以重新评估变量是否属于某种类型：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A runtime check is a check that is performed while the code is evaluated. It
    is part of the code execution phase and affects the application speed. We will
    look more closely at runtime checking later on in this chapter, in the section
    on solving problems in runtime validation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时检查是在代码评估时执行的检查。它是代码执行阶段的一部分，会影响应用程序的速度。我们将在本章后面更仔细地研究运行时检查，在运行时验证问题解决部分。
- en: When the `Error` message is thrown, we also need to use error boundaries for
    component replacement or some `try{}catch(){}` syntax for handling async code
    errors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出`Error`消息时，我们还需要为组件替换使用错误边界或一些`try{}catch(){}`语法来处理异步代码错误。
- en: If you did not read this book from the beginning, then you may find it handy
    to go back to [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View Patterns*,
    to learn more about error boundaries in React.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有从头开始阅读本书，那么您可能会发现回到[第2章](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml)，*查看模式*，以了解有关React中错误边界的更多信息。
- en: However, we did not check if the `obj` variable is of the `Object` type! Such
    runtime checks can be added, but let's look at something much more convenient—TypeScript, the
    type checking language built on top of JavaScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有检查`obj`变量是否是`Object`类型！可以添加此类运行时检查，但让我们看看更方便的东西——TypeScript，这是建立在JavaScript之上的类型检查语言。
- en: Introduction to TypeScript
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript简介
- en: 'TypeScript brings types to our code. We can explicitly express the requirement
    that a function accepts only a specific variable type. Let''s look at how we could
    use the example from the previous section with types from TypeScript:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript为我们的代码带来了类型。我们可以明确表达函数只接受特定变量类型的要求。让我们看看如何在TypeScript的类型中使用上一节的示例：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code will not compile. The static check will exit with an error saying
    that the code base is corrupted because types do not match.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将无法编译。静态检查将以错误退出，因为类型不匹配导致代码库损坏。
- en: 'The following error will be shown:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下错误：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript has caught us red-handed. We need to fix the error. Such code will
    never reach the end user until the developer fixes the error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript已经抓住了我们的错误。我们需要修复错误。除非开发人员修复错误，否则这样的代码永远不会到达最终用户。
- en: Configuring TypeScript
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置TypeScript
- en: For your convenience, I have configured TypeScript in our repository. You can
    check it under `src/Chapter 11/Example 1` in the code files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，我已经在我们的存储库中配置了TypeScript。您可以在代码文件的`src/Chapter 11/Example 1`下查看它。
- en: There are a few things I want you to understand.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事我希望您能理解。
- en: TypeScript comes with its own configuration file, called `tsconfig.json`. In
    this file, you will find multiple configuration properties that control how strict
    the TypeScript compiler is. You can find a detailed list of the properties and
    explanations in the official documentation at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript有自己的配置文件，称为`tsconfig.json`。在这个文件中，您会发现多个配置属性，控制着TypeScript编译器的严格程度。您可以在官方文档中找到属性和解释的详细列表[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)。
- en: 'Among the options, you can find `outDir`. This specifies where the compiler
    output should be saved. In our repository, it is set to `"outDir": "build/dist"`.
    Our application, from now on, will run the compiled code from the `build/dist`
    directory. Hence, I have changed the root `App.js` file as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在选项中，您可以找到`outDir`。这指定了编译器输出应该保存在哪里。在我们的存储库中，它设置为`"outDir": "build/dist"`。从现在开始，我们的应用程序将从`build/dist`目录运行编译后的代码。因此，我已经将根`App.js`文件更改如下：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you understand the configuration changes, we can now proceed with learning
    basic typing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了配置更改，我们现在可以继续学习基本类型。
- en: Learning the basic types
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基本类型
- en: To get the most out of TypeScript, you should type as much code as possible.
    However, our application did not have types before. In the case of a large application,
    you obviously cannot suddenly add types everywhere. Hence, we will gradually increase
    application type coverage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用TypeScript，您应该尽可能多地为代码添加类型。然而，在我们的应用之前并没有类型。对于大型应用程序，显然不能突然在所有地方添加类型。因此，我们将逐渐增加应用程序类型覆盖范围。
- en: 'TypeScript''s list of basic types is quite long—Boolean, number, string, array,
    tuple, enum, any, void, null, undefined, never, and object. If you are unfamiliar
    with any of the them, then kindly please check the following page:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的基本类型列表相当长 - 布尔、数字、字符串、数组、元组、枚举、any、void、null、undefined、never和对象。如果您对其中任何一个不熟悉，请查看以下页面：
- en: '[https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html)。'
- en: 'To start, let''s look at one of the components that we used:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下我们使用的组件之一：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now switch to TypeScript. Let''s start with the `Prop` types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将切换到TypeScript。让我们从`Prop`类型开始：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In these little examples, we have defined the structure of the `NavigationButton`
    props. The `data` prop is of the `any` type, as we do not control what kind of
    data is being passed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些小例子中，我们已经定义了`NavigationButton` props的结构。`data` prop是`any`类型，因为我们无法控制传递的数据是什么类型。
- en: The `navigation` prop uses types defined by the `react-navigation` library.
    This is crucial to reuse already exposed types. In the project files, I have installed
    the `react-navigation` types using the `yarn add @types/react-navigation` command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigation` prop使用了`react-navigation`库定义的类型。这对于重用已经暴露的类型至关重要。在项目文件中，我使用`yarn
    add @types/react-navigation`命令安装了`react-navigation`类型。'
- en: 'We can proceed with adding types to `NavigationButton`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续为`NavigationButton`添加类型：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`SFC` type is exported by React library. It is a generic type that can accept
    any possible prop types definition. Hence, we need to specify what kind of prop
    type it is: `SFC<NavigateButtonProps>`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`SFC`类型由React库导出。它是一个通用类型，可以接受任何可能的prop类型定义。因此，我们需要指定它是什么样的prop类型：`SFC<NavigateButtonProps>`。'
- en: That's it—we also need to remove the old `NavigateButton.propTypes` definition
    at the bottom. From now on, TypeScript will validate the types passed on the `NavigateButton`
    function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 我们还需要删除底部的旧`NavigateButton.propTypes`定义。从现在开始，TypeScript将验证传递给`NavigateButton`函数的类型。
- en: enums and constants patterns
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举和常量模式
- en: 'There is a concept that is long praised in any code base I have seen: constants.
    They save so much value that almost everybody agrees that it is a must to define
    variables that hold a specific constant value. If, instead, we copied it to every
    single place where we need them, it would be much harder to update the value.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看到的任何代码库中，都有一个长期受到赞扬的概念：常量。它们节省了很多价值，几乎每个人都同意定义保存特定常量值的变量是必须的。如果我们将它复制到需要它们的每个地方，更新值将会更加困难。
- en: 'Some constants need to be flexible, hence, wise developers extract them to
    configuration files. Such files are stored in the code base, and sometimes in
    many different flavors (for instance, for test: `dev`, quality assurance, and
    production environments).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常量需要灵活，因此，聪明的开发人员将它们提取到配置文件中。这些文件存储在代码库中，有时以许多不同的风格存储（例如，用于测试：`dev`，质量保证和生产环境）。
- en: 'In many cases, the constants we define allow only a constant set of valid values.
    For instance, if we were to define available environments, then we could create
    a list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们定义的常量只允许一组常量有效值。例如，如果我们要定义可用环境，那么我们可以创建一个列表：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In old-school programming in JavaScript, you would simply `switch-case` the
    environments and propagate relevant information to the specific objects in your
    application. If the environment was unrecognized, then if would fall into a default
    clause where it usually simply throws an error saying "unrecognized environment"
    and closes the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧式的JavaScript编程中，你可以简单地使用`switch-case`来切换环境，并将相关信息传播给应用程序中的特定对象。如果环境无法识别，那么它会进入一个默认子句，通常会抛出一个错误，说“无法识别的环境”，然后关闭应用程序。
- en: If you assume that, in TypeScript, you would not need to check such things,
    you are wrong. Whatever you consume from the outside needs runtime validation.
    You cannot allow JavaScript to fail on its own and blow up the application in
    an unpredictable manner. This is a huge "gotcha" that is often overlooked.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为在TypeScript中，你不需要检查这些东西，那么你是错的。你从外部获取的任何东西都需要运行时验证。你不能允许JavaScript自行失败并以不可预测的方式使应用程序崩溃。这是一个经常被忽视的巨大“陷阱”。
- en: One of the most common problems you may run into is API change. If you expect
    the `http://XYZ` endpoint to return JSON with the `tasks` key, and you do not
    validate what was really returned to you, you are in trouble. For instance, if
    a separate team decides to change the key to `projectTasks`, and is not aware
    of your dependency on `tasks`, it will surely lead to problems. How can we fix
    this?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的最常见问题之一是API的更改。如果你期望`http://XYZ`端点返回带有`tasks`键的JSON，并且你没有验证实际返回给你的内容，那么你就会遇到麻烦。例如，如果另一个团队决定将键更改为`projectTasks`，并且不知道你对`tasks`的依赖，那么肯定会导致问题。我们该如何解决这个问题？
- en: The expected return values on your APIs is quite easy to enforce. A long time
    ago, the term contract tests was developed. This means creating a contract in
    both frontend and backend systems. Contracts cannot be changed without reassuring
    both code bases are ready. This is usually enforced by some automation tool, one
    of which may be Pact tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对API的预期返回值很容易强制执行。很久以前，就出现了术语合同测试。这意味着在前端和后端系统中创建合同。合同不能更改，而不确定两个代码库是否准备好。这通常由一些自动化工具强制执行，其中之一可能是Pact测试。
- en: '"**Pact** (noun):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “**Pact**（名词）：
- en: A formal agreement between individuals or parties. "The country negotiated a
    trade pact with the US.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 个人或团体之间的正式协议。“该国与美国谈判达成了一项贸易协定。
- en: 'Synonyms: agreement, protocol, deal, contract"'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同义词：协议，协议，协议，合同”
- en: - [Oxford Dictionaries (https://en.oxforddictionaries.com/definition/pact)](https://en.oxforddictionaries.com/definition/pact).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: - [牛津词典（https://en.oxforddictionaries.com/definition/pact）](https://en.oxforddictionaries.com/definition/pact)。
- en: If you look for a way to enforce this programmatically, have a look at [https://github.com/pact-foundation/pact-js](https://github.com/pact-foundation/pact-js).
    This topic is tough and also requires knowledge of  backend languages, hence it
    is out of this book's scope.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找一种以编程方式强制执行此操作的方法，请查看[https://github.com/pact-foundation/pact-js](https://github.com/pact-foundation/pact-js)。这个主题很难，也需要对后端语言有所了解，因此超出了本书的范围。
- en: Once we are 100% sure that outside world data is validated, we may want to ensure
    that our own computations never lead to changing the variables (for instance,
    through immutability, see [Chapter 9,](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml) *Elements
    of Functional Programming Patterns*) or if the change is expected, that it will
    always retain a value of the allowed set.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们100%确定外部世界的数据已经得到验证，我们可能希望确保我们自己的计算永远不会导致变量的改变（例如通过不可变性，参见[第9章](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml)
    *函数式编程模式的元素*），或者如果变化是预期的，它将始终保留允许集合的值。
- en: 'This is when TypeScript comes in handy. You can ensure that your computations
    will always lead to the one of the allowed states. You will not need any runtime
    validation. TypeScript will save you from unnecessary checks that, in large amounts,
    could result in slowing your app by a few miliseconds. Let''s see how we can do
    this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是TypeScript派上用场的时候。您可以确保您的计算将始终导致允许的状态之一。您将不需要任何运行时验证。TypeScript将帮助您避免不必要的检查，大量的检查可能会导致您的应用程序减慢几毫秒。让我们看看我们可以如何做到这一点：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have defined an `enum` type. If the variable is expected to be of the `TasksActionType`
    type, it can only be assigned the values from the preceding `enum TasksActionType`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个`enum`类型。如果变量预期是`TasksActionType`类型，它只能被赋予前面`enum TasksActionType`中的值。
- en: 'We can now define `AddTaskActionType`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义`AddTaskActionType`：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It will be used in the `addTask` action creator:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它将用于`addTask`动作创建者：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now our action creator is type checked very well. If any developer, by mistake,
    changes the `type` object key to any other, for instance, `TasksActionType.TASK_FETCH_COMPLETE`,
    then TypeScript will detect that and show an incompatibility error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的动作创建者经过了很好的类型检查。如果任何开发人员错误地将`type`对象键更改为其他任何值，例如`TasksActionType.TASK_FETCH_COMPLETE`，那么TypeScript将检测到并显示不兼容错误。
- en: We have `AddTaskActionType`, but how can we combine this with other action types
    that our reducer may accept? We can use union types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`AddTaskActionType`，但是我们如何将其与我们的reducer可能接受的其他动作类型组合起来？我们可以使用联合类型。
- en: Creating union types and intersections
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联合类型和交集
- en: 'A union type describes a value that can be one of several types. This is a
    great fit for our `Tasks` reducer type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型描述了可以是多种类型之一的值。这非常适合我们的`Tasks` reducer类型：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The union type is created with the `**|**` operator. It works just as if it
    was `|` was `or`. One type or another.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型是使用`**|**`运算符创建的。它的工作方式就像`|`是`或`。一个类型或另一个类型。
- en: 'We can now use the previous type in the `Reducer` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`Reducer`函数中使用之前的类型：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To make TypeScript happy, we need to add types to all of the parameters. Hence,
    I have added the rest of the types. One of them is still missing: `TaskType`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让TypeScript满意，我们需要为所有参数添加类型。因此，我已经添加了其余的类型。其中一个仍然缺失：`TaskType`。
- en: In the preceding code example, you may be surprised by the `Immutable.List<TaskType>`
    notation, and especially the `< >` signs. Those need to be used because `List`
    is a generic type. We will talk about generic types in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，您可能会对`Immutable.List<TaskType>`的表示法感到惊讶，特别是`< >`符号。这些需要使用，因为`List`是一种通用类型。我们将在下一节讨论通用类型。
- en: 'To create `TaskType`, we could just write its type as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`TaskType`，我们可以将其类型写成如下形式：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, this is not reusing the type we have already created: `TaskAddFormData`.
    Whether you want to do so is a topic for another discussion. Let's assume we want
    to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是重用我们已经创建的类型：`TaskAddFormData`。是否要这样做是另一个讨论的话题。让我们假设我们想要这样做。
- en: 'To reuse existing type and declare or create `TaskType` in the desired shape,
    we will need to use an intersection:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重用现有类型并声明或创建所需形状的`TaskType`，我们需要使用交集：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we used the `&` intersection operator to create a new type.
    The created type is an intersection of the types from the left-hand side and right-hand
    side of the  `&` operator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`&`交集运算符创建了一个新类型。创建的类型是`&`运算符左侧和右侧类型的交集：
- en: '![](Images/7683edab-1560-4008-9969-33e9e76d8ef9.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7683edab-1560-4008-9969-33e9e76d8ef9.png)'
- en: An intersection diagram, where the intersection is the space that is both in
    circle A and in circle B
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 交集图，其中交集是既在圆A中又在圆B中的空间。
- en: 'An intersection of **A** and **B** possesses both the properties of **A** and
    **B**. Hence, the type that is created by an intersection of type **A** and type
    **B** must have both type **A** types and type **B** types. To summarize,  `TaskType` must
    now be of the following shape:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**和**B**的交集具有**A**和**B**的属性。因此，由类型**A**和类型**B**的交集创建的类型必须同时具有类型**A**和类型**B**的类型。总结一下，`TaskType`现在必须具有以下形状：'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, intersections may be handy. Sometimes, when we rely on external
    libraries, we don''t want to hardcode the key types as in the previous examples.
    Let''s look at it again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，交集可能很方便。有时，当我们依赖外部库时，我们不希望像前面的例子中那样硬编码键类型。让我们再看一遍：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The navigation key is hardcoded in our type. We could have used an intersection
    to comply with possible future changes of the external library shape:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 导航键在我们的类型中是硬编码的。我们可以使用交集来符合外部库形状可能发生的未来变化：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we use the `<>` signs again. These are needed because `NavigationInjectedProps`
    is a generic type. Let's learn what generic types are.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次使用`<>`符号。这是因为`NavigationInjectedProps`是一种泛型类型。让我们学习一下泛型类型是什么。
- en: Generic types
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'Generics allow you to write code that will handle any type of object. For instance,
    you know that a list is a generic type. You can make a list of anything. Hence,
    when we used `Immutable.List`, we had to specify what kind of objects the list
    will consist of:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许您编写能够处理任何类型对象的代码。例如，您知道列表是一种泛型类型。您可以创建任何类型的列表。因此，当我们使用`Immutable.List`时，我们必须指定列表将包含哪种类型的对象：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: List of tasks. Let's now create our own generic type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表。现在让我们创建我们自己的泛型类型。
- en: In our code base, we have one util that is supposed to work with any type. It
    is a `Maybe` monad.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码库中，有一个工具应该能够处理任何类型。它是一个`Maybe`单子。
- en: If you have jumped to this chapter, then you may find it handy to read about
    monad patterns in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经跳转到本章，则可能会发现在[第9章](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml)中阅读有关单子模式的信息很有用，*函数式编程模式的元素*。
- en: 'The `Maybe` monad is either `Nothing`, when the variable happens to be `null`,  `undefined`,
    or `Something` of that type. This is a perfect fit for generic types:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe`单子要么是`Nothing`，当变量恰好是`null`、`undefined`时，要么是该类型的`Something`。这非常适合泛型类型：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The tricky part is implementing `Something<T>` and `Nothing`. Let''s start
    with `Nothing`, as it is much easier. It should return `null` on value check and
    always map to itself:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是实现`Something<T>`和`Nothing`。让我们从`Nothing`开始，因为它要容易得多。它应该在值检查时返回`null`，并始终映射到自身：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Something<T>` should map to either `Something<MappingResult>` or `Nothing`.
    The value check should return `T`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Something<T>`应该映射到`Something<MappingResult>`或`Nothing`。值检查应该返回`T`：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Mapping the result type is saved by using the `Z` generic type that is introduced
    in the `map` function signature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`map`函数签名中引入的`Z`泛型类型来保存结果类型的映射。
- en: 'However, if we try to use our newly defined types, they will not work. Unfortunately,
    TypeScript does not always figure out union types correctly. This problem occurs
    when union of types leads to different call signatures per specific key. In our
    case, this happens with the `map` function. Its type is `(args: any) => Nothing`
    or `<Z>(fn: ((a:T) => Z)) => MaybeType<Z>`. Hence, `map` has no compatible call
    signature.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，如果我们尝试使用我们新定义的类型，它们将不起作用。不幸的是，TypeScript并不总是正确地推断联合类型。当类型的联合导致特定键的不同调用签名时，就会出现这个问题。在我们的情况下，这发生在`map`函数上。它的类型是`(args:
    any) => Nothing`或`<Z>(fn: ((a:T) => Z)) => MaybeType<Z>`。因此，`map`没有兼容的调用签名。'
- en: 'The quick fix to this problem is defining a standalone `MaybeType` that satisfies
    two conflicting type definitions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的快速解决方法是定义一个独立的`MaybeType`，满足两个冲突的类型定义：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With such a type definition, we can proceed to use the new generic type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的类型定义，我们可以继续使用新的泛型类型：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The selector function takes `TasksState` as an argument and is expected to return
    a map that is assigned to the `tasks` key within the state. It may look a little
    tough to understand, hence, I highly recommend you to open the previous file and
    have a longer look. If you struggle, in the *Further reading* section at the end
    of the chapter, I have included a reference to an issue on GitHub that discusses
    this in detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器函数以`TasksState`作为参数，并且期望返回一个分配给状态中`tasks`键的映射。这可能看起来有点难以理解，因此，我强烈建议你打开前面的文件，仔细看一看。如果你有困难，在本章末尾的“进一步阅读”部分中，我已经包含了一个在GitHub上讨论这个问题的参考链接。
- en: Understanding TypeScript
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TypeScript
- en: In the previous section, we ran into a problem that is quite tough to understand
    if you have never worked with type systems. Let's learn a little bit about TypeScript
    itself to understand this better.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们遇到了一个问题，如果你从未使用过类型系统，可能很难理解。让我们稍微了解一下TypeScript本身，以更好地理解这个问题。
- en: Type inference
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: The very first thing I want you to understand is type inference. You do not
    need to type everything. Some types can be inferred by TypeScript.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让你明白的第一件事是类型推断。你不需要输入所有的类型。一些类型可以被TypeScript推断出来。
- en: Imagine a situation where I have told you, "I have put only chocolate donuts
    in the box on your desk." Since, in this example, I pretend to be the computer,
    you can trust me. Hence, when you arrive at your desk, you are 100% sure that
    the box is of the `Box<ChocolateDonut[]>` type. You know this without opening
    the box or having an explicit sticker on it that says *Box full of chocolate donuts*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情况，我告诉你，“我只在你桌子上的盒子里放了巧克力甜甜圈。”在这个例子中，我假装是计算机，你可以相信我。因此，当你到达你的桌子时，你百分之百确定这个盒子是`Box<ChocolateDonut[]>`类型。你知道这一点，而不需要打开盒子或者在上面贴上写着“装满巧克力甜甜圈的盒子”的标签。
- en: 'In a real code, it works very similarly. Let''s look at the following minimal
    example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，它的工作方式非常相似。让我们看下面的最小示例：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is trivial. We can now look at something that I like more, `ChocolateDonuts`,
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这很琐碎。现在我们可以看一些我更喜欢的东西，`ChocolateDonuts`，如下：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we exercise both the `enum` and generic types. The `clone`
    simply clones any type into a brand new one and delegates to JSON functions: `stringify` and
    then `parse`. The `ProduceBox` function simply takes a recipe and creates an array
    of clones based on that recipe. In the end, we create a box of chocolate donuts.
    The type is correctly inferred because we have specified a generic type for `produceBox`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们同时使用了`enum`和泛型类型。`clone`简单地将任何类型克隆成一个全新的类型，并委托给JSON函数：`stringify`和`parse`。`ProduceBox`函数简单地接受一个配方，并根据该配方创建一个克隆数组。最后，我们创建了一个巧克力甜甜圈盒子。类型被正确地推断，因为我们为`produceBox`指定了一个泛型类型。
- en: Structural typing
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构类型
- en: 'TypeScript uses structural typing. To understand what that means, let''s look
    at the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript使用结构类型。为了理解这意味着什么，让我们看下面的例子：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we first declare the `p` variable, and then assign a new instance
    of `ChocolateDonut` to it. It works in TypeScript. It wouldn't work in Java. Why?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先声明了变量`p`，然后将`ChocolateDonut`的一个新实例赋给它。这在TypeScript中是有效的。在Java中是行不通的。为什么呢？
- en: 'We have never explicitly indicated that `ChocolateDonut` implements the `Donut`
    interface. If TypeScript did not use structural typing, you would need to refactor
    part of the preceding code to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未明确指出`ChocolateDonut`实现了`Donut`接口。如果TypeScript没有使用结构类型，你需要将前面的代码部分重构为以下内容：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The reasoning behind using structural typing is often referred as duck-typing:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构类型的原因通常被称为鸭子类型：
- en: If it walks like a duck and it quacks like a duck, then it must be a duck.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它走起来像鸭子，叫起来像鸭子，那么它一定是鸭子。
- en: Hence, `implements Donut` is not required in TypeScript, because `ChocolateDonut`
    already behaves like a donut, so it must be a donut. Hurray!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在TypeScript中不需要`implements Donut`，因为`ChocolateDonut`已经表现得像一个甜甜圈，所以它一定是一个甜甜圈。万岁！
- en: Immutability with TypeScript
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的不可变性
- en: In this section, I want to reiterate a point on immutability. This topic is
    huge in JavaScript, and in some cases, TypeScript may be a much better solution
    than any other path to immutability.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我想重申一下不可变性的观点。这个话题在JavaScript中非常重要，在某些情况下，TypeScript可能是比其他任何不可变性路径更好的解决方案。
- en: TypeScript comes with the special `readonly` keyword that enforces that a certain
    variable is read-only. You cannot mutate such a variable. This is enforced at
    compile time. Hence, you have no runtime checks for immutability. If this is a
    huge win for you, then you may not even need any API, such as Immutable.js. Immutable.js
    shines when you are required to clone huge objects to avoid mutations. If you
    can get away with a spread operation on your own, then it means your object may
    not be big enough for Immutable.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript带有特殊的`readonly`关键字，它强制某个变量是只读的。你不能改变这样的变量。这在编译时强制执行。因此，你没有不可变性的运行时检查。如果这对你来说是一个巨大的胜利，那么你甚至可能不需要任何API，比如Immutable.js。当你需要克隆大对象以避免变异时，Immutable.js就会发光。如果你可以自己使用扩展操作来解决问题，那么这意味着你的对象可能还不够大，不需要Immutable.js。
- en: readonly
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readonly
- en: 'Since our application is not super big yet, as an exercise, let''s replace
    Immutable.js with `readonly` from TypeScript:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序目前还不是很大，因此作为一个练习，让我们用TypeScript的`readonly`来替换Immutable.js：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This looks like a lot of repetition. We can use `Readonly< T >` instead:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有很多重复。我们可以使用`Readonly< T >`代替：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This looks much cleaner. However, it is not entirely immutable. You can still
    mutate the `entities` array. To prevent that, we need to use `ReadonlyArray<TaskType>`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来干净多了。然而，它并不完全不可变。你仍然可以改变`entities`数组。为了防止这种情况，我们需要使用`ReadonlyArray<TaskType>`：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The remaining work is to replace every `TaskType[]`  with `ReadonlyArray<TaskType>` throughout
    the entire application. Then you will need to change Immutable.js objects into
    standard JavaScript arrays. Such a refactor is long and does not fit in these
    book pages, but I have done the refactor in the code files. If you want to see
    what has changed, go to the code files directory at `src/Chapter_11/Example_5`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是在整个应用程序中用`ReadonlyArray<TaskType>`替换每个`TaskType[]`。然后，您需要将Immutable.js对象更改为标准的JavaScript数组。这样的重构很长，不适合这些书页，但我已经在代码文件中进行了重构。如果您想查看已更改的内容，请转到`src/Chapter_11/Example_5`的代码文件目录。
- en: Using linter to enforce immutability
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用linter来强制不可变性
- en: You may use the TypeScript linter to enforce the `readonly` keyword in TypeScript
    files. One of the open source solutions that allows you to do this is `tslint-immutable`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用TypeScript linter在TypeScript文件中强制使用`readonly`关键字。允许您执行此操作的开源解决方案之一是`tslint-immutable`。
- en: 'It adds additional rules to the `tslint.json` configuration file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它向`tslint.json`配置文件添加了额外的规则：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'From now on, when you run linter, you will see errors if you violate any of
    the preceding rules. I have refactored the code to comply with them. Check the
    full example in code files directory at `src/Chapter_11/Example_6`. To run linter,
    you may use the following command in the Terminal:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当您运行linter时，如果违反了前述规则，您将看到错误。我已经重构了代码以符合这些规则。在`src/Chapter_11/Example_6`的代码文件目录中检查完整示例。要运行linter，您可以在终端中使用以下命令：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you have learned about a very powerful tool: typed language
    built on top of JavaScript. Type checking has countless advantages for any code
    base. It prevents you from deploying a breaking change that definitely does not
    comply with what is expected. You have learned how to tell TypeScript what is
    allowed. You know what generic types are, and how to use them to reduce code repetition
    in typed files.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了一个非常强大的工具：建立在JavaScript之上的类型化语言。类型检查对于任何代码库都有无数的优势。它可以防止您部署违反预期的破坏性更改。您已经学会了如何告诉TypeScript什么是允许的。您知道什么是泛型类型，以及如何在类型文件中使用它们以减少代码重复。
- en: New tools come with new knowledge, so you have also learned the basics of type
    inference and structural typing. This part of TypeScript definitely requires trial
    and error. Practice it to understand it better.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 新工具带来了新知识，因此您还学会了类型推断和结构类型的基础知识。TypeScript的这一部分绝对需要反复试验。练习以更好地理解它。
- en: This is the last chapter of this book. I hope you have learned many interesting
    concepts and patterns. I have challenged you throughout this book; now it is time
    that you challenged your code base. See what fits your application and maybe rethink
    the choices you and your team made before.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章。我希望你已经学到了许多有趣的概念和模式。我在整本书中都在向你挑战；现在是你挑战你的代码库的时候了。看看哪些适合你的应用程序，也许重新思考你和你的团队之前所做的选择。
- en: Don't worry if you do not understand some patterns. Not all of them are a must.
    Some come with experience, some apply only to large code bases, and some are a
    matter of preference.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解某些模式，不要担心。并非所有模式都是必需的。有些是通过经验获得的，有些仅适用于大型代码库，有些是偏好问题。
- en: Choose the patterns that guarantee application correctness, as well as ones
    that enable you to add customer value more quickly. Good luck!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 选择能够保证应用程序正确性的模式，以及能够更快地为客户增加价值的模式。祝你好运！
- en: Further reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering TypeScript (Second edition),* Nathan Rozentals: This is a great
    book to learn TypeScript in depth. It demonstrates how to type some really advanced
    use cases. This is my personal recommendation, not the publisher''s.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通TypeScript（第二版）*，Nathan Rozentals：这是一本深入学习TypeScript的好书。它演示了如何对一些非常高级的用例进行类型化。这是我的个人推荐，而不是出版商的。'
- en: Official documentation for TypeScript can be found at [www.typescriptlang.org](http://www.typescriptlang.org).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的官方文档可以在[www.typescriptlang.org](http://www.typescriptlang.org)找到。
- en: The discussion of the call signatures issue, mentioned previously in this chapter,
    can be found in the TypeScript GitHub repository at [https://github.com/Microsoft/TypeScript/issues/7294](https://github.com/Microsoft/TypeScript/issues/7294).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面提到的调用签名问题的讨论可以在TypeScript GitHub存储库的[https://github.com/Microsoft/TypeScript/issues/7294](https://github.com/Microsoft/TypeScript/issues/7294)找到。
