- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Answers to questions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题的答案
- en: Here, we answer all the questions asked at the end of each chapter. You can
    use these questions to review what you have learned throughout the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们回答每章末尾提出的所有问题。您可以使用这些问题来回顾您在整本书中学到的知识。
- en: Chapter 1: Introducing React and React Hooks
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：介绍React和React Hooks
- en: What are React's three fundamental principles?
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React的三个基本原则是什么？
- en: '**Declarative**: Instead of telling React how to do things, we tell it what we
    want. As a result, we can easily design our applications and React will efficiently
    update and render just the right components when data changes.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明性的：** 我们告诉React我们想要什么，而不是告诉React如何做事。因此，我们可以轻松设计我们的应用程序，当数据发生变化时，React将高效地更新和渲染恰当的组件。'
- en: '**Component-based**: React encapsulates components that manage their own state
    and views, then allows us to compose them to create complex user interfaces.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于组件的：** React封装了管理自己状态和视图的组件，然后允许我们组合它们以创建复杂的用户界面。'
- en: '**Learn once, write anywhere:** React does not make assumptions about your
    technology stack and tries to ensure you can develop without rewriting existing
    code as much as possible.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学一次，随处编写：** React不对您的技术堆栈做出假设，并努力确保您可以尽可能少地重写现有代码来开发。'
- en: What are the two types of components in React?
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React中有哪两种类型的组件？
- en: '**Function components**: JavaScript functions that take the props as an argument
    and return the user interface (usually via JSX)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数组件：** 接受props作为参数并返回用户界面的JavaScript函数（通常通过JSX）'
- en: '**Class components**: JavaScript classes that provide a `render` method, which
    returns the user interface (usually via JSX)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类组件：** 提供`render`方法的JavaScript类，该方法返回用户界面（通常通过JSX）'
- en: What are the problems with class components in React?
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中类组件有哪些问题？
- en: 'JavaScript classes are hard to understand for developers: The `this` context
    can be confusing, and we sometimes have to write code in multiple places at once'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript类对开发人员来说也很难理解：`this`上下文可能令人困惑，有时我们不得不同时在多个地方编写代码。
- en: 'They are also hard to understand for machines: It is hard to tell which methods
    will be called and, as such, performance optimizations are not really possible'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们对机器也很难理解：很难说哪些方法会被调用，因此性能优化实际上并不可行。
- en: 'They are not declarative and thus go against React''s fundamental principles:
    To use React features, we have to write code that tells React what to do, not
    how to do it'
  id: totrans-14
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是声明性的，因此违反了React的基本原则：要使用React功能，我们必须编写代码告诉React要做什么，而不是如何做。
- en: What is the problem of using higher-order components in React?
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中使用高阶组件的问题是什么？
- en: Using higher-order components introduces components to our view tree that do
    not actually matter in terms of view structure. Having many higher-order components
    causes the so-called **wrapper hell**.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶组件会向我们的视图树引入实际上在视图结构方面并不重要的组件。拥有许多高阶组件会导致所谓的**包装器地狱**。
- en: Which tool can we use to set up a React project, and what is the command that
    we need to run to use it?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个工具来设置React项目，我们需要运行什么命令来使用它？
- en: We can use `create-react-app`. To create a new project, we have to run `npx
    create-react-app <app-name>` or `yarn create react-app <app-name>`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`create-react-app`。要创建一个新项目，我们必须运行`npx create-react-app <app-name>`或`yarn
    create react-app <app-name>`。
- en: 'What do we need to do if we get the following error with class components: *TypeError:
    undefined is not an object (evaluating ''this.setState'')*?'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果我们在类组件中遇到以下错误，我们需要做什么：*TypeError: undefined is not an object (evaluating
    ''this.setState'')*？'
- en: We forgot to re-bind the `this` context of the method in the `constructor` of
    our class. As a result, `this` is not pointing to the class but, instead, to the
    context of the input field.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们忘记在类的`constructor`中重新绑定方法的`this`上下文。结果，`this`指向的不是类，而是输入字段的上下文。
- en: How do we access and set React state using Hooks?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Hooks访问和设置React状态？
- en: 'We make use of the `useState()` Hook as follows: `const [ name, setName ] =
    useState('''')`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`useState()` Hook如下：`const [ name, setName ] = useState('')`
- en: What are the advantages of using function components with Hooks, in comparison
    to class components?
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与类组件相比，使用带有Hooks的函数组件的优势是什么？
- en: Function components with Hooks do not suffer from the same problems as classes.
    They are declarative and thus fit React's fundamental principles better. Hooks
    also make our code more concise and easier to understand.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有Hooks的函数组件不会遇到与类相同的问题。它们是声明性的，因此更适合React的基本原则。Hooks还使我们的代码更简洁，更易于理解。
- en: Do we need to replace all class components with function components using Hooks
    when updating React?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新React时，我们是否需要用Hooks替换所有类组件？
- en: No, we do not need to replace all class components. Function components with
    Hooks can work side-by-side with existing class components and are 100% backward-compatible.
    We can simply write new components using Hooks or upgrade existing components
    at our own pace.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，我们不需要替换所有类组件。带有Hooks的函数组件可以与现有的类组件并存，并且是100%向后兼容的。我们可以简单地使用Hooks编写新组件，或者以自己的步调升级现有组件。
- en: What are the three basic hooks provided by React?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React提供的三个基本Hooks是什么？
- en: The `useState`, `useEffect`, and `useContext` Hooks are the basic Hooks provided
    by React and used very frequently in projects. However, React also provides some
    more advanced Hooks out of the box.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`，`useEffect`和`useContext` Hooks是React提供的基本Hooks，并在项目中经常使用。但是，React还提供了一些更高级的Hooks。'
- en: Chapter 2: Using the State Hook
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：使用State Hook
- en: What problems did we run into while developing our own reimplementation of the
    `useState` hook? How did we solve these problems?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发自己的`useState` hook的重新实现时，我们遇到了什么问题？我们是如何解决这些问题的？
- en: One problem was the initialization of the value every time the component gets
    rendered. We solved this problem by using a global variable to store the value.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题是每次组件被渲染时值的初始化。我们通过使用全局变量来存储值来解决了这个问题。
- en: Then, we had the problem that multiple Hooks write to the same global variable.
    To solve this problem, we stored the values in an array and kept track of the
    current Hook by assigning an index to each Hook.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们遇到了多个Hooks写入同一个全局变量的问题。为了解决这个问题，我们将值存储在数组中，并通过为每个Hook分配索引来跟踪当前Hook。
- en: Why are conditional Hooks not possible in the React implementation of Hooks?
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在React的Hooks实现中不可能有条件Hooks？
- en: Conditional Hooks are not possible, because React uses the order of Hook definitions
    to keep track of the values. If we change the order of Hooks later on, the values
    will be assigned to different Hooks.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件Hooks是不可能的，因为React使用Hook定义的顺序来跟踪值。如果我们稍后更改Hooks的顺序，值将分配给不同的Hooks。
- en: What are Hooks and what do they deal with?
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hooks是什么，它们处理什么？
- en: Hooks are functions that deal with state and effects in a React application
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks是处理React应用程序中状态和效果的函数
- en: What do we need to watch out for when using Hooks?
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Hooks时，我们需要注意什么？
- en: We need to ensure that the order of Hooks always stays the same, so we cannot
    use Hooks in loops or conditionals
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保Hooks的顺序始终保持不变，因此我们不能在循环或条件语句中使用Hooks
- en: What are the common problems of alternative API ideas for Hooks?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hooks的替代API想法的常见问题是什么？
- en: Named Hooks have the problem of name collisions. Each Hook would have to have
    a unique name, even when using Hooks within libraries.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名钩子存在名称冲突的问题。即使在库中使用钩子时，每个钩子也必须具有唯一的名称。
- en: Hook factories require more boilerplate code, mainly instantiating each Hook
    twice, once outside of the component and once inside. Furthermore, they make it
    much harder to create custom Hooks.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子工厂需要更多的样板代码，主要是实例化每个钩子两次，一次在组件外部，一次在组件内部。此外，它们使得创建自定义钩子变得更加困难。
- en: How do we implement conditional Hooks?
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现条件钩子？
- en: In simple cases, we can always define the Hook. Otherwise, we have to split
    up the components and conditionally render a separate component instead of conditionally
    rendering the Hook.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在简单情况下，我们总是可以定义钩子。否则，我们必须拆分组件，并有条件地渲染一个单独的组件，而不是有条件地渲染钩子。
- en: How do we implement Hooks in loops?
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在循环中实现钩子？
- en: In simple cases, we can store an array in the State Hook. Otherwise, we have
    to split up the components and render a separate component in a loop.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在简单情况下，我们可以将数组存储在状态钩子中。否则，我们必须拆分组件并在循环中渲染一个单独的组件。
- en: 'Chapter 3: Writing Your First Application with React Hooks'
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：使用React Hooks编写您的第一个应用程序
- en: What is the best practice for folder structures in React?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中，文件结构的最佳实践是什么？
- en: Start with a simple structure at first and nest more deeply when needed. Do
    not spend too much time thinking about the file structure when starting a project.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先从一个简单的结构开始，需要时再进行更深层次的嵌套。在启动项目时，不要花太多时间考虑文件结构。
- en: Which principle should we use when splitting up React components?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在拆分React组件时应该使用哪个原则？
- en: The single responsibility principle, which states that every component should
    have responsibility over a single encapsulated part of the functionality
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则，即每个组件应对功能的单个封装部分负责
- en: What does the `map` function do?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`函数是做什么的？'
- en: The `map` function applies a given function to all elements of an array and
    returns a new array with the results
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`函数将给定的函数应用于数组的所有元素，并返回具有结果的新数组'
- en: How does destructuring work, and when do we use it?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解构是如何工作的，我们什么时候使用它？
- en: With destructuring, we can get properties from an object or elements from an
    array by specifying the structure and variable names on the left side of the assignment.
    We can use destructuring to get certain props in React components.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过解构，我们可以通过在赋值的左侧指定结构和变量名称来从对象中获取属性或从数组中获取元素。我们可以使用解构来获取React组件中的某些props。
- en: How does the spread operator work, and when do we use it?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展运算符是如何工作的，我们什么时候使用它？
- en: The spread operator inserts all properties of an object or all elements of an
    array at a certain point in another object/array. It can be used to create new
    arrays or objects or to pass on all properties of an object as props to a React
    component.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展运算符在另一个对象/数组的特定点插入对象的所有属性或数组的所有元素。它可以用于创建新的数组或对象，或者将对象的所有属性作为props传递给React组件。
- en: How do we deal with input fields using React Hooks?
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用React Hooks处理输入字段？
- en: We create a State Hook for the input field value and define a handler function
    that sets the value
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为输入字段值创建一个状态钩子，并定义一个设置值的处理函数
- en: Where should local State Hooks be defined?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地状态钩子应该在哪里定义？
- en: Local State Hooks should always be defined in the component where they are used
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地状态钩子应始终在使用它们的组件中定义
- en: What is global state?
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: Global state is state that is used across multiple components throughout the
    whole application
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局状态是在整个应用程序中跨多个组件使用的状态
- en: Where should global State Hooks be defined?
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局状态钩子应该在哪里定义？
- en: Global State Hooks should be defined as high up in the component tree as possible.
    In our case, we defined them in the `App` component.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局状态 Hook 应该尽可能高地定义在组件树中。在我们的例子中，我们在 `App` 组件中定义了它们。
- en: 'Chapter 4: Using the Reducer and Effect Hooks'
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用 Reducer 和 Effect Hooks
- en: What are common problems with State Hooks?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: State Hook 的常见问题是什么？
- en: Complex state changes are hard to do with State Hooks
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 State Hook 很难进行复杂的状态改变
- en: What are actions?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是动作？
- en: 'Actions are objects that describe a state change, for example, `{ type: ''CHANGE_FILTER'',
    byAuthor: ''Daniel Bugl'' }`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '动作是描述状态改变的对象，例如，`{ type: ''CHANGE_FILTER'', byAuthor: ''Daniel Bugl'' }`'
- en: What are reducers?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 reducer？
- en: Reducers are functions that process state changes. They accept the current state
    and an action object and return a new state.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer 是处理状态改变的函数。它们接受当前状态和一个动作对象，并返回一个新状态。
- en: When should we use a Reducer Hook instead of a State Hook?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用 Reducer Hook 而不是 State Hook？
- en: Reducer Hooks should be used when complex state changes are needed. Usually,
    this is the case for global state.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要复杂的状态改变时，应该使用 Reducer Hook。通常，这适用于全局状态。
- en: When setter functions of multiple State Hooks are called together, this is a
    good indicator for using a Reducer Hook instead.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个 State Hook 的 setter 函数一起被调用时，这是使用 Reducer Hook 的一个很好的指标。
- en: Which steps are needed in order to turn a State Hook into a Reducer Hook?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将 State Hook 转换为 Reducer Hook，需要哪些步骤？
- en: We first need to define actions, then the reducer function, and finally a Reducer
    Hook
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先需要定义动作，然后是 reducer 函数，最后是 Reducer Hook
- en: How can we create actions more easily?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更容易地创建动作？
- en: We could define functions that return action objects, so called **action creators**
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义返回动作对象的函数，称为**动作创建者**
- en: When should we merge Reducer Hooks?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该合并 Reducer Hook？
- en: When we want to avoid having two separate dispatch functions or when the same
    action modifies state in multiple reducers
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要避免有两个单独的 dispatch 函数或者同一个动作修改多个 reducer 中的状态时
- en: What do we need to watch out for when merging Reducer Hooks?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合并 Reducer Hook 时需要注意什么？
- en: We need to make sure that each reducer returns the current state for unhandled
    actions
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保每个 reducer 对于未处理的动作返回当前状态
- en: What is the equivalent of an Effect Hook in class components?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类组件中，Effect Hook 的等价物是什么？
- en: In React class components we would use `componentDidMount` and `componentDidUpdate`
    to deal with effects
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 类组件中，我们将使用 `componentDidMount` 和 `componentDidUpdate` 来处理效果
- en: What are the advantages of using an Effect Hook versus class components?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Effect Hook 相对于类组件有什么优势？
- en: With Effect Hooks we do not need to define both `componentDidMount` and `componentDidUpdate`.
    Furthermore, Effect Hooks are much easier to understand, and we do not need to
    know how React works internally to be able to use them.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Effect Hook 时，我们不需要同时定义 `componentDidMount` 和 `componentDidUpdate`。此外，Effect
    Hook 更容易理解，我们不需要知道 React 内部的工作原理就能使用它们。
- en: 'Chapter 5: Implementing React Context'
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：实现 React 上下文
- en: Which problem do contexts avoid?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文避免了哪些问题？
- en: Contexts avoid having to pass down props through multiple levels of components
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文避免了必须通过多个组件层级传递 props 的问题
- en: What are the two parts that contexts consist of?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文由哪两部分组成？
- en: React contexts consist of a provider and a consumer
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 上下文由提供者和消费者组成
- en: Are both parts required to be defined in order to use contexts?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上下文是否需要两部分都定义？
- en: The provider is not required, as contexts will use the default value passed
    to `React.createContext` when no provider is defined
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者不是必需的，因为当没有定义提供者时，上下文将使用传递给 `React.createContext` 的默认值
- en: What is the advantage of using Hooks instead of traditional context consumers?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Hooks 而不是传统上下文消费者的优势是什么？
- en: Hooks do not require using a component and render props for the consumer. Using
    multiple contexts with consumer components makes our component tree very deep
    and our app harder to debug and maintain. Hooks avoid this problem by allowing
    us to consume contexts by simply calling a Hook function.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks不需要使用组件和渲染props来进行消费。使用多个上下文和消费者组件会使我们的组件树变得非常深，使我们的应用程序更难调试和维护。Hooks通过允许我们通过简单调用Hook函数来消费上下文来避免这个问题。
- en: What is an alternative to contexts, and when should we use it?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文的替代方案是什么，什么时候应该使用它？
- en: Contexts make reusing components more difficult. Contexts should only be used
    when we need to access data in multiple components at different nesting levels.
    Otherwise, we can either pass down props or pass down the rendered component,
    using a technique called inversion of control.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文使得重用组件变得更加困难。只有在我们需要在不同嵌套级别的多个组件中访问数据时，才应该使用上下文。否则，我们可以通过传递props或传递渲染的组件来使用控制反转技术。
- en: How can we implement dynamically changing contexts?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现动态更改上下文？
- en: We need to use a State Hook to provide the value for the context provider
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用State Hook来为上下文提供值
- en: When does it make sense to use contexts for state?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么时候使用上下文来管理状态是有意义的？
- en: Usually, it makes sense to use contexts for global state, which is used across
    multiple components at different nesting levels
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，使用上下文来管理全局状态是有意义的，这些状态在不同嵌套级别的多个组件中使用。
- en: 'Chapter 6: Implementing Requests and React Suspense'
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：实现请求和React Suspense
- en: How can we easily create a full REST API from a simple JSON file?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从一个简单的JSON文件中轻松创建一个完整的REST API？
- en: We can use the `json-server` tool to create a full REST API from a JSON file
    for development and testing
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`json-server`工具从JSON文件创建一个完整的REST API，用于开发和测试
- en: What are the advantages of using a proxy to access our backend server during
    development?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发过程中使用代理访问后端服务器的优势是什么？
- en: When using a proxy, we do not need to deal with cross-site restrictions during
    development
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用代理时，在开发过程中我们不需要处理跨站点限制
- en: Which combinations of Hooks can we use to implement requests?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些组合的Hooks来实现请求？
- en: We can implement requests using an Effect and a State or Reducer Hook
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Effect和State或Reducer Hook来实现请求
- en: Which libraries can we use to implement requests?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些库来实现请求？
- en: We can also use the `axios` and `react-request-hook` libraries to implement
    requests
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`axios`和`react-request-hook`库来实现请求
- en: How can we deal with loading states using `react-request-hook`?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用`react-request-hook`处理加载状态？
- en: We can use the `result.isLoading` flag returned from the `useResource` Hook
    and conditionally display a loading message
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用从`useResource` Hook返回的`result.isLoading`标志，并有条件地显示加载消息
- en: How can we deal with errors using `react-request-hook`?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用`react-request-hook`处理错误？
- en: We can use the `result.error` object returned from the `useResource` Hook and
    dispatch an error action
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用从`useResource` Hook返回的`result.error`对象并分派错误操作
- en: How can we prevent unnecessary re-rendering of components?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何防止组件不必要的重新渲染？
- en: Using `React.memo`, we can prevent unnecessary re-rendering, similarly to `shouldComponentUpdate`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`React.memo`，我们可以防止不必要的重新渲染，类似于`shouldComponentUpdate`
- en: How can we reduce the bundle size of our app?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何减少应用程序的捆绑大小？
- en: We can use `React.Suspense` to lazily load certain components, which means that
    they will only be requested from the server when needed
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`React.Suspense`来延迟加载某些组件，这意味着只有在需要时才会从服务器请求它们。
- en: 'Chapter 7: Using Hooks for Routing'
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：使用Hooks进行路由
- en: Why do we need to define separate pages?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要定义单独的页面？
- en: Most large apps consist of multiple pages. For example, a separate page for
    each blog post
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数大型应用程序由多个页面组成。例如，每篇博客文章都有一个单独的页面
- en: How do we define routes using the Navi library?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Navi库定义路由？
- en: We use the `mount` function and pass an object mapping path to `route` functions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`mount`函数并传递一个将路径映射到`route`函数的对象
- en: How do we define routes with URL parameters?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用URL参数定义路由？
- en: We can use the `:parameter` syntax to specify URL parameters within the path
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`:parameter`语法在路径中指定URL参数
- en: How are static links defined with Navi?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Navi定义静态链接？
- en: Static links can be defined using the `Link` component from `react-navi`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`react-navi`中的`Link`组件来定义静态链接
- en: How can we implement dynamic navigation?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现动态导航？
- en: Dynamic navigation can be implemented using the `useNavigation` Hook and calling
    `navigation.navigate()`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`useNavigation` Hook并调用`navigation.navigate()`来实现动态导航
- en: Which Hook is used to access route information of the current route?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于访问当前路由信息的Hook是什么？
- en: The `useCurrentRoute` Hook gives us all information about the current route
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCurrentRoute` Hook为我们提供了关于当前路由的所有信息'
- en: Which Hook is used to access route information of the currently loading route?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于访问当前加载路由的Hook是什么？
- en: The `useLoadingRoute` Hook gives us all information about the route that is
    currently being loaded
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useLoadingRoute` Hook为我们提供了关于当前正在加载的路由的所有信息'
- en: 'Chapter 8: Using Community Hooks'
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用社区Hooks
- en: Which Hook can we use to simplify input field handling?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个Hook来简化输入字段处理？
- en: We can use the `useInput` Hook from the `react-hookedup` library
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`react-hookedup`库中的`useInput` Hook
- en: How are the `componentDidMount` and `componentWillUnmount` life cycles implemented
    using Effect Hooks?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Effect Hooks实现`componentDidMount`和`componentWillUnmount`生命周期？
- en: '`componentDidMount` can be implemented by using an Effect Hook with an empty
    array passed as the second argument. For example, `useEffect(() => console.log(''did
    mount''), [])`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount`可以通过使用Effect Hook并将空数组作为第二个参数传递来实现。例如，`useEffect(() => console.log(''did
    mount''), [])`。'
- en: '`componentWillUnmount` can be implemented by returning a function from an Effect
    Hook with an empty array passed as the second argument, for example, `useEffect(()
    => { return () => console.log(''will unmount'') }, [])`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`可以通过从Effect Hook返回一个函数来实现，其中空数组作为第二个参数传递，例如，`useEffect(()
    => { return () => console.log(''will unmount'') }, [])`。'
- en: How can we use Hooks to get the behavior of `this.setState()`?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Hooks来获得`this.setState()`的行为？
- en: '`this.setState()` merges the existing state object with the given state object.
    We can get the same behavior by using the `useMergeState` Hook instead of a simple
    State Hook.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.setState()`将现有状态对象与给定状态对象合并。我们可以使用`useMergeState` Hook来获得相同的行为，而不是简单的State
    Hook。'
- en: Why should we use timer Hooks instead of calling `setTimeout` and `setInterval` directly?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用定时器Hooks而不是直接调用`setTimeout`和`setInterval`？
- en: When defining simple timeouts or intervals they are going to reset when the
    component re-renders. To prevent this resetting from happening, we have to use
    the `useTimeout` and `useInterval` Hooks from `react-hookedup` instead.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义简单的超时或间隔时，当组件重新渲染时它们将被重置。为了防止这种重置发生，我们必须使用`react-hookedup`中的`useTimeout`和`useInterval`
    Hook。
- en: Which Hooks can we use to simplify dealing with common data structures?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些Hooks来简化处理常见数据结构？
- en: We can use the `useBoolean`, `useArray`, and `useCounter` Hooks from `react-hookedup`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`react-hookedup`中的`useBoolean`、`useArray`和`useCounter` Hooks
- en: When should we use responsive design with Hooks versus simply using CSS media
    queries?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用Hooks进行响应式设计，而不是简单地使用CSS媒体查询？
- en: We should use Hooks for responsive design when rendering elements within a canvas
    or WebGL, or when we dynamically want to decide whether to load components based
    on the window size
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在画布或WebGL中渲染元素时，或者当我们动态地想要根据窗口大小决定是否加载组件时，我们应该使用Hooks进行响应式设计
- en: Which Hook can we use to implement undo/redo functionality?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个Hook来实现撤销/重做功能？
- en: We can use the `useUndo` Hook from the `use-undo` library to implement simple
    undo/redo functionality in our app
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`use-undo`库中的`useUndo` Hook来在我们的应用程序中实现简单的撤销/重做功能
- en: What is debouncing? Why do we need to do it?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是防抖动？为什么我们需要这样做？
- en: Debouncing means that a function will only be called after a certain amount
    of time, not every time an event triggers it. Using debouncing, we can store a
    value entered in a text field in the undo history only after each second, not
    after every typed character.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防抖动意味着函数只会在一定时间后被调用，而不是每次事件触发时都被调用。使用防抖动，我们可以在文本字段中输入的值仅在每秒后存储在撤销历史中，而不是在每次输入字符后。
- en: Which Hook can we use for debouncing?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个Hook来进行防抖动？
- en: We can use the `useDebounce` or the `useDebouncedCallback` Hook from the `use-debounce`
    library
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`use-debounce`库中的`useDebounce`或`useDebouncedCallback` Hook
- en: 'Chapter 9: Rules of Hooks'
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：Hook的规则
- en: Where can Hooks be called?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hook可以在哪里调用？
- en: Hooks can only be called at the beginning of React function components or custom
    Hooks
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook只能在React函数组件或自定义Hook的开头调用
- en: Can we use Hooks in React class components?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在React类组件中使用Hook吗？
- en: No, it is not possible to use Hooks in React class components
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，不可能在React类组件中使用Hook
- en: What do we need to watch out for regarding the order of Hooks?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于Hook的顺序，我们需要注意什么？
- en: The order of Hooks should never change, as it is used to track the values of
    various Hooks
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook的顺序不应该改变，因为它用于跟踪各种Hook的值
- en: Can hooks be called inside conditions, loops, or nested functions?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hook可以在条件语句、循环或嵌套函数中调用吗？
- en: No, Hooks cannot be called inside conditionals, loops, or nested functions,
    because that would change the order of Hooks
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，Hook不能在条件语句、循环或嵌套函数中调用，因为那样会改变Hook的顺序
- en: What is the naming convention for Hooks?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hook的命名约定是什么？
- en: 'Hook function names should always start with a `use` prefix and then a name
    in `CamelCase`. For example: `useSomeHookName`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook函数名称应始终以`use`前缀开头，然后是`CamelCase`中的名称。例如：`useSomeHookName`。
- en: How can we automatically enforce the rules of Hooks?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何自动强制执行Hook的规则？
- en: We can use `eslint` with `eslint-plugin-react-hooks` to enforce the rules of
    Hooks
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`eslint`和`eslint-plugin-react-hooks`来强制执行Hook的规则
- en: What is the exhaustive dependencies rule?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详尽的依赖规则是什么？
- en: The exhaustive dependencies rule ensures that in an Effect Hook all variables
    that are used are listed as dependencies via the second argument
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详尽的依赖规则确保在Effect Hook中使用的所有变量都通过第二个参数列为依赖项
- en: How can we automatically fix linter warnings?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何自动修复linter警告？
- en: We can run the `npm run lint -- --fix` command to automatically fix linter warnings.
    Running this command will, for example, automatically enter all variables used
    in an Effect Hook as dependencies.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以运行`npm run lint -- --fix`命令来自动修复linter警告。例如，运行此命令将自动将Effect Hook中使用的所有变量输入为依赖项。
- en: 'Chapter 10: Building Your Own Hooks'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：构建自己的Hooks
- en: How can we extract a custom Hook from existing code?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从现有代码中提取自定义Hook？
- en: We can simply put our code into a separate function. In custom Hook functions
    other Hook functions can be used, but we need to make sure not to violate the
    rules of Hooks.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以简单地将我们的代码放入一个单独的函数中。在自定义Hook函数中可以使用其他Hook函数，但我们需要确保不违反Hook的规则。
- en: What is the advantage of creating API Hooks?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建API Hooks的优势是什么？
- en: When defining separate functions for the various API calls, we can easily adjust
    them if the API changes later on, because we have all the API-related code in
    one place
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当为各种API调用定义单独的函数时，如果API以后发生更改，我们可以很容易地调整它们，因为我们把所有与API相关的代码放在一个地方
- en: When should we extract functionality into a custom Hook?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们何时应该将功能提取到自定义Hook中？
- en: We should create a custom Hook when a certain functionality is used in multiple
    places or when it could be re-used later on
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当某个功能在多个地方使用或以后可能被重复使用时，我们应该创建一个自定义Hook
- en: How do we use custom Hooks?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用自定义Hooks？
- en: We can simply call custom Hooks just like we would call official React Hooks
    or Hooks from libraries
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以像调用官方React Hooks或来自库的Hooks一样简单地调用自定义Hooks
- en: When should we create local Hooks?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该创建本地Hooks？
- en: Local Hooks can be used when we want to encapsulate a certain functionality
    in a separate function, but it will only be used in a single component
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要将某个功能封装在单独的函数中，但它只会在单个组件中使用时，可以使用本地Hooks
- en: Which interactions between Hooks are possible?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hooks之间有哪些交互？
- en: We can use other Hooks in Hook functions and we can pass values from other Hooks
    to Hooks
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在Hook函数中使用其他Hooks，并且可以从其他Hooks传递值到Hooks
- en: Which library can we use to test Hooks?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个库来测试Hooks？
- en: We can use the `jest` test runner in combination with the React Hooks Testing
    Library (`@testing-library/react-hooks`) and the `react-test-renderer` to test
    Hooks
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`jest`测试运行器与React Hooks测试库（`@testing-library/react-hooks`）和`react-test-renderer`来测试Hooks
- en: How can we test Hook actions?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试Hook动作？
- en: Hook actions can be tested by using the `act` function. For example, `act(()
    => result.current.increment())`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`act`函数来测试Hook动作。例如，`act(() => result.current.increment())`。
- en: How can we test contexts?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试上下文？
- en: 'Contexts can be tested by writing a context wrapper function, which returns
    the provider. The wrapper function can then be passed to the `renderHook` function.
    For example, `const { result } = renderHook(() => useTheme(), { wrapper: ThemeContextWrapper
    })`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '通过编写一个上下文包装函数来测试上下文，该函数返回提供者。然后可以将包装函数传递给`renderHook`函数。例如，`const { result
    } = renderHook(() => useTheme(), { wrapper: ThemeContextWrapper })`。'
- en: How can we test asynchronous code?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试异步代码？
- en: We can use the async/await construct in combination with the `waitForNextUpdate`
    function returned from `renderHook` to wait for asynchronous code to finish running
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用与从`renderHook`返回的`waitForNextUpdate`函数结合使用async/await构造来等待异步代码完成运行
- en: 'Chapter 11: Migrating from React Class Components'
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：从React类组件迁移
- en: How are React class components defined?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React类组件是如何定义的？
- en: React class components are defined by using `class ComponentName extends React.Component
    {`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React类组件是通过使用`class ComponentName extends React.Component {`来定义的
- en: What do we need to call when using a `constructor` with class components? Why?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用类组件的`constructor`时，我们需要调用什么？为什么？
- en: We first need to call `super(props)` to ensure that the props get passed on
    to the `React.Component` class
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先需要调用`super(props)`来确保props被传递给`React.Component`类
- en: How do we set the initial state with class components?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在类组件中设置初始状态？
- en: We can set the initial state in class components by defining the `this.state`
    object in the `constructor`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过在`constructor`中定义`this.state`对象来在类组件中设置初始状态
- en: How do we change the state with class components?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何改变类组件的状态？
- en: In class components, we use `this.setState()` to change the state
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类组件中，我们使用`this.setState()`来改变状态
- en: Why do we need to re-bind the `this` context with class component methods?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要重新绑定类组件方法的`this`上下文？
- en: When passing a method to an element as event handler, the `this` context changes
    to the element that triggered the event. We need to re-bind the `this` context
    to the class to prevent this from happening.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将方法传递给元素作为事件处理程序时，`this`上下文会更改为触发事件的元素。我们需要重新绑定`this`上下文到类以防止这种情况发生。
- en: How can we re-bind the `this` context?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何重新绑定`this`上下文？
- en: We need to use `.bind(this)` on the method in the constructor. For example, `this.handleInput
    = this.handleInput.bind(this)`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在构造函数中对方法使用`.bind(this)`。例如，`this.handleInput = this.handleInput.bind(this)`。
- en: How can we use React context with class components?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在类组件中使用React上下文？
- en: We can set the `contextType` and then access `this.context`. For example, `static
    contextType = StateContext`.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以设置`contextType`，然后访问`this.context`。例如，`static contextType = StateContext`。
- en: 'If we want to use multiple contexts, we can use context consumers. For example, `<StateContext.Consumer>{value
    => <div>State is: {value}</div>}</StateContext.Consumer>`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果我们想使用多个上下文，我们可以使用上下文消费者。例如，`<StateContext.Consumer>{value => <div>State is:
    {value}</div>}</StateContext.Consumer>`。'
- en: What can we replace state management with when migrating to Hooks?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在迁移到Hooks时，我们可以用什么替换状态管理？
- en: We can replace `this.state` and `this.setState` with a State Hook
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用State Hook替换`this.state`和`this.setState`。
- en: What are the trade-offs of using Hooks versus class components?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hooks与类组件相比有哪些权衡？
- en: Function components with Hooks are simpler (no need to deal with constructors,
    `this`, or destructuring the same values multiple times, no magic when dealing
    with contexts, props, and state, no need to define both `componentDidMount` and
    `componentDidUpdate`). Function components also encourage making small and simple
    components, are easier to refactor and test, require less code, are easier to
    understand for beginners, and are more declarative.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks的函数组件更简单（不需要处理构造函数、`this`或多次解构相同的值，处理上下文、props和状态时没有魔法，不需要同时定义`componentDidMount`和`componentDidUpdate`）。函数组件还鼓励创建小而简单的组件，更容易重构和测试，需要更少的代码，对初学者更容易理解，更具有声明性。
- en: However, class components can be fine when sticking to certain conventions and
    using the latest JavaScript features to avoid `this` re-binding. Furthermore,
    class components might be easier to understand for the team, because of existing
    knowledge.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，当遵循特定约定并使用最新的JavaScript特性来避免`this`重新绑定时，类组件可能是可以的。此外，由于具有现有知识，类组件可能更容易为团队理解。
- en: When and how should an existing project be migrated to Hooks?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时以及如何将现有项目迁移到Hooks？
- en: Slowly replace old class components with Hook-based function components when
    appropriate. For example, when you are already refactoring a component.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的时候逐步用基于Hook的函数组件替换旧的类组件。例如，当您已经在重构一个组件时。
- en: 'Chapter 12: Redux and Hooks'
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章：Redux和Hooks
- en: What kind of state should Redux be used for?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux应该用于哪种状态？
- en: Redux should be used for global state, which is state that is used in multiple
    components across our app
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux应该用于全局状态，即在我们的应用程序中多个组件中使用的状态。
- en: Which elements does Redux consist of?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux由哪些元素组成？
- en: Redux consists of the **store** (an object that describes the full state of
    our application), **actions** (objects that describe state modifications), **action
    creators** (functions that create action objects), **reducers** (functions that
    take the current state and an action object and return a new state), and **connectors**
    (higher-order components that connect an existing component to Redux)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux由**store**（描述应用程序完整状态的对象）、**actions**（描述状态修改的对象）、**action creators**（创建操作对象的函数）、**reducers**（接受当前状态和操作对象并返回新状态的函数）和**connectors**（将现有组件连接到Redux的高阶组件）组成
- en: What are the three principles of Redux?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux的三个原则是什么？
- en: Single source of truth (data should always have a single source)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一数据源（数据应始终具有单一来源）
- en: Read-only state (it is not possible to modify state directly, only through dispatching
    actions)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读状态（不可能直接修改状态，只能通过分派操作来修改）
- en: State changes are processed with pure functions (given the same state and action,
    reducers will always return the same new state)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态更改通过纯函数处理（给定相同的状态和操作，reducer将始终返回相同的新状态）
- en: Why do we define action types?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要定义操作类型？
- en: Action types avoid making typos when defining or comparing the `type` property
    of actions
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作类型避免在定义或比较动作的`type`属性时出现拼写错误。
- en: How can we connect components to Redux?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将组件连接到Redux？
- en: We can either use the `connect` higher-order component, or Dispatch and Selector
    Hooks
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`connect`高阶组件，也可以使用Dispatch和Selector Hooks。
- en: Which Hooks can we use with Redux?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些Hooks与Redux一起使用？
- en: '`useDispatch` to get the dispatch function, `useSelector` to get a certain
    part of the state, and `useStore` to get the Redux store (for special use cases,
    such as replacing reducers)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useDispatch`来获取分发函数，使用`useSelector`来获取状态的某个部分，使用`useStore`来获取Redux存储（用于特殊用例，比如替换reducers）。
- en: Why should we create reusable selectors?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该创建可重用的选择器？
- en: Reusable selectors can be used in multiple components. Furthermore, they memoize
    the result and only recompute it when the state changes.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用的选择器可以在多个组件中使用。此外，它们会记忆结果，并且只在状态改变时重新计算。
- en: How can we migrate a Redux application?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何迁移Redux应用程序？
- en: We should first replace simple local state, such as input field values, with
    State Hooks. Then replace complex local state with Reducer Hooks. We keep global
    state, which is used across multiple components, in the Redux store. Finally,
    we use the Selector and Dispatch Hooks instead of the `connect` higher-order component.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该首先用State Hooks替换简单的本地状态，比如输入字段的值。然后用Reducer Hooks替换复杂的本地状态。我们将全局状态（在多个组件中使用）保留在Redux存储中。最后，我们使用Selector和Dispatch
    Hooks来代替`connect`高阶组件。
- en: What are the trade-offs of Redux?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux的权衡是什么？
- en: 'The pros of using Redux are: It provides a certain project structure that allows
    us to easily extend and modify code later on, there are fewer possibilities for
    errors in our code, it has better performance than simply using React context
    for state, and it makes our `App` component much simpler by offloading state management
    and action creators to Redux'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux的优点是：它提供了一定的项目结构，使我们可以轻松地扩展和修改代码，代码中的错误可能性较少，它的性能比仅使用React上下文来管理状态要好，并且通过将状态管理和动作创建者转移到Redux，使我们的`App`组件变得更简单。
- en: 'The downsides of using Redux are: It requires a lot of boilerplate code, the
    project structure becomes more complicated, and it requires a wrapper component
    (`Provider`) to connect the app to the store'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux的缺点是：它需要大量样板代码，项目结构变得更加复杂，并且需要一个包装组件（`Provider`）来连接应用程序到存储。
- en: When should we use Redux?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们何时应该使用Redux？
- en: We should use Redux only for applications that require complex state changes.
    For simple projects, Reducer Hooks or even just State Hooks might be enough.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该只在需要复杂状态更改的应用程序中使用Redux。对于简单项目，Reducer Hooks甚至只使用State Hooks可能就足够了。
- en: 'Chapter 13: MobX and Hooks'
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：MobX和Hooks
- en: Which elements form the MobX life cycle?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些元素构成MobX的生命周期？
- en: Events invoke **actions**, which modify state. **State** is observable and should
    not contain redundant or derivable data. **Computed values** are derived from
    the state through pure functions. **Reactions** are like computed values, but
    they can also produce a side-effect, such as updating the user interface in React.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件调用**动作**，从而修改状态。**状态**是可观察的，不应包含冗余或可推导的数据。**计算值**是通过纯函数从状态派生出来的。**反应**类似于计算值，但它们也可以产生副作用，比如在React中更新用户界面。
- en: Which decorators does MobX provide?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobX提供哪些装饰器？
- en: 'MobX provides decorators for the various elements: `observer`, `observable`,
    `computed`, and `action`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX为各种元素提供装饰器：`observer`、`observable`、`computed`和`action`。
- en: How can we connect components to MobX?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将组件连接到MobX？
- en: We can connect our app to the MobX store by using the `Provider` component and
    then connect components via the `inject` higher-order component. If we want a
    component to automatically re-render on state changes, we also need to wrap it
    with the `observer` decorator function.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Provider`组件将我们的应用连接到MobX存储，然后通过`inject`高阶组件连接组件。如果我们希望组件在状态更改时自动重新渲染，还需要使用`observer`修饰函数来包装它。
- en: Which Hooks does MobX provide?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobX提供了哪些Hooks？
- en: We can use the `useObserver` Hook to define parts of our component that should
    re-compute when the state changes
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`useObserver` Hook来定义组件的部分，在状态更改时应该重新计算。
- en: How can we access the MobX store using Hooks?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Hooks访问MobX存储？
- en: MobX provides a context, which can be used to create custom Hooks that access
    the MobX stores. We can use a normal Context Hook to access the `MobXProviderContext`
    from `mobx-react`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX提供了一个上下文，可以用来创建访问MobX存储的自定义Hooks。我们可以使用普通的上下文Hook来访问`mobx-react`中的`MobXProviderContext`。
- en: Can we store local state using MobX?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用MobX存储本地状态吗？
- en: Yes, with MobX we can create as many stores as we want. MobX even provides a
    `useLocalStore` Hook to create local stores.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，使用MobX，我们可以创建任意数量的存储。MobX甚至提供了一个`useLocalStore` Hook来创建本地存储。
- en: How should we go about migrating an existing MobX application to Hooks?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该如何将现有的MobX应用迁移到Hooks？
- en: We can slowly upgrade certain parts of our MobX applications. Instead of the
    `inject` higher-order component, we can use a custom Hook that accesses a part
    of the context. Instead of the `observer` higher-order component, we can use the
    `useObserver` Hook.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以逐步升级MobX应用的某些部分。我们可以使用自定义Hook来访问上下文的一部分，而不是`inject`高阶组件。我们可以使用`useObserver`
    Hook来替代`observer`高阶组件。
- en: We should first use a State Hook for simple local state, then a `useLocalState` Hook
    for complex local state, and finally keep global state in separate MobX stores.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该首先使用State Hook来处理简单的本地状态，然后使用`useLocalState` Hook来处理复杂的本地状态，最后将全局状态保留在单独的MobX存储中。
- en: What are the advantages of using MobX?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MobX的优势是什么？
- en: It provides a simple way of dealing with state changes, requires less boilerplate
    code, provides more flexibility in how our application code is structured, allows
    using multiple global and local stores, and makes the `App` component much simpler
    by offloading state management and actions to MobX
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了处理状态更改的简单方式，需要更少的样板代码，在应用代码结构方面提供了更多的灵活性，允许使用多个全局和本地存储，并通过将状态管理和操作交给MobX使`App`组件变得更简单。
- en: What are the disadvantages of using MobX?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MobX的缺点是什么？
- en: It allows state changes to happen anywhere, not just in a single store, which
    could make our app more unpredictable. More flexibility also means it is possible
    to structure the project in a bad way and cause errors or bugs. Furthermore, MobX
    requires a wrapper component to connect the app to the store if we want to get
    all features (we could directly import and use the MobX store, but it would break
    features such as server-side rendering).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许状态更改发生在任何地方，而不仅仅是在单个存储中，这可能会使我们的应用更加不可预测。更多的灵活性也意味着可能以不好的方式构建项目并导致错误或缺陷。此外，如果我们想要获得所有功能，MobX需要一个包装组件将应用连接到存储（我们可以直接导入和使用MobX存储，但这将破坏诸如服务器端渲染之类的功能）。
- en: When should MobX not be used?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么时候不应该使用MobX？
- en: MobX should not be used if state changes are simple and only local state within
    components is used. In that case, State and Reducer Hooks might be enough.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态更改简单且仅使用组件内的本地状态，则不应使用MobX。在这种情况下，状态和Reducer Hooks可能足够了。
