- en: Elements of Functional Programming Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程模式的元素
- en: This is an advanced chapter that focuses on the functional programming paradigm
    and design patterns that come from the functional programming world. It is high
    time to dive deep into why we have the option of creating stateless and stateful
    components. This comes down to understanding what pure functions are and how immutable
    objects help us to predict application behavior. Once we have clarified that,
    we will move on to higher-order functions and higher-order components. You have
    used them already many times, but this time we will look at them from a slightly
    different perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个专注于函数式编程范式和设计模式的高级章节，这些设计模式来自函数式编程世界。现在是深入了解为什么我们可以创建无状态和有状态组件的时候了。这归结于理解纯函数是什么，以及不可变对象如何帮助我们预测应用程序的行为。一旦我们搞清楚了这一点，我们将继续讨论高阶函数和高阶组件。你已经多次使用过它们，但这一次我们将从稍微不同的角度来看待它们。
- en: Throughout this book, I have challenged you with many concepts that will get
    much much clearer after reading this chapter. I hope you will embrace them in
    your applications and use them wisely, keeping in mind the maturity of your team.
    These patterns are good to know but are not essential to either React or React
    Native development. However, at some point when reading pull requests to the React
    or React Native repositories, you will find yourself referring back to this chapter
    quite often.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我向你提出了许多概念，在阅读完这一章后，这些概念会变得更加清晰。我希望你能在应用程序中接受它们并明智地使用它们，牢记你的团队的成熟度。这些模式是值得了解的，但对于React或React
    Native的开发并非必不可少。然而，当阅读React或React Native存储库的拉取请求时，你会发现自己经常参考这一章。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mutable and immutable structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变和不可变结构
- en: Specific functions, such as pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定函数，如纯函数
- en: '`Maybe` monad and the monad pattern'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Maybe`单子和单子模式'
- en: Functional programming benefits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的好处
- en: Caching and memorization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存和记忆
- en: Mutable and immutable objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变和不可变对象
- en: This concept surprised me in one of my coding interviews. At the beginning of
    my career, I had little knowledge of mutable and immutable objects and it backfired
    without me even realizing the root cause.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念在我的一次编程面试中让我感到惊讶。在我职业生涯的开始，我对可变和不可变对象知之甚少，而这甚至在我没有意识到根本原因的情况下产生了不良后果。
- en: In [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store Patterns,*
    I explained the basics of mutability and immutability. We even used the `Immutable.js`
    library. That part of the book was heavily focused on the store. Now let's look
    at the bigger picture. Why do we even need mutable or immutable objects?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)中，*存储模式*，我解释了可变性和不可变性的基础知识。我们甚至使用了`Immutable.js`库。这部分书重点关注了存储。现在让我们来看看更大的图景。我们为什么需要可变或不可变的对象？
- en: Usually, the main reason is the ability to quickly reason about our application's
    behavior. For instance, React wants to quickly check whether it should re-render
    components. If you create object *A* and you are guaranteed that it won't ever
    change, then to reassure yourself that nothing changed, the only thing you need
    to do is compare the reference to the object. If it is the same as before, then
    object *A* remained unchanged. If object *A* could change, we would need to compare
    every single nested key within object *A* to be sure it remained unchanged. If
    object *A* had nested objects and we wanted to know whether those did not change,
    we would need to repeat the process for the nested objects. This is a lot of work,
    especially as object *A* grows. But why would we need to do it this way?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，主要原因是能够快速推断我们应用的行为。例如，React想要快速检查是否应该重新渲染组件。如果你创建了对象*A*并且可以保证它永远不会改变，那么为了确保没有任何更改，你唯一需要做的就是比较对象的引用。如果它与之前相同，那么对象*A*保持不变。如果对象*A*可能会改变，我们需要比较对象*A*中的每个嵌套键，以确保它保持不变。如果对象*A*有嵌套对象，并且我们想知道它们是否没有改变，我们需要为嵌套对象重复这个过程。这是很多工作，特别是当对象*A*增长时。但为什么我们需要以这种方式做呢？
- en: Immutable primitives in JavaScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的不可变原始数据类型
- en: In JavaScript, primitive data types (number, string, Boolean, undefined, null,
    and symbol) are immutable. Objects are mutable. In addition, JavaScript is loosely
    typed; that means the variable does not need to be of a certain type. For instance,
    you may declare variable A and assign the number 5 to it, and then later decide
    to assign an object to it. JavaScript allows that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，原始数据类型（数字、字符串、布尔值、未定义、null和符号）是不可变的。对象是可变的。此外，JavaScript是弱类型的；这意味着变量不需要是某种类型。例如，你可以声明变量A并将数字5赋给它，然后稍后决定将对象赋给它。JavaScript允许这样做。
- en: 'To simplify things, the community has created two very important movements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，社区创建了两个非常重要的运动：
- en: Libraries that guarantee immutability of objects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证对象的不可变性的库
- en: Static type-checkers for JavaScript, such as Flow or TypeScript
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的静态类型检查器，如Flow或TypeScript
- en: The first one provides functions to create objects that guarantee their immutability.
    This means that, whenever you want to change something within an object, it will
    clone itself, apply the change, and return a brand new immutable object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提供了创建对象的功能，保证它们的不可变性。这意味着，每当你想要改变对象中的某些东西时，它会克隆自身，应用更改，并返回一个全新的不可变对象。
- en: The second, static type-checkers, primarily solves the problem of human error
    when developers accidentally try to assign a value of a different type than initially
    expected. Hence, if you declare `variableA` to be a number, you can never assign
    a string to it. To us, it means type immutability. If you want a different type,
    you need to create a new variable and map `variableA` to it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，静态类型检查器，主要解决了开发人员在意外尝试将值分配给与最初预期的不同类型的变量时的人为错误问题。因此，如果你声明`variableA`是一个数字，你永远不能将一个字符串赋给它。对我们来说，这意味着类型的不可变性。如果你想要不同的类型，你需要创建一个新的变量并将`variableA`映射到它。
- en: 'An important side note on the `const` keyword: `const` operates on the reference
    level. It forbids a reference change. The value of a constant variable cannot
    be reassigned and cannot be redeclared. With primitive immutable types, it simply
    means freezing them for life. You can never reassign a new value to the variable.
    Trying to assign a different value will also fail, because primitives are immutable
    and it simply means creating a brand new reference. With objects that are mutable
    types, it simply means freezing the object reference. We cannot reassign a new
    object to the variable, but we can change the contents of the object. This means
    we can mutate what is inside. This is not very useful.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`const`关键字的一个重要说明：`const`在引用级别上运作。它禁止引用更改。常量变量的值不能被重新分配，也不能被重新声明。对于原始的不可变类型，它只是意味着永久冻结它们。你永远不能重新分配一个新值给变量。尝试分配不同的值也会失败，因为原始类型是不可变的，这只是意味着创建一个全新的引用。对于可变类型的对象，它只是意味着冻结对象引用。我们不能将一个新对象重新分配给变量，但我们可以改变对象的内容。这意味着我们可以改变内部的内容。这并不是很有用。
- en: Immutability cost explained
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性成本解释
- en: When I was first introduced to this concept, I started to scratch my head. How
    is it any faster? If you want to modify an object, you need to clone it and this
    is a serious cost with any simple change. I thought it was unacceptable. I assumed
    it was the same cost as if we were performing equality check on every level. I
    was both right and wrong.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次接触到这个概念时，我开始挠头。这样会更快吗？如果你想修改一个对象，你需要克隆它，这是任何简单改变的严重成本。我认为这是不可接受的。我假设它的成本与我们在每个级别执行相等检查是一样的。我既对也错。
- en: It depends on the tools you use. Special data structures, such as Immutable.js,
    make numerous optimizations to work easily. However, if you clone your objects
    with the `spread` operator or `Object.assign()`, then you recreate the whole object
    again or unknowingly just clone one level deep.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你使用的工具。特殊的数据结构，比如Immutable.js，进行了许多优化，以便轻松工作。然而，如果你用`spread`运算符或`Object.assign()`克隆你的对象，那么你会重新创建整个对象，或者在不知不觉中只是克隆一层。
- en: '"For deep cloning, we need to use other alternatives because Object.assign()
    copies property values. If the source value is a reference to an object, it only
    copies that reference value."'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “对于深层克隆，我们需要使用其他替代方案，因为Object.assign()只会复制属性值。如果源值是对对象的引用，它只会复制该引用值。”
- en: '- Mozilla JavaScript Documentation'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '- Mozilla JavaScript文档'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).  "Spread
    syntax effectively goes one level deep while copying an array. Therefore, it may
    be unsuitable for copying multidimensional arrays [...] (it''s the same with Object.assign()
    and spread syntax)."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)。“扩展语法在复制数组时有效地进入一层。因此，它可能不适用于复制多维数组[...]（与Object.assign()和扩展语法相同）。”'
- en: '- Mozilla JavaScript Documentation'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '- Mozilla JavaScript文档'
- en: '[https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Operators/Spread_syntax).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Operators/Spread_syntax).'
- en: 'This is very convenient and we abuse this fact many times in React apps. Let''s
    look at this with an example. The following is the object we will perform operations
    on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，我们在React应用程序中经常滥用这一事实。让我们通过一个例子来看看这一点。以下是我们将执行操作的对象：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we will clone just one level deep, and then mutate something two levels
    deep in the cloned object. Observe what happens to the original object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将只克隆一层深，然后在克隆的对象中对两层深的东西进行变异。观察原始对象会发生什么。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is one of the gotchas of mutations. If you are not proficient enough to
    understand what is going on, you may generate bugs that are incredibly hard to
    fix. The question is, how do we clone two levels deep? See the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是变异的一个陷阱。如果您不熟练地理解发生了什么，您可能会产生难以修复的错误。问题是，我们如何克隆两层深？请参见以下内容：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you need to, you may use this technique to copy the whole object this way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以使用这种技术来以这种方式复制整个对象。
- en: Copying just one level deep is often called a **shallow copy**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仅复制一层被称为**浅复制**。
- en: Benchmark on read/write operations
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读/写操作基准测试
- en: To better understand the tradeoffs and which library to decide on for your specific
    use case, please have a look at the read and write operations benchmarks. This
    should serve as a general idea. Please run your own tests before making the final
    call.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解权衡和决定哪个库适合您的特定用例，请查看读写操作的基准测试。这应该作为一个一般的想法。在最终决定之前，请进行自己的测试。
- en: I have used the benchmarks created by [ImmutableAssign authors](https://github.com/engineforce/ImmutableAssign/).
    The code automatically compares numerous libraries and approaches to solve immutability
    in JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了由[ImmutableAssign作者](https://github.com/engineforce/ImmutableAssign/)创建的基准测试。该代码自动比较了许多库和方法来解决JavaScript中的不可变性。
- en: 'First, let''s look at pure JavaScript with just simple mutable structures.
    We do not care about any benefits, just use them as is for a benchmark:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看纯JavaScript，只使用简单的可变结构。我们不关心任何好处，只是用它们作为基准测试：
- en: '| Nearly-new MacBook Pro 15'''' (2018) with no background tasks | MacBook Pro
    15'''' (2016) with a few background tasks running |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 几乎全新的MacBook Pro 15''''（2018）没有后台任务 | MacBook Pro 15''''（2016）有一些后台任务在运行
    |'
- en: '| **Mutable objects and arrays**  Object: read (x500000): 9 ms  Object: write
    (x100000): 3 ms  Object: very deep read (x500000): 31 ms  Object: very deep write
    (x100000): 9 ms  Object: merge (x100000): 17 ms  Array: read (x500000): 4 ms 
    Array: write (x100000): 3 ms  Array: deep read (x500000): 5 ms  Array: deep write
    (x100000): 2 ms  Total elapsed  49 ms (read) + **17 ms (write)** + 17 ms   (merge)
    = 83 ms. | **Mutable objects and arrays**  Object: read (x500000): 11 ms  Object:
    write (x100000): 4 ms  Object: very deep read (x500000): 42 ms  Object: very deep
    write (x100000): 12 ms  Object: merge (x100000): 17 ms  Array: read (x500000):
    7 ms  Array: write (x100000): 3 ms  Array: deep read (x500000): 7 ms  Array: deep
    write (x100000): 3 ms  Total elapsed  67 ms (read) + **22 ms (write)** + 17 ms
    (merge)  = 106 ms. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **可变对象和数组** 对象：读取（x500000）：9毫秒 对象：写入（x100000）：3毫秒 对象：非常深的读取（x500000）：31毫秒
    对象：非常深的写入（x100000）：9毫秒 对象：合并（x100000）：17毫秒 数组：读取（x500000）：4毫秒 数组：写入（x100000）：3毫秒
    数组：深读（x500000）：5毫秒 数组：深写（x100000）：2毫秒 总计经过49毫秒（读取）+ **17毫秒（写入）** + 17毫秒（合并）= 83毫秒。
    | **可变对象和数组** 对象：读取（x500000）：11毫秒 对象：写入（x100000）：4毫秒 对象：非常深的读取（x500000）：42毫秒 对象：非常深的写入（x100000）：12毫秒
    对象：合并（x100000）：17毫秒 数组：读取（x500000）：7毫秒 数组：写入（x100000）：3毫秒 数组：深读（x500000）：7毫秒 数组：深写（x100000）：3毫秒
    总计经过67毫秒（读取）+ **22毫秒（写入）** + 17毫秒（合并）= 106毫秒。 |'
- en: In the parentheses, you can see a number of performed operations. It is incredibly
    fast. No immutable solution can outperform this benchmark, as it uses just mutable
    JS objects and arrays.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中，您可以看到执行的操作次数。这是非常快的。没有不可变的解决方案可以超过这个基准，因为它只使用可变的JS对象和数组。
- en: 'Some things to spot are differences based on how deep we read. For instance,
    the object read (x500000) takes 11 ms, while the very deep object read (x500000)
    takes 42 ms, which is nearly 4x longer:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些要注意的事情是基于我们阅读的深度而产生的差异。例如，读取对象（x500000）需要11毫秒，而非常深的对象读取（x500000）需要42毫秒，几乎是4倍长：
- en: '| Nearly-new MacBook Pro 15'''' (2018) with no background tasks | MacBook Pro
    15'''' (2016) with a few background tasks running |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 几乎全新的MacBook Pro 15''''（2018）没有后台任务 | MacBook Pro 15''''（2016）有一些后台任务在运行|'
- en: '| **Immutable objects and arrays (Object.assign)**  Object: read (x500000):
    13 ms  Object: write (x100000): 85 ms  Object: very deep read (x500000): 30 ms 
    Object: very deep write (x100000): 220 ms  Object: merge (x100000): 91 ms  Array:
    read (x500000): 7 ms  Array: write (x100000): 402 ms  Array: deep read (x500000):
    9 ms  Array: deep write (x100000): 400 ms  Total elapsed  59 ms(read)+**1107 ms(write)**+91
    ms(merge)  = 1257 ms. | **Immutable objects and arrays (Object.assign)**  Object:
    read (x500000): 19 ms  Object: write (x100000): 107 ms  Object: very deep read
    (x500000): 33 ms  Object: very deep write (x100000): 255 ms  Object: merge (x100000):
    136 ms  Array: read (x500000): 11 ms  Array: write (x100000): 547 ms  Array: deep
    read (x500000): 14 ms  Array: deep write (x100000): 504 ms  Total elapsed  77
    ms(read)+**1413 ms(write)**+136 ms(merge)  = 1626 ms. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **不可变对象和数组（Object.assign）** 对象：读取（x500000）：13毫秒 对象：写入（x100000）：85毫秒 对象：非常深的读取（x500000）：30毫秒
    对象：非常深的写入（x100000）：220毫秒 对象：合并（x100000）：91毫秒 数组：读取（x500000）：7毫秒 数组：写入（x100000）：402毫秒
    数组：深读（x500000）：9毫秒 数组：深写（x100000）：400毫秒 总计经过 59毫秒（读取）+**1107毫秒（写入）**+91毫秒（合并）=
    1257毫秒。| **不可变对象和数组（Object.assign）** 对象：读取（x500000）：19毫秒 对象：写入（x100000）：107毫秒
    对象：非常深的读取（x500000）：33毫秒 对象：非常深的写入（x100000）：255毫秒 对象：合并（x100000）：136毫秒 数组：读取（x500000）：11毫秒
    数组：写入（x100000）：547毫秒 数组：深读（x500000）：14毫秒 数组：深写（x100000）：504毫秒 总计经过 77毫秒（读取）+**1413毫秒（写入）**+136毫秒（合并）=
    1626毫秒。|'
- en: '`Object.assign` creates a spike on write operations. Now we see the cost of
    copying things that are not needed. The object write operation on a very deep
    level is close to 25 times more costly. An array deep write is 100 to 200 times
    slower than the mutable way:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`在写操作上创建了一个峰值。现在我们看到了复制不需要的东西的成本。非常深层级的对象写操作接近于比较昂贵。数组深写比可变方式慢100到200倍：'
- en: '| Nearly-new MacBook Pro 15'''' (2018) with no background tasks | MacBook Pro
    15'''' (2016) with a few background tasks running |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 几乎全新的MacBook Pro 15''''（2018）没有后台任务 | MacBook Pro 15''''（2016）有一些后台任务在运行|'
- en: '| **Immutable.js objects and arrays**  Object: read (x500000): 12 ms  Object:
    write (x100000): 19 ms  Object: very deep read (x500000): 111 ms  Object: very
    deep write (x100000): 80 ms  Object: merge (x100000): 716 ms  Array: read (x500000):
    18 ms  Array: write (x100000): 135 ms  Array: deep read (x500000): 51 ms  Array:
    deep write (x100000): 97 ms  Total elapsed  192 ms(read)+**331 ms(write)**+716  
    ms(merge)  = 1239 ms. | **Immutable.js objects and arrays**  Object: read (x500000):
    24 ms  Object: write (x100000): 52 ms  Object: very deep read (x500000): 178 ms 
    Object: very deep write (x100000): 125 ms  Object: merge (x100000): 1207 ms  Array:
    read (x500000): 24 ms  Array: write (x100000): 255 ms  Array: deep read (x500000):
    128 ms  Array: deep write (x100000): 137 ms  Total elapsed  354 ms(read)+**569
    ms(write)**+1207  ms(merge)  = 2130 ms. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **Immutable.js对象和数组** 对象：读取（x500000）：12毫秒 对象：写入（x100000）：19毫秒 对象：非常深的读取（x500000）：111毫秒
    对象：非常深的写入（x100000）：80毫秒 对象：合并（x100000）：716毫秒 数组：读取（x500000）：18毫秒 数组：写入（x100000）：135毫秒
    数组：深读（x500000）：51毫秒 数组：深写（x100000）：97毫秒 总计经过 192毫秒（读取）+**331毫秒（写入）**+716毫秒（合并）=
    1239毫秒。| **Immutable.js对象和数组** 对象：读取（x500000）：24毫秒 对象：写入（x100000）：52毫秒 对象：非常深的读取（x500000）：178毫秒
    对象：非常深的写入（x100000）：125毫秒 对象：合并（x100000）：1207毫秒 数组：读取（x500000）：24毫秒 数组：写入（x100000）：255毫秒
    数组：深读（x500000）：128毫秒 数组：深写（x100000）：137毫秒 总计经过 354毫秒（读取）+**569毫秒（写入）**+1207毫秒（合并）=
    2130毫秒。|'
- en: The object write is 6 times slower than the mutable way. A very deep object
    write is nearly 9 times slower than the mutable way, and 2.75 times faster than
    with `Object.assign()`. The merge operation, which constructs the object that
    is a result of merging the two objects passed as arguments, is much slower (42
    times slower than a mutable one or even 70 times slower if the user is using other
    programs).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对象写入的速度比可变方式慢6倍。非常深的对象写入几乎比可变方式慢9倍，并且比`Object.assign()`快2.75倍。合并操作，构造作为参数传递的两个对象合并结果的对象，要慢得多（比可变对象慢42倍，甚至如果用户正在使用其他程序，可能慢70倍）。
- en: Please pay attention to the hardware used. It is either a 2016 MacBook Pro or
    2018 MacBook Pro, which are both blazing-fast machines. Taking this to the mobile
    world will spike those benchmarks even more. The purpose of this section is to
    give you a general idea of how the numbers compare. Before you jump to a conclusion,
    please run your own tests on a specific hardware relevant to your project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意所使用的硬件。要么是2016年的MacBook Pro，要么是2018年的MacBook Pro，两者都是速度非常快的机器。将这一点带到移动世界将会使这些基准值更高。本节的目的是让您对数字进行比较有一个大致的了解。在得出结论之前，请在与您的项目相关的特定硬件上运行您自己的测试。
- en: Pure functions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: In this section, we come back to the pure functions that we have already learned,
    but now from a different perspective. Do you remember that Redux tries to be as
    explicit as possible? There is a reason for that. Everything that is implicit
    is usually the root cause of troubles. Do you remember functions from math classes?
    Those are 100% explicit. There is nothing else happening other than transforming
    the input into some output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从不同的角度回顾我们已经学过的纯函数。您还记得Redux试图尽可能明确吗？这是有原因的。一切隐式的东西通常是麻烦的根源。您还记得数学课上的函数吗？那些是100%明确的。除了将输入转换为某种输出之外，没有其他事情发生。
- en: In JavaScript, however, function can have implicit output. It may change a value,
    change an external system, and many many other things may happen outside of the
    function scope. You have already learned that in [Chapter 5,](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml) *Store
    Patterns*. All such implicit output is usually referred to as side effects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在JavaScript中，函数可能具有隐式输出。它可能会更改一个值，更改外部系统，以及许多其他事情可能发生在函数范围之外。您已经在[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)
    *存储模式*中学到了这一点。所有这些隐式输出通常被称为副作用。
- en: We need to address all of the different flavours of side effects. One of our
    weapons is immutability, which shields us from implicit external object changes.
    This is what immutability is for—it guarantees no such thing ever happens.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决所有不同类型的副作用。不可变性是我们的一种武器，它可以保护我们免受外部对象隐式更改的影响。这就是不可变性的作用——它保证绝对不会发生这种情况。
- en: In JavaScript, we cannot eliminate all side effects by introducing weapons such
    as immutability. Some require the tools on the language level, which are not available.
    In functional programming languages such as Haskell, even input/output is controlled
    by a separate structure called `IO()`. In JavaScript, however, we need to deal
    with it on our own. This means we cannot avoid some functions being impure—as
    those need to take care of API calls.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们无法通过引入不可变性等武器来消除所有副作用。有些需要语言级别上的工具，而这些工具在JavaScript中是不可用的。在Haskell等函数式编程语言中，甚至输入/输出都由称为`IO()`的单独结构控制。然而，在JavaScript中，我们需要自己处理这些问题。这意味着我们无法避免一些函数是不纯的——因为这些函数需要处理API调用。
- en: Another example is randomness. Any function using `Math.random` cannot be considered
    pure, as some part of such functions rely on the random number generator, which
    defeats the purpose of pure functions. Once the function is invoked with certain
    arguments, you are not guaranteed to receive the same output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是随机性。任何使用`Math.random`的函数都不能被认为是纯的，因为这些函数的一部分依赖于随机数生成器，这违背了纯函数的目的。一旦使用特定参数调用函数，就不能保证收到相同的输出。
- en: Similarly, everything that relies on time is impure. If your function execution
    relies on the month, day, second, or even year, it cannot be considered a pure
    function. At some point, the same argument will not give the same output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一切依赖于时间的东西都是不纯的。如果你的函数执行依赖于月份、日期、秒甚至年份，它就不能被认为是一个纯函数。在某个时刻，相同的参数将不会产生相同的输出。
- en: 'In the end, it all comes down to the execution chain. If you want to say a
    subset of operations were pure, then you need to know that each one of them was
    pure. An minimalist example is a function that consumes another function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一切都归结为执行链。如果你想说一部分操作是纯净的，那么你需要知道它们每一个都是纯净的。一个最简单的例子是一个消耗另一个函数的函数：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we do not know what `someFunc` will be. If `someFunc` is impure,
    the `example` function will also be impure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不知道`someFunc`会是什么。如果`someFunc`是不纯的，那么`example`函数也将是不纯的。
- en: Pure functions in Redux
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux中的纯函数
- en: The good news is we can push side-effects to one place of our application and
    call them in a loop when we really need them. This is what Flux does. Redux embraces
    it even further, allowing only pure functions as reducers. This is understandable.
    Reducers are called when the impure part is already done. From there on, we can
    maintain immutability, at least in terms of the Redux stores.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们可以将副作用推到我们应用程序的一个地方，并在真正需要时循环调用它们。这就是Flux所做的。Redux甚至进一步采纯函数作为reducers。这是可以理解的。当不纯的部分已经完成时，reducers被调用。从那时起，我们可以保持不可变性，至少在Redux存储方面。
- en: Some may question whether this is a good choice in terms of performance. Trust
    me, it is. We have a really low number of events happening (that need to be reduced,
    and hence affect the store) in comparison with state accesses and selectors operating
    on the computed state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会质疑这在性能方面是否是一个好选择。相信我，它是的。与状态访问和操作计算状态的选择器相比，我们发生的事件数量非常少（需要被减少，因此影响存储）。
- en: In return for keeping the state immutable, we get a huge benefit. We can tell
    the order of the function application that led to this particular state. We can
    track it if we really need to. This is huge. We can apply those functions again
    in a test environment and we will be guaranteed that the output is exactly the
    same. This is thanks to the functions being pure—hence, no side-effects are generated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持状态不可变，我们得到了巨大的好处。我们可以知道导致特定状态的函数应用顺序。如果我们真的需要，我们可以追踪它。这是巨大的。我们可以在测试环境中再次应用这些函数，并且我们可以保证输出完全相同。这要归功于函数的纯净性
    - 因此不会产生副作用。
- en: Caching pure functions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存纯函数
- en: Caching is a technique of remembering computations. If you are guaranteed that
    for certain arguments your function will always return the same value, you can
    safely compute it once and always return that computed value for these specific
    arguments.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种记住计算的技术。如果你可以保证对于某些参数，你的函数总是返回相同的值，你可以安全地计算一次，并且始终返回这些特定参数的计算值。
- en: 'Let''s look at the trivial implementation that is usually brought up for teaching
    purposes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通常用于教学目的的微不足道的实现：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a powerful technique and is used in the reselect library.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的技术，被用于reselect库。
- en: Referential transparency
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明度
- en: Pure functions are **referentially transparent**, meaning that their function
    invocation can be replaced with its corresponding outcome for a given argument.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是**引用透明**的，这意味着它们的函数调用可以用给定参数的相应结果替换。
- en: 'Now, look at the examples of referentially-transparent and referentially-opaque
    functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下引用透明和引用不透明函数的例子：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s imagine a mathematical expression:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个数学表达式：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Be aware that you need to avoid such simplifications if your function is not
    referentially transparent. Expressions such as the preceding or `x() + x() * 0`
    are tempting gotchas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您的函数不是引用透明的，您需要避免这样的简化。类似前面的表达式或`x() + x() * 0`都是诱人的陷阱。
- en: Whether you make any use of it or not is up to you. Also, see the *Further reading*
    section at the end of the chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否使用它取决于你自己。另请参阅本章末尾的*进一步阅读*部分。
- en: Everything but monads
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除了单子以外的一切
- en: The term monad has been infamous for many years. Not because it's an amazingly
    useful construct, but because of the complexity it introduces. There is also a
    common belief that once you understand monads, you lose the capability to explain
    them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，术语单子一直臭名昭著。不是因为它是一个非常有用的构造，而是因为它引入的复杂性。人们普遍认为，一旦你理解了单子，你就失去了解释它们的能力。
- en: '"In order to understand monads, you need to first learn Haskell and Category
    Theory.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “为了理解单子，你需要先学习Haskell和范畴论。”
- en: 'I think this is like saying: In order to understand burritos, you must first
    learn Spanish."'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这就像说：为了理解墨西哥卷饼，你必须先学习西班牙语。
- en: '- Douglas Crockford: Monads and Gonads (YUIConf Evening Keynote)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '- Douglas Crockford：单子和性腺体（YUIConf晚间主题演讲）'
- en: '[https://www.youtube.com/watch?v=dkZFtimgAcM](https://www.youtube.com/watch?v=dkZFtimgAcM).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=dkZFtimgAcM](https://www.youtube.com/watch?v=dkZFtimgAcM)。'
- en: A monad is a way of composing functions despite special circumstances, such
    as nullable values, side-effects, computations, or just conditional execution.
    Such a definition of a monad makes it a context holder. That's why the monad of
    X is not equivalent to X. This X Before being treated as `monad<X>`, this X something needs
    to be lifted first, which simply means creation of the required context. If we
    do not need monad<X> anymore, we can flatten the structure to just X, which is
    the equivalent of losing a context.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一种组合函数的方式，尽管存在特殊情况，比如可空值、副作用、计算，或者条件执行。这样对单子的定义使它成为一个上下文持有者。这就是为什么X的单子不等同于X。在被视为`monad<X>`之前，这个X需要首先被提升，这意味着创建所需的上下文。如果我们不再需要`monad<X>`，我们可以将结构展平为X，这相当于失去了一个上下文。
- en: It's like unwrapping a present for Christmas. You are pretty sure there is a
    present in there, but it depends on whether you were nice throughout the year.
    In some rare cases of misbehavior, you may end up with the stick or lump of coal
    in there. This is how the `Maybe<X>`  monad works. It may be X or nothing. It
    works great with nullable API values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像打开圣诞礼物一样。你很确定里面有礼物，但这取决于你整年表现如何。在一些罕见的不良行为情况下，你可能最终得到的是一根棍子或一块煤。这就是`Maybe<X>`单子的工作原理。它可能是X，也可能是空。它与可空API值一起使用效果很好。
- en: Call me Maybe
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 也许给我打电话
- en: 'There is one place in our code that begs for simplification. Take a look at
    the `taskSelector`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中有一个地方需要简化。看一下`taskSelector`：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We constantly fear whether we received something or null. This is a perfect
    case to delegate such work to the `Maybe` monad. Once we implement `Maybe`, the
    following code will be fully functional:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断担心我们是否收到了某物还是空值。这是一个完美的情况，可以将这样的工作委托给`Maybe`单子。一旦我们实现了`Maybe`，以下代码将是完全功能的：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Okay, so far you know a little about the `Maybe` monad we need to implement:
    it needs to be nothing when `null`/`undefined` or `Something` when `null` nor
    `undefined`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了我们需要实现的`Maybe` monad的一些知识：当`null`/`undefined`时，它需要是nothing，当`null`或`undefined`时，它需要是`Something`：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, very easy. The problem is, we did not implement neither `Nothing` nor
    `Something`. Don't worry, it is dead simple, just like in my comment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，非常简单。问题是，我们既没有实现`Nothing`也没有实现`Something`。别担心，这很简单，就像我的评论一样。
- en: 'We need both of them to react to three functions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要它们都对三个函数做出反应：
- en: '`isNothing`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNothing`'
- en: '`val`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`'
- en: '`map`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`'
- en: 'The first two functions are trivial:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数很简单：
- en: '`isNothing`: `Nothing` returns `true`, `Something` returns `false`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNothing`：`Nothing`返回`true`，`Something`返回`false`'
- en: '`val`: `Nothing` returns `null`, `Something` returns its value'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`：`Nothing`返回`null`，`Something`返回它的值'
- en: 'The last one is `map`, which for `Nothing` should do nothing (return itself)
    and for `Something` it should apply the function to the value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是`map`，对于`Nothing`应该什么都不做（返回自身），对于`Something`应该将函数应用于值：
- en: '![](Images/f293a752-b6fb-44b1-ad84-e1f05ca9d370.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f293a752-b6fb-44b1-ad84-e1f05ca9d370.png)'
- en: Applying toUpperCase on an ordinary string type and on the Maybe<string> monad
    using the map function
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通字符串类型和`Maybe<string>` monad上使用map函数对toUpperCase进行应用
- en: 'Let''s implement this logic:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个逻辑：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here we go, it took us less than 20 lines. Our selectors are now using the
    `Maybe` monad. The last thing we need to do is fix the end usages; it should ask
    for the value after the selector call, as in the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了，不到20行。我们的选择器现在使用`Maybe` monad。我们需要做的最后一件事是修复最终的用法；在选择器调用之后，它应该要求值，就像下面的例子中那样：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `Maybe` implementation is a cool pattern to avoid the null-checking burden,
    but is it really a monad?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Maybe`实现是一个很酷的模式，可以避免空检查的负担，但它真的是一个monad吗？
- en: Monad interface requirements
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monad接口要求
- en: 'More formally, the monad interface should define two basic operators:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，monad接口应该定义两个基本运算符：
- en: Return (`a -> M a`), an operation that takes the `a` type and wraps it into
    a monad (`M a`)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Return（`a -> M a`），一个接受`a`类型并将其包装成monad（`M a`）的操作
- en: 'Bind (`M a -> (a -> M b) -> M b`), an operation that takes two arguments: a
    monad of the a type, and a function that operates on `a` and returns the `M b`
    (`a -> M b`) monad'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bind（`M a ->（a -> M b）-> M b`），一个接受两个参数的操作：a类型的monad和一个在`a`上操作并返回`M b`（`a ->
    M b`）monad的函数
- en: In these terms, our constructor function is the `return` function. However,
    our map function is not compliant with the `bind` requirements. It takes a function
    that turns `a` into `b` (`a -> b`), then our `map` function automatically wraps
    `b` into `M b`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些条件下，我们的构造函数是`return`函数。然而，我们的map函数不符合`bind`的要求。它接受一个将`a`转换为`b`（`a -> b`）的函数，然后我们的`map`函数自动将`b`包装成`M
    b`。
- en: 'Beside this, our monad needs to obey three monad laws:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们的monad需要遵守三个monad定律：
- en: 'Left identity:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左单位元：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Right identity:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右单位元：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Associativity:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合律：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Mathematical proof is outside the scope of this book. However, we can play
    with the laws and see whether they hold for some random examples:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数学证明超出了本书的范围。然而，我们可以用这些定律来验证一些随机的例子：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Higher-order functions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: We have learned about higher-order components, and in this section, we will
    have a look at the more general concept, called higher-order functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了高阶组件，本节我们将看一下更一般的概念，称为高阶函数。
- en: 'Have a look at the example. It''s pretty straightforward. You wouldn''t even
    notice you created anything special:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子。非常简单。你甚至不会注意到你创建了什么特别的东西：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So what is a higher-order function?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是高阶函数呢？
- en: 'A higher-order function is a function that does one of the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个做以下操作之一的函数：
- en: Takes one or more functions as an argument
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个或多个函数作为参数
- en: Returns a function
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数
- en: That's it; it's so simple.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，很简单。
- en: Examples of higher-order functions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数的例子
- en: 'There are a number of functions that are higher-order functions and you use
    them on a daily basis:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多高阶函数，你每天都在使用它们：
- en: '`Array.prototype.map`:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.map`：'
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Array.prototype.filter`:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.filter`：'
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Array.prototype.reduce`:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.reduce`：'
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And, of course, functions such as `compose`, `call`, or `curry`, which we have
    learned about already.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有`compose`，`call`或`curry`等函数，我们已经学习过了。
- en: In general, any function that takes a callback is a higher-order function. You
    use such functions everywhere.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何接受回调的函数都是高阶函数。你在各个地方都使用这样的函数。
- en: 'Do you remember how nicely those compose? See the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得它们是如何很好地组合的吗？请看下面：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But some of them don't, such as callbacks. Have you heard of callback hell?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但有些不行，比如回调。你听说过回调地狱吗？
- en: A callback in a callback in a callback, this is a callback hell. That's why
    Promises were invented.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回调中的回调中的回调，这就是回调地狱。这就是为什么Promise被发明的原因。
- en: 'And then, all of a sudden, `Promise` hell started, so wise people created a
    syntactic sugar for promises: `async` and `await`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，突然之间，“Promise”地狱开始了，所以聪明的人为promise创建了一种语法糖：`async`和`await`。
- en: Functional languages aside
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除了函数式语言
- en: To begin, please read this interesting opinion from David.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请阅读大卫的这个有趣观点。
- en: '"Wait, wait, wait. What does the performance of persistent data structures
    have to do with the future of JavaScript MVCs?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “等等，等等。持久数据结构的性能与JavaScript MVC的未来有什么关系？
- en: A whole lot.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 很多。
- en: We'll see how, perhaps unintuitively, immutable data allows a new library, Om,
    to outperform a reasonably performant JavaScript MVC like Backbone.js without
    hand optimization from the user. Om itself is built upon the absolutely wonderful React library
    from Facebook."
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，也许不直观的是，不可变数据允许一个新的库Om，即使没有用户的手动优化，也能胜过像Backbone.js这样性能合理的JavaScript MVC。Om本身是建立在Facebook绝妙的React库之上的。
- en: - The Future of JavaScript MVC Frameworks
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '- JavaScript MVC框架的未来'
- en: David Nolen (swannodette), 17 December 2013
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·诺伦（swannodette），2013年12月17日
- en: '[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs)。'
- en: At the time of writing (September 2018), Backbone is already out of business.
    Even the popularity of Angular struggles to compete with React. React took the
    market insanely fast and once it finally changed it's license to MIT, it even
    accelerated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时（2018年9月），Backbone已经停止运营。即使Angular的流行程度也难以与React竞争。React迅速占领了市场，一旦它最终将许可证更改为MIT，甚至加速了这一过程。
- en: The fun fact is that **requestAnimationFrame** (**rAF**) is not such a big deal
    as once believed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是**requestAnimationFrame**（**rAF**）并不像人们曾经认为的那样重要。
- en: '"We do batching between different setState()s within one event handler (everything
    is flushed when you exit it). For many cases this works well enough and doesn’t
    have pitfalls of using rAF for every update.  We are also looking at asynchronous
    rendering by default. But rAF doesn’t really help much if the rendered tree is
    large. Instead we want to split non-critical updates in chunks using rIC until
    they’re ready to be flushed.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “我们在一个事件处理程序中在不同的setState()之间进行批处理（当您退出时，所有内容都会被刷新）。对于许多情况来说，这足够好用，并且没有使用rAF更新的潜在问题。我们还在默认情况下查看异步渲染。但是，如果渲染树很大，rAF并不会帮助太多。相反，我们希望使用rIC将非关键更新分成块，直到它们准备好被刷新。
- en: (...) We use a concept of "expiration". Updates coming from interactive events
    get very short expiration time (must flush soon), network events get more time
    (can wait). Based on that we decide what to flush and what to time-slice."
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (...) 我们使用了“过期”概念。来自交互事件的更新具有非常短的过期时间（必须很快刷新），网络事件具有更长的时间（可以等待）。基于此，我们决定刷新和时间切片的内容。
- en: '- Dan Abramov tweets'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '- Dan Abramov的推文'
- en: '[https://twitter.com/jaffathecake/status/952861127528124417](https://twitter.com/jaffathecake/status/952861127528124417).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://twitter.com/jaffathecake/status/952861127528124417](https://twitter.com/jaffathecake/status/952861127528124417).'
- en: 'The lesson I want you to learn from these two quotations is: don''t take things
    for granted, do not glorify one approach over another, and learn in which circumstances
    one is better than the other. Functional programming is similar; it would be foolish
    to just abandon this chapter as I once thought. I had this feeling: is it relevant
    to React Native programmers? Yes, it is. If it is popular enough to flood many
    public PRs in the community, you are certainly going to be exposed to these concepts
    and I want you to be prepared.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你从这两个引语中学到的教训是：不要想当然，不要过分美化一种方法，要学会在哪些情况下一种方法比另一种更好。函数式编程也是如此；像我曾经想的那样，简单地放弃这一章是愚蠢的。我有这种感觉：这对React
    Native程序员有用吗？是的，它有用。如果它足够流行，以至于在社区中涌现出许多公共PR，那么你肯定会接触到这些概念，我希望你做好准备。
- en: Terminology
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Don't be scared by Functors, EndoFunctors, CoMonads, and CoRoutines—take what
    is useful from the theoretical abstractions. Let theoretical experts take care
    of them. Math geeks have always been ahead and usually this is a good thing, but
    don't get too crazy. Business is business. Deadlines cannot wait for you to prove
    the greatest law in category theory.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被函子、EndoFunctors、CoMonads和CoRoutines吓到——从理论抽象中获取有用的东西。让理论专家来处理它们。数学极客们一直走在前面，通常这是一件好事，但不要太疯狂。业务就是业务。截止日期不能等待你证明范畴论中最伟大的定律。
- en: Focus on understanding the immediate benefits, such as the ones outlined in
    this book. If you ever find yourself in a team that is opposed to functional programming
    patterns, do not enforce them. After all, it is not as important in JavaScript
    as it is in Haskell.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于理解即时的好处，比如本书中概述的好处。如果你发现自己在一个反对函数式编程模式的团队中，不要强制执行它们。毕竟，在JavaScript中它并不像在Haskell中那样重要。
- en: '"Using fancy words instead of simple, common ones makes things harder to understand.
    Your writing will be clearer if you stick with a small vocabulary."'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: “使用花哨的词而不是简单、常见的词会使事情更难理解。如果你坚持使用一个小的词汇表，你的写作会更清晰。”
- en: '- Sophie Alpert tweet (Engineering manager of React at Facebook)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '- Sophie Alpert的推文（Facebook的React工程经理）'
- en: '[https://twitter.com/sophiebits/status/1033450495069761536](https://twitter.com/sophiebits/status/1033450495069761536).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://twitter.com/sophiebits/status/1033450495069761536](https://twitter.com/sophiebits/status/1033450495069761536).'
- en: Building abstractions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建抽象
- en: At the beginning of this chapter, we benchmarked immutable libraries and compared
    their performance. As with everything, I highly encourage you to spend some time
    before you commit to any library, pattern, or way of doing things.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们对不可变库进行了基准测试，并比较了它们的性能。和任何事情一样，我强烈建议你在承诺任何库、模式或做事情的方式之前花一些时间。
- en: Most libraries that adopt functional programming patterns do so for a real benefit.
    If you are unsure, leave it to someone else, and stick to your well-known imperative
    patterns. It turns out that simple code often gets better optimizations on the
    engine level.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数采用函数式编程模式的库都是为了真正的好处。如果你不确定，就把它留给别人，坚持你熟悉的命令式模式。事实证明，简单的代码通常在引擎层面上得到更好的优化。
- en: React is not obsessed with pure functions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React并不迷恋纯函数
- en: When you dive into the React ecosystem for the first time, you may get a bit
    of a surprise. There are a lot of examples that use pure functions and talk about
    time travelling, using Redux, and about one store to rule them all.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次接触React生态系统时，你可能会有些惊讶。有很多例子使用纯函数，并谈论时间旅行，使用Redux，以及一个存储来统治它们所有。
- en: 'The truth is, neither React nor Redux use only pure functions. In fact, there
    are a lot of functions in both libraries that perform mutations in the outer scope:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，React和Redux都不仅仅使用纯函数。实际上，这两个库中有很多函数在外部范围中执行变异：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These variables are being modified by other functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量正在被其他函数修改。
- en: 'Now, look at the React way of remembering what the library warned about:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看React如何记住库所警告的内容：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This little mutation depends on the environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的变异取决于环境。
- en: If you maintain a library with such checks, current build tools, such as webpack,
    can remove this dead code when building a production-minified file. By dead code,
    I mean code paths (like the preceding `if` statement) that will never be accessed
    because of the environment (production).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你维护一个带有这些检查的库，当前的构建工具，比如webpack，在构建生产压缩文件时可以删除这些死代码。所谓的死代码，我指的是因为环境（生产）而永远不会被访问的代码路径（如前面的`if`语句）。
- en: 'When it comes to Facebook in general, they are not ashamed to show that their
    code base is tricky in some places:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Facebook并不羞于展示他们的代码库在某些地方是棘手的：
- en: '![](Images/0b931c82-9955-4d74-b5ac-cf24732225a9.png)Facebook codebase screenshot,
    posted by Dan Abramov on Twitter'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/0b931c82-9955-4d74-b5ac-cf24732225a9.png)Facebook代码库截图，由Dan Abramov在Twitter上发布'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a deep dive into one of the most esoteric branches
    of JavaScript programming. We learned about monads, how to use them for the greater
    good, and how not to care about the laws of math if we really don't need to. Then,
    we got comfortable using vocabulary such as pure functions, mutable/immutable
    objects, and referential transparency.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入研究了JavaScript编程中最神秘的分支之一。我们学习了单子，如何为了更大的利益使用它们，以及如果我们真的不需要的话，如何不关心数学定律。然后，我们开始使用词汇，比如纯函数，可变/不可变对象和引用透明度。
- en: We know that there is a caching pattern for pure functions if we need it. This
    great approach can be useful in many Flux apps. You now can work effectively with
    selectors and make them dead simple using the Maybe monad, which takes away the
    null-checking burden.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如果需要的话，纯函数有一个缓存模式。这种很好的方法在许多Flux应用中都很有用。现在你可以有效地使用选择器，并使用Maybe monad使它们变得非常简单，这消除了空值检查的负担。
- en: With all of this expertise, it is now time to learn the challenges of maintaining
    dependencies and large code bases. In the next chapter, you will face a major
    challenge of every big code base, and believe me, every major company struggles
    with this at some point—no matter how many programming patterns they use or how
    many libraries they depend on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些专业知识，现在是时候学习维护依赖和大型代码库的挑战了。在下一章中，你将面临每个大型代码库的主要挑战，相信我，每个大公司在某个时候都会遇到这个问题——无论他们使用了多少编程模式或依赖了多少库。
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A mostly adequate guide to functional programming—a free book on functional
    programming in JavaScript:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于JavaScript函数式编程的大部分合格指南——一本免费的关于JavaScript函数式编程的书：
- en: '[https://github.com/MostlyAdequate/mostly-adequate-guide](https://github.com/MostlyAdequate/mostly-adequate-guide).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/MostlyAdequate/mostly-adequate-guide](https://github.com/MostlyAdequate/mostly-adequate-guide)。'
- en: 'Examples of cache functions that you may want to use with the Reselect library:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想要与Reselect库一起使用的缓存函数的例子：
- en: '[https://github.com/reduxjs/reselect#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one](https://github.com/reduxjs/reselect#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/reduxjs/reselect#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one](https://github.com/reduxjs/reselect#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one)。'
- en: 'Information on referential transparency:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于引用透明性的信息：
- en: '[https://softwareengineering.stackexchange.com/questions/254304/what-is-referential-transparency](https://softwareengineering.stackexchange.com/questions/254304/what-is-referential-transparency).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://softwareengineering.stackexchange.com/questions/254304/what-is-referential-transparency](https://softwareengineering.stackexchange.com/questions/254304/what-is-referential-transparency)。'
- en: 'Eric''s Elliott mastering JavaScript interview series episode, Pure Functions:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eric's Elliott掌握JavaScript面试系列的一集，Pure Functions：
- en: '[https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976)。'
- en: 'A historical post that predicted the future, *The future of JavaScript MVCs*:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个预测未来的历史帖子，《JavaScript MVCs的未来》：
- en: '[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs)。'
- en: 'This is old but still worth a read, *A General Theory of Reactivity*:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是旧的，但仍然值得一读，《反应性的一般理论》：
- en: '[https://github.com/kriskowal/gtor](https://github.com/kriskowal/gtor).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kriskowal/gtor](https://github.com/kriskowal/gtor)。'
- en: 'The following book on FP in JavaScript, *JavaScript Allonge* (free to read
    online):'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于JavaScript中的函数式编程的以下书籍，《JavaScript Allonge》（可免费在线阅读）：
- en: '[https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong](https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong](https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong)。'
- en: 'Monad laws (Haskell Wiki):'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monad laws（Haskell Wiki）：
- en: '[https://wiki.haskell.org/Monad_laws](https://wiki.haskell.org/Monad_laws).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.haskell.org/Monad_laws](https://wiki.haskell.org/Monad_laws)。'
- en: 'Douglas Crockford, Monads and Gonads:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Douglas Crockford，Monad和Gonads：
- en: '[https://www.youtube.com/watch?v=dkZFtimgAcM](https://www.youtube.com/watch?v=dkZFtimgAcM).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=dkZFtimgAcM](https://www.youtube.com/watch?v=dkZFtimgAcM)。'
- en: 'How Immutable.js is using the Trie graph to optimize writing operations:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Immutable.js如何使用Trie图来优化写操作：
- en: '[https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2](https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2](https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2)。'
- en: '[https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)。'
- en: 'Should React use `requestAnimationFrame` by default:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React是否应默认使用`requestAnimationFrame`：
- en: '[https://github.com/facebook/react/issues/11171](https://github.com/facebook/react/issues/11171).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/facebook/react/issues/11171](https://github.com/facebook/react/issues/11171)。'
- en: 'An awesome functional programming collection on GitHub:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上一个很棒的函数式编程收藏：
- en: '[https://github.com/xgrommx/awesome-functional-programming/blob/master/README.md](https://github.com/xgrommx/awesome-functional-programming/blob/master/README.md).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/xgrommx/awesome-functional-programming/blob/master/README.md](https://github.com/xgrommx/awesome-functional-programming/blob/master/README.md)。'
- en: If you fell in love with functional programming, here is a very good resource,
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你迷恋函数式编程，这是一个非常好的资源，
- en: 'Learn You a Haskell for Great Good (requires Haskell understanding):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 《Learn You a Haskell for Great Good》（需要了解Haskell）：
- en: '[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters).'
