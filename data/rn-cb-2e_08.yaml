- en: Working with Application Logic and Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理应用逻辑和数据
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Storing and retrieving data locally
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储和检索数据
- en: Retrieving data from a remote API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程API检索数据
- en: Sending data to a remote API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向远程API发送数据
- en: Establishing real-time communication with WebSockets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与WebSockets建立实时通信
- en: Integrating persistent database functionality with Realm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将持久数据库功能与Realm集成
- en: Masking the application upon network connection loss
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络连接丢失时掩盖应用程序
- en: Synchronizing locally persisted data with a remote API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地持久化数据与远程API同步
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the most important aspects of developing any application is handling
    data. This data may come locally from the user, may be served by a remote server
    that exposes an API, or, as with most business applications, may be some combination
    of both. You may be wondering what strategies are best for dealing with data,
    or how to even accomplish simple tasks such as making an HTTP request. Luckily,
    React Native makes your life that much simpler by providing mechanisms for easily
    dealing with data from all different sources.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开发任何应用程序最重要的一个方面是处理数据。这些数据可能来自用户本地，可能由公开API的远程服务器提供，或者，与大多数业务应用程序一样，可能是两者的组合。您可能想知道处理数据的最佳策略是什么，或者如何甚至完成简单的任务，比如发出HTTP请求。幸运的是，React
    Native通过提供易于处理来自各种不同来源的数据的机制，使您的生活变得更加简单。
- en: The open source community has taken things a step further and provided some
    excellent modules that can be used with React Native. In this chapter, we will
    discuss how to work with data in all aspects, and how it integrates into our React
    Native applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开源社区已经进一步提供了一些可以与React Native一起使用的优秀模块。在本章中，我们将讨论如何处理各个方面的数据，以及如何将其整合到我们的React
    Native应用程序中。
- en: Storing and retrieving data locally
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地存储和检索数据
- en: When developing a mobile app, we need to consider the network challenges that
    need to be overcome. A well-designed app should allow the user to continue using
    the app when there is no internet connection. This requires the app to save data
    locally on the device when there's no internet connection, and to also sync that
    data with the server when the network is available again.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发移动应用程序时，我们需要考虑需要克服的网络挑战。一个设计良好的应用程序应该允许用户在没有互联网连接时继续使用应用程序。这需要应用程序在没有互联网连接时在设备上本地保存数据，并在网络再次可用时将数据与服务器同步。
- en: Another challenge to overcome is network connectivity, which might be slow or
    limited. To improve the performance of our app, we should save critical data on
    the local device to avoid putting stress on our server API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要克服的挑战是网络连接，可能会很慢或有限。为了提高我们应用的性能，我们应该将关键数据保存在本地设备上，以避免对服务器API造成压力。
- en: In this recipe, we will learn about a basic and effective strategy for saving
    and retrieving data locally from the device. We will create a simple app with
    a text input and two buttons, one to save the content of the field and one to
    load the existing content. We will use the `AsyncStorage` class to achieve our
    goal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习一种从设备本地保存和检索数据的基本有效策略。我们将创建一个简单的应用程序，其中包含一个文本输入和两个按钮，一个用于保存字段内容，另一个用于加载现有内容。我们将使用`AsyncStorage`类来实现我们的目标。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create an empty app named `local-data-storage`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`local-data-storage`的空应用程序。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll begin with the `App` component. Let''s start by importing all of the
    dependencies:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`App`组件开始。让我们首先导入所有的依赖项：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s create the `App` class. We are going to create a `key` constant
    so that we can set the name of the key we will use to save the content. On the
    `state`, we''ll have two properties: one to keep the value from the text input
    component, and another to load and display the currently stored value:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`App`类。我们将创建一个`key`常量，以便我们可以设置要用于保存内容的键的名称。在`state`中，我们将有两个属性：一个用于保存来自文本输入组件的值，另一个用于加载和显示当前存储的值：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the component mounts, we want to load the existing stored value if it
    exists. We''ll display the content once the app loads, so we''ll need to read
    the local value in the `componentWillMount` life cycle method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件挂载时，如果存在，我们希望加载已存储的值。一旦应用程序加载，我们将显示内容，因此我们需要在`componentWillMount`生命周期方法中读取本地值：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `onLoad` function loads the current content from the local storage. Like
    `localStorage` in the browser, it''s as easy as using the key we defined when
    saving the data:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onLoad`函数从本地存储加载当前内容。就像浏览器中的`localStorage`一样，只需使用保存数据时定义的键即可：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Saving the data is straightforward as well. We''ll declare a key to save any
    data we want to associate with that key, via the `setItem` method of `AsyncStorage`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存数据也很简单。我们将声明一个键，通过`AsyncStorage`的`setItem`方法保存我们想要与该键关联的任何数据：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need a function for saving the value from the input text to the `state`.
    When the value of the input changes, we will get the new value and save it to
    the `state`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数，将输入文本中的值保存到`state`中。当输入的值发生变化时，我们将获取新的值并保存到`state`中：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our UI will be simple: just a `Text` element to render the saved content, a
    `TextInput` component to allow the user to enter a new value, and two buttons.
    One button will call the `onLoad` function to load the current saved value, and
    the other will save the value from the text input:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的UI将很简单：只有一个`Text`元素来呈现保存的内容，一个`TextInput`组件允许用户输入新值，以及两个按钮。一个按钮将调用`onLoad`函数来加载当前保存的值，另一个将保存文本输入的值：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let''s add some styles. This will be simple colors, paddings, margins,
    and a layout, as covered in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml),
    *Creating a Simple React Native App*:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些样式。这将是简单的颜色、填充、边距和布局，如[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中所述，*创建一个简单的React
    Native应用*：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/1e7aa953-2b8d-4c6c-be09-463c40c90198.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1e7aa953-2b8d-4c6c-be09-463c40c90198.png)'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `AsyncStorage` class allows us to easily save data on the local device.
    On iOS, this is accomplished by using dictionaries on text files. On Android,
    it will use RocksDB or SQLite, depending on what's available.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage`类允许我们轻松地在本地设备上保存数据。在iOS上，这是通过在文本文件上使用字典来实现的。在Android上，它将使用RocksDB或SQLite，具体取决于可用的内容。'
- en: It's not recommended to save sensitive information using this method, as the
    data is not encrypted.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用此方法保存敏感信息，因为数据未加密。
- en: In *step 4*, we loaded the current saved data. The `AsyncStorage` API contains
    a `getItem` method. This method receives the key we want to retrieve as a parameter.
    We are using the `await`/`async` syntax here since this call is asynchronous.
    After we get the value, we just set it to `state`; this way, we will be able to
    render the data on the view.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们加载了当前保存的数据。`AsyncStorage` API包含一个`getItem`方法。该方法接收我们要检索的键作为参数。我们在这里使用`await`/`async`语法，因为这个调用是异步的。获取值后，我们只需将其设置为`state`；这样，我们就能在视图上呈现数据。
- en: In *step 7*, we saved the text from the `state`. Using the `setItem` method,
    we can set a new `key` with any value we want. This call is asynchronous, therefore
    we used the `await`/`async` syntax.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们保存了`state`中的文本。使用`setItem`方法，我们可以设置一个新的`key`和任何我们想要的值。这个调用是异步的，因此我们使用了`await`/`async`语法。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A great article on how `async`/`await` in JavaScript works, available at [https://ponyfoo.com/articles/understanding-javascript-async-await](https://ponyfoo.com/articles/understanding-javascript-async-await).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript中`async`/`await`的工作原理的一篇很棒的文章，可在[https://ponyfoo.com/articles/understanding-javascript-async-await](https://ponyfoo.com/articles/understanding-javascript-async-await)上找到。
- en: Retrieving data from a remote API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从远程API检索数据
- en: In the previous chapters we used data from a JSON file or directly defined in
    the source code. While that worked for our previous recipes, it's rarely very
    helpful in real-world applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用了来自JSON文件或直接在源代码中定义的数据。虽然这对我们之前的示例很有用，但在现实世界的应用程序中很少有帮助。
- en: In this recipe, we will learn how to request data from an API. We will make
    a `GET` request from an API to get a JSON response. For now, however, we are only
    going to display the JSON in a text element. We'll be using the Fake Online REST
    API for Testing and Prototyping, hosted at [http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com) and
    powered by the excellent development test API software, JSON Server ([https://github.com/typicode/json-server](https://github.com/typicode/json-server)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何从API请求数据。我们将从API中进行`GET`请求，以获得JSON响应。然而，现在，我们只会在文本元素中显示JSON。我们将使用Fake
    Online REST API for Testing and Prototyping，托管在[http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com)，由优秀的开发测试API软件JSON
    Server（[https://github.com/typicode/json-server](https://github.com/typicode/json-server)）提供支持。
- en: We will keep this app simple so that we can focus on data management. We will
    have a text component that will display the response from the API and also add
    a button that requests the data when pressed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持这个应用程序简单，以便我们可以专注于数据管理。我们将有一个文本组件，用于显示来自API的响应，并添加一个按钮，按下时请求数据。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create an empty app. Let's name this one `remote-api`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个空的应用。让我们把这个命名为`remote-api`。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by importing our dependencies into the `App.js` file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`App.js`文件中导入我们的依赖项开始：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are going to define a `results` property on the `state`. This property will
    hold the response from the API. We''ll need to update the view once we get the
    response:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`state`上定义一个`results`属性。这个属性将保存来自API的响应。一旦我们得到响应，我们需要更新视图：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll send the request when the button is pressed. Next, let''s create a method
    to handle that request:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被按下时，我们将发送请求。接下来，让我们创建一个处理该请求的方法：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `render` method, we''ll display the response, which will be read from
    the `state`. We will use a `TextInput` to display the API data. Via properties,
    we''ll declare editing as disabled and support multiline functionality. The button
    will call the `onLoad` function that we created in the previous step:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们将显示来自`state`的响应。我们将使用`TextInput`来显示API数据。通过属性，我们将声明编辑为禁用，并支持多行功能。按钮将调用我们在上一步中创建的`onLoad`函数：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we''ll add some styles. Again, this will just be the layout, colors,
    margins, and padding:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一些样式。同样，这只是布局、颜色、边距和填充：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/9374a894-a2e5-4de5-89a2-84ab98ecfb23.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9374a894-a2e5-4de5-89a2-84ab98ecfb23.png)'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 4*, we sent the request to the API. We use the `fetch` method to make
    the request. The first parameter is a string with the URL of the endpoint, while
    the second parameter is a configuration object. For this request, the only option
    we need to define is the `request` method to `GET`, but we can also use this object
    to define headers, cookies, parameters, and many other things.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们向API发送了请求。我们使用`fetch`方法发出请求。第一个参数是一个包含端点URL的字符串，而第二个参数是一个配置对象。对于这个请求，我们需要定义的唯一选项是`request`方法为`GET`，但我们也可以使用这个对象来定义头部、cookie、参数和许多其他内容。
- en: We are also using `async`/`await` syntax to wait on the response and finally
    set it on the `state`. If you prefer, you could, of course, use promises for this
    purpose instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`async`/`await`语法来等待响应，并最终将其设置在`state`上。如果您愿意，当然也可以使用承诺来实现这个目的。
- en: Also, note how we are using an arrow function here to properly handle the scope.
    This will automatically set the correct scope when this method is assigned to
    the `onPress` callback.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们在这里使用箭头函数来正确处理作用域。当将此方法分配给`onPress`回调时，这将自动设置正确的作用域。
- en: Sending data to a remote API
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向远程API发送数据
- en: In the previous recipe, we covered how to get data from an API using `fetch`.
    In this recipe, we will learn how to `POST` data to the same API. This app will
    emulate creating a forum post, and the request for the post will have `title`,
    `body`, and `user` parameters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们介绍了如何使用`fetch`从API获取数据。在这个教程中，我们将学习如何向同一个API发送数据。这个应用程序将模拟创建一个论坛帖子，帖子的请求将具有`title`、`body`和`user`参数。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...准备好
- en: Before going through this recipe, we need to create a new empty app named `remote-api-post`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行本教程之前，我们需要创建一个名为`remote-api-post`的新空应用程序。
- en: 'In this recipe, we will also be using the very popular `axios` package for
    handling our API requests. You can install it via the Terminal with `yarn`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们还将使用非常流行的`axios`包来处理我们的API请求。您可以通过终端使用`yarn`安装它：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can use `npm`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用`npm`：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先，我们需要从`state`中获取值。我们还可以在这里运行一些验证，以确保`title`和`body`不为空。在`POST`请求中，我们需要定义请求的内容类型，这种情况下将是JSON。我们将`userId`属性硬编码为`1`。在真实的应用程序中，我们可能会从之前的API请求中获取这个值。请求完成后，我们获取JSON响应，如果成功，将触发我们之前定义的`onLoad`方法：
- en: 'First, we''ll need to open the `App.js` file and import the dependencies we''ll
    be using:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要打开`App.js`文件并导入我们将要使用的依赖项：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll define the `App` class with a `state` object that has three properties.
    The `title` and `body` properties will be used for making the request, and `results`
    will hold the API''s response:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义`App`类，其中包含一个具有三个属性的`state`对象。`title`和`body`属性将用于发出请求，`results`将保存API的响应：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After saving a new post, we will request all of the posts from the API. We
    are going to define an `onLoad` method to fetch the new data. This code works
    just the same as the `onLoad` method in the previous recipe, but this time, we''ll
    be using the `axios` package to create the request:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存新帖子后，我们将从API请求所有帖子。我们将定义一个`onLoad`方法来获取新数据。这段代码与上一个教程中的`onLoad`方法完全相同，但这次，我们将使用`axios`包来创建请求：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s work on saving the new data. First, we need to get the values from the
    `state`. We could also run some validations here to make sure that the `title`
    and `body` are not empty. On the `POST` request, we need to define the content
    type of the request, which, in this case, will be JSON. We will hard code the
    `userId` property to `1`. In a real app, we would have probably gotten this value
    from a previous API request. After the request has completed, we get the JSON
    response, which, if successful, will fire the `onLoad` method that we defined
    previously:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始保存新数据。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The save functionality is complete. Next, we need methods for saving the `title`
    and `body` to the `state`. These methods will be executed as the user types in
    the input text, keeping track of the values on the `state` object:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存功能已经完成。接下来，我们需要方法来保存`title`和`body`到`state`。这些方法将在用户在输入文本中输入时执行，跟踪`state`对象上的值：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have everything we need for the functionality, so let''s add the UI. The
    `render` method will display a toolbar, two input texts, and a Save button for
    calling the `onSave` method that we defined in *step 4*:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经拥有了功能所需的一切，所以让我们添加UI。`render`方法将显示一个工具栏、两个输入文本和一个保存按钮，用于调用我们在*步骤4*中定义的`onSave`方法：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, let''s add the styles to define the layout, color, padding, and margins:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加样式来定义布局、颜色、填充和边距：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/52d9a6cb-2df6-4112-be62-3f1e3431970b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52d9a6cb-2df6-4112-be62-3f1e3431970b.png)'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 2*, we defined three properties on the `state`. The `results` property
    will contain the response from the server API, which we later use to display the
    value in the UI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们在`state`上定义了三个属性。`results`属性将包含来自服务器API的响应，我们稍后将用它来在UI中显示值。
- en: We used the `title` and `body` properties to hold the values from the input
    text components so that the user can create a new post. Those values will then
    be sent to the API when pressing the Save button.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`title`和`body`属性来保存输入文本组件中的值，以便用户可以创建新的帖子。然后，这些值将在按下保存按钮时发送到API。
- en: In *step 6*, we declared the elements on the UI. We used two inputs for post
    data and the Save button, which calls the `onSave` method when pressed. Finally,
    we used input text to display the result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们在UI上声明了元素。我们使用了两个输入来输入数据和一个保存按钮，当按下时调用`onSave`方法。最后，我们使用输入文本来显示结果。
- en: Establishing real-time communication with WebSockets
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSockets建立实时通信
- en: In this recipe, we will integrate WebSockets in a React Native application.
    We are going to use the *Hello World* of WebSockets applications, that is, a simple
    chat app. This app will allow users to send and receive messages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将在React Native应用程序中集成WebSockets。我们将使用WebSockets应用程序的*Hello World*，也就是一个简单的聊天应用程序。这个应用程序将允许用户发送和接收消息。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To support WebSockets on React Native, we will need to run a server to handle
    all connected clients. The server should be able to broadcast a message when it
    receives a message from any of the connected clients.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在React Native上支持WebSockets，我们需要运行一个服务器来处理所有连接的客户端。服务器应该能够在收到任何连接的客户端的消息时广播消息。
- en: We'll start with a new, empty React Native app. We'll name it `web-sockets`. In
    the root of the project, let's add a `server` folder with an `index.js` file inside
    of it. If you don't already have it, you'll need Node to run the server. You can
    get Node.js from [https://nodejs.org/](https://nodejs.org/) or by using the Node
    Version Manager ([https://github.com/creationix/nvm](https://github.com/creationix/nvm)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的空白React Native应用程序开始。我们将其命名为`web-sockets`。在项目的根目录下，让我们添加一个带有`index.js`文件的`server`文件夹。如果您还没有它，您将需要Node来运行服务器。您可以从[https://nodejs.org/](https://nodejs.org/)获取Node.js，或者使用Node版本管理器([https://github.com/creationix/nvm](https://github.com/creationix/nvm))。
- en: 'We''ll be using the excellent WebSocket package, `ws`. You can add the package
    via the Terminal with `yarn`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用优秀的WebSocket包`ws`。您可以通过终端使用`yarn`添加该包：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, you can use `npm`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`npm`：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you''ve got the package installed, add the following code to the `/server/index.js`
    file. Once this server is running, it will listen for incoming connections via
    `server.on(''connection'')` and incoming messages via `socket.on(''message'')`.
    For more information on how `ws` works, you can check out the documentation at [https://github.com/websockets/ws](https://github.com/websockets/ws):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，将以下代码添加到`/server/index.js`文件中。一旦此服务器运行，它将通过`server.on('connection')`监听传入的连接，并通过`socket.on('message')`监听传入的消息。有关`ws`的更多信息，请查看[https://github.com/websockets/ws](https://github.com/websockets/ws)上的文档：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the server code is in place, you can start up the server using Node by
    running the following command in the Terminal at the root of the project:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器代码就位，您可以通过在项目根目录的终端中运行以下命令来启动服务器：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Leave the server running so that, once we've built the React Native app, we
    can use the server to communicate between clients.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让服务器保持运行，这样一旦我们构建了React Native应用程序，我们就可以使用服务器在客户端之间进行通信。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s create the `App.js` file and import all the dependencies we''ll
    be using:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建`App.js`文件并导入我们将使用的所有依赖项：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the `state` object, we''ll declare a `history` property. This property will
    be an array for holding all of the messages that have been sent back and forth
    between users:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`state`对象上，我们将声明一个`history`属性。该属性将是一个数组，用于保存用户之间来回发送的所有消息：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we need to integrate WebSockets into our app by connecting to the server
    and setting up the callback functions for receiving messages, errors, and when
    the connection is opened or closed. We will do this when the component has been
    created, by using the `componentWillMount` life cycle hook:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过连接到服务器并设置用于接收消息、错误以及连接打开或关闭时的回调函数来将WebSockets集成到我们的应用中。我们将在组件创建后执行此操作，使用`componentWillMount`生命周期钩子：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s define the callbacks for opened/closed connections and for handling
    received errors. We are just going to log the actions, but this is where we could
    show an alert message when the connection is closed, or display an error message
    when an error is thrown by the server:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义打开/关闭连接和处理接收到的错误的回调。我们只是要记录这些操作，但这是我们可以在连接关闭时显示警报消息，或者在服务器抛出错误时显示错误消息的地方：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When receiving a new message from the server, we need to add it to the `history` property
    on the `state` so that we can render the new content as soon as it arrives:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从服务器接收到新消息时，我们需要将其添加到`state`上的`history`属性中，以便在消息到达时能够立即呈现新内容：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, on to sending the message. We need to define a method that will get executed
    when the user presses the *Return* key on the keyboard. We need to do two things
    at this point: add the new message to `history`, and then send the message through
    the socket:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们发送消息。我们需要定义一个方法，当用户在键盘上按下*Return*键时将执行该方法。此时我们需要做两件事：将新消息添加到`history`中，然后通过socket发送消息：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the previous step, we got the `text` property from the `state`. We need
    to keep track of the value whenever the user types something into the input, so
    we''ll need a function for listening to keystrokes and saving the value to `state`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们从`state`中获取了`text`属性。每当用户在输入框中输入内容时，我们需要跟踪该值，因此我们需要一个用于监听按键并将值保存到`state`的函数：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have all of the functionality in place, so let''s work on the UI. In the
    `render` method, we''ll add a toolbar, a scroll view to render all of the messages
    in `history`, and a text input to allow the user to send a new message:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经就位了所有功能，现在让我们来处理UI。在`render`方法中，我们将添加一个工具栏，一个滚动视图来呈现`history`中的所有消息，以及一个文本输入框，允许用户发送新消息：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To render the messages from `history`, we''ll loop through the `history` array
    and render each message via the `renderMessage` method. We''ll need to check whether
    the current message belongs to the user on this device so that we can apply the
    appropriate styles:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了渲染来自`history`的消息，我们将遍历`history`数组，并通过`renderMessage`方法渲染每条消息。我们需要检查当前消息是否属于此设备上的用户，以便我们可以应用适当的样式：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, let''s work on the styles! Let''s add styles to the toolbar, the `history`
    component, and the text input. We need to set the `history` container as flexible,
    since we want it to take up all of the available vertical space:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们来处理样式！让我们为工具栏、`history`组件和文本输入添加样式。我们需要将`history`容器设置为灵活，因为我们希望它占用所有可用的垂直空间：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, on to the styles for each message. We are going to create a common styles
    object called `msg` for all messages, then styles for messages from the user on
    the device, and finally, styles for messages from others, changing the color and
    alignment accordingly:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来处理每条消息的样式。我们将为所有消息创建一个名为`msg`的公共样式对象，然后为来自设备上用户的消息创建样式，最后为来自其他人的消息创建样式，相应地更改颜色和对齐方式：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下屏幕截图：
- en: '![](assets/71f2d573-5ccf-46f4-828f-89463af001bb.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/71f2d573-5ccf-46f4-828f-89463af001bb.png)'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *step 2*, we declared the `state` object with a `history` array for keeping
    track of messages. The `history` property will hold objects representing all of
    the messages being exchanged between clients. Each object will have two properties:
    a string with the message text, and a Boolean flag to determine the sender. We
    could add more data here, such as the name of the user, a URL of the avatar image,
    or anything else we might need.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们声明了`state`对象，其中包含一个用于跟踪消息的`history`数组。`history`属性将保存表示客户端之间交换的所有消息的对象。每个对象都将有两个属性：包含消息文本的字符串，以及用于确定发送者的布尔标志。我们可以在这里添加更多数据，例如用户的名称、头像图像的URL，或者我们可能需要的其他任何内容。
- en: In *step 3*, we connected to the socket provided by the WebSocket server and
    set up callbacks for handling socket events. We specified the server address as
    well as the port.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们连接到WebSocket服务器提供的套接字，并设置了处理套接字事件的回调。我们指定了服务器地址以及端口。
- en: In *step 5*, we defined the callback to execute when a new message is received
    from the server. Here, we add a new object to the `history` array on the `state` every
    time a new message is received. Each message object has the properties `isSentByMe` and
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了当从服务器接收到新消息时要执行的回调。在这里，每次接收到新消息时，我们都会向`state`的`history`数组添加一个新对象。每个消息对象都有`isSentByMe`的属性
- en: '`messageText`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`messageText`。'
- en: In *step 6*, we sent the message to the server. We need to add the message to
    the history because the server will broadcast the message to all other clients,
    but not the author of the message. To keep track of this message, we need to manually
    add it to the history.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们将消息发送到服务器。我们需要将消息添加到历史记录中，因为服务器将向所有其他客户端广播消息，但不包括消息的作者。为了跟踪这条消息，我们需要手动将其添加到历史记录中。
- en: Integrating persistent database functionality with Realm
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将持久数据库功能与Realm集成
- en: As your application becomes more complex, you will likely reach a point where
    you need to store data on the device. This could be business data, such as user
    lists, to avoid having to make expensive network connections to a Remote API.
    Maybe you don't have an API at all and your application works as a self-sufficient
    entity. Regardless of the situation, you may benefit from leveraging a database
    to store your data. There are multiple options for React Native applications.
    The first option is `AsyncStorage`, which we covered in the *Storing and retrieving
    data locally* recipe in this chapter. You could also consider SQLite, or you could
    write an adapter to an OS-specific data provider, such as Core Data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序变得更加复杂，您可能会达到需要在设备上存储数据的地步。这可能是业务数据，比如用户列表，以避免不得不进行昂贵的网络连接到远程 API。也许您根本没有
    API，您的应用程序作为一个自给自足的实体运行。无论情况如何，您可能会受益于利用数据库来存储您的数据。对于 React Native 应用程序有多种选择。第一个选择是
    `AsyncStorage`，我们在本章的 *存储和检索本地数据* 教程中介绍过。您还可以考虑 SQLite，或者您可以编写一个适配器来连接到特定于操作系统的数据提供程序，比如
    Core Data。
- en: Another excellent option is using a mobile database, such as Realm. Realm is
    an extremely fast, thread-safe, transactional, object-based database. It is primarily
    designed for use by mobile devices, with a straightforward JavaScript API. It
    supports other features, such as encryption, complex querying, UI bindings, and
    more. You can read all about it at [https://realm.io/products/realm-mobile-database/](https://realm.io/products/realm-mobile-database/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个极好的选择是使用移动数据库，比如 Realm。Realm 是一个非常快速、线程安全、事务性、基于对象的数据库。它主要设计用于移动设备，具有直观的
    JavaScript API。它支持其他功能，如加密、复杂查询、UI 绑定等。您可以在 [https://realm.io/products/realm-mobile-database/](https://realm.io/products/realm-mobile-database/)
    上阅读有关它的所有信息。
- en: In this recipe, we will walk through using Realm in React Native. We will create
    a simple database and perform basic operations, such as inserting, updating, and
    deleting records. We will then display these records in the UI.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将介绍在 React Native 中使用 Realm。我们将创建一个简单的数据库，并执行基本操作，如插入、更新和删除记录。然后我们将在
    UI 中显示这些记录。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a new empty React Native app named `realm-db`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `realm-db` 的新的空白 React Native 应用程序。
- en: 'Installing Realm requires running the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Realm 需要运行以下命令：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Because of this, we will be working on an app that is ejected from Expo. This
    means that you could create this app with the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将致力于一个从 Expo 弹出的应用程序。这意味着您可以使用以下命令创建此应用程序：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you could create a new Expo app with the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令创建一个新的 Expo 应用程序：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, you can eject the app that was created with Expo via the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过以下命令弹出使用 Expo 创建的应用程序：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once you''ve created a React Native app, be sure to install the CocoaPods dependencies
    via the `ios` directory by using `cd` inside the new app and running the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 React Native 应用程序后，请务必通过 `cd` 在新应用程序中使用 `ios` 目录安装 CocoaPods 依赖项，并运行以下命令：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Refer to Chapter 10, *App Workflow and Third-party Plugins*, for a in-depth
    explanation of how CocoaPods works, and how ejected (or pure React Native) applications
    differ from Expo React Native applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 CocoaPods 工作原理的详细解释以及弹出（或纯粹的 React Native）应用程序与 Expo React Native 应用程序的区别，请参阅第
    10 章 *应用程序工作流程和第三方插件*。
- en: In the *Sending data to a remote API* recipe, we handled our AJAX calls with
    the `axios` package. In this recipe, we will be using the native JavaScript `fetch`
    method for AJAX calls. Either method works just as well, and having exposure to
    both will hopefully allow you to decide which you prefer for your projects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*将数据发送到远程 API*的示例中，我们使用了`axios`包来处理我们的 AJAX 调用。在这个示例中，我们将使用原生 JavaScript 的
    `fetch` 方法进行 AJAX 调用。两种方法都同样有效，对两种方法都有所了解，希望能让您决定您更喜欢哪种方法来进行您的项目。
- en: 'Once you''ve taken care of creating an ejected app, install Realm with `yarn`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您处理了创建一个弹出式应用程序，就可以使用 `yarn` 安装 Realm：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can use `npm`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `npm`：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the package installed, you can link the native packages with the following
    code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了包之后，您可以使用以下代码链接本机包：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let''s open `App.js` and import the dependencies we''ll be using:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们打开 `App.js` 并导入我们将要使用的依赖项：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we need to instantiate our Realm database, which we''ll do in the `componentWillMount`
    method. We''ll keep a reference to it by using the `realm` class variable:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `componentWillMount` 方法中实例化我们的 Realm 数据库。我们将使用 `realm` 类变量保留对它的引用：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To create the `User` entries, we will use the random user generator API provided
    by [randomuser.me](http://randomuser.me). Let''s create a method with the `getRandomUser`
    function. This will `fetch` this data:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建 `User` 条目，我们将使用[randomuser.me](http://randomuser.me)提供的随机用户生成器 API。让我们创建一个带有
    `getRandomUser` 函数的方法。这将 `fetch` 这些数据：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ll also need a method for creating users in our app. The `createUser` method
    will use the function we defined previously to get a random user, before saving
    it to our realm database with the `realm.write` method and the `realm.create`
    method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个在我们的应用程序中创建用户的方法。`createUser` 方法将使用我们之前定义的函数来获取一个随机用户，然后使用 `realm.write`
    方法和 `realm.create` 方法将其保存到我们的 realm 数据库中：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since we''re interacting with a database, we should also add a function for
    updating a `User` in the database. `updateUser` will, for simplicity, take the
    first record in the collection and change its information:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在与数据库交互，我们还应该添加一个用于更新数据库中的 `User` 的函数。`updateUser` 将简单地获取集合中的第一条记录并更改其信息：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, let''s add a way to delete our users. We''ll add a `deleteUsers` method
    for removing all users. This is achieved by calling `realm.write` with a callback
    function that executes `realm.deleteAll`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加一种删除用户的方法。我们将添加一个 `deleteUsers` 方法来删除所有用户。这是通过调用带有执行 `realm.deleteAll`
    的回调函数的 `realm.write` 实现的：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s build our UI. We will render a list of `User` objects and a button for
    each of our `create`, `update`, and `delete` methods:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建我们的用户界面。我们将呈现一个 `User` 对象列表和一个按钮，用于我们的 `create`、`update` 和 `delete` 方法：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once we run the app on either platform, our three buttons for interacting with
    the database should display over the live data that''s saved in our Realm database:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在任何平台上运行应用程序，我们与数据库交互的三个按钮应该显示在我们的 Realm 数据库中保存的实时数据上：
- en: '![](assets/8b14a014-e823-46b5-bf7d-34ba1de2733d.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b14a014-e823-46b5-bf7d-34ba1de2733d.png)'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Realm database is built in C++ and its core is known as the **Realm Object
    Store**. There are products that encapsulate this object store for each major
    platform (Java, Objective-C, Swift, Xamarin, and React Native). The React Native
    implementation is a JavaScript adapter for Realm. From the React Native side,
    we do not need to worry about the implementation details. Instead, we get a clean
    API for persisting and retrieving data. The *step 4* to* step 6* demonstrate using
    some basic Realm methods. If you want to see more of what you can do with the
    API, check out the documentation for this, which can be found at [https://realm.io/docs/react-native/latest/api/](https://realm.io/docs/react-native/latest/api/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Realm数据库是用C++构建的，其核心被称为**Realm对象存储**。有一些产品为每个主要平台（Java、Objective-C、Swift、Xamarin和React
    Native）封装了这个对象存储。React Native的实现是Realm的JavaScript适配器。从React Native方面来看，我们不需要担心实现细节。相反，我们得到了一个用于持久化和检索数据的清晰API。*步骤4*到*步骤6*演示了使用一些基本的Realm方法。如果您想了解API的更多用法，请查看此文档，网址为[https://realm.io/docs/react-native/latest/api/](https://realm.io/docs/react-native/latest/api)。
- en: Masking the application upon network connection loss
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络连接丢失时对应用进行屏蔽
- en: An internet connection is not always available, especially when people are moving
    around a city, on the train, or hiking in the mountains. A good user experience
    will inform the user when their connection to the internet has been lost.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网连接并不总是可用，特别是当人们在城市中移动、乘坐火车或在山上徒步时。良好的用户体验将在用户失去与互联网的连接时通知用户。
- en: In this recipe, we will create an app that shows a message when network connection
    is lost.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个应用，当网络连接丢失时会显示一条消息。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create an empty app. Let's name it `network-loss`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个空的应用。让我们把它命名为`network-loss`。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by importing the necessary dependencies into `App.js`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`App.js`中导入必要的依赖项开始：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we''ll define the `App` class and a `state` object for storing the connectivity
    status. The `online` Boolean will be `true` if connected, and the `offline` Boolean
    will be `true` if it isn''t:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`App`类和一个用于存储连接状态的`state`对象。如果连接成功，`online`布尔值将为`true`，如果连接失败，`offline`布尔值将为`true`：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After the component has been created, we need to get the initial network status.
    We are going to use the `NetInfo` class''s `getConnectionInfo` method to get the
    current status, and we''ll also set up a callback that''s going to be executed
    when the status changes:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件创建后，我们需要获取初始网络状态。我们将使用`NetInfo`类的`getConnectionInfo`方法来获取当前状态，并且我们还将设置一个回调，当状态改变时将执行该回调：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When the component is about to be destroyed, we need to remove the listener
    via the `componentWillUnmount` life cycle:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件即将被销毁时，我们需要通过`componentWillUnmount`生命周期来移除监听器：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s add the callback that gets executed when the network status changes.
    It just checks whether the current network type is `none`, and sets the `state` accordingly:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个在网络状态改变时执行的回调。它只是检查当前的网络类型是否为`none`，并相应地设置`state`：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we know when the network is on or off, but we still need a UI for displaying
    information. Let''s render a toolbar with some dummy text as the content:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们知道网络是开启还是关闭，但我们仍然需要一个用于显示信息的用户界面。让我们渲染一个带有一些虚拟文本的工具栏作为内容：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see from the previous step, there''s a `renderMask` function. This
    function will return a modal when the network is offline, and nothing if it''s
    online:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您从上一步中看到的，有一个`renderMask`函数。当网络离线时，此函数将返回一个模态，如果在线则什么都不返回：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, let''s add the styles for our app. We''ll start with the toolbar and
    content:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们为我们的应用添加样式。我们将从工具栏和内容开始：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For the disconnection message, we will render a dark mask on top of all content,
    and a container with the text at the center of the screen. For the `mask`, we
    need to set the position to `absolute`, and then set the `top`, `bottom`, `right`,
    and `left` to `0`. We''ll also add opacity to the mask''s background color, and
    justify and align the content to the center:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于断开连接的消息，我们将在所有内容的顶部呈现一个黑色蒙版，并在屏幕中央放置一个带有文本的容器。对于`mask`，我们需要将位置设置为`absolute`，然后将`top`、`bottom`、`right`和`left`设置为`0`。我们还将为mask的背景颜色添加不透明度，并将内容调整和对齐到中心：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To see the mask displayed in the emulators, the emulated device must be disconnected
    from the internet. For the iOS simulator, simply disconnect your Mac''s Wi-Fi
    or unplug the Ethernet to disconnect the simulator from the internet. On the Android
    emulator, you can disable the Wi-Fi connection of the phone via the toolbar:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在模拟器中看到蒙版显示，模拟设备必须断开与互联网的连接。对于iOS模拟器，只需断开Mac的Wi-Fi或拔掉以太网即可断开模拟器与互联网的连接。在Android模拟器上，您可以通过工具栏禁用手机的Wi-Fi连接：
- en: '![](assets/0f528871-6c98-4795-95cf-0d10f0aef02b.png)![](assets/0e357b80-81b3-4a0c-8ba1-1f4e00d9fa9b.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0f528871-6c98-4795-95cf-0d10f0aef02b.png)![](assets/0e357b80-81b3-4a0c-8ba1-1f4e00d9fa9b.png)'
- en: 'Once the device has been disconnected from the internet, the mask should display
    accordingly:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设备与互联网断开连接，蒙版应该相应地显示：
- en: '![](assets/23f4c602-c56c-4ad1-9507-825302567b9b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23f4c602-c56c-4ad1-9507-825302567b9b.png)'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 2*, we created the initial `state` object with two properties: `online`
    will be `true` when a network connection is available, and `offline` will be `true`
    when it's not available.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们创建了初始的`state`对象，其中包含两个属性：`online`在网络连接可用时为`true`，`offline`在网络不可用时为`true`。
- en: In *step 3*, we retrieved the initial network status and set up a listener to
    check when the status changes. The network type returned by `NetInfo` will be
    either `wifi`, `cellular`, `unknown`, or `none`. Android also has the extra options
    of `bluetooth`, `ethernet`, and `WiMAX` (for WiMAX connections). You can read
    the documentation to see all of the available values: [https://facebook.github.io/react-native/docs/netinfo.html](https://facebook.github.io/react-native/docs/netinfo.html).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们检索了初始的网络状态并设置了一个监听器来检查状态的变化。`NetInfo`返回的网络类型可以是`wifi`、`cellular`、`unknown`或`none`。Android还有额外的选项，如`bluetooth`、`ethernet`和`WiMAX`（用于WiMAX连接）。您可以阅读文档以查看所有可用的值：[https://facebook.github.io/react-native/docs/netinfo.html](https://facebook.github.io/react-native/docs/netinfo.html)。
- en: In *step 5*, we defined the method that will execute whenever the network status
    changes, and set the `state` values of `online` and `offline` accordingly. Updating
    the state re-renders the DOM, and the mask is displayed if there is no connection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了每当网络状态发生变化时执行的方法，并相应地设置了`state`的值`online`和`offline`。更新状态会重新渲染DOM，如果没有连接，则会显示蒙版。
- en: Synchronizing locally persisted data with a remote API
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将本地持久化数据与远程API同步
- en: When using a mobile app, network connectivity is something that is often taken
    for granted. But what happens when your app needs to make an API call, and the
    user has just lost connectivity? Fortunately for us, React Native has a module
    that reacts to the network connectivity status. We can architect our application
    in a way that supports the loss of connectivity by synchronizing our data automatically
    as soon as the network connection is restored.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用移动应用程序时，网络连接通常是理所当然的。但是当您的应用程序需要调用API并且用户刚刚失去连接时会发生什么？幸运的是，对于我们来说，React Native有一个模块可以对网络连接状态做出反应。我们可以以一种支持连接丢失的方式设计我们的应用程序，通过在网络连接恢复后自动同步我们的数据来实现。
- en: This recipe will show a simple implementation of using the `NetInfo` module
    to control whether or not our application will make an API call. If connectivity
    is lost, we will keep a reference of the pending request and complete it when
    the network access is restored. We will be using [http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com) again
    to make a `POST` request to a live server.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤将展示使用`NetInfo`模块来控制我们的应用是否会进行API调用的简单实现。如果失去连接，我们将保留挂起请求的引用，并在网络访问恢复时完成它。我们将再次使用[http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com)来向实时服务器发出`POST`请求。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use an empty React Native application named `syncing-data`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，我们将使用一个名为`syncing-data`的空的React Native应用程序。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start this recipe by importing our dependencies into `App.js`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在`App.js`中导入我们的依赖项开始这个步骤：
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We''ll need to add the `pendingSync` class variable, which we''ll use for storing
    a pending request when there is no network connection available. We''ll also create
    the `state` object with properties for tracking whether the app is connected (`isConnected`),
    the status of a sync (`syncStatus`), and the response from the server after our
    `POST` request is made (`serverResponse`):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加`pendingSync`类变量，用于在没有可用网络连接时存储挂起的请求。我们还将创建`state`对象，其中包含用于跟踪应用程序是否连接（`isConnected`）、同步状态（`syncStatus`）以及发出`POST`请求后服务器的响应（`serverResponse`）的属性：
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the `componentWillMount` life cycle hook, we''ll get the status of the network
    connection via the `NetInfo.isConnected.fetch` method, setting the state''s `isConnected` property
    with the response. We''ll also add an event listener to the `connectionChange`
    event for keeping track of changes to the connection:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`componentWillMount`生命周期钩子中，我们将通过`NetInfo.isConnected.fetch`方法获取网络连接的状态，并使用响应设置状态的`isConnected`属性。我们还将添加一个`connectionChange`事件的事件侦听器，以跟踪连接的变化：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, let''s implement the callback that will be executed by the event listener
    we defined in the previous step. In this method, we update the `isConnected` property
    of `state`. Then, if the `pendingSync` class variable is defined, it means we''ve
    got a cached `POST` request, so we''ll submit that request and update the state
    accordingly:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现在前一步中定义的事件侦听器将执行的回调。在这个方法中，我们将更新`state`的`isConnected`属性。然后，如果定义了`pendingSync`类变量，这意味着我们有一个缓存的`POST`请求，因此我们将提交该请求并相应地更新状态：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we need to implement a function that will actually make the API call
    when there is an active network connection:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现一个函数，当有活动网络连接时，将实际进行API调用：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last thing we need to do before we can work on our UI is add a function
    for handling the `onPress` event on the Submit Data button we will be rendering.
    This will either perform the call immediately or be saved in `this.pendingSync`
    if there is no network connection:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以开始处理用户界面之前，我们需要做的最后一件事是为“提交数据”按钮添加一个处理`onPress`事件的函数，我们将要渲染这个按钮。如果没有网络连接，这将立即执行调用，否则将保存在`this.pendingSync`中：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can build out our UI, which will render the Submit Data button and
    show the current connection status, sync status, and most recent response from
    the API:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构建我们的用户界面，它将渲染“提交数据”按钮，并显示当前连接状态、同步状态以及来自API的最新响应：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can disable the network connection in the simulator in the same way as
    described in *step 10* of the previous recipe:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以像在上一个步骤的*步骤10*中描述的那样在模拟器中禁用网络连接：
- en: '![](assets/faa23de2-9bd7-4bc8-b2ed-c963e6cd7677.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/faa23de2-9bd7-4bc8-b2ed-c963e6cd7677.png)'
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe leverages the `NetInfo` module to control when an AJAX request should
    be made.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤利用了`NetInfo`模块来控制何时进行AJAX请求。
- en: In *step 6*, we defined the method that's executed when the Submit Data button
    is pressed. If there is no connectivity, we save the request body into the `pendingSync` class
    variable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们定义了当单击“提交数据”按钮时执行的方法。如果没有连接，我们将请求主体保存到`pendingSync`类变量中。
- en: In *step 3*, we defined the `componentWillMount` life cycle hook. Here, two `NetInfo`
    method calls retrieve the current network connection status and attach an event
    listener to the change event.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们定义了`componentWillMount`生命周期钩子。在这里，两个`NetInfo`方法调用检索当前的网络连接状态，并附加一个事件监听器到变化事件。
- en: In *step 4*, we defined the function that will be executed whenever the network
    connection has changed, which informs the state's `isConnected` Boolean property
    appropriately. If the device is connected, we also check to see whether there
    is a pending API call, and complete the request if it exists.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了当网络连接发生变化时将执行的函数，该函数适当地通知状态的`isConnected`布尔属性。如果设备已连接，我们还会检查是否有挂起的API调用，并在存在时完成请求。
- en: This recipe could also be expanded on to support a queue system of pending calls,
    which would allow multiple AJAX requests to be delayed until an internet connection
    was re-established.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程也可以扩展为支持挂起调用的队列系统，这将允许多个AJAX请求延迟，直到重新建立互联网连接。
- en: Logging in with Facebook
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Facebook登录
- en: Facebook is the largest social media platform in existence, with well over 1
    billion users worldwide. This means that there's a good chance that your users
    will have a Facebook account. Your app can register and link with their account,
    allowing you to use their Facebook credentials as a login for your app. Depending
    on the requested permissions, this will also allow you to access data such as
    user information, and pictures, and even give you the ability to access shared
    content. You can read more about the available permission options from the Facebook
    docs at [https://developers.facebook.com/docs/facebook-login/permissions#reference-public_profile](https://developers.facebook.com/docs/facebook-login/permissions#reference-public_profile).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook是全球最大的社交媒体平台，拥有超过10亿用户。这意味着您的用户很可能拥有Facebook账户。您的应用程序可以注册并链接到他们的账户，从而允许您使用他们的Facebook凭据作为应用程序的登录。根据请求的权限，这还将允许您访问用户信息、图片，甚至让您能够访问共享内容。您可以从Facebook文档中了解更多关于可用权限选项的信息，网址为[https://developers.facebook.com/docs/facebook-login/permissions#reference-public_profile](https://developers.facebook.com/docs/facebook-login/permissions#reference-public_profile)。
- en: In this recipe, we will cover a basic method for logging into Facebook via an
    app to get a session token. We'll then use that token to access the basic `/me`
    endpoint provided by Facebook's Graph API, which will give us the user's name
    and ID. For more complex interactions with the Facebook Graph API, you can look
    at the documentation, which can be found at [https://developers.facebook.com/docs/graph-api/using-graph-api](https://developers.facebook.com/docs/graph-api/using-graph-api).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将介绍通过应用程序登录Facebook以获取会话令牌的基本方法。然后，我们将使用该令牌访问Facebook的Graph API提供的基本`/me`端点，这将给我们用户的姓名和ID。要与Facebook
    Graph API进行更复杂的交互，您可以查看文档，该文档可以在[https://developers.facebook.com/docs/graph-api/using-graph-api](https://developers.facebook.com/docs/graph-api/using-graph-api)找到。
- en: To keep this recipe simple, we will be building an Expo app that uses the `Expo.Facebook.logInWithReadPermissionsAsync`
    method to do the heavy lifting of logging into Facebook, which will also allow
    us to bypass much of the setup that's otherwise necessary for such an app. If
    you wish to interact with Facebook without using Expo, you will likely want to
    use the React Native Facebook SDK, which requires a lot more steps. You can find
    the SDK at [https://github.com/facebook/react-native-fbsdk](https://github.com/facebook/react-native-fbsdk).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例简单，我们将构建一个使用`Expo.Facebook.logInWithReadPermissionsAsync`方法来完成Facebook登录的Expo应用程序，这也将允许我们绕过其他必要的设置。如果您希望在不使用Expo的情况下与Facebook交互，您可能希望使用React
    Native Facebook SDK，这需要更多的步骤。您可以在[https://github.com/facebook/react-native-fbsdk](https://github.com/facebook/react-native-fbsdk)找到SDK。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll create a new app called `facebook-login`. You will need
    to have an active Facebook account to test its functionality.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将创建一个名为`facebook-login`的新应用程序。您需要有一个活跃的Facebook账户来测试其功能。
- en: A Facebook Developer account is also necessary for this recipe. Head over to [https://developers.facebook.com](https://developers.facebook.com)
    to sign up if you don't have one. Once you are logged in, you can use the dashboard
    to create a new app. Make note of the app ID once it's been created, as we'll
    need it for the recipe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还需要一个Facebook开发者账户。如果您还没有，请前往[https://developers.facebook.com](https://developers.facebook.com)注册。一旦您登录，您可以使用仪表板创建一个新的应用程序。一旦创建完成，请记下应用程序ID，因为我们将在示例中需要它。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening the `App.js` file and adding our imports:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`App.js`文件并添加我们的导入开始：
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, we''ll declare the `App` class and add the `state` object. The `state`
    will keep track of whether the user is logged in with the `loggedIn` Boolean,
    and will save the retrieved user data from Facebook in an object called `facebookUserInfo`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将声明`App`类并添加`state`对象。`state`将跟踪用户是否使用`loggedIn`布尔值登录，并将在一个名为`facebookUserInfo`的对象中保存从Facebook检索到的用户数据：
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, let''s define the `logIn` method of our class. This will be the method
    that''s called when the Login button is pressed. This method uses the `logInWithReadPermissionsAsync` Expo
    helper class of the `Facebook` method to prompt the user with a Facebook login
    screen. Replace the first parameter, labeled `APP_ID` in the following code, with
    your App''s ID:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们的类的`logIn`方法。这将是在按下登录按钮时调用的方法。这个方法使用`Facebook`方法的`logInWithReadPermissionsAsync`
    Expo辅助类来提示用户显示Facebook登录屏幕。在下面的代码中，用你的应用ID替换第一个参数，标记为`APP_ID`：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the second half of the `logIn` method, if the request is successful, we''ll
    make a call to the Facebook Graph API using the token that was received from logging
    in to request the logged-in user''s information. Once the response resolves, we
    set the state accordingly:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`logIn`方法的后半部分，如果请求成功，我们将使用从登录中收到的令牌调用Facebook Graph API来请求已登录用户的信息。一旦响应解析，我们就相应地设置状态：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''ll also need a simple `render` function. We''ll display a Login button
    for logging in, as well as `Text` elements that will display user information
    once the login has completed successfully:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个简单的`render`函数。我们将显示一个登录按钮用于登录，以及一些`Text`元素，一旦登录成功完成，将显示用户信息：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see in the preceding `render` function, we''re calling `this.renderFacebookUserInfo`
    to render user information. This method simply checks whether the user in logged
    in via `this.state.loggedIn`. If they are, we''ll display the user''s information.
    If not, we''ll return `null` to display nothing:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您在前面的`render`函数中所看到的，我们正在调用`this.renderFacebookUserInfo`来渲染用户信息。这个方法简单地检查用户是否通过`this.state.loggedIn`登录。如果是，我们将显示用户的信息。如果不是，我们将返回`null`来显示空白：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we''ll add styles to complete the layout, setting padding, margins,
    color, and font sizes:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加样式以完成布局，设置填充、边距、颜色和字体大小：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, if we run the app, we''ll see our Login button, a login modal when the
    Login button is pressed, and the user''s information, which will be displayed
    once the user has successfully logged in:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用程序，我们将看到我们的登录按钮，当按下登录按钮时会出现登录模态，以及用户的信息，一旦用户成功登录，将显示在屏幕上：
- en: '![](assets/dae0c64f-f443-4740-a2c5-ccc23680be55.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dae0c64f-f443-4740-a2c5-ccc23680be55.png)'
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Interacting with Facebook in our React Native app is made much easier than it
    otherwise would be, via Expo's `Facebook` helper library.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的React Native应用中与Facebook互动要比以往更容易，通过Expo的`Facebook`辅助库。
- en: 'In *step 5*, we created the `logIn` function, which uses `Facebook.logInWithReadPermissionsAsync` to
    make the login request to Facebook. It takes two parameters: an `appID` and an
    options object. In our case, we''re only setting the permissions option. The permissions
    option takes an array of strings for each type of permission requested, but for
    our purpose, we only use the most basic permission, `''public_profile''`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们创建了`logIn`函数，它使用`Facebook.logInWithReadPermissionsAsync`来向Facebook发出登录请求。它接受两个参数：一个`appID`和一个选项对象。在我们的情况下，我们只设置了权限选项。权限选项接受一个字符串数组，用于请求每种类型的权限，但是对于我们的目的，我们只使用最基本的权限，`'public_profile'`。
- en: In *step 6*, we completed the `logIn` function. It makes a call to Facebook's
    Graph API endpoint, `/me`, upon successful login, using the token provided by
    the data that's returned from `logInWithReadPermissionsAsync`. The user's information
    and the login status are saved to state, which will trigger a re-render and display
    the user's data on the screen.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们完成了`logIn`函数。在成功登录后，它使用从`logInWithReadPermissionsAsync`返回的数据提供的令牌，向Facebook的Graph
    API端点`/me`发出调用。用户的信息和登录状态将保存到状态中，这将触发重新渲染并在屏幕上显示用户的数据。
- en: This recipe intentionally only makes a call to one simple API endpoint. You
    could use the return data from this endpoint to populate user data in your app.
    Alternatively, you could use the same token that was received from logging in
    to perform any actions provided by the Graph API. To see what kind of data is
    at your disposal via the API, you can view the reference docs at [https://developers.facebook.com/docs/graph-api/reference](https://developers.facebook.com/docs/graph-api/reference).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例故意只调用了一个简单的API端点。您可以使用此端点返回的数据来填充应用程序中的用户数据。或者，您可以使用从登录中收到的相同令牌来执行图形API提供的任何操作。要查看通过API可以获得哪些数据，您可以在[https://developers.facebook.com/docs/graph-api/reference](https://developers.facebook.com/docs/graph-api/reference)上查看参考文档。
