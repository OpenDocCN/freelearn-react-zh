- en: Bringing in the Real Live World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入真实世界
- en: As you learned in the last [Chapter 9](08f23d64-9bb7-4910-b0d9-86190ac5cc8b.xhtml), *Do
    it Yourself – Native Modules and Three.js*, we can include native code and JavaScript
    code into our world. Aside from breathing life into our world by making it more
    interesting visually, we can also bring the outside world in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章[第9章](08f23d64-9bb7-4910-b0d9-86190ac5cc8b.xhtml)中学到的，*自己动手-本地模块和Three.js*，我们可以将本地代码和JavaScript代码包含到我们的世界中。除了通过使其在视觉上更有趣来为我们的世界注入生命外，我们还可以将外部世界引入其中。
- en: In this chapter, you will learn how to use React and JavaScript to bring the
    web into the VR world. You will learn how to use your existing high-performance
    code in VR.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用React和JavaScript将网络带入VR世界。您将学习如何在VR中使用现有的高性能代码。
- en: First, we will need a VR world to start in. This time, we're going to Mars!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个VR世界来开始。这一次，我们要去火星了！
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Doing JSON/Web API calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行JSON/Web API调用
- en: The `Fetch` statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fetch`语句'
- en: '**Cross-Origin Resource Sharing** (**CORS**)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）
- en: The Networking tab for diagnostics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断的网络选项卡
- en: The `Cylindrical Pano` statement
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cylindrical Pano`语句'
- en: Justified text, similar to a flexbox (part of React Native)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于flexbox的文本对齐（React Native的一部分）
- en: Conditional rendering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件渲染
- en: Style sheets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式表
- en: Going to Mars (the initial world creation)
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前往火星（初始世界创建）
- en: You would think there is no weather in space, but actually there is, and we
    have weather stations there. We will go to Mars to get our weather. This will
    be a real-time program that will obtain weather data from the Mars Science Laboratory,
    or its rover called **Curiosity**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为太空中没有天气，但实际上是有的，我们在那里有天气站。我们将前往火星获取我们的天气。这将是一个实时程序，将从火星科学实验室或其名为**好奇号**的探测车获取天气数据。
- en: Curiosity is an SUV-sized robotic rover that was sent to Mars on November 26,
    2011 and landed on August 6, 2012\. If you drove your SUV there, even if you could
    buy gas, you would take about 670 years to get there. The Mars rover was designed
    for a two year mission, but its mission was extended, which is fortunate for us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇号是一辆体积为SUV大小的火星探测车，于2011年11月26日发射到火星，于2012年8月6日着陆。如果您开着SUV去那里，即使您能买到汽油，也需要大约670年才能到达那里。火星探测车最初设计为两年的任务，但其任务被延长了，这对我们来说是幸运的。
- en: Driving that SUV to Mars to get the weather report would have been a hassle.
    I don't even know where the gas stations are.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开着SUV去火星获取天气报告将是一件麻烦事。我甚至不知道加油站在哪里。
- en: Creating the initial world
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建初始世界
- en: 'First, as we''ve done before, go to your directory where you''re storing your
    worlds and create one, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像以前做过的那样，转到存储世界的目录并创建一个，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, download the assets from [https://github.com/jgwinner/ReactVRBook/tree/master/Chapter10/MarsInfo](https://github.com/jgwinner/ReactVRBook/tree/master/Chapter10/MarsInfo).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从[https://github.com/jgwinner/ReactVRBook/tree/master/Chapter10/MarsInfo](https://github.com/jgwinner/ReactVRBook/tree/master/Chapter10/MarsInfo)下载资产。
- en: Although I uploaded all of the files to make this work, not just the static
    assets, you really should try to code this yourself. You don't really learn anything
    from downloading files and running them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我上传了所有文件来使其工作，而不仅仅是静态资产，但您真的应该尝试自己编写代码。从下载文件并运行它们中，您并不会真正学到任何东西。
- en: Making mistakes is what builds character. I uploaded the files and will maintain
    them just in case there is *too much* character.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 犯错误是塑造性格的过程。我上传了文件并将继续维护它们，以防有*太多*的性格。
- en: Now that we have an initial world, we'll start setting up the web services to
    obtain data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个初始世界，我们将开始设置Web服务以获取数据。
- en: Jason and JSON
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jason和JSON
- en: 'When you hear people talk about JSON, hopefully, you aren''t thinking of this
    guy:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您听到人们谈论JSON时，希望您不会想到这个家伙：
- en: '![](Images/96fa4baa-8e01-4ee7-97ab-1a1193891460.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/96fa4baa-8e01-4ee7-97ab-1a1193891460.jpg)'
- en: I found the image on the web, marked creative commons; it's a Jason Voorhees
    costume (cosplay) from the Montreal Comic-Con. The photo is from Pikawil from
    Laval, Canada.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我在网上找到了这张图片，标记为创意共享；这是来自加拿大拉瓦尔的Pikawil拍摄的蒙特利尔Comic-Con上的Jason Voorhees服装（角色扮演）。
- en: On a serious note, JSON is the most common way to bring in the outside world
    through web services; however, as we've seen ways to include native code and JavaScript,
    you could integrate your system in a variety of ways.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 认真地说，JSON是通过Web服务引入外部世界的最常见方式；然而，正如我们已经看到包括原生代码和JavaScript的方式，您可以以各种方式集成您的系统。
- en: The other huge advantage of React VR is that it is based on React, so things
    that you can commonly do with React, you can do in React VR, with some important
    differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: React VR的另一个巨大优势是它基于React，因此您可以在React VR中常见的事情，也可以在React VR中做，只是有一些重要的区别。
- en: Why JSON has nothing to do with React
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么JSON与React无关
- en: At first, you might be thinking, *"How do I do AJAX requests in React VR?"*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，您可能会想，"在React VR中如何进行AJAX请求？"
- en: You don't, not really. React VR and React Native do not have any allegiance
    to any particular way of fetching data. In fact, as far as React is concerned,
    it doesn't even know there's a *server* in the picture at all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并不是。React VR和React Native对获取数据的方式没有任何忠诚度。事实上，就React而言，它甚至不知道图片中有*服务器*。
- en: 'React simply renders components using data from only two places: props and
    state.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React只是使用来自两个地方的数据（props和state）简单地渲染组件。
- en: 'That is the academic answer. The real answer is a bit more broad. You can get
    data any way you feel like it. After having said that, usually most React programmers
    will use one of these APIs and/or frameworks:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学术答案。真实答案要广泛一些。您可以以任何您喜欢的方式获取数据。在说完这些之后，通常大多数React程序员将使用这些API和/或框架之一：
- en: '**Fetch**: Nearly a standard, it is built-in to React, as it is usually already
    included; refer to [http://bit.ly/FetchAPI](http://bit.ly/FetchAPI) for usage
    notes and examples'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch：几乎是一个标准，它内置在React中，因为它通常已经包含；有关用法说明和示例，请参阅[http://bit.ly/FetchAPI](http://bit.ly/FetchAPI)
- en: '**Axios**: Axios revolves around promises (asynchronous completion APIs), although
    it can be used in a simpler way as well for singlethreaded apps; refer to [http://bit.ly/AxiosReadme](http://bit.ly/AxiosReadme)
    for more details'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Axios：Axios围绕着承诺（异步完成API）展开，尽管它也可以在单线程应用程序中以更简单的方式使用；有关更多详细信息，请参阅[http://bit.ly/AxiosReadme](http://bit.ly/AxiosReadme)
- en: '**Superagent**: If you don''t like promises, but like callbacks; refer to [http://bit.ly/SuperagentAPI](http://bit.ly/SuperagentAPI)
    for more info'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Superagent：如果您不喜欢承诺，但喜欢回调；有关更多信息，请参阅[http://bit.ly/SuperagentAPI](http://bit.ly/SuperagentAPI)
- en: In these examples, we will show fetch, as there is no need to install different
    modules and set up callbacks. After having said this, you may want to build a
    slightly more responsive app that uses some type of callback of asynchronous completion
    so that your app can do something while it waits for data externally. Fetch does
    do asynchronous completion through promises, so we'll be doing conditional rendering
    to take advantage of this and maintain a responsive VR app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们将展示fetch，因为没有必要安装不同的模块和设置回调。在说完这些之后，您可能希望构建一个稍微更具响应性的应用程序，该应用程序使用某种类型的回调或异步完成，以便在等待外部数据时执行某些操作。Fetch确实通过承诺进行异步完成，因此我们将进行条件渲染以利用这一点，并保持响应性VR应用程序。
- en: You may already have a lot of this code written. React VR, as discussed earlier,
    is a rendering system for your VR objects, so you can use a variety of external
    JavaScript systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经写了很多这样的代码。React VR，正如前面讨论的那样，是一个用于VR对象的渲染系统，因此你可以使用各种外部JavaScript系统。
- en: Finding the API -- All the way from Mars
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到API——从火星一直到地球
- en: Now, we'll get the weather data all the way from Mars. No, I'm not really joking.
    Refer to [http://bit.ly/MarsWeatherAPI](http://bit.ly/MarsWeatherAPI), which describes
    the API and gives a little science background, if you are interested. This API
    is set up to consume XML data from, and return it in, a JSON or JSONP format.
    The following is the resulting data, which you can also get by referring to: [http://marsweather.ingenology.com/v1/latest/](http://marsweather.ingenology.com/v1/latest/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从火星获取天气数据。不，我并不是在开玩笑。参考[http://bit.ly/MarsWeatherAPI](http://bit.ly/MarsWeatherAPI)，如果你感兴趣，这里描述了API并提供了一些科学背景。这个API被设置为从XML数据中获取并以JSON或JSONP格式返回。以下是结果数据，你也可以参考：[http://marsweather.ingenology.com/v1/latest/](http://marsweather.ingenology.com/v1/latest/)。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can fairly easily turn this into our JSON object. First, let''s test the
    connectivity and make a sanity check to the actual JSON text returned. We tested
    the preceding JSON data in a browser, but we need to test the code to make sure
    that it works. To do this, follow these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以相当容易地将这转换为我们的JSON对象。首先，让我们测试连接性，并对实际返回的JSON文本进行合理检查。我们在浏览器中测试了前面的JSON数据，但我们需要测试代码以确保它能正常工作。要做到这一点，请按照以下步骤：
- en: 'In `index.vr.js` find the MarsInfo `Component {`  declaration to add the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.vr.js`中找到MarsInfo `Component {`的声明，添加以下内容：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Paste this in and run it.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴这个并运行它。
- en: 'Open the console in the browser (*Ctrl*+*Shift*+*K* in Firefox Nightly). Although
    the code we just showed is really reasonable, and runs fine in the browser, when
    we run this, we will get an error:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开控制台（在Firefox Nightly中按*Ctrl*+*Shift*+*K*）。虽然我们刚刚展示的代码非常合理，在浏览器中运行良好，但当我们运行时，会出现错误：
- en: '![](Images/43f4c4e3-5168-4392-9908-550e7b62b00f.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/43f4c4e3-5168-4392-9908-550e7b62b00f.png)'
- en: What is the problem? It's CORS. This is a mechanism to make Cross-Origin or
    web content that doesn't come from the same server safe and secure. Essentially,
    it is a way for web servers to say, "I'm OK to be embedded in another web page."
    Your bank, for example, would not want to have your banking details embedded inside
    some other site's web page; your checking account could be compromised easily
    that way, and you'd think you were logging into your real bank—and you would be.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？是CORS。这是一种机制，用于使跨源或不来自同一服务器的Web内容安全可靠。基本上，这是Web服务器表明“我可以嵌入到另一个网页中”的一种方式。例如，你的银行不希望你的银行详细信息被嵌入到其他网站的网页中；你的支票账户可能会很容易地受到威胁，你会认为自己正在登录真正的银行——而实际上并非如此。
- en: Note that I could have used an API that did not give these errors, but you may
    well run into the same problem with your own content, so we will discuss how to
    spot a CORS problem and how to fix it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我本可以使用一个不会出现这些错误的API，但你可能会遇到自己内容的相同问题，所以我们将讨论如何发现CORS问题以及如何解决它。
- en: 'To find out why we got this error, we need to look at the protocol headers;
    open the Network tab by clicking on Tools ->Web Developer ->Network:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出我们为什么会出现这个错误，我们需要查看协议头；点击工具->Web开发者->网络，打开网络选项卡：
- en: '![](Images/737cb7a4-23ee-4587-8a4d-a0b584397150.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/737cb7a4-23ee-4587-8a4d-a0b584397150.png)'
- en: This window is very valuable for figuring out native JSON request issues and
    website integrations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口对于解决原生JSON请求问题和网站集成非常有价值。
- en: 'Once you bring up the console, you''ll see the different HTTP actions; click
    on the one that didn''t complete:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开控制台，你会看到不同的HTTP操作；点击那个没有完成的操作：
- en: '![](Images/21eea88e-d6be-4bd8-a82e-7b69caf419a4.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/21eea88e-d6be-4bd8-a82e-7b69caf419a4.png)'
- en: We will then take a look at the data that is returned.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将查看返回的数据。
- en: 'Look at the right-hand side of the following screenshot; here, you can click
    on a response and headers to check the data. We can see that the website does
    return the data; however, our browser (Firefox) has blocked it from showing by
    generating the CORS error:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下截图的右侧；在这里，您可以单击响应和头部来检查数据。我们可以看到网站确实返回了数据；但是，我们的浏览器（Firefox）通过生成CORS错误来阻止显示：
- en: '![](Images/9d3e593d-284b-40f8-9807-bfa13a15937d.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9d3e593d-284b-40f8-9807-bfa13a15937d.png)'
- en: The code was correct, but the website does not include the important CORS headers,
    so per CORS security rules, the website blocks it. You can read more about CORS
    at: [http://bit.ly/HTTPCORS](http://bit.ly/HTTPCORS).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是正确的，但网站没有包括重要的CORS头，因此根据CORS安全规则，网站将其阻止。您可以在以下网址了解有关CORS的更多信息：[http://bit.ly/HTTPCORS](http://bit.ly/HTTPCORS)。
- en: 'If you get this error, there may be a solution by adding headers to the request.
    To add headers, you need to modify the `fetch` request; the `fetch` request also
    allows a mode of `''cors''`. However, for whatever reason, for this particular
    website, the `''cors''` option didn''t seem to work for me; for other websites,
    it might work better. The syntax for this is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现此错误，可能可以通过向请求添加头部来解决。要添加头部，您需要修改`fetch`请求；`fetch`请求还允许使用`'cors'`模式。然而，出于某种原因，对于这个特定的网站，`'cors'`选项似乎对我不起作用；对于其他网站，可能效果更好。其语法如下：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To have more control over exactly what we are requesting, create a header object
    and pass it into the `fetch` command. This can also be used for what is called
    a **preflight check**, which is simply two requests: one to find out whether CORS
    is supported, and the second request will include values from the first request.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地控制我们的请求，创建一个头部对象并将其传递给`fetch`命令。这也可以用于所谓的**预检查**，即简单地进行两个请求：一个是为了找出CORS是否受支持，第二个请求将包括来自第一个请求的值。
- en: 'To construct a request or preflight request, set the headers as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建请求或预检查请求，请设置如下头部：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The header value `'Access-Control-Request-Headers'` can be set to custom header
    options that the server will return (if it supports CORS) to validate to the client
    code that this is a valid CORS request. As of 2016, the spec was modified to include
    wild cards, but not all servers will be updated. You may need to experiment and
    use the Network tab to see what's going on if you get a CORS error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 头部值`'Access-Control-Request-Headers'`可以设置为服务器将返回的自定义头部选项（如果支持CORS），以验证客户端代码是否是有效的CORS请求。截至2016年，规范已经修改以包括通配符，但并非所有服务器都会更新。如果出现CORS错误，您可能需要进行实验并使用网络选项卡来查看发生了什么。
- en: In this case, we will need to use options for a "preflight" check—but even after
    making a modification to the React VR networking code, this didn't work with [marsweather.ingenology.com](http://marsweather.ingenology.com) so,
    it's quite likely that their server has not been upgraded to modern web security
    standards.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要使用“预检查”的选项，但即使在修改了React VR网络代码之后，这在[marsweather.ingenology.com](http://marsweather.ingenology.com)上也没有起作用，因此他们的服务器很可能还没有升级到现代网络安全标准。
- en: This can happen! In our case, there really is no general fix. I did find a Firefox
    plugin that will allow you to bypass CORS restrictions (remember, the problem
    isn't from the server, it's the browser that shuts down your code when seeing
    the payload the server *already* sent), but this would require people to download
    plugins and fiddle with them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能会发生！在我们的情况下，确实没有通用的解决方法。我找到了一个Firefox插件，可以让您绕过CORS限制（请记住，问题不是来自服务器，而是浏览器在看到服务器*已经*发送的有效负载时关闭您的代码），但这需要人们下载插件并进行调试。
- en: 'We need to find a better API. NASA has a fantastic catalog of web APIs, and
    we will use their Mars rover camera API. You can fetch any of the hundreds of
    thousands of photos all for free. Once we use a different web API, we will get
    the proper CORS headers we''ve been looking for, and it all works just fine. Once
    we ask a server that has modern security standards, we will note that it automatically
    includes the access-control-allow-origin that Firefox needs (here wildcarded),
    as seen in the following image, taken from the Network tab:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一个更好的API。NASA拥有一个出色的Web API目录，我们将使用他们的火星探测器相机API。你可以免费获取数十万张照片中的任何一张。一旦我们使用不同的Web
    API，我们将得到我们一直在寻找的正确的CORS标头，一切都运行得很好。一旦我们向具有现代安全标准的服务器发出请求，我们会注意到它自动包含了Firefox需要的`access-control-allow-origin`（在这里是通配符），如下图所示，取自网络选项卡：
- en: '![](Images/5d3aadc5-181d-42fc-a1c2-8cc58ed417f0.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5d3aadc5-181d-42fc-a1c2-8cc58ed417f0.png)'
- en: So, instead of seeing the weather on Mars, we'll look at actual pictures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将看实际图片，而不是火星上的天气。
- en: A better API from NASA
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自NASA的更好的API
- en: To take a look at some great web APIs, you can go to: [http://bit.ly/NasaWebAPI ](http://bit.ly/NasaWebAPI)and
    see the list of APIs that you can use, or better yet, use some web APIs you've
    already written. React VR makes it very easy to integrate these through the power
    of React and React Native. We will use the Mars photo API. To enable it, you will
    probably need a Developer key. When you make the requests, you can add your API
    key to the URL or use `DEMO_KEY`. This becomes part of the API call, for example, [https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?sol=1000&api_key=DEMO_KEY](https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?sol=1000&api_key=DEMO_KEY).
    Note that there is no period on the end of the URL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一些很棒的Web API，你可以访问：[http://bit.ly/NasaWebAPI](http://bit.ly/NasaWebAPI)并查看你可以使用的API列表，或者更好的是，使用你已经编写的一些Web
    API。React VR使得通过React和React Native的强大功能集成这些API变得非常容易。我们将使用火星照片API。要启用它，你可能需要一个开发者密钥。当你发出请求时，你可以将你的API密钥添加到URL中，或者使用`DEMO_KEY`。这将成为API调用的一部分，例如，[https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?sol=1000&api_key=DEMO_KEY](https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?sol=1000&api_key=DEMO_KEY)。请注意，URL末尾没有句号。
- en: If you start getting errors while developing your code, you might be using the
    `DEMO_KEY` a little too much; it is very quick and easy to get your own Developer
    API; instructions for that can be found at the website I mentioned at: [http://bit.ly/NasaWebAPI](http://bit.ly/NasaWebAPI).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开发代码时出现错误，你可能使用了`DEMO_KEY`太多次；获取你自己的开发者API非常快速和简单；有关说明可以在我提到的网站上找到：[http://bit.ly/NasaWebAPI](http://bit.ly/NasaWebAPI)。
- en: 'To fetch the data from NASA, all we have to do is change the `fetch` command
    slightly, as follows; we won''t need the custom headers, as it turns out:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要从NASA获取数据，我们只需稍微更改`fetch`命令，如下所示；事实证明，我们不需要自定义标头：
- en: 'Change `index.vr.js` to the following, up to the `render()` statement:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`index.vr.js`更改为以下内容，直到`render()`语句：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is all we have to do to obtain the data from Mars, via NASA and put it
    in a collection. Amazing! The following are a few notes on what we did:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们从NASA获取火星数据并将其放入集合中所需做的一切。太棒了！以下是我们所做的一些注意事项：
- en: The `photoCollection` object is initialized to be an empty array (collection).
    This is so that we can use similar code before and after we get data.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`photoCollection`对象被初始化为空数组（集合）。这样我们在获取数据之前和之后可以使用类似的代码。'
- en: You should still check for failures, however.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，你仍然应该检查是否有失败。
- en: The `currentPhoto` value we initialize to `2` as sort of a "cheat." The reason
    this is cheating is that when I was writing this book, if you let `currentPhoto`
    default to the first image, your first view of Mars was pretty boring. The first
    couple of images were test images and fairly plain, so I'll have you change `currentPhoto`
    to `2`, so we can see something interesting. You might do the same thing if you
    have an API that returns specific data you want to show someone.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`currentPhoto`值初始化为`2`，有点像是在“作弊”。这样做的原因是，当我写这本书的时候，如果你让`currentPhoto`默认为第一张图片，你在火星的第一个视图会很无聊。前几张图片都是测试图片，相当普通，所以我让你把`currentPhoto`改成`2`，这样我们就能看到一些有趣的东西。如果你有一个返回特定数据的API，你也可以做同样的事情。
- en: This code just obtains data; it doesn't render it. For that, we will develop
    a separate object to keep our code modular.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码只是获取数据；它不会渲染它。为此，我们将开发一个单独的对象来保持我们的代码模块化。
- en: 'For debugging purposes, we''ll also add a line in the `render()` thread to
    see exactly what data we have. Insert the following `console.log` statement:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于调试目的，我们还将在`render()`线程中添加一行，以查看我们确切拥有的数据。插入以下`console.log`语句：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This can be very handy for working out the rendering code and understanding
    the current state and how it changes. Run this code, and we can see the object
    that is returned in the console.  First, we get a line from the `render()` thread
    that shows us an empty `photo collection`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于解决渲染代码和理解当前状态以及其变化非常有用。运行这段代码，我们可以在控制台中看到返回的对象。首先，我们从`render()`线程中得到一行，显示一个空的`photo
    collection`：
- en: '![](Images/207bd55f-cb86-4cdf-b080-9be5d5110377.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/207bd55f-cb86-4cdf-b080-9be5d5110377.png)'
- en: 'Note that the `photo collection` is empty; this makes sense as we initialized
    it that way. After a few seconds delay—during which you *can view the virtual
    world*—you will see another `render()` update and changed data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`photo collection`是空的；这是有道理的，因为我们是这样初始化的。几秒钟后——在这段时间内*你可以查看虚拟世界*——你会看到另一个`render()`更新和更改的数据：
- en: '![](Images/f4110a61-08cd-4deb-a3b1-8ca1530e8bc9.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f4110a61-08cd-4deb-a3b1-8ca1530e8bc9.png)'
- en: In this particular case (day 1,1197), there were a *lot* of images. JSON handles
    this very well, slicing (ouch, bad pun) and dicing the data, all while we look
    around in our VR world.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下（第1,1197天），有*很多*图片。JSON处理这些数据非常出色，同时我们在VR世界中四处张望。
- en: Another thing to note is that the `render()` loop is called just twice. If you
    are used to a game development paradigm, this may seem weird since, as we discussed,
    to build a sense of immersion, we will need more than 60 frames per second. How
    can we do that if we rendered just twice?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是`render()`循环只被调用了两次。如果你习惯于游戏开发范式，这可能看起来很奇怪，因为正如我们讨论过的，为了建立沉浸感，我们需要超过60帧每秒。如果我们只渲染了两次，我们怎么能做到呢？
- en: React VR doesn't do the actual image generation, three.js does. When React VR
    "renders," it just takes the React VR syntax and applies any props or state changes
    and calls `render()` for those objects that have changed once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: React VR并不实际生成图像，而是由three.js完成。当React VR“渲染”时，它只是采用React VR语法，并应用任何props或状态更改，并为那些已经改变的对象调用`render()`。
- en: To display the data we've retrieved, we'll build a new object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示我们检索到的数据，我们将构建一个新对象。
- en: Create a new file, called `CameraData`, and make it a separate component. We'll
    also change the `render()` method in `index.vr.js`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CameraData`的新文件，并将其作为一个单独的组件。我们还将改变`index.vr.js`中的`render()`方法。
- en: Everyone needs a style(sheet)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个人都需要一个样式表
- en: Styles aren't just for your hair; in this case, it will help to use a style
    sheet to make our code simpler, cleaner, and easier to maintain. Style reuse is
    very easy. Styles aren't a separate language; they are JavaScript like everything
    else in React. All of the core objects in React VR accept a prop named `styles`.
    We will define this style in our file and reuse it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 样式不仅仅适用于你的头发；在这种情况下，使用样式表将有助于使我们的代码更简单、更清洁、更易于维护。样式重用非常容易。样式不是一种单独的语言；它们像React中的其他所有内容一样都是JavaScript。React
    VR中的所有核心对象都接受一个名为`styles`的prop。我们将在我们的文件中定义这个样式并重用它。
- en: 'Create the following style definitions so that we can use them for the `CameraData.js`
    component (note that you can put this anywhere in the file):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下样式定义，以便我们可以在`CameraData.js`组件中使用它们（请注意，您可以将其放在文件的任何位置）：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you omit the `width` style, objects will transform and move completely differently.
    I'm not sure yet if this is a bug or is a different type of layout style, but
    note that if your `transform` statements are not moving a text or view object,
    it might be because you don't have a `width:` prop for your text style.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`width`样式，对象将以完全不同的方式进行变换和移动。我还不确定这是否是一个错误，还是一种不同类型的布局样式，但请注意，如果您的`transform`语句没有移动文本或视图对象，可能是因为您的文本样式没有`width:`属性。
- en: Building the image and status UI
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建图像和状态UI
- en: Next, we will need to render the camera data in two different ways. The first,
    when we have no `CameraData`, yet, in other words, right when the app starts up,
    or if we don't have an internet connectivity; and the second, when we obtain the
    data and need to display it. We also want to keep these routines fairly modular
    so that when a state change is initiated we can easily redraw the objects that
    need it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要以两种不同的方式渲染相机数据。第一种是当我们还没有`CameraData`时，换句话说，就是在应用程序启动时，或者如果我们没有互联网连接；第二种是当我们获取数据并需要显示它时。我们还希望保持这些例程相当模块化，以便在启动状态变化时可以轻松地重新绘制需要的对象。
- en: Note that a lot of this is done automagically by React VR. If an object's props
    or state do not change, it is not told to render itself. In this case, our main
    thread already has the JSON handling to modify the change, so nothing in the main
    loop has to be created to re-render the camera data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，React VR自动完成了很多工作。如果一个对象的props或状态没有改变，它就不会被告知重新渲染自己。在这种情况下，我们的主线程已经具有了修改更改的JSON处理，因此主循环中不需要创建任何内容来重新渲染相机数据。
- en: 'Add the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we aren't finished with the component, so don't type the final `};`
    yet. Let's discuss what we added. The previous main `render()` loop essentially
    checks what values are valid and calls one of two routines to actually do the
    rendering, either `renderPhoto(photo)` or `renderLoadingView()`. We can assume
    that if we don't have a photo, we are in the process of loading it. The nice thing
    about the preceding code is that we are checking our props and making sure that
    they are valid before using them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有完成组件，所以不要输入最终的`};`。让我们讨论一下我们添加了什么。先前的主`render()`循环实质上是检查哪些值是有效的，并调用两个例程中的一个来实际进行渲染，要么是`renderPhoto(photo)`，要么是`renderLoadingView()`。我们可以假设如果我们没有照片，我们正在加载它。前面的代码的好处是在使用之前检查我们的props并确保它们是有效的。
- en: Many computer courses and self-help books strip out error handling to *"concentrate
    on the important things"*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机课程和自助书籍剥离了错误处理以“专注于重要的事情”。
- en: Error handling is the *most* important thing in your app.In this case, it's
    particularly important as while we are retrieving data, we don't have the photographs
    loaded yet, so we have nothing to display. We'll get an error if we don't handle
    this. What I have stripped out are `console.log` statements; if you download the
    source code for the book, you will find more extensive comments and trace statements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是你的应用程序中*最*重要的事情。在这种情况下，它特别重要，因为当我们检索数据时，我们还没有加载照片，所以我们没有东西可以显示。如果我们不处理这个问题，我们会得到一个错误。我剥离的是`console.log`语句；如果你下载本书的源代码，你会发现更多的详细注释和跟踪语句。
- en: Now, let's move on to the actual rendering. This looks deceptively simple, mostly
    as all of the hardwork to serialize, fetch, and selectively render has already
    been done. This is what programming should strive to be—clean, robust, easy to
    understand, and maintain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行实际的渲染。这看起来欺骗性地简单，主要是因为所有序列化、获取和有选择地渲染的辛苦工作已经完成。这就是编程应该努力做到的—清晰、健壮、易于理解和维护。
- en: Some of these code samples are getting long, so I'm putting closing braces and
    tags at the end of the object they are closing. I would recommend that you buy
    a large desktop screen and code in a more expansive way; when you spend an hour
    tracking down a missing or out of place `/>`, you will appreciate a large format
    display device. It just helps productivity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码示例变得很长，所以我把闭合括号和标签放在它们要关闭的对象的末尾。我建议你买一个大的台式屏幕，以更宽广的方式编码；当你花一个小时追踪丢失或放错的`/>`时，你会感激大尺寸的显示设备。这只会提高生产力。
- en: 'Add the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you''ve typed in all of the code so far, when the world loads, you will
    see a green dialog box that informs you that it''s receiving data. After a few
    seconds, that will be replaced by photo 2 and detailed meta-info about the data
    that came to you from Mars, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你迄今为止已经输入了所有的代码，当世界加载时，你会看到一个绿色的对话框，告诉你它正在接收数据。几秒钟后，它将被照片2和来自火星的数据的详细元信息所取代。
- en: '![](Images/acd7e7e7-b883-4ad2-94ea-dfab4bf0a77a.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/acd7e7e7-b883-4ad2-94ea-dfab4bf0a77a.jpg)'
- en: If you want to open two virtual words at the same time, for example, to check
    on some imports without incurring the round trip web hits that we're in the middle
    of programming, you can do it by going to your second world that's set up, instead
    of `npm start`, using the `react-native start --port 9091` command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时打开两个虚拟世界，例如，为了检查一些导入而不产生我们正在编程中的往返网络请求，你可以通过转到设置好的第二个世界，而不是`npm start`，使用`react-native
    start --port 9091`命令来实现。
- en: I mentioned this briefly earlier, but it's important to note how multithreaded
    React really is; the elements change their rendering when their props or state
    change, without being told to. It's multithreaded without a change of code. This
    allows you to move the camera around and look while the world fills in its data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前简要提到过这一点，但重要的是要注意React是多线程的；当它们的props或状态改变时，元素会改变它们的渲染，而无需告诉它们。这是多线程的，而不需要改变代码。这使你能够在世界填充数据时移动摄像机并查看。
- en: This makes the virtual world seem more "real"; it responds to input just as
    if it was reality. It is—we created a Virtual Reality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这使虚拟世界看起来更加“真实”；它对输入做出响应，就像它是现实一样。它就是—我们创造了虚拟现实。
- en: How (not to) to make people sick
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何（不）让人生病
- en: You may have noted that we put the user interface for this—the icons and the
    screens—a little far out; so far, we've put everything at least five meters out.
    Why is that?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们把用户界面——图标和屏幕——放得有点远；到目前为止，我们把所有东西都放在至少五米外。为什么呢？
- en: It's because of accommodation-vergence conflict.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为容纳-聚焦冲突。
- en: When your eyes 'point' at something, like we discussed in Chapter 1, *What is
    Virtual Reality, Really?*, and if that something is really close to your face,
    your eyes will attempt to focus on it. However, your HMD is a fixed focus device,
    and always shows things in focus, no matter how close or far away they are. In
    the real world, something that is, say, closer than 3 to 4 feet will require your
    eyes to focus more than something say 10 feet away.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的眼睛“注视”着某样东西，就像我们在第1章“虚拟现实到底是什么？”中讨论的那样，如果那个东西离你的脸很近，你的眼睛会试图对其进行聚焦。然而，你的头戴式显示器是一个固定焦距的设备，无论物体离你有多近或多远，它总是显示清晰的图像。在现实世界中，比如说，距离小于3到4英尺的物体会需要你的眼睛进行更多的聚焦，而距离10英尺的物体则需要较少的聚焦。
- en: So, your eyes will converge on an image that you should have to focus more on,
    but what you are looking at is already in focus (as everything is), so there is
    a difference between what you expect to see in the real world and what you see
    in the HMD.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的眼睛会聚焦在一个你本应该需要更多聚焦的图像上，但你所看到的已经是清晰的（因为一切都是清晰的），所以你期望在现实世界中看到的和在头戴式显示器中看到的有所不同。
- en: This doesn't cause any actual vision issues—everything is sharp and in focus.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会导致任何实际的视觉问题——一切都是清晰的和聚焦的。
- en: What you can get would be eye strain and a vague feeling of discomfort, which
    is worse the longer you use the HMD.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感到眼睛疲劳和一种模糊的不适感，这种感觉会随着使用头戴式显示器的时间变得更糟。
- en: The way to avoid this is to try to always put UI elements at least as far away
    as we have in this example. Don't put floating screens where a pair of glasses
    would be, for example. If you do, people will look at them, and their eyes will
    expect to have to focus on something say six inches away, but from a focus standpoint,
    the item is more than arms-length away. This will strain your users.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的方法是尽量将UI元素放得比我们在这个例子中展示的更远。比如不要将浮动屏幕放在眼镜的位置。如果你这样做，人们会看着它们，他们的眼睛会期望对着距离大约六英寸的东西进行聚焦，但从聚焦的角度来看，这个物体的距离已经超过了手臂的长度。这会让你的用户感到疲劳。
- en: This is why most VR has you looking at large screens that are far away to make
    a selection. About the closest you would want to make a UI element might be on
    a wrist, and even that is a little risky.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么大多数虚拟现实让你看着远处的大屏幕进行选择。你可能希望将UI元素放在手腕上，甚至那样也有点冒险。
- en: I do feel that the more people use VR, the more their eyes and focusing will
    retrain, however, I do not know of any medical studies that show this effect.
    I only mention it because I have a nearsighted eye and a farsighted eye; when
    I put glasses on, my focusing changes. What is funny is that if I put on glasses
    *without any glass*, my focusing still changes. I feel the human brain is infinitely
    adaptable and that we can overcome the accommodation-vergance conflict.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得人们使用虚拟现实的次数越多，他们的眼睛和聚焦就会得到重新训练，然而，我不知道有没有任何医学研究显示这种效果。我之所以提到这一点，是因为我的一只眼睛近视，另一只眼睛远视；当我戴上眼镜时，我的聚焦会发生变化。有趣的是，如果我戴上“没有镜片”的眼镜，我的聚焦仍然会发生变化。我觉得人类大脑是无限适应的，我们可以克服调节-调节冲突。
- en: Your user's mileage may vary, however, so don't make them tired by putting things
    at a close distance (less than a meter) to their face.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户的体验可能会有所不同，所以不要让他们因为把东西放得太近（距离小于一米）而感到疲劳。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned quite a few things. We've taken our worlds and
    made them truly interactive by building web service calls that consume JSON APIs.
    We've seen a few ways to obtain data and used the more or less built-in `fetch`
    statement. These API calls are now asynchronous, so we can look around our world
    and admire Mars while the camera data we're asking for is loading.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多东西。我们通过构建消耗JSON API的网络服务调用，使我们的世界真正实现了互动。我们看到了一些获取数据的方法，并使用了更多或更少内置的`fetch`语句。这些API调用现在是异步的，所以我们可以环顾四周，欣赏火星，而我们请求的相机数据正在加载。
- en: We've seen how to build secure worlds by handling cross-site scripting issues.
    We've created justified text and built conditional rendering. We've also discussed
    error handling.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过处理跨站脚本问题来构建安全的世界。我们创建了合理的文本并进行了条件渲染。我们还讨论了错误处理。
- en: Doing all of this takes some time, and we've had a few times where during development
    we spent hours trying to line up objects. I got shut down a few times because
    I was exceeding the `DEMO_KEY` number of retrievals during one hour. That's why
    I recommend that you get your own API key, then you can request a lot more images.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 做所有这些需要一些时间，我们在开发过程中有几次花了几个小时来排列对象。有几次我被关闭，因为我在一个小时内超过了“DEMO_KEY”检索次数。这就是为什么我建议你获取自己的API密钥，然后你就可以请求更多的图片。
- en: This chapter has been fairly long, and the world, while retrieving real-world
    data, is not totally interactive yet. In the next chapter, you will learn how
    to make your worlds interact to our input. This is why I built in the + and -
    arrows in the preceding view. Check out the next chapter to find how to hook them
    up to a page through our Mars data. I'll show a different world, but show ways
    to make the buttons interactive. It'll be your exercise to come up with and make
    simple prop changes to make the plus and minus buttons real.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章相当长，虽然检索了真实世界的数据，但世界还不是完全互动的。在下一章中，你将学习如何使你的世界与我们的输入互动。这就是为什么我在前面的视图中加入了+和-箭头。查看下一章，找出如何将它们连接到页面通过我们的火星数据。我会展示一个不同的世界，但展示如何使按钮互动。你可以通过做简单的属性更改来使加号和减号按钮变得真实。
