- en: Take a Walk on the Wild Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 走在野生的一边
- en: We've built some real, yet small, worlds so far in the chapters up to here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在前面的章节中，我们已经建立了一些真实但小型的世界。
- en: There has been something missing, however. At the start, I've talked about VR
    as being something that you can interact with — a reality, even if it doesn't
    look real. So far, most of what we've been doing is looking and seeing things,
    but we can't move around.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些东西一直缺失。一开始，我谈到了VR作为一种可以互动的东西——一种现实，即使它看起来并不真实。到目前为止，我们所做的大部分是看和观察事物，但我们无法四处移动。
- en: In this chapter, we will do exactly that.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做到这一点。
- en: 'You will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习以下主题：
- en: Using NPM to add components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NPM添加组件
- en: The Gaze button
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凝视按钮
- en: Using a Gaze button to trigger an event
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凝视按钮触发事件
- en: Adding in JavaScript files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加JavaScript文件
- en: Converting the JavaScript files to build geometry on the fly
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JavaScript文件转换为动态构建几何图形
- en: Moving the point of view in the world we've created
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们创建的世界中移动观点
- en: Moving makes things seem more real
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动使事物看起来更真实
- en: A little more about VR controllers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于VR控制器的信息
- en: Going loco–VR locomotion
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发疯了——VR运动方式
- en: I used to get carsick as a kid. VR can do this to you too — the reasons for
    this were discussed earlier while introducing VR, but this is a very important
    topic, so it bears repeating.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我小时候晕车。VR也会让你晕车——之前在介绍VR时已经讨论了这些原因，但这是一个非常重要的话题，所以值得重复。
- en: If you move a point of view, independently of what the user is doing (user agency),
    the brain knows that it didn't move. Yet, the brain also sees the world moving
    through your (VR) eyes. The brain then relies on a very ancient, important survival
    characteristic—you will think you've been poisoned.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移动一个观点，独立于用户的行为（用户代理），大脑会知道它没有移动。然而，大脑也会看到世界通过你（VR）的眼睛移动。然后，大脑依赖于一个非常古老、重要的生存特征——你会认为自己中毒了。
- en: When you've been poisoned, your body is very good at emesis. In less clinical
    terms, you throw up. Your body figures that something is trying to kill you, so
    it just gets rid of whatever is in your stomach as a panic reaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你中毒时，你的身体非常擅长呕吐。用不太临床的术语来说，你会呕吐。你的身体认为有什么东西试图杀死你，所以它只是想尽快摆脱胃里的任何东西，作为一种恐慌反应。
- en: So, how do you move around in VR? How to enable VR locomotion without making
    people loco?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在VR中如何移动？如何在不让人发疯的情况下启用VR运动方式？
- en: Types of VR locomotion
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR运动方式的类型
- en: A discussion of VR locomotion wouldn't be complete without discussing VR controllers
    at least a little bit. What you've got in your hands, under your feet, holding
    you up, or letting you roll around in obviously makes a huge difference.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论VR运动方式，至少要稍微讨论一下VR控制器。你手中拿着的东西，脚下的东西，支撑你的东西，或者让你在周围滚动的东西显然会产生巨大的影响。
- en: We are discussing WebVR, which, while very easy for people to get into, probably
    means that your users may not have all of the various types of VR gear handy.
    If you do have gear handy, you may still find that for your app, simpler types
    of locomotion are better, and they are certainly faster to code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在讨论WebVR，虽然对人们来说非常容易上手，但这可能意味着你的用户可能没有各种类型的VR装备。如果你确实有装备，你可能会发现对于你的应用程序，更简单的运动方式更好，而且编码速度肯定更快。
- en: When discussing equipment, people discuss **Degrees of Freedom **(**DOF**).
    This really is less about strictly considering degrees of freedom but mostly about
    what is tracked.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论设备时，人们讨论**自由度**(**DOF**)。这实际上与严格考虑自由度有关，但主要是关于被跟踪的内容。
- en: If you have a handheld device, you may have only **3DOF**; this means that the
    electronics can track whether you spin it around its center or not. A **6DOF**
    controller is tracked that way, but it can also detect whether it is moving around,
    in other words, translating. Usually, each of these has 3 degrees.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有手持设备，您可能只有**3DOF**；这意味着电子设备可以跟踪您是否围绕其中心旋转。**6DOF**控制器是这样跟踪的，但它也可以检测自己是否在移动，换句话说，是在进行平移。通常，每个都有3个度。
- en: A 6DOF controller is much more lifelike; you can reach out and touch things.
    However, they require some form of tracking, which, for the current state of the
    industry, usually means external trackers such as the Vive lighthouses or the
    Oculus cameras.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 6DOF控制器更加逼真；您可以伸手触摸物体。然而，它们需要某种形式的跟踪，对于目前的行业状态来说，通常意味着外部跟踪器，比如Vive灯塔或Oculus摄像头。
- en: There is a third type of tracking called *inside out* tracking, which simply
    means that the headset itself sees the controllers and figures out where they
    are. They do use cameras, just not external cameras scattered about the room.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为*内部跟踪*的跟踪方式，这意味着头戴设备本身可以看到控制器并确定它们的位置。它们确实使用摄像头，只是不是散布在房间周围的外部摄像头。
- en: It's difficult to categorize types of locomotion as things that work without
    controllers; it may also work great with controllers (teleportation).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很难将运动类型归类为无控制器的运动方式；它也可能与控制器（传送）一起很好地工作。
- en: I won't really include moving your head around (or mousing around), although
    that is movement; without that, a VR system isn't really VR (in my definition).
    However, there have been VR headsets that did not include this feature—or don't
    do it well. This is the real breakthrough for high-end cell phones (for Samsung
    Gear VR and Google Daydream) and for the PC headsets, Vive and Rift.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会真的包括四处移动头部（或四处移动鼠标），尽管那也是移动；没有这个，VR系统实际上不是真正的VR（按我的定义）。然而，确实有一些VR头戴设备不包括这个功能，或者做得不好。这是高端手机（三星Gear
    VR和Google Daydream）和PC头戴设备Vive和Rift的真正突破。
- en: 'Consider the following types of VR Locomotion:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类型的VR运动：
- en: '**Gaze detection**:You look at something, and it activates an effect, a blink,
    or makes you move'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝视检测**：您看着某物，它会激活一个效果，一个眨眼，或者让您移动'
- en: '**Vehicles/Cockpit locomotion**: Your view shows walls or details of a cockpit'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**车辆/驾驶舱运动**：您的视野显示墙壁或驾驶舱的细节'
- en: Can move with gaze detection
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过凝视检测移动
- en: With controllers (joysticks, and so on)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有控制器（游戏手柄等）
- en: Timed/artificial (push a button or move the player after a time)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时/人工（按下按钮或在一段时间后移动玩家）
- en: Only a slight chance of getting ill
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有轻微的生病几率
- en: '**Room scale**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**房间规模**：'
- en: Walk around (up to bounds)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四处走动（直到边界）
- en: Very low chance of getting ill
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生病的几率非常低
- en: Requires hardware
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要硬件
- en: '**Teleportation or blinks**:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传送或眨眼**：'
- en: Usually with Gaze or with 3DOF or 6DOF controllers
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常使用凝视或3DOF或6DOF控制器
- en: Teleportation can also be done in small steps—removing motion (vection); this
    makes it feel like you are moving, but won't make you sick
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传送也可以分成小步骤进行——消除运动（视觉加速）；这会让您感觉自己在移动，但不会让您感到恶心
- en: '**Treadmills**:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跑步机**：'
- en: A device you stand on and move your feet, and it detects how you move
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种您站在上面并移动脚，它会检测您的移动方式
- en: There are hang glider simulators as well as flight simulators, where you lay
    down or sit down and fly by shifting your body weight
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有滑翔伞模拟器和飞行模拟器，您可以躺下或坐下，通过移动身体重量来飞行
- en: All of these are large and expensive, usually limited to VR arcades
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些都很大且昂贵，通常只限于VR游乐场
- en: '**Tracked 6DOF controller movement paradigms**:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪的6DOF控制器运动范式**：'
- en: Vive/Rift usually use teleportation, and the 6DOF controllers make it easy
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vive/Rift通常使用传送，而6DOF控制器使其变得容易
- en: There are many other ways to move with 6DOF controllers; one good list can be
    found at [http://bit.ly/VRLoco](http://bit.ly/VRLoco)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多其他使用6DOF控制器的移动方式；一个好的列表可以在[http://bit.ly/VRLoco](http://bit.ly/VRLoco)找到
- en: '**Artificial locomotion/rails**:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工运动/轨道：
- en: Once you've used your UI to indicate what to do, the VR system moves you along
    a path.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你使用UI指示要做什么，VR系统就会沿着一条路径将你移动。
- en: Gaze/head controlled turning is in this category.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凝视/头部控制的转向属于这一类。
- en: Very easy to make people sick.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易让人感到恶心。
- en: It can be irritating — if your head turns, just change the way you move; even
    if you don't get sick, you'll feel as if you are being carried away. Still, it
    can work with careful implementation.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的头转动，它可能会很烦人；只需改变你的移动方式；即使你不会感到恶心，你也会感觉自己被带走了。不过，通过谨慎的实施，它也可以起作用。
- en: The preceding ways to move around are, of course, constrained by how much hardware
    you have. Another constraint is how large you want your audience to be. If you
    design your VR app to be **room scale** (natural walking around), you've excluded
    every mobile phone user. Yet, by the same token, if you've decided on a gaze teleportation
    system, people that do have room scale VR will feel frustrated that they cannot
    just walk around.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕移动的方式当然受到你拥有多少硬件的限制。另一个限制是你想要多大的受众群体。如果你设计你的VR应用程序为房间规模（自然四处走动），你就排除了每个手机用户。然而，同样地，如果你决定使用凝视瞬移系统，那些拥有房间规模VR的人会感到沮丧，因为他们不能四处走动。
- en: 'WebVR is currently more aimed at mobile VR, with room scale being a large programming
    challenge. It is possible, but is not built in ''out of the box'' with React-VR,
    and for that matter WebVR. Looking from the point of view of hardware is available:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: WebVR目前更多地针对移动VR，房间规模是一个很大的编程挑战。这是可能的，但在React-VR和WebVR中并没有内置。从硬件可用性的角度来看：
- en: '**No equipment** (Google Cardboard):'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需设备（Google Cardboard）：
- en: Natural locomotion (pan/tilt)–small amounts only
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然运动（平移/倾斜）- 仅限少量
- en: Gaze detection
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凝视检测
- en: Artificial movement ('rails' movement, like you are on a rail) either by timer
    or gaze detection
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定时器或凝视检测的人工运动（'轨道'运动，就像你在轨道上）
- en: '**VR Headset with controller** (Gear VR, Daydream, others):'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带控制器的VR头盔（Gear VR，Daydream等）：
- en: 'Now we have better ways, but can still do all the previous ways:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有更好的方法，但仍然可以做所有以前的方法：
- en: Natural locomotion (pan/tilt) - small amounts only
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然运动（平移/倾斜）- 仅限少量
- en: Gaze detection
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凝视检测
- en: Artificial movement ('rails' movement, like you are on a rail) either by timer
    or gaze detection
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定时器或凝视检测的人工运动（'轨道'运动，就像你在轨道上）
- en: Cockpit locomotion
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶舱运动
- en: Teleport via controller
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过控制器进行瞬间移动
- en: Joystick/controller
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵杆/控制器
- en: '**PC VR–Vive/Rift**:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PC VR–Vive/Rift：
- en: 'Now we have better ways, but can still do all the previous ways:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有更好的方法，但仍然可以做所有以前的方法：
- en: Natural locomotion (pan/tilt)–small amounts only
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然运动（平移/倾斜）- 仅限少量
- en: Gaze detection
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凝视检测
- en: Artificial movement ('rails' movement, like you are on a rail) either by timer
    or gaze detection
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定时器或凝视检测的人工运动（'轨道'运动，就像你在轨道上）
- en: Cockpit locomotion
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶舱运动
- en: Teleport via controller
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过控制器进行瞬间移动
- en: Joystick/controller (on the tracked 6DOF controllers)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵杆/控制器（在被跟踪的6DOF控制器上）
- en: Tracked 6DOF controller movement paradigms
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被跟踪的6DOF控制器运动范式
- en: Room scale walking
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间规模行走
- en: '**High-end equipment**:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高端设备：
- en: Omni virtual treadmill or other treadmill
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全景虚拟跑步机或其他跑步机
- en: Avoiding the ghost effect
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免幽灵效应
- en: There is another reason why we want people to be able to move around without
    some type of user agency; without movement, it really isn't Virtual Reality. In
    reality, we all move around; cats move their heads sideways when stalking. If
    you're intrigued or curious, you tilt your head. With 360 video, one of the challenges
    is that you can only look around; you can't move. Tilting your head really does
    nothing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个原因，为什么我们希望人们能够在没有某种用户代理的情况下四处移动；没有移动，它真的不是虚拟现实。实际上，我们都在四处移动；猫在潜行时会侧着头。如果你感到好奇，你会歪着头。在360度视频中，一个挑战是你只能四处看看；你不能移动。歪着头真的没什么用。
- en: What happens with 360 video, as detailed as it can be, is that you feel like
    a disembodied ghost. You can't look down and see yourself (you might see the camera
    rig though), you can't move around, you can't reach out and touch something, and
    you can't move your point of view. If you tilt your head, or  move side-to-side,
    there is no parallax effect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 360度视频会发生什么，尽管它可能非常详细，但你会感觉自己像一个游荡的幽灵。你不能往下看到自己（尽管你可能会看到摄像机支架），你不能四处移动，也不能伸手触摸东西，也不能改变你的视角。如果你歪着头，或者左右移动，就没有视差效果。
- en: I really like 360 video, but I also feel that it isn't really VR, as ultimately
    you feel disembodied, essentially a chained ghost. Sure, the video might move,
    but you can't change how it moves; you're just along for the ride.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢360度视频，但我也觉得它并不真正是虚拟现实，因为最终你会感到游离，本质上是一个被束缚的幽灵。当然，视频可能会移动，但你无法改变它的移动方式；你只是随波逐流。
- en: One of the subtle things I was very impressed with WebVR is that if you tilt
    your head, the VR view does shift slightly, as if you are moving your head to
    the side. It's a subtle effect; it isn't room scale VR, where you can just walk
    around, but it is a type of VR. You don't feel like a disembodied ghost.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我对WebVR非常印象深刻的一个微妙之处是，如果你歪着头，VR视图会稍微移动，就好像你在侧头。这是一个微妙的效果；它不是室内尺度的VR，你不能四处走动，但它是一种VR。你不会感觉自己像一个游荡的幽灵。
- en: Allowing people to explore their environment is important; without that, you
    really do feel like a ghost. For our example, we will use a teleport movement
    metaphor and allow people to explore a maze.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让人们探索他们的环境是很重要的；没有这一点，你真的会感觉自己像一个幽灵。在我们的例子中，我们将使用传送移动的隐喻，让人们探索一个迷宫。
- en: Without the ability to interact with the world and move around, you feel like
    a disembodied ghost. Although it's taken us nearly the entire book to get to this
    point, the ability to interact with your environment and world is one of the most
    important things in VR.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 没有与世界互动和移动的能力，你会感觉自己像一个游荡的幽灵。虽然我们几乎用了整本书的篇幅才达到这一点，但与环境和世界互动的能力是虚拟现实中最重要的事情之一。
- en: You will be able to do that in this chapter with any WebVR client. If we knew
    everyone had an HTC Vive or a room scale Oculus Rift, we could show you code to
    walk around the maze, although this brings up some interesting UI issues — what
    if someone walks through a hedge? Until we get full haptic head to toe suits,
    you can walk through a virtual wall. There are ways of using the user interface
    to counteract this, such as fading the screen to black briefly and then teleporting
    the user back to the start, just allowing them to cheat (not good), or other interesting
    ways around this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将能够使用任何WebVR客户端来做到这一点。如果我们知道每个人都有HTC Vive或室内尺度的Oculus Rift，我们可以向你展示在迷宫中四处走动的代码，尽管这会带来一些有趣的用户界面问题——如果有人走过篱笆会怎么样？在我们获得全身触觉套装之前，你可以穿过虚拟墙。有一些使用用户界面来抵消这一点的方法，比如将屏幕短暂地变黑，然后将用户传送回起点，只是允许他们作弊（不好），或者其他有趣的方法来解决这个问题。
- en: For now, we will simply allow the user to move to the next cell/open spot in
    the maze, and  to that location only. We will use gaze selection, meaning that
    when you stare at a UI element, we'd know you've *clicked* on it. This will work
    with all VR devices on the market, and this really is the best place to start
    at. More sophisticated UI elements would need to check to see what kind of VR
    controllers and tracking the user has and enable the proper movement as appropriate.
    This is a little beyond the scope of this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简单地允许用户移动到迷宫中的下一个单元格/开放位置，并且仅限于该位置。我们将使用凝视选择，这意味着当您盯着一个UI元素时，我们会知道您已经*点击*它。这将适用于市场上所有的VR设备，这真的是开始的最佳地点。更复杂的UI元素需要检查用户拥有的VR控制器和跟踪类型，并根据需要启用适当的移动。这超出了本书的范围。
- en: Before we discuss how to move in our world, we will need something interesting
    to move around in. For example, perhaps we were strolling through the forest and
    found our way blocked by a maze or it is early morning and we wanted to get to
    a small lake and see the early morning fog.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何在我们的世界中移动之前，我们需要有一些有趣的东西可以四处走动。例如，也许我们在森林中漫步，发现迷宫挡住了我们的去路，或者是清晨，我们想去一个小湖看清晨的雾。
- en: Let's build that maze.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来建造那个迷宫。
- en: Building a maze
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造迷宫
- en: There are a few ways we could build a maze. The most straightforward way would
    be to fire up our 3D modeler package (say, Blender) and create a labyrinth out
    of polygons. This would work fine and could be very detailed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以建造迷宫的几种方式。最直接的方法是启动我们的3D建模软件（比如Blender）并用多边形创建一个迷宫。这样做效果很好，也可以非常详细。
- en: However, it would also be very boring. Why? The first time we get through the
    maze will be exciting, but after a few tries, you'll know the way through. When
    we construct VR experiences, you usually want people to visit often and have a
    fun time every time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也会很无聊。为什么？第一次通过迷宫会很激动，但几次尝试之后，你会知道通往目的地的路。当我们构建VR体验时，通常希望人们经常访问并每次都有愉快的时光。
- en: A modeled labyrinth would be boring. Life is too short to do boring things.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 建模的迷宫会很无聊。生命太短暂，没有时间做无聊的事情。
- en: 'So, we want to generate a `Maze` randomly. This way, you can change the `Maze`
    every time so that it''ll be fresh and different. The way to do that is through
    random numbers to ensure that the `Maze` doesn''t shift around us, so we want
    to actually do it with pseudo-random numbers. To start doing that, we''ll need
    a basic application created. Please go to your VR directory and create an application
    called ''WalkInAMaze'':'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望随机生成一个“迷宫”。这样，您可以每次都改变“迷宫”，使其保持新鲜和不同。为了做到这一点，我们需要通过随机数来确保“迷宫”不会围绕我们移动，所以我们实际上希望用伪随机数来实现。要开始做到这一点，我们需要创建一个基本的应用程序。请转到您的VR目录并创建一个名为“WalkInAMaze”的应用程序：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Almost random–pseudo random number generators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几乎随机-伪随机数生成器
- en: To have a chance of replaying value or being able to compare scores between
    people, we really need a pseudo–random number generator. The basic JavaScript
    `Math.random()` is not a pseudo–random generator; it really gives you a totally
    random number every time. We need a pseudo–random number generator that takes
    a seed value. If you give the same seed to the random number generator, it will
    generate the same sequence of random numbers. (They aren't completely random,
    but are very close.) Random number generators are a complex topic; for example,
    they are used in cryptography, and if your random number generator isn't completely
    random, someone could break your code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有机会重播价值或能够比较不同人之间的分数，我们真的需要一个伪随机数生成器。基本的JavaScript `Math.random()`不是伪随机生成器；它每次都会给你一个完全随机的数字。我们需要一个带有种子值的伪随机数生成器。如果你给随机数生成器相同的种子，它将生成相同的随机数序列。（它们并不是完全随机的，但非常接近。）随机数生成器是一个复杂的话题；例如，它们被用于密码学，如果你的随机数生成器不是完全随机的，有人可能会破解你的代码。
- en: We aren't so worried about that, we just want repeatability. Although the UI
    for this may be a bit beyond the scope of this book, creating the `Maze` in a
    way that clicking on *Refresh* won't generate a totally different `Maze` is really
    a good thing and will avoid frustration on the part of the user. This will also
    allow two users to compare scores; we could persist a *board number* for the `Maze`
    and show this. This may be out of scope for our book; however, having a predictable
    `Maze` will help immensely during development. If it wasn't for this, you might
    get lost while working on your world. (Well, probably not, but it makes testing
    easier.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不太担心这一点，我们只是想要可重复性。尽管这方面的用户界面可能超出了本书的范围，但以一种点击*刷新*不会生成完全不同的`Maze`的方式创建`Maze`真的是一件好事，会避免用户的沮丧。这也将允许两个用户比较分数；我们可以为`Maze`持续一个*板号*，并显示这个。这可能超出了我们书的范围；然而，拥有可预测的`Maze`在开发过程中将会极大地帮助。如果没有这一点，你可能会在工作中迷失方向。（好吧，可能不会，但这样测试会更容易。）
- en: Including library code from other projects
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含来自其他项目的库代码
- en: Up to this point, I've shown you how to create components in React VR (or React).
    JavaScript interestingly has a historical issue with `include`. With C++, Java,
    or C#, you can `include` a file in another file or make a reference to a file
    in a project. After doing that, everything in those other files, such as functions,
    classes, and global properties (variables), are then usable from the file that
    you've issued the include statement in.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向你展示了如何在React VR（或React）中创建组件。有趣的是，JavaScript在`include`方面有一个历史问题。在C++、Java或C#中，你可以在另一个文件中`include`一个文件或在项目中引用一个文件。在那之后，那些其他文件中的所有内容，比如函数、类和全局属性（变量），都可以从发出`include`语句的文件中使用。
- en: 'With a browser, the concept of "including" JavaScript is a little different.
    With Node.js, we use `package.json` to indicate what packages we need. To bring
    those packages into our code, we will use the following syntax in your .js files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，“包含”JavaScript的概念有点不同。在Node.js中，我们使用`package.json`来指示我们需要哪些包。要将这些包引入我们的代码中，我们将在.js文件中使用以下语法：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, instead of using `Math.random()`, we will create a new random number
    generator and pass a seed, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的随机数生成器并传递一个种子，而不是使用`Math.random()`。
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From this point on, you just call `rng.random()` instead of `Math.random()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你只需要调用`rng.random()`而不是`Math.random()`。
- en: 'For now, we can just use `npm install <package>` and the `require` statement
    for properly formatted packages. In the next chapter, we''ll discuss upgrades
    and modify `package.json` to make sure that the code ships and updates properly.
    Much of this can be done for you by executing the `npm` command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需使用 `npm install <package>` 和 `require` 语句来正确格式化包。在下一章中，我们将讨论升级并修改 `package.json`，以确保代码正确地发布和更新。执行
    `npm` 命令可以为您完成其中的大部分工作：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remember, the --save command to update our manifest in the project. While we
    are at it, we can install another package we''ll need later:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，--save 命令用于更新项目中的清单。在此期间，我们还可以安装另一个以后会用到的包：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have a good random number generator, let's use it to complicate
    our world.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个很好的随机数生成器，让我们用它来复杂化我们的世界。
- en: The Maze render()
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迷宫渲染()
- en: How do we build a `Maze`? I wanted to develop some code that dynamically generates
    the `Maze`; anyone could model it in a package, but a VR world should be living.
    Having code that can dynamically build `Maze` in any size (to a point) will allow
    a repeat playing of your world.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何构建一个 `Maze`？我想开发一些动态生成 `Maze` 的代码；任何人都可以在一个包中对其进行建模，但VR世界应该是活生生的。拥有能够动态构建
    `Maze` 的代码（在一定程度上）将允许您重复玩您的世界。
- en: There are a number of JavaScript packages out there for printing mazes. I took
    one that seemed to be everywhere, in the public domain, on GitHub and modified
    it for HTML. This app consists of two parts: `Maze.html` and `makeMaze.JS`. Neither
    is React, but it is JavaScript. It works fairly well, although the numbers don't
    really represent exactly how wide it is.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于打印迷宫的JavaScript包。我选择了一个似乎无处不在的、公共领域的GitHub上的包，并对其进行了HTML修改。这个应用程序由两部分组成：`Maze.html`
    和 `makeMaze.JS`。它们都不是React，而是JavaScript。它运行得相当不错，尽管数字并不真正代表宽度。
- en: '![](Images/bd1de5fc-463e-4c9c-b084-6106bcadee46.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bd1de5fc-463e-4c9c-b084-6106bcadee46.png)'
- en: First, I made sure that only one `x` was displaying, both vertically and horizontally.
    This will not print well (lines are usually *taller* than *wide*), but we are
    building a virtually real `Maze`, not a paper `Maze`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我确保只有一个 `x` 在垂直和水平方向上显示。这样打印效果可能不好（行通常比列*高*），但我们正在构建一个虚拟的 `Maze`，而不是纸质的 `Maze`。
- en: 'The `Maze` that we generate with the files at `Maze.html` (`localhost:8081/vr/maze.html`)
    and the JavaScript file—`makeMaze.js`—will now look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Maze.html`（`localhost:8081/vr/maze.html`）和JavaScript文件 `makeMaze.js` 生成的
    `Maze` 现在看起来是这样的：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is a little hard to read, but you can count the squares vs. `x`s. Don't worry,
    it's going to look a lot fancier. Now that we have the HTML version of a `Maze`
    working, we'll start building the hedges.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以阅读，但你可以数一下方块和 `x` 的数量。别担心，它会看起来更加花哨。现在我们已经让HTML版本的 `Maze` 工作了，我们将开始建造树篱。
- en: This is a slightly larger piece of code than I expected, so I broke it into
    pieces and loaded the `Maze` object onto GitHub rather than pasting the entire
    code here, as it's long. You can find a link for the source at: [http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比我预期的要长一些，所以我把它分成了几部分，并将 `Maze` 对象加载到GitHub上，而不是在这里粘贴整个代码，因为它太长了。您可以在以下链接找到源代码：[http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)
- en: Adding the floors and type checking
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加地板和类型检查
- en: One of the things that look odd with a 360 Pano background, as we've talked
    about before, is that you can seem to "float" against the ground. One fix, other
    than fixing the original image, is to simply add a floor. This is what we did
    with the Space Gallery, and it looks pretty good as we were assuming we were floating
    in space anyway.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，360全景背景的一个奇怪之处是，你似乎可以“漂浮”在地面上。除了修复原始图像之外，另一个解决方法就是简单地添加一个地板。这就是我们在太空画廊中所做的，看起来相当不错，因为我们假设我们在太空中漂浮。
- en: For this version, let's `import` a ground square. We could use a large square
    that would encompass the entire `Maze`; we'd then have to resize it if the size
    of the `Maze` changes. I decided to use a smaller cube and alter it so that it's
    "underneath" every cell of the `Maze`. This would allow us some leeway in the
    future to rotate the squares for worn paths, water traps, or whatever.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个版本，让我们`import`一个地面方块。我们可以使用一个大方块来包含整个`Maze`；然后如果`Maze`的大小发生变化，我们就必须调整它的大小。我决定使用一个较小的立方体，并对其进行修改，使其“位于”`Maze`的每个单元格下方。这将使我们在将来有一些余地，可以旋转方块以制作磨损的路径、水陷阱或其他东西。
- en: 'To make the floor, we will use a simple cube object that I altered slightly
    and is UV mapped. I used Blender for this. We also `import` a `Hedge` model, and
    a `Gem`, which will represent where we can teleport to. Inside ''`Maze.js`'' we
    added the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作地板，我们将使用一个简单的立方体对象，我稍微修改了它，并进行了UV映射。我用Blender做的这个。我们还`import`了一个`Hedge`模型和一个`Gem`，它将代表我们可以传送到的地方。在`Maze.js`内部，我们添加了以下代码：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, inside the `Maze.js` we could instantiate our floor with the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Maze.js`内部，我们可以用以下代码实例化我们的地板：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that we don''t use ''`vr/components/Hedge.js`'' when we do the import;
    we''re inside Maze.js. However, in index.vr.js to include the Maze, we do need:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们进行导入时，我们不使用'`vr/components/Hedge.js`'；我们在Maze.js内部。然而，在index.vr.js中包含Maze时，我们确实需要：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s slightly more complicated though. In our code, the Maze builds the data
    structures when props have changed; when moving, if the maze needs rendering again,
    it simply loops through the data structure and builds a collection (mazeHedges)
    with all of the floors, teleport targets, and hedges in it. Given this, to create
    the floors, the line in `Maze.js` is actually:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况稍微复杂一些。在我们的代码中，当属性发生变化时，迷宫会构建数据结构；在移动时，如果迷宫需要重新渲染，它会简单地遍历数据结构并构建一个包含所有地板、传送目标和树篱的集合（mazeHedges）。鉴于此，要创建地板，在`Maze.js`中的代码实际上是：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here is where I ran into two big problems, and I'll show you what happened so
    that you can avoid these issues. Initially, I was bashing my head against the
    wall trying to figure out why my floors looked like hedges. This one is pretty
    easy—we imported `Floor` from the `Hedge.js` file. The floors will look like hedges
    (did you notice this in my preceding code? If so, I did this on purpose as a learning
    experience. Honest).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我遇到了两个大问题，我会告诉你发生了什么，这样你就可以避免这些问题。最初，我一直在试图弄清楚为什么我的地板看起来像树篱。这个问题很容易——我们从`Hedge.js`文件中导入了`Floor`。地板看起来像树篱（你在我的前面的代码中注意到了吗？如果是的话，我是故意这样做的，作为一个学习经验。诚实地说）。
- en: This is an easy fix. Make sure that you code `import Floor from './floor.js';` note
    that `Floor` not type-checked. (It is, after all, JavaScript.) I thought this
    was odd, as the `hedge.js` file exports a `Hedge` object, not a `Floor` object,
    but be aware you can rename the objects as you `import` them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复。确保你的代码中有`import Floor from './floor.js';`注意`Floor`没有经过类型检查。（毕竟，这是JavaScript。）我觉得这很奇怪，因为`hedge.js`文件导出了一个`Hedge`对象，而不是一个`Floor`对象，但请注意，你可以在`import`它们时重命名对象。
- en: 'The second problem I had was more of a simple goof that is easy to occur if
    you aren''t really thinking in React. You may run into this. JavaScript is a lovely
    language, but sometimes I miss a strongly typed language. Here is what I did:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的第二个问题更像是一个简单的失误，如果你没有真正思考React，很容易发生。你可能也会遇到这个问题。JavaScript是一种可爱的语言，但有时我会想念一种强类型的语言。这是我做的：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `maze.js` file, I had code like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`maze.js`文件中，我有这样的代码：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After some debugging, I found out that the value of `j` was going from `0` to
    `42`. Why did it get `42` instead of `6`? The reason was simple. We need to fully
    understand JavaScript to program complex apps. The mistake was in initializing
    SizeX to be `'4'` ; this makes it a string variable. When calculating `j` from
    `0` (an integer), React/JavaScript takes `2`, adds it to a string of `'4'`, and
    gets the `42` string, then converts it to an integer and assigns this to `j`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些调试，我发现`j`的值从`0`变成了`42`。为什么会变成`42`而不是`6`呢？原因很简单。我们需要充分理解JavaScript才能编写复杂的应用程序。错误在于将SizeX初始化为`'4'`；这使它成为一个字符串变量。当从`0`（一个整数）计算`j`时，React/JavaScript会取`2`，将其加到一个字符串`'4'`上，得到字符串`42`，然后将其转换为整数并赋给`j`。
- en: When this is done, very weird things happened.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样做时，非常奇怪的事情发生了。
- en: 'When we were building the Space Gallery, we could easily use the `''5.1''`
    values for the input to the box:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建Space Gallery时，我们可以轻松地使用`'5.1'`的值作为输入到框中：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, later use the transform statement below inside the class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在类中使用下面的转换语句：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: React/JavaScript will put in the string values into `This.Props.MyX`, then realize
    it needs an integer, and then quietly do the conversion. However, when you get
    more complicated objects, such as our `Maze` generation, you won't get away with
    this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: React/JavaScript会将字符串值放入`This.Props.MyX`，然后意识到它需要一个整数，然后悄悄地进行转换。然而，当你得到更复杂的对象，比如我们的`Maze`生成时，你就逃不过这一点。
- en: Remember that your code isn't "really" JavaScript. It's processed. At the heart,
    this processing is fairly simple, but the implications can be a killer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的代码并不是“真正”的JavaScript。它是经过处理的。在本质上，这种处理是相当简单的，但其影响可能是致命的。
- en: Pay attention to what you code. With a loosely typed language such as JavaScript,
    with React on top, any mistakes you make will be quietly converted to something
    you didn't intend.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你所编写的代码。在JavaScript这样的弱类型语言中，再加上React，你所犯的任何错误都会悄悄地转换成你意想不到的结果。
- en: You are the programmer. Program correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你是程序员。要正确编程。
- en: 'So, back to the `Maze`. The `Hedge` and `Floor` are straightforward copies
    of the initial `Gem` code. Let''s take a look at our starting `Gem`, although
    note it gets a lot more complicated later (and in your source files):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回到`Maze`。`Hedge`和`Floor`基本上是初始`Gem`代码的副本。让我们来看看我们的起始`Gem`，尽管请注意它后来变得更加复杂（以及在你的源文件中）：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Hedge` and `Floor` are essentially the same thing. (We could have made
    a prop be the file loaded, but we want a different behavior for the `Gem`, so
    we will edit this file extensively.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hedge`和`Floor`本质上是相同的东西。（我们本可以让一个prop成为加载的文件，但我们希望`Gem`有不同的行为，所以我们将大幅编辑这个文件。）'
- en: 'To run this sample, first, we should have created a directory as you have before,
    called `WalkInAMaze`. Once you do this, download the files from the Git source
    for this part of the chapter ([http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)).
    Once you''ve created the app, copied the files, and fired it up, (go to the `WalkInAMaze` directory and
    type `npm start`), and you should see something like this once you look around
    - except, there is a bug. This is what the maze should look like (if you use the
    file  ''`MazeHedges2DoubleSided.gltf`'' in `Hedge.js`, in the `<Model>` statement):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个示例，首先，我们应该像之前一样创建一个名为`WalkInAMaze`的目录。一旦你这样做了，从本章的Git源下载文件（[http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)）。一旦你创建了应用程序，复制了文件并启动了它（进入`WalkInAMaze`目录并输入`npm
    start`），你应该看到类似这样的东西一旦你四处看看——除了有一个bug。这就是迷宫应该看起来的样子（如果你在`Hedge.js`中使用文件`'MazeHedges2DoubleSided.gltf'`，在`<Model>`语句中）：
- en: '![](Images/11460f25-89c6-4293-b109-f9f57dcf91ef.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11460f25-89c6-4293-b109-f9f57dcf91ef.png)'
- en: Now, how did we get those neat-looking hedges in the game? (OK, they are pretty
    low poly, but it is still pushing it.) One of the nice things about the pace of
    improvement on web standards is their new features. Instead of just .obj file
    format, React VR now has the capability to load glTF files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是如何在游戏中得到那些看起来整洁的树篱的呢？（好吧，它们的多边形确实很低，但仍然可以。）Web标准改进的速度之一是它们的新功能。现在，React
    VR不仅支持.obj文件格式，还可以加载glTF文件。
- en: Using the glTF file format for models
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用glTF文件格式进行建模
- en: glTF files are a new file format that works pretty naturally with WebGL. There
    are exporters for many different CAD packages. The reason I like glTF files is
    that getting a proper export is fairly straightforward. Lightwave OBJ files are
    an industry standard, but in the case of React, not all of the options are imported.
    One major one is transparency. The OBJ file format allows that, but at of the
    time of writing this book, it wasn't an option. Many other graphics shaders that
    modern hardware can handle can't be described with the OBJ file format.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: glTF文件是一种新的文件格式，与WebGL非常自然地配合。有许多不同的CAD软件的导出器。我喜欢glTF文件的原因是，获得正确的导出相当简单。Lightwave
    OBJ文件是行业标准，但在React的情况下，并非所有选项都被导入。一个主要的问题是透明度。OBJ文件格式允许这样做，但在撰写本书时，这并不是一个选项。许多其他现代硬件可以处理的图形着色器无法用OBJ文件格式描述。
- en: This is why glTF files are the next best alternative for WebVR. It is a modern
    and evolving format, and work is being done to enhance the capabilities and make
    a fairly good match between what WebGL can display and what glTF can export.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么glTF文件是WebVR的下一个最佳选择。这是一种现代和不断发展的格式，正在努力增强功能，并在WebGL可以显示的内容和glTF可以导出的内容之间取得相当好的匹配。
- en: This is, however, a chapter on interacting with the world, so I'll give a brief
    mention on how to export glTF files and provide the objects, especially the `Hedge`,
    as glTF models.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一章关于与世界互动的内容，所以我会简要提及如何导出glTF文件并提供对象，特别是`Hedge`，作为glTF模型。
- en: 'The nice thing with glTF from the modeling side is that if you use their material
    specifications, for example, for Blender, then you don''t have to worry that the
    export won''t be quite right. Today''s **physically Based Rendering** (**PBR**)
    tends to use the metallic/roughness model, and these import better than trying
    to figure out how to convert PBR materials into the OBJ file''s specular lighting
    model. Here is the metallic-looking `Gem` that I''m using as the gaze point:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从建模方面来看，glTF的好处是，如果您使用它们的材质规范，例如Blender，那么您就不必担心导出不够准确。今天的**基于物理的渲染**（**PBR**）倾向于使用金属/粗糙模型，这些比尝试将PBR材质转换为OBJ文件的镜面光照模型更容易导入。这是我用作凝视点的看起来金属质的`Gem`：
- en: '![](Images/bedfa54d-f990-4ad9-a111-d03c08d7fd71.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bedfa54d-f990-4ad9-a111-d03c08d7fd71.png)'
- en: Using the glTF Metallic Roughness model, we can assign the texture maps that
    programs, such as Substance Designer, calculate and import easily. The resulting
    figures look metallic where they are supposed to be metallic and dull where the
    paint still holds on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用glTF金属粗糙模型，我们可以分配纹理贴图，例如Substance Designer等程序计算并轻松导入。结果看起来金属的地方看起来金属，油漆仍然保持的地方看起来暗淡。
- en: I didn't use Ambient Occlusion here, as this is a very convex model; something
    with more surface depressions would look fantastic with Ambient Occlusion. It
    would also look great with architectural models, for example, furniture.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里没有使用环境遮挡，因为这是一个非常凸起的模型；表面凹陷更多的东西会与环境遮挡搭配得很棒。例如，对于建筑模型和家具，也会看起来很棒。
- en: 'To convert your models, there is user documentation at [http://bit.ly/glTFExporting](http://bit.ly/glTFExporting).
    You will need to download and install the Blender glTF exporter. Or, you can just
    download the files I have already converted. If you do the export, in brief, you
    do the the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换您的模型，可以在[http://bit.ly/glTFExporting](http://bit.ly/glTFExporting)找到用户文档。您需要下载并安装Blender
    glTF导出器。或者，您可以直接下载我已经转换过的文件。如果您要进行导出，简而言之，您需要执行以下步骤：
- en: Download the files from [http://bit.ly/gLTFFiles](http://bit.ly/gLTFFiles). You
    will need the `gltf2_Principled.blend` file, assuming that you are on a newer
    version of Blender.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/gLTFFiles](http://bit.ly/gLTFFiles)下载文件。您将需要`gltf2_Principled.blend`文件，假设您使用的是Blender的较新版本。
- en: In Blender, open your file, then link to the new materials. Go to File->Link,
    then choose the `gltf2_Principled.blend` file. Once you do that, drill into "NodeTree"
    and choose either glTF Metallic Roughness (for metal), or glTF specular glossiness
    for other materials.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender中，打开您的文件，然后链接到新的材质。转到文件->链接，然后选择`gltf2_Principled.blend`文件。一旦您这样做了，进入“NodeTree”，然后选择glTF金属粗糙度（用于金属）或其他材质的glTF高光光泽。
- en: Choose the object you are going to export; make sure that you choose the Cycles
    renderer.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要导出的对象；确保选择Cycles渲染器。
- en: '![](Images/a01e8241-d327-4f09-9289-c9543e843d18.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a01e8241-d327-4f09-9289-c9543e843d18.png)'
- en: Open the Node Editor in a window (like you did for images in earlier chapters). Scroll
    down to the bottom of the Node Editor window, and make sure that the box Use Nodes is
    checked.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口中打开节点编辑器（就像您在之前的章节中处理图像时所做的那样）。向下滚动到节点编辑器窗口的底部，并确保“使用节点”框被选中。
- en: '![](Images/ebec695d-f40a-4540-baf3-86533b1921b9.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ebec695d-f40a-4540-baf3-86533b1921b9.png)'
- en: Add the node via the nodal menu, Add->Group->glTF Specular Glossiness or Metallic
    Roughness.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过节点菜单添加节点，添加->组->glTF高光光泽或金属粗糙度。
- en: Once the node is added, go to Add->Texture->Image texture. Add as many image
    textures as you have image maps, then wire them up. You should end up with something
    similar to this diagram.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加节点后，转到添加->纹理->图像纹理。添加与图像地图数量相同的图像纹理，然后将它们连接起来。您应该得到类似于这个图表的东西。
- en: '![](Images/ff400999-4004-4c90-9536-1fc01c17591d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ff400999-4004-4c90-9536-1fc01c17591d.png)'
- en: 'To export the models, I recommend that you disable camera export and combine
    the buffers, unless you think you will be exporting several models that share
    geometry or materials. The Export options I used are as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导出模型，我建议您禁用相机导出并合并缓冲区，除非您认为将要导出共享几何图形或材质的多个模型。我使用的导出选项如下：
- en: '![](Images/d64cf541-7053-4e14-acf3-0af94bf489c2.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: 现在，要包含导出的glTF对象，使用`<Model>`组件，就像使用OBJ文件一样，只是没有MTL文件。所有材质都在.glTF文件中描述。要包含导出的glTF对象，只需将文件名作为`<Model`中的gltf2属性：
- en: 'Now, to include the exported glTF object, use the `<Model>` component as you
    would with an OBJ file, except you have no MTL file. The materials are all described
    inside the .glTF file. To include the exported glTF object, you just put the filename
    as a gltf2 prop in the `<Model`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d64cf541-7053-4e14-acf3-0af94bf489c2.png)'
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To find out more about these options and processes, you can go to the glTF export
    web site at: [http://bit.ly/WebGLTF](http://bit.ly/WebGLTF). This site also includes
    tutorials on major CAD packages and the all important glTF shaders (for example,
    the Blender model I showed earlier).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些选项和流程的信息，您可以访问glTF导出网站：[http://bit.ly/WebGLTF](http://bit.ly/WebGLTF)。该网站还包括主要CAD软件的教程以及非常重要的glTF着色器（例如，我之前展示的Blender模型）。
- en: I have loaded several .OBJ files and .glTF files at [http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11) so
    you can experiment with different combinations of low poly and transparency. When
    glTF support was added in React VR version 2.0.0, I was very excited as transparency
    maps are very important for a lot of VR models, especially vegetation; just like
    our hedges. However, it turns out there is a bug in WebGL or three.js that does
    not render the transparency properly. As a result, I have gone with a low polygon
    version in the files on the GitHub site; the pictures, above, were with the file `MazeHedges2DoubleSided.gltf`
    in the `Hedges.js` file (in vr/components).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经加载了几个.OBJ文件和.glTF文件，您可以在[http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)上尝试不同的低多边形和透明度的组合。当在React
    VR版本2.0.0中添加了glTF支持时，我感到非常兴奋，因为透明度贴图对于许多VR模型非常重要，特别是植被；就像我们的树篱一样。然而，事实证明在WebGL或three.js中存在一个bug，无法正确渲染透明度。因此，我在GitHub网站上的文件中选择了低多边形版本；上面的图片是使用`Hedges.js`文件中的`MazeHedges2DoubleSided.gltf`文件（在vr/components中）。
- en: If you get 404 errors, check the paths in the glTF file. It depends on which
    exporter you use—if you are working with Blender, the gltf2 exporter from the
    Khronos group calculates the path correctly, but the one from Kupoman has options,
    and you could export the wrong paths.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到404错误，请检查glTF文件中的路径。这取决于您使用的导出器——如果您使用的是Blender，Khronos组的gltf2导出器会正确计算路径，但Kupoman的导出器有选项，您可能会导出错误的路径。
- en: Animation — VR Buttons
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画 — VR按钮
- en: 'OK! We want to animate something. To do that, we will use the VRButton. It
    activates when one of the following things occur:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们想要做一些动画。为了做到这一点，我们将使用VRButton。当发生以下情况之一时，它会激活：
- en: Button A on an XBox Gamepad
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XBox游戏手柄上的A按钮
- en: Space button on a keyboard
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘上的空格键
- en: Left click with a Mouse
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用鼠标左键单击
- en: Touch on a screen
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上的触摸
- en: Unfortunately, our "lowest common denominator" is a Google Cardboard, which
    may, or may not, have a button. You don't want to have to stick your finger inside
    and try to touch the screen. (After having said that, the newer VR headsets have
    a little lever arm that pokes the screen, even in the actual cardboard versions).
    What we will use is a *Gaze button*. When a mouse pointer or center of the screen
    (marked by a small dot) go over your object, events will be called, and our code
    will handle this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的“最低公共分母”是Google Cardboard，可能有，也可能没有按钮。您不想不得不把手指伸进去尝试触摸屏幕。（说了这些之后，更新的VR头盔有一个小杠杆可以戳屏幕，即使是在实际的硬纸板版本中）。我们将使用*凝视按钮*。当鼠标指针或屏幕中心（由一个小点标记）悬停在您的对象上时，事件将被调用，我们的代码将处理这个问题。
- en: 'The Gaze button is also packaged into a nice `<GazeButton>` object in the `npm`
    ecosystem. Please refer to the web page at: [http://bit.ly/GazeButton](http://bit.ly/GazeButton).
    To use it, we''ll need to understand what it does, and how we can let the View
    know that a `Gem` has been "touched" (or looked at for two seconds). We installed
    it earlier in the chapter; if you haven''t up to now, we install it by using Node.js
    command prompt and entering:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 凝视按钮也被打包成了`npm`生态系统中的一个漂亮的`<GazeButton>`对象。请参考网页：[http://bit.ly/GazeButton](http://bit.ly/GazeButton)。要使用它，我们需要了解它的功能，以及如何让视图知道一个`Gem`已经被“触摸”（或者被观察了两秒）。我们在本章的前面已经安装了它；如果你到目前为止还没有安装，我们可以通过使用Node.js命令提示符并输入以下命令来安装它：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We could use VR Button, but then we'd have to handle entering the object, leaving
    it, counting down, and so on. The `GazeButton` does all of this for us. Note that
    the way it expects children is a bit different to what we have been used to up
    to now.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用VR按钮，但那样我们就必须处理进入对象、离开对象、倒计时等等。`GazeButton`会为我们处理所有这些。请注意，它对子元素的期望方式与我们到目前为止所习惯的方式有些不同。
- en: 'Your `Gem.js` code (note the capital) should now be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的`Gem.js`代码（注意大写）应该如下所示：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when we try this on the desktop, it seems to work, but on a mobile phone
    (I tried it with Samsung GearVR), there is no cursor and nothing to click on.
    We need to implement a raycaster (even without controls).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在桌面上尝试这样做时，似乎可以工作，但在手机上（我尝试了三星GearVR），没有光标，也没有可以点击的东西。我们需要实现一个射线投射器（即使没有控制）。
- en: There are so many different kinds of VR control systems, as we discussed briefly
    at the start of the chapter, where the default is "no" VR input device, including
    a center of the screen cursor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头简要讨论的那样，有许多不同类型的VR控制系统，默认情况下是“没有”VR输入设备，包括屏幕中心光标。
- en: The implementation of a proper control system is in our hands.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的控制系统的实施在我们手中。
- en: When you are using a desktop browser to do your initial development, you get
    a mouse cursor (including a *hand* cursor when over a tracked component), which
    can imply a gaze cursor is built in; they aren't. Just be aware there is a valid
    reason for this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用桌面浏览器进行初始开发时，您会得到一个鼠标光标（包括在跟踪组件上时的*手*光标），这可能意味着内置了注视光标；实际上并没有。只需意识到这是有合理理由的。
- en: Raycasters
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射线投射器
- en: A **raycaster** shoots a ray out into the world and calculates what it touches.
    You usually see these as glowing lines from VR controllers. Without a controller,
    the raycaster will cast a ray from the center of the screen; this is exactly what
    we need to implement our Gaze button.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**射线投射器**向世界发射一条射线并计算它触及了什么。通常您会看到这些作为VR控制器发出的发光线。没有控制器时，射线投射器将从屏幕中心发射一条射线；这正是我们需要实现我们的注视按钮的地方。'
- en: 'In this case, as we did with the button, there is already a  `simple-raycaster`
    out there. If you haven''t yet, you need to install it from `npm` via the following
    command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，就像我们对按钮所做的那样，已经有一个“simple-raycaster”。如果您还没有安装它，您需要通过以下命令从“npm”安装它：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might want to skip the `--save` while experimenting with packages; if you
    do, remember to update your `package.json` file manually or via the appropriate
    tools.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用软件包时，您可能希望跳过“--save”; 如果您这样做，请记得手动更新您的“package.json”文件，或者通过适当的工具进行更新。
- en: 'Implementation of the `simple-raycaster` is pretty easy. In `client.js`, below
    the existing `import` line (VRInstance), add the following `import` statement:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 实现“simple-raycaster”非常容易。在“client.js”中，在现有的“import”行（VRInstance）下面，添加以下“import”语句：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Where it says `// Add custom options here`, insert the following lines:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在“//在此处添加自定义选项”处，插入以下行：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On your PC, things get a little strange at this point—the center of the screen
    will activate (and drop) the gems, even if you don't click. That's the entire
    point.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的PC上，此时情况会有点奇怪——屏幕中心会激活（并丢弃）宝石，即使您没有点击。这正是整个重点。
- en: If we had more pages, we would make the gems spin when your gaze enters them.
    For now, we will give this exercise up to the reader.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有更多的页面，当你的目光进入宝石时，我们会让宝石旋转。但现在，我们将把这个练习留给读者。
- en: You'll want to start an animation during the `onClick` handler.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您将希望在“onClick”处理程序中开始动画。
- en: So far, we've shown how to get events when a gem is gazed at. That's good, we
    can use the event to trigger a movement, but how do we move?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了当注视宝石时如何获得事件。这很好，我们可以使用事件来触发移动，但我们如何移动呢？
- en: One thing that is a little odd, is that React VR has no way to move the camera
    as many graphics systems do. To move the current point of view, you translate
    the `<View>` at the start of the `index.vr.js` to the opposite direction; this
    moves everything in the world the other way, which makes it look like you are
    moving forward. To move a point of view, we need to pass on the click event from
    the `Gem` to its parent's parent (the top level View).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件有点奇怪的事情是，React VR没有像许多图形系统那样移动摄像头的方法。要移动当前的视角，你需要在`index.vr.js`的开头将`<View>`向相反方向进行平移；这会使世界中的一切朝相反方向移动，看起来就像你在向前移动。要移动视角，我们需要将点击事件从`Gem`传递给其父级的父级（顶级View）。
- en: Props, state, and events
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props，state和events
- en: React, and thus React VR, at its core, handles props, events, and state in a
    predictable, deterministic manner and this is what makes React apps consistent,
    clean, and easy to maintain.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: React，以及React VR，在其核心，以可预测、确定的方式处理props、事件和状态，这就是使React应用程序保持一致、清晰且易于维护的原因。
- en: Props are created when an object is declared and should not change over the
    life of the object. If an object needs to change, for example, our teleport gems,
    then you should assign these values to `state`. This enforces a top-down, unidirectional
    data flow. If a component needs the same state in different areas, then that `state`
    should be lifted up to the highest parent.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象声明时创建props，并且在对象的生命周期内不应更改。如果对象需要更改，例如我们的传送门宝石，那么应将这些值分配给`state`。这强制实现了自顶向下的单向数据流。如果组件在不同区域需要相同的状态，那么该`state`应该被提升到最高级的父级。
- en: This causes interesting issues if you want a subcomponent to let a parent component
    know about an event or change its state based on an event at a lower level.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这会引发有趣的问题，如果你想让一个子组件告诉父组件有关事件的信息，或者根据较低级别的事件改变其状态。
- en: There are several ways of handling this; it can be a complicated subject in
    the React world. React VR doesn't differ from React Native or React in how state,
    props, and events are handled. A good place to start is the React Documentation,
    on *State and Lifecycle*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题有几种方法；在React世界中，这可能是一个复杂的主题。React VR在处理状态、props和事件方面与React Native或React没有区别。一个很好的起点是React文档中的*State
    and Lifecycle*。
- en: Essentially, in a React app, there should be a single source of truth for something
    that changes. If a parent doesn't care, for example, if a `Gem` is higher or lower
    (stepped on or not), then you do not need to have that parent keep track of its
    children's height. Keeping `state` at a level as low as possible is the right
    decision. The height can be calculated from "have we stepped on the `Gem`", and
    so shouldn't be a prop that is passed down. (You might consider a *starting height*,
    though, as a prop; good programming says not to hardcode values, even though in
    a lot of the book files, we have for brevity.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在React应用程序中，应该有一个用于变化的单一真相来源。如果父级不关心，例如`Gem`是更高还是更低（被踩或未被踩），那么你不需要让父级跟踪其子级的高度。将`state`保持在尽可能低的级别是正确的决定。高度可以从“我们是否踩了`Gem`”中计算出来，因此不应该是传递下来的prop。（尽管在很多书籍文件中，出于简洁起见，我们已经硬编码了值，但你可能会考虑*起始高度*作为一个prop；良好的编程规范说不要硬编码值。）
- en: With our maze world, we have a quandary. We move the point of view by changing
    the `<View>` node at the top of our world tree. Yet, as we click on each `<Gem>`,
    we want the view to change.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的迷宫世界中，我们遇到了一个困境。我们通过改变世界树顶部的`<View>`节点来移动视角。然而，当我们点击每个`<Gem>`时，我们希望视图发生变化。
- en: We could handle this with context; a number of libraries, such as Redux or MobX,
    use context under the covers. There are event libraries that use context and other
    abilities. Context, however, is a bit of an advanced concept and a bit of overkill
    for what we are doing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用上下文来处理这个问题；许多库，比如Redux或MobX，在内部使用上下文。还有一些使用上下文和其他功能的事件库。然而，上下文是一个有点高级的概念，对于我们正在做的事情来说有点过度。
- en: 'In this particular case, we will simply pass a `callback` function down the
    child tree. The reasons we will do this are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们将简单地将一个“回调”函数传递到子树中。我们这样做的原因如下：
- en: At this point, our app is fairly small from a hierarchy view, only three levels.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时，从层次结构的角度来看，我们的应用程序相当小，只有三个级别。
- en: The `Maze` itself may need to know when the user has gotten to the end (for
    example, to display fireworks or update a high score). The `Gem` doesn't know
    this. If the `Gem` sent the notification directly to the View, the `Maze` would
    never know.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “迷宫”本身可能需要知道用户何时到达终点（例如，显示烟花或更新高分）。“宝石”不知道这一点。如果“宝石”直接向视图发送通知，那么“迷宫”将永远不知道。
- en: We could bring in additional libraries, but this is a straightforward project,
    and too many external dependencies in an open source world can break things. This
    isn't a big problem usually, though—if something breaks, it's open source; go
    fix it.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引入额外的库，但这是一个简单的项目，在开源世界中太多外部依赖可能会导致问题。通常这不是一个大问题，如果出了问题，那就是开源的，去修复它。
- en: 'If, while looking for external packages, you do break things, you need to uninstall
    the offending package, then restart your Node.js server by running the following
    command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在寻找外部包时出现问题，你需要卸载有问题的包，然后通过运行以下命令重新启动你的Node.js服务器：
- en: '`npm start -- --reset-cache`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm start -- --reset-cache`'
- en: '`npm cache clean --force` does *not* do this cache reset. The error message
    you get should point this out if you forget.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm cache clean --force`不会执行此缓存重置。如果你忘记了，你得到的错误消息应该指出这一点。'
- en: Making updates flow up river
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使更新向上流动
- en: Although updates ripple down, we need to pass the information up. How do we
    do that? Easy, with a functional `callback`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管更新会传播下来，但我们需要传递信息。我们怎么做？很简单，用一个功能性的“回调”。
- en: 'In `index.vr.js`, create a couple of routines and do an all important binding
    of these routines to this—the `WalkInAMaze` component. I''m just showing the changed
    lines at this point:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.vr.js`中，创建一些例行程序，并将这些例行程序与`WalkInAMaze`组件进行重要的绑定。在这一点上，我只展示了更改的行：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside our `Gem.js`, we already have an `onClick` method. We just need to add
    a few new `props`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“Gem.js”中，我们已经有一个“onClick”方法。我们只需要添加一些新的“props”：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, what''s this `this.props.onClickGem`? This is a prop, which is a function,
    that is passed from the parent. Where we create the `Gem`, we just insert this
    following prop (the inserted line in bold—not that source code can be bold):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个`this.props.onClickGem`是什么？这是一个从父级传递的函数prop。在我们创建“宝石”时，我们只需插入以下prop（加粗的插入行，注意源代码不能加粗）：
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'OK, where do we get `this.handleClickGem`? In this (simple) case, the `Maze`
    won''t be doing anything with the event, just passing it through. In `Maze.js`,
    we will add a handler:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们从哪里得到“this.handleClickGem”？在这个（简单）情况下，“迷宫”不会对事件做任何处理，只是将其传递。在“Maze.js”中，我们将添加一个处理程序：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we note another prop here. This is, of course, passed to us by the maze''s
    parent; so, in `index.vr.js`, add the (bold) line:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们注意到这里还有另一个prop。这当然是由迷宫的父级传递给我们的；所以，在`index.vr.js`中，添加（加粗）这一行：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That''s pretty much it. What happens when the `Gem`''s VR Gaze button detects
    a click? It calls the prop, which is a function. This causes the maze''s `handleClickGem`
    to be called; it, in turn, calls `handleClickGem()` inside `index.vr.js`. This
    routine (pun intended) then sets internal state. This state causes the view to
    be re-rendered:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上就是这样。当`Gem`的VR注视按钮检测到点击时会发生什么？它调用了一个函数作为prop。这会导致迷宫的`handleClickGem`被调用；它反过来调用了`index.vr.js`中的`handleClickGem()`。这个例程（双关语）然后设置内部状态。这个状态导致视图重新渲染：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's all it takes. Note that you don't just set the `state` with `this.startX
    = -X`, you need to call `this.setState()` as shown in the preceding code. This
    routine will then handle the rippling down of the `render()` updates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。请注意，你不仅仅通过`this.startX = -X`来设置`state`，你需要像前面的代码中所示调用`this.setState()`。然后这个例程将处理`render()`更新的传递。
- en: These are big files, and we just made a lot of changes. I called out important
    lines in the above, but I highly recommend you download the source files from [http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)
    and take a look at what we have done. In it, I've built a 4x4 maze that should
    have reasonable frame rate on most PC's and mobile devices. You can experiment
    with some other versions of the various objects (hedges that look like hedges
    or low poly hedges).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是大文件，我们刚刚做了很多改变。我在上面标出了重要的行，但我强烈建议你从[http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)下载源文件并看看我们做了什么。在其中，我建立了一个4x4的迷宫，应该在大多数PC和移动设备上有合理的帧率。你可以尝试一些其他版本的各种对象（看起来像树篱或低多边形树篱）。
- en: Where to go from here?
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来怎么办？
- en: 'This is a pretty basic game, but there is a lot you could do with it. Some
    things we''ve discussed before, that would be easy to include, are the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当基础的游戏，但你可以做很多事情。我们之前讨论过的一些东西，很容易包括在内，比如：
- en: Our teleporting is a bit abrupt. We should have a sound, or even do two updates
    (by changing the `HandleClickGem()` routine) to either add a brief animation or
    a two-step teleport. Note that it is generally not a good idea to smoothly animate
    the view itself; this makes people sick, as their eyes say they are moving but
    their body says not.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的传送有点突然。我们应该有声音，或者甚至通过改变`HandleClickGem()`例程进行两次更新，以添加一个简短的动画或两步传送。请注意，通常不建议平滑地动画化视图本身；这会让人们感到不适，因为他们的眼睛说他们在移动，但他们的身体说没有。
- en: The number of gems clicked on could become a score. This gives us an advantage
    to go slower, step by step and click on all the gems.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击的宝石数量可以成为得分。这使我们有优势可以慢慢前进，一步一步地点击所有的宝石。
- en: You could time how long it takes to get to the exit, and lower numbers could
    increase your score. This gives an advantage to go faster and skip the teleport
    gems. The two goals here are exclusive, which, with balancing, can make it fun.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以计时到达出口所需的时间，较短的时间可以增加你的得分。这使得快速前进并跳过传送宝石有优势。这两个目标是互斥的，通过平衡可以使游戏变得有趣。
- en: You could include buttons at the front of the maze to increase/decrease the
    size or generate different random numbers (and display them).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在迷宫前面加入按钮来增加/减少大小或生成不同的随机数（并显示它们）。
- en: The scores and the random numbers could be loaded into a high score API.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分和随机数可以加载到高分API中。
- en: Event passing libraries, such as `eventing-bus`, make the passing of `props`
    a lot easier. My goal was to show you the React VR way of doing it.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件传递库，比如`eventing-bus`，使传递`props`变得更容易。我的目标是向你展示React VR的做法。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the final pieces to build complete apps and games
    on the web; coupled with what we learned earlier, our journey is nearly complete;
    this is really just the first step toward bringing reality to the web. The topics
    we covered included how to move in a VR world, including basic teleport mechanics.
    We discussed Gaze buttons and using ray casting to implement them. We discussed
    the important mechanics of `props`, `state`, and events. To implement these flows,
    we went over the important React philosophy of pushing `state` up and handling
    events down stream. We also discussed using pseudo random number generators to
    make sure that our `props` and `state` didn't change chaotically. All together,
    we now know how to create, move around in, and make worlds react to us.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了构建完整的网络应用程序和游戏的最后一部分；再加上我们之前学到的知识，我们的旅程几乎已经完成；这实际上只是将现实带到网络的第一步。我们讨论了如何在VR世界中移动，包括基本的传送机制。我们讨论了凝视按钮和使用射线投射来实现它们。我们讨论了`props`，`state`和事件的重要机制。为了实现这些流程，我们复习了重要的React哲学，即将`state`向上传递并处理下游事件。我们还讨论了使用伪随机数生成器来确保我们的`props`和`state`不会发生混乱性变化。总的来说，我们现在知道如何创建、在其中移动，并使世界对我们做出反应。
- en: In the next chapter, we'll discuss where to go from here, how to upgrade React
    VR, and how to publish your virtual worlds on the internet.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论接下来该怎么做，如何升级React VR，以及如何在互联网上发布你的虚拟世界。
