- en: Easy Backend Setup With Firebase
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase轻松设置后端
- en: Our application looks pretty, but it doesn't do that much. We have a login form
    that doesn't let users actually log in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序看起来很漂亮，但它并没有做太多事情。我们有一个登录表单，但用户实际上无法登录。
- en: 'In this chapter, we''ll get started on the backend of our application. In our
    case, that means setting up a database to save users and their messages. In one
    chapter, we will cover everything we need to let our users create accounts and
    log in. We''ll also dive deeper into React and component state. We''ll learn the
    following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始处理我们应用程序的后端。在我们的情况下，这意味着设置一个数据库来保存用户及其消息。在一个章节中，我们将涵盖让用户创建帐户和登录所需的一切。我们还将深入研究React和组件状态。我们将学到以下内容：
- en: What Firebase is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase是什么
- en: Gotchas and problems to look out for
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要注意的问题和问题
- en: How to deploy our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何部署我们的应用程序
- en: User authentication (signup and login)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户认证（注册和登录）
- en: React life cycle methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React生命周期方法
- en: Let's get to it!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: What is Firebase?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase是什么？
- en: Building a progressive web app is, for the most part, a frontend process. PWAs
    care little for how they consume data from a backend API (unless it impedes performance,
    of course). We want to keep the backend setup for our application minimal; for
    that, we turn to Firebase.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构建渐进式Web应用程序在很大程度上是一个前端过程。PWA对于它们如何从后端API获取数据并不太关心（除非它影响性能，当然）。我们希望保持我们应用程序的后端设置最小化；为此，我们转向Firebase。
- en: '**Firebase** is a project by Google designed to help developers build apps
    without worrying about backend infrastructure. It operates on the freemium model,
    based on the amount of requests your backend has to respond to as well as the
    amount of storage you need. For our purposes, it is the perfect fit for quickly
    developing a small prototype. When our app scales, the Chatastrophe executive
    board assures us, "money won''t be an issue."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firebase**是Google设计的一个项目，旨在帮助开发人员构建应用程序，而不必担心后端基础设施。它采用免费模型，基于后端需要响应的请求数量以及您需要的存储量。对于我们的目的，它非常适合快速开发一个小型原型。当我们的应用扩展时，Chatastrophe的执行委员会向我们保证，“金钱不是问题”。'
- en: What does Firebase provide? Of interest to us is a database, a hosting solution,
    and built-in authentication. Beyond that, it also offers something called **Cloud
    Functions**, which are snippets of code automatically run in response to certain
    events. We'll be working with Cloud Functions once we add push notifications to
    our application. For now, we want to add some authentication to our login form
    so that users can sign up and log in to Chatastrophe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase提供了什么？我们感兴趣的是数据库、托管解决方案和内置认证。除此之外，它还提供了一种称为**Cloud Functions**的东西，这是一些代码片段，会在特定事件的响应中自动运行。一旦我们为我们的应用程序添加推送通知，我们将使用Cloud
    Functions。现在，我们想要在我们的登录表单中添加一些身份验证，以便用户可以注册并登录到Chatastrophe。
- en: If you have a Google account (via Google Plus or Gmail, for example) you can
    log in to Firebase with those credentials, or create a new account; that's all
    we need to get started.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有Google帐户（例如通过Google Plus或Gmail），您可以使用这些凭据登录Firebase，或者创建一个新帐户；这就是我们开始所需要的一切。
- en: Firebase gotchas
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase注意事项
- en: Firebase is a useful tool, but it does have some caveats.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一个有用的工具，但它确实有一些注意事项。
- en: One of the big selling points (for us especially) is its real-time database.
    This means that changes to the data by one user are automatically pushed to all
    users. We don't have to check whether a new chat message has been created; each
    instance of the application will be instantly informed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个重要的卖点（尤其是对我们来说）是它的实时数据库。这意味着一个用户对数据的更改会自动推送给所有用户。我们不必检查是否已创建了新的聊天消息；应用程序的每个实例都将立即收到通知。
- en: The database also has offline persistence, which means our users can read their
    messages even when they're offline (which, if you remember, fulfills one of the
    user stories we outlined earlier). Firebase uses local caching to achieve this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库还具有离线持久性，这意味着我们的用户甚至在离线时也可以阅读他们的消息（如果您记得的话，这满足了我们之前概述的用户故事之一）。Firebase使用本地缓存来实现这一点。
- en: So, what's the downside? The Firebase database is a NoSQL database, and has
    a specific syntax that may seem strange to developers more used to SQL databases.
    The process is similar to a SQL database (with the major **CRUD** actions--**Create**,
    **Read**, **Update**, and **Delete**-- applying to data), but it may not be as
    intuitive.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有什么缺点吗？Firebase数据库是一个NoSQL数据库，具有特定的语法，对于更习惯于SQL数据库的开发人员可能会感到奇怪。该过程类似于SQL数据库（具有主要的**CRUD**操作--**创建**，**读取**，**更新**和**删除**--适用于数据），但可能不太直观。
- en: The other gotcha with Firebase is that it is not (at the time of writing) optimized
    for **Single-Page Applications** (**SPAs**) like those built with React. We'll
    have to do a couple of workarounds to get everything running smoothly with our
    React application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase的另一个要点是，它（在撰写本文时）并未针对像React这样构建的**单页应用程序**（**SPAs**）进行优化。我们将不得不做一些变通方法，以使一切在我们的React应用程序中顺利运行。
- en: All that said, however, Firebase will save us a lot of time in comparison to
    setting up our own backend server/hosting solution, and it's a pleasure to use
    for personal projects; this is definitely something worth learning.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Firebase将节省我们大量时间，与设置我们自己的后端服务器/托管解决方案相比，这绝对是值得学习的。
- en: Setting up
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Here''s how we''ll get going with Firebase:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何开始使用Firebase：
- en: We'll go to the Firebase console.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将转到Firebase控制台。
- en: From there, we'll create a project.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，我们将创建一个项目。
- en: We'll name our lovely little project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们可爱的小项目命名。
- en: We'll get the code necessary to integrate it into our app.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获得将其集成到我们的应用程序中所需的代码。
- en: We'll add that code to `index.html`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将将该代码添加到`index.html`中。
- en: We'll make Firebase available as a global variable.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使Firebase作为全局变量可用。
- en: 'If you''re ready to get started, let''s do it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您准备好开始，请这样做：
- en: 'Once you''ve created or logged in to your Google account, head over to [https://firebase.google.com/](https://firebase.google.com/).
    In the top-right corner of your screen, you should see a button titled GO TO CONSOLE:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您创建或登录到您的Google帐户，转到[https://firebase.google.com/](https://firebase.google.com/)。在屏幕右上角，您应该看到一个名为GO
    TO CONSOLE的按钮：
- en: '![](../images/00027.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'From the Firebase console, we want to Add Project. Click on the icon:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Firebase控制台，我们想要添加项目。点击图标：
- en: '![](../images/00028.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: For Project Name, choose `chatastrophe` (all lowercase), and then select your
    Country/Region.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于项目名称，选择`chatastrophe`（全部小写），然后选择您的国家/地区。
- en: 'Firebase should take you directly to the project page once that''s done. From
    there, click on the link that says Add Firebase to your web app:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，Firebase应该直接带您到项目页面。从那里，点击上面写着Add Firebase to your web app的链接：
- en: '![](../images/00029.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'Copy and paste the code it gives you into your `public/index.html`, before
    the closing `</body>` tag:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴它给您的代码到`public/index.html`中，在闭合的`</body>`标签之前：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Lastly, we need to make our Firebase application available to the rest of our
    app. At the bottom of the script tag, just before the `firebase.initializeApp(config)`
    line, add the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使我们的Firebase应用程序对我们的应用程序的其余部分可用。在脚本标签的底部，在`firebase.initializeApp(config)`行之前，添加以下内容：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code stores our Firebase setup on the `window` object, so we can access
    it in the rest of our JavaScript.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将我们的Firebase设置存储在`window`对象上，这样我们就可以在JavaScript的其余部分中访问它。
- en: If you're not using source control (GitHub or Bitbucket, for example) or are
    using a private repository to store your code, you can skip to the next section.
    For the rest of us, we need to do some work to ensure that we don't display our
    `config.apiKey` to the entire world (a recipe for malicious use).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用源代码控制（例如GitHub或Bitbucket），或者正在使用私有存储库来存储您的代码，您可以跳过到下一节。对于我们其他人，我们需要做一些工作，以确保我们不会向整个世界显示我们的`config.apiKey`（这是一种恶意使用的方法）。
- en: Hiding our API key
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏我们的API密钥
- en: 'We need to move our API key and `messagingSenderId` to a separate file, and
    then ensure that the file is not checked into Git:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的API密钥和`messagingSenderId`移动到一个单独的文件中，然后确保该文件没有被检入Git：
- en: 'To do so, create a file in `public/` called `secrets.js`. In that file, place
    the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，在`public/`中创建一个名为`secrets.js`的文件。在该文件中，放入以下内容：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, we're taking advantage of the globally accessible window object to store
    the key. For those of you new to JavaScript, note that it is not good practice
    to abuse the window object; only use it when absolutely necessary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们利用全局访问的window对象来存储密钥。对于那些对JavaScript新手来说，请注意滥用window对象并不是一个好的做法；只有在绝对必要时才使用它。
- en: 'To use this key in `index.html`, we can add the following above all the other
    script tags:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在`index.html`中使用此密钥，我们可以在所有其他脚本标签之前添加以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, in our Firebase initialization:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的Firebase初始化中：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As the last step, we need to tell Git to ignore the `secrets.js` file. You
    can do so by modifying our `.gitignore` file in the project base, adding the following
    line:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要告诉Git忽略`secrets.js`文件。您可以通过修改我们项目基础中的`.gitignore`文件来实现这一点，添加以下行：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All done! We can now commit and push up freely.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定了！我们现在可以自由地提交和推送了。
- en: Deploying Firebase
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Firebase
- en: 'As I mentioned earlier, Firebase comes with a baked-in deployment solution.
    Let''s get our app up and working on the real live web! Here''s how to do it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，Firebase自带了一个内置的部署解决方案。让我们在真实的网络上让我们的应用程序运行起来！以下是如何做到这一点：
- en: 'To do so, we''ll first need to install the Firebase command-line tools:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们首先需要安装Firebase命令行工具：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don’t forget the `-g`. This flag installs the tools globally on your machine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`-g`。这个标志会在您的机器上全局安装这些工具。
- en: 'The next step is to log in to our Firebase tools:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是登录我们的Firebase工具：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To complete our Firebase tools setup, we can now initialize our app as a Firebase
    project, similar to what we did with `npm`. Ensure that you run this from the
    root of the project folder:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的Firebase工具设置，我们现在可以将我们的应用初始化为一个Firebase项目，类似于我们使用`npm`所做的。确保您从项目文件夹的根目录运行此命令：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first question it then prompts you for, use the arrow keys and the *Spacebar*
    to select both Functions and Hosting. We will use Firebase's Cloud Functions later
    on. Don't select Database, that's for configuring database rules locally; we'll
    rely on the Firebase console instead.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在它随后提示您的第一个问题中，使用箭头键和*空格键*来选择Functions和Hosting。我们稍后将使用Firebase的Cloud Functions。不要选择Database，那是用于在本地配置数据库规则的；我们将依赖于Firebase控制台。
- en: 'Your selections should look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您的选择应该如下所示：
- en: '![](../images/00030.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: When it asks for a default Firebase project, select `chatastrophe`(or whatever
    you named this project in the Firebase console).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当它要求默认的Firebase项目时，请选择`chatastrophe`（或者您在Firebase控制台中命名的项目）。
- en: For the question Do you want to install dependencies with npm now?, enter y.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于问题“您是否要立即使用npm安装依赖项？”，输入y。
- en: Next, it'll ask you what folder you want to use as your public directory. Enter
    `build`, not `public`. Firebase is asking what folder to use to deploy your project;
    we want our final compiled build, including our transpiled JavaScript and therefore,
    we want the `build` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它会问你要使用哪个文件夹作为你的公共目录。输入`build`，而不是`public`。Firebase正在询问要使用哪个文件夹来部署你的项目；我们想要我们最终编译的构建，包括我们转译的JavaScript，因此，我们想要`build`文件夹。
- en: Let's move to the next question now! Do we want to configure our app as a single-page
    application? Heck yes. Decline overwriting `index.html` though (however, no worries
    if you say yes; we regenerate our `build/index.html` every time we run our `build`
    command).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到下一个问题！我们想将我们的应用程序配置为单页面应用程序吗？当然。尽管拒绝覆盖`index.html`（但是，如果你说是，也没关系；每次运行`build`命令时，我们都会重新生成我们的`build/index.html`）。
- en: Okay, we're all set up to deploy. Let's make an `npm` script to make our lives
    easier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备好部署了。让我们创建一个`npm`脚本，让我们的生活更轻松。
- en: 'Every time we deploy, we''ll want to rerun our `build` command to ensure that
    we have the freshest build of our project. Our `npm` script will thus combine
    both, added into our `package.json`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每次部署，我们都希望重新运行我们的`build`命令，以确保我们拥有项目的最新构建。因此，我们的`npm`脚本将结合这两者，添加到我们的`package.json`中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the script with `yarn deploy`, and then check out the URL it displays in
    the Terminal. If all goes well, your app should look exactly like it does in development.
    Open up the console and check for warnings; if you see any, skim the Webpack chapter
    and see whether you missed any of the settings for our `webpack.config.prod.js`
    (you can take a peek at the final file in the branch here: [https://github.com/scottdomes/chatastrophe/tree/chapter4](https://github.com/scottdomes/chatastrophe/tree/chapter4)):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`yarn deploy`运行脚本，然后在终端中检查它显示的URL。如果一切顺利，你的应用程序应该看起来和在开发中一样。打开控制台并检查警告；如果看到任何警告，浏览一下Webpack章节，看看是否错过了我们`webpack.config.prod.js`的一些设置（你可以在这里的最终文件中查看：[https://github.com/scottdomes/chatastrophe/tree/chapter4](https://github.com/scottdomes/chatastrophe/tree/chapter4)）：
- en: '![](../images/00031.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: Awesome! We have a deployed app ready to share with our friends. The only problem
    is what we discussed at the end of the last chapter; it doesn't actually do much
    yet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们有一个部署好的应用程序可以与朋友分享。唯一的问题是我们在上一章讨论的问题；它实际上还没有做太多事情。
- en: Let's get started with using Firebase by adding an authentication process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Firebase添加身份验证流程。
- en: Authentication with Firebase
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase进行身份验证
- en: 'To allow users to log in/sign up for our app, we need to do three things:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够登录/注册我们的应用程序，我们需要做三件事：
- en: Turn on email authentication on the Firebase console.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Firebase控制台上打开电子邮件验证。
- en: Submit the email and password in our form to Firebase when the user clicks on
    the button.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，将电子邮件和密码提交到Firebase中。
- en: Either sign up or log in the user based on the result.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据结果注册或登录用户。
- en: 'Let’s open up our Firebase console ([https://console.firebase.google.com](https://console.firebase.google.com))
    and get to work on task #1:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的Firebase控制台（[https://console.firebase.google.com](https://console.firebase.google.com)）并开始处理任务＃1：
- en: From our Chatastrophe project page, click on Authentication.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的Chatastrophe项目页面，点击身份验证。
- en: Under the SIGN-IN METHOD tab, you can see all the options that Firebase provides.
    These authentication solutions are huge boons to developers, as configuring authentication
    can be tricky (especially when working with third-party APIs, such as Twitter
    or Facebook). There's a lot of infrastructure to create to provide the proper
    security. Firebase takes care of that for us, so all we have to worry about is
    tapping into their system.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“登录方法”选项卡下，您可以看到Firebase提供的所有选项。这些身份验证解决方案对开发人员来说是巨大的福音，因为配置身份验证可能会很棘手（特别是在使用第三方API时，如Twitter或Facebook）。提供适当的安全性需要创建大量基础设施。Firebase为我们处理了这一切，所以我们只需要担心如何利用他们的系统。
- en: Click on Email/Password and then on Enable and Save. Our app can now use email
    and password combinations to sign up and log in. If you're looking to spice up
    our app a bit down the line, try implementing a Facebook or GitHub sign-in.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击电子邮件/密码，然后点击启用和保存。我们的应用现在可以使用电子邮件和密码组合进行注册和登录。如果您想稍后为我们的应用增添一些趣味性，可以尝试实现Facebook或GitHub登录。
- en: 'Get back to the app, and hop on over to `LoginContainer.js`. At the moment,
    when the user submits our form, we just prevent the default submission and log
    out our state:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应用程序，转到`LoginContainer.js`。目前，当用户提交我们的表单时，我们只是阻止默认提交并注销我们的状态：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For our process, we will combine the signup and login processes into one. First,
    we'll check whether the email and password fields are filled in. If so, we'll
    try logging the user in, and if Firebase tells us that no user exists with that
    email, we'll create the user and sign them in automatically.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的流程，我们将合并注册和登录过程。首先，我们将检查电子邮件和密码字段是否已填写。如果是，我们将尝试登录用户，如果Firebase告诉我们该电子邮件对应的用户不存在，我们将自动创建用户并登录。
- en: However, if the user does exist and we get a wrong password error, we'll alert
    the user by implementing a bit more state in our component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果用户存在并且我们收到密码错误的错误，我们将通过在我们的组件中实现更多状态来提醒用户。
- en: 'Here''s the plan:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计划：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Firstly, check whether the fields are filled in:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查字段是否已填写：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Right away, we need a way to display an error to the user to tell them that
    they missed a field. Let''s add an error string to our state:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，我们需要一种方法向用户显示错误，告诉他们他们错过了一个字段。让我们向我们的状态添加一个错误字符串：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll reset that error to an empty string every time they submit the form,
    but if they missed a field, we''ll display the following text:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每次他们提交表单时，我们将将该错误重置为空字符串，但如果他们错过了一个字段，我们将显示以下文本：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, to display the error, we''ll add a `<p>` tag above our button, with
    the `className` of the error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了显示错误，我们将在按钮上方添加一个`<p>`标签，其中包含错误的`className`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay, try submitting our form without a field filled in. You can do so by either
    running the app locally (with your Dev server) or redeploying your changes. You
    should see the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，尝试提交我们的表单，而不填写任何字段。您可以通过在本地运行应用程序（使用您的开发服务器）或重新部署更改来这样做。您应该会看到以下内容：
- en: '![](../images/00032.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: It's looking good so far. The next step is to try to log the user in. At this
    point, our app has no users, so Firebase should return an error. Let's call Firebase
    with our email and password, and then console log the result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止看起来很不错。下一步是尝试登录用户。此时，我们的应用程序没有用户，因此Firebase应该返回一个错误。让我们使用我们的电子邮件和密码调用Firebase，然后在控制台中记录结果。
- en: The method we want to use is `firebase.auth().signInWithEmailAndPassword(email,
    password)`. This function returns a JavaScript promise. For those familiar with
    promises, you can skip to the next section, but it’s worth brushing up on if you're
    unsure.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用的方法是`firebase.auth().signInWithEmailAndPassword(email, password)`。这个函数返回一个JavaScript
    promise。对于熟悉promise的人，可以跳到下一节，但如果不确定的话，值得复习一下。
- en: What is a promise?
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是promise？
- en: The problem with JavaScript is that it often deals with asynchronous operations.
    These are steps that the code must complete which don't follow a linear flow in
    time. Normally, code runs line by line, one after the other, but what happens
    when we need to call an API that takes a random number of seconds to respond?
    We can't just stop our code and wait, and we will still have certain lines of
    code to execute once that call is complete, whenever that is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的问题在于它经常处理异步操作。这些是代码必须完成的步骤，它们不遵循时间上的线性流动。通常，代码一行一行地运行，但当我们需要调用一个需要随机秒数才能响应的API时会发生什么？我们不能停止我们的代码并等待，而且我们仍然有一些代码行需要在调用完成后执行，无论何时。
- en: 'The solution used to be **callbacks**. If we were using `firebase.auth().signInWithEmailAndPassword`
    in this manner, it would look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的解决方案是**回调**。如果我们以这种方式使用`firebase.auth().signInWithEmailAndPassword`，它会是这样的：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We would pass it a callback that is called when the operation is complete.
    This approach works fine, but can lead to some ugly code: specifically, something
    called the **pyramid of doom**, or **callback hell**, where nested callbacks lead
    to sloping code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会传递一个回调函数，当操作完成时调用它。这种方法很好用，但可能会导致一些丑陋的代码：具体来说，一些称为**噩梦金字塔**或**回调地狱**的东西，其中嵌套的回调导致倾斜的代码：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make working with asynchronous functions easier and cleaner, the people
    behind JavaScript implemented promises. **Promises** have a simple syntax: pass
    one function to a `.then` statement to be called when the operation is a success,
    and another to a `.catch` statement when the operation is a failure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使处理异步函数更容易和更清晰，JavaScript背后的人们实现了promises。**Promises**有一个简单的语法：将一个函数传递给`.then`语句，当操作成功时调用它，将另一个函数传递给`.catch`语句，当操作失败时调用它：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, our code is nice and readable, and we know exactly what code will be run
    when the operation is complete.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码很好读，我们知道操作完成时将运行哪些代码。
- en: Back to authentication
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到认证
- en: 'Since we expect an error to be returned (since we haven''t signed up with any
    email and password combination), we can leave our `then` statement blank, but
    add a console log to our `catch` statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们期望返回一个错误（因为我们还没有使用任何电子邮件和密码组合进行注册），我们可以将我们的`then`语句留空，但在我们的`catch`语句中添加一个控制台日志：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Submit your form, and you should be returned the following error:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 提交您的表单，您应该返回以下错误：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Great! This is exactly the error we wanted. This is the code we''ll check for,
    before initiating the signup process. For now, we''ll assume that all the other
    errors are due to an incorrect password:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这正是我们想要的错误。这是我们在启动注册流程之前将检查的代码。现在，我们将假设所有其他错误都是由于密码不正确：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Code cleanup
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码清理
- en: Our `handleSubmit` function is getting a little long and difficult to follow.
    Let's do some reorganization before we move on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`handleSubmit`函数变得有点长，难以跟踪。在继续之前，让我们重新组织一下。
- en: 'We''ll start by moving everything after the initial `if` statement inside a
    separate function, called `login()`, for simplicity:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从初始的`if`语句之后的所有内容移到一个名为`login()`的单独函数中，以简化操作：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, our `handleSubmit` becomes much smaller:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的`handleSubmit`变得更小：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's much easier to read and follow now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在阅读和跟踪起来更容易了。
- en: Signing up
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: 'Let''s get that signup process going. Again, it''s a rather simple function
    name--`firebase.auth().createUserWithEmailAndPassword(email, password)`. Again,
    it returns a promise. Let''s add `then` and `catch`, but leave the `then` as a
    console log for now:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始注册流程。同样，这是一个相当简单的函数名--`firebase.auth().createUserWithEmailAndPassword(email,
    password)`。同样，它返回一个promise。让我们添加`then`和`catch`，但现在将`then`作为控制台日志：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Try logging in to our app, and you should see a complicated user object show
    up in the console. Success! We created our first user account. If you try logging
    in again with the same account, you should see the same user object logged to
    the console.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试登录我们的应用程序，你应该会在控制台看到一个复杂的用户对象。成功！我们创建了我们的第一个用户帐户。如果你尝试使用相同的帐户再次登录，你应该会在控制台看到相同的用户对象。
- en: You can try again with a different email and password combination (it doesn't
    matter if it's a real email, for our purposes), and it should work smoothly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用不同的电子邮件和密码组合再次尝试（对于我们的目的来说，它不必是真实的电子邮件），它应该可以顺利工作。
- en: Saving our user
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存我们的用户
- en: The `user` object we received in response to our `firebase.auth().signIn` seems
    like it'll be useful down the line. There may be numerous times we want access
    to the email of the currently signed-in user. Let's go ahead and save that in
    the state of our `App` component so that we can then pass it down to any `Container`
    component (once we make more containers).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的`firebase.auth().signIn`的`user`对象似乎将来会有用。可能会有很多次我们想要访问当前登录用户的电子邮件。让我们将其保存在我们的`App`组件的状态中，这样我们就可以将其传递给任何`Container`组件（一旦我们创建更多的容器）。
- en: 'There are two possible approaches: we can pass up the user object from `LoginContainer`
    to `App` via a callback through props, and `App` will pass a `handleLogin` function
    to `LoginContainer` as a prop, which will be called when the user logs in and
    sets the state of `App` appropriately.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的方法：我们可以通过props从`LoginContainer`将用户对象传递给`App`，并且`App`将一个`handleLogin`函数作为prop传递给`LoginContainer`，当用户登录时调用该函数并适当设置`App`的状态。
- en: Firebase gives us another option, however. As we discussed earlier, the Firebase
    database is real-time, which means changes to the data are automatically pushed
    to the frontend. All we need to do is set up the appropriate listener functions
    to wait for that change and act on it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Firebase给了我们另一个选择。正如我们之前讨论的，Firebase数据库是实时的，这意味着数据的更改会自动推送到前端。我们所需要做的就是设置适当的监听函数来等待这些更改并对其进行操作。
- en: Event listeners
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件监听器
- en: '**Event listeners** in JavaScript essentially work like so: we define an event
    and a callback we want to run when that event occurs. We can thus declare a function
    early on in our code, and only have it triggered later, whenever the specified
    event occurs.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的**事件监听器**基本上是这样工作的：我们定义一个事件和一个我们想要在该事件发生时运行的回调。因此，我们可以在代码中提前声明一个函数，然后在稍后触发它，只要指定的事件发生。
- en: 'Here''s an example of listening for a resize of the browser window:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是监听浏览器窗口调整大小的示例：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Firebase provides us with a function called `firebase.auth().onAuthStateChanged`.
    This function takes a callback as an argument, which is then called with the user
    object; it's perfect for our purposes!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase为我们提供了一个名为`firebase.auth().onAuthStateChanged`的函数。这个函数以一个回调作为参数，然后用用户对象调用它；这对我们来说非常完美！
- en: 'The challenge, however, is when to declare this function in our `App` component.
    We want it to do the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，挑战在于在我们的`App`组件中何时声明这个函数。我们希望它执行以下操作：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, this leads to a couple of restrictions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致一些限制：
- en: We only want to register the listener once, so we can't put it in the `render`
    method (which can be called multiple times as React updates the DOM)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只想注册一次监听器，所以我们不能将其放在`render`方法中（因为React更新DOM时可能会多次调用）
- en: We need the `App` component to be fully loaded before registering the listener,
    because React complains if you try to `setState` on a non-existent component
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在注册监听器之前完全加载`App`组件，因为如果你尝试在不存在的组件上`setState`，React会报错
- en: In other words, we need to declare `onAuthStateChanged` at a particular time,
    that is, as soon as possible after `App` has appeared on the screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要在特定时间声明`onAuthStateChanged`，也就是在`App`出现在屏幕上后尽快。
- en: Lifecycle methods
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: 'Fortunately, situations like this one are common in React, so the library provides
    us with a solution: a suite of functions called **lifecycle methods**. These methods
    come standard with all (class-based) React components, and are called at certain
    points as the component appears, updates, and disappears.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在React中这样的情况很常见，所以库为我们提供了一个解决方案：一组名为**生命周期方法**的函数。这些方法是所有（基于类的）React组件的标准功能，并在组件出现、更新和消失时的特定时间点被调用。
- en: 'The lifecycle of a React component is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的生命周期如下：
- en: The application has started, and the component's `render` method is about to
    be called
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序已启动，组件的`render`方法即将被调用
- en: The component has rendered and has now appeared on the screen
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件已呈现并出现在屏幕上
- en: The component is about to receive new props
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件即将接收新的props
- en: The component has received new props, and is about to call render again to update
    in response
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件已收到新的props，并将再次调用render以响应更新
- en: The component has updated in response to new props or a state change
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件已根据新的props或状态更改进行了更新
- en: The component is about to disappear from the screen
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件即将从屏幕上消失
- en: Note that all of these don't necessarily occur with every component, but they
    are all quite common as our UI updates and changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有这些方法都会在每个组件中发生，但它们在UI更新和更改时都很常见。
- en: 'The corresponding lifecycle methods are as listed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的生命周期方法如下：
- en: '`componentWillMount`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount`'
- en: '`componentDidMount`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount`'
- en: '`componentWillReceiveProps`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`'
- en: '`componentWillUpdate`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`'
- en: '`componentDidUpdate`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate`'
- en: '`componentWillUnmount`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`'
- en: Based on the preceding description, take a moment and try to figure out which
    lifecycle method we want to use to register our `onAuthStateChanged`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述描述，花点时间想一想我们想要使用哪个生命周期方法来注册我们的`onAuthStateChanged`。
- en: 'Again, the point of time we''re looking for is right after the component is
    first rendered. This makes `componentDidMount` the perfect choice; let''s add
    it to our `App` component. We also need to initialize our state with the `user`
    key, which we''ll work with in a second:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们要找的时间点是在组件首次呈现后。这使得`componentDidMount`成为完美的选择；让我们将其添加到我们的`App`组件中。我们还需要用`user`键初始化我们的状态，稍后我们将使用它：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you're unclear on lifecycle methods, try adding all six of them to your app
    with console logs in each one (as well as a `console.log` in the `render` method),
    and watch the lifecycle of your React component.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对生命周期方法不清楚，请尝试在您的应用程序中添加所有六个生命周期方法，并在每个方法中使用控制台日志（以及在`render`方法中使用`console.log`），观察您的React组件的生命周期。
- en: 'Okay, we can add `onAuthStateChanged` next:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来我们可以添加`onAuthStateChanged`：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Confused about the `this.setState({ user })`? That''s called the `ES6` property
    shorthand. Basically, when you''re assigned a key to a variable, and the key and
    the variable should have the same name, you can save time instead of typing `this.setState({
    user: user })`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '对`this.setState({ user })`感到困惑吗？这被称为`ES6`属性简写。基本上，当你将一个键分配给一个变量，并且键和变量应该有相同的名称时，你可以节省时间，而不是输入`this.setState({
    user: user })`。'
- en: Note the `if` statement. `onAuthStateChanged` is also called when the user logs
    out, in which case the user argument will be null. We can set `this.state.user`
    to null, but let's keep it simple and let the user persist in state until the
    next user comes along.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`if`语句。`onAuthStateChanged`也在用户登出时被调用，此时用户参数将为null。我们可以将`this.state.user`设置为null，但让我们保持简单，让用户在状态中持续，直到下一个用户出现。
- en: Another bonus to Firebase authentication is that it takes care of persistent
    login for us. This means that a user won't have to log in every time they come
    to our app; Firebase will load their logged-in state automatically, until they
    click on sign out (which we'll add in the future). In accordance with this, `onAuthStateChanged`
    will be called every time that a user visits our app, whether they physically
    log in or are already logged in. Therefore, we can rely on our user object always
    being saved in state if the user is logged in.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase身份验证的另一个好处是它为我们处理了持久登录。这意味着用户不必每次进入我们的应用程序时都要登录；Firebase会自动加载他们的登录状态，直到他们点击登出（这是我们将来会添加的）。根据这一点，`onAuthStateChanged`将在用户访问我们的应用程序时每次被调用，无论他们是物理登录还是已经登录。因此，如果用户已登录，我们可以依赖于我们的用户对象始终保存在状态中。
- en: You can try it by logging out the user in the callback of `onAuthStateChanged`
    with `firebase.auth().signOut();`. Try logging in again, and then refreshing the
    page; you should see the user object appear no matter how many times you refresh,
    as you are automatically logged in.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`onAuthStateChanged`的回调中使用`firebase.auth().signOut();`来尝试登出用户。尝试重新登录，然后刷新页面；无论您刷新多少次，您都应该看到用户对象出现，因为您已自动登录。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'That does it for authentication! Now, our users can log in to our app. The
    next step is to give them something to do once they sign in. For that, we need
    more pages, which leads us to our next topic: routing with React. How do we navigate
    between React components? How do we change the content of our app in accordance
    with the URL? All that and more is coming up next!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证就是这样！现在，我们的用户可以登录我们的应用程序。下一步是在他们登录后给他们一些事情要做。为此，我们需要更多页面，这将引出我们的下一个主题：使用React进行路由。我们如何在React组件之间导航？我们如何根据URL更改应用程序的内容？所有这些等等都即将到来！
