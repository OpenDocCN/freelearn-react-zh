- en: Implementing Complex User Interfaces - Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现复杂的用户界面-第一部分
- en: In this chapter, we will implement complex user interfaces. We will learn more
    about using flexbox to create components that work on different screen sizes,
    how to detect orientation changes, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现复杂的用户界面。我们将学习如何使用flexbox创建适用于不同屏幕尺寸的组件，如何检测方向变化等。
- en: 'The chapter will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下教程：
- en: Creating a reusable button with theme support
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有主题支持的可重用按钮
- en: Building a complex layout for tablets using flexbox
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用flexbox为平板电脑构建复杂的布局
- en: Including custom fonts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括自定义字体
- en: Using font icons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字体图标
- en: Creating a reusable button with theme support
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有主题支持的可重用按钮
- en: Reusability is very important when developing software. We should avoid repeating
    the same thing over and over again, and instead we should create small components
    that we can reuse as many times as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，可重用性非常重要。我们应该避免一遍又一遍地重复相同的事情，而是应该创建可以尽可能多次重用的小组件。
- en: In this recipe, we will create a `Button` component, and we are also going to
    define several properties to change its look and feel. While going through this
    recipe, we will learn how to dynamically apply different styles to a component.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个`Button`组件，并且我们还将定义几个属性来改变其外观和感觉。在学习本教程的过程中，我们将学习如何动态地将不同的样式应用到组件上。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create an empty app. Let's name it `reusable-button`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个空的应用程序。让我们将其命名为`reusable-button`。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the root of our new app, we'll need to create a new `Button` folder for our
    reusable button-related code. Let's also create `index.js` and `styles.js` in
    our new `Button` folder.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们新应用程序的根目录中，我们需要为可重用的按钮相关代码创建一个新的`Button`文件夹。让我们还在新的`Button`文件夹中创建`index.js`和`styles.js`。
- en: 'We will start by importing the dependencies for our new component. In the `Button/index.js`
    file, we will be creating a `Button` component. This means we''ll need to import
    the `Text` and `TouchableOpacity` components. You''ll notice we''re also importing
    styles that do not exist yet. We will define these styles in a different file
    later in this recipe. In the `Button/index.js` file, we should have these imports:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从导入新组件的依赖项开始。在`Button/index.js`文件中，我们将创建一个`Button`组件。这意味着我们需要导入`Text`和`TouchableOpacity`组件。您会注意到我们还在导入尚不存在的样式。我们将在本教程的后续部分中定义这些样式。在`Button/index.js`文件中，我们应该有以下导入：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have our dependencies imported, let''s define the class for this
    component. We are going to need some properties and two methods. It''s also required
    that we export this component so we can use it elsewhere:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了依赖项，让我们为这个组件定义类。我们将需要一些属性和两种方法。还需要导出此组件，以便我们可以在其他地方使用它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to select the styles to apply to our component based on the given `properties`.
    For this purpose, we will define the `getTheme` method. This method will check
    whether any of the `properties` are `true` and will return the appropriate styles. If
    none are `true`, it will return the `Default` style:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要根据给定的`属性`选择要应用于我们组件的样式。为此，我们将定义`getTheme`方法。该方法将检查任何`属性`是否为`true`，并返回相应的样式。如果没有一个是`true`，它将返回`Default`样式：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's required that all components have a `render` method. Here, we need to return
    the JSX elements for this component. In this case, we will get the styles for
    the given `properties` and apply them to the `TouchableOpacity` component.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有组件都需要一个`render`方法。在这里，我们需要返回此组件的JSX元素。在这种情况下，我们将获取给定`属性`的样式，并将其应用于`TouchableOpacity`组件。
- en: 'We are also defining a label for the button. Inside this label, we will render
    the `children` property. If a callback function is received, then it will be executed
    when the user presses this component:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为按钮定义了一个标签。在这个标签内，我们将渲染`children`属性。如果接收到回调函数，那么当用户按下这个组件时它将被执行：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are almost done with our `Button` component. We still need to define our
    styles, but first let's move over to the `App.js` file in the root of the project.
    We need to import the dependencies, including the `Button` component we have created.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Button`组件几乎完成了。我们仍然需要定义我们的样式，但首先让我们转到项目根目录下的`App.js`文件。我们需要导入依赖项，包括我们创建的`Button`组件。
- en: 'We are going to display an alert message when the user clicks the button, therefore,
    we also need to import the `Alert` component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，我们将显示警报消息，因此我们还需要导入`Alert`组件：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have all the dependencies, let''s define a stateless component that
    renders a few buttons. The first button will use the default style, and the second
    button will use the success style, which will add a nice green color to the button''s
    background. The last button will display an alert when it gets pressed. For that,
    we need to define the callback function that will use the `Alert` component, just
    setting the title and message:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了所有的依赖项，让我们定义一个无状态组件，渲染几个按钮。第一个按钮将使用默认样式，第二个按钮将使用成功样式，这将为按钮的背景添加一个漂亮的绿色。最后一个按钮将在按下时显示一个警报。为此，我们需要定义使用`Alert`组件的回调函数，只需设置标题和消息：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are going to add some styles for how the main layout should align and justify
    each button, along with some margins:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为主要布局的对齐和每个按钮的对齐方式添加一些样式，以及一些边距：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we try to run the app now, we will get some errors. This is because we haven''t
    declared the styles for our button. Let''s work on that now. Inside the `Button/styles.js` file,
    we need to define the base styles. These styles will be applied to every instance
    of the button. Here, we will define a radius, padding, font color, and all the
    common styles that we need for this component:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行应用程序，将会出现一些错误。这是因为我们还没有为按钮声明样式。让我们现在来解决这个问题。在`Button/styles.js`文件中，我们需要定义基本样式。这些样式将应用于按钮的每个实例。在这里，我们将定义半径、填充、字体颜色和我们需要的所有常见样式：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we have the common styles for our button, we need to define the styles
    for the `Danger`, `Info`, `Success`, and `Default` themes. For this, we are going
    to define different objects for each theme. Inside each theme, we will use the
    same object but with specific styles for that theme.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了按钮的常见样式，我们需要为`Danger`、`Info`、`Success`和`Default`主题定义样式。为此，我们将为每个主题定义不同的对象。在每个主题内，我们将使用相同的对象，但具有该主题的特定样式。
- en: 'To keep things simple, we are only going to change the `backgroundColor`, but
    we do have the option to use as many style properties as we want:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们只会改变`backgroundColor`，但我们可以使用尽可能多的样式属性：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, let''s export the styles. This step is necessary so that the `Button`
    component can import all the styles for each theme:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们导出样式。这一步是必要的，这样`Button`组件就可以导入每个主题的所有样式：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we open the app, we should be able to see our completed layout:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们打开应用程序，我们应该能够看到我们完成的布局：
- en: '![](assets/fb784d29-16db-4a64-a1c9-bba06dcfaf0a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb784d29-16db-4a64-a1c9-bba06dcfaf0a.png)'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, we made use of the `TouchableOpacity` component. This component
    allows us to define a nice animation that changes the opacity when the user presses
    the button.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`TouchableOpacity`组件。这个组件允许我们定义一个漂亮的动画，当用户按下按钮时改变不透明度。
- en: We can use the `activeOpacity` property to set the opacity value when the button
    gets pressed. The value can be any number between `0` and `1`, where `0` is completely
    transparent.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`activeOpacity`属性来设置按钮被按下时的不透明度值。该值可以是`0`到`1`之间的任何数字，其中`0`是完全透明的。
- en: 'If we press the rounded button, we will see a native Alert message, as shown
    in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下圆形按钮，我们将看到一个原生的警报消息，如下面的截图所示：
- en: '![](assets/4b6b4ca1-7313-4570-9e82-17758d2b4711.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4b6b4ca1-7313-4570-9e82-17758d2b4711.png)'
- en: Building a complex layout for tablets using flexbox
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flexbox为平板电脑构建复杂布局
- en: Flexbox is really convenient when it comes to creating responsive layouts. React
    Native uses flexbox as a layout system, and if you are already familiar with these
    concepts, it will be really easy for you to start creating layouts of any kind.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建响应式布局时，flexbox真的非常方便。React Native使用flexbox作为布局系统，如果你已经熟悉这些概念，那么对于你来说开始创建任何类型的布局将会非常容易。
- en: As discussed in the previous chapter, there are some differences between the
    way flexbox works in React Native as compared to how it works in CSS. For more
    information on the differences between React Native and CSS flexbox, please refer
    to the *How it works... *section of the *Using flexbox to create a layout *recipe
    in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating a Simple
    React Native App*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，在React Native中，flexbox的工作方式与CSS中的工作方式有一些不同。有关React Native和CSS flexbox之间的区别的更多信息，请参阅[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中*如何工作...*部分的*使用flexbox创建布局*教程。
- en: In this recipe, we will create a layout to display a list of blog posts. Each
    post will be a small card with an image, an excerpt, and a button to read more.
    We will use flexbox to arrange the posts on the main container based on screen
    size. This will allow us to handle the screen rotation by properly aligning the
    cards in both landscape and portrait.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个布局来显示博客文章列表。每篇文章都将是一个带有图片、摘录和阅读更多按钮的小卡片。我们将使用flexbox根据屏幕大小在主容器上排列这些文章。这将允许我们通过正确对齐横向和纵向的卡片来处理屏幕旋转。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to need a new app for this recipe. Let's name it `tablet-flexbox`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新的应用程序来完成这个教程。让我们把它命名为`tablet-flexbox`。
- en: When we create a new app with Expo, there is an `app.json` that gets created
    at the base of the project that provides some basic configuration. In this recipe,
    we are building an app that we want to be sure looks good on a tablet, particularly
    in landscape mode. When we open `app.json`, we should see an `orientation` property
    set to `'portrait'`. This property determines which orientations should be allowed
    within our app. The `orientation` property accepts `'portrait'` (lock app to portrait
    mode), `'landscape'` (lock app to landscape mode), and `'default'` (allow app
    to adjust screen orientation based on the device's orientation). For our app,
    we will set the `orientation` to `'landscape'` so that we can support both landscape
    and portrait layouts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Expo创建一个新应用程序时，项目的基础部分会创建一个`app.json`，其中提供了一些基本配置。在这个教程中，我们正在构建一个应用程序，我们希望它在平板电脑上看起来很好，特别是在横向模式下。当我们打开`app.json`时，我们应该看到一个`orientation`属性设置为`'portrait'`。该属性确定应用程序内允许哪些方向。`orientation`属性接受`'portrait'`（锁定应用程序为纵向模式）、`'landscape'`（锁定应用程序为横向模式）和`'default'`（允许应用程序根据设备的方向调整屏幕方向）。对于我们的应用程序，我们将把`orientation`设置为`'landscape'`，这样我们就可以支持横向和纵向布局。
- en: We'll also be using some images, which need to be hosted remotely for this recipe
    to properly simulate loading remote data and displaying images with the `Image`
    component. I have uploaded these images to the [www.imgur.com](http://www.imgur.com) image
    hosting service, and referenced these remote images in the `data.json` file that
    the recipe uses for its consumable data. If, for any reason these remote images
    don't load properly for you, they are also in included in the repository for this
    recipe under the `/assets` folder. Feel free to upload them to any server or hosting
    service, and update the image URLs in `data.json` accordingly. The repository
    can be found on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-3/tablet-flexbox](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-3/tablet-flexbox).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一些图片，这些图片需要远程托管，以便为该示例正确模拟加载远程数据并使用`Image`组件显示图片。我已经将这些图片上传到[www.imgur.com](http://www.imgur.com)图像托管服务，并在`data.json`文件中引用了这些远程图片，该文件是该示例用于其可消耗数据的。如果由于任何原因这些远程图片对您来说加载不正常，它们也包含在该示例的存储库中的`/assets`文件夹中。请随意将它们上传到任何服务器或托管服务，并相应地更新`data.json`中的图片URL。该存储库可以在GitHub上找到，网址为[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-3/tablet-flexbox](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-3/tablet-flexbox)。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we need to create a `Post` folder in the root of the project. We need
    to also create an `index.js` and a `styles.js` file in the new `Post` folder.
    We will use this `Post` component to display each post for our app. Finally, we
    need to add a `data.json` file to the root of the project, which we will use to
    define a list of posts.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在项目的根目录中创建一个`Post`文件夹。我们还需要在新的`Post`文件夹中创建一个`index.js`和一个`styles.js`文件。我们将使用这个`Post`组件来为我们的应用程序显示每个帖子。最后，我们需要在项目的根目录中添加一个`data.json`文件，我们将使用它来定义一个帖子列表。
- en: 'Now we can move on to building the `App.js` component. First, we need to import
    the dependencies for this class. We are going to use a `ListView` component to
    render the list of posts. We''ll also need `Text` and `View` components for content
    containers. We are going to create a custom `Post` component to render each post
    on the list, and we will also need to import the `data.json` file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续构建`App.js`组件。首先，我们需要导入这个类的依赖项。我们将使用`ListView`组件来渲染帖子列表。我们还需要`Text`和`View`组件作为内容容器。我们将创建一个自定义的`Post`组件来渲染列表中的每个帖子，并且我们还需要导入`data.json`文件：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's create the class for the `App` component. Here, we will use the data from
    the `.json` file to create the `dataSource` for the list. We will add some actual
    data to our `data.json` file in the next step. In the `render` method, we are
    going to define a simple top toolbar and the `List` component. We are going to
    use the `Post` component for every record and get the `dataSource` from the `state`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`App`组件创建类。在这里，我们将使用`.json`文件中的数据来创建列表的`dataSource`。我们将在下一步向我们的`data.json`文件中添加一些实际数据。在`render`方法中，我们将定义一个简单的顶部工具栏和`List`组件。我们将使用`Post`组件来处理每条记录，并从`state`中获取`dataSource`。
- en: 'If you have any questions regarding the `ListView` component, you should take
    a look at the recipe in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App*, where we created a list of orders:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`ListView`组件有任何疑问，您应该查看[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中的示例，*创建一个简单的React
    Native应用程序*，在那里我们创建了一个订单列表：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Two files are still missing: the `.json` file with the data and the `Post`
    component. In this step, we will create the data that we are going to use for
    each post. To make things simple, there is only one record of data in the following
    code snippet, but the rest of the `POST` object I used in this recipe can be found
    in the `data.json` file of the code repository for this recipe, located at [https://github.com/warlyware/react-native-cookbook/blob/master/chapter-3/tablet-flexbox/data.json](https://github.com/warlyware/react-native-cookbook/blob/master/chapter-3/tablet-flexbox/data.json):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还缺少两个文件：包含数据的`.json`文件和`Post`组件。在这一步中，我们将创建我们将用于每个帖子的数据。为了简化事情，在以下代码片段中只有一条数据记录，但我在这个示例中使用的其余`POST`对象可以在本示例的代码存储库中的`data.json`文件中找到，位于[https://github.com/warlyware/react-native-cookbook/blob/master/chapter-3/tablet-flexbox/data.json](https://github.com/warlyware/react-native-cookbook/blob/master/chapter-3/tablet-flexbox/data.json)：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have some data, we are ready to work on the `Post` component. In
    this component, we need to display the image, title, and button. Since this component
    does not need to know about state, we will use a stateless component. The following
    code uses all the components we learned about in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App*. If something is unclear, please review that chapter
    again. This component receives the data as a parameter, which we then use for
    displaying the content in the component. The `Image` component will use the `img`
    property defined on each object in the `data.json` file to display the remote
    image:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一些数据，我们准备开始处理`Post`组件。在这个组件中，我们需要显示图片、标题和按钮。由于这个组件不需要知道状态，我们将使用一个无状态组件。以下代码使用了我们在[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中学到的所有组件，*创建一个简单的React
    Native应用*。如果有什么不清楚的地方，请再次查看那一章。这个组件将接收数据作为参数，然后我们将用它来显示组件中的内容。`Image`组件将使用`data.json`文件中每个对象上定义的`img`属性来显示远程图片。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have defined the component, we also need to define the styles for each
    post. Let''s create an empty `StyleSheet` export so that the `Post` component
    relying on `styles.js` will properly function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们定义了组件，我们还需要为每个帖子定义样式。让我们创建一个空的`StyleSheet`导出，以便依赖于`styles.js`的`Post`组件能够正常运行。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we try to run the app, we should be able to see the data from the `.json`
    file on the screen. It won't be very pretty though, since, we haven't applied
    any styles yet.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试运行应用程序，我们应该能够在屏幕上看到来自`.json`文件的数据。不过，它不会很漂亮，因为我们还没有应用任何样式。
- en: 'We have everything we need on the screen. Now we are ready to start working
    on the layout. First, let''s add styles for our `Post` container. We''ll be setting `width`,
    `height`, `borderRadius`, and a few others. Let''s add them to the `/Post/styles.js`
    file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在屏幕上已经有了所需的一切。现在我们准备开始布局工作。首先，让我们为我们的`Post`容器添加样式。我们将设置`width`、`height`、`borderRadius`和其他一些样式。让我们把它们添加到`/Post/styles.js`文件中。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By now, we should see small boxes vertically aligned. That''s some progress,
    but we need to add more styles to the image so we can see it onscreen. Let''s
    add an `image` property to the same `styles` const from the last step. The `resizeMode`
    property will allow us to set how we want to resize the image. In this case, by
    selecting `cover`, the image will keep the aspect ratio of the original:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该看到垂直对齐的小框。这是一些进展，但我们需要为图片添加更多样式，这样我们才能在屏幕上看到它。让我们在上一步的相同`styles`常量中添加一个`image`属性。`resizeMode`属性将允许我们设置我们想要如何调整图片的大小。在这种情况下，通过选择`cover`，图片将保持原始的宽高比。
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the `content` of the post, we want to take up all of the available height
    on the card, therefore we need to make it flexible and add some padding. We''ll
    also add `overflow: hidden` to the content to avoid overflowing the `View` element.
    For the `title`, we only need to change the `fontSize` and add a `margin` to the
    bottom:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于帖子的`content`，我们希望占据卡片上所有可用的高度，因此我们需要使其灵活并添加一些填充。我们还将向内容添加`overflow: hidden`以避免溢出`View`元素。对于`title`，我们只需要更改`fontSize`并在底部添加`margin`：'
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, for the button, we will set the `backgroundColor` to green and the
    text to white. We also need to add some `padding` and `margin` for spacing:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于按钮，我们将`backgroundColor`设置为绿色，文本设置为白色。我们还需要添加一些`padding`和`margin`来进行间距：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we refresh the simulator, we should see our posts in small cards. Currently,
    the cards are arranged vertically, but we want to render all of them horizontally.
    We are going to fix that in the following steps:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们刷新模拟器，我们应该能够看到我们的帖子以小卡片的形式显示。目前，卡片是垂直排列的，但我们希望将它们全部水平渲染。我们将在以下步骤中解决这个问题：
- en: '![](assets/9b2adc12-a3f8-4fe4-9a57-1a67d26382d0.png)Primary styles have been
    added for all post elements'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9b2adc12-a3f8-4fe4-9a57-1a67d26382d0.png)已为所有帖子元素添加了主要样式'
- en: 'Currently, we can only see the first three items on the list in a column instead
    of in a row across the screen. Let''s return to the `App.js` file and start adding
    our styles. We add `flex: 1` to the `container` so that our layout will always
    fill the screen. We also want to show a toolbar at the top. For that, we just
    need to define some `padding` and `color` as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '目前，我们只能在列表中以列的形式看到前三个项目，而不是横向排列在屏幕上。让我们返回`App.js`文件并开始添加我们的样式。我们在`container`中添加`flex:
    1`，以便我们的布局始终填满屏幕。我们还希望在顶部显示一个工具栏。为此，我们只需要定义一些`padding`和`color`如下：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s add some basic styles to the `list` as well. Just a nice background
    color and some padding. We''ll also add the `flex` property, which will ensure
    the list takes all the available height on the screen. We only have two components
    here: the toolbar and the list. The toolbar is taking about 50 px. If we make
    the list flexible, it will take all of the remaining available space, which is
    exactly what we want when rotating the device or when running the app in different
    screen resolutions:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也为`list`添加一些基本样式。一个漂亮的背景颜色和一些填充。我们还将添加`flex`属性，这将确保列表占据屏幕上所有可用的高度。我们这里只有两个组件：工具栏和列表。工具栏占用大约50像素。如果我们使列表灵活，它将占据所有剩余的可用空间，这正是我们在旋转设备或在不同屏幕分辨率下运行应用程序时想要的效果：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we check the app in the simulator once more, we should be able to see the
    toolbar and list being laid out as expected:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次在模拟器中检查应用程序，我们应该能够看到工具栏和列表按预期布局：
- en: '![](assets/7136ddc4-acb9-4d77-a451-d8b6fa2e90b8.png)Styles have been applied
    to each post to give them a card like appearance'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7136ddc4-acb9-4d77-a451-d8b6fa2e90b8.png)已应用样式给每个帖子，使它们看起来像卡片'
- en: 'We are almost done with this app. All we have left to do is to arrange the
    cards horizontally. This can be achieved with flexbox in three simple steps:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了这个应用程序。我们唯一剩下的事情就是将卡片水平排列。这可以通过flexbox在三个简单的步骤中实现：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first step is applying these `content` styles via the `contentContainerStyle`
    property in the `ListView` component. Internally, the `ListView` component will
    apply these styles to the content container, which wraps all of the child views.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过`ListView`组件中的`contentContainerStyle`属性应用这些`content`样式。在内部，`ListView`组件将这些样式应用于包裹所有子视图的内容容器。
- en: 'We then set the `flexDirection` to `row`. This will horizontally align the
    cards on the list; however, this presents a new problem: we can only see one single
    row of posts. To fix the problem, we need to wrap the items. We do this by setting
    the `flexWrap` property to `wrap`, which will automatically move the items that
    don''t fit in the view to the next row. Lastly, we use the `justifyContent` property
    and set it to `center`, which will center our `ListView` in the middle of our
    app.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`flexDirection`设置为`row`。这将水平对齐列表上的卡片；然而，这提出了一个新问题：我们只能看到一行帖子。为了解决这个问题，我们需要包裹这些项目。我们通过将`flexWrap`属性设置为`wrap`来实现这一点，这将自动将不适合视图的项目移动到下一行。最后，我们使用`justifyContent`属性并将其设置为`center`，这将使我们的`ListView`居中在应用程序的中间。
- en: 'We now have a responsive app that looks good on a tablet in landscape mode:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有一个响应灵敏的应用程序，在横向模式下在平板电脑上看起来很好：
- en: '![](assets/cbd691f2-e7a5-484e-8381-4db14dd7ad36.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cbd691f2-e7a5-484e-8381-4db14dd7ad36.png)'
- en: Side-by-side comparison of iPad and Android tablet screenshots in landscape
    mode
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 横向模式下iPad和Android平板电脑截图的并排比较
- en: 'And looks just as good in portrait mode:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在纵向模式下看起来也很好：
- en: '![](assets/07bd3013-a9eb-4d81-9bd5-240d3731943b.png)Side-by-side comparison
    of iPad and Android tablet screenshots in portrait mode'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/07bd3013-a9eb-4d81-9bd5-240d3731943b.png)纵向模式下iPad和Android平板电脑截图的并排比较'
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Expo also provides a `ScreenOrientation` helper for changing the orientation
    configuration of the app. This helper also allows for more granular orientation
    settings (such as `ALL_BUT_UPSIDE_DOWN` or `LANDSCAPE_RIGHT`). If your app needs
    dynamic, granular control over screen orientation, see the `ScreenOrientation`
    Expo documentation for information: [https://docs.expo.io/versions/v24.0.0/sdk/screen-orientation.html](https://docs.expo.io/versions/v24.0.0/sdk/screen-orientation.html).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Expo还提供了一个`ScreenOrientation`助手，用于更改应用程序的方向配置。该助手还允许更精细的方向设置（例如`ALL_BUT_UPSIDE_DOWN`或`LANDSCAPE_RIGHT`）。如果您的应用程序需要动态、细粒度的屏幕方向控制，请参阅`ScreenOrientation`Expo文档获取信息：[https://docs.expo.io/versions/v24.0.0/sdk/screen-orientation.html](https://docs.expo.io/versions/v24.0.0/sdk/screen-orientation.html)。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation on static image resources and the `<Image>` component
    can be found at[ https://facebook.github.io/react-native/docs/images.html](https://facebook.github.io/react-native/docs/images.html).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关静态图像资源和`<Image>`组件的官方文档可以在[ https://facebook.github.io/react-native/docs/images.html](https://facebook.github.io/react-native/docs/images.html)找到。
- en: Including custom fonts
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括自定义字体
- en: At some point, we are probably going to want to display text with a custom font
    family. Until now, we've been using the default font, but we can use any other
    that we like.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们可能会想要使用自定义字体系列显示文本。到目前为止，我们一直在使用默认字体，但我们可以使用任何其他我们喜欢的字体。
- en: Before Expo, the process of adding custom fonts was more difficult, required
    working with native code, and needed to be implemented differently in iOS and
    Android. Luckily, through the use of Expo's font helper library, this has become
    streamlined and simplified.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Expo之前，添加自定义字体的过程更加困难，需要使用原生代码，并且需要在iOS和Android中实现不同的方式。幸运的是，通过使用Expo的字体助手库，这一切都变得简化和简化了。
- en: In this recipe, we will import a few fonts and then display text using each
    of the imported font families. We will also use different font styles, such as
    **bold** and *italic*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将导入一些字体，然后使用每个导入的字体系列显示文本。我们还将使用不同的字体样式，如**粗体**和*斜体*。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to work on this example we need some fonts. You can use whatever fonts
    you want. I recommend going to Google Fonts ([https://fonts.google.com/](https://fonts.google.com/))
    and downloading your favorites. For this recipe, we will be using theJosefin Sans and Raleway
    fonts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这个示例上工作，我们需要一些字体。你可以使用任何你喜欢的字体。我建议去Google Fonts（[https://fonts.google.com/](https://fonts.google.com/)）下载你喜欢的字体。在这个示例中，我们将使用Josefin
    Sans和Raleway字体。
- en: Once you have the fonts downloaded, let's create an empty app and name it `custom-fonts`. 
    When we create a blank app with Expo, it creates an `assets` folder in the root
    of the project for placing all of your assets (images, fonts, and so on), so we'll
    follow the standard and add our fonts to this folder. Let's create the `/assets/fonts`
    folder and add our custom font files downloaded from Google Fonts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你下载了字体，让我们创建一个空的应用程序并将其命名为`custom-fonts`。当我们使用Expo创建一个空白应用程序时，它会在项目的根目录中创建一个`assets`文件夹，用于放置所有资产（图像、字体等），因此我们将遵循标准，并将我们的字体添加到此文件夹中。让我们创建`/assets/fonts`文件夹并将从Google
    Fonts下载的自定义字体文件添加到此文件夹中。
- en: When downloading fonts from Google Fonts, you'll get a `.zip` file containing
    a `.ttf` file for each of the font family variants.  We will be using the regular, **bold**,
    and *italic*variations, so copy the corresponding `.ttf` files for each variant
    in each family to our `/assets/fonts` folder.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从Google Fonts下载字体时，你会得到一个包含每个字体系列变体的`.ttf`文件的`.zip`文件。我们将使用常规、**粗体**和*斜体*变体，因此将每个系列的对应`.ttf`文件复制到我们的`/assets/fonts`文件夹中。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With our font files in place, the first step is to open `App.js` and add the
    imports we''ll need:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置好我们的字体文件后，第一步是打开`App.js`并添加我们需要的导入：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we''ll add a simple component for displaying some text that we want to
    style with our custom fonts. We''ll start with just one `Text` element to display
    the regular variant of the Roboto font:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个简单的组件来显示一些我们想要用我们自定义字体样式的文本。我们将从一个`Text`元素开始，显示Roboto字体的常规变体：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s also add some starter styles for the component we''ve just created.
    For now, we''ll just increase the font size for our `josefinSans` class styles:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也为我们刚刚创建的组件添加一些初始样式。现在，我们只会增加我们的`josefinSans`类样式的字体大小：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we open the app now in our simulator, we will see the Hello, Josefin Sans!
    text displayed in the middle of the screen using the default font:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在模拟器中打开应用程序，我们将看到“Hello, Josefin Sans!”文本以默认字体显示在屏幕中央：
- en: '![](assets/29a14fb0-a5c0-4208-acb2-eb0a0221f62a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/29a14fb0-a5c0-4208-acb2-eb0a0221f62a.png)'
- en: 'Let''s load our `JosefinSans-Regular.ttf` font file so that we can style our
    text with it. We''ll use the `componentDidMount` life cycle hook provided by React
    Native to tell our app when to start loading the font:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载我们的`JosefinSans-Regular.ttf`字体文件，以便我们可以用它来样式化我们的文本。我们将使用React Native提供的`componentDidMount`生命周期钩子来告诉我们的应用程序何时开始加载字体：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we''ll add the font we''re loading to the styles being applied to our
    `Text` element:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们正在加载的字体到应用于我们的`Text`元素的样式中：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have styles, right? Well, not quite. If we look back at our simulators,
    we''ll see that we''re getting an error instead:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有样式了，对吗？嗯，并不完全是。如果我们回头看看我们的模拟器，我们会看到我们得到了一个错误：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But we did just load fonts via `Expo.Font.loadAsync`! What gives? It turns
    out we have a race condition on our hands. The `josefinSans` styles we defined
    for our `Text` element are being applied before the Josefin Sans font has been
    loaded. To handle this problem, will need to use the component''s `state` to keep
    track of the load status of the font:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是我们刚刚通过`Expo.Font.loadAsync`加载了字体！怎么回事？事实证明我们面临一个竞争条件。我们为`Text`元素定义的`josefinSans`样式被应用在Josefin
    Sans字体加载之前。为了解决这个问题，我们需要使用组件的`state`来跟踪字体的加载状态：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that our component has a `state`, we can update the state''s `fontLoaded`
    property to `true` once the font is loaded. Using the ES6 feature `async`/`await`
    makes this succinct and straightforward. Let''s do this in our `componentDidMount`
    code block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的组件有了一个`state`，一旦字体加载完成，我们就可以将状态的`fontLoaded`属性更新为`true`。使用ES6特性`async`/`await`使这变得简洁而直接。让我们在我们的`componentDidMount`代码块中这样做：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we are now awaiting the `Font.loadAsync()` call, we can set the state
    of `fontLoaded` to `true` once the call is complete:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在正在等待`Font.loadAsync()`调用，一旦调用完成，我们可以将`fontLoaded`的状态设置为`true`：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All that''s left to do is to update our `render` method to only render the
    `Text` element that depends on the custom font when the `fontLoaded` state property
    is `true`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要做的就是更新我们的`render`方法，只有在`fontLoaded`状态属性为`true`时才渲染依赖于自定义字体的`Text`元素：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, when we check out our app in the simulators, we should see our custom
    font being applied:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们在模拟器中查看我们的应用程序时，我们应该看到我们的自定义字体被应用：
- en: '![](assets/2702c3c8-c45a-4a87-8f45-0d1e93006668.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2702c3c8-c45a-4a87-8f45-0d1e93006668.png)'
- en: 'Let''s load the rest of our fonts so that we can use them in our app as well:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载其余的字体，这样我们也可以在应用程序中使用它们：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll also need `Text` elements for displaying text in each of our new font
    families/variants. Note that we''ll also need to wrap all our `Text` elements
    in another `View` element, since JSX expressions require that there be only one
    parent node. We''re also now passing the `style` property an array of styles to
    apply in order to consolidate the `fontSize` and `padding` styles we''ll be applying
    in the next step:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`Text`元素来显示每个新字体系列/变体中的文本。请注意，由于JSX表达式要求只有一个父节点，我们还需要将所有的`Text`元素包装在另一个`View`元素中。我们现在还将`style`属性传递给一个样式数组，以便在下一步中应用`fontSize`和`padding`样式：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All that''s left to apply our custom fonts is to add the new styles to the
    `StyleSheet`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是将我们的自定义字体应用到`StyleSheet`中的新样式：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, in our app, we''ll see six different text elements, each styled with its
    own custom font:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的应用程序中，我们将看到六个不同的文本元素，每个都使用自己的自定义字体样式：
- en: '![](assets/ea1e48cb-17e9-490d-bd1a-2eca8180b23c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea1e48cb-17e9-490d-bd1a-2eca8180b23c.png)'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 5* and *step 6*, we used the `componentDidMount` React life cycle hook 
    to tell when our app finishes loading. While it may seem tempting to use `componentWillMount`,
    this too will throw an error, since `componentWillMount` is not guaranteed to
    wait for our `Font.loadAsync` to finish. By using `componentDidMount`, we can
    also assure we are not blocking the initial rendering of the app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*和*步骤6*中，我们使用了`componentDidMount` React生命周期钩子来告诉我们的应用程序何时完成加载。虽然使用`componentWillMount`可能很诱人，但这也会引发错误，因为`componentWillMount`不能保证等待我们的`Font.loadAsync`完成。通过使用`componentDidMount`，我们还可以确保不阻止应用程序的初始渲染。
- en: In *step 9*, we used the ES6 feature `async`/`await`. You're likely familiar
    with this pattern if you're a web developer, but if you'd like more information,
    I've included an awesome article from [ponyfoo.com](http://ponyfoo.com) in the
    *See also* section at the end of this recipe, which does a great job of explaining
    how `async`/`await` works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们使用了ES6特性`async`/`await`。如果您是Web开发人员，您可能已经熟悉了这种模式，但如果您想了解更多信息，我在本教程末尾的*另请参阅*部分中包含了一篇来自[ponyfoo.com](http://ponyfoo.com)的精彩文章，该文章很好地解释了`async`/`await`的工作原理。
- en: In *step 11*, we used a ternary statement to render either our custom font styled
    `Text` element if loaded, or to render nothing if it's not loaded by returning
    `null`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们使用了一个三元语句，如果加载了我们的自定义字体样式的`Text`元素，则渲染它，如果没有加载，则返回`null`。
- en: Fonts loaded through Expo don’t currently support the `fontWeight` or `fontStyle`
    properties—you will need to load those variations of the font and specify them
    by name, as we have done here with bold and italic.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Expo加载的字体目前不支持`fontWeight`或`fontStyle`属性-您需要加载字体的这些变体，并按名称指定它们，就像我们在这里使用粗体和斜体一样。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A great article on `async`/`await` can be found at [https://ponyfoo.com/articles/understanding-javascript-async-await](https://ponyfoo.com/articles/understanding-javascript-async-await).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`async`/`await`的一篇很棒的文章可以在[https://ponyfoo.com/articles/understanding-javascript-async-await](https://ponyfoo.com/articles/understanding-javascript-async-await)找到。
- en: Using font icons
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字体图标
- en: Icons are an indispensable part of almost any app, particularly in navigation
    and buttons. Similar to Expo's font helper, covered in the previous chapter, Expo
    also has an icon helper that makes adding icon fonts much less of a hassle than
    using vanilla React Native. In this recipe, we'll see how to use the icon helper
    module with the popular `FontAwesome` and `Ionicons` icon font libraries.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图标是几乎任何应用程序的必不可少的部分，特别是在导航和按钮中。与上一章中介绍的Expo字体助手类似，Expo还有一个图标助手，使添加图标字体比使用原始的React
    Native要方便得多。在这个示例中，我们将看到如何使用图标助手模块与流行的`FontAwesome`和`Ionicons`图标字体库。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to make a new project for this recipe. Let's name this project `font-icons`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个示例创建一个新项目。让我们将这个项目命名为`font-icons`。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'We''ll begin by opening `App.js` and importing the dependencies that we need
    to build the app:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先打开`App.js`并导入构建应用程序所需的依赖项：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we can add the shell of the application, where we will display the icons:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加应用程序的外壳，我们将在其中显示图标：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside of the `View` element, let''s add two more `View` elements for holding
    icons from each icon set:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`View`元素内，让我们再添加两个`View`元素来容纳每个图标集中的图标：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s add the styles for each of our declared elements. As we''ve seen
    in previous recipes, the `container` styles fill the screen with `flex: 1` and
    center the items with `alignItems` and `justifyContent` set to `center`. The `iconRow`
    property sets the `flexDirection` to `row` so that our icons will be lined up
    in a row:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们为我们声明的每个元素添加样式。正如我们在之前的示例中看到的，`container`样式使用`flex: 1`填充屏幕，并使用`alignItems`和`justifyContent`将项目居中设置为`center`。`iconRow`属性将`flexDirection`设置为`row`，这样我们的图标将排成一行：'
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that the basic structure of our app is in place, let''s add our icons.
    In the first row of icons, we''ll use four `FontAwesome` components to display
    four icons from the `FontAwesome` font library. The `name` property determines
    which icon should be used, the `size` property sets the size of the icon in pixels,
    and the `color` sets what color the icon should be:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的应用程序的基本结构已经就位，让我们添加我们的图标。在第一行图标中，我们将使用四个`FontAwesome`组件来显示`FontAwesome`字体库中的四个图标。`name`属性确定应该使用哪个图标，`size`属性设置图标的像素大小，`color`设置图标的颜色：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Just as in CSS, the `color` property can be a color keyword defined in the CSS
    specification (you can check out the full list in the MDN docs at [https://developer.mozilla.org/en-US/docs/Web/CSS/color_value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)),
    or a hex code for a given color.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在CSS中一样，`color`属性可以是CSS规范中定义的颜色关键字（您可以在MDN文档的完整列表中查看[https://developer.mozilla.org/en-US/docs/Web/CSS/color_value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)），也可以是给定颜色的十六进制代码。
- en: 'In the next `View` element, we''ll add icons from the `Ionicons` font library.
    As you can see, the `Ionicons` element takes the same properties as the `FontAwesome`
    elements used in the previous step:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的`View`元素中，我们将添加来自`Ionicons`字体库的图标。正如您所看到的，`Ionicons`元素接受与上一步中使用的`FontAwesome`元素相同的属性：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last step in this recipe is to add the remaining style, `iconPadding`,
    which just adds some padding to evenly space out each of our icons:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个配方的最后一步是添加剩下的样式`iconPadding`，它只是为每个图标添加一些填充，以均匀地间隔开每个图标：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That''s all it takes! When we check out our app, there will be two rows of
    icons, each row showcasing icons from `FontAwesome` and `Ionicons` respectively:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！当我们查看我们的应用程序时，将会有两行图标，每一行分别展示来自`FontAwesome`和`Ionicons`的图标：
- en: '![](assets/f7371449-caec-4c4a-9993-256cecd34e81.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7371449-caec-4c4a-9993-256cecd34e81.png)'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `vector-icons` package that comes with Expo provides access to 11 full icon
    sets. All you have to do is import the associated component (for example, the
    `FontAwesome` component for Font Awesome icons) and provide it with the name that
    corresponds to the icon in the set that you'd like to use. You can find a full,
    searchable list of all the icons you can use with the `vector-icons` helper library
    in the `vector-icons` directory, hosted at [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/).
    Simply set the element's `name` property to the icon name listed in the directory,
    add `size` and `color` properties, and you're done!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Expo提供的`vector-icons`包可以访问11个完整的图标集。你所需要做的就是导入相关的组件（例如，`FontAwesome`组件用于Font
    Awesome图标），并为其提供与你想要使用的图标集中相对应的图标名称。你可以在`vector-icons`目录中找到一个完整的、可搜索的图标列表，该目录托管在[https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/)。只需将元素的`name`属性设置为目录中列出的图标名称，添加`size`和`color`属性，就完成了！
- en: As the GitHub README for `vector-icons` states, this library is a compatibility
    layer created for using the icons provided by the `react-native-vector-icons`
    package in Expo. You can find this package at [https://github.com/oblador/react-native-vector-icons](https://github.com/oblador/react-native-vector-icons).
    If you are building a React Native app without Expo, you can get the same functionality
    by using the `react-native-vector-icons` library instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如GitHub上`vector-icons`的README所述，这个库是为了在Expo中使用`react-native-vector-icons`包提供的图标而创建的兼容层。你可以在[https://github.com/oblador/react-native-vector-icons](https://github.com/oblador/react-native-vector-icons)找到这个包。如果你正在构建一个没有Expo的React
    Native应用程序，你可以使用`react-native-vector-icons`库来获得相同的功能。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A catalog of all of the icons available in the `vector-icons` library can be
    found at [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector-icons`库中所有可用图标的目录可以在[https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/)找到。'
