- en: Build a Full Stack Social Media Application with React Native and GraphQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和GraphQL构建全栈社交媒体应用程序
- en: By now, you can almost call yourself an expert with React Native, as you're
    about to start working on the most complex application of the React Native sections.
    A great advantage of mobile applications is that you can send direct notifications
    to the people that have your application installed. That way, you can target users
    when there's an important event taking place in your application or when someone
    hasn't used the application for a while. Also, mobile applications can directly
    use the camera of the device it's running on to take photos and videos.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你几乎可以称自己是React Native的专家了，因为你即将开始在React Native部分中工作最复杂的应用程序。移动应用程序的一个巨大优势是，你可以直接向安装了你的应用程序的人发送通知。这样，你可以在应用程序中发生重要事件或有人很久没有使用应用程序时，针对用户。此外，移动应用程序可以直接使用设备的相机拍照和录像。
- en: In the previous chapter, you created a mobile messaging application that has
    an authentication flow and real-time data and uses GraphQL with React Native.
    These patterns and techniques will also be used in this chapter to create a mobile
    social media application that lets you post images to a social feed and allows
    you to star and comment on these posts. Not only will using the camera be an important
    section in this chapter, but you'll also add the possibility to send notifications
    to the user with Expo.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了一个移动消息应用程序，具有身份验证流程和实时数据，并使用React Native的GraphQL。这些模式和技术也将在本章中使用，以创建一个移动社交媒体应用程序，让你将图片发布到社交动态，并允许你对这些帖子进行点赞和评论。在本章中，使用相机不仅是一个重要的部分，还将添加使用Expo向用户发送通知的可能性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using the camera with React Native and Expo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Native和Expo的相机
- en: Refreshing data with React Native and GraphQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Native和GraphQL刷新数据
- en: Sending mobile notifications with Expo
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Expo发送移动通知
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: A mobile social media application that is using a local GraphQL server to request
    and add posts to the social feed, including using the camera on the mobile device.
    Basic authentication is added using the local GraphQL server and React Navigation,
    while Expo is used for access to the camera (roll) and for sending notifications
    when new comments are added to your posts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个移动社交媒体应用程序，使用本地GraphQL服务器请求和添加帖子到社交动态，包括使用移动设备上的相机。使用本地GraphQL服务器和React Navigation添加基本身份验证，同时使用Expo访问相机（滚动）并在添加新评论时发送通知。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch11-initial](https://github.com/PacktPublishing/React-Projects/tree/ch11-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch11](https://github.com/PacktPublishing/React-Projects/tree/ch11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中创建的项目基于GitHub上的初始版本：[https://github.com/PacktPublishing/React-Projects/tree/ch11-initial](https://github.com/PacktPublishing/React-Projects/tree/ch11-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch11](https://github.com/PacktPublishing/React-Projects/tree/ch11)。
- en: You need to have the application Expo Client installed on a mobile iOS or Android
    device to run the project on a physical device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在移动iOS或Android设备上安装Expo Client应用程序，才能在物理设备上运行项目。
- en: It's **highly recommended** to use the Expo Client application to run the project
    from this chapter on a physical device. Receiving notifications is currently only
    supported on physical devices, and running the project on either the iOS simulator
    or Android Studio emulator will result in error messages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议使用Expo Client应用程序在物理设备上运行本章的项目。目前，仅支持在物理设备上接收通知，并且在iOS模拟器或Android Studio模拟器上运行项目将导致错误消息。
- en: 'Alternatively, you can install either Xcode or Android Studio on your computer
    to run the application on a virtual device:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在计算机上安装Xcode或Android Studio来在虚拟设备上运行应用程序：
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于iOS**：可以在这里找到如何设置本地机器以运行iOS模拟器的信息：[https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/)。'
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/).
    There''s a known issue when running the emulator, which can be prevented by ensuring
    that the following lines are present in your `~/.bash_profile` or `~/.bash_rc`  file:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Android**：可以在这里找到如何设置本地机器以从Android Studio运行模拟器的信息：[https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/)。在运行模拟器时存在已知问题，可以通过确保以下行存在于您的`~/.bash_profile`或`~/.bash_rc`文件中来防止这种情况：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value for `ANDROID_SDK_LOCATION` is the path to the Android SDK on your
    local machine and can be found by opening Android Studio and going to **Preferences** | **Appearance
    & Behavior** *|* **System Settings** | **Android SDK**. The path is listed in
    the box that states the Android SDK locationand looks like this: `/Users/myuser/Library/Android/sdk`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANDROID_SDK_LOCATION`的值是本地机器上Android SDK的路径，可以通过打开Android Studio并转到**首选项**|**外观和行为**|**系统设置**|**Android
    SDK**来找到。路径在声明Android SDK位置的框中列出，看起来像这样：`/Users/myuser/Library/Android/sdk`。'
- en: This application was created using **Expo SDK version 33.0.0,** and so, you
    need to ensure that the version of Expo you're using on your local machine is
    similar. As React Native and Expo are frequently updated, make sure that you're
    working with this version so that the patterns described in this chapter behave
    as expected. In case your application doesn’t start or if you encounter errors,
    refer to the Expo documentation to learn more about updating the Expo SDK.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序是使用**Expo SDK版本33.0.0**创建的，因此，您需要确保您在本地机器上使用的Expo版本类似。由于React Native和Expo经常更新，请确保您使用此版本，以便本章中描述的模式表现如预期。如果您的应用程序无法启动或遇到错误，请参考Expo文档，了解有关更新Expo
    SDK的更多信息。
- en: Checking out the initial project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检出初始项目
- en: This project consists of two parts, a boilerplate React Native application and
    a GraphQL server. The React Native application can be found in the `client` directory,
    while the GraphQL server is placed in the `server` directory. For this chapter,
    you'll need to have both the application and the server running at all times,
    while you only make code changes to the application in the `client` directory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目由两部分组成，一个是样板React Native应用程序，另一个是GraphQL服务器。 React Native应用程序位于`client`目录中，而GraphQL服务器放置在`server`目录中。在本章中，您需要始终同时运行应用程序和服务器，而只对`client`目录中的应用程序进行代码更改。
- en: 'To get started you''ll need to run the following command in both the `client` and `server` directories
    to install all of the dependencies and start both the server and application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要在`client`和`server`目录中运行以下命令，以安装所有依赖项并启动服务器和应用程序：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the mobile application, this command will start Expo after installing the
    dependencies, and it gives you the ability to start your project both from the
    Terminal or your browser. In the Terminal, you can now either use the QR code
    to open the application on your mobile device or open the application in a simulator.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动应用程序，此命令将在安装依赖项后启动Expo，并使您能够从终端或浏览器启动项目。在终端中，您现在可以使用QR码在移动设备上打开应用程序，或者在模拟器中打开应用程序。
- en: The local GraphQL server for this project is running on `http://localhost:4000/graphql/`, but
    to be able to use this endpoint in the React Native application, you need to find
    the local IP address of your machine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的本地GraphQL服务器正在运行`http://localhost:4000/graphql/`，但为了能够在React Native应用程序中使用此端点，您需要找到您机器的本地IP地址。
- en: 'To find your local IP address, you''ll need to do the following depending on
    your operating system:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找本地IP地址，您需要根据您的操作系统执行以下操作：
- en: '**For Windows**: Open the Terminal (or command prompt) and run this command:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Windows**：打开终端（或命令提示符）并运行此命令：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will return a list like the one you see below with data from your local
    machine. In this list, you need to look for the field **IPv4 Address**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个类似下面所见的列表，其中包含来自您本地机器的数据。在此列表中，您需要查找字段**IPv4地址**：
- en: '![](assets/f91e2398-5dc0-4091-ba7e-90f29bf63aac.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f91e2398-5dc0-4091-ba7e-90f29bf63aac.png)'
- en: '**For macOS**: Open the Terminal and run this command:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于macOS**：打开终端并运行此命令：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running this command, the local `Ipv4 Address` of your machine gets returned,
    which looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，将返回您机器的本地`Ipv4地址`，看起来像这样：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The local IP address must be used to create the value for `API_URL` in the
    file `client/App.js`, with the prefix `http://` and suffix `/graphql`, making
    it look like `http://192.168.1.107/graphql`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用本地IP地址来创建文件`client/App.js`中的`API_URL`的值，前缀为`http://`，后缀为`/graphql`，使其看起来像`http://192.168.1.107/graphql`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'No matter whether you''ve opened the application from virtual or physical device,
    the application at this point should look something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是从虚拟设备还是物理设备打开应用程序，此时应用程序应该看起来像这样：
- en: '![](assets/f5b65733-4019-44b8-8c29-afa114d8695f.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f5b65733-4019-44b8-8c29-afa114d8695f.jpg)'
- en: This application was created using **Expo SDK version 33.0.0** and therefore
    you need to make sure the version of Expo you're using on your local machine is
    similar. As React Native and Expo are updated frequently, make sure that you're
    working with this version to ensure the patterns described in this chapter are
    behaving as expected. If your application won't start or you're receiving errors,
    make sure to check the Expo documentation to learn more about updating the Expo
    SDK.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序是使用**Expo SDK版本33.0.0**创建的，因此您需要确保您本地机器上使用的Expo版本类似。由于React Native和Expo经常更新，请确保您使用此版本，以确保本章中描述的模式表现如预期。如果您的应用程序无法启动或收到错误消息，请务必查看Expo文档，以了解有关更新Expo
    SDK的更多信息。
- en: 'The initial application consists of seven screens: `AddPost`,  `AuthLoading`, `Login`, 
    `Notifications`, `Post`, `Posts`, and `Settings`. The `Login` screen will be the
    first screen you''ll see when first starting the application, where you can log
    in using the following credentials:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 初始应用程序由七个屏幕组成：`AddPost`、`AuthLoading`、`Login`、`Notifications`、`Post`、`Posts`和`Settings`。当首次启动应用程序时，您将看到`Login`屏幕，您可以使用以下凭据登录：
- en: '**Username**: `test`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：`test`'
- en: '**Password**: `test`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：`test`'
- en: The `Posts` screen will be the initial screen when logged in and shows a list
    of posts on which you can tap to continue to the `Post` screen, while the `Settings` screens
    shows a non-functioning logout button. For now, the `AddPost` and `Notification` screens
    aren't visible yet, as you'll add the routing to these screens later on in this
    chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Posts` 屏幕将是登录后的初始屏幕，显示一个帖子列表，您可以点击继续到`Post`屏幕，而`Settings`屏幕显示一个无效的注销按钮。目前，`AddPost`和`Notification`屏幕尚不可见，因为您将在本章后面添加到这些屏幕的路由。'
- en: 'The project structure from this React Native application in the `directory` client is
    as follows, where the structure is similar to the projects you''ve created before
    in this book:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: React Native应用程序中的项目结构在`directory` client 中如下，结构类似于您在本书中之前创建的项目：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `assets` directory,  you can find the images that are used as the application
    icon on the home screen once you've installed this application on your mobile
    device, and the image that will serve as the splash screen that is displayed when
    you start the application. For example, configurations in the App Store for the
    name of your application are placed in `app.json`, while `babel.config.js` holds
    specific Babel configurations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`assets`目录中，您可以找到用作应用程序图标的图像，一旦您在移动设备上安装了该应用程序，它将显示在主屏幕上，以及作为启动画面的图像，当您启动应用程序时显示。例如，应用程序名称的App
    Store配置放在`app.json`中，而`babel.config.js`包含特定的Babel配置。
- en: The `App.js` file is the actual entry point of your application, where the `AppContainer.js` file is
    being imported and returned. In `AppContainer`, all of the routes for this application
    are defined and `AppContext` will contain information that should be available
    in the entire application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`文件是您的应用程序的实际入口点，其中导入并返回`AppContainer.js`文件。在`AppContainer`中，定义了该应用程序的所有路由，`AppContext`将包含应该在整个应用程序中可用的信息。'
- en: 'All of the components for this application are located in the `Screens` and `Components` directories,
    where the first one holds the components that are rendered by the screens. The
    child components for these screens can be found in the `Components` directory, which
    has the following structure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的所有组件都位于`Screens`和`Components`目录中，其中第一个包含由屏幕呈现的组件。这些屏幕的子组件可以在`Components`目录中找到，其结构如下：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The GraphQL server can be found at the `http://localhost:4000/graphql` URL,
    where GraphQL Playground will be visible. From this playground, you can view the
    schema for the GraphQL server and inspect all of the available queries, mutations,
    and subscriptions. Although you won't be making any code changes to the server,
    it's important to know about the schema and its workings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL服务器可以在`http://localhost:4000/graphql` URL找到，GraphQL Playground将可见。从这个playground，您可以查看GraphQL服务器的模式，并检查所有可用的查询、变异和订阅。虽然您不会对服务器进行任何代码更改，但了解模式及其工作原理是很重要的。
- en: 'The server has two queries to retrieve a list of posts or a single post by
    using the `userName` parameter as the identifier. These queries will return the
    `Post` type that has `id`, `userName`, `image`, a counted value of `stars` and
    `comments`, a list of stars of the `stars` type, and a list of `comments` with
    the `Comment` type. The query to retrieve a single post will look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有两个查询，通过使用`userName`参数作为标识符来检索帖子列表或单个帖子。这些查询将返回具有`id`、`userName`、`image`、`stars`和`comments`计数值的`Post`类型，`stars`类型的星星列表，以及具有`Comment`类型的`comments`列表。检索单个帖子的查询将如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After this, three mutations can be found for the GraphQL server, which are to
    either log in the user, store a push token from Expo, or add a post.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以在GraphQL服务器中找到三个变异，用于登录用户、存储来自Expo的推送令牌，或添加帖子。
- en: If you're receiving an error stating `Please provide (valid) authentication details`,
    you'll need to log in to the application again. Probably, the JWT from the previous
    application is still available in `AsyncStorage` of Expo, and this will not validate
    on the GraphQL server for this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到错误消息“请提供（有效的）身份验证详细信息”，则需要重新登录应用程序。可能，上一个应用程序的JWT仍然存储在Expo的`AsyncStorage`中，并且这将无法在本章的GraphQL服务器上验证。
- en: Building a full stack social media application with React Native, Apollo, and
    GraphQL
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native、Apollo和GraphQL构建全栈社交媒体应用程序
- en: The application that you're going to build in this chapter will use a local
    GraphQL server to retrieve and mutate data that is available in the application.
    This application will display data from a social media feed and let you respond
    to these social media posts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中要构建的应用程序将使用本地GraphQL服务器来检索和改变应用程序中可用的数据。该应用程序将显示来自社交媒体动态的数据，并允许您对这些社交媒体帖子进行回复。
- en: Using the camera with React Native and Expo
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和Expo的相机
- en: Next to displaying the posts that were created by the GraphQL server, you can
    also add a post yourself using a GraphQL mutation and send a text and an image
    as variables. Uploading images to your React Native application can be done by
    using either the camera to take an image or by selecting an image from your camera
    roll. For both use cases, there are APIs available from React Native and Expo,
    or numerous packages that are installable from `npm`. For this project, you'll
    use the ImagePicker API from Expo, which combines these functionalities into just
    one component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示由GraphQL服务器创建的帖子之外，您还可以使用GraphQL mutation自己添加帖子，并将文本和图像作为变量发送。将图像上传到您的React
    Native应用程序可以通过使用相机拍摄图像或从相机滚动中选择图像来完成。对于这两种用例，React Native和Expo都提供了API，或者可以从`npm`安装许多包。对于此项目，您将使用Expo的ImagePicker
    API，它将这些功能合并到一个组件中。
- en: 'To add the feature to create new posts to your social media application, the
    following changes need to be made to create the new screen to add the post:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要向您的社交媒体应用程序添加创建新帖子的功能，需要进行以下更改以创建新的添加帖子屏幕：
- en: 'The GraphQL mutation that can be used to add a post to the feed you see in
    the `Main` screen sends the image variable to the GraphQL server. This mutation
    has the following form:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用的GraphQL mutation用于向您在`Main`屏幕中看到的动态中添加帖子，它将图像变量发送到GraphQL服务器。此mutation具有以下形式：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `image` variable is `String` and is the URL to the absolute path of the
    image for this post. This GraphQL mutation needs to be added to the bottom of
    the `client/constants.js` file so it can be used from a `useMutation` Hook later
    on:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`变量是`String`，是此帖子的图像的绝对路径的URL。此GraphQL mutation需要添加到`client/constants.js`文件的底部，以便稍后可以从`useMutation`
    Hook中使用：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With `Mutation` in place, the screen for adding the post must be added to `SwitchNavigator`
    in the `client/AppContainer.js` file. The `AddPost` screen component can be found
    in the `client/Screens/AddPost.js` file and should be added as a modal in the
    navigator:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了`Mutation`，必须将添加帖子的屏幕添加到`client/AppContainer.js`文件中的`SwitchNavigator`。`AddPost`屏幕组件可以在`client/Screens/AddPost.js`文件中找到，并应作为导航器中的模态添加：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And of course, the user must be able to open this modal from somewhere in your
    application, for example, from the tab navigator at the bottom of the screen or
    the header. For this scenario, you can add the navigation link to the `AddPost`
    screen in the header—that way, the user can add a new post from the `Posts` screen
    only by tapping a link in the header. This link can be added by setting `navigationOptions`
    in the `client/Screens/Posts.js` file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，用户必须能够从应用程序的某个位置打开这个模态框，例如，从屏幕底部的选项卡导航器或标题栏。对于这种情况，您可以在`client/Screens/Posts.js`文件中设置`navigationOptions`来在标题栏中添加导航链接到`AddPost`屏幕：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By setting the `headerRight` field in `navigationOptions`, only the right part
    of the header will be changed and the title that has been set from the navigator
    will keep in place. Tapping the `Add Post` link will now navigate to the `AddPost`
    screen, where a title and button to close the modal are displayed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`navigationOptions`中设置`headerRight`字段，只会更改标题的右侧部分，而导航器设置的标题将保持不变。现在点击`Add
    Post`链接将导航到`AddPost`屏幕，显示标题和关闭模态框的按钮。
- en: 'As you''ve now added the `AddPost` screen, the ImagePicker API from Expo should
    be added to this screen. To add `ImagePicker` to the `AddPost` screen, follow
    the next steps to enable the selection of photos from the camera roll in the `client/Screens/AddPost.js` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了`AddPost`屏幕，Expo的ImagePicker API应该被添加到这个屏幕上。要将`ImagePicker`添加到`AddPost`屏幕上，请按照以下步骤在`client/Screens/AddPost.js`文件中启用从相机滚动中选择照片：
- en: 'Before the user can select photos from the camera roll, the right permission
    should be set for the application when the user is using an iOS device. To request
    permissions, you can use the permissions API from Expo, which should request `CAMERA_ROLL`
    permissions. The permissions API used to be available directly from Expo, but
    has been moved to a separate package called `expo-permissions` that can be installed
    from the Expo CLI by running this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户可以从相机滚动中选择照片之前，当用户使用iOS设备时，应该为应用程序设置正确的权限。要请求权限，您可以使用Expo的权限API，它应该请求`CAMERA_ROLL`权限。权限API曾经直接从Expo可用，但现在已经移动到一个名为`expo-permissions`的单独包中，可以通过Expo
    CLI安装，方法是运行以下命令：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After this, you can import the permissions API and create the function to check
    whether the right permissions have been granted for the camera roll:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以导入权限API并创建函数来检查是否已经为相机滚动授予了正确的权限：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `getPermissionAsync` function is asynchronous and can be called from a
    `Button` or `Touchable` element. At the bottom of this file, the `UploadImage` component can
    be found, which is a styled `TouchableOpacity` element that can take an `onPress` function.
    This component must be added to the return function of `AddPost` and should call
    the `getPermissionAsync` function when tapped:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`getPermissionAsync`函数是异步的，可以从`Button`或`Touchable`元素中调用。在文件底部可以找到`UploadImage`组件，它是一个带有`onPress`函数的样式化`TouchableOpacity`元素。这个组件必须添加到`AddPost`的返回函数中，并在点击时调用`getPermissionAsync`函数：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When tapped, a popup requesting permission to access the camera roll will be
    opened on iOS devices. When you don't accept the request, you can't select photos
    from the camera roll.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS设备上点击时，将打开一个请求访问相机滚动权限的弹出窗口。如果您不接受请求，就无法从相机滚动中选择照片。
- en: You can't ask the user for permission a second time; instead, you'd need to
    manually grant the permission to the camera roll. To set this permission again,
    you should go to the setting screen from iOS and select the Expo application.
    On the next screen, you're able to add the permission to access the camera.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能再次要求用户授予权限；相反，您需要手动授予对摄像机滚动的权限。要再次设置这个权限，您应该从iOS的设置屏幕进入，并选择Expo应用程序。在下一个屏幕上，您可以添加访问摄像机的权限。
- en: 'When the user has granted permission to access the camera roll, you can call
    the ImagePicker API from Expo to open the camera roll. Just like the permissions
    API, this used to be part of Expo''s core, but has now been moved to a separate
    package that you can install using the Expo CLI:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户已经授予访问摄像机滚动的权限时，您可以调用Expo的ImagePicker API来打开摄像机滚动。就像权限API一样，这曾经是Expo核心的一部分，但现在已经移动到一个单独的包中，您可以使用Expo
    CLI安装：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is again an asynchronous function that takes some configuration fields
    such as the aspect ratio. If the user has selected an image, the ImagePicker API
    will return an object containing the field URI, which is the URL to the image
    on the users'' device that can be used in an `Image` component. This result can
    be stored in a local state by creating one with the `useState` Hook, so it can
    be sent to the GraphQL server later on:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个再次使用异步函数，它接受一些配置字段，比如宽高比。如果用户选择了一张图片，ImagePicker API将返回一个包含字段URI的对象，该字段是用户设备上图片的URL，可以在`Image`组件中使用。可以通过使用`useState`
    Hook创建一个本地状态来存储这个结果，以便稍后将其发送到GraphQL服务器：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And this `pickImageAsync` function can then be called from the function to
    get the users'' permissions when they''ve been granted for the camera roll:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以从函数中调用`pickImageAsync`函数，以获取用户在摄像机滚动时授予的权限：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As the URL to the image is now stored in the local state to the `imageUrl` constant,
    you can display this URL in an `Image` component. This `Image` component takes `imageUrl`
    as value for the source and has been set to use a 100% `width` and `height`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于图片的URL已经存储在本地状态中的`imageUrl`常量中，您可以在`Image`组件中显示这个URL。这个`Image`组件以`imageUrl`作为源的值，并且已经设置为使用100%的`width`和`height`：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these changes, the `AddPost` screen should look something like the following
    screenshot, which was taken from a device running iOS. There might be slight differences
    in the appearance of this screen if you''re using the Android Studio emulator
    or a device that runs Android:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，`AddPost`屏幕应该看起来像下面的截图，这是从运行iOS的设备上获取的。如果您使用Android Studio模拟器或运行Android的设备，这个屏幕的外观可能会有轻微的差异：
- en: '![](assets/cae322ec-d489-4df3-924c-08de3f1fb3ea.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cae322ec-d489-4df3-924c-08de3f1fb3ea.png)'
- en: These changes will make it possible to select a photo from your camera roll,
    but your users should also be able to upload an entirely new photo by using their
    camera. With the ImagePicker from Expo, you can handle both scenarios, as this
    component also has a `launchCameraAsync` method. This asynchronous function will
    launch the camera, and return it the same way as it returns a URL to the image
    from the camera roll.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将使从摄像机滚动中选择照片成为可能，但您的用户还应该能够通过使用他们的摄像机上传全新的照片。使用Expo的ImagePicker，您可以处理这两种情况，因为这个组件还有一个`launchCameraAsync`方法。这个异步函数将启动摄像机，并以与从摄像机滚动中返回图片的URL相同的方式返回它。
- en: 'To add the functionality to directly use the camera on the user''s device to
    upload an image, you can make the following changes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加直接使用用户设备上的摄像机上传图片的功能，可以进行以下更改：
- en: 'As the user needs to grant your application permission to access the camera
    roll, the user needs to do the same for using the camera. Permission to use the
    camera can be requested by sending `Permissions.CAMERA` with the `Permissions.askAsync` method.
    The check for the granted permission for the camera roll must be extended to also
    check for the camera permission:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于用户需要授予您的应用程序访问相机滚动条的权限，因此用户需要做同样的事情来使用相机。可以通过使用`Permissions.askAsync`方法发送`Permissions.CAMERA`来请求使用相机的权限。必须扩展对相机滚动条的授予权限的检查，以便还检查相机权限：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will ask the user for permission to use the camera on iOS, which can also
    be granted manually by going to Settings | Expo.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在iOS上要求用户允许使用相机，也可以通过转到设置| Expo手动授予权限。
- en: 'With the permission granted, you can continue by creating the function to launch
    the camera by calling `launchCameraAsync` from `ImagePicker`. The functionality
    is the same as for the `launchCameraAsync` function that you created to open the
    camera roll; therefore, the `pickImageAsync` function can be edited to also be
    able to launch the camera:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获得权限后，您可以通过调用`ImagePicker`中的`launchCameraAsync`函数来创建启动相机的功能。该功能与您创建的用于打开相机滚动条的`launchCameraAsync`函数相同；因此，`pickImageAsync`函数也可以编辑为能够启动相机：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you now send a parameter to the `addImageAsync` function, `launchCameraAsync` will
    be called. Otherwise, the user will be directed to the camera roll on their device.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在向`addImageAsync`函数发送参数，将调用`launchCameraAsync`。否则，用户将被引导到其设备上的相机滚动条。
- en: 'When the user clicks on the image placeholder, the image roll will be opened
    by default. But you also want to give the user the option to use their camera.
    Therefore, a selection must be made between using the camera or the camera roll
    for uploading the image, which is a perfect use case for implementing an `ActionSheet`
    component. React Native and Expo both have an `ActionSheet` component; it''s advisable
    to use the one from Expo as it will use the native `UIActionSheet` component on
    iOS and a JavaScript implementation for Android. The `ActionSheet` component is
    available from Expo''s `react-native-action-sheet` package, which you can install
    from `npm`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击图像占位符时，默认情况下将打开图像滚动条。但您还希望给用户选择使用他们的相机的选项。因此，必须在使用相机或相机滚动条上传图像之间进行选择，这是实现`ActionSheet`组件的完美用例。React
    Native和Expo都有一个`ActionSheet`组件；建议使用Expo中的组件，因为它将在iOS上使用本机的`UIActionSheet`组件，在Android上使用JavaScript实现。`ActionSheet`组件可从Expo的`react-native-action-sheet`软件包中获得，您可以从`npm`安装。
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After this, you need to wrap your top-level component in the `client/App.js` file with
    `Provider` from the package, which is comparable to adding `ApolloProvider`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要在`client/App.js`文件中使用来自该软件包的`Provider`将顶级组件包装起来，这类似于添加`ApolloProvider`：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And create `ActionSheet` in `client/Screens/AddPost.js` by importing the `connectActionSheet` function
    from `react-native-action-sheet`, which needs to wrap the `AddPost` component before
    you export it. Wrapping the `AddPost` component with `connectActionSheet()` adds
    the `showActionSheetWithOptions` prop to the component, which you''ll use in the
    next step to create `ActionSheet`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client/Screens/AddPost.js`中通过从`react-native-action-sheet`导入`connectActionSheet`函数来创建`ActionSheet`，在导出之前需要将`AddPost`组件包装起来。使用`connectActionSheet()`将`AddPost`组件包装起来，将`showActionSheetWithOptions`属性添加到组件中，你将在下一步中使用它来创建`ActionSheet`：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To add `ActionSheet`, a function to open this `ActionSheet` must be added,
    and by using the `showActionSheetWithOptions` prop and the options, `ActionSheet`
    should be constructed. The options are `Camera`, `Camera roll`, and `Cancel`,
    where selecting the first option should call the `addImageAsync` function with
    a parameter, the second should call that function without a parameter, and the
    last option is to close `ActionSheet`. The function to open `ActionSheet` must
    be added to the `getPermissionsAsync` function and be called when the permissions
    for both `Camera` and `Camera roll` are granted:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`ActionSheet`，必须添加一个打开`ActionSheet`的函数，并使用`showActionSheetWithOptions`属性和选项来构造`ActionSheet`。选项包括`相机`、`相机相册`和`取消`，选择第一个选项应该调用带有参数的`addImageAsync`函数，第二个选项应该调用不带参数的函数，最后一个选项是关闭`ActionSheet`。打开`ActionSheet`的函数必须添加到`getPermissionsAsync`函数中，并在`相机`和`相机相册`的权限都被授予时调用：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Tapping the image placeholder will give the user the option to either use `Camera`
    or `Camera roll` to add an image to the `AddPost` component. This can be done
    from `ActionSheet`, which will look different on iOS and Android. In the following
    screenshot, you can see what this will look like when using the iOS simulator
    or a device that runs on iOS:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击图像占位符将给用户选择使用`相机`或`相机相册`向`AddPost`组件添加图像的选项。这可以通过`ActionSheet`来实现，在iOS和Android上看起来会有所不同。在下面的截图中，您可以看到在使用iOS模拟器或运行iOS的设备时的效果：
- en: '![](assets/341ba1a8-17f2-4761-8fcf-b0f5e3d374ff.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/341ba1a8-17f2-4761-8fcf-b0f5e3d374ff.png)'
- en: 'This, however, is not all as the image must still be sent to the server to
    appear in the feed of the application, by adding a `useMutation` Hook from `@apollo/react-hooks`
    and using the returned `addPost` function to send the `imageUrl` variable in a
    document to the GraphQL server. The mutation to add the post has been mentioned
    at the beginning of this section and can be imported from the `client/constants.js` file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这还不是全部，因为图像仍然必须发送到服务器才能出现在应用程序的动态中，通过从`@apollo/react-hooks`中添加`useMutation`
    Hook，并使用返回的`addPost`函数将`imageUrl`变量发送到GraphQL服务器的文档中。在本节的开头已经提到了添加帖子的变异，并可以从`client/constants.js`文件中导入：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The image will be added as a post after tapping the `Submit` button, and the
    user will be redirected to the `Main` screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`提交`按钮后，图像将作为帖子添加，并且用户将被重定向到`Main`屏幕。
- en: 'By setting a query on the `refetchQueries` variable to the `useMutation` Hook,
    the posts on the `Main` screen can be reloaded and the post you''ve just added
    will be displayed in this list. The posts can be retrieved by fetching the `GET_POSTS`
    query from `client/constants.js`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`refetchQueries`变量上的查询设置为`useMutation` Hook，可以重新加载`Main`屏幕上的帖子，并在此列表中显示您刚刚添加的帖子。可以通过从`client/constants.js`中获取`GET_POSTS`查询来检索帖子：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Your post will now be displayed at the top of the `Main` screen, meaning you've
    added the post successfully and other users can view, star, and comment on it.
    As your users might be sending posts while the application is opened, you want
    them to be able to receive these posts. Therefore, the next section will explore
    how to achieve near real-time data from GraphQL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您的帖子现在将显示在`Main`屏幕的顶部，这意味着您已成功添加了帖子，其他用户可以查看、点赞和评论。由于用户可能在应用程序打开时发送帖子，您希望他们能够接收这些帖子。因此，接下来的部分将探讨如何从GraphQL实现近实时数据。
- en: Retrieving near real-time data using GraphQL
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraphQL检索近实时数据
- en: Other than with the messaging application, you don't want the feed with posts
    to reload every time a new post has been posted by any of the people in your network.
    Besides subscriptions, there are other ways to have (near) real-time data flows
    with GraphQL and Apollo, namely, polling. With polling, you can retrieve a query
    from a `useQuery` Hook once every `n` milliseconds, saving you the complexity
    of setting up subscriptions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消息应用程序之外，您不希望每当您的网络中的任何人发布新帖子时，就重新加载带有帖子的信息流。除了订阅之外，还有其他方法可以使用GraphQL和Apollo实现（近乎）实时数据流，即轮询。通过轮询，您可以每隔“n”毫秒从“useQuery”
    Hook中检索一个查询，而无需设置订阅的复杂性。
- en: 'Polling can be added to the `useQuery` Hook, like this one in `client/Screens/Posts.js`.
    By setting a `pollInterval` value on the object parameter from the `useQuery` Hook,
    you can specify how often the document with the `GET_POSTS` query should be resent
    by the Hook:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询可以添加到“client/Screens/Posts.js”中的“useQuery” Hook中，就像这样。通过在“useQuery” Hook的对象参数上设置“pollInterval”值，您可以指定多久应该由Hook重新发送带有“GET_POSTS”查询的文档：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This causes your `Posts` component to send a document with the `GET_POSTS` query every
    2 seconds (2,000 milliseconds), and as the GraphQL server is returning mocked
    data, the posts that are displayed will be different on every re-fetch. In comparison
    to subscriptions, polling will resend the documents to retrieve the posts even
    when there is no new data—something that isn't very useful for an application
    displaying mock data or data that changes often.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致您的“Posts”组件每2秒（2,000毫秒）发送一个带有“GET_POSTS”查询的文档，由于GraphQL服务器返回的是模拟数据，显示的帖子在每次重新获取时都会有所不同。与订阅相比，轮询会重新发送文档以检索帖子，即使没有新数据，这对于显示模拟数据或经常更改的数据的应用程序并不是很有用。
- en: Next to setting a `pollInterval` variable on the `useQuery` Hook, you can also
    manually call the `refetch` function that sends a document with the query. A common
    interaction for social media feeds is being able to pull down the displayed component
    to refresh the data on the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在“useQuery” Hook上设置“pollInterval”变量之外，您还可以手动调用“refetch”函数，该函数会发送一个带有查询的文档。社交媒体信息流的常见交互是能够下拉显示的组件以刷新屏幕上的数据。
- en: 'This pattern can also be added to your application by making the following
    changes to the `Posts` screen component:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对“Posts”屏幕组件进行以下更改，也可以将此模式添加到您的应用程序中：
- en: 'The `pollInterval` prop can be set to `0`, which disables the polling for now.
    Besides the `loading` and `data` variables, more variables can be retrieved from
    the `useQuery` Hook. One of those variables is the `refetch` function, which you
    can use to manually send the document to the server:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “pollInterval”属性可以设置为“0”，这样就暂时禁用了轮询。除了“loading”和“data”变量之外，还可以从“useQuery” Hook中检索更多变量。其中一个变量是“refetch”函数，您可以使用它手动将文档发送到服务器：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There''s a React Native component to create the pull-to-refresh interaction,
    which is called `RefreshControl` and which you should import from `react-native`.
    Also, you should import a `ScrollView` component as the `RefreshControl` component
    only works with either a `ScrollView` or `ListView` component:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个React Native组件用于创建下拉刷新交互，称为“RefreshControl”，您应该从“react-native”中导入它。此外，您还应该导入一个“ScrollView”组件，因为“RefreshControl”组件只能与“ScrollView”或“ListView”组件一起使用：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This `ScrollView` component should be wrapped around the `PostsList` component,
    which is a styled `FlatList` component that iterates over the posts created by
    the GraphQL server. As a value for the `refreshControl` prop, the `RefreshControl`
    component must be passed to this `ScrollView` and a `style` prop must be set,
    to lock the width to 100%, which makes sure you can only scroll vertically:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`ScrollView`组件应该包裹在`PostsList`组件周围，它是一个经过GraphQL服务器创建的帖子进行迭代的样式化`FlatList`组件。作为`refreshControl`属性的值，必须将`RefreshControl`组件传递给这个`ScrollView`，并且必须设置一个`style`属性，将宽度锁定为100%，以确保只能垂直滚动：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you now pull down the `Posts` screen, a loading indicator will be displayed
    at the top of the screen that keeps spinning. With the `refreshing` prop, you
    can control whether or not the loading indicator should be displayed by passing
    a value that is created by a `useState` Hook. Besides a `refreshing` prop, the
    function that should be called when the refreshing starts can be passed to the
    `onRefresh` prop. You should pass the `refetch` function to this function, which
    should set the `refreshing` state variable to `true` and call the `refetch` function
    that was returned by the `useQuery` Hook. After the `refetch` function resolves,
    the callback can be used to set the `refreshing` state to `false` again:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在下拉`Posts`屏幕，屏幕顶部将显示一个不断旋转的加载指示器。通过`refreshing`属性，您可以通过传递由`useState` Hook创建的值来控制是否应该显示加载指示器。除了`refreshing`属性，还可以将应该在刷新开始时调用的函数传递给`onRefresh`属性。您应该将`refetch`函数传递给此函数，该函数应将`refreshing`状态变量设置为`true`并调用`useQuery`
    Hook返回的`refetch`函数。在`refetch`函数解析后，回调可以用于再次将`refreshing`状态设置为`false`：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, when you pull down the `Posts` screen, the loading message returned
    from the `useQuery` Hook interferes with the loading indicator from `RefreshControl`.
    By also checking for the value of `refreshing` in the if-else statement, you can
    prevent this behavior:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当您下拉`Posts`屏幕时，从`useQuery` Hook返回的加载消息会干扰`RefreshControl`的加载指示器。通过在if-else语句中还检查`refreshing`的值，可以防止这种行为：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After these last changes, the interaction of pulling to refresh the data is
    implemented for the `Posts` screen, making it possible for your users to retrieve
    the latest data by pulling down the screen. When you''re using iOS as the operating
    system for the virtual or physical device that runs the application, this will
    look something like this screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后这些更改之后，下拉刷新`Posts`屏幕的交互已经实现，使您的用户可以通过下拉屏幕来检索最新数据。当您将iOS作为运行应用程序的虚拟或物理设备的操作系统时，它将看起来像这样的截图：
- en: '![](assets/b87269bb-aa38-4ac7-b0ee-9295ac618b14.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b87269bb-aa38-4ac7-b0ee-9295ac618b14.png)'
- en: In the next section, you'll add notifications to this social media application,
    by using Expo and GraphQL servers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将使用Expo和GraphQL服务器向这个社交媒体应用程序添加通知。
- en: Sending notifications with Expo
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Expo发送通知
- en: Another important feature for a mobile social media application is the ability
    to send users notifications of important events, for example, when their post
    gets starred or a friend has uploaded a new post. Sending notifications can be
    done with Expo and requires you to add both server- and client-side code, as the
    notifications are sent from the server. The client needs to retrieve a local identifier
    for the users' device, which is called the Expo push code. This code is needed
    to identify which device belongs to the user and how a notification should be
    sent to either iOS or Android.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 移动社交媒体应用程序的另一个重要功能是向用户发送重要事件的通知，例如，当他们的帖子被点赞或朋友上传了新帖子。使用Expo可以发送通知，并且需要添加服务器端和客户端代码，因为通知是从服务器发送的。客户端需要检索用户设备的本地标识符，称为Expo推送代码。这个代码是需要的，以确定哪个设备属于用户，以及通知应该如何发送到iOS或Android。
- en: Testing notifications can only be done by using the Expo application on your
    mobile device. iOS and Android simulators cannot receive push notifications, as
    they don't run on an actual device.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通知只能通过在您的移动设备上使用Expo应用程序来完成。iOS和Android模拟器无法接收推送通知，因为它们不在实际设备上运行。
- en: 'Retrieving the push code is the first step in sending notifications to your
    users, which consists of the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 检索推送代码是向用户发送通知的第一步，包括以下步骤：
- en: 'To be able to send notifications, users should permit your application to push
    these notifications. To ask for this permission, the same permissions API should
    be used to get permission for the camera. The function to request this permission
    can be added in a new file called `registerForPushNotificationsAsync.js`. This
    file must be created in the new `client/utils` directory, in which you can paste
    the following code that also retrieves the push code using the Notifications API:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够发送通知，用户应该允许您的应用程序推送这些通知。要请求此权限，应该使用相同的权限API来获取相机的权限。请求此权限的函数可以添加到一个名为`registerForPushNotificationsAsync.js`的新文件中。这个文件必须创建在新的`client/utils`目录中，您可以在其中粘贴以下代码，该代码还使用通知API检索推送代码：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you''re using an iOS device, the `registerForPushNotificationAsync` function
    should be called when the application opens, as you should ask for permission.
    On Android devices, the request for whether or not a user wants you to send them
    notifications is sent during the installation process. This function should, therefore,
    be fired when the user opens the application, after which this function will return
    the Expo push token on Android or launch the popup to ask for permission on iOS.
    As you only want to ask registered users for their token, this is done in the
    `client/Screens/Posts.js` file by using an `useEffect` Hook:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您使用iOS设备时，应该在应用程序打开时调用`registerForPushNotificationAsync`函数，因为您应该请求权限。在Android设备上，用户是否希望您发送通知的请求是在安装过程中发送的。因此，当用户打开应用程序时，应该触发此函数，之后此函数将在Android上返回Expo推送令牌，或在iOS上启动弹出窗口以请求权限。由于您只想要向注册用户请求他们的令牌，因此在`client/Screens/Posts.js`文件中使用`useEffect`
    Hook来完成。
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you see this error, `Error: The Expo push notification service is supported
    only for Expo projects. Ensure you are logged in to your Expo developer account
    on the computer from which you are loading your project.`*,* it means you need
    to make sure you''re logged in to your Expo developer account. By running `expo
    login` from the Terminal, you can check whether you''re logged in and otherwise,
    it will prompt you to log in again.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到此错误，“错误：Expo推送通知服务仅支持Expo项目。请确保您已登录到从中加载项目的计算机上的Expo开发人员帐户。”，这意味着您需要确保已登录到Expo开发人员帐户。通过在终端中运行`expo
    login`，您可以检查是否已登录，否则它将提示您重新登录。
- en: 'In the Terminal, the Expo push token for this user will now be displayed, which
    looks like `ExponentPushToken[AABBCC123]`. This token is unique for this device
    and can be used to send the notification. To test how a notification will look,
    you can go to the `https://expo.io/dashboard/notifications` URL in the browser
    to find the Expo dashboard. In here, you can enter the Expo push token together
    with a message and a title for the notification; depending on the mobile operating
    system, there are different options you can select, such as the ones that follow:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，现在将显示此用户的Expo推送令牌，看起来像`ExponentPushToken[AABBCC123]`。这个令牌对于这个设备是唯一的，可以用来发送通知。要测试通知的外观，您可以在浏览器中转到`https://expo.io/dashboard/notifications`的URL以找到Expo仪表板。在这里，您可以输入Expo推送令牌以及通知的消息和标题；根据移动操作系统的不同，您可以选择不同的选项，例如以下选项：
- en: '![](assets/ff6cbf7e-aa70-4994-82ac-ba1bed1205d8.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff6cbf7e-aa70-4994-82ac-ba1bed1205d8.png)'
- en: This will send a notification to your device, with the title `Test` and the
    body `This is a test`, and try to play a sound when the notification is sent.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您的设备发送一个标题为`Test`，正文为`This is a test`的通知，并在发送通知时尝试播放声音。
- en: However, this notification won't be visible on devices running on iOS when the
    application is foregrounded. So, when you're using the Expo application on an
    Apple device, make sure the Expo application is running in the background.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当应用程序在iOS设备上运行并处于前台时，此通知不会显示。因此，当您在苹果设备上使用Expo应用程序时，请确保Expo应用程序在后台运行。
- en: The next part of this section will show how you can also receive notifications
    when the application is running in the foreground.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的下一部分将展示如何在应用程序在前台运行时也可以接收通知。
- en: Handling foreground notifications
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理前台通知
- en: Handling notifications when the application is foregrounded is more complex,
    and requires us to add a listener that checks for new notifications and afterward,
    these notifications should be stored somewhere. Expo's Notifications API has a
    listener available that can help you to check for new notifications, while the
    notifications can be stored using Apollo by having a local state. This local state
    extends the data returned by the GraphQL server by adding any new notifications
    that were found by the listener.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序处于前台时处理通知更加复杂，需要我们添加一个监听器来检查新通知，然后这些通知应该被存储在某个地方。Expo的通知API提供了一个可用的监听器，可以帮助您检查新通知，而通知可以使用Apollo来存储，通过使用本地状态。这个本地状态通过添加监听器发现的任何新通知来扩展GraphQL服务器返回的数据。
- en: When the notifications are stored in the local state, this data can be queried
    and shown in either a component or a screen in your application. Let's create
    a notifications screen that will display these notifications that were sent when
    the application was loaded in the foreground.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当通知存储在本地状态中时，可以查询这些数据并在应用程序的组件或屏幕中显示。让我们创建一个通知屏幕，显示这些在应用程序在前台加载时发送的通知。
- en: 'Adding the support for foreground notifications requires you to make these
    changes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对前台通知的支持需要您进行以下更改：
- en: 'The setup for Apollo Client in `client/App.js` should be extended in a way
    that you could query for notifications and can add new notifications when these
    are spotted by the listener. A new type for `Query` should be created that is
    called `notifications` and returns a list of the `Notification` type. Also, an
    initial value for this `Query` must be added in the form of an empty array that
    will be written to `cache`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client/App.js`中Apollo Client的设置应该被扩展，以便您可以查询通知，并在监听器发现新通知时添加新通知。应该创建一个名为`notifications`的新类型`Query`，返回`Notification`类型的列表。此外，必须在`cache`中添加一个空数组的形式作为这个`Query`的初始值：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, you''re able to send a document with the query to retrieve the list of
    notifications including the `id`, `title`, and `body` fields. This query must
    also be defined in the `client/constants.js` file so it can be used from a `useQuery` Hook
    in the next step:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以发送一个带有查询的文档，以检索包括`id`、`title`和`body`字段的通知列表。这个查询也必须在`client/constants.js`文件中定义，以便在下一步中从`useQuery`
    Hook中使用。
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `client/Screens` directory, the `Notifications.js` file can be found,
    which must be used as the screen to display the notifications for the user. This
    screen component should be imported in the `client/AppContainer.js` file where
    a new `StackNavigator` object must be created:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client/Screens`目录中，可以找到`Notifications.js`文件，必须将其用作用户显示通知的屏幕。此屏幕组件应该在`client/AppContainer.js`文件中导入，其中必须创建一个新的`StackNavigator`对象：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After `StackNavigator` for the `Notifications` screen is created, it needs
    to be added to `TabNavigator` so it will be displayed next to the `Posts` and
    `Settings` screens:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Notifications`屏幕的`StackNavigator`之后，需要将其添加到`TabNavigator`中，以便它将显示在`Posts`和`Settings`屏幕旁边：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Notifications` screen is now being displayed in `TabNavigator` and displays
    the text Empty! as there aren''t any notifications to display. To add any notifications
    that have been sent to the user, you need to create a local resolver for the GraphQL
    client. This local resolver will be used to create `Mutation`, which can be used
    to add any new notifications to the local state. You create the local resolver
    by adding the following code to `client/App.js`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Notifications`屏幕现在显示在`TabNavigator`中，并显示文本Empty！因为没有任何通知可显示。要添加已发送给用户的任何通知，需要为GraphQL客户端创建本地解析器。此本地解析器将用于创建`Mutation`，用于将任何新通知添加到本地状态。您可以通过将以下代码添加到`client/App.js`来创建本地解析器：'
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will create the `addNotification` mutation, which takes the `id`, `title`,
    and `body` variables and adds these values to the data for the `Notification`
    type. The notifications that are currently in the local state are requested using
    the `GET_NOTIFICATIONS` query that you created before. By calling the `query` function
    on the GraphQL `client` constant, you send the document containing this query
    to the server. Together with the notification that has been sent together with
    a document containing the mutation, these will be written to the local state by
    `cache.writeData`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建`addNotification`变异，该变异接受`id`、`title`和`body`变量，并将这些值添加到`Notification`类型的数据中。当前在本地状态中的通知是使用之前创建的`GET_NOTIFICATIONS`查询来请求的。通过在GraphQL
    `client`常量上调用`query`函数，您将向服务器发送包含此查询的文档。连同与变异一起发送的通知以及包含变异的文档，这些将通过`cache.writeData`写入本地状态。
- en: 'This mutation must be added to the `client/constants.js` file, where the other
    GraphQL queries and mutations are also placed. It''s important to also add that `client`
    should be used to resolve this mutation, by using the `@client` tag:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个变异必须添加到`client/constants.js`文件中，其他GraphQL查询和变异也放在那里。同样重要的是要添加`client`应该使用`@client`标签来解决这个变异：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the listener from the `Notifications` API is added to the `client/App.js` file,
    which will look for new notifications when the application is foregrounded. New
    notifications are added to the local state using the preceding mutation from `client/constants.js`.
    The `mutate` function that is called on the client will use the information from
    the Expo notification and adds this to mutation; the mutation will make sure it''s
    added to the local state by writing this information to `cache`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`Notifications` API中添加的监听器被添加到`client/App.js`文件中，当应用程序处于前台时，它将寻找新的通知。新的通知将使用`client/constants.js`中的前述变异添加到本地状态。在客户端上调用的`mutate`函数将使用来自Expo通知的信息并将其添加到变异；变异将确保通过将此信息写入`cache`将其添加到本地状态：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the previous code block, you cannot use the `useMutation` Hook to send the
    `ADD_NOTIFICATION` mutation in a document, as React Apollo Hooks can only be used
    from a component nested within `ApolloProvider`. Therefore, the `mutate` function
    on the `client` object is used, which also provides the functionality to send
    documents with queries and mutations without using a `Query` or `Mutation` component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码块中，您不能使用`useMutation` Hook来发送`ADD_NOTIFICATION`变异，因为React Apollo Hooks只能从嵌套在`ApolloProvider`中的组件中使用。因此，使用了`client`对象上的`mutate`函数，该函数还提供了发送带有查询和变异的文档的功能，而无需使用`Query`或`Mutation`组件。
- en: 'By importing the `Notifications` API from Expo, the `handleNotification` function
    can access the data object from the notification that was sent. This data object
    is different from the message title and message body you''ve sent using the Expo
    dashboard, therefore you need to also add JSON data when sending the notification
    from `https://expo.io/dashboard/notifications`. A test notification can be sent
    by adding the body in the form:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从Expo导入`Notifications` API，`handleNotification`函数可以访问发送的通知中的数据对象。该数据对象与您使用Expo仪表板发送的消息标题和消息正文不同，因此在从`https://expo.io/dashboard/notifications`发送通知时，您还需要添加JSON数据。可以通过在表单中添加正文来发送测试通知：
- en: '![](assets/4a6c73cf-01ef-4ed0-bc50-809452135e25.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a6c73cf-01ef-4ed0-bc50-809452135e25.png)'
- en: By submitting the form, a notification with the title `Test` and the body `This
    is a test` will be sent to the user when the application is foregrounded, but
    also when the application is running in the background.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提交表单，当应用程序处于前台运行时，将向用户发送标题为`Test`，正文为`This is a test`的通知，但也会在应用程序在后台运行时发送。
- en: 'In a mobile application that is running in production, you''d expect the notifications
    to be sent from the GraphQL server instead of the Expo dashboard. The local GraphQL
    server that is handling the data flow for this application is already configured
    to send notifications to the user but would need the user''s Expo push token to
    send. This token should be stored in the server and linked to the current user,
    as this token is unique for this device. The token should be sent in a document
    to the GraphQL server from a mutation that would take the token and can get information
    about the user from the headers in the mutation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中运行的移动应用程序中，您期望通知是从GraphQL服务器而不是Expo仪表板发送的。处理此应用程序的数据流的本地GraphQL服务器已配置为向用户发送通知，但需要用户的Expo推送令牌才能发送。该令牌应存储在服务器上并与当前用户关联，因为该令牌对于此设备是唯一的。该令牌应在文档中从变异发送到GraphQL服务器，该变异将获取关于用户的信息并从变异的标头中获取：
- en: 'First, the mutation that will store the Expo push token on the GraphQL server
    must be created in the `client/constants.js` file along with the other queries
    and mutations. The only variable this mutation takes is the push token, as the
    OAuth token that is sent with every document to the GraphQL server is used to
    identify the user:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`client/constants.js`文件中创建将在GraphQL服务器上存储Expo推送令牌的变异，以及其他查询和变异。此变异所需的唯一变量是推送令牌，因为发送到GraphQL服务器的每个文档的OAuth令牌用于标识用户：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sending the document with this mutation with the Expo push token must be done
    from the `client/Posts.js` file where the token is retrieved by calling the `registerForPushNotificationsAsync` function.
    This function will return the push token, which you can send along with the mutation''s
    document. To send this document, the `useMutation` Hook from `@apollo/react-hooks`
    can be used, which you must import together with the `STORE_EXPO_TOKEN` constant:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须从“client/Posts.js”文件中发送带有Expo推送令牌的此变异，该文件通过调用“registerForPushNotificationsAsync”函数检索令牌。此函数将返回推送令牌，您可以将其与变异文档一起发送。要发送此文档，可以使用“@apollo/react-hooks”中的“useMutation”
    Hook，您必须与“STORE_EXPO_TOKEN”常量一起导入：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Before React Apollo Hooks were available, it was complicated to use a mutation
    without the usage of a `Mutation` component, as sending mutations was only possible
    from the `client` object or the `Mutation` component. Accessing the `client` object
    from a React component is possible by importing an `ApolloConsumer` component
    that can read the client value from `ApolloProvider` that wraps your application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Apollo Hooks可用之前，使用变异是很复杂的，因为只能从“client”对象或“Mutation”组件发送变异。通过导入“ApolloConsumer”组件，可以从React组件中访问“client”对象，该组件可以从包装应用程序的“ApolloProvider”中读取客户端值。
- en: 'The `useMutation` Hook can now be called with the `STORE_EXPO_TOKEN` mutation
    with `expoToken` from `registerForPushNotificationsAsync` as a parameter, which
    returns a function to store the token called `storeExpoToken`. This function can
    be called from the callback of the asynchronous `registerForPushNotificationsAsync` function
    with the token as a variable:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用“useMutation” Hook调用“STORE_EXPO_TOKEN”变异，并将“registerForPushNotificationsAsync”中的“expoToken”作为参数，该参数返回一个用于存储令牌的函数称为“storeExpoToken”。可以从异步“registerForPushNotificationsAsync”函数的回调中调用此函数，并将令牌作为变量传递：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This Expo push token will be sent to the GraphQL server whenever the `Posts`
    screen gets mounted, something you can force by switching between the `AddPosts`
    and `Posts` screens, for example. When the content of the `Posts` screen gets
    requested from the GraphQL server, the server will send a random notification
    to your application, which you can view from the `Notifications` screen. Also,
    you're still able to send any notification from the Expo dashboard, both when
    the application is in the foreground or the background.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每当“帖子”屏幕被挂载时，Expo推送令牌将被发送到GraphQL服务器，您可以通过在“添加帖子”和“帖子”屏幕之间切换来强制执行此操作。当从GraphQL服务器请求“帖子”屏幕的内容时，服务器将向您的应用程序发送一个随机通知，您可以从“通知”屏幕中查看该通知。此外，您仍然可以在Expo仪表板上发送任何通知，无论应用程序是在前台还是后台运行。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've created a mobile social media application with React
    Native and Expo that uses a GraphQL server to send and receive data as well for
    authentication. Using Expo, you've learned how to have the application request
    access to use the device's camera or camera roll to add new photos to posts. Also,
    Expo is used to receive notifications from the Expo dashboard or the GraphQL server.
    These notifications will be received by the user no matter whether the application
    is running on the back- or foreground.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您使用React Native和Expo创建了一个移动社交媒体应用程序，该应用程序使用GraphQL服务器发送和接收数据以及进行身份验证。使用Expo，您学会了如何让应用程序请求访问设备的相机或相机滚动条，以添加新照片到帖子中。此外，Expo还用于从Expo仪表板或GraphQL服务器接收通知。这些通知将被用户接收，无论应用程序是在后台还是前台运行。
- en: In completing this social media application, you've completed the final React
    Native chapter of this book and are now ready to start with the very last chapter. In
    this last chapter, you'll be exploring another use case of React, which is React
    360\. With React 360, you can create 360-degree 2D and 3D experiences by writing
    React components.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这个社交媒体应用程序，您已经完成了本书的最后一个React Native章节，现在准备开始最后一个章节。在这最后一个章节中，您将探索React的另一个用例，即React
    360。使用React 360，您可以通过编写React组件创建360度的2D和3D体验。
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Expo camera: [https://docs.expo.io/versions/latest/sdk/camera/](https://docs.expo.io/versions/latest/sdk/camera/)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo相机：[https://docs.expo.io/versions/latest/sdk/camera/](https://docs.expo.io/versions/latest/sdk/camera/)
- en: Notifications: [https://docs.expo.io/versions/v33.0.0/sdk/notifications/](https://docs.expo.io/versions/v33.0.0/sdk/notifications/)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知：[https://docs.expo.io/versions/v33.0.0/sdk/notifications/](https://docs.expo.io/versions/v33.0.0/sdk/notifications/)
