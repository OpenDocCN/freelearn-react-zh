- en: Advanced Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型
- en: We've already learned about a fair amount of the type system in TypeScript.
    In this chapter, we'll continue on this journey, this time diving into some of
    the more advanced types and concepts that will help us later in the book to create
    reusable strongly type React components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了相当多的TypeScript类型系统知识。在本章中，我们将继续这个旅程，这次深入一些更高级的类型和概念，这将帮助我们在本书后面创建可重用的强类型React组件。
- en: We'll learn about how we can combine existing types to create union type. We'll
    find out in [Chapter 8](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=31&action=edit#post_31),* React
    Redux,* that these types are fundamental to creating strongly typed React Redux
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何将现有类型组合成联合类型。我们将在[第8章](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=31&action=edit#post_31)，*React
    Redux*中发现，这些类型对于创建强类型的React Redux代码至关重要。
- en: We briefly covered type guards in [Chapter 2](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=31&action=edit#post_31),* What
    is New in TypeScript 3*, when we learned about the `unknown` type. We look at
    these in more detail in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=31&action=edit#post_31)中简要介绍了类型守卫，*TypeScript
    3有什么新特性*，当时我们学习了`unknown`类型。在本章中，我们将更详细地了解这些内容。
- en: Generics are a TypeScript feature that many libraries use to allow consumers
    to create strongly typed apps with their library. React itself uses it in class
    components to allow us to create strongly typed props and states in the component. We
    cover generics in detail in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是TypeScript的一个特性，许多库使用它允许消费者使用其库创建强类型应用程序。React本身在类组件中使用它，允许我们在组件中创建强类型的props和states。我们将在本章中详细介绍泛型。
- en: Overload signatures is a nice feature that allows us to have a single function
    taking different combinations of parameters. We'll learn how to use these in this
    chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重载签名是一个很好的功能，允许我们的单个函数接受不同组合的参数。我们将在本章中学习如何使用这些内容。
- en: Lookup and mapped types allow us to dynamically create new types from existing
    types. We learn all about these at the end of this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 查找和映射类型允许我们从现有类型动态创建新类型。我们将在本章末尾详细了解这些内容。
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Union types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合类型
- en: Type guards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型守卫
- en: Generics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Overload signatures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载签名
- en: Lookup and mapped types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找和映射类型
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We''ll use the following technologies in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**TypeScript playground**: This is a website at [http://www.typescriptlang.org/play](http://www.typescriptlang.org/play) that
    allows us to play and understand the features in TypeScript without installing
    it. We''ll use this the majority of the time in this chapter.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript playground**：这是一个网站，网址为[http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)，允许我们在不安装TypeScript的情况下进行实验和了解其特性。在本章中，我们将大部分时间使用这个网站。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code that can be installed from the [https://code.visualstudio.com/](https://code.visualstudio.com/) website.
    We will also need the **TSLint** (by egamma) and **Prettier** (by Esben Petersen) extensions
    installed within Visual Studio Code.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写我们的React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)网站安装。我们还需要在Visual
    Studio Code中安装**TSLint**（由egamma提供）和**Prettier**（由Esben Petersen提供）扩展。'
- en: All the code snippets in this chapter can be found online at: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/05-AdvancedTypes.](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/05-AdvancedTypes)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在以下网址找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/05-AdvancedTypes.](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/05-AdvancedTypes)
- en: Union types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: As the name suggests, union types are types that we can combine together to
    form a new type. Unions are commonly used with string literal types, which we'll
    cover in the first section. Unions can be used in a pattern called discriminated
    union, which we can use when creating generic and reusable React components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，联合类型是我们可以组合在一起形成新类型的类型。联合类型通常与字符串文字类型一起使用，我们将在第一部分中介绍。联合类型可以用于一种称为辨识联合的模式，我们可以在创建通用和可重用的React组件时使用它。
- en: String literal types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串文字类型
- en: A variable of a string literal type can only be assigned the exact string value
    specified in the string literal type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字类型的变量只能被赋予字符串文字类型中指定的确切字符串值。
- en: 'In the TypeScript playground, let''s go through an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript playground中，让我们通过一个例子来看一下：
- en: 'Let''s create a string literal type called `Control` that can only be set to
    the `"Textbox"` string:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Control`的字符串文字类型，它只能设置为`"Textbox"`字符串：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s now create a variable called `notes` with our `Control` type and set
    this to `"Textbox"`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`notes`的变量，使用我们的`Control`类型，并将其设置为`"Textbox"`：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we would expect, the TypeScript compiler is happy with this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，TypeScript编译器对此非常满意。
- en: 'Now let''s set our variable to a different value:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将变量设置为不同的值：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We get the compilation error Type ''"DropDown"'' is not assignable to type
    ''"Textbox"'':'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了编译错误，类型`"DropDown"`不能赋值给类型`"Textbox"`：
- en: '![](assets/91dd9145-99e1-43da-af3c-7bff1f48250f.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91dd9145-99e1-43da-af3c-7bff1f48250f.png)'
- en: 'As with all other types in TypeScript, `null` and `undefined` are valid values
    as well:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与TypeScript中的所有其他类型一样，`null`和`undefined`也是有效的值：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: String literal types aren't that useful on their own. However, they become extremely
    useful when used in a union type, which we'll look at in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字类型本身并不那么有用。然而，当它们用于联合类型时，它们变得非常有用，我们将在下一部分中看到。
- en: String literal union types
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串文字联合类型
- en: A string literal union type is where we combine multiple string literal types
    together.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字联合类型是指我们将多个字符串文字类型组合在一起。
- en: Let's continue from the previous example and go through this.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一个例子继续，并通过这个例子来看一下。
- en: 'Let''s enhance our `Control` type to be a union of string literals:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们增强我们的`Control`类型，使其成为字符串文字的联合类型：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We combine types in a union type using `|`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`|`在联合类型中组合类型。
- en: 'Setting our `notes` variable to either `"Textbox"` or `"DropDown"` is now perfectly
    valid:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将我们的`notes`变量设置为`"Textbox"`或`"DropDown"`现在是完全有效的：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s extend our `Control` type to include more string literals:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们扩展我们的`Control`类型，以包含更多的字符串文字：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now set our `notes` variable to any of these values:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的`notes`变量设置为这些值中的任何一个：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we think about it, this is really useful. We could have declared the `notes`
    variable as a `string`, but declaring it with the specific string literals it
    can contain makes it super type-safe.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细想一想，这真的很有用。我们本来可以将`notes`变量声明为`string`，但是用包含的特定字符串文字来声明它可以包含的内容，这样就可以使它成为超级类型安全。
- en: Discriminated union pattern
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辨识联合模式
- en: The discriminated union pattern allows us to handle the logic for different
    union types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 辨识联合模式允许我们处理不同联合类型的逻辑。
- en: 'Let''s go through an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看一下：
- en: 'Let''s first create three interfaces to represent a textbox, a date picker,
    and a number slider:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建三个接口来表示文本框、日期选择器和数字滑块：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: They all have a property called `control`, which will be the discriminant in
    the pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有一个名为`control`的属性，这将是模式中的辨识者。
- en: 'Let''s move on to combine these interfaces into a union type called `Field`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续将这些接口组合成一个名为`Field`的联合类型：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, we can create union types from any types, and not just string literals.
    In this case, we have created a union type from three interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从任何类型创建联合类型，而不仅仅是字符串文字。在这种情况下，我们已经从三个接口创建了一个联合类型。
- en: 'Let''s now create a function to initialize the value in the `Field` type:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个函数来初始化`Field`类型中的值：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value we need to set depends on the discriminant property, `control`. So,
    we have used a `switch` statement to branch on this property.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置的值取决于辨别属性`control`。因此，我们使用了`switch`语句来根据这个属性进行分支。
- en: The `default` branch in the `switch` statement is where things get interesting.
    This branch should never be reached, so we have put a statement with the `never`
    type in that branch. We'll see the value of doing this after the next steps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句中的`default`分支是让事情变得有趣的地方。这个分支永远不应该被执行，所以我们在那个分支中放置了一个带有`never`类型的语句。在接下来的步骤之后，我们将看到这样做的价值。'
- en: 'Let''s pretend time has passed and we have a new requirement for checkbox fields.
    Let''s implement an interface for this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设时间已经过去，我们对复选框字段有了新的要求。让我们为此实现一个接口：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s also add this to the union `Field` type:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也将这个加入到联合`Field`类型中：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll immediately see that our `initializeValue` function throws a compilation
    error on the `never` declaration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会立即看到我们的`initializeValue`函数在`never`声明上抛出编译错误：
- en: '![](assets/63d39be5-cdfb-4d52-857e-8f99b628dab0.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63d39be5-cdfb-4d52-857e-8f99b628dab0.png)'
- en: This is very valuable because the `never` statement ensures we don't forget
    to add a branch of code for the new checkbox requirement.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有价值，因为`never`语句确保我们不会忘记为新的复选框要求添加代码分支。
- en: 'So, let''s go and implement this additional branch for the `"Checkbox"` field:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们去实现这个额外的分支，针对`"Checkbox"`字段：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, union types allow us to combine any types together to form another type.
    This allows us to create stricter types, particularly when working with strings.
    The discriminated union pattern allows us to have branches of logic for different
    types in the union, and the `never` type helps us catch all the changes that need
    to happen when we add a new type into the union type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，联合类型允许我们将任何类型组合在一起形成另一个类型。这使我们能够创建更严格的类型，特别是在处理字符串时。辨别联合模式允许我们为联合中的不同类型有逻辑分支，而`never`类型帮助我们捕捉添加新类型到联合类型时需要发生的所有变化。
- en: Type guards
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型守卫
- en: Type guards allow us to narrow down the specific type of an object within a
    conditional branch of code. They are useful when working with union types, when
    we need to implement a branch of code that deals with a specific type in the union.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类型守卫允许我们在代码的条件分支中缩小对象的特定类型。当我们需要实现处理联合类型中特定类型的代码分支时，它们非常有用。
- en: We already worked with a type guard in the last section when we implemented
    the `intializeValue` function. The `switch` statement on the discriminant property
    `control` allowed us to set the value on each type in the union.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当我们实现`intializeValue`函数时，我们已经使用了类型守卫。在辨别属性`control`上的`switch`语句允许我们在联合中的每种类型上设置值。
- en: There are other ways we can implement type guards. The following sections go
    through different ways.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现类型守卫的其他方法。以下部分介绍了不同的方法。
- en: Using the typeof keyword
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`typeof`关键字
- en: The `typeof` keyword is a JavaScript keyword that returns a string that represents
    the type. So, we can use this in a condition to narrow down the type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`关键字是JavaScript中返回表示类型的字符串的关键字。因此，我们可以在条件中使用它来缩小类型。'
- en: 'Let''s go through an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明：
- en: 'We have a union type that can be a string or an array of strings:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个可以是字符串或字符串数组的联合类型：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to implement a function called `first` that takes in a parameter of
    type `StringOrStringArray` and returns a `string`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现一个名为`first`的函数，它接受一个`StringOrStringArray`类型的参数并返回一个`string`：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The function needs to return the first character if `stringOrArray` is a `string`; otherwise,
    it should return the first array element:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`stringOrArray`是一个`string`，那么函数需要返回第一个字符；否则，它应该返回第一个数组元素：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we hover over `stringOrArray` in the first branch, we see that the type
    has been successfully narrowed to `string`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个分支中，如果我们悬停在`stringOrArray`上，我们会看到类型已成功缩小为`string`：
- en: '![](assets/c3bd8a84-3970-4d30-8028-6e7274641e85.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c3bd8a84-3970-4d30-8028-6e7274641e85.png)'
- en: 'If we hover over `stringOrArray` in the second branch, we see that the type
    has been successfully narrowed to `string[]`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个分支中，如果我们悬停在`stringOrArray`上，我们会看到类型已成功缩小为`string[]`：
- en: '![](assets/c486254e-591c-4bf5-8e52-79dc8e0e4f47.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c486254e-591c-4bf5-8e52-79dc8e0e4f47.png)'
- en: 'To check our function works, we can add the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查我们的函数是否有效，我们可以添加以下内容：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run the program, **T** and **The** will be output to the console.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行程序，**T**和**The**将被输出到控制台。
- en: 'The `typeof` keyword can only be used with JavaScript types, though. To illustrate
    that point, let''s create an enhanced version of our function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`关键字只能与JavaScript类型一起使用。为了说明这一点，让我们创建一个增强版本的函数：'
- en: 'We''ll call our function `firstEnhanced`. We want to make the second branch
    specifically deal with the `string[]` type and mark the third branch as a place
    that should never be reached. Let''s give this a try:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的函数称为`firstEnhanced`。我们希望第二个分支专门处理`string[]`类型，并将第三个分支标记为永远不会到达的地方。让我们试试看：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The TypeScript compiler isn''t happy with the second branch:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器对第二个分支不满意：
- en: '![](assets/6d9a86b0-d783-40de-bd18-a5ea0de264b4.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d9a86b0-d783-40de-bd18-a5ea0de264b4.png)'
- en: The message gives us a clue as to what is going on. The JavaScript `typeof`
    keyword works with JavaScript types, which are `string`, `number`, `boolean`,
    `symbol`, `undefined`, `object`, and `function`; hence the union type in the error
    message combining these types. So, `typeof` in our second branch will actually
    return `"object"`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 消息给了我们一些线索。JavaScript的`typeof`关键字适用于JavaScript类型，这些类型是`string`、`number`、`boolean`、`symbol`、`undefined`、`object`和`function`；因此错误消息中结合了这些类型的联合类型。因此，我们的第二个分支中的`typeof`实际上会返回`"object"`。
- en: 'Let''s implement this properly:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们正确地实现这个：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The TypeScript compiler is now happy again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器现在又高兴了。
- en: So, `typeof` is great for branching on JavaScript types but not ideal for TypeScript
    specific types. Let's find out how we can bridge this gap in the following sections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`typeof`非常适合根据JavaScript类型进行分支，但不太适合于TypeScript特定类型。让我们在接下来的部分中找出如何弥合这一差距。
- en: Using the instanceof keyword
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用instanceof关键字
- en: The `instanceof` keyword is another JavaScript keyword. It checks whether an
    object has a particular constructor function. It is typically used to determine
    whether an object is an instance of a class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`关键字是另一个JavaScript关键字。它检查对象是否具有特定的构造函数。通常用于确定对象是否是类的实例。'
- en: 'Let''s go through an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看一下：
- en: 'We have two classes representing `Person` and `Company`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个表示`Person`和`Company`的类：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also have a union type combining both of these classes:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个结合这两个类的联合类型：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now need to write a function that takes in a `Person` or `Company` and outputs
    their name to the console:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要编写一个函数，该函数接受`Person`或`Company`并将它们的名称输出到控制台：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When using `instanceof`, we have the variable we are checking before it and
    the constructor name (the class name) after it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`instanceof`时，我们在它之前有要检查的变量，之后是构造函数名称（类名）。
- en: 'If we hover over `personOrCompany` in the first branch, we get the `Person`
    type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个分支中，如果我们悬停在`personOrCompany`上，我们会得到`Person`类型：
- en: '![](assets/b107a292-3690-4dec-9489-8fa7b6b876b7.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b107a292-3690-4dec-9489-8fa7b6b876b7.png)'
- en: 'If we hover over `personOrCompany` in the second branch, we get the `Company`
    type:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个分支中，如果我们悬停在`personOrCompany`上，我们会得到`Company`类型：
- en: '![](assets/3086686e-4083-49af-8128-a5427e653428.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3086686e-4083-49af-8128-a5427e653428.png)'
- en: So, `instanceof` is great for narrowing down the type if we are dealing with
    classes. However, there are lots of TypeScript types we use that aren't JavaScript
    types or based on classes. So, what do we do in these situations? Let's find out
    in the following sections.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`instanceof`在处理类时非常适用于缩小类型。然而，我们使用许多不是JavaScript类型或基于类的TypeScript类型。那么，在这些情况下我们该怎么办呢？让我们在接下来的部分中找出答案。
- en: Using the in keyword
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`in`关键字
- en: The `in` keyword is another JavaScript keyword that can be used to check whether
    a property is in an object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`关键字是另一个JavaScript关键字，可用于检查属性是否在对象中。'
- en: 'Let''s implement the example from the last section using the `in` keyword:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`in`关键字来实现上一节的示例：
- en: 'Instead of classes for the `Person` and `Company` structures, we have interfaces
    this time:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们使用接口而不是`Person`和`Company`结构的类：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We again create a union type from the `Person` and `Company` structures:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次从`Person`和`Company`结构创建一个联合类型：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s implement our function using the `in` keyword:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用`in`关键字来实现我们的函数：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We put the property name in double quotes before the `in` keyword, followed
    by the object to check.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`in`关键字之前，我们用双引号将属性名称放在一起，然后是要检查的对象。
- en: If we hover over `personOrCompany` in the first branch, we get the `IPerson` type.  If
    we hover over `personOrCompany` in the second branch, we get the `ICompany` type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第一个分支上悬停在`personOrCompany`上，我们会得到`IPerson`类型。如果我们在第二个分支上悬停在`personOrCompany`上，我们会得到`ICompany`类型。
- en: So, the `in` keyword is pretty flexible. It can be used with any object to narrow
    down its type by checking if a property exists.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`in`关键字非常灵活。它可以与任何对象一起使用，通过检查属性是否存在来缩小其类型。
- en: There is one final type guard we will go through in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍最后一个类型保护。
- en: Using a user-defined type guard
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户定义的类型保护
- en: In situations where we can't use the other type guards, we can create our own.
    We can do this by creating a function with the return type as type predicate.
    We actually used a user-defined type guard earlier in the book when we went through
    the `unknown` type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法使用其他类型保护的情况下，我们可以创建自己的类型保护。我们可以通过创建一个返回类型为类型断言的函数来实现这一点。在本书之前，我们实际上在讨论`unknown`类型时使用了用户定义的类型保护。
- en: 'Let''s implement the example from the last two sections using our own type
    guard function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们自己的类型保护函数来实现上两节的示例：
- en: 'We have the same interfaces and union type:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有相同的接口和联合类型：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, let''s implement the type guard function that returns whether the object
    is of type `IPerson`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们实现返回对象是否为`IPerson`类型的类型保护函数：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The type predicate `personOrCompany` is `IPerson` helps the TypeScript compiler
    narrow down the type. To confirm this, hovering over `personOrCompany` in the
    first branch should give the `IPerson` type.  If we then hover over `personOrCompany` in
    the second branch, we should get the `ICompany` type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言`personOrCompany`是`IPerson`有助于TypeScript编译器缩小类型。要确认这一点，在第一个分支上悬停在`personOrCompany`上应该给出`IPerson`类型。然后，如果我们在第二个分支上悬停在`personOrCompany`上，我们应该得到`ICompany`类型。
- en: Creating a user-defined type guard is a little more work than the other methods,
    but it gives us lots of flexibility to deal with cases if the other methods don't
    work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户定义的类型保护比其他方法更费力，但它为我们提供了处理其他方法无法解决的情况的灵活性。
- en: Generics
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics can be applied to a function or a whole class. It's a mechanism for
    allowing the consumers, own type to be used with the generic function or class.
    The following sections go through examples of both of these.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以应用于函数或整个类。这是一种允许消费者使用自己的类型与泛型函数或类一起使用的机制。接下来的部分将介绍这两种情况的示例。
- en: Generic functions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'Let''s go through an example of a generic function. We are going to create
    a wrapper function around the `fetch` JavaScript function for getting data from
    a web service:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个通用函数的示例来进行讲解。我们将创建一个包装函数，用于调用`fetch` JavaScript函数从web服务获取数据：
- en: 'Let''s start by creating the `function` signature:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建`function`签名开始：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We place a `T` in angled brackets after the function name to denote that it
    is a generic function. We can actually use any letter, but `T` is commonly used. 
    We then use `T` in the signature where the type is generic. In our example, the
    generic bit is the return type, so we are returning `Promise<T>`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数名后的尖括号中放置一个`T`来表示它是一个通用函数。实际上我们可以使用任何字母，但`T`是常用的。然后我们在类型是通用的地方使用`T`。在我们的示例中，通用部分是返回类型，所以我们返回`Promise<T>`。
- en: 'If we wanted to use an arrow function, this would be:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用箭头函数，这将是：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s now implement our function:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现我们的函数：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, let''s consume the function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们消费这个函数：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We pass the type we want to use in the function in angle brackets after the
    function name. In our case, it is `IPerson`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数名后的尖括号中传递我们想要在函数中使用的类型。在我们的例子中，它是`IPerson`。
- en: 'If we hover over `person` in the `then` callback, we see that `person` is correctly
    typed to `IPerson`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`then`回调中悬停在`person`上，我们会看到`person`被正确地类型化为`IPerson`：
- en: '![](assets/e5c149ed-5efb-44a6-92e5-7c2fd38ac377.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e5c149ed-5efb-44a6-92e5-7c2fd38ac377.png)'
- en: So, as the name suggests, a generic function is a function that works with a
    generic type. An alternative implementation for the previous example would be
    to use `any` as the return type, but that wouldn't be type-safe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，顾名思义，通用函数是与通用类型一起工作的函数。先前示例的另一种实现方式是将`any`作为返回类型，但那不是类型安全的。
- en: Generic classes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用类
- en: 'We can make a whole class generic. Let''s dive into an example of a generic
    class that stores data in a list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使整个类成为通用的。让我们深入了解一个将数据存储在列表中的通用类的示例：
- en: 'Let''s define our class first without any content:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们定义我们的类，不包含任何内容：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We mark the class as generic by putting `<T>` after the class name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在类名后面加上`<T>`来标记类为通用的。
- en: 'Inside the class, let''s create a `private` property for the data in the list:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，让我们为列表中的数据创建一个`private`属性：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We refer to the generic type using `T`.  In our example, our `data` property
    is an array of whatever type the class has been declared with.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`T`来引用通用类型。在我们的示例中，我们的`data`属性是一个根据类声明的任何类型的数组。
- en: 'Let''s now add a `public` method to get all the data in the list:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个`public`方法来获取列表中的所有数据：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We reference the generic array as the return type with `T[]`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`T[]`来引用通用数组作为返回类型。
- en: 'Let''s implement a method for adding an item to the list:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个向列表中添加项目的方法：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We reference the data item being passed in with the generic type `T`. The implementation
    simply uses the arrays `push` method to add the item to our `private` array.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用通用类型`T`来引用传入的数据项。该实现简单地使用数组的`push`方法将项目添加到我们的`private`数组中。
- en: 'Let''s also implement a method for removing an item from the list:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也实现一个从列表中移除项目的方法：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We again reference the data item being passed in with the generic type `T`.
    The implementation uses the arrays `filter` method to filter the item out of our
    private array. The filter predicate uses a `private` method that checks whether
    two objects are equal.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用通用类型`T`来引用传入的数据项。该实现使用数组的`filter`方法来过滤私有数组中的项目。过滤谓词使用一个检查两个对象是否相等的`private`方法。
- en: 'So, now that we''ve implemented our generic list class, let''s create a type
    and some data in preparation for consuming it:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们已经实现了我们的通用列表类，让我们创建一个类型和一些数据，以便消费它：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s now create an instance of our generic class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个通用类的实例：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We put the type we want to use with the class after the class name in angled
    brackets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类名后面使用尖括号中的类型来与类交互。
- en: 'We can now interact with the class by adding and removing `billy`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过添加和删除`billy`来与类交互：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s try to use a different type with our list instance:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在我们的列表实例中使用不同的类型：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We get a compilation error, as we would expect:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了编译错误，正如我们所预期的那样：
- en: '![](assets/8c9d178e-6280-42a8-b058-b1297b821cde.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c9d178e-6280-42a8-b058-b1297b821cde.png)'
- en: 'Let''s save all the items in our list instance to a variable:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将列表实例中的所有项目保存到一个变量中：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we hover over the `items` variable, we see that the type has been correctly
    inferred to `IPerson[]`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们悬停在`items`变量上，我们会看到类型已经被正确推断为`IPerson[]`：
- en: '![](assets/d327fe7b-856e-46ad-8e97-a3a8291947e1.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d327fe7b-856e-46ad-8e97-a3a8291947e1.png)'
- en: So, a generic class allows us to use the class with different types but still
    maintain strong typing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，泛型类允许我们使用不同类型的类，但仍然保持强类型。
- en: 'We actually used generic classes earlier in the book where we implemented React
    class components with props and state:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的早些时候使用了泛型类，我们用它来实现了带有props和state的React类组件：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the `React.Component` class has two generic parameters for the props and
    state.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`React.Component`类有两个用于props和state的泛型参数。
- en: So, generics are a really important concept that we'll use heavily in this book
    to create strongly typed React components.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，泛型在这本书中是一个非常重要的概念，我们将大量使用它来创建强类型的React组件。
- en: Overload signatures
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载签名
- en: 'Overload signatures allow a function to be called with different signatures. This
    feature can be used nicely to streamline a set of functions that a library offers
    to consumers. Wouldn''t it be nice for a library that contained `condenseString`
    public functions and `condenseArray` to be streamlined so that it just contained
    a single public `condense` function? We''ll do just this in this section:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重载签名允许使用不同的签名调用函数。这个特性可以很好地用于简化库向消费者提供的一组函数。如果一个库包含`condenseString`公共函数和`condenseArray`，那么将它们简化为只包含一个公共`condense`函数会很好，不是吗？我们将在本节中做到这一点：
- en: 'We have a function that removes spaces from a string:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个从字符串中移除空格的函数：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We have another function that removes spaces from array items:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有另一个从数组项中移除空格的函数：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We now want to combine these two functions into a single function. We can do
    this as follows using union types:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想将这两个函数合并为一个单一的函数。我们可以使用联合类型来实现：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s consume our unified function:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们的统一函数：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we enter the function parameter, IntelliSense reminds us that we need to
    enter a string or an array of strings:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入函数参数时，智能感知提醒我们需要输入一个字符串或字符串数组：
- en: '![](assets/16211526-e4fe-4474-ac5f-e0a20c980546.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16211526-e4fe-4474-ac5f-e0a20c980546.png)'
- en: 'If we hover over the `condensedText` variable, we see that the inferred type
    is the union type:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们悬停在`condensedText`变量上，我们会看到推断类型是联合类型：
- en: '![](assets/be356958-af22-4cd1-a743-26cc4f932376.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/be356958-af22-4cd1-a743-26cc4f932376.png)'
- en: 'It''s time to add two signature overloads to improve the consumption of our
    function:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候添加两个签名重载来改进我们函数的使用了：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We add function overload signatures before the main function signature. We've
    added an overload for when we work with a string, and a second overload for when
    we work with an array of strings.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主函数签名之前添加了函数重载签名。我们为处理字符串时添加了一个重载，为处理字符串数组时添加了第二个重载。
- en: 'Let''s consume our overloaded function:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们的重载函数：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We get improved IntelliSense now as we type the parameter. We also get up and
    down arrows to scroll through the two different signatures:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们输入参数时，我们得到了改进的智能感知。我们还可以使用上下箭头来滚动两个不同的签名：
- en: '![](assets/3e18d290-be0c-4bac-b77e-cc8bceea1b4a.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e18d290-be0c-4bac-b77e-cc8bceea1b4a.png)'
- en: 'If we hover over the `moreCondensedText` variable, we see that we get better
    type inference:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们悬停在`moreCondensedText`变量上，我们会看到我们获得了更好的类型推断：
- en: '![](assets/9556262a-e3ca-429f-b871-7fc53c4c55ee.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9556262a-e3ca-429f-b871-7fc53c4c55ee.png)'
- en: So, overload signatures improve the experience for developers consuming our
    functions. They can give improved IntelliSense and type inference.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，重载签名可以改善开发人员使用我们函数的体验。它们可以提供改进的智能感知和类型推断。
- en: Lookup and mapped types
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和映射类型
- en: The `keyof` is a keyword in TypeScript that creates a union type of all the
    properties in an object. The type that is created is called a lookup type.  This
    allows us to create types dynamically, based on the properties of an existing
    type. It's a useful feature that we can use to create generic but strongly typed
    code against varying data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyof`是TypeScript中的一个关键字，它创建了对象中所有属性的联合类型。创建的类型称为查找类型。这允许我们根据现有类型的属性动态创建类型。这是一个有用的功能，我们可以用它来针对不同的数据创建通用但强类型的代码。'
- en: 'Let''s go through an example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明：
- en: 'We have the following `IPerson` interface:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下`IPerson`接口：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s create a lookup type on this interface using `keyof`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在这个接口上使用`keyof`创建一个查找类型：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we hover over the `PersonProps` type, we see that a union type containing
    `"id"` and `"name"` has been created:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们悬停在`PersonProps`类型上，我们会看到创建了一个包含`"id"`和`"name"`的联合类型：
- en: '![](assets/adf4d8ce-701b-4c33-bae1-625b4f3bee33.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/adf4d8ce-701b-4c33-bae1-625b4f3bee33.png)'
- en: 'Let''s add a new property to `IPerson`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向`IPerson`添加一个新属性：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we hover over the `PersonProps` type again, we see that the type has been
    automatically extended to include `"age"`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次悬停在`PersonProps`类型上，我们会看到该类型已自动扩展以包含`"age"`：
- en: '![](assets/e3f68ad0-87a7-49b2-a2ea-44b820ab9ded.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3f68ad0-87a7-49b2-a2ea-44b820ab9ded.png)'
- en: So, the `PersonProps` type is a lookup type because it looks up the literals
    it needs to contain.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`PersonProps`类型是一个查找类型，因为它查找它需要包含的文字。
- en: 'Let''s create something useful now with a lookup type:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用查找类型创建一些有用的东西：
- en: 'We''re going to create a `Field` class that contains the field name, a label,
    and a default value:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`Field`类，其中包含字段名称、标签和默认值：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is a start, but we can make `name` more strongly typed by making our class
    generic:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只是一个开始，但我们可以通过使我们的类通用来使`name`更加强类型化：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have created two generic parameters on the class. The first one is for the
    type of the object containing the field, and the second one is for the property
    name within the object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类上创建了两个通用参数。第一个是包含字段的对象类型，第二个是对象内的属性名称。
- en: 'It will probably make more sense if we create an instance of the class. Let''s
    do just that using `IPerson` from the last example and passing `"id"` in as the
    field name:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们创建类的实例，可能会更有意义。让我们使用上一个示例中的`IPerson`，并将`"id"`作为字段名称传递进去：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s try and reference a property that doesn''t exist in `IPerson`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试引用在`IPerson`中不存在的属性：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We get a compilation error, as we would expect:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了编译错误，正如我们所期望的那样：
- en: '![](assets/9bcff5a0-6fb8-45c1-9716-8cd06aacca2c.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9bcff5a0-6fb8-45c1-9716-8cd06aacca2c.png)'
- en: Catching problems like this is the benefit of the lookup type, rather than using
    a `string` type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 捕捉这样的问题是查找类型的好处，而不是使用`string`类型。
- en: 'Let''s move our attention to the `defaultValue` property in our `Field` class.
    This is not type-safe at the moment. For example, we can set `idField` to a string:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向`Field`类中的`defaultValue`属性。目前这不是类型安全的。例如，我们可以将`idField`设置为一个字符串：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s resolve this and make `defaultValue` type-safe:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解决这个问题，使`defaultValue`具有类型安全性：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are looking up the type using `T[K]`. For `idField`, this will resolve to
    the type of the `id` property in `IPerson`, which is `number`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`T[K]`查找类型。对于`idField`，这将解析为`IPerson`中`id`属性的类型，即`number`。
- en: 'The line of code that sets `idField.defaultValue` now throws a compilation
    error, as we would expect:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置`idField.defaultValue`的代码行会引发编译错误，正如我们所期望的那样：
- en: '![](assets/229bceae-9608-4b21-af80-a048171564ce.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/229bceae-9608-4b21-af80-a048171564ce.png)'
- en: 'Let''s change `"2"` to `2`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`"2"`更改为`2`：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The compilation error disappears.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误消失了。
- en: So, lookup types can be useful when creating generic components for variable
    data types.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建可变数据类型的通用组件时，查找类型可能会很有用。
- en: Let's move on to mapped types now. Again, these let us create new types from
    an existing type's properties. However, mapped types allow us to specifically
    define the properties in the new type by mapping them from the existing property.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到映射类型。同样，这些让我们可以从现有类型的属性中创建新类型。但是，映射类型允许我们通过从现有属性中映射它们来明确定义新类型中的属性。
- en: 'Let''s go through an example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看一下：
- en: 'First, let''s create a type that we will map from in the next step:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个类型，我们将在下一步中进行映射：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now let''s create a new version of the `interface` where all the properties
    are `readonly` using mapped type:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新版本的`interface`，其中所有属性都是使用映射类型`readonly`的：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The important bit that creates the map is `[P in keyof IPerson]`. This iterates
    through all the properties in `IPerson` and assigns each one to `P` to create
    the type. So, the type that is generated in the previous example is the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建映射的重要部分是`[P in keyof IPerson]`。这会遍历`IPerson`中的所有属性，并将每个属性分配给`P`以创建类型。因此，在上一个示例中生成的类型如下：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let try this out to see if our type really is `readonly`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下，看看我们的类型是否真的是`readonly`：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we expect, a compilation error is thrown where we try to set the `readonly`
    property to a new value:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，当我们尝试将`readonly`属性设置为新值时，会引发编译错误：
- en: '![](assets/e5cdc52a-81b3-4d5c-a4cf-45e9b1d0b7ef.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e5cdc52a-81b3-4d5c-a4cf-45e9b1d0b7ef.png)'
- en: So our mapped type worked! A more generic version of this mapped type is actually
    in TypeScript as a standard type, and is `Readonly<T>`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的映射类型起作用了！这种映射类型的更通用版本实际上是TypeScript中的标准类型，即`Readonly<T>`。
- en: 'Let''s use the standard `readonly` type now:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用标准的`readonly`类型：
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s try changing the values in our `readonly`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试更改我们的`readonly`中的值：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A compilation error is thrown, as we would expect:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 引发编译错误，正如我们所期望的那样：
- en: '![](assets/ec2cbbfd-da34-49d8-b69d-995921a2d5d1.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec2cbbfd-da34-49d8-b69d-995921a2d5d1.png)'
- en: 'If we were in Visual Studio Code and used the Go to Definition option on the
    `Readonly` type, we would get the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Visual Studio Code中使用“转到定义”选项来查看“Readonly”类型，我们会得到以下结果：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is very similar to our `ReadonlyPerson` type, but `IPerson` has been substituted
    with generic type `T`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的`ReadonlyPerson`类型非常相似，但是`IPerson`已被替换为通用类型`T`。
- en: 'Let''s have a go at creating our own generic mapped type now:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建我们自己的通用映射类型：
- en: 'We are going to create a mapped type that makes all the properties of an existing
    type of type `string`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个映射类型，使现有类型的所有属性都是`string`类型：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s try to consume our mapped type:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的映射类型：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s try to set `id` to a number:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试将`id`设置为一个数字：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The expected compilation error is thrown:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的编译错误被引发：
- en: '![](assets/ec29dcfe-ffbc-4520-83ab-6920edba4a0c.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec29dcfe-ffbc-4520-83ab-6920edba4a0c.png)'
- en: So, mapped types are useful in situations when we need a new type that is based
    on an existing type. Along with `Readonly<T>`, there are quite a few standard
    mapped types in TypeScript, such as `Partial<T>`, which creates a mapped type
    making all the properties optional.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在需要基于现有类型创建新类型的情况下，映射类型非常有用。除了`Readonly<T>`之外，在TypeScript中还有许多标准映射类型，例如`Partial<T>`，它创建一个映射类型，使所有属性都是可选的。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've learned some of the more advanced types in TypeScript in this chapter,
    starting with union types. Union types are extremely useful, allowing us to create
    new types by unioning existing types together. We discovered that unioning together
    string literals allow us to create a type that is more specific and type-safe
    than a regular `string`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了TypeScript中一些更高级的类型，从联合类型开始。联合类型非常有用，允许我们通过将现有类型联合在一起来创建新类型。我们发现，将字符串字面量联合在一起可以创建比普通`string`更具体和类型安全的类型。
- en: We explored various ways of implementing type guards. Type guards are useful
    to help the compiler narrow down a union type in branches of logic. They are also
    useful when working with the `unknown` type to tell the compiler what the type
    is in branches of logic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了各种实现类型守卫的方式。类型守卫在逻辑分支中帮助编译器缩小联合类型的范围时非常有用。它们在使用`unknown`类型时，在逻辑分支中告诉编译器类型是什么也非常有用。
- en: Generics, as the name suggests, allow us to create generic types. Having covered
    this topic in detail, the type-safety for props and state in React components
    makes a lot more sense now. We will continue to use generic classes and functions
    heavily in the rest of the book.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型，顾名思义，允许我们创建通用类型。在详细讨论了这个主题之后，React组件中的props和state的类型安全现在更加有意义了。我们将在本书的其余部分大量使用通用类和函数。
- en: We learned that overload signatures allow us to have a function that has different
    parameters and return types. We can now use this feature to good effect to streamline
    public functions we expose in a library.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到重载签名允许我们拥有具有不同参数和返回类型的函数。现在我们可以有效地使用这个特性来简化我们在库中公开的公共函数。
- en: We learned about how we can dynamically create new types from existing type
    properties using both lookup and mapped types. We are now aware that there are
    lots of useful standard TypeScript mapped types such as `Readonly<T>` and `Partial<T>`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何可以使用查找和映射类型从现有类型属性动态创建新类型。我们现在知道，有许多有用的标准TypeScript映射类型，如`Readonly<T>`和`Partial<T>`。
- en: Learning about all these features is great preparation for the next chapter,
    where we'll dive into some common patterns when working with React components.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 学习所有这些特性是对下一章的很好准备，我们将深入探讨在使用React组件时的一些常见模式。
- en: Questions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let''s have a go at some questions on advanced types:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试试一些关于高级类型的问题：
- en: 'We have an `interface` that represents a course result, as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个代表课程结果的`interface`，如下：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can use this `interface` as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用这个`interface`：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The grades can only be A, B, C, or D. How can we create a stronger typed version
    of the `grade` property in this interface?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 成绩只能是A、B、C或D。我们如何创建这个接口中`grade`属性的更强类型版本？
- en: 'We have the following functions that validate that numbers and strings are
    populated with a value:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下函数，用于验证数字和字符串是否有值：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How can we combine these into a single function called `isPopulated` with signature
    overloads?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这些组合成一个名为`isPopulated`的单一函数，带有签名重载？
- en: How can we implement a more flexible version of the `isPopulated` function with
    generics?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何可以使用泛型实现一个更灵活的`isPopulated`函数？
- en: 'We have the follow `type` alias of stages:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个代表阶段的`type`别名：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How can we programmatically turn this into the `'Pending' | 'Started' | 'Completed'` union
    type?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何可以编程地将这个转换成`'Pending' | 'Started' | 'Completed'`联合类型？
- en: 'We have the following union type:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下联合类型：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'How can we programmatically create the following type:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何可以编程地创建以下类型：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Further reading
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The TypeScript documentation has a great section on advanced types that is
    worth looking at:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript文档中有一个关于高级类型的很棒的部分，值得一看：
- en: '[https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)'
