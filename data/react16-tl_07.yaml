- en: Isolating Components with Storybook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Storybook隔离组件
- en: 'React components are smaller pieces of a larger user interface. Naturally,
    you want to develop your UI components in tandem with the rest of the application.
    On the other hand, experimenting with component changes can prove tricky if the
    only environment you have is inside the larger UI. The focus of this chapter is
    showing you how the Storybook tool can be leveraged to provide an isolated sandbox
    for developing React components. You will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React组件是较大用户界面的较小部分。自然而然，您希望与应用程序的其余部分一起开发UI组件。另一方面，如果您唯一的环境是在较大的UI内部，那么尝试组件更改可能会变得棘手。本章的重点是向您展示如何利用Storybook工具提供一个隔离的沙盒来开发React组件。您将学到：
- en: The importance of isolated component development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离组件开发的重要性
- en: Installing Storybook and getting it set up
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Storybook并进行设置
- en: Developing components using stories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用故事开发组件
- en: Bringing components into the application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件引入应用程序
- en: The need for isolated component development
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离组件开发的需求
- en: Isolating React components during development can be difficult. Often, the only
    context available to developers and the React components that they're making is
    the application itself. Rarely do things go exactly as planned while a component
    is being developed. Part of the debug process for a React component is, well,
    playing with it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中隔离React组件可能会很困难。开发人员和他们正在制作的React组件所拥有的唯一上下文通常只有应用程序本身。在组件开发过程中很少会按计划进行。调试React组件的一部分是，嗯，与之互动。
- en: I often find myself doing weird things in application code to accommodate for
    temporary changes that we make to components as I troubleshoot problems. For example,
    I'll change the type of container element to see if this is what's causing the
    layout issues that I'm seeing; or, I'll change the markup that's internal to the
    component; or, I'll completely fabricate some state or props that the component
    uses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现自己在应用程序代码中做一些奇怪的事情，以适应我们对组件进行临时更改时出现的问题。例如，我会更改容器元素的类型，看看这是否导致了我看到的布局问题；或者，我会更改组件内部的标记；或者，我会完全捏造一些组件使用的状态或属性。
- en: The point is that there are random experiments that you're going to want to
    perform over the course of developing component. Trying to do this within the
    application that you're building can be cumbersome. This is mostly because you're
    forced to take in everything else around the component, which can be distracting
    when all you care about is seeing what your component does.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，在开发组件的过程中，您将想要进行一些随机实验。在您构建的应用程序中尝试这样做可能会很麻烦。这主要是因为您被迫接受组件周围的一切，当您只关心看看您的组件做了什么时，这可能会分散注意力。
- en: Sometimes, I end up creating a whole new page, or a whole new app, just so that
    I can see what my component does all on its own. This is a painful process and
    other people feel the same way, which is why **Storybook** exists. React tools
    exist to automate something for the React developer. With Storybook, you're automating
    a sandboxed environment for you to work with. It also handles all the build steps
    for you, so you can just write a story for your components and see the result.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我最终会创建一个全新的页面，或者一个全新的应用程序，只是为了看看我的组件单独做了什么。这是一个痛苦的过程，其他人也有同样的感受，这就是为什么**Storybook**存在的原因。React工具存在是为了为React开发人员自动化某些事情。使用Storybook，您正在自动化一个沙盒环境供您使用。它还为您处理所有构建步骤，因此您只需为组件编写一个故事并查看结果。
- en: The best way to think about Storybook is as a site like JSFiddle ([https://jsfiddle.net/](https://jsfiddle.net/))
    or JSBin ([https://jsbin.com/](https://jsbin.com/)). They let you experiment with
    small pieces of code without having to set up and maintain an environment. Storybook
    is like JSFiddle for React that exists as an integral part of your project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方式是将Storybook视为类似JSFiddle（[https://jsfiddle.net/](https://jsfiddle.net/)）或JSBin（[https://jsbin.com/](https://jsbin.com/)）这样的网站。它们让你可以在不设置和维护环境的情况下尝试小段代码。Storybook就像React的JSFiddle，作为你项目的一个组成部分存在。
- en: Installing and configuring Storybook
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Storybook
- en: 'The first step to using Storybook is installing the global command-line tool.
    It''s installed as a global tool because it can be used with many projects at
    the same time, and it can be used to bootstrap new projects. Let''s start with
    this first step:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Storybook的第一步是安装全局命令行工具。它被安装为全局工具，因为它可以同时用于许多项目，并且可以用来引导新项目。让我们从这第一步开始：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once this installation is done, you have the command-line tool that''s used
    to modify your `package.json` dependencies and generate boilerplate Storybook
    files. Let''s assume that you''ve used `create-react-app` to create a new application.
    Change into your application directory, and use the Storybook command-line tool
    to add Storybook to your current project:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将拥有用于修改`package.json`依赖项和生成样板Storybook文件的命令行工具。假设你已经使用`create-react-app`创建了一个新应用程序。进入你的应用程序目录，并使用Storybook命令行工具将Storybook添加到你当前的项目中：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `getstorybook` command does a number of things for you when you run it.
    Here''s what you should see as the output when you run this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`getstorybook`命令时，它会为你做很多事情。当你运行这个命令时，以下是你应该看到的输出：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will try to figure out what type of project you have before adding anything
    because different types of projects will have different organizational requirements.
    `getstorybook` takes this into account. Then, it''ll install dependencies, boilerplate
    files, and add scripts to your `package.json`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它会在添加任何内容之前尝试弄清楚你的项目类型，因为不同类型的项目会有不同的组织要求。`getstorybook`会考虑到这一点。然后，它会安装依赖项，样板文件，并向你的`package.json`添加脚本：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output tells you have to run the Storybook server within your project.
    Here''s what the `scripts` section of your `package.json` should look like at
    this point:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉你如何在项目中运行Storybook服务器。此时，你的`package.json`的`scripts`部分应该如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll look at the `build-storybook` script later on in the chapter; you'll use
    the `storybook` script more often.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看一下`build-storybook`脚本；你会更经常使用`storybook`脚本。
- en: 'Next, let''s look at the boilerplate files that `getstorybook` has created
    for you. First, you''ll notice that there''s a new `.storybook` directory in the
    top-level directory of your project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看`getstorybook`为你创建的样板文件。首先，你会注意到在项目的顶层目录中有一个新的`.storybook`目录：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The two files added are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的两个文件如下：
- en: '`addons.js`: This file imports add-on modules for Storybook. By default, the
    actions and links add-ons are used, but these can be removed if they''re not used.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addons.js`：这个文件导入了Storybook的插件模块。默认情况下，会使用actions和links插件，但如果不需要可以移除。'
- en: '`config.js`: This file imports the stories for this project and configures
    Storybook to use them.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.js`：这个文件导入了这个项目的故事，并配置Storybook来使用它们。'
- en: 'You''ll also find a new directory called `stories` within your `src` directory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会在你的`src`目录中找到一个名为`stories`的新目录：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Remember how `getstorybook` figured out that you''re using `create-react-app`
    with your project? This is how it knows to put the `stories` directory under `src`.
    This is where you''ll find two demo stories to help get you started:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 记得`getstorybook`是如何发现你正在使用`create-react-app`来开发你的项目的吗？这就是它知道要把`stories`目录放在`src`下的方式。这里有两个演示故事，可以帮助你入门：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Don''t worry about figuring out what''s going on in this file just yet, we''ll
    get there. These default stories will be replaced by stories that you come up
    with for your component. It''s also helpful to have these default stories in place
    so that you have something to look at when you fire up the Storybook server for
    the first time. Let''s do that now:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先不要担心这个文件里发生了什么，我们会搞清楚的。这些默认故事将被你为组件想出的故事所替代。将这些默认故事放在那里也很有帮助，这样当你第一次启动Storybook服务器时，你就有东西可以看。现在让我们来做吧：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After a few seconds, you should see console output that tells you where the
    server is running so that you can open it in your browser:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你应该会看到控制台输出，告诉你服务器运行的位置，这样你就可以在浏览器中打开它：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s what you should see when you look at the Storybook app in your browser:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中查看Storybook应用程序时，你应该看到的是：
- en: '![](Images/53c9334f-ba6d-4f76-aed5-3a3962bb2bc7.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/53c9334f-ba6d-4f76-aed5-3a3962bb2bc7.png)'
- en: 'Here''s a rough breakdown of what you''re looking at:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你所看到的大致情况：
- en: The left pane is where you'll find all of your stories. This is where the two
    default Storybook stories are displayed.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左窗格是你找到所有故事的地方。这是显示两个默认Storybook故事的地方。
- en: The main pane is where you'll see rendered content from the selected story.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主窗格是你将看到所选故事的渲染内容的地方。
- en: The bottom actions pane is where you'll see triggered actions logged.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部操作窗格是你将看到触发的操作被记录的地方。
- en: 'Let''s try selecting a different story in the left pane:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在左窗格中选择一个不同的故事：
- en: '![](Images/76b9a4a5-12c8-4fab-a347-83b36072774e.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/76b9a4a5-12c8-4fab-a347-83b36072774e.png)'
- en: As soon as you change story selections in the left pane, you'll see the rendered
    component output in the main pane. In this case, it's a basic button.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在左窗格中更改故事选择，你就会在主窗格中看到渲染的组件输出。在这种情况下，它是一个基本的按钮。
- en: Developing components with stories
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用故事开发组件
- en: The value of Storybook is that you don't have to set up an application to start
    hacking components. Or, if you already have an application under development,
    you don't have to figure out how to integrate in-progress components into your
    app. Storybook is a tool that enables experimentation. Through the use of add-ons,
    you can test almost any aspect of your component before worrying about integrating
    it into your application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook的价值在于，你不必设置应用程序就可以开始开发组件。或者，如果你已经在开发中有一个应用程序，你也不必想办法将正在进行中的组件集成到你的应用程序中。Storybook是一个可以进行实验的工具。通过使用插件，你可以在担心将其集成到应用程序之前测试组件的几乎任何方面。
- en: Experimenting with props
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用props进行实验
- en: Perhaps, the most straightforward way to get started with developing components
    in Storybook is to start experimenting with different property values. To do so,
    you just have to create different stories of your component, each with different
    property values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，开始在Storybook中开发组件最直接的方法是开始尝试不同的属性值。为此，你只需要创建组件的不同故事，每个故事都有不同的属性值。
- en: 'First, let''s take a look at the component that you''re working on:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看你正在开发的组件：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There isn't much to this component. It takes four props and renders some HTML
    markup. The `title` and the `content` prop values are simple strings. The `titleStyle`
    and the `contentStyle` props are objects that are assigned to the `style` prop
    of the appropriate HTML element.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件并不复杂。它接受四个属性并呈现一些HTML标记。`title`和`content`属性的值都是简单的字符串。`titleStyle`和`contentStyle`属性是分配给相应HTML元素的`style`属性的对象。
- en: 'Let''s start writing stories for this component. Let''s assume that the same
    approach as the preceding section was used:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为这个组件编写故事。假设使用了与前一节相同的方法：
- en: '`create-react-app` is used to create the React application structure and install
    dependencies'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create-react-app`用于创建React应用程序结构并安装依赖项'
- en: '`getstorybook` is used to examine the current project and add the appropriate
    boilerplate and dependencies'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getstorybook`用于检查当前项目并添加适当的样板和依赖项'
- en: 'You can open up `src/stories/index.js` and get started with the `storiesOf()`
    function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开`src/stories/index.js`并开始使用`storiesOf()`函数：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the top-level subject that will appear in the left pane when you launch
    the Storybook UI. Underneath this function is where you add individual stories.
    Since you''re currently interested in testing out different property values, the
    stories that you add will be for the purpose of reflecting different property
    values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启动Storybook UI时将出现在左窗格中的顶级主题。在此函数下方是您添加单独故事的位置。由于您目前对测试不同的属性值感兴趣，您添加的故事将用于反映不同的属性值：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This adds a story called `No Props` to the left pane in Storybook. When you
    click on it, you''ll see what `MyComponent` looks like in the main pane when it''s
    rendered without any props:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Storybook的左窗格中添加一个名为`No Props`的故事。当您点击它时，您将看到在没有任何属性的情况下`MyComponent`在主窗格中的外观：
- en: '![](Images/b0588569-8f37-48c7-ad1c-b19b8198d29f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b0588569-8f37-48c7-ad1c-b19b8198d29f.png)'
- en: 'There''s nothing to see here because both the `title` and the `content` props
    are missing. Since these two values are the only visible rendered content, there''s
    nothing to display. Let''s switch to the next story:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么可看的，因为`title`和`content`属性都缺失。由于这两个值是唯一可见的呈现内容，所以没有内容可显示。让我们切换到下一个故事：
- en: '![](Images/191017c1-328b-4013-8204-76cbf478f95f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/191017c1-328b-4013-8204-76cbf478f95f.png)'
- en: 'This time, with the Just "title" story selected, you can see different React
    component output rendered. As the story title suggests, only the `title` property
    is being passed to `MyComponent`. Here''s the code for this story:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，选择了"Just "title" story"，您可以看到不同的React组件输出呈现。正如故事标题所示，只有`title`属性被传递给了`MyComponent`。以下是此故事的代码：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next story only passes the `content` property. Here is the result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个故事只传递了`content`属性。以下是结果：
- en: '![](Images/888a25e6-b1eb-47ea-be79-7e19bf06f86d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/888a25e6-b1eb-47ea-be79-7e19bf06f86d.png)'
- en: 'And here is the code that passes just the `content` property:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是仅传递`content`属性的代码：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next story passes both the `title` and the `content` properties to `MyComponent`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个故事将`title`和`content`属性都传递给`MyComponent`：
- en: '![](Images/d88b2ede-3ba4-4168-95f5-7544d7e6b640.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d88b2ede-3ba4-4168-95f5-7544d7e6b640.png)'
- en: 'And here is the code that renders both of these props in a story:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在故事中呈现这两个属性的代码：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At this point, you have three stories for your component and they've already
    proven useful. You've seen how `MyComponent` looks when it's rendered without
    content or without a title, for example. Based on the result, you might decide
    to make both of these props mandatory or to provide default values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的组件有三个故事，并且它们已经被证明是有用的。例如，您已经看到了`MyComponent`在没有内容或没有标题时的外观。根据结果，您可能决定将这两个属性都设为必填，或者提供默认值。
- en: 'Let''s move onto the style properties next. First, you''ll pass in just the
    `titleStyle` prop, like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们移动到样式属性。首先，您将只传递`titleStyle`属性，就像这样：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that you''re also passing the `title` and `content` properties. This way,
    you can see how the styles actually affect the content that''s rendered by `MyComponent`.
    Here''s the result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还传递了`title`和`content`属性。这样，您就可以看到样式实际上如何影响`MyComponent`渲染的内容。这是结果：
- en: '![](Images/f36bbc51-e0c7-4de7-bc74-e42d4623d055.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f36bbc51-e0c7-4de7-bc74-e42d4623d055.png)'
- en: 'Next, you''ll pass just the `contentStyle` prop:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将只传递`contentStyle`属性：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s what this looks like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的样子：
- en: '![](Images/417a9c5e-ff34-482b-9407-650144cb4aa5.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/417a9c5e-ff34-482b-9407-650144cb4aa5.png)'
- en: 'Finally, let''s pass every possible prop to `MyComponent`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将每个可能的属性传递给`MyComponent`：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s what `MyComponent` looks like with every prop passed to it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`MyComponent`传递给它的每个属性的样子：
- en: '![](Images/ad8de25f-37c4-4154-bd79-54209d0f9d21.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ad8de25f-37c4-4154-bd79-54209d0f9d21.png)'
- en: You just created seven stories for a simple component. Using the Storybook dev
    server and the Storybook user interface, it's easy to toggle between the different
    stories that you create for your component so that you can easily see the differences
    between them. This works especially well for functional components that only deal
    with props, as you just saw.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚为一个简单的组件创建了七个故事。使用Storybook开发服务器和Storybook用户界面，很容易在您为组件创建的不同故事之间切换，以便您可以轻松地看到它们之间的差异。这对于只处理属性的功能组件特别有效，就像您刚刚看到的那样。
- en: 'Here''s all of the stories that you just implemented so that you can see what
    they look like all together:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您刚刚实现的所有故事，这样您就可以看到它们一起是什么样子的：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What's nice about adding stories where each one has a different prop configuration
    for your component is that it's like taking a static snapshot of your component.
    Then, once you have several stories for your component, you can toggle between
    the snapshots. On the other hand, you might not be ready to start implementing
    several stories this way just yet. If you just want to fiddle around with prop
    values, there's a Storybook add-on called **Knobs**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的组件添加每个故事都有不同的属性配置的好处是，这就像为您的组件拍摄静态快照。然后，一旦您为组件有了几个故事，您可以在这些快照之间切换。另一方面，您可能还没有准备好以这种方式开始实现几个故事。如果您只是想玩弄属性值，有一个名为**Knobs**的Storybook插件。
- en: 'The Knobs add-on allows you to play with React component prop values through
    form controls in the Storybook UI. Let''s try out this add-on now. The first step
    is installing it in your project:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 旋钮插件允许您通过Storybook UI中的表单控件玩转React组件属性值。现在让我们试用一下这个插件。第一步是在您的项目中安装它：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, you have to tell your Storybook configuration that you want to use the
    add-on. Add the following line to `.storybook/addons.js`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须告诉您的Storybook配置，您想要使用这个插件。将以下行添加到`.storybook/addons.js`：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you can import the `withKnobs` decorator into your `stories/index.js` file,
    which is used to tell Storybook that the stories that follow will use controls
    to play with prop values. You'll also want to import the various types of knob
    controls. These are simple functions that pass values to your components as the
    values in the Storybook UI change.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将`withKnobs`装饰器导入到您的`stories/index.js`文件中，该装饰器用于告诉Storybook接下来的故事将使用控件来玩转属性值。您还需要导入各种类型的旋钮控件。这些都是简单的函数，当Storybook
    UI中的值发生变化时，它们将值传递给您的组件。
- en: 'As an example, let''s copy the same storyline as you just implemented for `MyComponent`.
    This time, instead of building a whole bunch of static stories where each one
    sets particular property values, you''ll just add one story that uses the Knobs
    add-on to control prop values. Here is what you''ll need to add as imports:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们复制刚刚为`MyComponent`实现的相同故事情节。这一次，不再构建一堆静态故事，每个故事都设置特定的属性值，而是只添加一个使用Knobs附加组件来控制属性值的故事。以下是需要添加的导入内容：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the new context for stories, along with a default story that uses knob
    controls to set and change your React component property values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是故事的新上下文，以及一个使用旋钮控件来设置和更改React组件属性值的默认故事：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The two functions that you imported from the Knobs add-on, `text()` and `object()`,
    are used to set the label for a knob control, and a default value. For example,
    `title` is using the `text()` function with a default string value, while `contentStyle`
    is using the `object()` function with a default style object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从Knobs附加组件中导入的两个函数`text()`和`object()`用于设置旋钮控件的标签和默认值。例如，`title`使用`text()`函数并带有默认字符串值，而`contentStyle`使用`object()`函数并带有默认样式对象。
- en: 'Here''s what the result looks like in the Storybook user interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Storybook用户界面中的效果如下：
- en: '![](Images/0e07dc05-62de-4056-ad26-dc3a635e7820.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0e07dc05-62de-4056-ad26-dc3a635e7820.png)'
- en: 'If you look at the bottom pane, you''ll see that there''s a KNOBS tab beside
    the ACTION LOGGER tab. Based on the functions from the Knobs add-on that you used
    to declare your story, these form controls are created. Now you can go ahead and
    play around with component prop values and watch the rendered content change on
    the fly:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看底部窗格，你会看到一个KNOBS标签，旁边是一个ACTION LOGGER标签。根据你用来声明故事的Knobs附加组件中的函数，这些表单控件被创建。现在你可以继续玩弄组件属性值，并观察呈现的内容实时变化：
- en: '![](Images/b06e39bd-adf6-4806-beda-87b2cbce7cc6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b06e39bd-adf6-4806-beda-87b2cbce7cc6.png)'
- en: If you end up finding prop values that you like, while experimenting with knob
    fields, you take these values and hardcode them into a story. It's like bookmarking
    a component configuration that works so that you can go back to it later on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在尝试旋钮字段时找到了喜欢的属性值，你可以将这些值硬编码到一个故事中。这就像是将一个组件配置标记为有效，以便以后可以返回到它。
- en: Experimenting with actions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用actions
- en: Let's shift our attention to another add-on—Actions. This add-on is enabled
    in your Storybook by default. The idea with Actions is that once you select a
    story, you can interact with the rendered page elements in the main pane. Actions
    provide you with a mechanism that logs user interactions in the Storybook UI.
    Additionally, Actions can serve as a general-purpose tool to help you monitor
    data as it flows through your components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将注意力转移到另一个附加组件——Actions。这个附加组件在你的Storybook中默认启用。Actions的理念是，一旦你选择了一个故事，你就可以与主窗格中呈现的页面元素进行交互。Actions为你提供了一种记录用户在Storybook
    UI中交互的机制。此外，Actions还可以作为一个通用工具，帮助你监视数据在组件中的流动。
- en: 'Let''s start with a simple button component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的按钮组件开始：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `MyButton` component re
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyButton`组件'
- en: 'nders a `<button>` element and assigns it an `onClick` event handler. The handler
    is actually defined by `MyComponent`; it''s passed in as a prop. So let''s create
    a story for this component and pass it an `onClick` handler function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染一个`<button>`元素并为其分配一个`onClick`事件处理程序。实际上，处理程序是由`MyComponent`定义的；它作为一个prop传递进来。因此，让我们为这个组件创建一个故事，并传递一个`onClick`处理程序函数：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Do you see the `action()` function that''s imported from `@storybook/addon-actions`?
    This is a higher-order function—a function that returns another function. When
    you call `action(''my component clicked'')`, you''re getting a new function in
    return. The new function behaves kind of like `console.log()`, in that you can
    assign it a label and log arbitrary values. The difference is that functions created
    by the Storybook `action()` add-on function is that the output is rendered right
    in the actions pane of the Storybook UI:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了从`@storybook/addon-actions`导入的`action()`函数吗？这是一个高阶函数——一个返回另一个函数的函数。当你调用`action('my
    component clicked')`时，你会得到一个新的函数作为返回。这个新函数的行为有点像`console.log()`，你可以给它分配一个标签并记录任意值。不同之处在于，Storybook
    `action()` 插件函数创建的函数的输出会直接在Storybook UI的动作面板中呈现：
- en: '![](Images/15be61dc-fc60-4a15-b122-47298b1d7f2a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15be61dc-fc60-4a15-b122-47298b1d7f2a.png)'
- en: As usual, the `<button>` element is rendered in the main pane. The content that
    you're seeing in the actions pane is the result of clicking on the button three
    times. The output is the exact same with every click, so the output is all grouped
    under the `my component clicked` label that you assigned to the handler function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，`<button>`元素被渲染在主面板中。你在动作面板中看到的内容是点击按钮三次的结果。每次点击的输出都是完全相同的，所以输出都被分组在你分配给处理函数的`my
    component clicked`标签下。
- en: In the preceding example, the event handler functions that `action()` creates
    are useful for as a substitute for actual event handler functions that you would
    pass to your components. Other times, you actually need the event handling behavior
    to run. For example, you have a controlled form field that maintains its own state
    and you want to see what happens as the state changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`action()`创建的事件处理函数对于作为你传递给组件的实际事件处理函数的替代是有用的。其他时候，你实际上需要事件处理行为来运行。例如，你有一个维护自己状态的受控表单字段，并且你想看看状态改变时会发生什么。
- en: 'For cases like these, I find the simplest and most effective approach is to
    add event handler props, even if you''re not using them for anything else. Let''s
    take a look at an example of this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的情况，我发现最简单和最有效的方法是添加事件处理程序属性，即使你没有用它们做其他事情。让我们来看一个例子：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s start by taking a look at the `defaultProps` of this component. By default,
    this component has two default handler functions for `onChange` and `onRender`—these
    do nothing so that if they''re not set, they can still be called and nothing will
    happen. As you might have guessed, we can now pass `action()` handlers to `MyRangeInput`
    components. Let''s try this out. Here''s what your `stories/index.js` looks like
    now:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下这个组件的`defaultProps`。默认情况下，这个组件有两个`onChange`和`onRender`的默认处理函数，它们什么也不做，所以如果它们没有设置，仍然可以被调用而不会发生任何事情。正如你可能已经猜到的，现在我们可以将`action()`处理程序传递给`MyRangeInput`组件。让我们试一试。现在你的`stories/index.js`看起来是这样的：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now when you view this story in the Storybook UI, you should see lots of actions
    logged when you slide the range input slider:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你在Storybook UI中查看这个故事时，你应该会看到在滑动范围输入滑块时记录了很多动作。
- en: '![](Images/7c18980a-87db-4227-a3b5-76ae7b9e307f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7c18980a-87db-4227-a3b5-76ae7b9e307f.png)'
- en: As the slider handle moves, you can see the two event handler functions that
    you've passed to the component are logging the value at different stages of the
    component rendering life cycle. The most recent action is logged at the top of
    the pane, unlike browser dev tools which logs the most recent value at the bottom.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当滑块移动时，你可以看到传递给组件的两个事件处理函数在组件渲染生命周期的不同阶段记录了值。最近的操作被记录在面板顶部，不像浏览器开发工具会在底部记录最近的值。
- en: 'Let''s revisit the `MyRangeInput` code for a moment. The first function that''s
    called when the slider handle moves is the change handler:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾一下`MyRangeInput`代码。滑块移动时调用的第一个函数是更改处理程序：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This `onChange()` method is internal to `MyRangeInput`. It's needed because
    the `<input>` element that it renders uses the component state as the single source
    of truth. These are called controlled components in React terminology. First,
    it sets the state of the value using the `target.value` property from the event
    argument. Then, it calls `this.props.onChange()`, passing it the same value. This
    is how you can see the even value in the Storybook UI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`onChange()`方法是`MyRangeInput`内部的。它是必需的，因为它渲染的`<input>`元素使用组件状态作为唯一的真相来源。在React术语中，这些被称为受控组件。首先，它使用事件参数的`target.value`属性设置值的状态。然后，它调用`this.props.onChange()`，将相同的值传递给它。这就是您可以在Storybook
    UI中看到事件值的方式。
- en: Note that this isn't the right place to log the updated state of the component.
    When you call `setState()`, you have to make the assumption that you're done dealing
    with state in the function because it doesn't always update synchronously. Calling
    `setState()` only schedules the state update and the subsequent re-render of your
    component.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不是记录组件的更新状态的正确位置。当您调用`setState()`时，您必须假设您在函数中已经处理完状态，因为它并不总是同步更新。调用`setState()`只安排了状态更新和随后的重新渲染组件。
- en: 'Here''s an example of how this can cause problems. Let''s say that instead
    of logging the value from the event argument, you logged the value state after
    setting it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可能会引起问题的例子。假设您不是记录事件参数中的值，而是在设置后记录值状态：
- en: '![](Images/64116467-b4fd-4379-a34d-158e29be003e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/64116467-b4fd-4379-a34d-158e29be003e.png)'
- en: There's a bit of a problem here now. The `onChange` handler is logging the old
    state while the `onRender` handler is logging the updated state. This sort of
    logging output is super confusing if you're trying to trace an event value to
    rendered output—things don't line up! Never log state values after calling `setState()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了一点问题。`onChange`处理程序记录了旧状态，而`onRender`处理程序记录了更新后的状态。如果您试图追踪事件值到呈现的输出，这种记录输出会非常令人困惑-事情不会对齐！永远不要在调用`setState()`后记录状态值。
- en: If the idea of calling noop functions makes you feel uncomfortable, then maybe
    this approach to displaying actions in Storybook isn't for you. On the other hand,
    you might find that having a utility to log essentially anything at any point
    in the life cycle of your component without the need to write a bunch of debugging
    code inside your component. For such cases, Actions are the way to go.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用空操作函数的想法让您感到不舒服，那么在Storybook中显示操作的这种方法可能不适合您。另一方面，您可能会发现，无需在组件内部编写大量调试代码，就可以在组件的生命周期的任何时刻记录基本上任何内容的实用程序。对于这种情况，操作是一种方法。
- en: Linking stories together
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接故事在一起
- en: The Links Storybook add-on allows you to link stories together in the same way
    that you would link regular web pages together. Storybook has a navigation pane
    that allows you to switch from story to story. This is useful as a table of contents.
    But when you're reading content on the web, you typically find several links in
    a single paragraph of text. Imagine if the only way to move around on the web
    were to look through the links in the table of contents in each document, it'd
    be painful.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 链接故事书附加组件允许您以与链接常规网页相同的方式将故事链接在一起。故事书有一个导航窗格，允许您从一个故事切换到另一个故事。这就像一个目录一样有用。但是当您在网上阅读内容时，通常会在一个段落中找到几个链接。想象一下，如果在网上移动的唯一方法是查看每个文档中的目录中的链接，那将是痛苦的。
- en: 'For the same reason that embedding links within content on the web is valuable,
    embedding links in Storybook output is valuable: they provide context. Let''s
    take a look at an example of links in action. Like Actions, the links add-on is
    enabled by default when you run the `getstorybook` command in your project. Here''s
    the component that you''ll write stories for:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页内容中嵌入链接有价值的原因，同样在Storybook输出中嵌入链接也是有价值的：它们提供了上下文。让我们看一个链接实际应用的例子。与Actions一样，当您在项目中运行`getstorybook`命令时，链接插件默认启用。这是您将为其编写故事的组件：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This component accepts `headingText` and `children` properties. Now let''s
    write some Storybook stories that are linked together. Here are three stories
    that are all linked to each other within the output pane:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件接受`headingText`和`children`属性。现在让我们编写一些相互关联的Storybook故事。以下是三个故事，它们在输出窗格中都相互关联：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s walk through each of these stories so that you can see how they''re
    linked to each other. First, there''s the default story:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个讲解这些故事，这样您就可以看到它们是如何相互关联的。首先是默认故事：
- en: '![](Images/f5870cd4-8d7c-4af9-89b6-f2db070f02a9.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f5870cd4-8d7c-4af9-89b6-f2db070f02a9.png)'
- en: 'You can see the rendered content of `MyComponent`, which consists only of heading
    text because you didn''t pass it any children. Moreover, this is just the default
    heading text, as the content rendered below the component explains. The content
    handily links to a story that renders different heading text:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`MyComponent`的渲染内容，其中只包含标题文本，因为您没有传递任何子元素。此外，这只是默认的标题文本，因为在组件下方呈现的内容解释了这一点。这个内容方便地链接到一个呈现不同标题文本的故事：
- en: '![](Images/c749e9bb-4030-467f-a6b5-3a2e774214eb.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c749e9bb-4030-467f-a6b5-3a2e774214eb.png)'
- en: 'Once again, you can see the rendered component with the custom `headingText`
    prop value and a note below the component that links to another story. In this
    case, the link takes the user to a story that passes a child element to `MyComponent`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以看到使用自定义`headingText` prop值呈现的组件，并在组件下方有一个链接到另一个故事的注释。在这种情况下，链接将用户带到一个将子元素传递给`MyComponent`的故事：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There''s also a button that uses the `linkTo()` function to build a callback
    function that takes the user to the linked story instead of the `<LinkTo>` component
    which renders a link:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个按钮，它使用`linkTo()`函数构建一个回调函数，该函数将用户带到链接的故事，而不是渲染链接的`<LinkTo>`组件：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both approaches take a kind argument, but they're omitted here because we're
    linking from within the `MyComponent` kind. The ability to link stories together
    like this takes you a step closer to using Storybook as a tool for documenting
    your React components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都需要一个kind参数，但在这里被省略了，因为我们是从`MyComponent` kind内部进行链接。像这样链接故事的能力使您更接近将Storybook作为记录React组件的工具。
- en: Stories as documentation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事作为文档
- en: Storybook is much more than a convenient place to isolate your components while
    they're developed. With add-ons, it's also an effective tool for documenting your
    components. As your application grows, it's all the more compelling to have something
    like Storybook in place. Other developers are likely going to have to work with
    components that you've created. Wouldn't it be nice if they could look at Storybook
    stories to see the various ways your component can be used?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook不仅仅是一个方便的地方，可以在开发过程中隔离您的组件。通过插件，它也是一个有效的记录组件的工具。随着应用程序的增长，拥有类似Storybook这样的工具变得更加具有吸引力。其他开发人员可能需要使用您创建的组件。如果他们可以查看Storybook故事来了解组件的各种用法，那不是很好吗？
- en: The last add-on that we'll look at in this chapter is called Info. It provides
    usage info about the component in a nicely-presented format, in addition to the
    standard rendered component output.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章我们将看一下的最后一个插件叫做Info。它以一个漂亮的格式提供关于组件的使用信息，除了标准的渲染组件输出之外。
- en: 'Let''s create a couple of components that we want to document. Instead of writing
    every story in `stories/index.js` like you have been throughout this chapter,
    let''s separate your stories into something more consumable:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些我们想要记录的组件。与其像本章节一直以来那样在`stories/index.js`中编写每个故事，不如把你的故事分开成更易消化的内容：
- en: '`stories/MyButton.story.js`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stories/MyButton.story.js`'
- en: '`stories/MyList.story.js`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stories/MyList.story.js`'
- en: 'The stories for the two components that you''re about to implement will be
    separated in their own modules, which will be a little easier to maintain going
    forward. Another change that you''ll have to make in order to support this new
    file layout is in `.storybook/config.js`. Here, you''ll have to require your two
    story modules individually:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将要实现的两个组件的故事将分别在它们自己的模块中，这样以后维护起来会更容易一些。为了支持这种新的文件布局，你还需要在`.storybook/config.js`中做一些改变。在这里，你需要分别引入你的两个故事模块：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s take a look at the components now. First, there''s `MyButton`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看这些组件。首先是`MyButton`：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can see that `MyButton` defines a `propTypes` property; you''ll see why
    this is important for the Info Storybook add-on shortly. Next, let''s look at
    the `MyList` component:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`MyButton`定义了一个`propTypes`属性；很快你就会明白为什么这对于Info Storybook插件很重要。接下来，让我们看看`MyList`组件：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This component also defines a `propTypes` property. It defines a `defaultProps`
    property as well so that when the `items` property isn't provided, it has an empty
    array by default so that the call to `map()` still works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件还定义了一个`propTypes`属性。它也定义了一个`defaultProps`属性，这样当`items`属性没有提供时，默认情况下它是一个空数组，这样调用`map()`仍然有效。
- en: 'Now you''re ready to write stories for these two components. Keeping in mind
    that you also want these stories to serve as the main source of documentation
    for your components, you''ll use the Info add-on for Storybook to give users more
    usage information for any given story. Let''s start with `MyButton.story.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好为这两个组件编写故事了。记住你还希望这些故事作为组件的主要文档来源，你将使用Storybook的Info插件为任何给定的故事提供更多的使用信息。让我们从`MyButton.story.js`开始：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, you're documenting `MyButton` using two stories, each of which show a
    different way to use the component. The first story shows the basic usage and
    the second story shows how to pass a click handler property. The new addition
    to these stories is the call to `withInfo()`. This function is from the Info Storybook
    add-on, and you can pass it some text (markdown supported) that goes into more
    detail about the story. In other words, this is where you document a specific
    use of your component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用两个故事来记录`MyButton`，每个故事展示了组件的不同使用方式。第一个故事展示了基本用法，第二个故事展示了如何传递一个点击处理程序属性。这些故事的新添加是调用`withInfo()`。这个函数来自Info
    Storybook插件，你可以传递一些文本（支持markdown），更详细地说明故事。换句话说，这是你记录组件特定用法的地方。
- en: 'Now let''s look at `MyList.story.js` before we see what the output of the Info
    add-on looks like in the Storybook UI:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们先看看`MyList.story.js`，然后再看看Info插件在Storybook UI中的输出是什么样子的：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This looks a lot like the stories defined for `MyButton`—different docs and
    components, same overall structure and approach.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像为`MyButton`定义的故事——不同的文档和组件，相同的整体结构和方法。
- en: 'Let''s take a look at the default usage story for `MyButton`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`MyButton`的默认使用故事：
- en: '![](Images/173851a2-9514-4873-95b8-f97a22cb9643.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/173851a2-9514-4873-95b8-f97a22cb9643.png)'
- en: 'As expected, the button is rendered in the output pane so that users can see
    what they''re working with. In the top-right corner of the output pane, there''s
    an info button. When you click on it, you see all of the extra info provided by
    calling `withInfo()` in your story:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，按钮会在输出窗格中呈现，以便用户可以看到他们正在使用的内容。在输出窗格的右上角，有一个信息按钮。当您点击它时，您会看到通过在故事中调用`withInfo()`提供的所有额外信息：
- en: '![](Images/2c317cd2-ae23-4c2a-9426-5ac0f3ec2975.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2c317cd2-ae23-4c2a-9426-5ac0f3ec2975.png)'
- en: 'This reveals all sorts of information about the story, and the component that
    you''re documenting. From top to bottom, here is what it displays:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示有关故事和您正在记录的组件的各种信息。从上到下，这是它显示的内容：
- en: Component name
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件名称
- en: Story name
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事名称
- en: Usage documentation (provided as an argument to `withInfo()`)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用法文档（作为`withInfo()`的参数提供）
- en: Source used to render component
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于呈现组件的源
- en: Properties available to component (read from `propTypes`)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可用的属性（从`propTypes`中读取）
- en: The nice thing about the Info add-on is that it shows your users the source
    used to render the output that they're looking at, and shows the available properties
    if you provide them as prop types. This means that someone who is trying to understand
    and use your components can get the information they need without you, the component
    author, putting in a ton of extra effort.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Info插件的好处在于它显示了用于呈现用户正在查看的输出的源，并且如果您将其提供为属性类型，则显示可用属性。这意味着试图理解和使用您的组件的人可以在您作为组件作者不费吹灰之力的情况下获得他们所需的信息。
- en: 'Let''s take a look at the `MyList` component when it''s passed an array of
    items:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当`MyList`组件传递一个项目数组时的情况：
- en: '![](Images/2395c76a-2243-4bf8-8060-29eb28788f9a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2395c76a-2243-4bf8-8060-29eb28788f9a.png)'
- en: 'It renders a list of items that it gets through a prop. Let''s look at the
    info for this story now:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它呈现了通过属性获取的项目列表。现在让我们看看这个故事的信息：
- en: '![](Images/8d69e330-f9e9-440c-a697-7b86d579b607.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8d69e330-f9e9-440c-a697-7b86d579b607.png)'
- en: By looking at the information about this story, you can see at a glance the
    props that this component accepts, what their default values are, and the code
    that was used to generate the example, all in one place. I also like the fact
    that the info pane is hidden by default, meaning that you can navigate through
    stories and look for the end result that you need, and only then worry about the
    details.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看有关此故事的信息，您可以一目了然地看到此组件接受的属性、它们的默认值以及用于生成示例的代码，所有这些都在一个地方。我还喜欢信息窗格默认情况下是隐藏的这一事实，这意味着您可以浏览故事并寻找所需的最终结果，然后再担心细节。
- en: Building static Storybook apps
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建静态Storybook应用程序
- en: If you're building component library that you either want to distribute as an
    open source project or as something that's shared with various teams within your
    organization, you can use Storybook as the tool that documents how to work with
    your components. That said, you might not want to have a Storybook server running
    or you might just want to host the Storybook documentation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建组件库，并希望将其作为开源项目或与组织内的各个团队共享的内容，您可以使用Storybook作为记录如何使用您的组件的工具。也就是说，您可能不希望运行Storybook服务器，或者只想托管Storybook文档。
- en: In either scenario, you need a static build of the stories that you've written
    for your component library. Storybook provides you with this utility when you
    run the `getstorybook` command.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一种情况下，您都需要组件库的故事的静态构建。当您运行`getstorybook`命令时，Storybook会为您提供此实用程序。
- en: 'Let''s continue with the example from the preceding section where you used
    Storybook to document the usage scenarios of your two components. To build your
    static Storybook documentation, all you have to do is run the following command
    from within your project directory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用前一节的示例，您在其中使用Storybook来记录两个组件的使用场景。要构建您的静态Storybook文档，您只需在项目目录中运行以下命令：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see output that looks like the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once built, you'll see a new `storybook-static` directory in your project folder.
    Inside, you'll see several files, including the static JavaScript bundles created
    by Webpack and an `index.html` file that you can serve from any web server or
    simply open directly in your web browser.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，您将在项目文件夹中看到一个新的`storybook-static`目录。在其中，您将看到几个文件，包括由Webpack创建的静态JavaScript捆绑包和一个`index.html`文件，您可以从任何Web服务器提供，或者直接在Web浏览器中打开。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was the focus of a tool called Storybook. Storybook provides React
    developers with a sandboxed environment that makes it easy to develop React components
    on their own. This can be difficult when the only environment you have is the
    application that you're working on. Storybook provides a level of development
    isolation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个名为Storybook的工具的重点。Storybook为React开发人员提供了一个沙盒环境，使他们可以轻松地独立开发React组件。当您唯一的环境是您正在工作的应用程序时，这可能会很困难。Storybook提供了一定程度的开发隔离。
- en: First, you learned how to install the global Storybook command-line utility
    and how to use this utility to get Storybook set up in your `create-react-app`
    projects. Next, you learned how to write stories that show different perspectives
    of a component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您学会了如何安装全局Storybook命令行实用程序，以及如何使用此实用程序在您的`create-react-app`项目中设置Storybook。接下来，您学会了如何编写展示组件不同视角的故事。
- en: Then, you learned that a good portion of Storybook functionality comes from
    add-ons. You learned that Actions help with logging and that links provide a mechanism
    for navigation beyond the default. You also learned how to write documentation
    for React components using Storybook. We closed the chapter with a look at building
    static Storybook content.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您了解到Storybook功能的很大一部分来自于插件。您了解到Actions可以帮助记录日志，链接提供了超出默认范围的导航机制。您还学会了如何使用Storybook为React组件编写文档。我们在本章结束时看了一下构建静态Storybook内容。
- en: In the next chapter, you'll explore the React tooling available within web browsers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将探索Web浏览器中可用的React工具。
