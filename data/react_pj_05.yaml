- en: Build a Personal Shopping List Application Using Context API and Hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文API和Hooks构建个人购物清单应用程序
- en: State management is a very important part of modern web and mobile applications
    and is something that React is very good at. Handling state management in React
    applications can be quite confusing, as there are multiple ways you can handle
    the current state of your application. The projects you created in the first four
    chapters of this book haven't been focusing on state management too much, something
    that will be investigated much more in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理是现代Web和移动应用程序的一个非常重要的部分，也是React擅长的领域。在React应用程序中处理状态管理可能会相当令人困惑，因为有多种方式可以处理应用程序的当前状态。本书前四章创建的项目并没有过多关注状态管理，这一点将在本章中更加深入地探讨。
- en: This chapter will show how you can handle state management in React, by creating
    a global state for your application that is accessible from every component. Before
    React v16.3, you needed third-party packages to handle global state in React, but
    with the renewed version of the context API, this is no longer mandatory. Also,
    with the release of React Hooks, more ways to mutate this Context were introduced.
    Using an example application, the methods to handle global state management for
    your application are demonstrated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示如何在React中处理状态管理，通过为应用程序创建一个全局状态，可以从每个组件中访问。在React v16.3之前，您需要第三方包来处理React中的全局状态，但是随着上下文API的更新版本，这不再是必需的。此外，随着React
    Hooks的发布，引入了更多改变此上下文的方法。使用一个示例应用程序，演示了处理应用程序全局状态管理的方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using the context API for state management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文API进行状态管理
- en: '**Higher-Order Components** (**HOC**) and Context'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶组件**（**HOC**）和上下文'
- en: Mutating Context with Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks改变上下文
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a **Progressive Web App** (**PWA**) with declarative
    routing using `react-router`, which handles global state management using Context
    and React Hooks. Also, HOC is used to access data throughout the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`react-router`创建一个**渐进式Web应用程序**（**PWA**），它使用上下文和React Hooks进行全局状态管理。此外，HOC用于在整个应用程序中访问数据。
- en: Build time is 2.5 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2.5小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch5-initial](https://github.com/PacktPublishing/React-Projects/tree/ch5-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch5](https://github.com/PacktPublishing/React-Projects/tree/ch5).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将创建的项目是在GitHub上找到的初始版本的基础上构建的：[https://github.com/PacktPublishing/React-Projects/tree/ch5-initial](https://github.com/PacktPublishing/React-Projects/tree/ch5-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch5](https://github.com/PacktPublishing/React-Projects/tree/ch5)。
- en: After downloading the initial application, make sure that you run `npm install` from
    the project's root directory. This project is created using Create React App and
    installs the `react`, `react-dom`, `react-scripts`, `styled-components`, and `react-router` packages,
    which you've already seen in previous chapters. After finishing the installation
    process, you can run `npm start` from the same tab in Terminal and view the project
    in your browser (`http://localhost:3000`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下载初始应用程序后，请确保从项目的根目录运行`npm install`。该项目是使用Create React App创建的，并安装了`react`、`react-dom`、`react-scripts`、`styled-components`和`react-router`等包，这些包在前几章中已经见过。安装完成后，您可以在终端的同一个标签页中运行`npm
    start`，并在浏览器中查看项目（`http://localhost:3000`）。
- en: As the project is created with Create React App, the service workers are registered
    to have the application run as a PWA. You can check this by running `npm run build` first
    and `serve -s build` once the build process is completed. The build version of
    the application can now be visited at `http://localhost:5000`. In case you visit
    the application on this URL and see a different one, it might be that the built
    version of an application you've created in any of the preceding chapters is still
    being served. This might be due to the browser cache created by a service worker. You
    can clear any previous application from the browser cache by opening Developer
    Tools on your browse and open the Application tab, where you can click on the Clear
    site data button on the Clear Storage section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目是使用Create React App创建的，因此已注册服务工作者以使应用程序作为PWA运行。您可以通过首先运行`npm run build`，然后在构建过程完成后运行`serve
    -s build`来检查此功能。现在可以访问应用程序的构建版本`http://localhost:5000`。如果您访问此URL上的应用程序并看到不同的URL，可能是您在任何先前章节中创建的应用程序的构建版本仍在提供。这可能是由服务工作者创建的浏览器缓存造成的。您可以通过在浏览器上打开开发者工具并打开“应用程序”选项卡，在那里您可以单击“清除站点数据”部分上的“清除存储”按钮来清除浏览器缓存中的任何先前的应用程序。
- en: To check whether the application is really still available when there is no
    internet connection, you can have the browser simulate an offline situation. The
    option to enable this can be found in the Application tab in the browser's Developer
    Tools. Inside this tab, you can find Service Workers in the menu on the left and,
    after clicking this link, you can select the Offline checkbox on the page that
    appears.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 检查应用程序在没有互联网连接时是否仍然可用，您可以让浏览器模拟离线情况。启用此选项可以在浏览器的开发者工具中的“应用程序”选项卡中找到。在此选项卡中，您可以在左侧菜单中找到“服务工作者”，单击此链接后，可以在出现的页面上选择“离线”复选框。
- en: 'The initial application for this section is available at `http://localhost:3000` and
    is a bit more advanced than in any of the previous chapters. When you open the
    application, a screen displaying a header, a subheader, and two lists is being
    rendered. If you, for example, click on the first list that is displayed here,
    a new page will open that displays the items of this list. On this page, you can
    click on the Add List button at the top-right to open a new page, which has a
    form to add a new list and looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的初始应用程序位于`http://localhost:3000`，比以往任何一章都要先进一些。打开应用程序时，将呈现显示标题、副标题和两个列表的屏幕。例如，如果您单击此处显示的第一个列表，将打开一个新页面，显示此列表的项目。在此页面上，您可以单击右上角的“添加列表”按钮打开一个新页面，该页面具有添加新列表的表单，并且看起来像这样：
- en: '![](assets/b98a5a77-3dfa-4140-b1a3-10a6c27951ad.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b98a5a77-3dfa-4140-b1a3-10a6c27951ad.png)'
- en: This form is rendered by the `Form` component and has no functionality yet,
    as you'll add this later on. When you click on the left button, it redirects you
    to the previously visited page, using the `history.goBack` method from `react-router`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单由`Form`组件呈现，但尚无功能，因为稍后将添加此功能。当您单击左侧按钮时，它将使用`react-router`中的`history.goBack`方法将您重定向到先前访问的页面。
- en: When you try to submit the form to either add a new list or add a new item to
    a list, nothing happens yet. The functionality of these forms will be added in
    this section later on, for which you'll use the context API and React Hooks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试提交表单以添加新列表或向列表中添加新项目时，什么也不会发生。这些表单的功能将稍后在本节中添加，您将使用上下文API和React Hooks。
- en: The project is structured in the same manner as with the applications you've
    created before. A distinction between reusable function components in the `components` directory and
    class components in the `containers` directory is made. The class components are
    wrapped with a HOC called `withDataFetching`, which adds data fetching and life
    cycles (`componentDidMount`) to these components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的结构与您之前创建的应用程序的结构相同。在`components`目录中区分了可重用的函数组件和`containers`目录中的类组件。类组件被包装在一个名为`withDataFetching`的HOC中，该HOC为这些组件添加了数据获取和生命周期（`componentDidMount`）。
- en: The `withDataFetching` HOC is a slightly modified version of the HOC you created
    in [Chapter 2](ee5cf0ab-57c2-48bc-8c50-281de22969c5.xhtml), *Creating a Progressive
    Web Application with Reusable React Components*, which was also called `withDataFetching.js`.
    This modified version is a curried component, meaning it takes multiple arguments
    at once. In the case of a HOC, this means that you can't only use a component
    as an argument, but you also need to use the props for this component as an argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`withDataFetching` HOC是在[第2章](ee5cf0ab-57c2-48bc-8c50-281de22969c5.xhtml)中创建的HOC的略微修改版本，即*使用可重用的React组件创建渐进式Web应用程序*，该版本也被称为`withDataFetching.js`。这个修改后的版本是一个柯里化组件，意味着它一次接受多个参数。在HOC的情况下，这意味着您不仅可以将组件用作参数，还需要将此组件的props用作参数。'
- en: 'The following is an overview of the complete structure of the project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是项目的完整结构概述：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The entry point of this application is the `src/index.js` file that renders
    the `App` class component within a `Router` component from `react-router`. The `App` component contains
    a `Header` component and a `Switch` router component that defines four routes.
    These routes are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的入口点是`src/index.js`文件，它在`react-router`的`Router`组件中渲染`App`类组件。`App`组件包含一个`Header`组件和一个`Switch`路由组件，定义了四个路由。这些路由如下：
- en: '`/`: Renders `Lists`, with an overview of all of the lists'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：渲染`Lists`，显示所有列表的概述'
- en: '`/list/:id`: Renders `List`, with an overview of all items from a specific
    list'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/:id`：渲染`List`，显示特定列表中所有项目的概述'
- en: '`/list/:id/new`: Renders `Form`, with a form to add new items to a specific
    list'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/:id/new`：渲染`Form`，显示向特定列表添加新项目的表单'
- en: 'The data is fetched from a mock server that was created using the free service, My
    JSON Server, which creates a server from the `db.json` file in the root directory
    of your project in GitHub. This file consists of a JSON object that has two fields, `items` and `lists`,
    which creates multiple endpoints on a mock server. The ones you''ll be using in
    this chapter are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是从一个使用免费服务创建的模拟服务器中获取的，该服务是My JSON Server，它从GitHub项目的根目录中的`db.json`文件创建服务器。该文件包含一个具有两个字段`items`和`lists`的JSON对象，它在模拟服务器上创建了多个端点。在本章中，您将使用的端点如下：
- en: '`https://my-json-server.typicode.com/<your-username>/<your-repo>/items`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://my-json-server.typicode.com/<your-username>/<your-repo>/items`'
- en: '`https://my-json-server.typicode.com/<your-username>/<your-repo>/lists`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://my-json-server.typicode.com/<your-username>/<your-repo>/lists`'
- en: The `db.json` file must be present in the master branch (or default branch)
    of your GitHub repository for the My JSON Server to work. Otherwise, you'll receive
    a 404 Not Found message when trying to request the API endpoints.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.json`文件必须存在于您的GitHub存储库的主分支（或默认分支）中，以使My JSON Server正常工作。否则，在尝试请求API端点时，您将收到404
    Not Found的消息。'
- en: Personal shopping list
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人购物清单
- en: In this section, you'll build a personal shopping list application that has
    global state management using Context and React Hooks. With this application,
    you can create shopping lists that you can add items to, along with their quantities
    and prices. The starting point of this section is an initial application that
    has routing and local state management already enabled.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将构建一个个人购物清单应用程序，该应用程序使用Context和React Hooks进行全局状态管理。通过这个应用程序，您可以创建购物清单，并添加商品、数量和价格。本节的起点是一个已启用路由和本地状态管理的初始应用程序。
- en: Using the context API for state management
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文API进行状态管理
- en: State management is very important, as the current state of the application
    holds data that is valuable to the user. In previous chapters, you've already
    used local state management by setting an initial state in `constructor` and updating
    this with the `this.setState` method. This pattern is very useful when the data
    in the state is only of importance to the component you're setting the state in.
    As passing down the state as props through several components can become confusing,
    you'd need a way to access props throughout your application even when you're
    not specifically passing them as props. For this, you can use the context API
    from React, which is also used by packages you've already used in previous chapters
    such as `styled-components` and `react-router`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理非常重要，因为应用程序的当前状态包含对用户有价值的数据。在之前的章节中，您已经通过在`constructor`中设置初始状态并使用`this.setState`方法进行更新来使用本地状态管理。当状态中的数据只对设置状态的组件重要时，这种模式非常有用。由于通过多个组件传递状态作为props可能会变得混乱，您需要一种方法来在整个应用程序中访问props，即使您没有专门将它们作为props传递。为此，您可以使用React的上下文API，这也是您在之前章节中已经使用的包（如`styled-components`和`react-router`）所使用的。
- en: To share state across multiple components, a React feature called Context will
    be explored, starting in the first part of this section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个组件之间共享状态，将探讨一个名为Context的React功能，从本节的第一部分开始。
- en: Creating Context
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Context
- en: When you want to add Context to your React application, you can do this by creating
    a new Context with the `createContext` method from React. This creates a Context
    object that consists of two React components, called **Provider** and **Consumer**.
    The Provider is where the initial (and subsequently current) value of the Context
    is placed, which can be accessed by components that are present within the Consumer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要将Context添加到React应用程序中时，可以通过使用React的`createContext`方法创建一个新的Context来实现。这将创建一个由两个React组件组成的Context对象，称为**Provider**和**Consumer**。Provider是Context的初始（以及随后的当前）值所在的地方，可以被存在于Consumer中的组件访问。
- en: 'This is done in the `App` component in `src/containers/App.js`, as you want
    the Contexts for the lists to be available in every component that is rendered
    by `Route`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`src/containers/App.js`中的`App`组件中完成的，因为您希望列表的上下文在由`Route`渲染的每个组件中都可用。
- en: 'Let''s start by creating a Context for the lists and make it exportable so
    that the list data can be used everywhere. For this, you can create a new file
    called `ListsContextProvider.js` inside a new directory, `src/Context`. In this
    file, you can add the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先为列表创建一个Context，并将其导出，以便列表数据可以在任何地方使用。为此，您可以在一个新目录`src/Context`中创建一个名为`ListsContextProvider.js`的新文件。在这个文件中，您可以添加以下代码：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code creates a Provider based on a Context component that is passed
    as a prop and sets a value based on the return from the `withDataFetching` HOC
    that is fetching all of the lists. Using the `children` prop, all of the components
    that will be wrapped inside the `ListsContextProvider` component can retrieve
    the data for the value from a Consumer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码基于传递为prop的Context组件创建了一个Provider，并根据从获取所有列表的`withDataFetching` HOC的返回设置了一个值。使用`children`
    prop，所有将包装在`ListsContextProvider`组件内的组件都可以从Consumer中检索值的数据。
- en: 'This `ListsContextProvider` component and the Context can be imported inside
    your `App` component in `src/containers/App.js`, where it should subsequently
    be placed around the `Switch` component. The `ListsContext` object is also imported,
    as, you can''t create the Consumer later on:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`ListsContextProvider`组件和上下文可以在`src/containers/App.js`中的`App`组件中导入，随后应该放在`Switch`组件周围。`ListsContext`对象也被导入，因为之后无法创建Consumer：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This way, you''re now able to add a Consumer for `ListsContext`, which is nested
    within the `ListsContextProvider` component that holds the Provider for `ListsContext`.
    This Consumer returns the value from the Provider, which contains the list data
    that was fetched before:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，您现在可以为`ListsContext`添加一个Consumer，它嵌套在包含`ListsContext`的Provider的`ListsContextProvider`组件中。这个Consumer返回Provider中包含的值，其中包含之前获取的列表数据：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To actually pass this list data to any of the components rendered by `Route`,
    you should change the way the component is passed to the `Route` component. Instead
    of telling `Route` which component to render, you can also use the `RenderProps`
    pattern for React. This pattern refers to a technique for sharing code between
    React components using a prop whose value is a function that returns a component.
    In this case, you want the `Route` component to render a component and not just
    add the `react-router` props to it but also the list data from `ListsContext`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此列表数据实际传递给`Route`渲染的任何组件，您应该更改将组件传递给`Route`组件的方式。您可以使用React的`RenderProps`模式，而不是告诉`Route`要渲染哪个组件。这种模式是指一种在React组件之间共享代码的技术，使用一个值为返回组件的函数的prop。在这种情况下，您希望`Route`组件渲染一个组件，不仅将`react-router`的props添加到其中，还要添加来自`ListsContext`的列表数据：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you now look at the Network tab in the browser''s Developer Tools, you can
    see the API is fetched twice. As the lists are now also being fetched by `ListsContextProvider`,
    the `Lists` component itself doesn''t have to fetch the API anymore as it''s now
    sent as a prop. Therefore, you can make the following changes to `src/containers/Lists.js`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在查看浏览器的开发者工具中的网络选项卡，您会看到API被获取了两次。由于现在`ListsContextProvider`也在获取列表，因此`Lists`组件本身不再需要获取API，因为它现在作为prop发送。因此，您可以对`src/containers/Lists.js`进行以下更改：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you've removed the `withDataFetching` HOC from `Lists`, no duplicate requests to
    the API are sent anymore. The data for the lists is fetched from `ListsContextProvider` and
    is passed by `ListsContext.Consumer` to `Lists`. If you open the application in
    the browser by going to `http://localhost:3000/`, you can see the lists are being
    rendered just as before.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经从`Lists`中删除了`withDataFetching` HOC，不再发送重复的API请求。列表的数据是从`ListsContextProvider`中获取的，并由`ListsContext.Consumer`传递给`Lists`。如果通过转到`http://localhost:3000/`在浏览器中打开应用程序，您会看到列表像以前一样被渲染。
- en: 'Something else you can do is to send the list data to the `List` component
    as well, so you could, in the example, display the name of the selected lists
    when you click on a list from the home page:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将列表数据发送到`List`组件中，这样，例如，当您从主页点击列表时，可以显示所选列表的名称：
- en: 'For this, you use the `RenderProps` pattern again, this time for `Route`, which
    renders `List`. This makes sure `lists` is available and renders the `List` component
    afterward, which also takes all of the `react-router` props:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，您再次使用`RenderProps`模式，这次是为`Route`渲染`List`。这确保了`lists`是可用的，并在之后渲染`List`组件，该组件还接受所有的`react-router`
    props：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `List` component in the `src/containers/List.js` file, you can retrieve
    the lists from the props. This array needs to be filtered for the correct `list`
    and the found object contains `title`, which can be added to the `SubHeader` component
    so that it will be displayed on the page:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/containers/List.js`文件中的`List`组件中，您可以从props中检索列表。这个数组需要被过滤以获取正确的`list`，找到的对象包含`title`，可以添加到`SubHeader`组件中，这样它就会显示在页面上：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With these additions, `title` of the current list will now be displayed if
    you visit the project at `http://localhost:3000/list/1`. In the `SubHeader` component,
    the title Daily groceries is now visible, which looks similar to the following
    screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些添加，如果您访问`http://localhost:3000/list/1`，当前列表的`title`现在将显示。在`SubHeader`组件中，标题"Daily
    groceries"现在可见，看起来类似于以下截图：
- en: '![](assets/c48fd6c0-648d-4305-8e55-61d57a15c80b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c48fd6c0-648d-4305-8e55-61d57a15c80b.png)'
- en: In the next section, you'll also add a Context object for the items, so the
    items are also available to all of the components within the `Switch` component
    from `react-router`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您还将为项目添加一个Context对象，这样项目也可以在`react-router`的`Switch`组件内的所有组件中使用。
- en: Nesting Context
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套上下文
- en: 'Just as for the list data, the item data could also be stored in Context and
    passed to the components that need this data. That way, data is no longer fetched
    from any of the rendered components but from the `ContextProvider` components
    in the `src/Providers` directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对于列表数据一样，项目数据也可以存储在Context中，并传递给需要这些数据的组件。这样，数据不再从任何渲染的组件中获取，而是从`src/Providers`目录中的`ContextProvider`组件中获取：
- en: 'Again, start by creating a new component where both a Context and Provider
    are created. This time, it''s called `ItemsContextProvider`, which can also be
    added to the `src/Context` directory in a file called `ItemsContextProvider.js`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，首先创建一个新的组件，其中创建了一个Context和Provider。这次，它被称为`ItemsContextProvider`，也可以添加到`src/Context`目录中，文件名为`ItemsContextProvider.js`：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, import this new Context and `ContextProvider` in `src/containers/App.js`,
    where you can nest this inside the `ListsContextProvider` component:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`src/containers/App.js`中导入这个新的Context和`ContextProvider`，您可以将其嵌套在`ListsContextProvider`组件内：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ItemsContextProvider` is now nested below `ListsContextProvider`, which means
    `Consumer` for `ItemsContext` can also be nested below `Consumer` for `ListsContext`.
    This makes the value from `ItemsContextProvider` available to the `List` component
    that uses the `RenderProps` pattern:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ItemsContextProvider`现在嵌套在`ListsContextProvider`下面，这意味着`ItemsContext`的`Consumer`也可以嵌套在`ListsContext`的`Consumer`下面。这使得来自`ItemsContextProvider`的值可以被使用`RenderProps`模式的`List`组件使用：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After the item data is passed as a prop to `List`, this can now be used to
    replace the data fetching that is already in place using the `withDataFetching`
    HOC. To accomplish this, you need to make the following changes to `src/containers/List.js`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将项目数据作为prop传递给`List`之后，现在可以使用`withDataFetching` HOC替换已经存在的数据获取。为了实现这一点，您需要对`src/containers/List.js`进行以下更改：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All of the data fetching is now no longer by the `List` and `Lists` components.
    By nesting these Context Providers, the return values can be consumed by multiple
    components. But this still isn't ideal, as you're now loading all of the lists
    and all of the items when starting your application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的数据获取都不再由`List`和`Lists`组件进行。通过嵌套这些Context Providers，返回值可以被多个组件消耗。但这仍然不是理想的，因为现在在启动应用程序时加载了所有的列表和所有的项目。
- en: In the next section, you'll see how to get only the data you need by combining
    Context with Hooks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到如何通过将上下文与Hooks结合来获取所需的数据。
- en: Mutating context with Hooks
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks改变上下文
- en: There are multiple ways in which you can get data conditionally from the Context;
    one of these is placing the data from the Context in the local state. That could
    be a solution for a smaller application but can be inefficient for larger applications,
    as you'd still need to pass this state down your component tree. Another solution
    is using React Hooks to create a function that is added to the value of your Context
    and can be invoked from any of the components that are nested in this Context.
    Also, this method of getting the data prevents you from efficiently loading only
    the data that you'd need.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以有条件地从上下文中获取数据；其中一种是将上下文中的数据放入本地状态。这可能是一个较小应用的解决方案，但对于较大的应用来说效率不高，因为您仍然需要将这个状态传递到组件树中。另一个解决方案是使用React
    Hooks创建一个函数，将其添加到上下文的值中，并可以从嵌套在此上下文中的任何组件中调用。此外，这种获取数据的方法可以防止您有效地加载只需要的数据。
- en: How this can be used together with React life cycles and state management using
    Hooks is demonstrated in the first part of this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将其与React生命周期和使用Hooks进行状态管理结合使用的示例在本节的第一部分中进行了演示。
- en: Using life cycles in functional components
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数组件中使用生命周期
- en: 'One of the many great additions that came with Hooks is making life cycles
    available in functional components. Before Hooks, only class components supported
    life cycles using to the container components pattern and the `withDataFetching` HOC you''ve
    used so far. Follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks带来的许多伟大的增强之一是在函数组件中使用生命周期。在Hooks之前，只有类组件支持生命周期，使用容器组件模式和到目前为止您使用的`withDataFetching`
    HOC。按照以下步骤：
- en: 'The first step in achieving this is by moving the function to do data fetching
    from the `withDataFetching` HOC to the Provider for the lists, in the `src/Context/ListsContextProvider.js` file.
    This function will take `dataSource` (which could be a file or an API) and uses
    `fetch` to retrieve data from this source:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这一点的第一步是将数据获取功能从`withDataFetching` HOC移动到列表的Provider中，在`src/Context/ListsContextProvider.js`文件中。这个函数将接受`dataSource`（可以是文件或API）并使用`fetch`从这个源中检索数据：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this function in place, the next step would be to invoke it with `dataSource`
    and add the data to the Provider. But where should you store the data that is
    returned by `dataSource`? Before, you''ve used the `componentDidMount` life cycle
    method for this and added the results from the source to the local state. With
    Hooks, you can use local state management inside a function component with the
    `useState` Hook. You can pass the initial value for the state, which you set in `constructor` before,
    as an argument to this Hook. The returned value will be an array consisting of
    the current value for this state and a function to update this state. Also, Hooks
    should always be created inside the component in which it''s used—in this case,
    inside `ListsContextProvider`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个函数，下一步将是使用`dataSource`调用它并将数据添加到Provider中。但是，您应该将`dataSource`返回的数据存储在哪里？以前，您使用`componentDidMount`生命周期方法来实现这一点，并将来自源的结果添加到本地状态中。使用Hooks，您可以在函数组件中使用`useState`
    Hook进行本地状态管理。您可以将状态的初始值作为参数传递给这个Hook，这个初始值是您之前在`constructor`中设置的。返回的值将是一个数组，包含此状态的当前值和一个更新此状态的函数。此外，Hooks应该始终在使用它的组件内部创建——在这种情况下，应该在`ListsContextProvider`内部创建。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code block, you can see the initial value for the state is
    an empty array, which is passed to the Provider for `ListsContext`. To fill this
    state with data from `dataSource`, you need to actually invoke the `fetchData` function.
    Normally, this would be done inside a `componentDidMount` or `componentDidUpdate` life
    cycle method, but as a component is a function component, you''re using a Hook
    instead. This Hook is called `useEffect` and is used to handle side effects, either
    when the application mounts or when the state or a prop gets updated. This Hook
    takes two parameters, where the first one is a callback and the second one is
    an array containing all of the variables this Hook depends on. When any of these
    changes, the callback for this Hook will be called. When there are no values in
    this array, the Hook will only be called on the first mount. After the data is
    fetched from the source, the state will be updated with the results:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码块中，您可以看到状态的初始值是一个空数组，它被传递给`ListsContext`的Provider。要用来自`dataSource`的数据填充此状态，您需要实际调用`fetchData`函数。通常情况下，这将在`componentDidMount`或`componentDidUpdate`生命周期方法内完成，但由于组件是一个函数组件，您将使用一个Hook。这个Hook被称为`useEffect`，用于处理副作用，无论是应用程序挂载时还是状态或prop更新时。这个Hook接受两个参数，第一个是回调函数，第二个是包含此Hook依赖的所有变量的数组。当其中任何一个发生变化时，将调用此Hook的回调函数。当此数组中没有值时，Hook将仅在第一次挂载时调用。从源中获取数据后，状态将被更新为结果：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see the `fetchData` function isn't invoked directly but is wrapped inside
    a function called `asyncFetchData`. As `async/await` from the `fetchData` function
    would return `Promise`, you'd need another `async/await` to retrieve the values
    and resolve `Promise`. However, you can't use `async/await` directly with the
    `useEffect` Hook. The array block after the callback from the `useEffect` Hook
    is called the dependency array, and in here the values that are used in the Hook
    are defined. The functions `fetchData` and `setLists` are created on the first
    mount of this component, meaning the `useEffect` Hook mimics a lifecycle that's
    comparable to `componentDidMount`. If you want to use this Hook as a `componentDidUpdate` life
    cycle method, the array would consist of all of the state variables and props
    that should be watched for updates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`fetchData`函数并不是直接调用的，而是包裹在一个名为`asyncFetchData`的函数中。由于`fetchData`函数中的`async/await`将返回`Promise`，您需要另一个`async/await`来检索值并解决`Promise`。但是，您不能直接在`useEffect`
    Hook中使用`async/await`。在`useEffect` Hook的回调之后的数组块被称为依赖数组，在这里定义了在Hook中使用的值。`fetchData`和`setLists`函数是在此组件的第一次挂载时创建的，这意味着`useEffect`
    Hook模拟了一个类似于`componentDidMount`的生命周期。如果要将此Hook用作`componentDidUpdate`生命周期方法，数组将包含应该被监视更新的所有状态变量和props。
- en: By using other Hooks, you can also directly pass data to the Provider, without
    having to use local state management. This will be demonstrated in the next part
    of this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用其他Hooks，您还可以直接将数据传递给Provider，而无需使用本地状态管理。这将在本节的下一部分中进行演示。
- en: Updating the Provider with a Flux pattern
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flux模式更新Provider
- en: 'Another way to use actions to add data to the Provider is by using a pattern
    similar to Flux, which was introduced by Facebook. The Flux pattern describes
    a data flow where actions are being dispatched that retrieve data from a store
    and return it to the view. This would mean that actions need to be described somewhere;
    there should be a global place where data is stored and this data can be read
    by the view. To accomplish this pattern with the context API, you can use another
    Hook that is called `useReducer`. This Hook can be used to return data not from
    a local state, but from any data variable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用动作将数据添加到Provider的方法是使用类似Flux的模式，这是由Facebook引入的。Flux模式描述了一个数据流，其中派发动作从存储中检索数据并将其返回给视图。这意味着动作需要在某个地方描述；应该有一个全局的地方存储数据，视图可以读取这些数据。为了使用上下文API实现这种模式，可以使用另一个名为`useReducer`的Hook。这个Hook可以用来从任何数据变量中返回数据，而不是从本地状态中返回数据。
- en: 'Just as with the `useState` Hook, the `useReducer` Hook needs to be added to
    the component that is using it. `useReducer` will take an initial value and a
    function that determines which data should be returned. This initial value needs
    to be added to the `src/Context/ListsContextProvider.js` file before adding the
    Hook:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`useState` Hook一样，使用`useReducer` Hook的组件也需要添加到其中。`useReducer`将接受一个初始值和一个确定应返回哪些数据的函数。这个初始值需要在`src/Context/ListsContextProvider.js`文件中添加，然后再添加Hook。
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next to `initialValue`, the `useReducer` Hook also takes a function that''s
    called `reducer`. This `reducer` function should also be created and is a function
    that updates `initialValue`, which was passed and returns the current value, based
    on the action that was sent to it. If the action that was dispatched doesn''t
    match any of those defined in `reducer`, the reducer will just return the current
    value without any changes:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`initialValue`旁边，`useReducer` Hook还接受一个名为`reducer`的函数。这个`reducer`函数也应该被创建，它是一个更新`initialValue`的函数，根据发送给它的动作返回当前值。如果派发的动作不匹配`reducer`中定义的任何动作，`reducer`将只是返回当前值而没有任何改变。'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The two parameters for the `useReducer` Hook are now added to the file, so
    you need to add the actual Hook and pass `initialValue` and `reducer` to it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`useReducer` Hook的两个参数添加到文件中，因此需要添加实际的Hook并将`initialValue`和`reducer`传递给它。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, `reducer` changes the value it returns when the `GET_LISTS_SUCCESS`
    or `GET_LISTS_ERROR` action is sent to it. Before it was mentioned, you can call
    this `reducer` by using the `dispatch` function that was returned by the `useReducer` Hook.
    However, as you also have to deal with the asynchronous fetching of the data,
    you can''t invoke this function directly. Instead, you need to create an `async/await`
    function that calls the `fetchData` function and dispatches the correct action
    afterward:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，当`GET_LISTS_SUCCESS`或`GET_LISTS_ERROR`动作发送到`reducer`时，`reducer`会改变它返回的值。在之前提到过，可以使用`useReducer`
    Hook返回的`dispatch`函数来调用这个`reducer`。然而，由于你还需要处理数据的异步获取，所以不能直接调用这个函数。相反，你需要创建一个`async/await`函数，调用`fetchData`函数，然后派发正确的动作。
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the preceding `getListsRequest` function, an `async/await` call to the
    `fetchData` function is made when this function is invoked. If the data that was
    returned by `dataSource` is not an empty array, the `GET_LISTS_SUCCESS` action
    will be dispatched to the reducer using the `dispatch` function from the `useReducer` Hook.
    If not, the `GET_LISTS_ERROR` action will be dispatched, which returns an error
    message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的`getListsRequest`函数时，当调用这个函数时，会对`fetchData`函数进行`async/await`调用。如果`dataSource`返回的数据不是空数组，将使用`useReducer`
    Hook中的`dispatch`函数向reducer派发`GET_LISTS_SUCCESS`动作。如果不是，将派发`GET_LISTS_ERROR`动作，返回错误消息。
- en: 'This `getListsRequest` function can now be invoked from the `useEffect` Hook
    when your application mounts, so the application will be filled with the list
    data. This should be done from the view, so you need to create an action that
    you can add to `Provider`, so it can be used from any of the components that get
    this value from `Consumer`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的应用程序挂载时，现在可以从`useEffect` Hook中调用`getListsRequest`函数，以便应用程序将填充列表数据。这应该是从视图中完成的，因此您需要创建一个操作，可以将其添加到`Provider`中，以便从`Consumer`中获取此值的任何组件都可以使用它：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the component where the lists are displayed, the `Lists` component, you
    can retrieve the data for the lists with the `getListsRequest` function. Therefore,
    you''d need to pass it to this component from `RenderProps` in `Route`, in the `src/containers/App.js` file.
    Also, you can add a loading indicator that will be displayed when the list data
    isn''t retrieved yet or an error message when some error occurs:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示列表的组件`Lists`中，您可以使用`getListsRequest`函数检索列表的数据。因此，您需要从`src/containers/App.js`文件中的`RenderProps`中将其传递给此组件。此外，当尚未检索到列表数据或发生错误时，您可以添加一个加载指示器或错误消息：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And finally, invoke the `getListsRequest` function from the `Lists` component
    when it mounts, and add the loading indicator or error message. The lists should
    only be retrieved when there aren''t any lists available yet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Lists`组件中挂载时，从`Lists`组件调用`getListsRequest`函数，并添加加载指示器或错误消息。只有在尚无可用列表时才应检索列表：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you now visit the project in the browser again, you can see the data from
    the lists is loaded just as before. The big difference is that the data is fetched
    using a Flux pattern, meaning this can be extended to fetch the data in other
    instances as well. The same can be done for `ItemsContextProvider` as well, in
    the `src/Context/ItemsContextProvider.js` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在再次在浏览器中访问项目，您会发现列表中的数据与以前一样加载。最大的区别是数据是使用Flux模式获取的，这意味着这可以扩展到在其他情况下获取数据。同样，也可以在`src/Context/ItemsContextProvider.js`文件中对`ItemsContextProvider`执行相同操作：
- en: 'First add the initial value for the items, which you''ll use with the `useReducer` Hook:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加项目的初始值，这将与`useReducer` Hook一起使用：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After this, you can add the reducer, which has two actions that are quite similar
    to the ones for the list reducer. The only difference is that they will add information
    about the items to the Provider. Also, add the same `fetchData` function that
    as you added to `ListsContextProvider`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以添加reducer，它有两个操作，与列表reducer的操作非常相似。唯一的区别是它们将向Provider添加有关项目的信息。还要添加与您添加到`ListsContextProvider`的`fetchData`函数相同的函数：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you can create the `async/await` function that will fetch `dataSource`
    for the items. This function will also take the `id` variable of the list that
    is selected, so no over-fetching of data will occur. The `withDataFetching` HOC
    can be removed, as it''s no longer needed to retrieve the data:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以创建`async/await`函数，用于获取项目的`dataSource`。此函数还将获取所选列表的`id`变量，以避免数据的过度获取。`withDataFetching`
    HOC可以被移除，因为不再需要检索数据：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As the function to retrieve items is now added to the Provider for the items,
    the Consumer is `src/containers/App.js` and can pass this function to the `List`
    component that is displaying the items:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在已将检索项目的函数添加到项目的Provider中，因此Consumer是`src/containers/App.js`，可以将此函数传递给显示项目的`List`组件：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And finally, call this `getItemsRequest` function from the `List` component
    in `src/containers/List.js`. This function will take the `id` variable for the
    list that you are displaying from the current route, by using the `match` prop.
    It''s important to mention that this function should only be called when the value
    for `items` is empty, to prevent unnecessary data fetching:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`src/containers/List.js`中的`List`组件中调用`getItemsRequest`函数。此函数将使用`match`属性从当前路由中获取您正在显示的列表的`id`变量。重要的是要提到，只有在`items`的值为空时才应调用此函数，以防止不必要的数据获取。
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You might notice that the title of the list won''t be displayed any longer
    when you refresh the page. The information for the lists is only fetched when
    the `Lists` component is mounted, so you''d need to create a new function to always
    fetch the information for the list that you''re currently displaying in the `List` component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，当您刷新页面时，列表的标题将不再显示。只有在`Lists`组件挂载时才会获取列表的信息，因此您需要创建一个新函数，始终获取`List`组件中当前显示的列表的信息：
- en: 'In the `src/Context/ListsContextProvider.js` file, you need to extend `initialValue` to
    also have a field called `list`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Context/ListsContextProvider.js`文件中，您需要扩展`initialValue`，还要添加一个名为`list`的字段：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `reducer`, you now also have to check for two new actions that either add
    the data about a list to the context or add an error message:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`reducer`中，现在还必须检查两个新操作，其中一个是将列表数据添加到上下文中，另一个是添加错误消息：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These actions will be dispatched from an `async/await` function that calls `dataSource`
    with a specific `id`. If successful, the `GET_LIST_SUCCESS` action will be dispatched;
    otherwise, the `GET_LIST_ERROR` action is dispatched. Also, pass the function
    to the Provider so that it can be used from the `List` component:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些操作将从一个使用特定`id`调用`dataSource`的`async/await`函数中分派。如果成功，将分派`GET_LIST_SUCCESS`操作；否则，将分派`GET_LIST_ERROR`操作。还要将该函数传递给Provider，以便可以从`List`组件中使用：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And pass this to the `List` component, by destructuring it from the `ListsContext`
    Consumer. Also, take the list data from this Consumer and pass it to the `List` component.
    The `lists` props can be removed from this component, as filtering the list data
    is now done by `ListsContextProvider`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并将其传递给`List`组件，通过从`ListsContext` Consumer中解构它。还要从此Consumer中获取列表数据，并将其传递给`List`组件。`lists`属性现在可以从此组件中删除，因为现在列表数据的过滤是由`ListsContextProvider`完成的：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, you can invoke the `getListRequest` function that fetches the list
    data from the `List` component. You only want to retrieve the list information
    when this isn''t already available; the filtering of the `lists` prop is therefore
    no longer needed:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以调用`getListRequest`函数，从`List`组件中获取列表数据。只有在此数据尚不可用时，您才希望检索列表信息；因此不再需要对`lists`属性进行过滤：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All of the data in your application is now being loaded using the Providers,
    which means it's now detached from the views. Also, the `withDataFetching` HOC is
    completely removed, making your application structure more readable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序中的所有数据都是使用Providers加载的，这意味着它现在与视图分离。此外，`withDataFetching` HOC已完全删除，使您的应用程序结构更易读。
- en: Not only can you use the context API with this pattern to make data available
    to many components, but you can also mutate the data. How to mutate this data
    will be shown in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以使用此模式的上下文API使数据可用于许多组件，还可以改变数据。如何改变这些数据将在下一节中展示。
- en: Mutating data in the Provider
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Provider中改变数据
- en: 'Not only can you retrieve data using this Flux pattern, but you can also use
    it to update data. The pattern would remain the same: you dispatch an action that
    would trigger the request to the server and, based on the outcome, the reducer
    will mutate the data with this result. Depending on whether or not it was successful,
    you could display a success message or an error message.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以使用这种Flux模式来检索数据，还可以用它来更新数据。模式仍然是一样的：您派发一个动作，触发对服务器的请求，根据结果，reducer将使用这个结果改变数据。根据是否成功，您可以显示成功消息或错误消息。
- en: 'The code already has a form for adding a new item to a list—something that
    is not working yet. Let''s create the mechanism to add items by updating the Provider
    for `items`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码已经有一个用于向列表添加新项目的表单，但目前还没有工作。让我们通过更新`items`的Provider来创建添加项目的机制：
- en: 'The first step is to create a new function that can handle `POST` requests,
    as this function should also set the method and a body when handling the `fetch` request.
    You can create this function in the `src/Context/ItemsContextProvider.js` file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的函数，可以处理`POST`请求，因为这个函数在处理`fetch`请求时还应该设置方法和主体。您可以在`src/Context/ItemsContextProvider.js`文件中创建这个函数：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function takes not only `dataSource` but also information that will be
    posted to this source. Just as for retrieving the items, a case can be added to
    the `switch` statement in `reducer`. This time, it will look for an action that
    is called `ADD_ITEM_REQUEST`, which has a payload consisting of `dataSource` and `content`
    that should be added to the value. These actions change the value for `loading` and/or
    `error` and spread the actual current value in its return as well. If you don''t
    do this, all of the information that is already available about the lists will
    be cleared:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数不仅需要`dataSource`，还需要将要发布到这个源的信息。就像检索项目一样，在`reducer`的`switch`语句中可以添加一个情况。这一次，它将寻找一个名为`ADD_ITEM_REQUEST`的动作，它的载荷由`dataSource`和应该添加到值中的`content`组成。这些动作会改变`loading`和/或`error`的值，并在返回时也会传播实际的当前值。如果不这样做，所有关于列表的已有信息都将被清除：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The mock API from My JSON Server doesn't persist data once it is added, updated,
    or deleted with a request. However, you can see whether the request was successful
    by checking the request in the Network tab in the Developer Tools of your browser.
    That's why the input content is spread over the value for `items`, so this data
    is available from the Consumer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 来自My JSON Server的模拟API一旦添加、更新或删除请求，数据就不会持久保存。但是，您可以通过在浏览器的开发者工具的Network选项卡中检查请求来查看请求是否成功。这就是为什么输入内容分布在`items`的值上，所以这些数据可以从Consumer中获取。
- en: 'Also, create an `async/await` function that handles the `POST` request. If
    this request is successful, the data that will be returned has a field called
    `id`. So, when this is the case, the `ADD_ITEM_SUCCESS` action can be dispatched.
    Otherwise, an `ADD_ITEM_ERROR` action is dispatched. These actions will change
    the value for this Provider from `reducer`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建一个处理`POST`请求的`async/await`函数。如果这个请求成功，返回的数据将有一个名为`id`的字段。因此，在这种情况下，可以派发`ADD_ITEM_SUCCESS`动作。否则，会派发一个`ADD_ITEM_ERROR`动作。这些动作将从`reducer`改变这个Provider的值：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just as for retrieving the list, the `actionDispatch` function for adding a
    list can be wrapped inside a helper function. This function would take the content
    that is returned from the form later on. Also, pass this function to the Provider
    so that it can be used in any of the components that consume this Provider:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像检索列表一样，用于添加列表的`actionDispatch`函数可以包装在一个辅助函数中。这个函数将在稍后从表单返回的内容。还要将这个函数传递给Provider，以便它可以在任何使用这个Provider的组件中使用：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As the function to add a list is now available from the Provider, you can pass
    it to the `Form` component by using `RenderProps` from its `Route`. This can be
    done in the `src/containers/App.js` file. Make sure you don''t forget to send
    the `match` and `history` props as well, as these are used by the `Form` component:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在可以从提供者中使用添加列表的函数，你可以通过使用`Route`的`RenderProps`将其传递给`Form`组件。这可以在`src/containers/App.js`文件中完成。确保不要忘记发送`match`和`history`属性，因为这些被`Form`组件使用：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Form` component is now able to use the `addListRequest` function that will
    dispatch the action that triggers the `POST` request that will add an item to
    `dataSource`. This function needs to be triggered when the user submits the form.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`组件现在可以使用`addListRequest`函数，该函数将触发`POST`请求的动作，将项目添加到`dataSource`中。当用户提交表单时，需要触发这个函数。'
- en: 'However, the values of the input fields in the form need to be determined first.
    Therefore, the input fields need to be controlled components, meaning their value
    is controlled by the local state that encapsulates the value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表单中输入字段的值需要首先确定。因此，输入字段需要成为受控组件，这意味着它们的值由封装值的本地状态控制：
- en: 'For this, you can use the `useState` Hook, and call it for every `state` value
    that you want to create. The Hook will return both the current value of this `state`
    value and a function to update this value and must be added in `src/containers/Form.js`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，你可以使用`useState` Hook，并为你想要创建的每个`state`值调用它。这个Hook将返回这个`state`值的当前值和一个更新这个值的函数，必须添加在`src/containers/Form.js`中：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The local state values and the function that triggers an update of the local
    `state` values must be set as a prop on the `FormItem` components:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地状态值和触发本地`state`值更新的函数必须作为`FormItem`组件的属性进行设置：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `FormItem` component, in the `src/components/FormItem.js` file, can take
    these props and have the input field invoke the `handleOnChange` function. The
    element''s current `target` value must be used as the parameter for this function:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FormItem`组件在`src/components/FormItem.js`文件中可以接受这些属性，并使输入字段调用`handleOnChange`函数。元素的当前`target`值必须作为此函数的参数使用：'
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last thing you need to do now is to add a function that will be dispatched
    when the form is submitted by clicking the submit button. This function takes
    `value` for the local `state`, adds information about the list and a randomly
    generated `id` and uses this to call the `addItemRequest` function. After this
    function is called, the `goBack` function from the `history` prop is called:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你需要做的最后一件事是添加一个函数，当点击提交按钮时将被调度。这个函数接受本地状态的`value`，添加关于列表的信息和一个随机生成的`id`，然后使用这些来调用`addItemRequest`函数。在调用了这个函数之后，将调用`history`属性中的`goBack`函数：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you now submit the form, a `POST` request to the mock server will be sent.
    You'll be sent back to the previous page where you can see the result. If successful,
    the `GET_LIST_SUCCESS` action was dispatched and the item you inserted was added
    to the list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你提交表单时，将发送一个`POST`请求到模拟服务器。你将被发送回到之前的页面，你可以在那里看到结果。如果成功，将会触发`GET_LIST_SUCCESS`动作，并且你插入的项目将被添加到列表中。
- en: So far, the information from the Context has been used only separately by using
    the Providers, but this can also be combined into one global Context, as shown
    in the next section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，上下文中的信息仅通过使用提供者分开使用，但这也可以合并为一个全局上下文，如下一节所示。
- en: Creating a global Context
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全局上下文
- en: 'If you look at the current structure of the routes in your `App` component,
    you can imagine this will get messy if you add more Providers and Consumers to
    your application. State management packages such as Redux tend to have a global
    state where all of the data for the application is stored. When using Context,
    it''s possible to create a global Context that can be accessed using the `useContext` Hook.
    This Hook acts as a Consumer and can retrieve values from the Provider of the
    Context that was passed to it. Let''s refactor the current application to have
    a global Context:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下你的`App`组件中路由的当前结构，你可以想象如果你在应用程序中添加更多的Providers和Consumers，这将变得混乱。状态管理包如Redux倾向于有一个全局状态，其中存储了应用程序的所有数据。当使用Context时，可以创建一个全局Context，可以使用`useContext`
    Hook访问。这个Hook充当Consumer，可以从传递给它的Context的Provider中检索值。让我们重构当前的应用程序以拥有一个全局Context：
- en: 'Start by creating a file called `GlobalContext.js` in the `src/Context` directory.
    This file will import both `ListsContextProvider` and `ItemsContextProvider`,
    nest them, and have them wrap any component that will be passed to it as `children`
    prop:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src/Context`目录中创建一个名为`GlobalContext.js`的文件。这个文件将导入`ListsContextProvider`和`ItemsContextProvider`，将它们嵌套，并让它们包装任何作为`children`属性传递给它的组件：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `src/containers/App.js` file, you can now import this `GlobalContext` file
    in favor of the Providers for the lists and items:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/containers/App.js`文件中，你现在可以导入`GlobalContext`文件，而不是导入列表和项目的Providers：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can replace `ListsContextProvider` and `ItemsContextProvider` with `GlobalContext`.
    The Consumer will still be able to retrieve the data from `ListsContext` and `ItemsContext` if
    you''d still import them:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用`GlobalContext`替换`ListsContextProvider`和`ItemsContextProvider`。如果你仍然导入它们，Consumer仍然可以从`ListsContext`和`ItemsContext`中检索数据：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, you can delete the Consumers and the `RenderProps` pattern from the routes.
    The value from the Context will no longer be passed from both the Consumers but
    will be retrieved by using the `useContext` Hooks in each of the routes:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以删除路由中的Consumers和`RenderProps`模式。上下文中的值将不再从两个Consumers中传递，而是将使用`useContext`
    Hook在每个路由中检索：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In each of the components that are being rendered by `Route`, the Context that
    you want to use should be imported. The `useContext` Hook can then retrieve the
    value from this Context. You can start by adding this Hook to the `Lists` component
    in `src/containers/Lists.js`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个由`Route`渲染的组件中，你想要使用的上下文都应该被导入。然后，`useContext` Hook可以从这个上下文中检索值。你可以从`src/containers/Lists.js`组件开始添加这个Hook：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, `useContext` only takes the Context you want to use as an argument.
    To implement this in the `List` component, you''d need to import both `ListsContext`
    and `ItemsContext` in the `src/containers/List.js` file:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，`useContext`只需要将要使用的上下文作为参数。要在`List`组件中实现这一点，你需要在`src/containers/List.js`文件中导入`ListsContext`和`ItemsContext`：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And do the same for the `Form` component in the `src/containers/Form.js` file,
    where you only use `ItemsContext`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Form`组件在`src/containers/Form.js`文件中也是一样，你只使用`ItemsContext`：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can now see that your application has a much cleaner structure, while the
    data is still being retrieved by the Providers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到你的应用程序有一个更清晰的结构，同时数据仍然是通过Providers检索的。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've created a shopping list application that uses the context
    API and Hooks to pass and retrieve data, instead of a HOC. Context is used to
    store data and Hooks are used to retrieve and mutate data. With the context API,
    you can create more advanced scenarios for state management using the `useReducer` Hook.
    Also, you've recreated a situation where all of the data is stored globally and
    can be accessed from any component by creating a shared Context.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您已经创建了一个购物清单应用程序，该应用程序使用上下文API和Hooks来传递和检索数据，而不是使用HOC。上下文用于存储数据，Hooks用于检索和改变数据。使用上下文API，您可以使用`useReducer`
    Hook创建更高级的状态管理场景。此外，您已经重新创建了一个情况，其中所有数据都存储在全局，并且可以通过创建共享上下文从任何组件访问。
- en: The context API will be used in the next chapter as well, which will show you
    how to build a hotel review application with automated testing using libraries
    such as Jest and Enzyme. It will introduce you to the multiple ways you can test
    your UI components created with React, and also show you how to test state management
    in your application using the context API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，上下文API也将被使用，该章节将向您展示如何使用诸如Jest和Enzyme等库构建具有自动化测试的酒店评论应用程序。它将向您介绍使用React创建UI组件的多种测试方法，并向您展示如何使用上下文API测试应用程序中的状态管理。
- en: Further reading
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Consuming multiple Context objects: [https://reactjs.org/docs/Context.html#consuming-multiple-Contexts](https://reactjs.org/docs/Context.html#consuming-multiple-Contexts)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗多个上下文对象：[https://reactjs.org/docs/Context.html#consuming-multiple-Contexts](https://reactjs.org/docs/Context.html#consuming-multiple-Contexts)
