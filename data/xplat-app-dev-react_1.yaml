- en: Chapter 1. Project 1 – Car Booking App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。项目1 - 汽车预订应用程序
- en: Considering the success of the React framework, Facebook recently introduced
    a new mobile development framework called React Native. With React Native's game-changing
    approach to hybrid mobile development, you can build native mobile applications
    that are much more powerful, interactive, and faster by using JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到React框架的成功，Facebook最近推出了一个名为React Native的新移动开发框架。通过React Native对混合移动开发的颠覆性方法，您可以使用JavaScript构建更强大、更交互式、更快速的本机移动应用程序。
- en: In this lesson, we will set the focus on feature development rather than in
    building a user interface by delegating the styling of our applications to UI
    libraries such as native-base as well as spend more time in building custom UI
    components and screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们将把重点放在功能开发上，而不是构建用户界面，通过将我们应用程序的样式委托给原生库，如native-base，并花更多时间构建自定义UI组件和屏幕。
- en: The app we will build is a car booking app in which the user can select the
    location in which he/she wants to be picked up and the type of car she wants to
    book for the ride. Since we want to focus on the user interface, our app will
    only have two screens and a little state management is needed. Instead, we will
    dive deeper into aspects such as animations, component's layout, using custom
    fonts, or displaying external images.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的应用是一个汽车预订应用程序，用户可以选择想要被接送的位置以及想要预订的车辆类型。由于我们想要专注于用户界面，我们的应用程序只会有两个屏幕，并且需要一些状态管理。相反，我们将更深入地研究诸如动画、组件布局、使用自定义字体或显示外部图像等方面。
- en: 'The app will be available for iOS and Android devices, and since all the user
    interface will be custom made, 100% of the code will be reused between both platforms.
    We will only use two external libraries:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将适用于iOS和Android设备，由于所有用户界面都将是定制的，因此在两个平台之间将重复使用100%的代码。我们将只使用两个外部库：
- en: '`React-native-geocoder`: This will translate coordinates into human-readable
    locations'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React-native-geocoder`：这将把坐标转换成人类可读的位置'
- en: '`React-native-maps`: This will easily display the maps and the markers showing
    the locations for the bookable cars'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React-native-maps`：这将轻松显示地图和显示可预订汽车位置的标记'
- en: Due to its nature, most of the car booking apps put their complexity in the
    backend code to connect drivers with riders effectively. We will skip this complexity
    and mock all that functionality in the app itself to focus on building beautiful
    and usable interfaces.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其性质，大多数汽车预订应用程序将其复杂性放在后端代码中，以有效地连接司机和乘客。我们将跳过这种复杂性，并在应用程序中模拟所有这些功能，以便专注于构建美观和可用的界面。
- en: Overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概览
- en: When building mobile apps, we need to make sure we reduce the interface complexity
    to the minimum, as it's often punishing to present the user intrusive manuals
    or tooltips once the app is open. It is a good practice to make our app self-explanatory,
    so the user can understand the usage just by going through the app screens. That's
    why using standard components such as drawer menus or standard lists is always
    a good idea, but is not always possible (as it happens in our current app) due
    to the kind of data we want to present to the user.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建移动应用程序时，我们需要确保将界面复杂性降至最低，因为在打开应用程序后强制向用户呈现侵入式手册或工具提示通常是不利的。让我们的应用程序自解释是一个好习惯，这样用户就可以通过浏览应用程序屏幕来理解使用方法。这就是为什么使用标准组件，如抽屉菜单或标准列表，总是一个好主意，但并非总是可能的（就像我们当前的应用程序一样），因为我们想要向用户呈现的数据类型。
- en: 'In our case, we put all the functionality in the main screen plus in a modal
    box. Let''s take a look at what the app will look like on iOS devices:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将所有功能放在主屏幕和一个模态框中。让我们看看iOS设备上的应用程序将会是什么样子：
- en: '![Overview](Images/01_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/01_01.jpg)'
- en: 'The background on our main screen is the maps component itself where we will
    show all the available cars as markers in the map. On the maps, we will display
    three components:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主屏幕的背景是地图组件本身，在地图中我们将显示所有可用的汽车作为标记。在地图上，我们将显示三个组件：
- en: The pickup location box displaying the selected pickup location
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所选取的取货地点的取货地点框
- en: The location pin, which can be dragged around the maps to select a new location
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置图钉，可以在地图上拖动以选择新位置
- en: 'The selector for the kind of car the user wants to book. We will display three
    options: `ECONOMY`, `SPECIAL`, and `SUPERIOR`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户想要预订的汽车类型选择器。我们将显示三个选项：`经济`，`特别` 和 `高级`
- en: 'Since most of the components are custom built, this screen will look very similar
    in any Android device:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数组件都是自定义构建的，这个屏幕在任何 Android 设备上看起来都会非常相似：
- en: '![Overview](Images/01_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/01_02.jpg)'
- en: The main difference between the iOS and the Android version will be the map
    component. While iOS will use Apple maps by default, Android uses Google Maps.
    We will leave this setup as each platform has its own map component optimized,
    but it's good to know that we can switch the iOS version to use Google Maps just
    by configuring our component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 版本和 Android 版本之间的主要区别将是地图组件。虽然 iOS 将默认使用 Apple 地图，但 Android 使用 Google 地图。我们将保留这个设置，因为每个平台都有自己优化的地图组件，但知道我们可以通过配置我们的组件来切换
    iOS 版本以使用 Google 地图是很好的。
- en: 'Once the user has selected a pickup location, we will display a modal box to
    confirm the booking and contact the nearest driver for pickup:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了取货地点，我们将显示一个模态框来确认预订并联系最近的司机取货：
- en: '![Overview](Images/01_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/01_03.jpg)'
- en: 'As it happened with the main screen, this screen uses custom components: we
    even decided to create our own animated activity indicator. Because of this, the
    Android version will look very similar:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与主屏幕一样，这个屏幕也使用了自定义组件：我们甚至决定创建自己的动画活动指示器。因此，Android 版本看起来会非常相似：
- en: '![Overview](Images/01_04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/01_04.jpg)'
- en: Since our app won't be connected to any external API, it should be seen as a
    mere display of the visual capabilities of React Native, although it could be
    easily extended by adding a state management library and a matching API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序不会连接到任何外部 API，它应该被视为 React Native 的视觉能力的纯粹展示，尽管通过添加状态管理库和匹配的 API 可以很容易地进行扩展。
- en: 'Let''s take a look at the topics of this lesson:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本课程的主题：
- en: Using maps in our app
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用地图
- en: Style sheets in React Native
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 中的样式表
- en: Flexbox in React Native
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 中的 Flexbox
- en: Using external images in a React Native app
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React Native 应用程序中使用外部图像
- en: Adding custom fonts
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: Animations in React Native
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 中的动画
- en: Using modals
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模态框
- en: Working with shadows and opacity
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阴影和不透明度
- en: Setting up the Folder Structure
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `carBooking` and will be available for iOS and Android devices:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 React Native 的 CLI 初始化一个 React Native 项目。该项目将被命名为 `carBooking`，并将可用于 iOS
    和 Android 设备：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this app, there is only one screen so that the folder structure for the
    code should be very straightforward. Since we will be using external images and
    fonts, we will organize these resources in two separate folders: `img` and `fonts`,
    both under the root folder.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，只有一个屏幕，因此代码的文件夹结构应该非常简单。由于我们将使用外部图像和字体，我们将这些资源组织在两个单独的文件夹中：`img` 和
    `fonts`，都在根文件夹下。
- en: The images and fonts used to build this app can be downloaded freely from some
    image and font sock websites. The name of the font we will use is **Blair ITC**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建此应用程序的图像和字体可以从一些图像和字体库网站免费下载。我们将使用的字体名称是 **Blair ITC**。
- en: 'We also stored the following images inside the `img` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将以下图像存储在 `img` 文件夹中：
- en: '`car.png`: A simple drawing of a car to represent the bookable cars on the
    map.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car.png`：一辆汽车的简单图画，代表地图上可预订的汽车。'
- en: '`class.png`: The silhouette of a car to show inside the class selection button'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class.png`：汽车的轮廓，显示在类别选择按钮内部'
- en: '`classBar.png`: The bar in which the class selection button will be slid to
    change the class.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classBar.png`：类别选择按钮将滑动以更改类别的条形。'
- en: '`loading.png`: Our custom spinner. It will be stored as a static image and
    animated through the code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading.png`：我们自定义的旋转器。它将被存储为静态图像，并通过代码进行动画处理。'
- en: 'Finally, let''s take a look at our `package.json` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们的`package.json`文件：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We only use two npm modules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用两个npm模块：
- en: '`react-native-geocoder`: This translates coordinates into human-readable locations'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-geocoder`：这将坐标转换为人类可读的位置'
- en: '`react-native-maps`: This easily displays the maps and the markers showing
    the locations for the bookable cars'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-maps`：这很容易显示地图和显示可预订汽车位置的标记'
- en: In order to allow the app to use custom fonts, we need to make sure they are
    accessible from the native side. For that, we need to add a new key to `package.json`
    named `rnpm`. This key will store an array of `assets` in which we will define
    our `fonts` folder. During build time, React Native will copy the fonts to a location
    from where they will be available natively and therefore usable within our code.
    This is only required by fonts and some special resources, but not by images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序使用自定义字体，我们需要确保它们可以从本地端访问。为此，我们需要向`package.json`添加一个名为`rnpm`的新键。这个键将存储一个`assets`数组，在其中我们将定义我们的`fonts`文件夹。在构建时，React
    Native将把字体复制到一个位置，从那里它们将在本地可用，因此可以在我们的代码中使用。这仅适用于字体和一些特殊资源，而不适用于图像。
- en: Files and Folders Created by React Native's CLI
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由React Native的CLI创建的文件和文件夹
- en: Let's take the chance of having a simple folder structure in this app to show
    what other files and folders are created by React Native's CLI when initializing
    a project through `react-native init <projectName>`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这个应用程序中简单的文件夹结构的机会，展示通过`react-native init <projectName>`初始化项目时，React Native的CLI创建了哪些其他文件和文件夹。
- en: __tests__/
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __tests__/
- en: 'React Native''s CLI includes Jest as a developer dependency and, to get testing
    started, it includes a folder named `__tests__`, in which all tests can be stored.
    By default, React Native''s CLI adds one test file: `index.js`, representing the
    initial set of tests. Developers can add later tests for any components in the
    app. React Native also adds a `test` script in our `package.json`, so we can run
    `npm run test` from the very first moment.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的CLI包括Jest作为开发人员依赖项，并且为了开始测试，它包括一个名为`__tests__`的文件夹，其中可以存储所有测试。默认情况下，React
    Native的CLI添加一个测试文件：`index.js`，代表初始一组测试。开发人员可以为应用程序中的任何组件添加后续测试。React Native还在我们的`package.json`中添加了一个`test`脚本，因此我们可以从一开始就运行`npm
    run test`。
- en: Jest is ready to be used with every project initialized through the CLI and
    it's definitely the easiest option when it comes to testing React components,
    although it is also possible to use other libraries such as Jasmine or Mocha.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Jest已准备好与通过CLI初始化的每个项目一起使用，当涉及到测试React组件时，它绝对是最简单的选择，尽管也可以使用其他库，如Jasmine或Mocha。
- en: android/ and ios/
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: android/ 和 ios/
- en: These two folders hold the built app for both platforms natively. This means
    that we can find our `.xcodeproj` and `java` files in here. Every time we need
    to make changes to the native code of our app, we will need to modify some files
    in these two directories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件夹分别为两个平台本地构建的应用程序。这意味着我们可以在这里找到我们的`.xcodeproj`和`java`文件。每当我们需要对应用程序的本地代码进行更改时，我们都需要修改这两个目录中的一些文件。
- en: 'The most common reasons to find and modify files in these folders are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件夹中查找和修改文件的最常见原因是：
- en: Modify permissions (push notifications, access to location services, access
    to compass, and many more) by changing `Info.plist` (iOS) or `AndroidManifest.xml`
    (Android)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改`Info.plist`（iOS）或`AndroidManifest.xml`（Android）修改权限（推送通知，访问位置服务，访问指南针等）。
- en: Change the build settings for any platform
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改任何平台的构建设置
- en: Add API keys for native libraries
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为原生库添加API密钥
- en: Add or modify native libraries to be used from our React Native code
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或修改要从我们的React Native代码中使用的原生库
- en: node_modules/
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: node_modules/
- en: This folder should be familiar to most of the JavaScript developers who worked
    with `npm` as it is where `npm` stores all the modules marked as a dependency
    in our project. It is not common to have the necessity to modify anything inside
    this folder, as everything should be handled through npm's CLI and our `package.json`
    file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '这个文件夹对大多数使用`npm`的JavaScript开发人员来说应该很熟悉，因为它是`npm`存储在我们项目中标记为依赖项的所有模块的地方。在这个文件夹内修改任何内容的必要性并不常见，因为一切都应该通过npm的CLI和我们的`package.json`文件来处理。 '
- en: Files in the Root Folder
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根文件夹中的文件
- en: 'React Native''s CLI creates a number of files in the root directory of our
    project; let''s take a look at the most important ones:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的CLI在项目的根目录中创建了许多文件；让我们来看看最重要的文件：
- en: '`.babelrc`: Babel is the default library in React Native to compile our JavaScript
    files containing JSX and ES6 (for example, syntax into plain JavaScript capable
    to be understood by most of the JavaScript engines). Here, we can modify the configuration
    for this compiler so we can, for example, use the `@` syntax for decorators as
    it was done in the first versions of React.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.babelrc`：Babel是React Native中用于编译包含JSX和ES6（例如，语法转换为大多数JavaScript引擎能够理解的纯JavaScript）的默认库。在这里，我们可以修改这个编译器的配置，例如，可以使用`@`语法作为装饰器，就像在React的早期版本中所做的那样。'
- en: '`.buckconfig`: Buck is the build system used by Facebook. This file is used
    to configure the building process when using Buck.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.buckconfig`：Buck是Facebook使用的构建系统。这个文件用于配置使用Buck时的构建过程。'
- en: '`.watchmanconfig`: Watchman is a service that watches the files in our project
    to trigger a rebuild anytime something changes in them. In this file, we can add
    some configuration options such as directories, which should be ignored.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.watchmanconfig`：Watchman是一个监视项目中文件的服务，以便在文件发生更改时触发重新构建。在这个文件中，我们可以添加一些配置选项，比如应该被忽略的目录。'
- en: '`app.json`: This file is used by the `react-native eject` command to configure
    the native apps. It stores the name that identifies the app in each platform and
    also the name that will be displayed on the home screen of the device when the
    app is installed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.json`：这个文件被`react-native eject`命令用来配置原生应用程序。它存储了在每个平台上标识应用程序的名称，以及在设备的主屏幕上安装应用程序时将显示的名称。'
- en: '`yarn.lock`: The `package.json` file describes the intended versions desired
    by the original author, while `yarn.lock` describes the last-known-good configuration
    for a given application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn.lock`：`package.json`文件描述了原始作者期望的版本，而`yarn.lock`描述了给定应用程序的最后已知良好配置。'
- en: react-native link
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: react-native link
- en: Some apps depend on libraries with native capabilities which, before React Native
    CLI, required developers to copy native library files into the native projects.
    This was a cumbersome and repetitive project until `react-native link` came to
    the rescue. In this lesson we will use it to copy library files from `react-native-maps`
    and to link custom fonts from our `/fonts` folder to the compiled app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序依赖具有原生功能的库，在React Native CLI之前，开发人员需要将原生库文件复制到原生项目中。这是一个繁琐和重复的项目，直到`react-native
    link`出现才得以解决。在这节课中，我们将使用它来从`react-native-maps`复制库文件，并将自定义字体从我们的`/fonts`文件夹链接到编译后的应用程序。
- en: By running `react-native link` in our project's root folder we will trigger
    the linking steps which will result in those native capabilities and resources
    to be accessible from our React Native code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目的根文件夹中运行`react-native link`，我们将触发链接步骤，这将使那些原生能力和资源可以从我们的React Native代码中访问。
- en: Running the App in the Simulator
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模拟器中运行应用程序
- en: 'Having the dependencies in the `package.json` file and all the initial files
    in place, we can run the following command (in the root folder of our project)
    to finish the installation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中具有依赖项和所有初始文件就位后，我们可以运行以下命令（在项目的根文件夹中）完成安装：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, all the dependencies should be installed in our project. Once npm finishes
    installing all dependencies, we can start our app in the iOS simulator:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有依赖项都应该安装在我们的项目中。一旦npm完成安装所有依赖项，我们就可以在iOS模拟器中启动我们的应用程序：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or in the Android emulator using the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Android模拟器中使用以下命令：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When React Native detects the app is running in a simulator, it enables a developer
    toolset available through a hidden menu, which can be accessed through the shortcuts
    *command* + *D* on iOS or *command* + *M* on Android (on Windows *Ctrl* should
    be used instead of *command*). This is how the developer menu looks like in iOS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当React Native检测到应用程序在模拟器中运行时，它会启用一个隐藏菜单中可用的开发人员工具集，可以通过快捷键*command* + *D*（在iOS上）或*command*
    + *M*（在Android上）来访问（在Windows上应使用*Ctrl*而不是*command*）。这是iOS中开发人员菜单的外观：
- en: '![Running the App in the Simulator](Images/01_06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: 在模拟器中运行应用程序
- en: 'And this is how it looks like in the Android simulator:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Android模拟器中的外观：
- en: '![Running the App in the Simulator](Images/01_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![在模拟器中运行应用程序](Images/01_07.jpg)'
- en: The Developer Menu
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发人员菜单
- en: In the process of building an app in React Native, the developer will have debugging
    needs. React Native fulfills these needs with the ability to remotely debug our
    apps in Chrome developer's tools or external applications such as React Native
    Debugger. Errors, logs, and even React components can be debugged easily as in
    a normal web environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建React Native应用程序的过程中，开发人员将有调试需求。React Native通过在Chrome开发人员工具或外部应用程序（如React
    Native Debugger）中远程调试我们的应用程序来满足这些需求。错误、日志甚至React组件都可以像在普通Web环境中一样轻松调试。
- en: 'On top of that, React Native provides a way to automatically reload our app
    each time a change is done saving the developers the task of manually reloading
    the app (which can be achieved by pressing *command* + *R* or *Ctrl* + *R*). There
    are two options when we set our app for automatic reloading:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，React Native还提供了一种在每次更改时自动重新加载我们的应用程序的方式，从而节省了开发人员手动重新加载应用程序的任务（可以通过按*command*
    + *R*或*Ctrl* + *R*来实现）。当我们设置我们的应用程序进行自动重新加载时，有两个选项。
- en: Live reload detects any changes we make in the app's code and resets the app
    to its initial state after reloading.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时重新加载检测到我们在应用程序代码中所做的任何更改，并在重新加载后将应用程序重置为其初始状态。
- en: Hot reload also detects changes and reloads the app, but keeps the current state
    of the app. This is really useful when we are implementing user flows to save
    the developer to repeat each step in the flow (for example, logging in or registering
    test users)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热重新加载还会检测更改并重新加载应用程序，但会保持应用程序的当前状态。当我们正在实现用户流程以节省开发人员重复每个步骤（例如登录或注册测试用户）时，这非常有用。
- en: Finally, we can start the performance monitor to detect possible performance
    issues when performing complex operations such as animations or mathematical calculations.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以启动性能监视器来检测在执行复杂操作（例如动画或数学计算）时可能出现的性能问题。
- en: Creating our App's Entry Point
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们应用程序的入口点
- en: 'Let''s start our app''s code by creating the entry point for our app: `index.js`.
    We import `src/main.js` in this file to use a common root component for our code
    base. Moreover, we will register the app with the name `carBooking`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建我们应用的入口点 `index.js` 来开始我们的应用代码。我们在这个文件中导入 `src/main.js`，以便为我们的代码库使用一个共同的根组件。此外，我们将使用名称
    `carBooking` 注册应用程序：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s start building our `src/main.js` by adding a map component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加地图组件来开始构建我们的 `src/main.js`：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of using libraries for styling, we will create our own styles using
    `StyleSheet`, a React Native API, which serves as an abstraction similar to CSS
    style sheets. With `StyleSheet`, we can create a style sheet from an object (through
    the `create` method), which can be used in our components by referring to each
    style by its ID.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `StyleSheet` 来创建自己的样式，而不是使用样式库，`StyleSheet` 是一个 React Native API，类似于 CSS
    样式表的抽象。使用 `StyleSheet`，我们可以通过对象（通过 `create` 方法）创建样式表，然后在组件中通过引用每个样式的 ID 来使用它们。
- en: This way, we can reuse the style code and make the code more readable as we
    will be using meaningful names to refer to each style (for example, `<Text style={styles.title}>Title
    1</Text>`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以重用样式代码，并通过使用有意义的名称来引用每个样式（例如，`<Text style={styles.title}>Title 1</Text>`）使代码更易读。
- en: 'At this point, we will only create a style referred by the key `fullScreenMap`
    and make it as an absolute position by covering the fullscreen size by adding
    `top`, `bottom`, `left`, and `right` coordinates to zero. On top of this, we need
    to add some styling to our container view to ensure it fills the whole screen:
    `{flex: 1}`. Setting `flex` to `1`, we want our view to fill all the space its
    parent occupies. Since this is the main view, `{flex: 1}` will take over the whole
    screen.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '在这一点上，我们只会创建一个由键 `fullScreenMap` 引用的样式，并通过将 `top`、`bottom`、`left` 和 `right`
    坐标添加到零来使其成为绝对位置，覆盖全屏大小。除此之外，我们需要为容器视图添加一些样式，以确保它填满整个屏幕：`{flex: 1}`。将 `flex` 设置为
    `1`，我们希望我们的视图填满其父级占用的所有空间。由于这是主视图，`{flex: 1}` 将占据整个屏幕。'
- en: For our map component, we will use `react-native-maps`, an open module created
    by Airbnb using native maps capabilities for Google and Apple maps. `react-native-maps`
    is a very flexible module, really well maintained, and fully featured so that
    it has become the de facto maps module for React Native. As we will see later
    in this lesson, `react-native-maps` requires the developer to run `react-native
    link` in order for it to work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的地图组件，我们将使用 `react-native-maps`，这是由 Airbnb 创建的一个开放模块，使用原生地图功能支持 Google 和
    Apple 地图。`react-native-maps` 是一个非常灵活的模块，维护得非常好，并且功能齐全，因此它已经成为 React Native 的事实地图模块。正如我们将在本课程的后面看到的那样，`react-native-maps`
    需要开发人员运行 `react-native link` 才能正常工作。
- en: 'Apart from the style, the `<MapView/>` component will take `initialRegion`
    as a property to centre the map in a specific set of coordinates, which should
    be the current location of the user. For consistency reasons, we will locate the
    center of the map in San Francisco where we will also place some bookable cars:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了样式之外，`<MapView/>` 组件将以 `initialRegion` 作为属性，将地图居中在一组特定的坐标上，这些坐标应该是用户的当前位置。出于一致性的原因，我们将把地图的中心定位在旧金山，在那里我们还将放置一些可预订的汽车。
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have added an array of `carLocations` to be shown on the map as markers.
    Inside our `render` function, we will iterate over this array and place the corresponding
    `<MapView.Marker/>` in the provided coordinates. Inside each marker, we will add
    the image of the car rotating it by a specific number of degrees, so they match
    the streets directions. Rotating images must be done with the `Animated` API,
    which will be better explained later in this lesson.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个`carLocations`数组，以在地图上显示为标记。在我们的`render`函数中，我们将遍历这个数组，并将相应的`<MapView.Marker/>`放置在提供的坐标中。在每个标记内，我们将添加车辆的图像，并通过特定角度旋转它，以匹配街道方向。旋转图像必须使用`Animated`
    API完成，这将在本课程的后面更好地解释。
- en: 'Let''s add a new property in our state to store a human-readable position for
    the location in which the map is centered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的状态中添加一个新属性，用于存储地图中心位置的可读位置：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To fill this state variable, we also created a function `_onRegionChange`, which
    uses the `react-native-geocoder` module. This module uses Google Maps reverse
    geocoding services to translate some coordinates into a human-readable location.
    Because it's a Google Service, we might need to add an API key in order to authenticate
    our app with the service. All the instructions to get this module fully installed
    can be found at its repository URL [https://github.com/airbnb/react-native maps/blob/master/docs/installation.md](https://github.com/airbnb/react-native%20maps/blob/master/docs/installation.md).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这个状态变量，我们还创建了一个`_onRegionChange`函数，它使用`react-native-geocoder`模块。该模块使用Google
    Maps的逆地理编码服务将一些坐标转换为可读位置。因为这是一个Google服务，我们可能需要添加一个API密钥来验证我们的应用程序与服务的身份。有关完全安装此模块的所有说明可以在其存储库URL
    [https://github.com/airbnb/react-native maps/blob/master/docs/installation.md](https://github.com/airbnb/react-native%20maps/blob/master/docs/installation.md)
    中找到。
- en: We want this state variable to be available from the first mount of the main
    component, so we will call `_onRegionChange` in `componentDidMount` so that the
    name of the initial location is also stored in the state. Moreover, we will add
    the `onRegionChange` property on our `<MapView/>` to ensure the name of the location
    is recalculated every time the map is moved to show a different region, so we
    always have the name of the location in the center of the map in our `position`
    state variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个状态变量在主组件挂载时就可用，因此我们将在`componentDidMount`中调用`_onRegionChange`，以便初始位置的名称也存储在状态中。此外，我们将在我们的`<MapView/>`上添加`onRegionChange`属性，以确保每次地图移动以显示不同区域时，位置的名称都会重新计算，这样我们的`position`状态变量中始终有地图中心位置的名称。
- en: 'As a final step on this screen, we will add all the subviews and another function
    to confirm the booking request:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此屏幕的最后一步，我们将添加所有子视图和另一个确认预订请求的函数：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We added four subviews:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了四个子视图：
- en: '`LocationSearch`: The component in which we will show the user the location
    that is centered on the map so she can know the name of the location she is exactly
    requesting the pickup.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationSearch`: 我们将在此组件中向用户显示地图中心的位置，以便她知道她准确请求接送的位置名称。'
- en: '`LocationPin`: A pinpointing to the center of the map, so the user can see
    on the map where she will request the pickup. It will also display a button to
    confirm the pickup.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationPin`: 地图中心的标记，用户可以在地图上看到她将请求接送的位置。它还会显示一个确认接送的按钮。'
- en: '`ClassSelection`: A bar where the user can select the type of car for the pickup
    (economy, special, or superior).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassSelection`: 用户可以在其中选择接送车辆类型（经济型、特殊型或高级型）的条形图。'
- en: '`ConfirmationModal`: The modal displaying the confirmation of the request.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfirmationModal`: 显示请求确认的模态框。'
- en: The `_onBookingRequest` method will be responsible for bringing the confirmation
    modal up when a booking is requested.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`_onBookingRequest`方法将负责在请求预订时弹出确认模态框。'
- en: Adding Images to Our App
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加图像
- en: 'React Native deals with images in a similar way as websites do: images should
    be placed in a folder inside the projects folder structure, and then they can
    be referenced from the `<Image />` (or `<Animated.Image />`) by the `source` property.
    Let''s see an example from our app:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: React Native处理图像的方式与网站类似：图像应放置在项目文件夹结构内的一个文件夹中，然后可以通过`<Image />`（或`<Animated.Image
    />`）的`source`属性引用它们。让我们看一个来自我们应用程序的例子：
- en: '`car.png`: This is placed inside the `img/` folder in the root of our project'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car.png`：这个文件放在我们项目根目录的`img/`文件夹内'
- en: 'Then the image will be displayed by creating an `<Image/>` component using
    the `source` property:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后通过使用`source`属性创建一个`<Image/>`组件来显示图像：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the `source` property doesn't accept a string, but a `require('../img/car.png')`.
    This is a special case in React Native and may change in future versions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`source`属性不接受字符串，而是`require('../img/car.png')`。这是React Native中的一个特殊情况，可能会在将来的版本中改变。
- en: LocationSearch
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置搜索
- en: 'This should be a simple textbox displaying the human-readable name of the location
    in which the map is centered. Let''s take a look at the code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是一个简单的文本框，显示地图中心的位置的可读名称。让我们看一下代码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It receives only one property: `value` (the name of the location to be displayed).
    If it''s not set, it will display a spinner to show activity.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它只接收一个属性：`value`（要显示的位置的名称）。如果没有设置，它将显示一个旋转器来显示活动。
- en: Because there are many different styles to be applied in this component, it's
    beneficial to use the `StyleSheet` API to organize the styles in a key/value object
    and refer it from our `render` method. This separation between logic and style
    helps in readability of the code and also enables code reuse as the styles can
    be cascaded down to child components.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个组件中有许多不同的样式要应用，所以使用`StyleSheet` API将样式组织在一个键/值对象中，并从我们的`render`方法中引用它是有益的。逻辑和样式之间的分离有助于代码的可读性，也使代码重用成为可能，因为样式可以被级联到子组件中。
- en: Aligning Elements
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐元素
- en: 'React Native uses Flexbox for setting up the layout of the elements in an app.
    This is mostly straightforward, but sometimes it can be confusing when it comes
    to aligning elements as there are four properties that can be used for this purpose:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: React Native使用Flexbox来设置应用程序中元素的布局。这通常很简单，但有时在对齐元素时可能会令人困惑，因为有四个属性可以用于此目的：
- en: '`justifyContent:` It defines the alignment of the child elements through the
    main axis'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`justifyContent:` 它通过主轴定义子元素的对齐方式'
- en: '`alignItems`: It defines the alignment of the child elements through the cross-axis'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignItems`：它通过交叉轴定义子元素的对齐方式'
- en: '`alignContent`: It aligns a flex container''s lines within when there is extra
    space in the cross-axis'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignContent`：当交叉轴上有额外空间时，它会对齐flex容器的行'
- en: '`alignSelf`: It allows the default alignment (or the one specified by `alignItems`)
    to be overridden for individual flex items'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignSelf`：它允许为单个flex项覆盖默认对齐（或由`alignItems`指定的对齐方式）'
- en: The first three properties should be assigned to the container element, while
    the fourth one will be applied to a child element in case we want to override
    the default alignment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个属性应该分配给容器元素，而第四个属性将应用于子元素，以防我们想要覆盖默认对齐方式。
- en: 'In our case, we only want one element (the title) to be center aligned so we
    can use `alignSelf: ''center''`. Later in this lesson, we will see other uses
    for the different `align` properties.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的情况下，我们只希望一个元素（标题）居中对齐，所以我们可以使用`alignSelf: ''center''`。在本课程的后面，我们将看到不同`align`属性的其他用途。'
- en: LocationPin
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置图钉
- en: 'In this section, we will focus on building the pinpointing to the center of
    the map to visually confirm the pickup location. This pin also contains a button,
    which can be used to trigger a pickup request:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将专注于构建指向地图中心的图钉，以直观确认取货位置。这个图钉还包含一个按钮，可以用来触发取货请求：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This component is again very light in terms of functionality, but has a lot
    of custom style. Let's dive into some of the style details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件在功能上又非常轻量，但具有很多自定义样式。让我们深入一些样式细节。
- en: flexDirection
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: flexDirection
- en: 'By default, React Native and Flexbox stack elements vertically:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Native 和 Flexbox 会垂直堆叠元素：
- en: '![flexDirection](Images/01_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![flexDirection](Images/01_08.jpg)'
- en: 'For the banner in our pin, we want to stack every element horizontally after
    each other as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们图钉上的横幅，我们希望将每个元素水平堆叠在一起：
- en: '![flexDirection](Images/01_09.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![flexDirection](Images/01_09.jpg)'
- en: 'This can be achieved by adding the following styles to the containing element
    `flexDirection: ''row''`. The other valid options for `flexDirection` are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '这可以通过将以下样式添加到包含元素`flexDirection: ''row''`来实现。`flexDirection`的其他有效选项是：'
- en: '`row-reverse`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row-reverse`'
- en: '`column` (default)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`（默认）'
- en: '`column-reverse`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column-reverse`'
- en: Dimensions
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dimensions
- en: 'One of the first lines of code in this component extracts the height and the
    width from the device into two variables:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中的第一行代码中，从设备中提取了高度和宽度到两个变量中：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Obtaining the height and width of the device enables us developers to absolute
    position some elements being confident they will show properly aligned. For example,
    we want the banner of our pin to be aligned in the center of the screen, so it
    points to the center of the map. We can do this by adding `{top: (height/2), left:
    (width/2)}` to the `banner` style in our style sheet. Of book, that would align
    the upper-left corner, so we need to subtract half the size of the banner to each
    property to ensure it gets centered in the middle of the element. This trick can
    be used whenever we need to align an element that is not relative to any other
    in the components tree although it is recommended to use relative positioning
    when possible.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '获取设备的高度和宽度使我们开发人员能够绝对定位一些元素，确信它们将正确对齐。例如，我们希望我们图钉的横幅对齐在屏幕中心，所以它指向地图的中心。我们可以通过在我们的样式表中的`banner`样式中添加`{top:
    (height/2), left: (width/2)}`来实现这一点。当然，这会将其对齐到左上角，所以我们需要从每个属性中减去横幅大小的一半，以确保它在元素中间居中。每当我们需要对齐一个与组件树中的任何其他元素无关的元素时，都可以使用这个技巧，尽管在可能的情况下建议使用相对定位。'
- en: Shadows
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shadows
- en: 'Let''s set focus on our banner''s style, specifically on the `shadows` properties:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于我们横幅的样式，特别是`shadows`属性：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to add a shadow to a component, we need to add four properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给组件添加阴影，我们需要添加四个属性：
- en: '`shadowColor`: This adds the hexadecimal or RGBA value of the color we want
    for our component'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowColor`：这添加了我们想要为组件设置的十六进制或RGBA颜色值'
- en: '`shadowOffset`: This shows how far we want our shadow to be casted'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowOffset`：这显示了我们希望阴影投射多远'
- en: '`shadowRadius`: This shows the value of the radius in the corner of our shadow'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowRadius`：这显示了阴影角落的半径值'
- en: '`shadowOpacity`: This shows how dark we want our shadow to be'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowOpacity`：这显示了我们希望阴影有多深'
- en: That's it for our `LocationPin` component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`LocationPin`组件。
- en: ClassSelection
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClassSelection
- en: 'In this component, we will explore the `Animated` API in React Native to get
    started with animations. Moreover, we will use custom fonts to improve the user
    experience and increase the feeling of customization in our app:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们将探索在React Native中使用`Animated` API来开始动画。此外，我们将使用自定义字体来改善用户体验，并增加我们应用程序中的定制感。
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This simple component is made out of five sub components:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的组件由五个子组件组成：
- en: '`classBar`: This is an image showing the bar and the stop points for each class'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classBar`：这是显示条和每个类别停止点的图像'
- en: '`classButton`: This is the round button, which will be moved to the selected
    class once the user presses a specific class'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classButton`：这是圆形按钮，用户按下特定类别后将移动到所选类别'
- en: '`classButtonContainer`: This is the touchable component detecting what class
    the user wants to select'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classButtonContainer`：这是检测用户想要选择的类的可触摸组件'
- en: '`classLabel`: These are titles for each class to be displayed on top of the
    bar'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classLabel`：这些是要显示在条的顶部的每个类别的标题'
- en: 'Let''s start by taking a look at the styles as we can find a new property for
    image components: `resizeMode`, which determines how to resize the image when
    the frame doesn''t match the raw image dimensions. From the five possible values
    (`cover`, `contain`, `stretch`, `repeat`, and `center`), we chose contain as we
    want to scale the image uniformly (maintain the image''s aspect ratio) so that
    both dimensions of the image will be equal to or less than the corresponding dimension
    of the view. We are using these properties both in `classBar` and `classButtonImage`
    being the two images we will need to resize in this view.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下样式，因为我们可以找到图像组件的一个新属性：`resizeMode`，它确定当框架与原始图像尺寸不匹配时如何调整图像大小。从五种可能的值（`cover`、`contain`、`stretch`、`repeat`和`center`）中，我们选择了`contain`，因为我们希望均匀缩放图像（保持图像的纵横比），以便图像的两个尺寸都等于或小于视图的相应尺寸。我们在`classBar`和`classButtonImage`中都使用了这些属性，这是我们需要在此视图中调整大小的两个图像。
- en: Adding Custom Fonts
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: React Native includes a long list of cross-platform fonts available by default.
    The list of fonts can be checked on [https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: React Native包含默认可用的跨平台字体的长列表。字体列表可以在[https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts)上查看。
- en: Nevertheless, adding custom fonts is a common need when developing apps, especially
    when designers are involved, so we will use our car booking app as a playground
    to test this functionality.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，添加自定义字体是开发应用程序时的常见需求，特别是当设计师参与其中时，因此我们将使用我们的汽车预订应用程序作为测试此功能的游乐场。
- en: 'Adding custom fonts to our app is a three steps task:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将自定义字体添加到我们的应用程序是一个三步任务：
- en: Add the font file (`.ttf`) into a folder inside our project. We used `fonts/`
    for this app.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字体文件（`.ttf`）添加到项目内的一个文件夹中。我们在这个应用程序中使用`fonts/`。
- en: 'Add the following lines to our `package.json`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到我们的`package.json`中：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following command in a terminal:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s it, React Native''s CLI will handle the insertion of the `fonts` folder
    and its files inside the iOS and Android project at once. Our fonts will be available
    by their font name (which may not be the same as the filename). In our case, we
    have `fontFamily: ''Blair ITC''` in our style sheet.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '就是这样，React Native的CLI将一次性处理`fonts`文件夹及其文件在iOS和Android项目中的插入。我们的字体将通过它们的字体名称（可能与文件名不同）可用。在我们的样式表中，我们有`fontFamily:
    ''Blair ITC''`。'
- en: 'We can now modify our `classLabel` style in the `ClassSelection` component
    to include the new font:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改`ClassSelection`组件中的`classLabel`样式，以包含新的字体：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Animations
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: React Native's `Animated` API is designed to make it very easy to concisely
    express a wide variety of interesting animation and interaction patterns in a
    very performant way. Animated focuses on declarative relationships between inputs
    and outputs, with configurable transforms in between, and simple `start`/`stop`
    methods to control time-based animation execution.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的`Animated` API旨在以非常高效的方式简洁地表达各种有趣的动画和交互模式。动画侧重于输入和输出之间的声明关系，中间有可配置的转换，并且有简单的`start`/`stop`方法来控制基于时间的动画执行。
- en: 'What we want to do in our app is to move the `classButton` to a specific location
    whenever the user presses the class she wants to book. Let''s take a closer look
    at how we are using this API in our app:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中要做的是，当用户按下她想要预订的班级时，将`classButton`移动到特定位置。让我们更仔细地看看我们在应用程序中如何使用这个API：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this movement to happen correctly, we need to wrap the `classButtonImage`
    in `Animated.View` and provide an initial `Animated.Value` to it as a left coordinate.
    We will use `this.state.classButtonPosition` for this matter so that we can change
    it when the user selects a specific class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种移动正确发生，我们需要将`classButtonImage`包装在`Animated.View`中，并为其提供一个初始的`Animated.Value`作为左坐标。为此，我们将使用`this.state.classButtonPosition`，这样当用户选择特定班级时我们可以改变它。
- en: 'We are ready to start our animation. It will be triggered by the `_onClassChange`
    method, as it is the one invoked when the user presses `classButtonContainer`
    `(<TouchableOpacity/>`). This method is calling the `Animated.timing` function
    passing two parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备开始我们的动画。它将由`_onClassChange`方法触发，因为当用户按下`classButtonContainer`（`<TouchableOpacity/>`）时，它被调用。这个方法调用`Animated.timing`函数传递两个参数：
- en: The animated value to drive (`this.state.classButtonPosition`)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动动画的动画值（`this.state.classButtonPosition`）
- en: An object containing the end value and the duration of the animation
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含动画的结束值和持续时间的对象
- en: Invoking `Animated.timing` will result in an object containing the `start()`
    method, which we call right away to start the animation. React Native will then
    know that the `left` coordinate of the `Animated.View` needs to be slowly changed
    according to the provided parameters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Animated.timing`将导致一个包含`start()`方法的对象，我们立即调用该方法来启动动画。然后React Native将知道`Animated.View`的`left`坐标需要根据提供的参数慢慢改变。
- en: As this may feel a bit overcomplicated for a simple move animation, it allows
    a wide range of customization as chaining animations or modifying the easing functions.
    We will see a rotation animation later in this lesson.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能对于简单的移动动画来说有点复杂，但它允许广泛的定制，如链接动画或修改缓动函数。我们将在本课程的后面看到旋转动画。
- en: ConfirmationModal
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConfirmationModal
- en: 'Our last component is a modal view, which will be opened once the user has
    pressed on the `SET PICKUP LOCATION` button on the location pin. We will display
    the modal and a custom activity indicator, which will use a complex animation
    setup to continuously rotate in its position:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个组件是一个模态视图，当用户按下“设置取货位置”按钮时将打开该视图。我们将显示模态视图和自定义活动指示器，它将使用复杂的动画设置来持续旋转在其位置：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this component, we are using the `<Modal />` component available in React
    Native to take advantage of its fade animation and visibility capabilities. The
    property `this.props.visible` will drive the visibility of this component as it
    is the parent who is aware of the pickup request from the user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，我们使用了React Native中可用的`<Modal />`组件，以利用其淡入淡出动画和可见性功能。属性`this.props.visible`将驱动此组件的可见性，因为父级知道用户的取货请求。
- en: Let's focus again on animations as we want to do a more complex setup for the
    spinner showing activity. We want to display an endless rotating animation, so
    we need to systematically call our `start()` animation method. In order to achieve
    this, we created a `cycleAnimation()` method, which is called on the component
    mount (to get the animation started) and from the `Animated.timing` returned object
    as it is passed as a callback to be invoked every time the animation ends.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次关注动画，因为我们想为显示活动的旋转器设置一个更复杂的设置。我们想要显示一个无休止旋转的动画，所以我们需要系统地调用我们的`start()`动画方法。为了实现这一点，我们创建了一个`cycleAnimation()`方法，它在组件挂载时被调用（以启动动画），并且从返回的`Animated.timing`对象中调用，因为它被作为回调传递以在每次动画结束时被调用。
- en: 'We are also using `Animated.sequence` to concatenate two animations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`Animated.sequence`来连接两个动画：
- en: Moving from 0 degrees to 360 (in one second using a linear easing)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0度移动到360度（在一秒钟内使用线性缓动）
- en: Moving from 360 degrees to 0 (in 0 seconds)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从360度移动到0度（在0秒内）
- en: This is required to repeat the first animation over at the end of each cycle.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了在每个周期结束时重复第一个动画。
- en: Finally, we defined a variable named `interpolatedRotateAnimation` to store
    the interpolation from 0 degrees to 360, so it can be passed to the `transform`/`rotate`
    style defining what are going to be the available rotation values when animating
    our `Animated.Image`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个名为`interpolatedRotateAnimation`的变量，用于存储从0度到360度的插值，因此可以将其传递给`transform`/`rotate`样式，定义在动画我们的`Animated.Image`时可用的旋转值。
- en: 'As an experiment, we can try and change loading.png with an alternative image
    and see how it gets animated. This can be easily achieved by replacing the `source`
    property in our `<Animated.Image />` component:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，我们可以尝试用另一张图片替换loading.png，看看它是如何被动画化的。这可以通过替换我们的`<Animated.Image />`组件中的`source`属性来轻松实现：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Using UI libraries such as `native-base` or `react-native-elements` saves a
    lot of time and maintenance hassle when we need to build apps, but the results
    end up having a standard flavor, which is not always desirable in terms of user
    experience. That's why learning how to manipulate the style of our apps is always
    a good idea, especially on teams where the design is provided by UX specialists
    or app designers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如`native-base`或`react-native-elements`之类的UI库在构建应用程序时节省了大量时间和维护麻烦，但结果最终呈现出标准风格，这在用户体验方面并不总是理想的。这就是为什么学习如何操纵我们应用程序的样式总是一个好主意，特别是在设计由UX专家或应用程序设计师提供的团队中。
- en: In this lesson, we took a deep look into the folders and files created by React
    Native's CLI when initializing a project. Moreover, we familiarized ourselves
    with the developer menu and its debugging functionalities. When building our app
    we set the focus on the layouts and component styling, but also on how to add
    and manipulate animations to make our interface more appealing to the user. We
    took a look at Flexbox layout system and how to stack and center elements in our
    components. API's such as dimensions were used to retrieve the device width and
    height to perform positioning tricks on some components. You learned how to add
    fonts and images into our app and how to show them to improve the user experience.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们深入研究了React Native的CLI在初始化项目时创建的文件夹和文件。此外，我们熟悉了开发者菜单及其调试功能。在构建我们的应用程序时，我们专注于布局和组件样式，还学习了如何添加和操纵动画，使我们的界面更具吸引力。我们研究了Flexbox布局系统以及如何在组件中堆叠和居中元素。API，如dimensions，用于检索设备的宽度和高度，以便对一些组件进行定位。您学会了如何将字体和图像添加到我们的应用程序，并如何显示它们以改善用户体验。
- en: Now that we know how to build more custom interfaces, let's build in the next
    lesson an image sharing app in which design plays a key role.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何构建更多定制的界面，让我们在下一课中构建一个图像分享应用程序，其中设计起着关键作用。
- en: Assessments
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Why does the `react-native-geocoder` module uses Google Maps reverse geocoding
    services?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`react-native-geocoder`模块使用Google地图的逆地理编码服务？
- en: To store a human-readable position for the location in which the map is centred
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储地图中心位置的人类可读位置
- en: To translate some coordinates into a human-readable location
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些坐标转换为人类可读的位置
- en: To add an API key in order to authenticate our app with the service
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加API密钥以便用服务对我们的应用进行身份验证
- en: To ensure the name of the location is recalculated every time the map is moved
    to show a different region
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保每次地图移动以显示不同区域时重新计算位置的名称。
- en: Which of the following properties is used for aligning elements?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个属性用于对齐元素？
- en: '`justifyContent`'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`justifyContent`'
- en: '`alignLeft`'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alignLeft`'
- en: '`alignRight`'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alignRight`'
- en: '`alignJustify`'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alignJustify`'
- en: By default, React Native and Flexbox stack elements ________.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，React Native 和 Flexbox 堆叠元素。
- en: Diagonally
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对角线
- en: Reverse
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反向
- en: Vertically
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直地
- en: Horizontally
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平地
- en: Which of the following lines of code extracts the height and the width from
    a device into two variables?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行代码从设备中提取高度和宽度到两个变量中？
- en: '`const {height, width} = Dimensions.get(''height, width'');`'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const {height, width} = Dimensions.get(''height, width'');`'
- en: '`constant {height, width} = Dimensions.get(''window'');`'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constant {height, width} = Dimensions.get(''window'');`'
- en: '`const {height, width} = get(''window'');`'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const {height, width} = Dimensions.get(''window'');`'
- en: '`const {height, width} = Dimensions.get(''window'');`'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const {height, width} = Dimensions.get(''window'');`'
- en: Which are the four properties in order to add a shadow to a component?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按顺序添加阴影到组件的四个属性是什么？
