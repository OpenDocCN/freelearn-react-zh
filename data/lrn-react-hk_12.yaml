- en: Building Your Own Hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的Hooks
- en: In the previous chapter, we learned about the limitations and rules of Hooks.
    We learned where to call Hooks, why the order of Hooks matters, and the naming
    conventions for Hooks. Finally, we learned about enforcing the rules of Hooks
    and dealing with `useEffect` dependencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Hooks的限制和规则。我们了解了在哪里调用Hooks，为什么Hooks的顺序很重要，以及Hooks的命名约定。最后，我们学习了如何强制执行Hooks的规则以及处理`useEffect`的依赖关系。
- en: In this chapter, we are going to learn how to create custom Hooks by extracting
    existing code from our components. We are also going to learn how to use custom
    Hooks and how Hooks can interact with each other. Then, we are going to learn
    how to write tests for our custom Hooks. Finally, we are going to learn about
    the full React Hooks API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过从组件中提取现有代码来创建自定义Hooks。我们还将学习如何使用自定义Hooks以及Hooks如何相互交互。然后，我们将学习如何为我们的自定义Hooks编写测试。最后，我们将学习有关完整的React
    Hooks API。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Extracting custom Hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取自定义Hooks
- en: Using custom Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义Hooks
- en: Interactions between Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks之间的交互
- en: Testing Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Hooks
- en: Exploring the React Hooks API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索React Hooks API
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: The code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter10)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际运行情况：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples provided previously. It is important to write
    the code yourself in order to learn and understand properly. However, if you run
    into any issues, you can always refer to the code example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行之前提供的代码示例。重要的是要自己编写代码，以便正确学习和理解。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now let's get started with the chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始本章。
- en: Extracting custom Hooks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取自定义Hooks
- en: After getting a good grasp on the concept of Hooks by learning about the State
    and Effect Hooks, community Hooks, and the rules of Hooks, we are now going to
    build our own Hooks. We start by extracting custom Hooks from existing functionalities
    of our blog application. Usually, it makes the most sense to first write the component,
    and then later extract a custom Hook from it if we notice that we use similar
    code across multiple components. Doing so avoids prematurely defining custom Hooks
    and making our project unnecessarily complex.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习State和Effect Hooks、community Hooks以及Hooks的规则，我们对Hooks的概念有了很好的理解，现在我们将构建自己的Hooks。我们首先从我们的博客应用程序的现有功能中提取自定义Hooks。通常情况下，如果我们注意到我们在多个组件中使用类似的代码，那么首先编写组件，然后稍后从中提取自定义Hook是最合理的。这样做可以避免过早地定义自定义Hooks，并使我们的项目变得不必要地复杂。
- en: 'We are going to extract the following Hooks in this section:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提取以下Hooks：
- en: A `useTheme` Hook
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useTheme` Hook'
- en: The `useUserState` and `usePostsState` Hooks
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useUserState`和`usePostsState` Hooks'
- en: A `useDispatch` Hook
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDispatch` Hook'
- en: API Hooks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API Hooks
- en: A `useDebouncedUndo` Hook
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebouncedUndo` Hook'
- en: Creating a useTheme Hook
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个useTheme Hook
- en: 'In many components, we use the `ThemeContext` to style our blog app. Functionality
    that is used across multiple components is usually a good opportunity for creating
    a custom Hook. As you might have noticed, we often do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多组件中，我们使用 `ThemeContext` 来为我们的博客应用程序设置样式。通常在多个组件中使用的功能通常是创建自定义 Hook 的好机会。正如你可能已经注意到的，我们经常做以下事情：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We could abstract this functionality into a `useTheme` Hook, which will get
    the `theme` object from the `ThemeContext`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个功能抽象成一个 `useTheme` Hook，它将从 `ThemeContext` 中获取 `theme` 对象。
- en: 'Let''s start creating a custom `useTheme` Hook:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个自定义的 `useTheme` Hook：
- en: Create a new `src/hooks/` directory, which is where we are going to put our
    custom Hooks.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/` 目录，这是我们将放置自定义 Hooks 的地方。
- en: Create a new `src/hooks/useTheme.js` file.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/useTheme.js` 文件。
- en: 'In this newly created file, we first import the `useContext` Hook and the `ThemeContext` as
    follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，我们首先导入 `useContext` Hook 和 `ThemeContext` 如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we export a new function called `useTheme`; this will be our custom Hook.
    Remember, Hooks are just functions prefixed with the `use` keyword:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导出一个名为 `useTheme` 的新函数；这将是我们的自定义 Hook。记住，Hooks 只是以 `use` 关键字为前缀的函数：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our custom Hook, we can now use the essential Hooks provided by React to
    build our own Hook. In our case, we simply return the `useContext` Hook:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的自定义 Hook 中，我们现在可以使用 React 提供的基本 Hooks 来构建我们自己的 Hook。在我们的情况下，我们只是返回 `useContext`
    Hook：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, custom Hooks can be quite simple. In this case, the custom Hook
    only returns a Context Hook with the `ThemeContext` passed to it. Nevertheless,
    this makes our code more concise and easier to change later. Furthermore, by using
    a `useTheme` Hook, it is clear that we want to access the theme, which means our
    code will be easier to read and reason about.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，自定义 Hooks 可以非常简单。在这种情况下，自定义 Hook 只返回一个传递给它的 `ThemeContext` 的 Context
    Hook。然而，这使我们的代码更简洁，以后更容易更改。此外，通过使用 `useTheme` Hook，我们清楚地表明我们想要访问主题，这意味着我们的代码将更容易阅读和理解。
- en: Creating global state Hooks
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全局状态 Hooks
- en: 'Another thing that we often do is access the global state. For example, some
    components need the `user` state and some need the `posts` state. To abstract
    this functionality, which will also make it easier to adjust the state structure
    later on, we can create custom Hooks to get certain parts of the state:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常做的另一件事是访问全局状态。例如，一些组件需要 `user` 状态，一些需要 `posts` 状态。为了抽象这个功能，这也将使以后更容易调整状态结构，我们可以创建自定义
    Hooks 来获取状态的特定部分：
- en: '`useUserState`: Gets the `user` part of the `state` object'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useUserState`：获取 `state` 对象的 `user` 部分'
- en: '`usePostsState`: Gets the `posts` part of the `state` object'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usePostsState`：获取 `state` 对象的 `posts` 部分'
- en: Defining the useUserState Hook
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 useUserState Hook
- en: Repeating a similar process to what we did for the `useTheme` Hook, we import
    the `useContext` Hook from React and the `StateContext`. However, instead of returning
    the result of the Context Hook, we now pull out the `state` object via destructuring
    and then return `state.user`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重复类似于我们为 `useTheme` Hook 所做的过程，我们从 React 中导入 `useContext` Hook 和 `StateContext`。然而，我们现在不返回
    Context Hook 的结果，而是通过解构提取 `state` 对象，然后返回 `state.user`。
- en: 'Create a new `src/hooks/useUserState.js` file with the following contents:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/useUserState.js` 文件，内容如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similarly to the `useTheme` Hook, the `useUserState` Hook makes our code more
    concise, easier to change later, and improves readability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `useTheme` Hook 类似，`useUserState` Hook 使我们的代码更简洁，以后更容易更改，并提高了可读性。
- en: Defining the usePostsState Hook
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 usePostsState Hook
- en: 'We repeat the same process for the `posts` state. Create a new `src/hooks/usePostsState.js` file
    with the following contents:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `posts` 状态重复相同的过程。创建一个新的 `src/hooks/usePostsState.js` 文件，内容如下：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similarly to the `useTheme` and `useUserState` Hooks, the `usePostsState` Hook
    makes our code more concise, easier to change later, and improves readability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与`useTheme`和`useUserState` Hooks类似，`usePostsState` Hook使我们的代码更简洁，更容易以后更改，并提高了可读性。
- en: Creating a useDispatch Hook
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个useDispatch Hook
- en: 'In many components, we need the `dispatch` function to do certain actions,
    so we often have to do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多组件中，我们需要`dispatch`函数来执行某些操作，所以我们经常需要做以下操作：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can abstract this functionality into a `useDispatch` Hook, which will get
    the `dispatch` function from our global state context. Doing this will also make
    it easier to replace the state management implementation later on. For example,
    later on, we could replace our simple Reducer Hook with a state management library
    such as Redux or MobX.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个功能抽象成一个`useDispatch` Hook，它将从全局状态上下文中获取`dispatch`函数。这样做也会使以后更容易替换状态管理实现。例如，以后我们可以用Redux或MobX等状态管理库来替换我们简单的Reducer
    Hook。
- en: 'Let''s define the `useDispatch` Hook now using the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在按照以下步骤定义`useDispatch` Hook：
- en: Create a new `src/hooks/useDispatch.js` file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useDispatch.js`文件。
- en: 'Import the `useContext` Hook from React and the `StateContext` as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从React中导入`useContext` Hook和`StateContext`如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we define and export the `useDispatch` function; here, we allow passing
    a different `context` as an argument for making the Hook more generic (in case
    we want to use the `dispatch` function from a local state context later on). However,
    we set the default value of the `context` argument to the `StateContext` like
    so:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义并导出`useDispatch`函数；在这里，我们允许传递不同的`context`作为参数，以使Hook更通用（以防以后我们想要从本地状态上下文中使用`dispatch`函数）。然而，我们将`context`参数的默认值设置为`StateContext`，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we pull out the `dispatch` function from the Context Hook via destructuring
    and return it with the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过解构从Context Hook中提取`dispatch`函数，并使用以下代码返回它：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, creating a custom Dispatch Hook makes our code easier to change
    later on, as we only need to adjust the `dispatch` function in one place.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，创建自定义Dispatch Hook使我们的代码更容易以后更改，因为我们只需要在一个地方调整`dispatch`函数。
- en: Creating API Hooks
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建API Hooks
- en: We can also create Hooks for the various API calls. Putting these Hooks in a
    single file allows us to adjust the API calls easily later on. We are going to
    prefix our custom API Hooks with `useAPI` so it is easy to tell which functions
    are API Hooks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为各种API调用创建Hooks。将这些Hooks放在一个单独的文件中可以让我们以后更容易调整API调用。我们将用`useAPI`前缀来命名我们的自定义API
    Hooks，这样很容易区分哪些函数是API Hooks。
- en: 'Let''s create custom Hooks for our API now using the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在按照以下步骤为我们的API创建自定义Hooks：
- en: Create a new `src/hooks/api.js` file.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/api.js`文件。
- en: 'Import the `useResource` Hook from the `react-request-hook` library as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`react-request-hook`库中导入`useResource` Hook如下：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, we define a `useAPILogin` Hook to log in a user; we simply cut and paste
    the existing code from the `src/user/Login.js` file like so:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`useAPILogin` Hook来登录用户；我们只需从`src/user/Login.js`文件中剪切并粘贴现有的代码如下：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we define a `useAPIRegister` Hook; we simply cut and paste the existing
    code from the `src/user/Register.js` file as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`useAPIRegister` Hook；我们只需从`src/user/Register.js`文件中剪切并粘贴现有的代码如下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we define a `useAPICreatePost` Hook, cutting and pasting the existing code
    from the `src/post/CreatePost.js` file, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个`useAPICreatePost` Hook，从`src/post/CreatePost.js`文件中剪切并粘贴现有的代码如下：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we define a `useAPIThemes` Hook, cutting and pasting the existing
    code from the `src/ChangeTheme.js` file as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个`useAPIThemes` Hook，从`src/ChangeTheme.js`文件中剪切并粘贴现有的代码如下：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, having all API-related functionality in one place makes it easier
    to adjust our API code later on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，将所有与API相关的功能放在一个地方，可以更容易地在以后调整我们的API代码。
- en: Creating a useDebouncedUndo Hook
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个useDebouncedUndo Hook
- en: We are now going to create a slightly more advanced Hook for debounced undo
    functionality. We already implemented this functionality in the `CreatePost` component.
    Now, we are going to extract this functionality into a custom `useDebouncedUndo` Hook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个稍微更高级的用于防抖撤销功能的Hook。我们已经在`CreatePost`组件中实现了这个功能。现在，我们将把这个功能提取到一个自定义的`useDebouncedUndo`
    Hook中。
- en: 'Let''s create the `useDebouncedUndo` Hook with the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建`useDebouncedUndo` Hook：
- en: Create a new `src/hooks/useDebouncedUndo.js` file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useDebouncedUndo.js`文件。
- en: 'Import the `useState`, `useEffect`, and `useCallback` Hooks from React, as
    well as the `useUndo` Hook and the `useDebouncedCallback` Hook:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从React中导入`useState`、`useEffect`和`useCallback` Hooks，以及`useUndo` Hook和`useDebouncedCallback`
    Hook：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we are going to define the `useDebouncedUndo` function, which accepts a
    `timeout` argument for the debounced callback:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义`useDebouncedUndo`函数，它接受一个用于防抖回调的`timeout`参数：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this function, we copy over the `useState` Hook from the previous implementation,
    as shown here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们从先前的实现中复制了`useState` Hook，如下所示：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we copy over the `useUndo` Hook; however, this time, we store all other
    undo-related functions in an `undoRest` object:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们复制`useUndo` Hook；但是，这一次，我们将所有其他与撤销相关的函数存储在一个`undoRest`对象中：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we copy over the `useDebouncedCallback` Hook, replacing the fixed `200`
    value with our `timeout` argument:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们复制`useDebouncedCallback` Hook，用我们的`timeout`参数替换固定的`200`值：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we copy over the Effect Hook, as shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们复制Effect Hook，如下所示的代码：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we define a `setter` function, which is going to set a new input `value`
    and call `setDebounce`. We can wrap the `setter` function with a `useCallback` Hook
    here to return a memoized version of the function and avoid recreating the function
    every time the component that uses the Hook re-renders. Similar to the `useEffect`
    and `useMemo` Hooks, we also pass a dependency array as the second argument of
    the `useCallback` Hook:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`setter`函数，它将设置一个新的输入`value`并调用`setDebounce`。我们可以在这里使用`useCallback`
    Hook来包装`setter`函数，以返回函数的记忆版本，并避免在使用Hook的组件重新渲染时每次重新创建函数。与`useEffect`和`useMemo`
    Hook类似，我们还将一个依赖数组作为`useCallback` Hook的第二个参数传递：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we return the `content` variable (containing the current input `value`),
    the `setter` function, and the `undoRest` object (which contains the `undo`/`redo`
    functions and the `canUndo`/`canRedo` booleans):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回`content`变量（包含当前输入`value`）、`setter`函数和`undoRest`对象（其中包含`undo`/`redo`函数和`canUndo`/`canRedo`布尔值）：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a custom Hook for debounced undo means that we can reuse that functionality
    across multiple components. We could even provide this Hook as a public library,
    allowing others to easily implement debounced undo/redo functionality.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于防抖撤销的自定义Hook意味着我们可以在多个组件中重用该功能。我们甚至可以将此Hook提供为公共库，让其他人轻松实现防抖撤销功能。
- en: Exporting our custom Hooks
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出我们的自定义Hooks
- en: 'After creating all our custom Hooks, we are going to create an `index.js` file
    in our Hooks directory and re-export our Hooks there, so that we can import our
    custom Hooks as follows: `import { useTheme } from ''./hooks''`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了所有我们的自定义Hooks之后，我们将在我们的Hooks目录中创建一个`index.js`文件，并在那里重新导出我们的Hooks，这样我们就可以按照以下方式导入我们的自定义Hooks：`import
    { useTheme } from './hooks'`
- en: 'Let''s export all our custom Hooks now using the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤导出所有我们的自定义Hooks：
- en: Create a new `src/hooks/index.js` file.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/index.js`文件。
- en: 'In this file, we first import our custom Hooks as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先导入我们的自定义Hooks如下：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we re-export these imported Hooks with the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码重新导出这些导入的Hooks：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we re-export all Hooks from the `api.js` file as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从`api.js`文件中重新导出所有的Hooks，如下所示：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have exported all our custom Hooks, we can simply import Hooks directly
    from the `hooks` folder, making it easier to import multiple custom Hooks at once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导出了所有自定义的Hooks，我们可以直接从`hooks`文件夹中导入Hooks，这样可以更容易地一次导入多个自定义的Hooks。
- en: Example code
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter10/chapter10_1` folder.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter10/chapter10_1`文件夹中找到。
- en: Just run `npm install` to install all dependencies and `npm start` to start
    the application, and then visit `http://localhost:3000` in your browser (if it
    does not open automatically).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有的依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using our custom Hooks
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的自定义Hooks
- en: After creating our custom Hooks, we can now start using them throughout our
    blog application. Using custom Hooks is quite straightforward as they are similar
    to community Hooks. Just like all other Hooks, custom Hooks are simply JavaScript
    functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的自定义Hooks之后，我们现在可以开始在整个博客应用程序中使用它们。使用自定义Hooks非常简单，因为它们类似于社区Hooks。就像所有其他Hooks一样，自定义Hooks只是JavaScript函数。
- en: 'We created the following Hooks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了以下的Hooks：
- en: '`useTheme`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useTheme`'
- en: '`useDispatch`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDispatch`'
- en: '`usePostsState`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usePostsState`'
- en: '`useUserState`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useUserState`'
- en: '`useDebouncedUndo`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebouncedUndo`'
- en: '`useAPILogin`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAPILogin`'
- en: '`useAPIRegister`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAPIRegister`'
- en: '`useAPICreatePost`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAPICreatePost`'
- en: '`useAPIThemes`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAPIThemes`'
- en: In this section, we are going to refactor our app to use all of our custom Hooks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将重构我们的应用程序来使用所有自定义的Hooks。
- en: Using the useTheme Hook
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用useTheme Hook
- en: Instead of using the `useContext` Hook with the `ThemeContext`, we can now use
    the `useTheme` Hook directly! If we end up changing the theming system later on,
    we can simply modify the `useTheme` Hook and our new system will be implemented
    throughout our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接使用`useTheme` Hook，而不是使用`ThemeContext`的`useContext` Hook！如果以后我们改变了主题系统，我们只需修改`useTheme`
    Hook，新系统就会在整个应用程序中实现。
- en: 'Let''s refactor our app to use the `useTheme` Hook:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的应用程序来使用`useTheme` Hook：
- en: 'Edit `src/Header.js` and replace the existing imports with an import of the
    `useTheme` Hook. The `ThemeContext` and `useContext` imports can be removed:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/Header.js`，并用`useTheme` Hook的导入替换现有的导入。`ThemeContext`和`useContext`的导入可以被移除：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, replace the current Context Hook definition with the `useTheme` Hook,
    as shown here:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将当前的Context Hook定义替换为`useTheme` Hook，如下所示：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now edit `src/post/Post.js` and adjust the imports similarly there:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑`src/post/Post.js`，并在那里进行类似的导入调整：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, replace the `useContext` Hook with the `useTheme` Hook as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`useContext` Hook替换为以下的`useTheme` Hook：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, using a custom Hook makes our code much more concise and easier
    to read. We now move on to using the global state Hooks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用自定义Hook使我们的代码更加简洁和易于阅读。现在我们继续使用全局状态的Hooks。
- en: Using the global state Hooks
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局状态的Hooks
- en: Similarly to what we did with the `ThemeContext`, we can also replace our state
    Context Hooks with the `usePostsState`, `useUserState`, and `useDispatch` Hooks.
    This is optimal if we want to change the state logic later. For example, if our
    state grows and we want to use a more sophisticated system such as Redux or MobX,
    then we can simply adjust the existing Hooks and everything will work the same
    way as before.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对`ThemeContext`所做的类似，我们也可以用`usePostsState`、`useUserState`和`useDispatch` Hook替换我们的状态Context
    Hooks。如果以后我们想要更改状态逻辑，这是最佳的选择。例如，如果我们的状态增长并且我们想要使用更复杂的系统，比如Redux或MobX，那么我们只需调整现有的Hooks，一切都会像以前一样工作。
- en: 'In this section, we are going to adjust the following components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将调整以下组件：
- en: '`UserBar`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserBar`'
- en: '`Login`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Login`'
- en: '`Register`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Register`'
- en: '`Logout`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logout`'
- en: '`CreatePost`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatePost`'
- en: '`PostList`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostList`'
- en: Adjusting the UserBar component
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`UserBar`组件
- en: 'First, we are going to adjust the `UserBar` component. Here, we can use the
    `useUserState` Hook by following these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调整`UserBar`组件。在这里，我们可以按照以下步骤使用`useUserState` Hook：
- en: 'Edit `src/user/UserBar.js` and import the `useUserState` Hook:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/UserBar.js`并导入`useUserState` Hook：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we remove the following Hook definition:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们移除以下Hook定义：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We replace it with our custom `useUserState` Hook:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用我们自定义的`useUserState` Hook替换它：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the `UserBar` component makes use of our custom Hook instead of directly
    accessing the `user` state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`UserBar`组件使用我们的自定义Hook，而不是直接访问`user`状态。
- en: Adjusting the Login component
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`Login`组件
- en: 'Next, we are going to adjust the `Login` component, where we can use the `useDispatch`
    Hook. This process is outlined in the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整`Login`组件，这里我们可以使用`useDispatch` Hook。具体步骤如下所述：
- en: 'Edit `src/user/Login.js` and import the `useDispatch` Hook, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Login.js`并导入`useDispatch` Hook，如下所示：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then remove the following Context Hook:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后移除以下Context Hook：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace it with our custom `useDispatch` Hook:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们自定义的`useDispatch` Hook替换它：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now the `Login` component makes use of our custom Hook instead of directly accessing
    the `dispatch` function. Next, we are going to adjust the `Register` component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Login`组件使用我们的自定义Hook，而不是直接访问`dispatch`函数。接下来，我们将调整`Register`组件。
- en: Adjusting the Register component
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`Register`组件
- en: 'Similarly to the `Login` component, we can also use the `useDispatch` Hook
    in the `Register` component, as shown in the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Login`组件类似，我们也可以在`Register`组件中使用`useDispatch` Hook，具体步骤如下所示：
- en: 'Edit `src/user/Register.js` and import the `useDispatch` Hook:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Register.js`并导入`useDispatch` Hook：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, replace the current Context Hook with our custom Dispatch Hook, as shown
    here:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用我们自定义的Dispatch Hook替换当前的Context Hook，如下所示：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the `Register` component also makes use of our custom Hook instead of directly
    accessing the `dispatch` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Register`组件也使用我们的自定义Hook，而不是直接访问`dispatch`函数。
- en: Adjusting the Logout component
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`Logout`组件
- en: 'Then, we are going to adjust the `Logout` component to use both the `useUserState`
    and the `useDispatch` Hooks with the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将调整`Logout`组件，以使用`useUserState`和`useDispatch` Hooks，具体步骤如下：
- en: 'Edit `src/user/Logout.js` and import the `useUserState` and `useDispatch` Hooks:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Logout.js`并导入`useUserState`和`useDispatch` Hooks：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, replace the current Hook definitions with the following:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换当前的Hook定义：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now the `Logout` component makes use of our custom Hooks instead of directly
    accessing the `user` state and the `dispatch` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Logout`组件使用我们的自定义Hooks，而不是直接访问`user`状态和`dispatch`函数。
- en: Adjusting the CreatePost component
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`CreatePost`组件
- en: 'Next we are going to adjust the `CreatePost` component, which is similar to
    what we did with the `Logout` component. This process is outlined in the following
    steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整`CreatePost`组件，这与我们对`Logout`组件所做的类似。具体步骤如下所述：
- en: 'Edit `src/post/CreatePost.js` and import the `useUserState` and `useDispatch` Hooks:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/CreatePost.js`并导入`useUserState`和`useDispatch` Hooks：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, replace the current Context Hook definition with the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换当前的Context Hook定义：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now the `CreatePost` component makes use of our custom Hooks instead of directly
    accessing the `user` state and the `dispatch` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`CreatePost`组件使用我们的自定义Hooks，而不是直接访问`user`状态和`dispatch`函数。
- en: Adjusting the PostList component
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`PostList`组件
- en: 'Finally, we are going to use the `usePostsState` Hook to render the `PostList`
    component, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`usePostsState` Hook来渲染`PostList`组件，如下所示：
- en: 'Edit `src/post/PostList.js` and import the `usePostsState` Hook:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/PostList.js`并导入`usePostsState` Hook：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then replace the current Hook definition with the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后用以下内容替换当前的Hook定义：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now the `PostList` component makes use of our custom Hook instead of directly
    accessing the `posts` state.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`PostList`组件使用我们自定义的Hook而不是直接访问`posts`状态。
- en: Using the API Hooks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API Hooks
- en: Next, we are going to replace all the `useResource` Hooks with our custom API
    Hooks. Doing so allows us to have all the API calls in one file so that we can
    easily adjust them later on, in case the API changes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将用我们自定义的API Hooks替换所有`useResource` Hooks。这样做可以让我们将所有API调用放在一个文件中，以便以后可以轻松调整它们，以防API发生变化。
- en: 'In this section, we are going to adjust the following components:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将调整以下组件：
- en: '`ChangeTheme`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChangeTheme`'
- en: '`Register`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Register`'
- en: '`Login`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Login`'
- en: '`CreatePost`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatePost`'
- en: Let's get started.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Adjusting the ChangeTheme component
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整ChangeTheme组件
- en: 'First, we are going to adjust the `ChangeTheme` component and replace the Resource
    Hook, accessing `/themes` with our custom `useAPIThemes` Hook in the following
    steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调整`ChangeTheme`组件，并用我们自定义的`useAPIThemes` Hook替换访问`/themes`的Resource Hook，步骤如下：
- en: 'In `src/ChangeTheme.js`, remove the following `useResource` Hook import statement:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/ChangeTheme.js`中，删除以下`useResource` Hook导入语句：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace it with our custom `useAPIThemes` Hook:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 用我们自定义的`useAPIThemes` Hook替换它：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, replace the `useResource` Hook definition with the following custom Hook:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下自定义Hook替换`useResource` Hook定义：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now the `ChangeTheme` component uses our custom API Hook to pull themes from
    the API.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`ChangeTheme`组件使用我们自定义的API Hook从API中获取主题。
- en: Adjusting the Register component
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整注册组件
- en: 'Next, we are going to adjust the `Register` component with the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过以下步骤调整`Register`组件：
- en: 'Edit `src/user/Register.js` and adjust the import statement to also import
    the `useAPIRegister` Hook:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Register.js`并调整导入语句以导入`useAPIRegister` Hook：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, replace the current Resource Hook with the following:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换当前的Resource Hook：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now the `Register` component uses our custom API Hook to `register` users via
    the API.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Register`组件使用我们自定义的API Hook通过API“注册”用户。
- en: Adjusting the Login component
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整登录组件
- en: 'Similar to the `Register` component, we are also going to adjust the `Login`
    component:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Register`组件类似，我们还将调整`Login`组件：
- en: 'Edit `src/user/Login.js` and adjust the import statement to also import the
    `useAPILogin` Hook:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Login.js`并调整导入语句以导入`useAPILogin` Hook：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, replace the current Resource Hook with the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换当前的Resource Hook：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now the `Login` component uses our custom API Hook to log in users via the API.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Login`组件使用我们自定义的API Hook通过API登录用户。
- en: Adjusting the CreatePost component
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整CreatePost组件
- en: 'Finally, we are going to adjust the `CreatePost` component by following these
    steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过以下步骤调整`CreatePost`组件：
- en: 'Edit `src/post/CreatePost.js` and adjust the import statement to also import
    the `useAPICreatePost` Hook:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/CreatePost.js`并调整导入语句以导入`useAPICreatePost` Hook：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, replace the current Resource Hook with the following:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换当前的Resource Hook：
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now the `CreatePost` component uses our custom API Hook to create new posts
    via the API.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`CreatePost`组件使用我们自定义的API Hook通过API创建新帖子。
- en: Using the useDebouncedUndo Hook
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用useDebouncedUndo Hook
- en: Finally, we are going to replace all debounced undo logic in the `src/post/CreatePost.js`
    file with our custom `useDebouncedUndo` Hook. Doing so will make our component
    code much cleaner and easier to read. Furthermore, we can reuse the same debounced
    undo functionality in other components later.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`src/post/CreatePost.js`文件中用我们自定义的`useDebouncedUndo` 钩子替换所有防抖撤销逻辑。这样做将使我们的组件代码更加清晰和易于阅读。此外，我们以后可以在其他组件中重用相同的防抖撤销功能。
- en: 'Let''s get started using the Debounced Undo Hook in the `CreatePost` component
    by following these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤在`CreatePost`组件中开始使用Debounced Undo钩子：
- en: 'Edit `src/post/CreatePost.js` and import the `useDebouncedUndo` Hook:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/CreatePost.js`并导入`useDebouncedUndo` 钩子：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, remove the following code related to debounced undo handling:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，移除与防抖撤销处理相关的以下代码：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Replace it with our custom `useDebouncedUndo` Hook, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用我们自定义的`useDebouncedUndo` 钩子替换它，如下所示：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, remove the following setter functions in our `handleContent` function
    (marked in bold):'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`handleContent`函数中移除以下设置函数（用粗体标记）：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can now use the `setContent` function provided by our custom Hook instead:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们自定义钩子提供的`setContent`函数：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, our code is much cleaner, more concise, and easier to read now.
    Furthermore, we can reuse the Debounced Undo Hook in other components later on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的代码现在更加清晰、简洁和易于阅读。此外，我们以后可以在其他组件中重用Debounced Undo钩子。
- en: Example code
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter10/chapter10_2` folder.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter10/chapter10_2`文件夹中找到。
- en: Just run `npm install` to install all dependencies and `npm start` to start
    the application, and then visit `http://localhost:3000` in your browser (if it
    does not open automatically).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Interactions between Hooks
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子之间的交互
- en: Our whole blog app now works in the same way as before, but it uses our custom
    Hooks! Until now, we have always had Hooks that encapsulated the whole logic,
    with only constant values being passed as arguments to our custom Hooks. However,
    we can also pass values of other Hooks into custom Hooks!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个博客应用现在的工作方式与以前相同，但它使用我们自定义的钩子！到目前为止，我们一直有封装整个逻辑的钩子，只有常量值作为参数传递给我们的自定义钩子。然而，我们也可以将其他钩子的值传递给自定义钩子！
- en: 'Since Hooks are simply JavaScript functions, all Hooks can accept any value
    as arguments and work with them: constant values, component props, or even values
    from other Hooks.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于钩子只是JavaScript函数，所有钩子都可以接受任何值作为参数并与它们一起工作：常量值、组件props，甚至来自其他钩子的值。
- en: We are now going to create local Hooks, which means that they will be placed
    in the same file as the component, because they are not needed anywhere else.
    However, they will still make our code easier to read and maintain. These local
    Hooks will accept values from other Hooks as arguments.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要创建本地钩子，这意味着它们将放在与组件相同的文件中，因为它们在其他地方都不需要。但是，它们仍然会使我们的代码更易于阅读和维护。这些本地钩子将接受来自其他钩子的值作为参数。
- en: 'The following local Hooks will be created:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下本地钩子将被创建：
- en: A local Register Effect Hook
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地注册效果钩子
- en: A local Login Effect Hook
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地登录效果钩子
- en: Let's see how to create them in the following subsections.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下小节中创建它们。
- en: Creating a local Register Effect Hook
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地注册效果钩子
- en: 'First of all, we are going to extract the Effect Hook from our `Login` component
    to a separate `useRegisterEffect` Hook function. This function will accept the
    following values from other Hooks as arguments: `user` and `dispatch`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从我们的`Login`组件中提取Effect Hook到一个单独的`useRegisterEffect` 钩子函数中。这个函数将接受来自其他钩子的以下值作为参数：`user`和`dispatch`。
- en: 'Let''s create a local Effect Hook for the `Register` component now using the
    following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下步骤为`Register`组件创建一个本地Effect Hook：
- en: 'Edit `src/user/Register.js` and define a new function outside of the component
    function, right after the import statements:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Register.js`并在组件函数之外定义一个新函数，在导入语句之后：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the contents of the function, cut the existing Effect Hook from the `Register`
    component and paste it here:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于函数的内容，从`Register`组件中剪切现有的Effect Hook，并将其粘贴在这里：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, define our custom `useLoginEffect` Hook where we cut out the previous
    Effect Hook, and pass the values from the other Hooks to it:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义我们的自定义`useLoginEffect` Hook，在其中剪切出先前的Effect Hook，并将其他Hooks的值传递给它：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we can see, extracting an effect into a separate function makes our code
    easier to read and maintain.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，将效果提取到一个单独的函数中使我们的代码更易于阅读和维护。
- en: Creating a local Login Effect Hook
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个本地登录效果钩子
- en: 'Repeating a similar process to the local Register Effect Hook, we are also
    going to extract the Effect Hook from our `Login` component to a separate `useLoginEffect` Hook
    function. This function will accept the following values from other Hooks as arguments:
    `user`, `dispatch`, and `setLoginFailed`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 重复类似的过程到本地`Register` Effect Hook，我们还将从`Login`组件中提取Effect Hook到一个单独的`useLoginEffect`
    Hook函数。这个函数将接受来自其他Hooks的以下值作为参数：`user`，`dispatch`和`setLoginFailed`。
- en: 'Let''s create a local Hook for the `Login` component now using the following
    steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下步骤为`Login`组件创建一个本地Hook：
- en: 'Edit `src/user/Login.js` and define a new function outside of the component
    function, right after the import statements:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Login.js`并在组件函数之外定义一个新函数，在导入语句之后：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For the contents of the function, cut the existing Effect Hook from the `Login`
    component and paste it here:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于函数的内容，从`Login`组件中剪切现有的Effect Hook，并将其粘贴在这里：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we also added `setLoginFailed` to the Effect Hook dependencies. This is
    to make sure that whenever the `setter` function changes (which could happen eventually
    when using the Hook) the Hook triggers again. Always passing all dependencies
    of an Effect Hook, including functions, prevents bugs and unexpected behavior
    later on.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还将`setLoginFailed`添加到Effect Hook的依赖项中。这是为了确保每当`setter`函数发生变化时（在使用Hook时可能会发生），Hook会再次触发。始终传递Effect
    Hook的所有依赖项，包括函数，可以防止以后出现错误和意外行为。
- en: 'Finally, define our custom `useLoginEffect` Hook, where we cut out the previous
    Effect Hook, and pass the values from the other Hooks to it:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义我们的自定义`useLoginEffect` Hook，在其中剪切出先前的Effect Hook，并将其他Hooks的值传递给它：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As we can see, extracting an effect into a separate function makes our code
    easier to read and maintain.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，将效果提取到一个单独的函数中使我们的代码更易于阅读和维护。
- en: Example code
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter10/chapter10_3` folder.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter10/chapter10_3`文件夹中找到。
- en: Just run `npm install` to install all dependencies and `npm start` to start
    the application, and then visit `http://localhost:3000` in your browser (if it
    does not open automatically).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Testing Hooks
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Hooks
- en: Now our blog application makes full use of Hooks! We even defined custom Hooks
    for various functions to make our code more reusable, concise, and easy to read.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的博客应用程序充分利用了Hooks！我们甚至为各种功能定义了自定义Hooks，使我们的代码更具可重用性，简洁和易于阅读。
- en: When defining custom Hooks, it makes sense to write tests for them to ensure
    they work properly, even when we change them later on or add more options.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义自定义Hooks时，编写测试对它们进行测试是有意义的，以确保它们能够正常工作，即使以后我们对它们进行更改或添加更多选项。
- en: To test our Hooks, we are going to use the Jest test runner, which is included
    in our `create-react-app` project. However, as a result of the rules of Hooks,
    we cannot call Hooks from the test functions because they can only be called inside
    the body of a function component.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的Hooks，我们将使用Jest测试运行器，它包含在我们的`create-react-app`项目中。然而，由于Hooks的规则，我们不能从测试函数中调用Hooks，因为它们只能在函数组件的主体内部调用。
- en: Because we do not want to create a component specifically for each test, we
    are going to use the React Hooks Testing Library to test Hooks directly. This
    library actually creates a test component and provides various utility functions
    to interact with the Hook.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不想为每个测试专门创建一个组件，我们将使用React Hooks测试库直接测试Hooks。该库实际上创建一个测试组件，并提供各种实用函数来与Hook交互。
- en: Using the React Hooks Testing Library
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Hooks测试库
- en: 'In addition to the React Hooks Testing Library, we also need a special renderer
    for React. To render React components to the DOM, we used `react-dom`; for tests,
    we can use the `react-test-renderer`. We are now going to install the React Hooks
    Testing Library and the `react-test-renderer` via `npm`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React Hooks测试库，我们还需要一个专门的React渲染器。我们使用`react-dom`将React组件渲染到DOM中，而在测试中，我们可以使用`react-test-renderer`。现在我们将通过`npm`安装React
    Hooks测试库和`react-test-renderer`：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The React Hooks Testing Library should be used in the following circumstances:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 应在以下情况下使用React Hooks测试库：
- en: When writing libraries that define Hooks
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写定义Hooks的库时
- en: When you have Hooks that are used throughout multiple components (global Hooks)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有Hooks在多个组件中使用时（全局Hooks）
- en: However, the library should not be used when a Hook is only defined and used
    in a single component (local Hooks).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当一个Hook只在单个组件中定义和使用时（局部Hooks），不应该使用该库。
- en: In that case, we should test the component directly using the React Testing
    Library. However, testing React components is beyond the scope of this book. More
    information about testing components can be found on the library website: [https://testing-library.com/docs/react-testing-library/intro](https://testing-library.com/docs/react-testing-library/intro).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该直接使用React Testing Library测试组件。然而，测试React组件超出了本书的范围。有关测试组件的更多信息可以在库网站上找到：[https://testing-library.com/docs/react-testing-library/intro](https://testing-library.com/docs/react-testing-library/intro)。
- en: Testing simple Hooks
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试简单的Hooks
- en: First of all, we are going to test a very simple Hook that does not make use
    of contexts or asynchronous code such as timeouts. To do this, we are going to
    create a new Hook called `useCounter`. Then, we are going to test various parts
    of the Hook.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将测试一个非常简单的 Hook，它不使用上下文或异步代码，比如超时。为了做到这一点，我们将创建一个名为`useCounter`的新 Hook。然后，我们将测试
    Hook 的各个部分。
- en: 'The following tasks will be covered in this section:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下任务：
- en: Creating the `useCounter` Hook
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`useCounter` Hook
- en: Testing the result
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试结果
- en: Testing Hook actions
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Hook动作
- en: Testing the initial value
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试初始值
- en: Testing reset and forcing re-rendering
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试重置和强制重新渲染
- en: Let's get started now.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始吧。
- en: Creating the useCounter Hook
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`useCounter` Hook
- en: The `useCounter` Hook is going to provide a current `count` and functions to `increment` and `reset` the
    counter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCounter` Hook将提供当前的`count`和用于`增加`和`重置`计数器的函数。'
- en: 'Let''s create the `useCounter` Hook now using the following steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下步骤创建`useCounter` Hook：
- en: Create a new `src/hooks/useCounter.js` file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useCounter.js`文件。
- en: 'Import the `useState` and `useCallback` Hooks from React as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从React中导入`useState`和`useCallback` Hooks如下：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We define a new `useCounter` Hook function with an argument for the `initialCount`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一个参数`initialCount`来定义一个新的`useCounter` Hook函数：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we define a new State Hook for the `count` value with the following code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码为`count`值定义一个新的State Hook：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we define functions for incrementing and resetting the `count`, as shown
    here:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义增加和重置`count`的函数，如下所示：
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we return the current `count` and the two functions:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回当前的`count`和两个函数：
- en: '[PRE69]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now that we have defined a simple Hook, we can start testing it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个简单的Hook，我们可以开始测试它。
- en: Testing the useCounter Hook result
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试useCounter Hook结果
- en: 'Let''s now write tests for the `useCounter` Hook we created, by following these
    steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤为我们创建的`useCounter` Hook编写测试：
- en: Create a new `src/hooks/useCounter.test.js` file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useCounter.test.js`文件。
- en: 'Import the `renderHook` and `act` functions from the React Hooks Testing Library,
    as we are going to use these later:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从React Hooks测试库中导入`renderHook`和`act`函数，因为我们将在稍后使用它们：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Also, import the to-be-tested `useCounter` Hook, as shown here:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要导入要测试的`useCounter` Hook，如下所示：
- en: '[PRE71]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we can write our first test. To define a test, we use the `test` function
    from Jest. The first argument is the name of the test and the second argument
    is a function to be run as the test:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的第一个测试。要定义一个测试，我们使用Jest的`test`函数。第一个参数是测试的名称，第二个参数是要作为测试运行的函数：
- en: '[PRE72]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In this test, we use the `renderHook` function to define our Hook. This function
    returns an object with a `result` key, which is going to contain the result of
    our Hook:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用`renderHook`函数来定义我们的Hook。这个函数返回一个带有`result`键的对象，其中将包含我们Hook的结果：
- en: '[PRE73]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can check the values of the `result` object using `expect` from Jest.
    The `result` object contains a `current` key, which will contain the current result
    from the Hook:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用Jest的`expect`来检查`result`对象的值。`result`对象包含一个`current`键，其中将包含来自Hook的当前结果：
- en: '[PRE74]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we can see, writing tests for Hook results is quite simple! When creating
    custom Hooks, especially when they are going to be used publicly, we should always
    write tests to ensure they work correctly.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，为Hook结果编写测试非常简单！创建自定义Hook时，特别是当它们将被公开使用时，我们应该始终编写测试以确保它们正常工作。
- en: Testing useCounter Hook actions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试useCounter Hook操作
- en: Using the `act` function from the React Hooks Testing Library, we can execute
    functions from the Hook and then check the new result.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Hooks测试库中的`act`函数，我们可以执行Hook中的函数，然后检查新的结果。
- en: 'Let''s now test actions of our Counter Hook:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的Counter Hook的操作：
- en: 'Write a new `test` function, as shown in the following code:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码编写一个新的`test`函数：
- en: '[PRE75]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Call the `increment` function of the Hook within the `act` function:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`act`函数内调用Hook的`increment`函数：
- en: '[PRE76]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we check whether the new `count` is now `1`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查新的`count`现在是否为`1`：
- en: '[PRE77]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As we can see, we can simply use the `act` function to trigger actions in our
    Hook and then test the value just like we did before.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以简单地使用`act`函数来触发我们的Hook中的操作，然后像以前一样测试值。
- en: Testing the useCounter initial value
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试useCounter初始值
- en: We can also check the result before and after calling `act` and pass an initial value
    to our Hook.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在调用`act`之前和之后检查结果，并将初始值传递给我们的Hook。
- en: 'Let''s now test the initial value of our Hook:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的Hook的初始值：
- en: 'Define a new `test` function, passing the initial value `123` to the Hook:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的`test`函数，将初始值`123`传递给Hook：
- en: '[PRE78]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now we can check if the `current` value equals the initial value, call `increment`,
    and ensure the `count` was increased from the initial value:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查`current`值是否等于初始值，调用`increment`，并确保`count`从初始值增加：
- en: '[PRE79]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As we can see, we can simply pass the initial value to the Hook and check whether
    the value is the same.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以简单地将初始值传递给Hook，并检查值是否相同。
- en: Testing reset and forcing re-rendering
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试重置和强制重新渲染
- en: We are now going to simulate the props of a component changing. Imagine the
    initial value for our Hook is a prop and it is initially `0`, which then changes
    to `123` later on. If we reset our counter now, it should reset to `123` and not
    `0`. However, to do so, we need to force the re-rendering of our test component
    after changing the value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要模拟组件的props发生变化。假设我们Hook的初始值是一个prop，最初是`0`，然后后来变成了`123`。如果我们现在重置计数器，它应该重置为`123`而不是`0`。然而，为了做到这一点，我们需要在改变值后强制重新渲染我们的测试组件。
- en: 'Let''s now test resetting and forcing the component to re-render:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试重置并强制组件重新渲染：
- en: 'Define the `test` function and a variable for the `initial` value:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`test`函数和一个`initial`值的变量：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, we are going to render our Hook, but this time, we also pull out the
    `rerender` function via destructuring:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将渲染我们的Hook，但这次，我们还通过解构赋值取出`rerender`函数：
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we set a new `initial` value and call the `rerender` function:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们设置一个新的`initial`值并调用`rerender`函数：
- en: '[PRE82]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Our `initial` value should now have changed, so when we call `reset`, the `count`
    will be set to `123`:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`initial`值现在应该已经改变了，所以当我们调用`reset`时，`count`将被设置为`123`：
- en: '[PRE83]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As we can see, the testing library creates a dummy component, which is used
    for testing the Hook. We can force this dummy component to re-render in order
    to simulate what would happen when props change in a real component.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，测试库创建了一个虚拟组件，用于测试Hook。我们可以强制这个虚拟组件重新渲染，以模拟在真实组件中props发生变化时会发生什么。
- en: Testing Context Hooks
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试上下文Hooks
- en: Using the React Hooks Testing Library, we can also test more complex Hooks,
    such as Hooks making use of React context. Most of the custom Hooks we created
    for our blog app make use of contexts, so we are now going to test those. To test
    Hooks that use context, we first have to create a context wrapper, and then we
    can test the Hook.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Hooks测试库，我们也可以测试更复杂的Hooks，比如使用React上下文的Hooks。我们为博客应用程序创建的大多数自定义Hooks都使用了上下文，所以我们现在要测试这些。要测试使用上下文的Hooks，我们首先必须创建一个上下文包装器，然后我们可以测试这个Hook。
- en: 'In this section, we are going to perform the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将执行以下操作：
- en: Create a `ThemeContextWrapper` component
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`ThemeContextWrapper`组件
- en: Test the `useTheme` Hook
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`useTheme` Hook
- en: Create a `StateContextWrapper` component
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`StateContextWrapper`组件
- en: Test the `useDispatch` Hook
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`useDispatch` Hook
- en: Test the `useUserState` Hook
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`useUserState` Hook
- en: Test the `usePostsState` Hook
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`usePostsState` Hook
- en: Let's get started.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating the ThemeContextWrapper
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ThemeContextWrapper
- en: To be able to test the Theme Hook, we first have to set up the context and provide
    a wrapper component for the Hook's test component.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试Theme Hook，我们首先必须设置上下文并为Hook的测试组件提供一个包装器组件。
- en: 'Let''s now create the `ThemeContextWrapper` component:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`ThemeContextWrapper`组件：
- en: Create a new `src/hooks/testUtils.js` file.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/testUtils.js`文件。
- en: 'Import `React` and the `ThemeContext`, as follows:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`React`和`ThemeContext`，如下所示：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define a new function component called `ThemeContextWrapper`; it will accept
    `children` as props:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`ThemeContextWrapper`的新函数组件；它将接受`children`作为props：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`children` is a special prop of React components. It will contain all other
    components passed to it as `children`; for example, `<ThemeContextWrapper>{children}</ThemeContextWrapper>`.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`是React组件的一个特殊prop。它将包含作为`children`传递给它的所有其他组件；例如，`<ThemeContextWrapper>{children}</ThemeContextWrapper>`。'
- en: 'We return a `ThemeContext.Provider` with our default theme, and then pass `children`
    to it:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回一个带有默认主题的`ThemeContext.Provider`，然后将`children`传递给它：
- en: '[PRE86]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As we can see, a context wrapper simply returns a context provider component.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，上下文包装器简单地返回一个上下文提供者组件。
- en: Testing the useTheme Hook
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试useTheme Hook
- en: Now that we have defined the `ThemeContextWrapper` component, we can make use
    of it while testing the `useTheme` Hook.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`ThemeContextWrapper`组件，我们可以在测试`useTheme` Hook时使用它。
- en: 'Let''s now test the `useTheme` Hook as outlined in the following steps:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤测试`useTheme` Hook：
- en: Create a new `src/hooks/useTheme.test.js` file.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useTheme.test.js`文件。
- en: 'Import the `renderHook` function as well as the `ThemeContextWrapper` and the `useTheme` Hook:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`renderHook`函数以及`ThemeContextWrapper`和`useTheme` Hook。
- en: '[PRE87]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, define the `test` using the `renderHook` function and pass the `wrapper`
    as a second argument to it. Doing this will wrap the test component with the defined
    `wrapper` component, which means that we will be able to use the provided context
    in the Hook:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`renderHook`函数定义`test`，并将`wrapper`作为第二个参数传递给它。这样做将使用定义的`wrapper`组件包装测试组件，这意味着我们将能够在Hook中使用提供的上下文。
- en: '[PRE88]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now we can check the result of our Hook, which should contain the colors defined
    in the `ThemeContextWrapper`:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查我们的Hook的结果，它应该包含在`ThemeContextWrapper`中定义的颜色。
- en: '[PRE89]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As we can see, after providing the context wrapper, we can test Hooks that use
    context just like we tested our simple Counter Hook.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，提供上下文包装器后，我们可以测试使用上下文的Hook，就像我们测试简单的Counter Hook一样。
- en: Creating the StateContextWrapper
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`StateContextWrapper`
- en: For the other Hooks, which make use of the `StateContext`, we have to define
    another wrapper to provide the `StateContext` to the Hooks.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他使用`StateContext`的Hook，我们必须定义另一个包装器来向Hook提供`StateContext`。
- en: 'Let''s now define the `StateContextWrapper` component with the following steps:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤定义`StateContextWrapper`组件：
- en: 'Edit `src/hooks/testUtils.js` and adjust the import statements to import the
    `useReducer` Hook, the `StateContext`, and the `appReducer` function:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/hooks/testUtils.js`并调整导入语句以导入`useReducer` Hook，`StateContext`和`appReducer`函数。
- en: '[PRE90]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define a new function component called `StateContextWrapper`. Here we are going
    to use the `useReducer` Hook to define the app state, which is similar to what
    we did in the `src/App.js` file:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`StateContextWrapper`的新函数组件。在这里，我们将使用`useReducer` Hook来定义应用程序状态，这与我们在`src/App.js`文件中所做的类似。
- en: '[PRE91]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, define and return the `StateContext.Provider`, which is similar to what
    we did for the `ThemeContextWrapper`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义并返回`StateContext.Provider`，这与我们为`ThemeContextWrapper`所做的类似。
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As we can see, creating a context wrapper always works similarly. However, this
    time, we are also defining a Reducer Hook in our wrapper component.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，创建上下文包装器总是类似的。然而，这一次，我们还在我们的包装器组件中定义了一个Reducer Hook。
- en: Testing the useDispatch Hook
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`useDispatch` Hook
- en: Now that we have defined the `StateContextWrapper`, we can use it to test the
    `useDispatch` Hook.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`StateContextWrapper`，我们可以使用它来测试`useDispatch` Hook。
- en: 'Let''s test the `useDispatch` Hook with the following steps:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤测试`useDispatch` Hook：
- en: Create a new `src/hooks/useDispatch.test.js` file.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useDispatch.test.js`文件。
- en: 'Import the `renderHook` function, the `StateContextWrapper` component, and
    the `useDispatch` Hook:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`renderHook`函数，`StateContextWrapper`组件和`useDispatch` Hook。
- en: '[PRE93]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then, define the `test` function, passing the `StateContextWrapper` component
    to it:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义`test`函数，将`StateContextWrapper`组件传递给它。
- en: '[PRE94]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Finally, check whether the result of the Dispatch Hook is a function (the `dispatch`
    function):'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查Dispatch Hook的结果是否是一个函数（`dispatch`函数）：
- en: '[PRE95]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As we can see, using a `wrapper` component always works the same way, even if
    we use other Hooks within the `wrapper` component.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用`wrapper`组件总是以相同的方式工作，即使我们在`wrapper`组件中使用其他Hook。
- en: Testing the useUserState Hook
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`useUserState` Hook
- en: Using the `StateContextWrapper` and the Dispatch Hook, we can now test the `useUserState` Hook
    by dispatching `LOGIN` and `REGISTER` actions and checking the result. To dispatch
    these actions, we use the `act` function from the testing library.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`StateContextWrapper`和Dispatch Hook，我们现在可以通过派发`LOGIN`和`REGISTER`动作并检查结果来测试`useUserState`
    Hook。要派发这些动作，我们使用测试库中的`act`函数。
- en: 'Let''s test the `useUserState` Hook:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试`useUserState` Hook：
- en: Create a new `src/hooks/useUserState.test.js` file.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useUserState.test.js`文件。
- en: 'Import the necessary functions, the `useDispatch` and `useUserState` Hooks,
    and the `StateContextWrapper`:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的函数，`useDispatch`和`useUserState` Hooks，以及`StateContextWrapper`：
- en: '[PRE96]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, we write a `test` that checks the initial `user` state:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写一个测试，检查初始的`user`状态：
- en: '[PRE97]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, we write a `test` that dispatches a `LOGIN` action and then checks the
    new state. Instead of returning a single Hook, we now return an object with the
    results of both Hooks:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们编写一个测试，派发一个`LOGIN`动作，然后检查新的状态。现在我们不再返回单个Hook，而是返回一个包含两个Hook结果的对象：
- en: '[PRE98]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, we write a `test` that dispatches a `REGISTER` action and then checks
    the new state:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编写一个测试，派发一个`REGISTER`动作，然后检查新的状态：
- en: '[PRE99]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As we can see, we can access both the `state` object and the `dispatch` function
    from our tests.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以从我们的测试中访问`state`对象和`dispatch`函数。
- en: Testing the usePostsState Hook
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`usePostsState` Hook
- en: Similarly to how we tested the `useUserState` Hook, we can also test the `usePostsState` Hook.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们测试`useUserState` Hook的方式类似，我们也可以测试`usePostsState` Hook。
- en: 'Let''s test the `usePostsState` Hook now:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试`usePostsState` Hook：
- en: Create a new `src/hooks/usePostsState.test.js` file.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/usePostsState.test.js`文件。
- en: 'Import the necessary functions, the `useDispatch` and `usePostsState` Hooks,
    and the `StateContextWrapper`:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的函数，`useDispatch`和`usePostsState` Hooks，以及`StateContextWrapper`：
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, we `test` the initial state of the `posts` array:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们测试`posts`数组的初始状态：
- en: '[PRE101]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, we `test` whether a `FETCH_POSTS` action replaces the current `posts`
    array:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试一个`FETCH_POSTS`动作是否替换了当前的`posts`数组：
- en: '[PRE102]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Finally, we `test` whether a new post gets inserted on a `CREATE_POST` action:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们测试一个新的帖子是否在`CREATE_POST`动作中被插入：
- en: '[PRE103]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As we can see, the tests for the `posts` state are similar to the `user` state,
    but with different actions being dispatched.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`posts`状态的测试与`user`状态类似，但派发的动作不同。
- en: Testing async Hooks
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异步Hooks
- en: Sometimes, we need to test Hooks that do asynchronous actions. This means that
    we need to wait a certain period of time until we check the result. To implement
    tests for these kind of Hooks, we can use the `waitForNextUpdate` function from
    the React Hooks Testing Library.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要测试执行异步操作的Hooks。这意味着我们需要等待一段时间，直到检查结果。为了实现这种类型的Hooks的测试，我们可以使用React Hooks
    Testing Library中的`waitForNextUpdate`函数。
- en: Before we can test async Hooks, we need to learn about the new JavaScript construct
    called `async`/`await`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试异步Hooks之前，我们需要了解一个叫做`async`/`await`的新JavaScript结构。
- en: The async/await construct
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`async`/`await`结构'
- en: 'Normal functions are defined as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 普通函数定义如下：
- en: '[PRE104]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Normal anonymous functions are defined as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 普通匿名函数定义如下：
- en: '[PRE105]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Asynchronous functions are defined by adding the `async` keyword:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`async`关键字来定义异步函数：
- en: '[PRE106]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can also make anonymous functions asynchronous:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使匿名函数异步：
- en: '[PRE107]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Within `async` functions, we can use the `await` keyword to resolve promises.
    We do not have to do the following anymore:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在`async`函数中，我们可以使用`await`关键字来解决承诺。我们不再需要做以下操作：
- en: '[PRE108]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Instead, we can now do this:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们现在可以这样做：
- en: '[PRE109]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: As we can see, `async` functions make our code much more concise and easier
    to read! Now that we have learned about the `async`/`await` construct, we can
    start testing the `useDebouncedUndo` Hook.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`async`函数使我们的代码更加简洁易读！现在我们已经了解了`async`/`await`结构，我们可以开始测试`useDebouncedUndo`
    Hook了。
- en: Testing the useDebouncedUndo Hook
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试useDebouncedUndo Hook
- en: 'We are going to use the `waitForNextUpdate` function to test debouncing in
    our `useDebouncedUndo` Hook by following these steps:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`waitForNextUpdate`函数来测试我们的`useDebouncedUndo` Hook中的去抖动，按照以下步骤：
- en: Create a new `src/hooks/useDebouncedUndo.test.js` file.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/useDebouncedUndo.test.js`文件。
- en: 'Import the `renderHook` and `act` functions as well as the `useDebouncedUndo` Hook:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`renderHook`和`act`函数以及`useDebouncedUndo` Hook：
- en: '[PRE110]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'First of all, we `test` whether the Hook returns a proper `result`, including
    the `content` value, `setter` function, and the `undoRest` object:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们测试Hook是否返回正确的`result`，包括`content`值、`setter`函数和`undoRest`对象：
- en: '[PRE111]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, we `test` whether the `content` value gets updated immediately:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试`content`值是否立即更新：
- en: '[PRE112]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Remember that we can give any name to variables we pull out from an array using
    destructuring. In this case, we first name the `content` variable as `content`,
    then, later, we name it `newContent`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们可以使用解构从数组中提取出的变量赋予任何名称。在这种情况下，我们首先将`content`变量命名为`content`，然后稍后将其命名为`newContent`。
- en: 'Finally, we use `waitForNextUpdate` to wait for the debounced effect to trigger.
    After debouncing, we should now be able to undo our change:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`waitForNextUpdate`来等待去抖动效果触发。去抖动后，我们现在应该能够撤销我们的更改：
- en: '[PRE113]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: As we can see, we can use `async`/`await` in combination with the `waitForNextUpdate`
    function to easily handle testing asynchronous operations in our Hooks.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以结合`waitForNextUpdate`函数和`async`/`await`来轻松处理Hooks中的异步操作。
- en: Running the tests
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'To run the tests, simply execute the following command:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，只需执行以下命令：
- en: '[PRE114]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'As we can see from the following screenshot, all our tests are passing successfully:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从以下截图中所看到的，所有的测试都成功通过了：
- en: '![](assets/d962f6c3-dd93-44f6-8685-80c8fdbb5456.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d962f6c3-dd93-44f6-8685-80c8fdbb5456.png)'
- en: All Hook tests passing successfully
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Hook测试都成功通过了
- en: The test suite actually watches for changes in our files and automatically reruns
    tests. We can use various commands to manually trigger test reruns and we can
    press *Q* to quit the test runner.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件实际上会监视我们文件的更改并自动重新运行测试。我们可以使用各种命令手动触发测试重新运行，我们可以按*Q*退出测试运行器。
- en: Example code
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter10/chapter10_4` folder.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter10/chapter10_4`文件夹中找到。
- en: Just run `npm install` to install all dependencies and `npm start` to start
    the application, and then visit `http://localhost:3000` in your browser (if it
    does not open automatically).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Exploring the React Hooks API
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React Hooks API
- en: 'The official React library provides certain built-in Hooks, which can be used
    to create custom Hooks. We have already learned about the three basic Hooks that
    React provides:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的React库提供了一些内置的Hooks，可以用来创建自定义Hooks。我们已经了解了React提供的三个基本Hooks：
- en: '`useState`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`'
- en: '`useEffect`'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect`'
- en: '`useContext`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useContext`'
- en: 'Additionally, React provides more advanced Hooks, which can be very useful
    in certain use cases:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React提供了更高级的Hooks，在某些用例中非常有用：
- en: '`useReducer`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer`'
- en: '`useCallback`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCallback`'
- en: '`useMemo`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo`'
- en: '`useRef`'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRef`'
- en: '`useImperativeHandle`'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useImperativeHandle`'
- en: '`useLayoutEffect`'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useLayoutEffect`'
- en: '`useDebugValue`'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebugValue`'
- en: The useState Hook
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useState Hook
- en: 'The `useState` Hook returns a value that will persist across re-renders, and
    a function to update it. A value for the `initialState` can be passed to it as
    an argument:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` Hook 返回一个值，该值将在重新渲染时保持不变，并返回一个更新它的函数。可以将一个值作为 `initialState` 的参数传递给它：'
- en: '[PRE115]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Calling `setState` updates the value and re-renders the component with the updated
    value. If the value did not change, React will not re-render the component.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `setState` 更新值并使用更新后的值重新渲染组件。如果值没有改变，React 将不会重新渲染组件。
- en: 'A function can also be passed to the `setState` function, with the first argument
    being the current value. For example, consider the following code:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将一个函数传递给 `setState` 函数，第一个参数是当前值。例如，考虑以下代码：
- en: '[PRE116]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Furthermore, a function can be passed to the first argument of the Hook if
    the initial state is the result of a complex computation. In that case, the function
    will only be called once during the initialization of the Hook:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果初始状态是复杂计算的结果，可以将一个函数传递给 Hook 的第一个参数。在这种情况下，该函数只会在 Hook 初始化期间被调用一次：
- en: '[PRE117]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The State Hook is the most basic and ubiquitous Hook provided by React.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: State Hook 是 React 提供的最基本和普遍的 Hook。
- en: The useEffect Hook
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useEffect` Hook'
- en: 'The `useEffect` Hook accepts a function that contains code with side effects,
    such as timers and subscriptions. The function passed to the Hook will run after
    the render is done and the component is on the screen:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` Hook 接受一个包含具有副作用的代码的函数，例如定时器和订阅。传递给 Hook 的函数将在渲染完成并且组件在屏幕上时运行：'
- en: '[PRE118]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'A cleanup function can be returned from the Hook, which will be called when
    the component unmounts and is used to, for example, clean up timers or subscriptions:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 一个清除函数可以从 Hook 中返回，它将在组件卸载时被调用，并且用于清除定时器或订阅等操作：
- en: '[PRE119]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The cleanup function will also be called before the effect is triggered again,
    when dependencies of the effect update.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当 effect 的依赖项更新时，清除函数也将在触发 effect 之前被调用。
- en: 'To avoid triggering the effect on every re-render, we can specify an array
    of values as the second argument to the Hook. Only when any of these values change,
    the effect will get triggered again:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在每次重新渲染时触发 effect，我们可以将一个值数组作为 Hook 的第二个参数进行指定。只有当这些值中的任何一个发生变化时，effect
    才会再次触发：
- en: '[PRE120]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This array passed as the second argument is called the dependency array of the
    effect. If you want the effect to only trigger during mounting, and the cleanup
    function during unmounting, we can pass an empty array as the second argument.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组作为第二个参数传递被称为 effect 的依赖数组。如果你希望 effect 只在挂载期间触发，并且清除函数在卸载期间触发，我们可以将一个空数组作为第二个参数传递。
- en: The useContext Hook
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useContext` Hook'
- en: 'The `useContext` Hook accepts a context object and returns the current `value`
    for the context. When the context provider updates its `value`, the Hook will
    trigger a re-render with the latest `value`:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext` Hook 接受一个上下文对象，并返回上下文的当前值。当上下文提供程序更新其值时，Hook 将使用最新的值触发重新渲染：'
- en: '[PRE121]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: It is important to note that the context object itself needs to be passed to
    the Hook, not the consumer or provider.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，上下文对象本身需要传递给 Hook，而不是消费者或提供者。
- en: The useReducer Hook
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useReducer` Hook'
- en: 'The `useReducer` Hook is an advanced version of the `useState` Hook. It accepts
    a `reducer` as the first argument, which is a function with two arguments: `state`
    and `action`. The `reducer` function then returns the updated state computed from
    the current state and the action. If a reducer returns the same value as the previous
    state, React will not re-render components or trigger effects:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` Hook 是 `useState` Hook 的高级版本。它接受一个 `reducer` 作为第一个参数，这是一个带有两个参数的函数：`state`
    和 `action`。然后 `reducer` 函数返回从当前状态和操作计算出的更新状态。如果 reducer 返回与上一个状态相同的值，React 将不会重新渲染组件或触发
    effect：'
- en: '[PRE122]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We should use the `useReducer` Hook instead of the `useState` Hook when dealing
    with complex `state` changes. Furthermore, it is easier to deal with global `state`
    because we can simply pass down the `dispatch` function instead of multiple setter
    functions.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂的 `state` 变化时，我们应该使用 `useReducer` Hook 而不是 `useState` Hook。此外，处理全局 `state`
    更容易，因为我们可以简单地传递 `dispatch` 函数，而不是多个 setter 函数。
- en: The `dispatch` function is stable and will not change on re-renders, so it is
    safe to omit it from `useEffect` or the `useCallback` dependencies.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数是稳定的，在重新渲染时不会改变，因此可以安全地从 `useEffect` 或 `useCallback` 的依赖中省略它。'
- en: We can specify the initial `state` by setting the `initialState` value or specifying
    an `initFn` function as the third argument. Specifying such a function makes sense
    when computing the initial `state` takes a long time or when we want to reuse
    the function to reset `state` through an `action`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置 `initialState` 值或指定 `initFn` 函数作为第三个参数来指定初始 `state`。当计算初始 `state` 需要很长时间，或者我们想要通过
    `action` 重用函数来重置 `state` 时，指定这样的函数是有意义的。
- en: The useMemo Hook
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useMemo Hook
- en: 'The `useMemo` Hook takes a result of a function and memoizes it. This means
    that it will not be recomputed every time. This Hook can be used for performance
    optimizations:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook 接受一个函数的结果并对其进行记忆化。这意味着它不会每次重新计算。这个 Hook 可以用于性能优化：'
- en: '[PRE123]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: In the previous example, `computeVal` is a performance-heavy function that computes
    a result from `a`, `b`, and `c`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`computeVal` 是一个性能消耗较大的函数，它从 `a`、`b` 和 `c` 计算出一个结果。
- en: '`useMemo` runs during rendering, so make sure the computation function does
    not cause any side effects, such as resource requests. Side effects should be
    put into a `useEffect` Hook.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 在渲染期间运行，因此确保计算函数不会引起任何副作用，比如资源请求。副作用应该放在 `useEffect` Hook 中。'
- en: The array passed as the second argument specifies the dependencies of the function.
    If any of these values change, the function will be recomputed; otherwise, the
    stored result will be used. If no array is provided, a new value will be computed
    on every render. If an empty array is passed, the value will only be computed
    once.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个参数传递的数组指定了函数的依赖项。如果这些值中的任何一个发生变化，函数将被重新计算；否则，将使用存储的结果。如果不提供数组，每次渲染都会计算一个新值。如果传递一个空数组，该值将只计算一次。
- en: Do not rely on `useMemo` to only compute things once. React may forget some
    previously memoized values if they are not used for a long time, for example,
    to free up memory. Use it only for performance optimizations.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖 `useMemo` 只计算一次。如果长时间不使用，React 可能会忘记一些先前记忆化的值，例如为了释放内存。只用于性能优化。
- en: The `useMemo` Hook is used for performance optimizations in React components.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook 用于 React 组件的性能优化。'
- en: The useCallback Hook
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useCallback Hook
- en: 'The `useCallback` Hook works similarly to the `useMemo` Hook. However, it returns
    a memoized callback function instead of a value:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` Hook 的工作方式类似于 `useMemo` Hook。然而，它返回的是一个记忆化的回调函数，而不是一个值：'
- en: '[PRE124]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The previous code is similar to the following `useMemo` Hook:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码类似于以下的 `useMemo` Hook：
- en: '[PRE125]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The function returned will only be redefined if one of the dependency values
    passed in the array of the second argument changes.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的函数只有在第二个参数的数组中传入的依赖值发生变化时才会被重新定义。
- en: The useRef Hook
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useRef Hook
- en: 'The `useRef` Hook returns a ref object that can be assigned to a component
    or element via the `ref` prop. Refs can be used to deal with references to elements
    and components in React:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` Hook 返回一个 ref 对象，可以通过 `ref` 属性分配给组件或元素。Refs 可以用来处理 React 中元素和组件的引用：'
- en: '[PRE126]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: After assigning the ref to an element or component, the ref can be accessed
    via `refContainer.current`. If `InitialValue` is set, `refContainer.current` will
    be set to this value before assignment.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ref 分配给元素或组件后，可以通过 `refContainer.current` 访问 ref。如果设置了 `InitialValue`，则在分配之前
    `refContainer.current` 将设置为此值。
- en: 'The following example defines an `input` field that will automatically be focused
    when rendered:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个 `input` 字段，当渲染时将自动聚焦：
- en: '[PRE127]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'It is important to note that mutating the current value of a ref does not cause
    a re-render. If this is needed, we should use a `ref` callback using `useCallback` as
    follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，改变 ref 的当前值不会导致重新渲染。如果需要这样做，我们应该使用 `useCallback` 来使用 `ref` 回调，如下所示：
- en: '[PRE128]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Refs can be used to access the DOM, but also to keep mutable values around,
    such as storing references to intervals:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 可以用于访问 DOM，也可以用于保持可变的值，比如存储间隔的引用：
- en: '[PRE129]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Using refs like in the previous example makes them similar to instance variables
    in classes, such as `this.intervalRef`.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的例子中使用 refs 使它们类似于类中的实例变量，比如 `this.intervalRef`。
- en: The useImperativeHandle Hook
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useImperativeHandle` Hook'
- en: The `useImperativeHandle` Hook can be used to customize instance values that
    are exposed to other components when pointing a `ref` to it. Doing this should
    be avoided as much as possible, however, as it tightly couples components together,
    which harms reusability.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`useImperativeHandle` Hook 可以用于自定义向其他组件暴露的实例值，当将 `ref` 指向它时。然而，应尽量避免这样做，因为它会紧密耦合组件，从而损害可重用性。'
- en: 'The `useImperativeHandle` Hook has the following signature:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`useImperativeHandle` Hook 的签名如下：'
- en: '[PRE130]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We can use this Hook to, for example, expose a `focus` function that other
    components can trigger via a `ref` to the component. This Hook should be used
    in combination with `forwardRef` as follows:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个 Hook，例如暴露一个 `focus` 函数，其他组件可以通过对组件的 `ref` 触发。这个 Hook 应该与 `forwardRef`
    结合使用，如下所示：
- en: '[PRE131]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Then, we can access the `focus` function as follows:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按如下方式访问 `focus` 函数：
- en: '[PRE132]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: As we can see, using refs means that we can directly access elements and components.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用 refs 意味着我们可以直接访问元素和组件。
- en: The useLayoutEffect Hook
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useLayoutEffect` Hook'
- en: The `useLayoutEffect` Hook is identical to the `useEffect` Hook, but it fires
    synchronously after all DOM mutations are completed and before the component is
    rendered in the browser. It can be used to read information from the DOM and adjust
    the appearance of components before rendering. Updates inside this Hook will be
    processed synchronously before the browser renders the component.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLayoutEffect` Hook 与 `useEffect` Hook 相同，但在所有 DOM 变化完成后同步触发，并在组件在浏览器中渲染之前。它可以用于在渲染之前从
    DOM 中读取信息并调整组件的外观。此 Hook 中的更新将在浏览器渲染组件之前同步处理。'
- en: Do not use this Hook unless it is really needed, which is only in certain edge
    cases. `useLayoutEffect` will block visual updates in the browser, and thus, is
    slower than `useEffect`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 除非真的需要，否则不要使用这个 Hook，这只在某些边缘情况下才需要。`useLayoutEffect` 会阻止浏览器的视觉更新，因此比 `useEffect`
    更慢。
- en: The rule here is to use `useEffect` first. If your mutation changes the appearance
    of the DOM node, which can cause it to flicker, you should use `useLayoutEffect`
    instead.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的规则是首先使用 `useEffect`。如果您的变化会改变 DOM 节点的外观，可能会导致闪烁，那么应该使用 `useLayoutEffect`。
- en: The useDebugValue Hook
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useDebugValue` Hook'
- en: The `useDebugValue` Hook is useful for developing custom Hooks that are part
    of shared libraries. It can be used to show certain values for debugging in React
    DevTools.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDebugValue` Hook 对于开发共享库中的自定义 Hook 非常有用。它可以用于在 React DevTools 中显示调试的特定值。'
- en: 'For example, in our `useDebouncedUndo` custom Hook, we could do the following:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的 `useDebouncedUndo` 自定义 Hook 中，我们可以这样做：
- en: '[PRE133]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Adding these `useDebugValue` Hooks will show the following in the React DevTools:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些`useDebugValue` Hook将在React DevTools中显示以下内容：
- en: 'When the Hook is initialized: DebouncedUndo: init'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Hook初始化时：DebouncedUndo：初始化
- en: 'When a value was entered: DebouncedUndo: waiting 200 ms'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当输入值时：DebouncedUndo：等待200毫秒
- en: 'After debouncing (after `200` ms): DebouncedUndo: added to history'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防抖后（`200`毫秒后）：DebouncedUndo：添加到历史记录
- en: Summary
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first learned how to extract custom Hooks from existing
    code in our blog app. We extracted various Context Hooks into custom Hooks, then
    created API Hooks and a more advanced Hook for debounced undo functionality. Next, we
    learned about interactions between Hooks and how we can use values from other
    Hooks in custom Hooks. We then created local Hooks for our blog app. Then, we
    learned about testing various Hooks with Jest and the React Hooks Testing Library.
    Finally, we learned about all the Hooks provided by the React Hooks API, at the
    time of writing.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何从我们的博客应用程序中的现有代码中提取自定义Hooks。我们将各种上下文Hooks提取为自定义Hooks，然后创建API Hooks和用于防抖撤消功能的更高级的Hook。接下来，我们了解了Hooks之间的交互以及如何在自定义Hooks中使用其他Hooks的值。然后，我们为我们的博客应用程序创建了本地Hooks。然后，我们学习了如何使用Jest和React
    Hooks测试库测试各种Hooks。最后，我们了解了在撰写时由React Hooks API提供的所有Hooks。
- en: Knowing when and how to extract custom Hooks is a very important skill in React
    development. In a larger project, we are probably going to define many custom
    Hooks, specifically tailored to our project's needs. Custom Hooks can also make
    it easier to maintain our application, as we only need to adjust functionality
    in one place. Testing custom Hooks is very important, because if we refactor our
    custom Hooks later on, we want to make sure that they still work properly. Now
    that we know the full React Hooks API, we can make use of all the Hooks that React
    provides to create our own custom Hooks.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 知道何时以及如何从现有代码中提取自定义Hooks是React开发中非常重要的技能。在一个更大的项目中，我们可能会定义许多特定于项目需求的自定义Hooks。自定义Hooks还可以使我们更容易地维护我们的应用程序，因为我们只需要在一个地方调整功能。测试自定义Hooks非常重要，因为如果以后重构我们的自定义Hooks，我们希望确保它们仍然正常工作。现在我们知道了完整的React
    Hooks API，我们可以利用React提供的所有Hooks来创建我们自己的自定义Hooks。
- en: In the next chapter, we are going to learn how to migrate from React class components
    to a Hook-based system. We will first create a small project using class components
    and then we will replace them with function components using Hooks, taking a closer
    look at the differences between the two solutions.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何从React类组件迁移到基于Hook的系统。我们将首先使用类组件创建一个小项目，然后我们将用Hook替换它们，仔细研究两种解决方案之间的差异。
- en: Questions
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try answering the following
    questions:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们在本章学到的内容，试着回答以下问题：
- en: How can we extract a custom Hook from existing code?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从现有代码中提取自定义Hook？
- en: What is the advantage of creating API Hooks?
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建API Hooks的优势是什么？
- en: When should we extract functionality into a custom Hook?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该将功能提取为自定义Hook？
- en: How do we use custom Hooks?
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用自定义Hooks？
- en: When should we create local Hooks?
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该创建本地Hooks？
- en: Which interactions between Hooks are possible?
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些钩子之间的交互是可能的？
- en: Which library can we use to test Hooks?
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个库来测试Hooks？
- en: How can we test Hook actions?
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试Hook动作？
- en: How can we test contexts?
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试上下文？
- en: How can we test asynchronous code?
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试异步代码？
- en: Further reading
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts we learned in
    this chapter, take a look at the following reading material:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章学到的概念更多信息感兴趣，请查看以下阅读材料：
- en: Creating custom Hooks: [https://reactjs.org/docs/hooks-custom.html](https://reactjs.org/docs/hooks-custom.html)
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 Hooks：[https://reactjs.org/docs/hooks-custom.html](https://reactjs.org/docs/hooks-custom.html)
- en: React Hooks Testing Library: [https://react-hooks-testing-library.com/](https://react-hooks-testing-library.com/)
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks 测试库：[https://react-hooks-testing-library.com/](https://react-hooks-testing-library.com/)
- en: React Testing Librar*y* (for testing components): [https://testing-library.com/react](https://testing-library.com/react)
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Testing Library（用于测试组件）：[https://testing-library.com/react](https://testing-library.com/react)
- en: React Hooks API Reference: [https://reactjs.org/docs/hooks-reference.html](https://reactjs.org/docs/hooks-reference.html)
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks API 参考：[https://reactjs.org/docs/hooks-reference.html](https://reactjs.org/docs/hooks-reference.html)
- en: When to use `useCallback`: [https://kentcdodds.com/blog/usememo-and-usecallback](https://kentcdodds.com/blog/usememo-and-usecallback)
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useCallback`的时机：[https://kentcdodds.com/blog/usememo-and-usecallback](https://kentcdodds.com/blog/usememo-and-usecallback)
