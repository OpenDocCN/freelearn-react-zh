- en: Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: Most of the most successful apps on the app stores are games. They proved to
    be really popular as mobile users tend to play all sort of games while commuting,
    in waiting rooms, when traveling, or even when relaxing at home. It is a fact
    that mobile users are more inclined to pay for a game than for any other kind
    of app in the market as the perceived value is higher most of the time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用商店上大多数成功的应用都是游戏。它们被证明非常受欢迎，因为移动用户倾向于在通勤、候诊室、旅行或者在家休息时玩各种游戏。事实上，移动用户更倾向于为游戏付费，而不是市场上其他任何类型的应用，因为大多数时候其感知价值更高。
- en: Modern games are usually built in powerful gaming engines such as Unity or Unreal,
    as they provide a wide range of tools and frameworks to work with sprites, animations,
    or physics. But the reality is that great games can also be built in React Native
    due to its native capabilities. Moreover, React Native has introduced many web
    and mobile app programmers into game development as it offers them a familiar
    and intuitive interface. Of course, there are some concepts in game development
    which need to be understood in order to make the most of the library when building
    games. Concepts like sprites, ticks, or collisions are small hurdles, which may
    need to be overcome by non-game developers before building a game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏通常是使用强大的游戏引擎构建的，如Unity或Unreal，因为它们提供了各种工具和框架来处理精灵、动画或物理效果。但事实是，由于其本地功能，伟大的游戏也可以在React
    Native中构建。此外，React Native已经将许多网络和移动应用程序程序员引入游戏开发，因为它为他们提供了熟悉和直观的界面。当然，在构建游戏时，非游戏开发人员可能需要理解一些游戏开发的概念，以充分利用该库。像精灵、滴答声或碰撞这样的概念是小障碍，非游戏开发人员在构建游戏之前可能需要克服这些障碍。
- en: The game will be built for both iOS and Android, and will use a limited number
    of external libraries. Redux, the state management library, was chosen to help
    calculate the position of every sprite on each frame.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将为iOS和Android构建，并将使用有限数量的外部库。选择了Redux作为状态管理库，以帮助计算每一帧上每个精灵的位置。
- en: We will use some custom sprites and add a sound effect to notice each time the
    score is increased. One of the main challenges when building a game is making
    sure the sprites are rendered responsively, so different devices will show the
    game with the same proportions providing the same game experience across different
    screen sizes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些自定义精灵，并添加声音效果以提醒每次得分增加。构建游戏时的一个主要挑战是确保精灵能够响应式地呈现，以便不同的设备以相同的比例显示游戏，提供不同屏幕尺寸下相同的游戏体验。
- en: This game will be designed to be played in portrait mode only.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏将设计为仅支持竖屏模式。
- en: Overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The game we will build in this chapter has simple mechanics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将构建的游戏具有简单的机制：
- en: The goal is to help a parrot fly between rocks in a cave
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是帮助一只鹦鹉在洞穴中的岩石之间飞行
- en: Tapping the screen will result in the parrot flying higher
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击屏幕将使鹦鹉飞得更高
- en: Gravity will pull the parrot toward the ground
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力将把鹦鹉拉向地面
- en: Any collision between the parrot and the rocks or the ground will result in
    the end of the game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鹦鹉与岩石或地面的任何碰撞都将导致游戏结束
- en: The score will be increased every time the parrot flies through a group of rocks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次鹦鹉飞过一组岩石时，得分都会增加。
- en: This kind of game is very well suited to being built with React Native, as it
    doesn't really need complex animations or physics capabilities. All we need to
    be sure of is that we move every sprite (graphics component) on the screen at
    the correct time to create the feeling of continuous animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种游戏非常适合使用React Native构建，因为它实际上不需要复杂的动画或物理能力。我们需要确保在正确的时间移动屏幕上的每个精灵（图形组件），以创建连续动画的感觉。
- en: 'Let''s take a look at the initial screen for our game:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们游戏的初始界面：
- en: '![](Images/e02842e8-cc74-4308-9aab-c75b96a87892.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e02842e8-cc74-4308-9aab-c75b96a87892.png)'
- en: This screen presents the logo and instructions about how to get the game started.
    In this case, a simple tap will start up the game mechanics causing the parrot
    to fly forward and up on every tap.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕展示了关于如何启动游戏的标志和说明。在这种情况下，简单的点击将启动游戏机制，导致鹦鹉在每次点击时向前飞行和上升。
- en: '![](Images/0f067129-8ea5-4aa1-bf40-b6ae50c442ce.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0f067129-8ea5-4aa1-bf40-b6ae50c442ce.png)'
- en: The player must help our parrot to fly through the rocks. Each time a set of
    rocks is passed, the player will get one point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家必须帮助我们的鹦鹉飞过岩石。每次通过一组岩石，玩家将获得一个点。
- en: '![](Images/34214fa0-b1d3-4e49-9193-2d2793c3f915.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/34214fa0-b1d3-4e49-9193-2d2793c3f915.png)'
- en: 'To make it more difficult, the heights of the rocks will vary forcing the parrot
    to fly higher or lower to pass through the rocks. If the parrot collides with
    a rock or the ground, the game will stop and the final score will be presented
    to the user:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加难度，岩石的高度将会变化，迫使鹦鹉飞得更高或更低来穿过岩石。如果鹦鹉与岩石或地面发生碰撞，游戏将停止，并向用户呈现最终得分：
- en: '![](Images/3d17458e-24d5-4459-ac8b-b5a80d5e838d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3d17458e-24d5-4459-ac8b-b5a80d5e838d.png)'
- en: At this point, the user will be able to restart the game by tapping again on
    the screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，用户可以通过再次点击屏幕来重新开始游戏。
- en: 'To make it nicer and easier to play, tapping can be done anywhere on the screen,
    causing a different effect depending on which screen the user is on:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏更加美观和易于玩，可以在屏幕的任何位置进行点击，这将导致不同的效果，取决于用户所在的屏幕：
- en: On the initial screen tapping will start up the game
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始屏幕上点击将启动游戏
- en: In-game tapping will result in the parrot flying higher
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的点击会导致鹦鹉飞得更高
- en: On the GAME OVER screen tapping will restart the game and reset the score
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏结束屏幕上点击将重新开始游戏并重置得分
- en: As can be observed, it will be a very simple game but, due to this, easily extendable
    and fun to play. One import aspect when building this kind of app is counting
    with a nice set of graphics. For this matter, we will download our assets from
    one of the multiple game assets markets, which can be found online (most game
    assets cost a small amount of money although free assets can be found every now
    and then).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，这将是一个非常简单的游戏，但由于这个原因，它很容易扩展并且很有趣。在构建这种类型的应用程序时一个重要的方面是拥有一套漂亮的图形。为此，我们将从多个游戏资产市场之一下载我们的资产，这些市场可以在线找到（大多数游戏资产需要支付一小笔费用，尽管偶尔也可以找到免费资产）。
- en: 'The technical challenges for this game lie more in how the sprites will be
    moved over time than on a complex state to be maintained. Despite this, we will
    use Redux to keep and update the app''s state as it is a performant and well-known
    solution. Besides revisiting Redux, we will review the following topics in this
    chapter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的技术挑战更多地在于精灵如何随时间移动，而不是复杂的状态维护。尽管如此，我们将使用Redux来保持和更新应用程序的状态，因为它是一个高效且广为人知的解决方案。除了重新审视Redux，我们还将在本章中回顾以下主题：
- en: Handling animated sprites
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理动画精灵
- en: Playing sound effects
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音效
- en: Detecting colliding sprites
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞的精灵
- en: Absolute positioning in different screen resolutions
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的屏幕分辨率下进行绝对定位
- en: Sprites
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵
- en: Sprites are the graphics used by the games, normally grouped into one or several
    images. Many game engines include tools to split and manage those graphics in
    a convenient way, but this is not the case in React Native. Since it was designed
    with a different kind of app having in mind, there are several libraries supporting
    React Native in the task of dealing with sprites, but our game will be simple
    enough not to need any of these libraries, so we will store one graphic in each
    image and we will load them separately into the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是游戏中使用的图形，通常分组到一个或多个图像中。许多游戏引擎包括工具来方便地拆分和管理这些图形，但在React Native中并非如此。由于它是设计用来处理不同类型的应用程序的，有几个库支持React
    Native处理精灵的任务，但我们的游戏将足够简单，不需要使用这些库，因此我们将把一个图形存储在每个图像中，并将它们分别加载到应用程序中。
- en: Before starting to build the game, let's get acquainted with the graphics we
    will load, as they will be the building blocks for the whole app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建游戏之前，让我们熟悉一下我们将加载的图形，因为它们将是整个应用程序的构建模块。
- en: Numbers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Instead of using a `<Text/>` component to display the score in our game, we
    will use sprites for a more attractive look. These are the images we will use
    to represent the user''s score:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将使用精灵而不是`<Text/>`组件来显示分数，以获得更吸引人的外观。这些是我们将用来表示用户分数的图像：
- en: '![](Images/a4b3c3b6-9401-4598-92cf-6258b365e038.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a4b3c3b6-9401-4598-92cf-6258b365e038.png)'
- en: As mentioned, all these graphics will be stored in separate images (named `0.png`
    to `9.png`) due to React Native's lack of sprite splitting capabilities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，所有这些图形都将存储在单独的图像中（命名为`0.png`到`9.png`），因为React Native缺乏精灵拆分功能。
- en: Background
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: 'We need a large background to make sure it will fit all screen sizes. In this
    chapter, we will use this sprite as a static graphic although it could be easily
    animated to create a nice parallax effect:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个大背景来确保它适合所有屏幕尺寸。在本章中，我们将使用这个精灵作为静态图形，尽管它可以很容易地进行动画处理，以创建一个漂亮的视差效果：
- en: '![](Images/ea0309e9-e825-4ed4-b2b9-dca9c49e0d2b.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ea0309e9-e825-4ed4-b2b9-dca9c49e0d2b.png)'
- en: From this background, we will take a piece of ground to animate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个背景中，我们将取一块地面来进行动画。
- en: Ground
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地面
- en: 'The ground will be animated in a loop to create a constant feeling of velocity.
    The size of this image needs to be larger than the maximum screen resolution we
    want to support, as it should be moved from one side of the screen to the opposite.
    At all times, two ground images will be displayed, one after the other to ensure
    at least one of them is shown on the screen during the animation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 地面将在循环中进行动画，以创建恒定的速度感。这个图像的大小需要大于我们想要支持的最大屏幕分辨率，因为它应该从屏幕的一侧移动到另一侧。在任何时候，将显示两个地面图像，一个接一个地显示，以确保在动画期间屏幕上至少显示一个地面图像：
- en: '![](Images/9773a4e8-6b80-45ce-896f-1fa3223c7bd1.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9773a4e8-6b80-45ce-896f-1fa3223c7bd1.png)'
- en: Rocks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 岩石
- en: 'The moving rocks are the obstacles our parrot needs to pass. There will be
    one on the top and one on the bottom and both will be animated at the same speed
    as the ground. Their height will vary for each pair of rocks but always keep the
    same gap size between them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 移动的岩石是我们的鹦鹉需要通过的障碍物。顶部和底部各有一个，它们将以与地面相同的速度进行动画。它们的高度将因每对岩石而异，但始终保持它们之间的间隙大小相同：
- en: '![](Images/14ada555-940f-4784-b6bd-c64293c6a71e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14ada555-940f-4784-b6bd-c64293c6a71e.png)'
- en: In our `images` folder, we will have `rock-up.png` and `rock-down.png` representing
    each sprite.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`images`文件夹中，我们将有`rock-up.png`和`rock-down.png`代表每个精灵。
- en: Parrot
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鹦鹉
- en: 'We will use two different images for our main character so we can create an
    animation displaying when the user has tapped on the screen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个不同的图像来表示我们的主角，这样我们就可以创建一个动画，显示用户何时点击了屏幕：
- en: '![](Images/8fe0a165-06a5-4651-b25e-94b6504f6e7d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8fe0a165-06a5-4651-b25e-94b6504f6e7d.png)'
- en: 'The first image will be displayed when the parrot is moving down:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当鹦鹉向下移动时将显示第一个图像：
- en: '![](Images/429db942-21e6-47aa-a0ce-9526be5d197b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/429db942-21e6-47aa-a0ce-9526be5d197b.png)'
- en: This second image will be shown every time the user presses the screen to move
    the parrot up. The images will be named `parrot1.png` and `parrot2.png`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户按下屏幕将鹦鹉向上移动时，将显示第二个图像。这些图像将被命名为`parrot1.png`和`parrot2.png`。
- en: The home screen
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主屏幕
- en: 'For the home screen, we will display two images: a logo and some instructions
    about how to get the game started. Let''s take a look at them:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主屏幕，我们将显示两个图像：一个标志和一些关于如何启动游戏的说明。让我们来看看它们：
- en: '![](Images/f875566d-ed37-4c3d-9f3b-4779633df307.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f875566d-ed37-4c3d-9f3b-4779633df307.png)'
- en: 'The instructions to start the game just point out that tapping will get the
    game started:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏的说明只是指出轻触将启动游戏：
- en: '![](Images/65f44b23-5417-41dc-b0d6-af7015d73514.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/65f44b23-5417-41dc-b0d6-af7015d73514.png)'
- en: Game over screen
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束屏幕
- en: 'When the parrot hits a rock or the ground, the game will end. Then, it is time
    to display a game over sign and a reset button to get the game started again:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当鹦鹉撞到岩石或地面时，游戏将结束。然后，是时候显示游戏结束标志和重置按钮，以便重新开始游戏：
- en: '![](Images/eb3473f1-4660-4946-87ec-899721e994b1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/eb3473f1-4660-4946-87ec-899721e994b1.png)'
- en: 'Although the entire screen will be touchable to get the game restarted, we
    will include a button to let the user know that tapping will result in the game
    restarting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然整个屏幕都可以触摸以重新启动游戏，但我们将包括一个按钮，让用户知道轻触将导致游戏重新开始：
- en: '![](Images/fb112db6-1a86-49e3-91f5-6a6a75dc9f41.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fb112db6-1a86-49e3-91f5-6a6a75dc9f41.png)'
- en: This image will be stored as `reset.png`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像将存储为`reset.png`。
- en: 'This is the full list of images we will have in our game:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们游戏中将拥有的所有图像的完整列表：
- en: '![](Images/f599524a-3dca-4f3e-8b33-b01dc5350125.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f599524a-3dca-4f3e-8b33-b01dc5350125.png)'
- en: Now, we know the list of images we will use in our game. Let's take a look at
    the whole folder structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了我们游戏中将使用的图像列表。让我们来看看整个文件夹结构。
- en: Setting up the folder structure
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `birdGame` and will be available for iOS and Android devices:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用React Native的CLI初始化一个React Native项目。 该项目将被命名为`birdGame`，并将适用于iOS和Android设备：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As this one is a simple game, we will only need one screen in which we will
    position all our sprites moving, showing, or hiding them depending on the state
    of the game, which will be managed by Redux. Therefore, our folder structure will
    be in line the standard Redux apps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单的游戏，我们只需要一个屏幕，我们将在其中根据游戏的状态定位所有我们的精灵移动，显示或隐藏它们，这将由Redux管理。因此，我们的文件夹结构将符合标准的Redux应用程序：
- en: '![](Images/4344e82a-4c61-49c2-8a38-b60204aa380c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4344e82a-4c61-49c2-8a38-b60204aa380c.png)'
- en: 'The `actions` folder will only contain one file as there are only three actions
    which may happen in this game *(*`start`*,* `tick`, and `bounce`). There is also
    a `sounds` folder to store the sound effect which will be played every time the
    parrot passes a pair of rocks:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions`文件夹将只包含一个文件，因为在这个游戏中可能发生的只有三个动作（`start`，`tick`和`bounce`）。还有一个`sounds`文件夹，用于存储每次鹦鹉通过一对岩石时播放的音效：'
- en: '![](Images/cb4bcc61-e53b-449b-bb36-bd0058cb52f1.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cb4bcc61-e53b-449b-bb36-bd0058cb52f1.png)'
- en: 'For each sprite, we will create a component so we can move it, show it, or
    hide it easily:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个精灵，我们将创建一个组件，以便可以轻松地移动，显示或隐藏它：
- en: '![](Images/57d92596-94cb-476f-8b6f-4f3c85497912.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/57d92596-94cb-476f-8b6f-4f3c85497912.png)'
- en: 'Again, only one reducer will be needed to process all our actions. We will
    also create two helper files:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，只需要一个reducer来处理所有我们的动作。我们还将创建两个辅助文件：
- en: '`constants.js`: This is where we will store helper variables for dividing the
    height and the width of the screen for the device playing the game'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constants.js`：这是我们将存储用于将屏幕高度和宽度分割为设备播放游戏的辅助变量的地方'
- en: '`sprites.js`: This stores all the functions which will calculate how the sprites
    should be positioned in each frame to create the required animations'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sprites.js`：这里存储了所有将计算每帧中精灵应该定位的函数，以创建所需的动画'
- en: '`main.js` will serve as the entry point for both iOS and Android and will be
    responsible to initialize Redux:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`将作为iOS和Android的入口点，并负责初始化Redux：'
- en: '![](Images/2f0f33c2-b2e6-4a59-b980-9e7e907e0a61.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2f0f33c2-b2e6-4a59-b980-9e7e907e0a61.png)'
- en: The rest of the files are generated by React Native's CLI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其余文件由React Native的CLI生成。
- en: 'Let''s now review the `package.json` file we will need to set the dependencies
    up in our project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来审查一下`package.json`文件，我们需要在项目中设置依赖项：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apart from Redux libraries, we will import `react-native-sound`, which will
    be in charge of playing any sounds in our game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Redux库，我们还将导入`react-native-sound`，它将负责在我们的游戏中播放任何声音。
- en: 'After running `npm install`, we will have our app ready to start coding. As
    happened in previous apps, the entry point for our messaging app will be the same
    code both in  `index.ios.js` for iOS and in `index.android.js` for Android, but
    both will delegate the initialisation logic to `src/main.js`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install`后，我们的应用程序将准备好开始编码。与以前的应用程序一样，我们的消息应用程序的入口点将在`index.ios.js`（iOS）和`index.android.js`（Android）中是相同的代码，但两者都将把初始化逻辑委托给`src/main.js`：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`src/main.js` is responsible for initializing Redux and will set `GameContainer`
    as the root component in our app:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main.js`负责初始化Redux，并将`GameContainer`设置为应用程序中的根组件：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use `GameContainer` as the root of the component tree in our app. As a regular
    Redux app, a `<Provider />` component is in charge of supplying the store to all
    the components which require reading or modifying the application state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`GameContainer`用作应用程序中组件树的根。作为一个常规的Redux应用程序，`<Provider />`组件负责向所有需要读取或修改应用程序状态的组件提供存储。
- en: GameContainer
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameContainer
- en: '`GameContainer` is responsible for starting up the game once the user taps
    the screen. It will do this using `requestAnimationFrame()`--one of the custom
    timers implemented in React Native.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameContainer`负责在用户点击屏幕时启动游戏。它将使用`requestAnimationFrame()`来实现这一点——这是React
    Native中实现的自定义定时器之一。'
- en: '`requestAnimationFrame()` is similar to `setTimeout()`, but the former will
    fire after all the frame has flushed, whereas the latter will fire as quickly
    as possible (over 1000x per second on a iPhone 5S); therefore, `requestAnimationFrame()`
    is more suited for animated games as it deals only with frames.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame()`类似于`setTimeout()`，但前者将在所有帧刷新后触发，而后者将尽可能快地触发（在iPhone
    5S上每秒超过1000次）；因此，`requestAnimationFrame()`更适合处理动画游戏，因为它只处理帧。'
- en: 'As happens with most animated games, we need to create a loop to animate the
    sprites in the screen by calculating the next position of each element on each
    frame. This loop will be created by a function named `nextFrame()` inside our
    `GameContainer`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数动画游戏一样，我们需要创建一个循环来计算屏幕上精灵的下一个位置，以便在每一帧中创建所需的动画。这个循环将由`GameContainer`内部的一个名为`nextFrame()`的函数创建：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function will be aborted if the property `gameOver` is set to `true`. Otherwise,
    it will trigger the action `tick()` (which calculates how the sprites should be
    moved on to the next frame, based on the elapsed time) and finally calls itself
    through `requestAnimationFrame()`. This will keep the loop in the game to animate
    the moving sprites.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性`gameOver`设置为`true`，则此函数将被中止。否则，它将触发`tick()`动作（根据经过的时间计算精灵应该在下一帧上移动的位置），最后通过`requestAnimationFrame()`调用自身。这将保持游戏中的循环以动画方式移动精灵。
- en: 'Of course, this `nextFrame()` should be called at the start for the first time,
    so we will also create a `start()` function inside `GameContainer` to get the
    game started:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个`nextFrame()`应该在开始时被调用，所以我们还将在`GameContainer`内创建一个`start()`函数来启动游戏：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `start` function makes sure there is no animation started by calling `cancelAnimationFrame()`.
    This will prevent any double animations being performed when the user resets the
    game.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`函数通过调用`cancelAnimationFrame()`确保没有启动任何动画。这将防止用户重置游戏时执行任何双重动画。'
- en: Then, the functions trigger the `start()` action, which will just set a flag
    in the store to notice the game has started.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些函数触发`start()`动作，它只是在存储中设置一个标志，以通知游戏已经开始。
- en: We want to start the game by moving the parrot up, so the user has the time
    to react. For this, we also call the `bounce()` action.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过将鹦鹉向上移动来开始游戏，以便用户有时间做出反应。为此，我们还调用`bounce()`动作。
- en: Finally, we start the animation loop by passing the already known `nextFrame()` function
    as a callback of `requestAnimationFrame()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将已知的`nextFrame()`函数作为`requestAnimationFrame()`的回调来启动动画循环。
- en: 'Let''s also review the `render()` method we will use for this container:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来审查一下我们将用于这个容器的`render()`方法：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It may be lengthy, but actually, it's a simple positioning of all the visible
    elements on the screen while wrapping them in a `<TouchableOpacity />` component
    to capture the user tapping no matter in which part of the screen. This `<TouchableOpacity
    />` component is actually not sending any feedback to the user when they tap the
    screen (we disabled it by passing `activeOpacity={1}` as a prop) since this feedback
    is already provided by the parrot bouncing on each tap.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有些冗长，但实际上只是将所有可见元素在屏幕上进行简单的定位，同时将它们包裹在`<TouchableOpacity />`组件中，以便捕捉用户在屏幕的任何部分的点击。这个`<TouchableOpacity
    />`组件实际上在用户点击屏幕时不会向用户发送任何反馈（我们通过传递`activeOpacity={1}`作为属性来禁用它），因为鹦鹉在每次点击时已经提供了这种反馈。
- en: We could have used React Native's `<TouchableWithoutFeedback />` for this matter,
    but it has several limitations which would have harmed our performance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用React Native的`<TouchableWithoutFeedback />`来处理这个问题，但它有一些限制，可能会影响我们的性能。
- en: 'The provided `onPress` attribute just defines what the app should do when the
    user taps on the screen:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`onPress`属性只是定义了用户在屏幕上点击时应用程序应该执行的操作：
- en: If the game is active, it will bounce the parrot sprite
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果游戏处于活动状态，它将使鹦鹉精灵弹跳
- en: If the user is on the game over screen it will restart the game by calling the
    `start()` action
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在游戏结束画面，将通过调用`start()`动作重新开始游戏
- en: 'All other children in the `render()` method are the graphic elements in our
    game, specifying for each of them, their position and size. It''s also important
    to note several points:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`方法中的所有其他子元素都是我们游戏中的图形元素，为它们指定位置和大小。还有几点需要注意：'
- en: There are two `<Ground />` components because we need to continuously animate
    it in the *x *axis. They will be positioned one after the other horizontally to
    animate them together so when the end of the first `<Ground />` component is shown
    on screen, the beginning of the second will follow creating the sense of continuum.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个`<Ground />`组件，因为我们需要在*x*轴上不断地对其进行动画处理。它们将水平排列在一起，以便一起进行动画处理，因此当第一个`<Ground
    />`组件的末端显示在屏幕上时，第二个的开头将跟随其后，从而产生连续感。
- en: The background is not contained in any custom component but in `<Image />`.
    This is because it doesn't need any special logic being a static element.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景不包含在任何自定义组件中，而是包含在`<Image />`中。这是因为作为静态元素，它不需要任何特殊的逻辑。
- en: Some positions are multiplied by factor variables (`W` and `H`). We will take
    a deeper look at these variables in the constants section. At this point, we only
    need to know that they are variables helping in the absolute positioning of the
    elements taking into account all screen sizes.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些位置被因子变量（`W`和`H`）相乘。我们将在常量部分更深入地研究这些变量。在这一点上，我们只需要知道它们是帮助绝对定位元素的变量，考虑到所有屏幕尺寸。
- en: 'Let''s now put all these functions together to build up our `<GameContainer
    />`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将所有这些函数组合起来构建我们的`<GameContainer />`：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We added three more ES6 and React lifecycle methods to this component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个组件中添加了三个ES6和React生命周期方法：
- en: '`super()`: The constructor will save an attribute named `animationFrameId`
    to capture the ID for the animation frame in which the `nextFrame` function will
    run and also another attribute named `time` will store the exact time at which
    the game was initialized. This `time` attribute will be used by the `tick()` function
    to calculate how much the sprites should be moved.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super()`: 构造函数将保存一个名为`animationFrameId`的属性，以捕获`nextFrame`函数将运行的动画帧的ID，还将保存另一个名为`time`的属性，该属性将存储游戏初始化的确切时间。这个`time`属性将被`tick()`函数用来计算精灵应该移动多少。'
- en: '`componentWillUpdate()`: This function will be called every time new props
    (positions and sizes for the sprites in the game) are passed. It will detect when
    the game must be stopped due to a collision so the game over screen will be displayed.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate()`: 每当传递新的props（游戏中精灵的位置和大小）时，将调用此函数。它将检测游戏是否因碰撞而必须停止，因此游戏结束屏幕将被显示。'
- en: '`shouldComponentUpdate()`: This performs another check to avoid re-rendering
    the game container if the game has ended.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate()`: 如果游戏已经结束，这将执行另一个检查以避免重新渲染游戏容器。'
- en: 'The rest of the functions are Redux related. They are in charge of connecting
    the component to the store by injecting actions and attributes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的函数与Redux相关。它们负责通过注入操作和属性将组件连接到存储中：
- en: '`mapStateToProps()`: This gets the data for all the sprites in the store and
    injects them into the component as props. The sprites will be stored in an array
    and therefore they will be accessed by index. On top of these, the `Score`, a
    flag noting if the current game is over, and a flag noting if the game is in progress
    will also be retrieved from the state and injected into the component.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapStateToProps()`: 这会获取存储中所有精灵的数据，并将它们注入到组件中作为props。精灵将被存储在一个数组中，因此它们将通过索引访问。除此之外，`Score`，标记当前游戏是否结束的标志，以及标记游戏是否正在进行的标志也将从状态中检索并注入到组件中。'
- en: '`mapStateActionsToProps()`: This will inject the three available actions (`tick`,
    `bounce`, and `start`) into the component so they can be used by it.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapStateActionsToProps()`: 这将把三个可用的操作（`tick`，`bounce`和`start`）注入到组件中，以便它们可以被使用。'
- en: Accessing the sprites data by index is not a recommended practice as indexes
    can change if the number of sprites grows, but we will use it like this in this
    app for simplicity reasons.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引访问精灵数据并不是一种推荐的做法，因为如果精灵数量增加，索引可能会改变，但出于简单起见，我们将在此应用程序中这样使用。
- en: Actions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: 'As we mentioned before, only three Redux actions will be available:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，只有三个Redux操作可用：
- en: '`tick()`: To calculate the next position of the sprites on the screen'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tick()`: 计算屏幕上精灵的下一个位置'
- en: '`bounce()`: To make the parrot fly up'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bounce()`: 让鹦鹉飞起来'
- en: '`start()`: To initialize the game variables'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`: 初始化游戏变量'
- en: 'This means our `src/actions/index.js` file should be very simple:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`src/actions/index.js`文件应该非常简单：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Only the `tick()` action needs to pass a payload: the time it passed since
    the last frame.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`tick()`操作需要传递一个有效负载：自上一帧以来经过的时间。
- en: Reducer
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducer
- en: 'Since we have a very limited amount of actions, our reducer will also be fairly
    simple and will delegate most of the functionality to the sprites helper functions
    in the `src/sprites.js` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的动作非常有限，我们的reducer也会非常简单，并且将大部分功能委托给`src/sprites.js`文件中的精灵辅助函数：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `start()` function only needs to set the `isStarted` flag to `true`, as
    the initial state will have it set to `false` by default. We will reuse this initial
    state every time the game ends.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()`函数只需要将`isStarted`标志设置为`true`，因为初始状态默认为`false`。我们将在每次游戏结束时重用这个初始状态。'
- en: '`bounce()` will use the `bounceParrot()` function from the sprites module to
    set a new direction for the main character.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`bounce()`将使用精灵模块中的`bounceParrot()`函数来为主角设置新的方向。'
- en: The most important changes will happen when the `tick()` function is triggered,
    as it needs to calculate the positions of all moving elements (through the `moveSprites()`
    function), detect if the parrot has collided with any static elements (through
    the `checkForCollision()` function), and update the score in the store (through
    the `getUpdatedScore()` function).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的变化将发生在`tick()`函数被触发时，因为它需要计算所有移动元素的位置（通过`moveSprites()`函数），检测鹦鹉是否与任何静态元素发生碰撞（通过`checkForCollision()`函数），并在存储中更新得分（通过`getUpdatedScore()`函数）。
- en: As we can see, most of the game's functionality is delegated to the helper functions
    inside the sprites module, so let's take a deeper look into the `src/sprites.js`
    file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，大部分游戏功能都委托给了精灵模块内的辅助函数，因此让我们深入了解一下`src/sprites.js`文件。
- en: The sprites module
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵模块
- en: 'The structure of the sprites module is formed by an array of sprites and several
    exported functions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵模块的结构由一个精灵数组和几个导出函数组成：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This module begins by loading the sound effect we will play when the parrot
    passes a set of rocks to give feedback to the user about the increment in their
    score.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块首先加载我们在鹦鹉通过一组岩石时将播放的音效，以向用户反馈其得分增加。
- en: 'Then, we define some heights for several sprites:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为几个精灵定义一些高度：
- en: '`heightOfRockUp`: This is the height of the rock which will appear in the upper
    part of the screen.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfRockUp`：这是将出现在屏幕上部的岩石的高度。'
- en: '`heightOfRockDown`: This is the height of the rock which will show in the lower
    part of the screen.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfRockDown`：这是将显示在屏幕下部的岩石的高度。'
- en: '`heightOfGap`: We will create an invisible view between the upper and the lower
    rock to detect when the parrot has passed each set of rocks so the score is updated.
    This this gap''s height.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfGap`：我们将在上下岩石之间创建一个不可见的视图，以便检测鹦鹉何时通过每组岩石，从而更新得分。这是缝隙的高度。'
- en: '`heightOfGround`: This is a static value for the height of the ground.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heightOfGround`：这是地面的高度的静态值。'
- en: Each other item in this module plays a role in moving or positioning the sprites
    on the screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块中的每个其他项目都在屏幕上移动或定位精灵。
- en: The sprites array
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵数组
- en: This is the array in charge of storing all the sprite's positions and sizes
    at a given time. Why are we using an array for storing our sprites instead of
    a hash map (Object)? Mainly for extensibility; Although a hash map would make
    our code noticeably more readable, if we want to add new sprites of an existing
    type (as it happens with the `ground` sprite in this app) we would need to use
    artificial keys for each of them despite being the same type. Using an array of
    sprites is a recurrent pattern in game development which allows to decouple the
    implementation from the list of sprites.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是负责在给定时间存储所有精灵位置和大小的数组。为什么我们使用数组来存储精灵而不是哈希映射（对象）？主要是为了可扩展性；虽然哈希映射会使我们的代码更易读，但如果我们想要添加现有类型的新精灵（就像在这个应用程序中的`ground`精灵一样），我们需要为它们每个使用人工键，尽管它们是相同类型的。使用精灵数组是游戏开发中的一种常见模式，它允许将实现与精灵列表解耦。
- en: 'Whenever we want to move a sprite, we will update its position in this array:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要移动一个精灵时，我们将在这个数组中更新它的位置：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The array will store the initial values for positioning and sizing all the moving
    sprites in the game.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数组将存储游戏中所有移动精灵的定位和大小的初始值。
- en: prepareNewRockSizes()
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prepareNewRockSizes()
- en: 'This function randomly calculates the size of the next upper and lower rock
    together with the height of the gap between them:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数随机计算下一个上部和下部岩石的大小以及它们之间间隙的高度：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's important to note that this function only calculates the heights for the
    new set of rocks but doesn't create them. This is just a preparation step.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，此函数仅计算新一组岩石的高度，但不创建它们。这只是一个准备步骤。
- en: getRockProps()
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getRockProps()
- en: 'The helper functions to format the `position` and `size` attributes of a rock
    (or `gap)`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化岩石（或`间隙`）的`位置`和`大小`属性的辅助函数：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: moveSprites()
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: moveSprites()
- en: This is the main function as it calculates the new position for each sprite
    stored in the sprites array. Game development relies in physics to calculate the
    position for each sprite in each frame.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要函数，因为它计算了存储在精灵数组中的每个精灵的新位置。游戏开发依赖于物理学来计算每个帧中每个精灵的位置。
- en: For example, if we want to move an object to the right side of the screen, we
    will need to update its `x` position a number of pixels. The more pixels we add
    to the object's `x` attribute for the next frame, the faster it will move (`sprite.x
    = sprite.x + 5;` moves `sprite` five times faster than `sprite.x = sprite.x +
    1;` ).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要将一个对象移动到屏幕的右侧，我们将需要更新它的`x`位置一定数量的像素。我们为下一帧添加到对象的`x`属性的像素越多，它就移动得越快（`sprite.x
    = sprite.x + 5;`比`sprite.x = sprite.x + 1;`移动得快五倍）。
- en: 'As we can see in the following example, the way we calculate the new position
    for each sprite is based on three factors: the current position of the sprite,
    the time that has passed since the last frame (`elapsedTime`), and the gravity/velocity
    of the sprite (`i.e. sprite.velocity.y + elapsedTime * gravity`).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的例子中所看到的，我们计算每个精灵的新位置的方式基于三个因素：精灵的当前位置，自上一帧以来经过的时间（`elapsedTime`），以及精灵的重力/速度（例如，`sprite.velocity.y
    + elapsedTime * gravity`）。
- en: 'Additionally, we will use the helper function `getRockProps` to get the new
    sizes and positions for the rocks. Let''s take a look at how the `moveSprites`
    function looks like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用辅助函数`getRockProps`来获取岩石的新大小和位置。让我们看一下`moveSprites`函数是什么样子的：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Calculating the next position for a sprite is, most of the time, basic addition
    (or subtraction). Let''s take, for example, how the parrot should move:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 计算精灵的下一个位置，大多数情况下是基本的加法（或减法）。让我们以鹦鹉应该如何移动为例：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The parrot will only move vertically, basing its speed on gravity, so the `x`
    attribute will always stay fixed for it while the `y` attribute will change according
    to the function `sprite.position.y +` `sprite.velocity.y * elapsedTime +` `0.5
    * gravity * elapsedTime * elapsedTime` which, in summary, adds the elapsed time
    and the gravity in different factors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 鹦鹉只会垂直移动，其速度基于重力，因此`x`属性将始终保持固定，而`y`属性将根据函数`sprite.position.y + sprite.velocity.y
    * elapsedTime + 0.5 * gravity * elapsedTime * elapsedTime`进行更改，该函数总结了经过的时间和重力的不同因素。
- en: 'The calculations for how the rocks should move are a little more complex, as
    we need to take into account every time the rocks disappear from the screen (`if
    (sprite.position.x > 0 - sprite.size.width)`). As they have been passed, we need
    to recreate them with different heights (`rockPosition = { x: 100, y: getRockProps(sprite.type).y
    }`).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '岩石的移动计算要复杂一些，因为我们需要考虑每次岩石从屏幕上消失时（`if (sprite.position.x > 0 - sprite.size.width)`）。因为它们已经通过，我们需要以不同的高度重新创建它们（`rockPosition
    = { x: 100, y: getRockProps(sprite.type).y }`）。'
- en: We have the same behavior for the ground, in terms of having to recreate it
    once it abandons the screen completely (`if (sprite.position.x > -97)`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 地面的行为与之相同，需要在完全离开屏幕时重新创建它（`if (sprite.position.x > -97)`）。
- en: bounceParrot()
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bounceParrot()
- en: 'The only task for this function is changing the velocity of the main character,
    so it will fly up reversing the effect of gravity. This function will be called
    whenever the user taps on the screen while the game is started:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的唯一任务是改变主角的速度，使其向上飞行，逆转重力的影响。每当用户在游戏开始时点击屏幕时，将调用此功能：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's a simple operation in which we take the parrot's sprite data from the `sprites`
    array; we change its velocity on the *y* axis to a negative value so that the
    parrot moves upwards.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的操作，我们从`sprites`数组中获取鹦鹉的精灵数据；我们将其在*y*轴上的速度更改为负值，以使鹦鹉向上移动。
- en: checkForCollision()
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: checkForCollision()
- en: '`checkForCollision()` is responsible for identifying if any of the rigid sprites
    have collided with the parrot sprite, so the game can be stopped. It will use
    `hasCollided()` as a supporting function to perform the required calculations
    on each specific sprite:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForCollision()`负责识别任何刚性精灵是否与鹦鹉精灵发生碰撞，以便停止游戏。它将使用`hasCollided()`作为支持函数来执行对每个特定精灵所需的计算：'
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For simplicity, we assume that all sprites have a rectangular shape (even though
    rocks grow thinner towards the end) because the calculation would be a lot more
    complex if we considered different shapes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们假设所有精灵都具有矩形形状（尽管岩石朝末端变得更薄），因为如果考虑不同的形状，计算将会更加复杂。
- en: In summary, `checkForCollision()` is just looping through the `sprites` array
    to find any colliding sprite, `hasCollided()` checks for collisions based on the
    sprite size and position. In just an `if` statement, we compare the boundaries
    of a sprite and the parrot's sprite to see if any of those boundaries are occupying
    the same area of the screen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`checkForCollision()`只是循环遍历`sprites`数组，以查找任何发生碰撞的精灵，`hasCollided()`根据精灵的大小和位置检查碰撞。在一个`if`语句中，我们比较精灵和鹦鹉精灵的边界，以查看是否有任何边界占据了屏幕的相同区域。
- en: getUpdatedScore()
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getUpdatedScore()
- en: 'The last function in the sprites module will check if the score needs to be
    updated based on parrot position relative to the gap position (the gap between
    the upper and the lower rock is also counted as a sprite):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵模块中的最后一个功能将检查得分是否需要根据鹦鹉位置相对于间隙位置（上下岩石之间的间隙也被视为一个精灵）进行更新：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An `if` statement checks if the parrot's position in the *x* axis has surpassed
    the gap (`gapXPosition + gapWidth`). When this happens, we play the sound we created
    in the header of the module (`const coinSound = new sound("coin.wav", sound.MAIN_BUNDLE);`)
    by calling its `play()` method. Moreover, we will increase the `score` variable
    and prepare a new set of rocks to be rendered when the current ones leave the
    screen.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`语句检查鹦鹉在*x*轴上的位置是否超过了间隙（`gapXPosition + gapWidth`）。当这种情况发生时，我们通过调用其`play()`方法来播放模块头部中创建的声音（`const
    coinSound = new sound("coin.wav", sound.MAIN_BUNDLE);`）。此外，我们将增加`score`变量，并在当前的石头离开屏幕时准备渲染新的石头组。
- en: Constants
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'We already saw the variables `W` and `H`. They represent one part of the screen
    if we divided it into 100 parts. Let''s take a look at the `constants.js` file
    to understand this better:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了变量`W`和`H`。它们代表屏幕的一部分，如果我们将其分成100部分。让我们看一下`constants.js`文件，以更好地理解这一点：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`W` can be calculated as the total width of the device''s screen divided by
    `100` units (as percentages are easier to reason about when positioning our sprites).
    The same goes for `H`; it can be calculated by dividing the total height by `100`.
    Using these two constants, we can position and size our sprites relative to the
    size of the screen, so all screen sizes will display the same ratios for positions
    and sizes.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`W`可以通过将设备屏幕的总宽度除以`100`单位来计算（因为百分比在定位我们的精灵时更容易推理）。`H`也是如此；它可以通过将总高度除以`100`来计算。使用这两个常量，我们可以相对于屏幕的大小来定位和调整精灵的大小，因此所有屏幕尺寸将显示相同的位置和大小比例。'
- en: These constants will be used in all the visual components requiring responsive
    capabilities so they will show and move different depending on the screen size.
    This technique will ensure the game is playable even in small screens as the sprites
    will be resized accordingly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量将用于所有需要响应能力的视觉组件，因此它们将根据屏幕大小显示和移动不同。这种技术将确保即使在小屏幕上，游戏也是可玩的，因为精灵将相应地调整大小。
- en: Let's move on now to the components which will be displayed inside the `<GameContainer
    />`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论将显示在`<GameContainer />`内的组件。
- en: Parrot
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鹦鹉
- en: 'The main character will be represented by this component, which will comprise
    of two different images (the same parrot with its wings up and down) driven by
    the `Y` position property passed by `<GameContainer />`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 主角将由这个组件表示，它将由`<GameContainer />`传递的`Y`位置属性驱动的两个不同的图像（翅膀上下的相同鹦鹉）组成：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use a state variable named `wings` to pick which image the parrot will be--when
    it is flying up the image with the wings down will be displayed while the wings
    up will be shown when flying down. The way this will be calculated is based on
    the position of the bird on the *y* axis passed as a property from the container:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`wings`的状态变量来选择鹦鹉将会是哪个图像--当它飞行时，翅膀向下的图像将被显示，而向上飞行时将显示翅膀向上的图像。这将根据从容器传递的鸟在*y*轴上的位置来计算：
- en: If the `Y` position is lower than the previous `Y` position means the bird is
    going down and therefore the wings should be up
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Y`位置低于先前的`Y`位置意味着鸟正在下降，因此翅膀应该向上
- en: If the `Y` position is higher than the previous `Y` position means the bird
    is going up and therefore the wings should be down
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Y`位置高于先前的`Y`位置意味着鸟正在上升，因此翅膀应该向下
- en: The size of the parrot is fixed to `12 * W` both for the `height` and `width`
    as the sprite is a square and we want it to be sized relative to the width of
    each screen device.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 鹦鹉的大小固定为`12 * W`，对于`height`和`width`都是如此，因为精灵是一个正方形，我们希望它相对于每个屏幕设备的宽度进行调整大小。
- en: RockUp and RockDown
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上升和下降
- en: 'The sprites for the rocks have no logic on them and are basically `<Image />`
    components positioned and sized by the parent component. This is the code for `<RockUp
    />` :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 岩石的精灵上没有逻辑，基本上是由父组件定位和调整大小的`<Image />`组件。这是`<RockUp />`的代码：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The height and the width will be calculated by the following formulae: `this.props.width
    * W` and `this.props.height * H`.  This will size the rock relative to the device's
    screen and the provided height and width.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 高度和宽度将由以下公式计算：`this.props.width * W` 和 `this.props.height * H`。这将使岩石相对于设备屏幕和提供的高度和宽度进行调整。
- en: 'The code for `<RockDown />` is quite similar:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`<RockDown />`的代码非常相似：'
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ground
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地面
- en: 'Building the ground component is similar to the rock sprites. An image rendered
    in the proper position and size will be sufficient for this component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 构建地面组件类似于岩石精灵。在适当的位置和大小上渲染的图像将足以满足此组件的需求：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, we will use `H` to relatively positioning the ground image.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用`H`来相对定位地面图像。
- en: Score
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分
- en: 'We decided to use number images to render the score, so we will need to load
    them and pick the appropriate digits depending on the user''s score:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用数字图像来渲染分数，因此我们需要加载它们并根据用户的分数选择适当的数字：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are doing the following in the `render` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`render`方法中做以下操作：
- en: Converting the score to a string
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分数转换为字符串
- en: Converting the string into a list of digits
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为数字列表
- en: Turning this list of digits into a list of images using the supporting `getSource()`
    function
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用支持的`getSource()`函数将数字列表转换为图像列表
- en: One of the limitations in React Native `<Image />` is that its source cannot
    be required as a variable. Hence, we are using this small trick of retrieving
    the source from our `getSource()` method, which actually acquires all the possible
    images and returns the correct one through a `switch`/`case` clause.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: React Native `<Image />`中的一个限制是其源不能作为变量被要求。因此，我们使用这个小技巧从我们的`getSource()`方法中检索源，该方法实际上获取所有可能的图像并通过`switch`/`case`子句返回正确的图像。
- en: Start
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The start screen includes two images:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 开始屏幕包括两个图像：
- en: A logo
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标志
- en: A start button explaining how to start up the game (tapping anywhere on the
    screen)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个开始按钮，解释如何启动游戏（在屏幕上任何地方轻触）
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using our `H` and `W` constants again to ensure the elements are positioned
    in the right place on every device screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用我们的`H`和`W`常量来确保元素在每个设备屏幕上的位置正确。
- en: GameOver
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'When the parrot collides with a rock or the ground, we should display the game
    over screen. This screen only contains two images:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当鹦鹉与岩石或地面发生碰撞时，我们应该显示游戏结束屏幕。这个屏幕只包含两个图像：
- en: A game over sign
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束标志
- en: A button to restart the game
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新开始游戏的按钮
- en: 'Let''s first take a look at the game over sign:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下游戏结束标志：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's move on to the reset the game button.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续重置游戏按钮。
- en: StartAgain
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新开始
- en: 'Actually, the reset button is only a sign as the user will be able to tap not
    only on the button but anywhere on the screen to get the game started. In any
    case, we will position this button properly on every screen using the `H` and
    `W` constants:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，重置按钮只是一个标志，因为用户不仅可以在按钮上轻触，还可以在屏幕上的任何地方开始游戏。无论如何，我们将使用`H`和`W`常量在每个屏幕上正确定位此按钮：
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Games are a very special kind of app. They are based on displaying and moving
    sprites on the screen, depending on the time and the user interaction. That is
    why we spent most of this chapter explaining how we could easily display all the
    images in the most performant way and how to position and size them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏是一种非常特殊的应用程序。它们基于根据时间和用户交互在屏幕上显示和移动精灵。这就是为什么我们在本章大部分时间都在解释如何以最高效的方式轻松显示所有图像以及如何定位和调整它们的大小。
- en: We also reviewed a common trick to position and size sprites relatively to the
    height and width of the device screen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还回顾了一种常见的技巧，相对于设备屏幕的高度和宽度来定位和调整精灵的大小。
- en: Despite not being designed for games specifically, Redux was used to store and
    distribute the sprite's data around the components in our app.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Redux并非专门为游戏设计，但我们在应用程序中使用Redux来存储和分发精灵的数据。
- en: 'At a general level, we proved that React Native can be used to build performant
    games and, although it lacks game-specific tooling, we can produce a very readable
    code which means it should be easy to extend and maintain. In fact, some very
    easy extensions can be created at this stage to make the game more fun and playable:
    increase speed after passing a specific amount of obstacles, reduce or increase
    the gap size, show more than one set of rocks on screen at once, etc.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般水平上，我们证明了React Native可以用来构建高性能的游戏，尽管它缺乏游戏特定的工具，但我们可以生成非常易读的代码，这意味着它应该很容易扩展和维护。事实上，在这个阶段可以创建一些非常简单的扩展，使游戏更有趣和可玩性：在通过一定数量的障碍物后增加速度，减少或增加间隙大小，在屏幕上显示多组岩石等。
- en: 'The next chapter will review the blueprint of a more conventional type of app:
    an e-commerce app.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将回顾更常规类型应用程序的蓝图：电子商务应用程序。
