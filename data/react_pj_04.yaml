- en: Build a SSR-Based Community Feed Using React Router
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router构建基于SSR的社区动态
- en: So far, you've learned how React applications are typically **Single-Page Applications**
    (**SPAs**) that can be used as a **Progressive Web App** (**PWA**). This means
    the application is rendered client-side, making it load in the browser when the
    user visits your application. But did you know React also supports **Server-Side
    Rendering** (**SSR**), as you might remember from back in the old days when code
    only rendered from a server?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解到React应用程序通常是**单页应用程序**（**SPA**），可以用作**渐进式Web应用程序**（**PWA**）。这意味着应用程序是在客户端渲染的，当用户访问您的应用程序时，它会在浏览器中加载。但您是否知道React还支持**服务器端渲染**（**SSR**），就像您可能还记得从以前代码只能从服务器渲染的时代一样？
- en: In this chapter, you'll add declarative routing to a Create React App using
    `react-router` and have components dynamically loaded from the server instead
    of the browser. To enable SSR, the React feature, Suspense, will be used with `ReactDOMServer`.
    If you're interested in **Search Engine Optimization** (**SEO**), this chapter
    will use React Helmet to add metadata to the page so your application can be better
    indexed by search engines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将使用`react-router`为Create React App添加声明式路由，并使组件动态加载到服务器而不是浏览器。为了启用SSR，将使用React特性Suspense与`ReactDOMServer`。如果您对**搜索引擎优化**（**SEO**）感兴趣，本章将使用React
    Helmet为页面添加元数据，以便您的应用程序可以更好地被搜索引擎索引。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Declarative routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式路由
- en: Server-side rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: SEO in React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的SEO
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a PWA with declarative routing using `react-router` that
    supports SSR and therefore is loaded from the server rather than the browser.
    Also, the application is optimized for search engines using React Helmet.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`react-router`创建一个支持SSR的PWA，因此从服务器而不是浏览器加载。此外，该应用程序使用React Helmet进行搜索引擎优化。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch4-initial](https://github.com/PacktPublishing/React-Projects/tree/ch4-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch4](https://github.com/PacktPublishing/React-Projects/tree/ch4).
    Also, this project uses the publicly available Stack Overflow API to fill the
    application with data. This is done by fetching questions that are posted to Stack
    Overflow. More information about this API can be found at: [https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true](https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建的项目是在初始版本的基础上构建的，您可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch4-initial](https://github.com/PacktPublishing/React-Projects/tree/ch4-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch4](https://github.com/PacktPublishing/React-Projects/tree/ch4)。此外，该项目使用公开可用的Stack
    Overflow API来填充应用程序的数据。这是通过获取发布到Stack Overflow的问题来完成的。有关此API的更多信息，请访问：[https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true](https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true)。
- en: After downloading the initial project from GitHub, you need to move into the
    root directory for this project and run `npm install`. As this project is built
    on top of Create React App, running this command will install `react`, `react-dom`, and `react-scripts`.
    Also, `styled-components` is used to handle the styling of all of the components
    in the application. When the installation process has finished, you can execute
    the `npm` command start to be able to visit the project in the browser at `http://localhost:3000`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载初始项目后，您需要进入该项目的根目录并运行`npm install`。由于该项目是基于Create React App构建的，运行此命令将安装`react`、`react-dom`和`react-scripts`。此外，`styled-components`用于处理应用程序中所有组件的样式。安装过程完成后，您可以执行`npm`命令`start`，以便在浏览器中访问项目，网址为`http://localhost:3000`。
- en: As the project is set up as a PWA, the service workers are registered to make
    it possible to visit the application even when there is no internet connection.
    You can check this by running `npm run build` first and `serve -s build` once
    the build process is completed. The build version of the application can now be
    visited at `http://localhost:5000`. As mentioned in a previous chapter, you can
    check whether the application is still available when there is no internet connection
    by visiting the Application tab in the Developer Tools of your browser. Inside
    this tab, you can find Service Workers in the menu on the left; after clicking
    this link, you can select the Offline checkbox on the page that appears.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该项目设置为PWA，服务工作者已注册，使得即使没有互联网连接也可以访问该应用。您可以通过首先运行`npm run build`，然后在构建过程完成后运行`serve
    -s build`来检查这一点。现在可以访问该应用的构建版本，网址为`http://localhost:5000`。如前一章所述，您可以通过访问浏览器的开发者工具中的“应用程序”选项卡来检查在没有互联网连接时应用程序是否仍然可用。在该选项卡中，您可以在左侧菜单中找到“服务工作者”；点击此链接后，您可以在出现的页面上选择“离线”复选框。
- en: You may see a different application than when you ran the project locally if
    you've built and served a Create React App PWA before. You can delete any previous
    application from the browser cache by opening the browser's Developer Tools and
    open the Application tab where you can click on the Clear site data button on
    the Clear Storage section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前构建并提供过Create React App PWA，则可能看到与在本地运行项目时不同的应用程序。您可以通过打开浏览器的开发者工具并打开“应用程序”选项卡，在其中可以点击“清除站点数据”按钮来删除浏览器缓存中的任何先前应用程序。
- en: 'The initial application that is available at `http://localhost:3000` consists
    of a simple header and a list of cards—as seen in the following screenshot. These
    cards have a title and meta information such as view count, answer count, and
    information about the user who asked this question:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 初始应用程序位于`http://localhost:3000`，包括一个简单的标题和一系列卡片，如下面的屏幕截图所示。这些卡片有标题和元信息，如查看次数、回答次数以及提出此问题的用户的信息：
- en: '![](assets/ea99accb-4a72-4c9c-852e-7cce404f51c8.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea99accb-4a72-4c9c-852e-7cce404f51c8.png)'
- en: 'If you look at the project''s structure, it uses the same structure as the
    projects you''ve created before. The entry point of this application is a file
    called `src/index.js`, which renders a container component called `App` that contains
    the `Header` and `Feed` components. The `Header` component only displays the title
    of the project, while `Feed` is a class component that has life cycle methods,
    calls the Stack Overflow API, and renders the `Card` components containing the
    Stack Overflow questions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看项目的结构，它使用与之前创建的项目相同的结构。该应用程序的入口点是一个名为`src/index.js`的文件，它渲染一个名为`App`的容器组件，其中包含`Header`和`Feed`组件。`Header`组件仅显示项目的标题，而`Feed`是一个具有生命周期方法的类组件，调用Stack
    Overflow API，并渲染包含Stack Overflow问题的`Card`组件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Community feed application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区动态应用
- en: In this section, you'll build a community feed application with declarative
    routing that has SSR enabled. For SEO, a package called React Helmet will be used.
    In this community feed, you can see an overview of recent questions on Stack Overflow
    that have the `reactjs` tag, and click on them to see more information and the
    answers. The starting point will be a project that is created using Create React
    App.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用启用了SSR的声明式路由构建一个社区动态应用程序。为了SEO，将使用一个名为React Helmet的软件包。在这个社区动态中，您可以看到Stack
    Overflow上具有`reactjs`标签的最新问题的概述，并单击它们以查看更多信息和答案。起点将是使用Create React App创建的项目。
- en: Declarative routing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式路由
- en: With the `react-router` package, you can add declarative routing to a React
    application, just by adding components. These components can be divided into three
    types: router components, route matching components, and navigation components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`react-router`软件包，您可以通过添加组件来为React应用程序添加声明式路由。这些组件可以分为三种类型：路由器组件、路由匹配组件和导航组件。
- en: 'Setting up routing with `react-router` consists of multiple steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`react-router`设置路由包括多个步骤：
- en: 'To use these components, you need to install the web package of `react-router`,
    called `react-router-dom`, by executing the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用这些组件，您需要通过执行以下命令来安装`react-router`的web软件包，称为`react-router-dom`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After installing `react-router-dom`, the next step is to import the routing
    and route matching components from this package in the component that is the entry
    point of your application. In this case, that is the `App` component, which is
    inside the `src/containers` directory:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完`react-router-dom`后，下一步是在您的应用程序入口点组件中从该软件包中导入路由和路由匹配组件。在这种情况下，这是`App`组件，它位于`src/containers`目录中：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The actual routes must be added to the `return` function of this component,
    where all of the route matching components (`Route`) must be wrapped in a routing
    component, `Router`. When your URL matches a route defined in any of the iterations
    of  `Route`, this component will render the JSX component that is added as a `component`
    prop:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的路由必须添加到该组件的`return`函数中，在那里所有的路由匹配组件(`Route`)必须包裹在一个路由组件`Router`中。当您的URL与`Route`的任何迭代中定义的路由匹配时，该组件将呈现添加为`component`属性的JSX组件：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you now visit the project in the browser again at `http://localhost:3000`,
    the `Feed` component showing all the questions will be rendered. Also, if you
    type `http://localhost:3000/feed` in the browser, the `Feed` component will still
    be rendered. This is because the `/` route matches every possible URL, as you
    didn''t define that an exact match should be made. Therefore, add the `exact` attribute to `Route`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在在浏览器中再次访问项目，地址为`http://localhost:3000`，将呈现显示所有问题的`Feed`组件。此外，如果您在浏览器中输入`http://localhost:3000/feed`，`Feed`组件仍将被呈现。这是因为`/`路由匹配每个可能的URL，因为您没有定义应该进行精确匹配。因此，添加`exact`属性到`Route`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, you shouldn't be able to see the `Feed` component being rendered if you
    visit any route other than `/`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您访问除`/`之外的任何路由，不应该看到`Feed`组件被呈现。
- en: If you want these routes to display, for example, a specific question, you'd
    need to send parameters to a route. How you can do this is shown in the next part
    of this section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望显示这些路由，例如，显示特定的问题，您需要向路由发送参数。如何做到这一点将在本节的下一部分中展示。
- en: Routes with parameters
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的路由
- en: 'With the first route in place, other routes can be added to the router component.
    A logical one is having a route for individual questions, that has an extra parameter
    that specifies which question should be displayed. Therefore, a new container
    component called `Question` must be created, which contains the logic for fetching
    a question from the Stack Overflow API. This component is rendered when the path
    matches `/question/:id`, where `id` stands for the ID of the question that is
    clicked on from the feed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了第一个路由之后，其他路由可以添加到路由器组件中。一个合理的路由是为单独的问题添加一个路由，该路由具有指定要显示的问题的额外参数。因此，必须创建一个名为`Question`的新容器组件，其中包含从Stack
    Overflow API获取问题的逻辑。当路径匹配`/question/:id`时，将呈现此组件，其中`id`代表从feed中点击的问题的ID：
- en: 'Create a new class component called `Question` in the `src/containers` directory,
    and add a `constructor` and  `render` method to this file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/containers`目录中创建一个名为`Question`的新类组件，并向该文件添加一个`constructor`和一个`render`方法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make this route available, you need to import this component inside the
    `App` component and define a route for it:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使此路由可用，您需要在`App`组件内导入此组件并为其定义一个路由：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you now visit `http://localhost:3000/questions/55366474`, the `Loading...` message will
    be displayed as no data fetching is implemented yet. The `Route` component passes
    props to the component that it renders, in this case, `Question`; these props
    are `match`, `location`, and `history`.  You can see this by opening the React
    Developer Tools and searching for the `Question` component, which will return
    the following result:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在访问`http://localhost:3000/questions/55366474`，由于尚未实现数据获取，将显示`Loading...`消息。`Route`组件将props传递给它渲染的组件，在本例中是`Question`；这些props是`match`，`location`和`history`。您可以通过打开React开发者工具并搜索`Question`组件来查看这一点，将返回以下结果：
- en: '![](assets/f5161ba8-f886-4949-87e7-0d3e8b2a9492.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f5161ba8-f886-4949-87e7-0d3e8b2a9492.png)'
- en: The `match` prop is the most interesting, as this contains the value of the `id` parameter.
    The `location` and `history` props have information about the current and past
    location of your application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`属性是最有趣的，因为它包含了`id`参数的值。`location`和`history`属性包含了有关应用程序当前位置和过去位置的信息。'
- en: You can also access the `react-router` props by using the `withRouter` **Higher-Order
    Component** (**HOC**), which passes the `match`, `location`, and `history` props to
    the wrapped component each time it renders. That way, you can use methods such
    as `history.goBack` or `history.push` from anywhere in your application. In [Chapter
    3](7d187482-3a85-42f1-a583-77d150c373a4.xhtml), *Build a Dynamic Project Management
    Board with React and Suspense*, you've seen an example of using a HOC; the `withRouter` HOC
    is implemented in the same manner.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用`withRouter`**Higher-Order Component** (**HOC**)访问`react-router` props，该组件在每次渲染时将`match`，`location`和`history`
    props传递给包装组件。这样，您可以在应用程序的任何位置使用`history.goBack`或`history.push`等方法。在[第3章](7d187482-3a85-42f1-a583-77d150c373a4.xhtml)中，*使用React和Suspense构建动态项目管理面板*，您已经看到了使用HOC的示例；`withRouter`
    HOC以相同的方式实现。
- en: 'To implement data fetching on the `Question` component, you need to check for
    the `id` parameter and fetch the corresponding question from the Stack Overflow
    API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Question`组件上实现数据获取，您需要检查`id`参数并从Stack Overflow API中获取相应的问题：
- en: 'Therefore, a `componentDidMount` method should be added to `Question`, which
    fetches the API using this parameter:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，应向`Question`添加一个`componentDidMount`方法，该方法使用此参数获取API：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The data that is being fetched can then be displayed inside a `Card` component.
    Bear in mind that the Stack Overflow API returns an array instead of a single
    object when making this request:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，获取的数据可以显示在`Card`组件内。请记住，当进行此请求时，Stack Overflow API返回的是一个数组而不是单个对象：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you now refresh `http://localhost:3000/questions/55366474`, a `Card` component
    showing information about this specific question is displayed. To be able to navigate
    to this page from the `Feed` component, a `Link` navigation should be added to
    wrap `Card`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在刷新`http://localhost:3000/questions/55366474`，将显示一个显示有关这个特定问题信息的`Card`组件。为了能够从`Feed`组件导航到这个页面，应该添加一个`Link`导航来包裹`Card`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you might notice when visiting `http://localhost:3000/`, the `Card` components
    are now clickable and link to a new page showing the question you''ve just clicked
    on. The styling for the `Card` components has also changed, as the `Link` navigation
    component is an `a` element; it adds an underline and changes the padding. You
    must make the following changes to fix these styling changes:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你访问`http://localhost:3000/`时，你可能会注意到`Card`组件现在是可点击的，并链接到一个新页面，显示你刚刚点击的问题。`Card`组件的样式也发生了变化，因为`Link`导航组件是一个`a`元素；它会添加下划线并改变填充。你需要做以下更改来修复这些样式变化：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the styling should be restored and you're able to navigate to the question
    routes to view individual questions. But next to parameters, there are other ways
    to use the routes for filtering or pass data to it, which are query strings. These
    are investigated in the next part of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，样式应该恢复了，你可以导航到问题路由以查看单个问题。但除了参数之外，还有其他方法可以使用路由进行过滤或向其传递数据，即查询字符串。这些将在本章的下一部分中进行探讨。
- en: Handling query strings
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理查询字符串
- en: 'Being able to navigate to individual questions is only one piece of the cake
    when you want to add routing a project, and pagination could be another one. 
    For this, it would be a good idea to move the overview of all of the questions
    to another route that is called `/questions`. To do this, you need to add another
    `Route` that refers to the `Feed` component within `Router` in your `App` component:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要为项目添加路由时，能够导航到单个问题只是其中的一部分，分页可能是另一个部分。为此，将所有问题的概述移动到另一个名为`/questions`的路由可能是一个好主意。为此，你需要在`App`组件中的`Router`中添加另一个引用`Feed`组件的`Route`：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, if you now visit the project and try clicking on any of the questions,
    you will see both the rendered component and URL haven''t changed. Because of
    the way `react-router` is set up, it will navigate to any route that matches the
    current URL. To solve this problem, you need to add a `Switch` route matching
    component, which works as a switch statement and will render the first `Route` that
    matches the current location:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你现在访问该项目并尝试点击任何一个问题，你会发现渲染的组件和URL都没有改变。由于`react-router`的设置方式，它会导航到与当前URL匹配的任何路由。为了解决这个问题，你需要添加一个`Switch`路由匹配组件，它的工作原理类似于switch语句，并且会渲染与当前位置匹配的第一个`Route`。
- en: 'You can import `Switch` from the `react-router-dom` package in the `scr/containers/App.js` file:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`scr/containers/App.js`文件中从`react-router-dom`包中导入`Switch`：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And place this `Switch` within `Router`, where the order of the routes must
    be changed to make sure that, whenever there is an `id` parameter, this route
    will be rendered first:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并将这个`Switch`放在`Router`中，路由的顺序必须改变，以确保每当有一个`id`参数时，这个路由将首先被渲染。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both the `/questions` and `/questions/:id` routes will now return the correct
    component, which is either the `Feed` or `Question` component. With this in place,
    the next step is to add the pagination. If you look at the API response, the object
    that is being returned has a field called `has_more`. If this field has the value
    `true`, which means you can request more questions by adding the `page` query
    string to the API request.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`/questions`和`/questions/:id`路由将返回正确的组件，即`Feed`或`Question`组件。有了这个设置，下一步是添加分页。如果你查看API响应，返回的对象有一个叫做`has_more`的字段。如果这个字段的值是`true`，就意味着你可以通过在API请求中添加`page`查询字符串来请求更多问题。
- en: 'You can try and add this query string to the URL in the browser, by visiting 
    `http://localhost:3000/questions?page=2`. This query string is now available as
    a prop on the `Feed` component in the `location` object under the `search` field,
    which you can see in the output of the React Developer Tools:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试将这个查询字符串添加到浏览器中的URL中，访问`http://localhost:3000/questions?page=2`。这个查询字符串现在作为`Feed`组件的一个prop出现在`location`对象的`search`字段下，你可以在React
    Developer Tools的输出中看到它：
- en: '![](assets/aa4a5765-277c-4b01-85ff-1d6cfe2a8d1d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa4a5765-277c-4b01-85ff-1d6cfe2a8d1d.png)'
- en: 'Unfortunately, `react-router` doesn''t come with a standard solution to easily
    grasp the value of the `location.search` prop. Therefore, you need to install
    the `query-string` package using `npm`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`react-router`没有一个标准的解决方案来轻松地获取`location.search`的值。因此，你需要使用`npm`安装`query-string`包：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This package is created to parse a query string, in this case, `location.search`,
    to an object you can use in your application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包被创建用来解析查询字符串，比如`location.search`，将其转换为你可以在应用程序中使用的对象：
- en: 'You can do this by importing the package in the `Feed` component:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在`Feed`组件中导入包来实现这一点：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can parse the value for the `page` query string in the `constructor` method,
    and add this parsed value to `state`. Make sure to use the JavaScript `parseInt` function,
    so the page will become an integer and not a string. If there is no page query
    string available, it''s assumed you''re visiting the first page:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在`constructor`方法中解析`page`查询字符串的值，并将这个解析后的值添加到`state`中。确保使用JavaScript的`parseInt`函数，这样页面将成为一个整数而不是一个字符串。如果没有可用的页面查询字符串，就假定你正在访问第一页：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And if there is a value for the `page` query string in `state`, you can send
    this to the API to get the questions for the page number you specify:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`state`中有`page`查询字符串的值，你可以将其发送到API，以获取你指定的页面号的问题：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can test whether this is working by changing the query string for `page`
    with different numbers, such as `http://localhost:3000/questions?page=1` or `http://localhost:3000/questions?page=3`.
    To make the application more user-friendly, let's add pagination buttons to the
    bottom of the page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改`page`的查询字符串来测试它是否有效，比如`http://localhost:3000/questions?page=1`或`http://localhost:3000/questions?page=3`。为了使应用程序更加用户友好，让我们在页面底部添加分页按钮。
- en: 'Create the `PaginationBar` component, which holds two `Button` components that
    are styled `Link` components from `react-router`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PaginationBar`组件，其中包含两个`Button`组件，它们是来自`react-router`的样式化的`Link`组件：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now add these to the bottom of `FeedWrapper`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以将这些添加到`FeedWrapper`的底部。
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These `PaginationLink` components should link to somewhere for the user to
    be able to navigate to different pages. For this, the current URL can be taken
    from the `match` prop and the current page number is available in `state`. Be
    aware that the previous button should only be shown when the page number is above
    1, and the next button only when the API response indicates that there are more
    results than the ones that are returned:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些`PaginationLink`组件应该链接到某个地方，以便用户能够导航到不同的页面。为此，可以从`match`属性中获取当前URL，并且当前页码在`state`中可用。请注意，只有当页码大于1时，才应显示上一页按钮，而只有当API响应表明返回的结果比返回的结果更多时，才应显示下一页按钮：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, if you now try and click on the next (or previous) button the URL will
    change, the questions that are being displayed don't change. By using the `componentDidMount` method,
    the API will only be called after your application mounts for the first time.
    To watch for any changes to `props` or `state` when your application is already
    mounted, you need to use another life cycle method called `componentDidUpdate`.
    This method can watch for changes to `props` or `state`, as it can access the
    values of `props` and `state` before they were updated. They are scoped within
    the `componendDidUpdate` method as the `prevProps` and `prevState` parameters,
    which you can compare to check whether you need to fetch the API again when any
    `props` or `state` have changed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您现在尝试单击下一个（或上一个）按钮，URL将更改，显示的问题不会更改。通过使用`componentDidMount`方法，API将仅在应用程序首次挂载后调用。要在应用程序已经挂载时监视`props`或`state`的任何更改，您需要使用另一个称为`componentDidUpdate`的生命周期方法。该方法可以监视`props`或`state`的更改，因为它可以访问更新之前的`props`和`state`的值。它们在`componendDidUpdate`方法中作用域内，作为`prevProps`和`prevState`参数，您可以比较它们以检查在任何`props`或`state`更改时是否需要再次获取API。
- en: 'The first step in achieving this is creating a function that fetches the API
    and that can also be used outside of the `componentDidMount` method. This function
    should take the `page` number as a parameter, so it can fetch the correct page:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这一点的第一步是创建一个获取API的函数，该函数还可以在`componentDidMount`方法之外使用。此函数应将`page`号作为参数，以便可以获取正确的页面：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After creating this function, it can be called in the `componentDidMount` method,
    which no longer needs to be an asynchronous function as this is already handled
    by the new `fetchAPI` function. Therefore, the method can be deleted and replaced
    by the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建此函数后，可以在`componentDidMount`方法中调用它，因为这不再需要是一个异步函数，因为这已经由新的`fetchAPI`函数处理。因此，该方法可以被删除并替换为以下内容：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Directly after the `componentDidMount` method, you need to add the new `componentDidUpdate` life
    cycle method. As mentioned before, this can take `prevProps` and `prevState` as
    parameters, but as navigating to a new URL only changes `props`, the prior is
    used. Here, you need to check whether the query strings have changed. If they
    have changed, you need to update `state` with the new parsed value for the `page` query
    string and call the `fetchAPI` function to get the results for this page:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`componentDidMount`方法之后，您需要添加新的`componentDidUpdate`生命周期方法。如前所述，这可以将`prevProps`和`prevState`作为参数，但是由于导航到新URL只会更改`props`，因此只使用前者。在这里，您需要检查查询字符串是否已更改。如果它们已更改，则需要使用`page`查询字符串的新解析值更新`state`，并调用`fetchAPI`函数以获取此页面的结果：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When using the `componentDidUpdate` life cycle method, you should always make
    sure to compare either `prevProps` or `prevState` to the current `props` or `state`.
    The `componentDidUpdate` method is invoked continuously and when you don't compare
    any values, you could end up with an infinite loop that crashes your application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`componentDidUpdate`生命周期方法时，您应始终确保将`prevProps`或`prevState`与当前的`props`或`state`进行比较。`componentDidUpdate`方法会不断调用，当您不比较任何值时，可能会导致应用程序崩溃的无限循环。
- en: You have now implemented the parsing of the query string to dynamically change
    the route for your application. In the next section, you'll explore another thing
    you can do with React, which is SRR that enables you to serve your application
    from the server instead of rendering it in runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经实现了解析查询字符串以动态更改应用程序路由的功能。在下一节中，您将探索React的另一项功能，即SRR，它使您能够从服务器上提供应用程序，而不是在运行时进行渲染。
- en: Enable SSR
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用SSR
- en: Using SSR can be helpful if you're building an application that needs to render
    very quickly or when you want certain information to be loaded before the web
    page is visible. Although most search engines are now able to render SPA, this
    can still be an improvement if you want users to share your page on social media.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSR可以帮助您构建需要快速渲染的应用程序，或者当您希望在网页可见之前加载某些信息时。尽管大多数搜索引擎现在能够渲染SPA，但如果您希望用户在社交媒体上分享您的页面，这仍然可以是一个改进。
- en: Creating an express server with react-router
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-router创建express服务器
- en: 'There is no standard pattern to enable SSR for your React application, but
    the starting point is to create a Node.js server that''s serving the entry for
    running the build version for your application. For this, you''ll use a minimal
    API framework for Node.js called `express`. Also, the packets that you''ve already
    used, such as `react-router` and `styled-components`, can work with SSR as well:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准模式可以为您的React应用程序启用SSR，但起点是创建一个Node.js服务器，该服务器为应用程序的构建版本提供服务。为此，您将使用一个名为`express`的Node.js的最小API框架。此外，您已经使用的包，如`react-router`和`styled-components`，也可以与SSR一起使用：
- en: 'You can start by installing `express` by running the following:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来安装`express`：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, you must create a new directory called `server` in the projects'' root
    directory and place a new file called `server.js` inside. In this file, you can
    place the following code block to import packages you need to run the Node.js
    server, `react`, and `react-dom/server`—which is used to render your application
    from a server:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您必须在项目的根目录中创建一个名为`server`的新目录，并在其中放置一个名为`server.js`的新文件。在此文件中，您可以放置以下代码块来导入您需要运行Node.js服务器、`react`和`react-dom/server`的软件包，后者用于从服务器渲染您的应用程序：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Directly below these imports, you need to import the entry point of the application
    that should be rendered by the server:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些导入的正下方，您需要导入应用程序的入口点，该入口点应该由服务器进行渲染：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After having defined the entry point, the code to set up the Node.js server
    with `express` and have it listen to all of the endpoints on the server can be
    added. First, you need to set a port on which `express` will be running, after
    which, you define that all of the routes matching the `/*` wildcard should return
    a static version of your application that is being rendered by `ReactDOMServer`
    as a string. That is done by getting the contents of the `index.html` build file
    and replacing the `<div id="root"></div>` tags with new tags that contain the
    server-rendered version of the `App` component:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了入口点之后，可以添加用`express`设置Node.js服务器并使其监听服务器上的所有端点的代码。首先，您需要设置`express`将运行的端口，之后，您定义所有与`/*`通配符匹配的路由应返回由`ReactDOMServer`呈现为字符串的应用程序的静态版本。这是通过获取`index.html`构建文件的内容并用包含`App`组件的服务器渲染版本的新标记替换`<div
    id="root"></div>`标记来完成的：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And have this `express` server listen to the `8080` port you''ve defined, by
    adding this code block to the bottom of this file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且通过将以下代码块添加到此文件的底部，使此`express`服务器监听您定义的`8080`端口：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, you need to change the way your `App` component is rendered from the
    entry point of the application in `src/index.js`. In this file, `ReactDOM.render` needs
    to be replaced by `ReactDOM.hydrate` as the Node.js server tries to change the
    markup of the `index.html` build file by injecting the server-rendered version:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要更改`src/index.js`中应用程序的入口点的方式。在这个文件中，`ReactDOM.render`需要被`ReactDOM.hydrate`替换，因为Node.js服务器试图通过注入服务器渲染版本来更改`index.html`构建文件的标记：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, this Node.js server isn''t able to use any of the webpack configuration
    that is being used by your React application, as its code isn''t placed in the
    `src` directory. To be able to run this Node.js server, you need to configure
    Babel for the `server` directory and install some of the Babel packages. This
    is something you''ve done before in the first chapter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个Node.js服务器无法使用React应用程序使用的任何webpack配置，因为其代码不在`src`目录中。为了能够运行这个Node.js服务器，您需要为`server`目录配置Babel并安装一些Babel包。这是您在第一章中做过的事情：
- en: 'The Babel packages that should be installed are `@babel/polyfill`, which compiles
    functions such as `async`/`await`; `@babel/register` to tell Babel it should transform
    files with the `.js` extension; and `@babel/preset-env` and `@babel/preset-react`
    to configure Babel to work with React:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该安装的Babel包是`@babel/polyfill`，它编译诸如`async`/`await`之类的函数；`@babel/register`告诉Babel它应该转换扩展名为`.js`的文件；`@babel/preset-env`和`@babel/preset-react`用于配置Babel以与React一起工作：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In a new file called `index.js` inside the `server` directory, you can now
    require these packages and have this file serve as an entry point to the `server.js`
    file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server`目录内的一个名为`index.js`的新文件中，您现在可以要求这些包，并使此文件作为`server.js`文件的入口点：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should be able to run the `server/index.js` file with Node.js, by executing
    the `node server/index.js` command. So, let''s make a shortcut for this command
    in `package.json` within the scripts field:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够通过执行`node server/index.js`命令来运行`server/index.js`文件。因此，在`package.json`中的scripts字段中为此命令创建一个快捷方式：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before running the `npm run ssr` command, you should always execute `npm run
    build` before as the Node.js server is using the build version. If you run the
    `npm run ssr` command now, though, you will receive an error saying `BrowserRouter
    needs to a DOM to render`. Because of the way `react-router` is set up, you need
    to use the `StaticRouter` component when using SSR instead of `BrowserRouter`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`npm run ssr`命令之前，您应该始终在Node.js服务器使用构建版本之前执行`npm run build`。如果您现在运行`npm run
    ssr`命令，您将收到一个错误，提示“BrowserRouter需要DOM来渲染”。由于`react-router`的设置方式，您需要在使用SSR时使用`StaticRouter`组件，而不是`BrowserRouter`：
- en: 'When the application is running client-side (using `npm start`), it will still
    need to use `BrowserRouter`, so therefore the wrapping of the `Route` components
    should be moved from `App` to the `src/index.js` file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序在客户端运行时（使用`npm start`），它仍然需要使用`BrowserRouter`，因此`Route`组件的包装应该从`App`移到`src/index.js`文件中：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And, of course, it''s deleted from the `App` component:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，它从`App`组件中删除：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To get the Node.js server to now use the `StaticRouter` component from `react-router`,
    you need to add this in `server/index.js` and wrap the `App` component that is
    being rendered by `ReactDOMServer` with `StaticRouter`. For `react-router` to
    know which route to load, you must pass the current URL as a `location` prop,
    and (in this case) an empty `context` prop as `StaticRouter` should always have
    this to handle redirects:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使Node.js服务器现在使用`react-router`中的`StaticRouter`组件，您需要在`server/index.js`中添加此内容，并使用`StaticRouter`包装由`ReactDOMServer`呈现的`App`组件。对于`react-router`来知道加载哪个路由，您必须将当前URL作为`location`属性传递，并且（在本例中）将空的`context`属性作为`StaticRouter`应该始终具有此属性以处理重定向：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this last step done, you can go and execute `npm run build` again. After
    the build has finished, you can start the Node.js server by running `npm run ssr`
    to view your server-rendered React application on `http://localhost:8080`. This
    application looks the same, as SSR doesn't change anything to the appearance of
    your application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了最后一步，您可以再次执行`npm run build`。构建完成后，您可以通过运行`npm run ssr`启动Node.js服务器，以在`http://localhost:8080`上查看您的服务器渲染的React应用程序。这个应用程序看起来一样，因为SSR不会改变应用程序的外观。
- en: Another advantage of SSR is that your application can be discovered by search
    engines more effectively. In the next part of this section, you'll add the tags
    that make your application discoverable by these engines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: SSR的另一个优点是，您的应用程序可以更有效地被搜索引擎发现。在本节的下一部分，您将添加标记，使您的应用程序可以被这些引擎发现。
- en: Adding head tags using React Helmet
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Helmet添加头标签
- en: 'Assuming you want your application to be indexed by search engines, you need
    to set head tags for the crawlers to identify the content on your page. This is
    something you want to do dynamically for each route route, as each route will
    have different content. A popular package for setting these head tags in React
    applications is React Helmet, which has support for SSR. You can install React
    Helmet with `npm`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望您的应用程序被搜索引擎索引，您需要为爬虫设置头标签，以识别页面上的内容。对于每个路由，您都希望动态执行此操作，因为每个路由都将具有不同的内容。在React应用程序中设置这些头标签的流行包是React
    Helmet，它支持SSR。您可以使用`npm`安装React Helmet：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'React Helmet can define the head tags in any component that is rendered by
    your application, and if nested, the lowest definition of a `Helmet` component
    in the component tree will be used. That''s why you can create a `Helmet` component
    in your `Header` component for all routes and in each of the components that are
    being rendered on a route, you can overwrite these tags:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: React Helmet可以在应用程序中呈现的任何组件中定义头标签，并且如果嵌套，则组件树中`Helmet`组件的最低定义将被使用。这就是为什么您可以在`Header`组件中为所有路由创建一个`Helmet`组件，并且在每个在路由上呈现的组件中，您可以覆盖这些标签：
- en: 'Import the `react-helmet` package in the `src/components/App/Header.js` file,
    and create a `Helmet` component that sets `title` and meta `description`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components/App/Header.js`文件中导入`react-helmet`包，并创建一个`Helmet`组件，设置`title`和meta`description`：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, create a `Helmet` component in `src/containers/Feed.js` that only sets
    a title for this route, so it will use the meta `description` of `Header`. This
    component is placed within Fragments before the `Alert` component as this is available
    when the application first renders:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `src/containers/Feed.js` 中创建一个 `Helmet` 组件，该组件仅为此路由设置标题，因此它将使用 `Header`
    的 `description` 元标签。此组件放置在 `Alert` 组件之前的 Fragment 中，因为这在应用程序首次渲染时可用。
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Do the same for the `src/containers/Question.js` file, where you can also take
    the ID of the question from the `match` props to make the page title more dynamic:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `src/containers/Question.js` 文件也要做同样的操作，您还可以从 `match` props 中获取问题的 ID，使页面标题更加动态：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'These head tags will now be used when you''re running your application client-side
    by executing the `npm start` command. But to support SSR, React Helmet should
    also be configured on the Node.js server. For this, you can use the `Helmet.renderStatic` method,
    which transforms the `Helmet` components in your code the same way as `ReactDOMserver.renderToString` does
    for other components. Open the `server/server.js` file and add the following lines
    of code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您执行 `npm start` 命令在客户端运行应用程序时，这些头标签将被使用。但是为了支持 SSR，React Helmet 也应该在 Node.js
    服务器上进行配置。为此，您可以使用 `Helmet.renderStatic` 方法，该方法会将您代码中的 `Helmet` 组件转换为其他组件的 `ReactDOMserver.renderToString`
    所做的方式一样。打开 `server/server.js` 文件并添加以下代码：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On one of the last lines of this file, you''ve now defined that the `<meta
    name="helmet" />` element should be replaced by the `title` and `meta` tags created
    by React Helmet. To make it possible to replace this element with these tags,
    add this element to `index.html` in the `public` directory. Also, you must delete
    the `title` element that is already being created by React Helmet now:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件的最后一行中，您现在已经定义了 `<meta name="helmet" />` 元素应该被 React Helmet 创建的 `title`
    和 `meta` 标签替换。为了能够用这些标签替换这个元素，将此元素添加到 `public` 目录中的 `index.html` 中。此外，您还必须删除 React
    Helmet 现在已经创建的 `title` 元素：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With these last changes, you can now run `npm run build` again to create a new
    build version of your application. After this process has finished, you execute
    the `npm run ssr` command to start the Node.js server and visit your React SSR
    application in the browser on `http://localhost:8080`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这些最后的更改后，您现在可以再次运行 `npm run build` 来创建应用程序的新构建版本。完成此过程后，执行 `npm run ssr`
    命令来启动 Node.js 服务器，并在浏览器上访问您的 React SSR 应用程序，网址为 `http://localhost:8080`。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've added dynamic routing to a Create React App using `react-router`,
    making it possible for users to open your application on a specific page. By using
    the React feature Suspense, components are loaded dynamically on the client-side.
    This way, you lower the amount of time before your user first gets in contact
    with your application. The project you created in this chapter also supports SSR,
    and React Helmet is used to add dynamic head tags to the application for SEO purposes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您使用 `react-router` 为 Create React App 添加了动态路由，使用户可以在特定页面上打开您的应用程序。通过使用
    React 的 Suspense 特性，组件在客户端动态加载。这样，您可以减少用户首次接触应用程序之前的时间。在本章中创建的项目还支持 SSR，并且使用 React
    Helmet 为应用程序添加动态头标签以用于 SEO 目的。
- en: After completing this chapter, you must already feel like an expert with React!
    The next chapter will for sure take your skill to the next level as you'll learn
    how to handle state management using the context API. With the context API, you
    can share state and data between multiple components in your application, no matter
    whether they're direct children of the parent component or not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您应该已经感觉像是 React 的专家了！下一章肯定会将您的技能提升到更高的水平，因为您将学习如何使用上下文 API 处理状态管理。使用上下文
    API，您可以在应用程序中的多个组件之间共享状态和数据，无论它们是父组件的直接子组件还是其他组件。
- en: Further reading
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: React Helmet: [https://github.com/nfl/react-helmet](https://github.com/nfl/react-helmet)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'React Helmet: [https://github.com/nfl/react-helmet](https://github.com/nfl/react-helmet)'
- en: ReactDOMServer: [https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ReactDOMServer: [https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)'
