- en: RSS Reader
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSS阅读器
- en: In this chapter, we will create an app which will be able to fetch, process,
    and show the user several RSS feeds. RSS is a web feed, which allows users to
    access updates to online content in a standardized and computer-readable format.
    They are normally used in news websites, news aggregators, forums, and blogs to
    represent updated content and it fits very well to the mobile world, as we can
    have all the content from different blogs or newspapers just by entering the feed's
    URL in one app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个应用程序，能够获取、处理和显示用户多个RSS订阅。RSS是一种Web订阅，允许用户以标准化和计算机可读的格式访问在线内容的更新。它们通常用于新闻网站、新闻聚合器、论坛和博客，以表示更新的内容，并且非常适合移动世界，因为我们可以通过在一个应用程序中输入订阅的URL来获取来自不同博客或报纸的所有内容。
- en: An RSS feed reader will serve as an example on how to fetch external data, store
    it, and display it to the user, but at the same time, will add a bit of complexity
    to our state tree; we will need to store and manage lists of feeds, entries, and
    posts. On top of that, we will introduce MobX as a library to manage all those
    state models and update our views, based on the user's actions. Therefore, we
    will introduce the concept of actions and stores, which is widely used in some
    of the most popular state management libraries, such as Redux or MobX.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个RSS订阅阅读器将作为一个示例，演示如何获取外部数据，存储它，并向用户显示它，但同时，它将给我们的状态树增加一些复杂性；我们需要存储和管理订阅、条目和帖子的列表。除此之外，我们将引入MobX作为一个库来管理所有这些状态模型，并根据用户的操作更新我们的视图。因此，我们将介绍行为和存储的概念，这在一些最流行的状态管理库中被广泛使用，比如Redux或MobX。
- en: As we did in the previous chapter, and because the UI patterns we will need
    for this app are very similar on both platforms, we will aim at sharing 100% of
    the code for iOS and Android.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，因为我们将在这个应用程序中需要的UI模式在两个平台上非常相似，我们将致力于在iOS和Android上共享100%的代码。
- en: Overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: To better understand our RSS reader, let's take a look at how the app will look
    like once we finish it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们的RSS阅读器，让我们看看完成后应用程序将会是什么样子。
- en: 'iOS:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: iOS：
- en: '![](Images/9b2159fe-4103-49bb-8d26-884e73c431a3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9b2159fe-4103-49bb-8d26-884e73c431a3.png)'
- en: 'Android:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Android：
- en: '![](Images/dc295cc7-7640-46fc-a27a-68b8e27fb961.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dc295cc7-7640-46fc-a27a-68b8e27fb961.png)'
- en: The home screen will display a list of the feeds already added by the user.
    It will also show a button (+) in the navigation header to add a new feed to the
    list. When that button is pressed, the app will navigate to the Add feed screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕将显示用户已添加的订阅列表。导航标题还会显示一个(+)按钮，用于向列表中添加新的订阅。当按下该按钮时，应用程序将导航到添加订阅屏幕。
- en: 'iOS:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: iOS：
- en: '![](Images/ab44b43d-3ec3-4384-9ffe-7635078d3540.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ab44b43d-3ec3-4384-9ffe-7635078d3540.png)'
- en: 'Android:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android：
- en: '![](Images/9ab48440-ae80-4472-a992-572019522f21.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9ab48440-ae80-4472-a992-572019522f21.png)'
- en: Once a new feed has been added, it will show on the home screen and the user
    will be able to open it by simply tapping on it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了新的订阅，它将显示在主屏幕上，用户只需点击即可打开它。
- en: 'iOS:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: iOS：
- en: '![](Images/2cff312d-358f-40a2-ac98-e25c7a4443de.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2cff312d-358f-40a2-ac98-e25c7a4443de.png)'
- en: 'Android:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android：
- en: '![](Images/2241542d-5f29-487d-9eb7-670f212020da.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2241542d-5f29-487d-9eb7-670f212020da.png)'
- en: At this stage, the app will retrieve the list of the updated entries for the
    selected feed and display it on a list. In the navigation header, a Trash icon
    will allow the user to remove the feed from the app. If the user is interested
    in any entries, she can click on it to display the full content for that entry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，应用程序将检索所选订阅的更新条目列表，并在列表上显示它。在导航标题中，一个垃圾桶图标将允许用户从应用程序中删除该订阅。如果用户对任何条目感兴趣，她可以点击它以显示该条目的完整内容。
- en: 'iOS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: iOS：
- en: '![](Images/80a7cfb4-2ce0-4e5f-a2b0-98354da60e05.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/80a7cfb4-2ce0-4e5f-a2b0-98354da60e05.png)'
- en: 'Android:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android：
- en: '![](Images/6e7a138d-9aed-48ec-9bf9-c1cc862b49d7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6e7a138d-9aed-48ec-9bf9-c1cc862b49d7.png)'
- en: This last screen is basically a WebView, a lightweight browser opened by default
    in the URL, which is containing the content for the selected entry. The user will
    be able to navigate to subsections and fully interact with the open website in
    this screen having also the possibility to go back to the feed details by tapping
    on the Back arrow in the navigation header.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的屏幕基本上是一个WebView，默认情况下在URL中打开的轻量级浏览器，其中包含所选条目的内容。用户将能够浏览子部分并完全与此屏幕中打开的网站进行交互，还可以通过在导航标题中点击返回箭头来返回到源的详细信息。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: State management with MobX
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MobX进行状态管理
- en: Fetch external data from a URL
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从URL获取外部数据
- en: WebView
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebView
- en: Basic linking modules with native resources
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基本链接模块与本地资源链接起来
- en: Adding icons
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加图标
- en: ActivityIndicator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActivityIndicator
- en: Setting up the folder structure
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'As we did in the first chapter, we need to initialize a new React Native project
    through React Native''s CLI. This time, we will name our project `RSSReader`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第一章中所做的那样，我们需要通过React Native的CLI初始化一个新的React Native项目。这次，我们将把我们的项目命名为`RSSReader`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this app, we will need a total of four screens:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将需要总共四个屏幕：
- en: '`FeedList`: This is a list containing the titles for the feeds which were added
    to the app sorted by the time they were added.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeedList`：这是一个包含已添加到应用程序中的源标题的列表，按它们被添加的时间排序。'
- en: '`AddFeed`: This is a simple form to allow the user to add a feed by sending
    its URL. We will here retrieve the feed details to finally add and save them in
    our app for later usage.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddFeed`：这是一个简单的表单，允许用户通过发送其URL来添加源。我们将在这里检索源的详细信息，最终将它们添加并保存在我们的应用程序中以供以后使用。'
- en: '`FeedDetail`: This is a list containing the latest entries (retrieved before
    mounting the screen) belonging to the selected feed.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeedDetail`：这是一个包含所选源的最新条目（在挂载屏幕之前检索）的列表。'
- en: '`EntryDetail`: This is a WebView showing the contents of the selected entry.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntryDetail`：这是一个WebView，显示所选条目的内容。'
- en: Besides the screens, we will include an `actions.js` file containing all the
    user actions modifying the app's state. Although we will review how the state
    is managed in a later section, in detail, it's also important to note that besides
    this `actions.js` file, we need a `store.js` file to contain the state structure
    and methods to modify it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了屏幕之外，我们还将包括一个`actions.js`文件，其中包含修改应用程序状态的所有用户操作。虽然我们将在后面的部分中审查状态的管理，但重要的是要注意，除了这个`actions.js`文件之外，我们还需要一个`store.js`文件来包含状态结构和修改它的方法。
- en: Finally, and as it is normal in most of the React Native projects, we will need
    an `index.js`  file (already created by React Native's CLI) and a `main.js` file
    to serve as an entry point for our app's components tree.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如在大多数React Native项目中一样，我们将需要一个`index.js`文件（已经由React Native的CLI创建）和一个`main.js`文件作为我们应用程序组件树的入口点。
- en: 'All these files will be organized inside `src/` and `src/screens/` folders,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件将被组织在`src/`和`src/screens/`文件夹中，如下所示：
- en: '![](Images/644ee843-3dc1-458f-9c92-d422f1c7f8e5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/644ee843-3dc1-458f-9c92-d422f1c7f8e5.png)'
- en: Adding dependencies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'For this project, we will use several npm modules to save development time
    and put the focus on the functional aspects of the RSS reader itself, rather than
    dealing with custom state management frameworks, custom UI, or data processing.
    For these matters, we will use the following `package.json` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用几个npm模块来节省开发时间，并将重点放在RSS阅读器本身的功能方面，而不是处理自定义状态管理框架、自定义UI或数据处理。对于这些问题，我们将使用以下`package.json`文件：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As can be seen in this file, we will be using the following npm modules together with
    the standard React Native''s modules:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在这个文件中所看到的，我们将与标准的React Native模块一起使用以下npm模块：
- en: '`mobx`: This is the state management library we will be using'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mobx`：这是我们将使用的状态管理库'
- en: '`mobx-react`: This is the official React bindings for MobX'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mobx-react`：这是MobX的官方React绑定'
- en: '`native-base`: As we did in the previous chapter, we will use NativeBase''s
    UI library'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native-base`：与上一章一样，我们将使用NativeBase的UI库'
- en: '`react-native-vector-icons`: NativeBase requires this module to display graphic
    icons'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-vector-icons`：NativeBase需要这个模块来显示图形图标'
- en: '`react-navigation`: We will use the React Native''s community navigation library again'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-navigation`：我们将再次使用React Native的社区导航库'
- en: '`simple-xml2json`: A lightweight library to convert XML (the standard format
    for RSS feeds) into JSON to easily manage the RSS data within our code'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple-xml2json`：一个轻量级库，用于将XML（RSS订阅的标准格式）转换为JSON，以便在我们的代码中轻松管理RSS数据'
- en: 'Having this `package.json` file, we can run the following command (in the root
    folder of our project) to finish the installation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个`package.json`文件，我们可以在项目的根文件夹中运行以下命令来完成安装：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once npm finishes installing all dependencies, we can start our app in the
    iOS simulator:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦npm完成安装所有依赖项，我们就可以在iOS模拟器中启动我们的应用程序：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or in the Android emulator:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Android模拟器中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using vector icons
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矢量图标
- en: 'For this app, we will use two icons: a plus sign to add feeds and a trash bin
    to remove them. React Native doesn''t include a list of icons to be used by default,
    so we will need to add one. In our case, since we are using `native-base` as our
    UI library, it''s very convenient to use `react-native-vector-icons`, as it is
    supported natively from `native-base`, but it requires one extra configuration
    step:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将使用两个图标：一个加号用于添加订阅，一个垃圾桶用于删除它们。React Native默认不包括要使用的图标列表，因此我们需要添加一个。在我们的情况下，由于我们正在使用`native-base`作为我们的UI库，使用`react-native-vector-icons`非常方便，因为它在`native-base`中受到原生支持，但需要一个额外的配置步骤：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some libraries use extra native capabilities which are not present in React
    Native. In the case of `react-native-vector-icons`, we need to include a number of
    vector icons stored in the library accessible natively. For these kinds of tasks,
    React Native includes `react-native link`, a script to automatically link the
    provided library to prepare all the native code and resources, which are needed
    for this library to be accessible within our app. Lots of libraries will require
    this extra step, but thanks to React Native's CLI, it is a very simple step, which
    in the past required moving files around projects and messing with configuration
    options.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库使用额外的原生功能，这些功能在React Native中不存在。在`react-native-vector-icons`的情况下，我们需要包含存储在库中的一些矢量图标，可以在原生中访问。对于这些类型的任务，React
    Native包括`react-native link`，这是一个脚本，可以自动链接提供的库，准备所有原生代码和资源，这些资源在我们的应用程序中需要访问此库。许多库将需要这一额外步骤，但由于React
    Native的CLI，这是一个非常简单的步骤，过去需要在项目之间移动文件并处理配置选项。
- en: Managing our state with MobX
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MobX管理我们的状态
- en: 'MobX is a library which makes state management simple and scalable by transparently
    applying functional reactive programming. The philosophy behind MobX is very simple:
    *anything that can be derived from the application state, should be derived automatically. *This
    philosophy applies to UI, data serialisation and server communication.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MobX是一个库，通过透明地应用函数式响应式编程，使状态管理变得简单和可扩展。MobX背后的哲学非常简单：*任何可以从应用程序状态派生出来的东西，都应该自动派生。*这个哲学适用于UI、数据序列化和服务器通信。
- en: Lots of documentation and examples of using MobX can be found on its website [https://mobx.js.org/,](https://mobx.js.org/) although
    we will make a small introduction in this section to fully understand our app's
    code in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在其网站[https://mobx.js.org/,](https://mobx.js.org/)上可以找到大量关于使用MobX的文档和示例，尽管在本节中我们将对其进行简要介绍，以便在本章中充分理解我们应用的代码。
- en: The store
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店
- en: 'MobX uses the concept of "observable" properties. We should declare an object
    containing our general application''s state, which will hold and declare those
    observable properties. When we modify one of these properties, all the subscribed
    observers will be updated by MobX automatically. This is the basic principle behind
    MobX, so let''s take a look at a sample code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: MobX使用“observable”属性的概念。我们应该声明一个包含我们一般应用状态的对象，它将保存和声明这些observable属性。当我们修改其中一个属性时，MobX会自动更新所有订阅的观察者。这是MobX背后的基本原则，让我们看一个示例代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have an attribute, `feeds`, marked as `@observable`, meaning that any component
    can subscribe to it and be notified every time the value is changed. This attribute
    is initialized as an empty array in the class constructor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个被标记为`@observable`的属性`feeds`，这意味着任何组件都可以订阅它，并在值发生变化时得到通知。这个属性在类构造函数中被初始化为空数组。
- en: 'Finally, we also created the `addFeed` method, which will push a new feed into
    the `feeds` attribute and therefore will trigger automatic updates on all the
    observers. To better understand MobX observers, let''s take a look at a sample
    component observing the feeds list:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还创建了`addFeed`方法，它将新的订阅推送到`feeds`属性中，因此将自动触发所有观察者的更新。为了更好地理解MobX观察者，让我们看一个观察订阅列表的示例组件：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing we notice is the need to mark our component with the `@observer`
    decorator to ensure it is updated when any of the `@observable ` properties change
    in our store.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是需要使用`@observer`装饰器标记我们的组件，以确保当我们商店中的任何`@observable`属性发生变化时它会被更新。
- en: By default, React Native's Babel configuration doesn't support the `@<decorator>`
    syntax. In order for it to work, we will need to modify our `.babelrc` file (found
    in the root of our project) and add `transform-decorator-legacy` as a plugin.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Native的Babel配置不支持`@<decorator>`语法。为了使其工作，我们需要修改我们项目根目录中的`.babelrc`文件，并将`transform-decorator-legacy`添加为插件。
- en: Another thing to note is the need for the store to be received in the component
    as a property. In this case, since we are using `react-navigation`, we will pass
    it inside `screenProps`, which is the standard way in `react-navigation` for sharing
    properties between `<Navigator>` and its child screens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是需要将存储作为属性传递给组件。在这种情况下，由于我们使用`react-navigation`，我们将在`screenProps`中传递它，这是在`react-navigation`中在`<Navigator>`和其子屏幕之间共享属性的标准方式。
- en: MobX has many more features, but we will leave those for more complex apps as
    one of the goals for this chapter is to show how simple state management can be when
    we are building small apps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MobX还有许多其他功能，但我们将把这些留给更复杂的应用程序，因为本章的一个目标是展示在构建小型应用程序时简单状态管理可以是多么简单。
- en: Setting up the store
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置商店
- en: 'After understanding how MobX works, we are ready to create our store:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了MobX的工作原理之后，我们准备创建我们的商店：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have already seen the basic structure of this file in the MobX section of
    this chapter. Now, we will add some methods to modify the list of feeds and to
    select a specific feed/entry when the user taps on them in our app's listings
    for feeds/entries.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的MobX部分看到了该文件的基本结构。现在，我们将添加一些方法来修改订阅列表，并在用户在我们应用的订阅/条目列表中点击它们时选择特定的订阅/条目。
- en: We are also making use of `AsyncStorage` to persist the list of feeds every
    time it is modified by either `addFeed` or `removeFeed`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用`AsyncStorage`来在`addFeed`或`removeFeed`修改时持久化订阅列表。
- en: Defining actions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作
- en: 'There will be two types of actions in our app: those affecting a specific component''s
    state and those affecting the general app state. We want to store the latter somewhere
    out of the component''s code, so we can reuse and easily maintain them. An extended
    practice in MobX (and also Redux or Flux) apps is to create a file named `actions.js`,
    where we will store all the actions modifying business logic for our app.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中将有两种类型的动作：影响特定组件状态的动作和影响一般应用程序状态的动作。我们希望将后者存储在组件代码之外的某个地方，这样我们可以重用并轻松维护它们。在MobX（以及Redux或Flux）应用程序中的一种常见做法是创建一个名为`actions.js`的文件，我们将在其中存储修改应用程序业务逻辑的所有动作。
- en: 'In the case of our RSS reader, the business logic revolves around feeds and
    entries, so we will capture all the logic dealing with these models in this file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的RSS阅读器中，业务逻辑围绕订阅源和条目展开，因此我们将在此文件中捕获处理这些模型的所有逻辑。
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since actions modify the general app state, they will need to access the store.
    Let''s take a look at each action separately:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作修改了应用程序的一般状态，它们将需要访问存储。让我们分别看看每个动作：
- en: '`fetchFeed`: When a user wants to add a feed to the RSS reader, he will need
    to pass the URL, so the app can download the details for that feed (feed title,
    list of latest entries, and when it was updated for the last time). This action
    is responsible for retrieving this data (formatted as an XML document) from the
    supplied URL and transforming that data into a JSON object with a standard format
    for the app. Fetching the data from the supplied URL will be performed by `fetch`,
    a built-in library in React Native, which is used to make HTTP requests to any
    URL. Since `fetch` supports promises, we will use async/await to handle the asynchronous
    behavior and simplify our code. Once the XML document containing the feed''s data
    is retrieved, we will convert that data into a JSON object using `simple-xml2json`,
    a very lightweight library for this kind of needs. Finally, the action returns
    a JSON object containing only the data we will really need in our app (title,
    entries, and last update time).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchFeed`：当用户想要将订阅源添加到RSS阅读器时，他将需要传递URL，以便应用程序可以下载该订阅源的详细信息（订阅源标题、最新条目列表以及上次更新时间）。此动作负责从提供的URL检索此数据（格式化为XML文档），并将该数据转换为应用程序的标准格式的JSON对象。从提供的URL获取数据将由React
    Native中的内置库`fetch`执行，该库用于向任何URL发出HTTP请求。由于`fetch`支持promises，我们将使用async/await来处理异步行为并简化我们的代码。一旦检索到包含订阅源数据的XML文档，我们将使用`simple-xml2json`将该数据转换为JSON对象，这是一种非常轻量级的库，用于这种需求。最后，该动作返回一个仅包含我们在应用程序中真正需要的数据（标题、条目和最后更新时间）的JSON对象。'
- en: '`selectFeed`: Once the user has added one or more feeds to the reader, she
    should be able to select one of them to get the list of the latest entries for
    that feed. This action just saves the details for a specific feed in the store,
    so it can be used by any screen interested in displaying data related to that
    feed (that is, the `FeedDetail` screen).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectFeed`：一旦用户向阅读器添加了一个或多个订阅源，她应该能够选择其中一个以获取该订阅源的最新条目列表。此动作只是将特定订阅源的详细信息保存在存储中，以便任何对显示与该订阅源相关的数据感兴趣的屏幕（即`FeedDetail`屏幕）可以使用它。'
- en: '`selectEntry`: Similar to `selectFeed`, a user should be able to select one
    of the entries in a feed to get the details for that specific entry. In this case,
    the screen displaying that data will be `EntryDetail` as we will see in a later
    section.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectEntry`：类似于`selectFeed`，用户应该能够选择订阅源中的条目之一，以获取该特定条目的详细信息。在这种情况下，显示该数据的屏幕将是`EntryDetail`，我们将在后面的部分中看到。'
- en: '`addFeed`: This action requires two parameters: the URL for a feed and the
    feed''s detail. These parameters will be used to store the feed in the list of
    saved feeds so that it will be available globally in our app. In the case of this
    app, we decided to use the URL as the key which stores the details for the feed,
    as it is a unique property of any RSS feed.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addFeed`：这个动作需要两个参数：订阅的URL和订阅的详细信息。这些参数将用于将订阅存储在保存的订阅列表中，以便在我们的应用中全局可用。在这个应用的情况下，我们决定使用URL作为存储订阅详细信息的键，因为它是任何RSS订阅的唯一属性。'
- en: '`removeFeed`: A user can also decide that they don''t want a specific feed
    in the RSS reader anymore and therefore we need an action to remove the feed from
    the list of feeds. This action only requires the URL for the feed to be passed
    as a parameter, since we stored the feed using the URL as an ID to uniquely identify
    the feed.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeFeed`：用户还可以决定他们不再想在RSS阅读器中看到特定的订阅，因此我们需要一个动作来从订阅列表中移除该订阅。这个动作只需要传递订阅的URL作为参数，因为我们使用URL作为ID来唯一标识订阅。'
- en: Networking in React Native
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native中的网络操作
- en: Most mobile apps need to fetch and update data from an external URL. There are
    several npm modules, which can be used in React Native to communicate and download
    remote resources such as Axios or SuperAgent. If you are familiar with a specific
    HTTP library, you can use it in your React Native projects (as long as is not
    dependent on any browser specific APIs), although a safe and proficient option
    is to use `Fetch`, the built-in networking library in React Native.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数移动应用需要从外部URL获取和更新数据。在React Native中可以使用几个npm模块来通信和下载远程资源，比如Axios或SuperAgent。如果你熟悉特定的HTTP库，你可以在React
    Native项目中使用它（只要不依赖于任何特定于浏览器的API），尽管一个安全和熟练的选择是使用`Fetch`，这是React Native中内置的网络库。
- en: '`Fetch` is very similar to `XMLHttpRequest`, so it will feel familiar to any
    web developers who had to perform AJAX requests from the browser. On top of that,
    `Fetch` supports promises and the ES2017 async/await syntax.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fetch`非常类似于`XMLHttpRequest`，因此对于任何需要从浏览器执行AJAX请求的web开发人员来说都会感到熟悉。除此之外，`Fetch`支持promises和ES2017的async/await语法。'
- en: The full documentation for the `Fetch` API can be found on Mozilla Developer
    Networks website [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fetch` API的完整文档可以在Mozilla开发者网络网站上找到[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。'
- en: By default, iOS will block any request that's not encrypted using SSL. If you
    need to fetch from a cleartext URL (one that begins with `http` instead of `https`),
    you will first need to add an **App Transport Security** (**ATS**) exception.
    If you know ahead of time what domains you will need access to, it is more secure
    to add exceptions just for those domains; if the domains are not known until runtime,
    you can disable ATS completely. Note, however, that from January 2017, Apple's
    App Store review will require reasonable justification for disabling ATS. See
    Apple's documentation for more information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，iOS将阻止任何未使用SSL加密的请求。如果您需要从明文URL（以`http`开头而不是`https`）获取数据，您首先需要添加一个**App
    Transport Security**（**ATS**）异常。如果您事先知道需要访问哪些域名，为这些域名添加异常更安全；如果域名直到运行时才知道，您可以完全禁用ATS。然而，请注意，从2017年1月起，苹果的App
    Store审核将要求合理的理由来禁用ATS。更多信息请参阅苹果的文档。
- en: Creating our app's entry point
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们应用的入口点
- en: 'All React Native apps have one entry file: `index.js`,  we will delegate the
    root of the component''s tree to our `src/main.js` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的React Native应用都有一个入口文件：`index.js`，我们将把组件树的根委托给我们的`src/main.js`文件：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will also register our app with the operating system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在操作系统中注册我们的应用。
- en: 'Now, let''s take a look at the `src/main.js` file to understand how we will
    set up navigation and start up our component''s tree:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下 `src/main.js` 文件，了解我们将如何设置导航并启动我们的组件树：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will use `react-navigation` as our navigator library and `StackNavigator`
    as our navigation pattern. Add each of our screens to the `StackNavigator` function
    to generate our `<Navigator>`. All this is very similar to the navigation pattern we
    used in [Chapter 1](51ac8f19-54e1-4917-b9f6-3b7df132cf3f.xhtml), *Shopping List*,
    but we incorporated an improvement to it: we are passing `store` in the `screenProps`
    property for our `<Navigator>`, instead of directly passing the attributes and
    methods to modify our app''s state. This simplifies and cleans up the code base
    and as we will see in later sections, it will free us from notifying the navigation
    every time our state changes. All these improvements come for free thanks to MobX.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `react-navigation` 作为我们的导航库，`StackNavigator` 作为我们的导航模式。将每个屏幕添加到 `StackNavigator`
    函数中以生成我们的 `<Navigator>`。所有这些都与我们在[第 1 章](51ac8f19-54e1-4917-b9f6-3b7df132cf3f.xhtml)中使用的导航模式非常相似，但我们对其进行了改进：我们将
    `store` 作为 `<Navigator>` 的 `screenProps` 属性传递，而不是直接传递属性和方法来修改我们应用程序的状态。这简化和清理了代码库，并且正如我们将在后面的部分中看到的那样，它将使我们摆脱每次状态更改时通知导航的负担。所有这些改进都是由于
    MobX 而免费获得的。
- en: Building the FeedsList screen
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 FeedsList 屏幕
- en: 'The list of feeds will be used as the home screen for this app, so let''s focus
    on building the list of the feeds'' titles:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: feeds 列表将作为此应用的主屏幕使用，因此让我们专注于构建 feeds 标题列表：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This component expects to receive the list of feeds from `this.props.screenProps.store` and
    then iterates over that list building a NativeBase `<List>`, showing the titles
    for each of the feeds on the store.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件期望从 `this.props.screenProps.store` 接收 feeds 列表，然后遍历该列表构建一个 NativeBase `<List>`，显示存储中每个
    feed 的标题。
- en: 'Let''s introduce some MobX magic now. As we want our component to be re-rendered
    when the list of feeds changes (when a feed is added or removed), we have to mark
    our component with the `@observer` decorator. MobX will automatically force the
    component re-rendering on any update. Let''s see now how to add the decorator
    to our component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在介绍一些 MobX 的魔法。由于我们希望当 feeds 列表发生变化时（添加或删除 feed 时）我们的组件能够重新渲染，因此我们必须使用 `@observer`
    装饰器标记我们的组件。MobX 将自动在任何更新时强制组件重新渲染。现在让我们看看如何将装饰器添加到我们的组件中：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's it. Now, our component will be notified when the store is changed and
    a re-render will be triggered.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，我们的组件将在存储更改时收到通知，并将触发重新渲染。
- en: Adding event handlers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加事件处理程序
- en: 'Let''s add an event handler to be triggered when the user taps on one of the
    feed''s titles so the list of entries for that feed is displayed on a new screen
    (`FeedDetail`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个事件处理程序，当用户点击 feed 标题时，将在新屏幕（`FeedDetail`）上显示该 feed 的条目列表：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For this, we added a method to our component named `_handleFeedPress`, which
    will receive the feed detail as a parameter. When this method is called, it will
    run the action `selectFeed` and will trigger a navigation event passing the feed's
    URL as a property, so the next screen (`FeedDetail`) can include a button to delete
    the feed based on that URL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们在组件中添加了一个名为 `_handleFeedPress` 的方法，该方法将接收 feed 的详细信息作为参数。当调用此方法时，它将运行 `selectFeed`
    动作，并将传递 feed 的 URL 作为属性触发导航事件，以便下一个屏幕（`FeedDetail`）可以根据该 URL 包含一个删除 feed 的按钮。
- en: 'Finally, we will add `navigationOptions`, including the title for the navigation
    header and the button to add a feed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加 `navigationOptions`，包括导航标题和添加 feed 的按钮：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pressing the `AddFeed` button will navigate to the `AddFeed` screen. This button
    will be displayed to the right of the navigation header by passing it as a property
    named `headerRight` in the `navigationOptions`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按下`AddFeed`按钮将导航到`AddFeed`屏幕。通过将它作为名为`headerRight`的属性传递给`navigationOptions`，该按钮将显示在导航标题的右侧。
- en: 'Let''s see how this component looks all together:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个组件是如何一起的：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have our list of feeds fully functional, let's allow the users to
    add some feeds through the `AddFeed` screen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的feeds列表功能完全可用，让我们允许用户通过`AddFeed`屏幕添加一些feeds。
- en: Building the AddFeed screen
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建AddFeed屏幕
- en: This screen consists of a basic form, including one `<Input>` for the URL from
    the feed and a `<Button>` to retrieve the feed information from the provided URL
    to later store the feed's details in our store.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该屏幕包括一个基本表单，包括一个用于从feed获取URL的`<Input>`和一个用于从提供的URL检索feed信息以后将feed的详细信息存储在我们的存储中的`<Button>`。
- en: 'We will need to import two actions ( `addFeed` and `fetchFeed` ), which will
    be called once the `Add` button is pressed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入两个操作（`addFeed`和`fetchFeed`），这两个操作将在按下`Add`按钮时被调用：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Most of the functionality in this component is in `_handleAddPress` as it is
    the handler, which will be triggered once the `Add` button is pushed. This handler
    is responsible for four tasks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中大部分功能都在`_handleAddPress`中，因为它是处理程序，一旦按下`Add`按钮就会被触发。这个处理程序负责四个任务：
- en: Checking there is a URL present to retrieve data from
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否存在URL以检索数据
- en: Retrieving the feed data from the provided URL (through the `fetchFeed` action)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从提供的URL检索feed数据（通过`fetchFeed`操作）
- en: Saving that data into the app's state (through the `addFeed` action)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到应用程序状态中（通过`addFeed`操作）
- en: Alerting the user if something went wrong when fetching or saving the data.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取或保存数据时，向用户发出警告。
- en: One important thing to note is how the  `fetchFeed` action is used. Since it
    was declared with the `async` syntax, we can use it as a promise and attach it
    to the result of its listeners for `then` and `catch`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件重要的事情是`fetchFeed`操作的使用方式。由于它是用`async`语法声明的，我们可以将它用作一个promise，并将它附加到其监听器的结果上，用于`then`和`catch`。
- en: ActivityIndicator
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActivityIndicator
- en: It is a good practice to display a spinner every time the app needs to wait
    for a response to an HTTP request. Both iOS and Android have standard activity
    indicators to display this behavior and both are available through the `<ActivityIndicator>`
    component in React Native's module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次应用程序需要等待HTTP请求的响应时显示一个旋转器是一个很好的做法。iOS和Android都有标准的活动指示器来显示这种行为，两者都可以通过React
    Native模块中的`<ActivityIndicator>`组件获得。
- en: 'The easiest way to display this indicator is by keeping a `loading` flag in
    the component state. Since this flag is only used by our component to display
    this `<ActivityIndicator>`, it makes sense to have it inside the component''s
    state instead of moving it to the general app''s state. Then, it can be used inside
    the `render` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 显示这个指示器的最简单方法是在组件状态中保持一个`loading`标志。由于这个标志只被我们的组件用来显示这个`<ActivityIndicator>`，所以把它放在组件的状态中而不是移动到通用的应用程序状态中是有意义的。然后，它可以在`render`函数中使用：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This syntax is very common in React apps for displaying or hiding components
    based on flags or simple conditions. It takes advantage of the way JavaScript
    evaluates the `&&` operations: check truthiness of the first operand, if truthy,
    returns the second operator; otherwise, it returns the first operator. This syntax
    saves lines of code on a very common kind of instructions and therefore it will
    be widely used throughout this book.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法在React应用程序中非常常见，用于根据标志或简单条件显示或隐藏组件。它利用了JavaScript评估`&&`操作的方式：检查第一个操作数的真实性，如果为真，则返回第二个操作数；否则，返回第一个操作数。这种语法在一种非常常见的指令上节省了代码行数，因此它将在本书中广泛使用。
- en: Building the FeedDetail screen
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建`FeedDetail`屏幕
- en: 'Let''s recap what happened when the user tapped on one feed on the `FeedsList`
    screen:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下当用户在`FeedsList`屏幕上点击一个 feed 时发生了什么：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `navigate` method was called on the `navigation` property to open the `FeedDetail`
    screen. As a parameter, the `_handleFeedPress` function passed `feedUrl`, so it
    can retrieve the feed data and display it to the user. This is a necessary step
    since the data we have in our store for the selected feed can be obsolete. So,
    it's better to re-fetch that data before showing it to the user so we are sure
    it's 100% updated. We could also do a more complex check instead of retrieving
    the whole feed every time the user selects a feed, but we will stay with the given approach
    in order to keep simplicity in this app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`navigation`属性上调用了`navigate`方法，以打开`FeedDetail`屏幕。作为参数，`_handleFeedPress`函数传递了`feedUrl`，这样它就可以检索
    feed 数据并显示给用户。这是一个必要的步骤，因为我们在存储中为所选的 feed 拥有的数据可能已经过时。因此，在向用户显示之前，最好重新获取数据，以确保它是100%更新的。我们也可以进行更复杂的检查，而不是每次用户选择
    feed 时都检索整个 feed，但为了保持这个应用程序的简单性，我们将坚持采用给定的方法。
- en: 'Let''s start by retrieving the updated list of entries in the `componentWillMount`
    method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`componentWillMount`方法中检索更新后的条目列表开始：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will mark our component as `@observer` so that it get''s updated every time
    the selected feed changes. Then, we need a state with two properties:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的组件标记为`@observer`，这样它就会在所选的 feed 改变时得到更新。然后，我们需要一个具有两个属性的状态：
- en: '`loading`: This is a flag to signal to the user that we are fetching the updated
    feed''s data'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`：这是一个标志，用来向用户表示我们正在获取更新的数据'
- en: '`entry`: This is the list of entries to be displayed to the user'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`：这是要显示给用户的条目列表'
- en: 'Then, before the component is mounted, we want to start the retrieval of the
    updated entries. For this matter, we can reuse the `fetchFeed` action we used
    in the `AddFeed` screen. When the feed data is received, the `loading` flag in
    the component''s state is set to `false`, which will hide `<ActivityIndicator>`
    and the entries list for the feed will be set in the component''s state. Now that
    we have a list of entries, let''s take a look at how we will display it to the
    user:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在组件挂载之前，我们想要开始检索更新后的条目。为此，我们可以重用在`AddFeed`屏幕中使用的`fetchFeed`操作。当接收到 feed 数据时，组件状态中的`loading`标志被设置为`false`，这将隐藏`<ActivityIndicator>`，并且条目列表将被设置在组件状态中。现在我们有了一个条目列表，让我们看看我们将如何向用户显示它：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `&&` syntax is used again to display `<ActivityIndicator>` until the data
    is retrieved. Once the data is available and properly stored in, the `entry` property
    inside our component's state, we will render the list items containing the entries
    titles for the selected field.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 语法再次被用来显示`<ActivityIndicator>`，直到数据被检索出来。一旦数据可用并且正确存储在组件状态的`entry`属性中，我们将渲染包含所选字段条目标题的列表项。'
- en: 'Now, we will add an event handler which will be triggered when a user taps
    on one of the entries'' titles:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个事件处理程序，当用户点击条目标题时将被触发：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This handler is named `_handleEntryPress` and is responsible for two tasks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序被命名为`_handleEntryPress`，负责两个任务：
- en: Marking the tapped entry as selected
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将点击的条目标记为已选
- en: Navigating to `EntryDetail`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到`EntryDetail`
- en: 'To finalize the component, let''s add the navigation header through the `navigationOptions`
    method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过`navigationOptions`方法添加导航标题：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Besides adding the title for this screen (the feed's title), we want to add
    an icon to the navigation for the user to be able to remove the feed from the
    stored list of feeds in the app. We will use the `trash` icon of `native-base`
    for this purpose. When it's pressed, the `removeFeed` action will be called passing
    the URL for the current feed URL, so it can be deleted from the store, then it
    will force the navigation to go back to the `FeedList` screen.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为这个屏幕添加标题（feed的标题）之外，我们还希望为用户的导航栏添加一个图标，以便用户能够从应用程序中存储的feed列表中删除该feed。我们将使用`native-base`的`trash`图标来实现这个目的。当按下时，将调用`removeFeed`动作，传递当前feed
    URL，以便可以从存储中删除，然后将强制导航返回到`FeedList`屏幕。
- en: 'Let''s take a look at the finished component:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看完成的组件：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s move on to the last screen: `EntryDetail`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到最后一个屏幕：`EntryDetail`。
- en: Building the EntryDetail screen
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建EntryDetail屏幕
- en: 'The `EntryDetail` screen is just WebView: a component-abled rendering web content
    in a native view. You can think of a WebView as a lightweight web browser displaying
    the contents of a website for a provided URL:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntryDetail`屏幕只是一个WebView：一个能够在原生视图中呈现web内容的组件。您可以将WebView视为一个轻量级的web浏览器，显示提供的URL的网站内容：'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `render` method in this component is merely returning a new `WebView` component
    loading the URL from the selected entry inside the store. As we did with the feed''s
    data in the previous sections, we need to retrieve the `selectedEntry` data from `this.props.screenProps.store`.
    The URL can be stored in two different ways depending on the RSS version of the
    feed: in the link property or one level deeper in `link.href`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中的`render`方法只是返回一个新的`WebView`组件，加载存储中所选条目的URL。就像我们在前面的部分中对feed的数据所做的那样，我们需要从`this.props.screenProps.store`中检索`selectedEntry`数据。URL可以以两种不同的方式存储，这取决于feed的RSS版本：在链接属性中或者在`link.href`中再深一层。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A state management library becomes necessary in every app when its complexity
    starts to grow. As a rule of thumb, it's a good idea to add a state management
    library when the app is comprised of more than four screens and they share information
    between them. For this app, we used MobX, which is simple but powerful enough
    to handle all the feeds and entries' data. In this chapter, you learned the basics
    of MobX and how to use it in conjunction of `react-navigation`. It's important
    to understand the concept of actions and stores, as we will use them in future
    apps not only built around MobX but also on Redux.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的复杂性开始增长时，每个应用程序都需要一个状态管理库。作为一个经验法则，当应用程序由四个以上的屏幕组成并且它们之间共享信息时，添加状态管理库是一个好主意。对于这个应用程序，我们使用了MobX，它简单但足够强大，可以处理所有的订阅和条目数据。在本章中，您学习了MobX的基础知识以及如何与`react-navigation`一起使用它。重要的是要理解动作和存储的概念，因为我们将在未来的应用程序中使用它们，不仅建立在MobX周围，还建立在Redux周围。
- en: You also learned how to fetch data from a remote URL. This is a very common
    action in most of the mobile apps, although we only covered the basic usage of
    it. In the following chapters, we will dive deeper into the `Fetch` API. Moreover,
    we saw how to process and format the fetched data to formalize it within our app.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何从远程URL获取数据。这是大多数移动应用程序中非常常见的操作，尽管我们只涵盖了它的基本用法。在接下来的章节中，我们将深入研究`Fetch`
    API。此外，我们还看到了如何处理和格式化获取的数据，以便在我们的应用程序中加以规范化。
- en: Finally, we reviewed what a WebView is and how we can insert web content into
    our native app. This can be done using local HTML strings or remotely through
    the URL, so it's a very powerful trick used by mobile developers to reuse or access
    web-only content.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了什么是WebView以及如何将web内容插入到我们的原生应用程序中。这可以通过本地HTML字符串或通过URL远程完成，因此这是移动开发人员用来重用或访问仅限于web的内容的一个非常强大的技巧。
