- en: E-Commerce App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子商务应用
- en: Online shopping is something most retailers have adopted, but users are slowly
    migrating from websites to mobile apps. That's why e-commerce has set a strong
    focus on responsive websites, which can be seamlessly accessed from a desktop
    computer or a mobile browser. Along with that, users also demand higher standards
    of quality which cannot always be met by even the most responsive websites. Loading
    times, laggy animations, non-native components, or a lack of native features may
    hurt user experiences resulting in low conversion rates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在线购物是大多数零售商采用的一种方式，但用户正在从网站慢慢迁移到移动应用。这就是为什么电子商务对响应式网站进行了强调，这些网站可以从台式电脑或移动浏览器无缝访问。除此之外，用户还要求更高的质量标准，这些标准甚至响应最高的网站也不能总是满足。加载时间长、动画卡顿、非本地组件或缺乏本地功能可能会影响用户体验，导致低转化率。
- en: Building our e-commerce app in React Native can reduce the development efforts
    required due to the possibility of reusing some web components, which were already
    designed for the web (using React.js). Besides that, we can reduce the time to
    market and development costs, making React Native a very attractive tool for small
    and medium-sized businesses willing to sell their products or services online.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中构建我们的电子商务应用可以减少开发工作量，因为可以重用一些已经为Web设计的Web组件（使用React.js）。除此之外，我们可以减少上市时间和开发成本，使React
    Native成为中小型企业愿意在线销售其产品或服务的非常有吸引力的工具。
- en: In this chapter, we will focus on building a bookstore for iOS and Android reusing
    100% of our code. Despite focusing on a bookstore, the same codebase could be
    reused to sell any kind of products just by replacing the products list.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注构建一个书店，用于iOS和Android，重复使用我们100%的代码。尽管专注于书店，但同一代码库可以通过替换产品列表来重复使用以销售任何类型的产品。
- en: To free us from building an API for this app, we will mock all the data behind
    a fake API service. The state management library we will use for this app will
    be Redux and its middleware `redux-thunk` to handle asynchronous calls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们摆脱为此应用程序构建API的负担，我们将模拟所有数据在一个虚假的API服务后面。我们将为此应用程序使用Redux及其中间件`redux-thunk`来处理异步调用的状态管理库。
- en: Asynchronous calls and redux-thunk were already explained in [Chapter 4](377902fe-8517-4d67-b0c2-3bc5648b4aa0.xhtml),
    *Image Sharing App*. It may be useful to review its usage in that chapter to reinforce
    the main concepts before moving into the Actions sections in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 异步调用和redux-thunk已经在[第4章](377902fe-8517-4d67-b0c2-3bc5648b4aa0.xhtml) *图像分享应用*中进行了解释。在进入本章的操作部分之前，回顾一下在该章节中的使用可能是有用的，以加强主要概念。
- en: Navigation will be handled by `react-navigation` as it is the most complete
    and performant navigation library in React Native developed to date. Finally,
    we will use some very useful libraries, especially for e-commerce apps, such as `react-native-credit-card-input`,
    which handles credit card inputs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 导航将由`react-navigation`处理，因为它是迄今为止在React Native中开发的最完整和性能最佳的导航库。最后，我们将使用一些非常有用的库，特别是对于电子商务应用，比如`react-native-credit-card-input`，它处理信用卡输入。
- en: While building this app, we will emphasize several quality aspects to make sure
    the app is production-ready by the end of the chapter. For example, we will use
    type validation extensively for properties and code linting.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建此应用程序时，我们将强调几个质量方面，以确保应用程序在本章结束时已经准备投入生产。例如，我们将广泛使用类型验证来验证属性和代码清理。
- en: Overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Instead of putting much effort into the app's look and feel, as we did in previous
    chapters, we will focus on functionality and code quality for this one. Nevertheless,
    we will build it in a way which will allow any developer to style it easily at
    a later stage. With that in mind, let's take a look at what the app will look
    like once finished.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节不同，我们不会花太多精力在应用程序的外观和感觉上，而是专注于功能和代码质量。尽管如此，我们将以一种方式构建它，以便任何开发人员都可以在以后轻松地为其添加样式。有了这个想法，让我们来看看完成后应用程序的样子。
- en: 'Let''s start from the home screen where all the books are displayed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从主屏幕开始，显示所有的书籍：
- en: '![](Images/35d223a1-9081-46a0-8a74-f23d43e13360.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/35d223a1-9081-46a0-8a74-f23d43e13360.png)'
- en: 'In Android, we will add a drawer navigation pattern instead of a tabbed one
    as Android users are more used to it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们将添加一个抽屉导航模式，而不是选项卡模式，因为Android用户更习惯于它：
- en: '![](Images/e509bfbc-76aa-4c7c-91e3-82f44799e3c7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e509bfbc-76aa-4c7c-91e3-82f44799e3c7.png)'
- en: 'The drawer can be opened by swiping the screen from the left edge to the right:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉可以通过从左边缘向右滑动屏幕来打开：
- en: '![](Images/eab6735d-bb99-4584-9320-cb66e6699cbc.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/eab6735d-bb99-4584-9320-cb66e6699cbc.png)'
- en: 'Now, let''s see what happens when a user taps on one of the books from the
    home screen (list of books available):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当用户点击主屏幕上的一本书时会发生什么（可用书籍列表）：
- en: '![](Images/00265d03-c3d9-48d9-b6fa-41d1ca088047.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/00265d03-c3d9-48d9-b6fa-41d1ca088047.png)'
- en: 'The Android version for this screen will be similar, as only a couple of native
    components will adopt a different styling, depending on which platform the app
    is executed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕的Android版本将是类似的，因为只有一些本地组件会根据应用程序执行的平台不同而采用不同的样式：
- en: '![](Images/dd9bd883-85d8-4171-b83b-746b52d0b546.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dd9bd883-85d8-4171-b83b-746b52d0b546.png)'
- en: 'Only logged-in users will be able to buy books from our app. This means that
    we need to pop up a login/registration screen at a certain point, and clicking
    on the BUY! button seems like an appropriate moment for this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只有登录用户才能从我们的应用程序购买书籍。这意味着我们需要在某个时候弹出登录/注册屏幕，点击“购买！”按钮似乎是一个合适的时机：
- en: '![](Images/fd7a6b32-2641-4a77-8a21-33851ddc5ef0.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fd7a6b32-2641-4a77-8a21-33851ddc5ef0.png)'
- en: 'In this case, the Android version will look different from the iOS because
    of the difference in styles between native buttons on each platform:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Android版本将与iOS版本看起来不同，因为每个平台上本机按钮的样式不同：
- en: '![](Images/2a40e2ee-0ca2-44a5-9e07-3303edebf0af.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2a40e2ee-0ca2-44a5-9e07-3303edebf0af.png)'
- en: 'For testing purposes, we created a test account in this app with the following
    credentials:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，在这个应用程序中我们创建了一个测试帐户，具有以下凭据：
- en: 'e-mail: `test@test.com`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件：`test@test.com`
- en: 'password: `test`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：`test`
- en: 'In case the user still doesn''t have an account, she will be able to click
    on the OR REGISTER button to create one:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户还没有帐户，她将能够点击“或注册”按钮来创建一个：
- en: '![](Images/f1c5c3ea-c226-4389-b911-27d3f8762d3b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f1c5c3ea-c226-4389-b911-27d3f8762d3b.png)'
- en: 'This form will include the following validations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单将包括以下验证：
- en: e-mail and repeat e-mail field values match
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件和重复电子邮件字段的值匹配
- en: All the fields are entered
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有字段都已输入
- en: 'In case any of these validations fail, we will display an error message at
    the bottom of this screen:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些验证中有任何失败，我们将在此屏幕底部显示错误消息：
- en: '![](Images/b99f89e2-e60f-4660-9d9f-3bdf55f6fea4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b99f89e2-e60f-4660-9d9f-3bdf55f6fea4.png)'
- en: 'After registering, the user will be logged in automatically and will be able
    to continue her purchase journey by reviewing her cart:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，用户将自动登录，并可以通过查看购物车来继续购买旅程：
- en: '![](Images/866c27f0-574b-4849-aa0c-e52bc0ea5ce5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/866c27f0-574b-4849-aa0c-e52bc0ea5ce5.png)'
- en: 'Again, the Android version will show small differences in the looks of this
    screen:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Android版本将在此屏幕的外观上显示细微差异：
- en: '![](Images/7e7acaf7-3ef6-4504-850f-3109090f8fbf.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7e7acaf7-3ef6-4504-850f-3109090f8fbf.png)'
- en: By clicking on the KEEP BUYING button on this screen, the user will be sent
    back to the home screen where all the available books are displayed for her to
    continue adding items to her cart.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击此屏幕上的“继续购买”按钮，用户将被发送回主屏幕，所有可用的书籍都会显示出来，供她继续添加到购物车中。
- en: 'In case she decides to confirm her purchase, the app will display a payment
    screen in which the user can enter her credit card details:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果她决定确认购买，应用程序将显示一个付款屏幕，用户可以在其中输入信用卡详细信息：
- en: '![](Images/5ad5d072-b725-4f89-8b66-bce250083042.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5ad5d072-b725-4f89-8b66-bce250083042.png)'
- en: 'The Pay now button will only be active when all the data has been entered correctly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有数据都输入正确时，“立即付款”按钮才会激活：
- en: '![](Images/7a3462f7-1be7-48f8-a8b9-8ee78512443c.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7a3462f7-1be7-48f8-a8b9-8ee78512443c.png)'
- en: 'For testing purposes, the developers can use the following credit card data:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，开发人员可以使用以下信用卡数据：
- en: 'Card number: `4111 1111 1111 1111`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡号：`4111 1111 1111 1111`
- en: 'Date of expiration: any date in the future'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到期日期：未来的任何日期
- en: 'CVC/CVV: `123`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CVC/CVV：`123`
- en: 'Once the payment has gone through, the user will receive a confirmation of
    her purchase detailing all the items which will be sent to her address:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦付款完成，用户将收到一份确认购买的确认，详细列出将发送到她地址的所有物品：
- en: '![](Images/6e87bdd5-c49c-4d41-9748-cb23c1c3155b.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6e87bdd5-c49c-4d41-9748-cb23c1c3155b.png)'
- en: This screen will finish the purchase journey. At this stage, the user can click
    on the Continue Shopping button to go back to the list of available products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕将完成购买旅程。在这个阶段，用户可以点击“继续购物”按钮，返回到可用产品列表。
- en: 'There are two more journeys available through the tabbed/drawer navigation.
    The first one is to the My Profile section to review her account details or Logout:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选项卡/抽屉导航还有两个可用的旅程。第一个是到“我的个人资料”部分，以查看她的账户详细信息或注销：
- en: '![](Images/7d246216-405b-4448-8de7-8b05b90a273f.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7d246216-405b-4448-8de7-8b05b90a273f.png)'
- en: If the user still didn't log in, the app will show the login/register form on
    this screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户还没有登录，应用程序将在此屏幕上显示登录/注册表单。
- en: 'The last journey is accessed through the Sales tab/menu item:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个旅程是通过销售选项卡/菜单项访问的：
- en: '![](Images/728b0175-6837-4357-9974-73998e5c0539.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/728b0175-6837-4357-9974-73998e5c0539.png)'
- en: By pressing Add to cart, the user will be sent directly to the purchase journey
    where she can add more items to the cart or directly confirm the purchase by entering
    her login (if not present) and payment details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“添加到购物车”按钮，用户将直接进入购买旅程，在那里她可以添加更多的物品到购物车，或者直接确认购买，输入她的登录（如果不存在）和付款详细信息。
- en: 'Lastly, every time we need to receive data from the backend API, we will display
    a spinner to let the user know there is some activity happening in the background:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当我们需要从后端API接收数据时，我们将显示一个旋转器，让用户知道后台有一些活动正在进行：
- en: '![](Images/85b9c5c9-85ef-4a28-88cf-8c9949f8e628.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/85b9c5c9-85ef-4a28-88cf-8c9949f8e628.png)'
- en: Since we will mock all the API calls, we will need to add a small delay to their
    responses in order to see the spinners, so the developers can have a similar experience
    as users will have, when we replace the mocked up calls for real API requests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将模拟所有的API调用，我们需要在它们的响应中添加一些小的延迟，以便看到旋转器，这样开发人员就可以像用户一样拥有类似的体验，当我们用真实的API请求替换模拟的调用时。
- en: Setting up the folder structure
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'This app will use Redux, as its state management library, which will define
    the folder structure we will be using throughout this chapter. Let''s start by
    initializing the project through React Native''s CLI:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用将使用Redux作为其状态管理库，这将定义我们在本章中将使用的文件夹结构。让我们通过React Native的CLI来初始化项目：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we have seen in previous chapters where we used Redux, we need our folder
    structure to accommodate different module types:  `reducers`, `actions`, `components`, `screens`, and `api` calls.
    We will do this in the following folder structure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中看到的，我们使用Redux，我们需要我们的文件夹结构来容纳不同的模块类型：`reducers`、`actions`、`components`、`screens`和`api`调用。我们将在以下文件夹结构中完成这一点：
- en: '![](Images/f421a392-a486-4146-aa7f-b4ca0f63b299.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f421a392-a486-4146-aa7f-b4ca0f63b299.png)'
- en: 'Apart from the folder structure created by React Native''s CLI, we added the
    following folders and files:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React Native的CLI创建的文件夹结构外，我们还添加了以下文件夹和文件：
- en: '`src/components`: This will hold the reusable visual components.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/components`：这将保存可重用的视觉组件。'
- en: '`src/reducers`: This will store the reducers, which modify the state of the
    app by detecting which actions were triggered.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/reducers`：这将存储修改应用程序状态的reducers，通过检测触发了哪些操作。'
- en: '`src/screens`: This will store all the different visual containers connecting
    them to the app state through Redux.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/screens`：这将存储所有不同的视觉容器，通过Redux将它们连接到应用程序状态。'
- en: '`src/api.js`: By the end of the chapter, we will have all the required API
    calls mocked inside this file. In case we wanted to connect to a real API, we
    would just need to change this file to make HTTP requests to the proper endpoints.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/api.js`：在本章结束时，我们将在此文件中模拟所有所需的API调用。如果我们想要连接到真实的API，我们只需要更改此文件以向正确的端点发出HTTP请求。'
- en: '`src/main.js`: This is the entry point to the app and will set up the navigation
    components and initialize the store in which the app''s state will live.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main.js`：这是应用程序的入口点，将设置导航组件并初始化存储应用程序状态的存储。'
- en: 'The `src/components` folder will contain the following files:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/components`文件夹将包含以下文件：'
- en: '![](Images/9d122f1c-c516-4414-9aaf-03e28883928b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9d122f1c-c516-4414-9aaf-03e28883928b.png)'
- en: 'The `src/reducers` will hold the three different data domains in our app: user,
    payment, and products:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/reducers`将保存我们应用程序中的三个不同数据领域：用户、支付和产品：'
- en: '![](Images/de00dfb4-eacb-479f-aaa6-894c70ff8210.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/de00dfb4-eacb-479f-aaa6-894c70ff8210.png)'
- en: 'Last, the `screens` folder will store a file for each of the screens the user
    will be able to see in the app:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`screens`文件夹将存储用户在应用程序中能够看到的每个屏幕的文件：
- en: '![](Images/cf773ca1-d83d-49c0-957b-1f0f067e9e4b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cf773ca1-d83d-49c0-957b-1f0f067e9e4b.png)'
- en: 'Let''s take a look now at the `package.json` file we will use to install all
    required libraries for this app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们将用于安装此应用程序的所有必需库的`package.json`文件：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will be using the following extra libraries for our app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的应用程序使用以下额外的库：
- en: '`native-base`: This is for styled components.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native-base`：这是用于样式化组件。'
- en: '`prop-types`: This is for property validation inside components.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prop-types`：这是用于组件内属性验证。'
- en: '`react-native-credit-card-input`: This is for the user to enter her credit
    card details.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-credit-card-input`：这是供用户输入信用卡详细信息的工具。'
- en: '`react-redux`: This and Redux are used for state management.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-redux`：这个和Redux一起用于状态管理。'
- en: '`redux-thunk`: This is for connecting Redux to asynchronous calls.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux-thunk`：这是用于将Redux连接到异步调用的工具。'
- en: 'Besides all these dependencies, we will add some other `dev` dependencies,
    which will help our developers write code in a very comfortable and confident
    way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些依赖项，我们还将添加一些其他`dev`依赖项，这将帮助我们的开发人员以非常舒适和自信的方式编写代码：
- en: '`babel-eslint`: This is for linting our ES6 code.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel-eslint`：这是用于linting我们的ES6代码。'
- en: '`eslint-config-airbnb`: This is the set of coding styles we will use.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eslint-config-airbnb`：这是我们将使用的一组编码样式。'
- en: '`prettier`: This is the code formatter we will use to support ES6 and JSX.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prettier`：这是我们将使用的代码格式化程序，以支持ES6和JSX。'
- en: 'Having this `package.json` in place, we are ready to install all these dependencies
    by running:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个`package.json`，我们准备通过运行来安装所有这些依赖项：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Before starting to write code let's configure our linting rules and the text
    editor to take full advantage of the code formatting tools we will use in this
    chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，让我们配置我们的代码检查规则和文本编辑器，充分利用本章中将使用的代码格式化工具。
- en: Linting and code formatting
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查和格式化
- en: 'Writing clean, bug-free code is challenging. There are a lot of pitfalls that
    we may face such as indentation, importing/exporting misses, tags not closed,
    and so on. Having to overcome all of them manually is a tough job which can distract
    us from our main purpose: writing functional code. Luckily, there are a handful
    of very useful tools to help us with this task.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编写干净，无错误的代码是具有挑战性的。我们可能会面临许多陷阱，例如缩进，导入/导出错误，标签未关闭等。手动克服所有这些问题是一项艰巨的工作，这可能会让我们分心，远离我们的主要目的：编写功能性代码。幸运的是，有一些非常有用的工具可以帮助我们完成这项任务。
- en: The tools we will be using in this chapter to ensure our code is clean will
    be ESLint ([https://eslint.org/](https://eslint.org/)) and Prettier ([https://github.com/prettier/prettier](https://github.com/prettier/prettier)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将使用的工具来确保我们的代码干净将是ESLint（[https://eslint.org/](https://eslint.org/)）和Prettier（[https://github.com/prettier/prettier](https://github.com/prettier/prettier)）。
- en: ESLint will be in charge of identifying and reporting on patterns found in the
    ES6/JavaScript code, with the goal of making the code more consistent and avoiding
    bugs. For example, ESLint will flag any use of non-declared variables, exposing
    the error while we are writing code instead of waiting until compilation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint将负责识别和报告ES6 / JavaScript代码中发现的模式，其目标是使代码更一致，避免错误。例如，ESLint将标记任何使用未声明变量的情况，暴露错误，而不是等到编译时才发现。
- en: On the other hand, Prettier enforces a consistent code style across your entire
    codebase because it disregards the original styling by parsing it away and reprinting
    it with its own rules that take the maximum line length into account, wrapping
    code when necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Prettier通过解析原始样式并重新打印具有自己规则的代码来强制执行整个代码库的一致代码样式，考虑到最大行长度，在必要时换行。
- en: We can also use ESLint to enforce Prettier code styles directly in our browser.
    Our first step will be to configure ESLint to adapt to the formatting and linting
    rules we want to enforce in our project. In the case of this app, we will follow
    Airbnb's and Prettier's rules as we already installed them as a developer's dependency
    in this project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用ESLint直接在浏览器中强制执行Prettier代码样式。我们的第一步将是配置ESLint以适应我们在项目中要强制执行的格式化和代码检查规则。在这个应用程序的情况下，我们将遵循Airbnb和Prettier的规则，因为我们已经将它们作为开发人员的依赖项安装在这个项目中。
- en: 'To ensure ESLint will use these rules, we will create a `.eslintrc` file containing
    all the options we want to set up when linting:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保ESLint将使用这些规则，我们将创建一个`.eslintrc`文件，其中包含我们在检查时要设置的所有选项：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We won't explore much in how to configure ESLint much in this book as their
    documentation is quite extensive and well explained. For this project, we will
    only need to extend Airbnb's and Prettier's rules while setting the corresponding
    plugins (`react`, `react-native`, `flowtype`, and `prettier`) in the configuration
    file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中深入探讨如何配置ESLint，因为它们的文档非常广泛且解释得很好。对于这个项目，我们只需要在配置文件中设置相应的插件（`react`，`react-native`，`flowtype`和`prettier`）来扩展Airbnb和Prettier的规则。
- en: Setting rules for the linter is a matter of taste, and in case of not having
    had much experience with it, it is always good to start with a set of prebuilt
    rules (such as the Airbnb rules) and modify them one rule at a time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置检查器的规则是一种品味问题，如果没有太多经验，最好从一套预先构建的规则（例如Airbnb规则）开始，并逐个修改它们。
- en: Finally, we would need to configure our code editor to display those rules,
    flag them, and ideally fix them on saving. Visual Studio Code does a very good
    job at integrating these linting/code formatting rules as its ESLint plugin ([https://github.com/Microsoft/vscode-eslint](https://github.com/Microsoft/vscode-eslint))
    does all the work for us. It is highly recommended to enable the `eslint.autoFixOnSave`
    option to ensure the editor fixes all the code formatting issues after saving
    the file we are working on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要配置我们的代码编辑器来显示这些规则，标记它们，并在保存时理想地修复它们。Visual Studio Code在集成这些linting/code格式化规则方面做得非常好，因为它的ESLint插件（[https://github.com/Microsoft/vscode-eslint](https://github.com/Microsoft/vscode-eslint)）为我们做了所有的工作。强烈建议启用`eslint.autoFixOnSave`选项，以确保编辑器在保存我们正在工作的文件后修复所有的代码格式问题。
- en: Now that we have our linting tools in place, let's start writing our app's codebase.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的linting工具，让我们开始编写我们应用程序的代码库。
- en: Indexes and main files
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和主文件
- en: 'Both the iOS and Android platforms will share the same codebase using `src/main.js`
    as an entry point. Therefore, we will change `index.ios.js` and `index.android.js`
    to import `main.js` and initialize the app with that component as a root:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Android平台将使用`src/main.js`作为入口点共享相同的代码库。因此，我们将更改`index.ios.js`和`index.android.js`来导入`main.js`并使用该组件作为根来初始化应用程序：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the same structure we used for all apps sharing codebase throughout
    the book. Our `main.js` file should now initialize the navigation components and
    set up the store we will use to hold the app''s state:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在整本书中共享代码库的所有应用程序所使用的相同结构。我们的`main.js`文件现在应该初始化导航组件并设置我们将用来保存应用状态的存储：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our main navigator (`Navigator`) will be a tabbed navigation on iOS and a drawer
    navigator on Android. This navigator will be the root for the app and will use
    two nested stacked navigators (`ProductsNavigator` and `PurchaseNavigator`), which
    will cover the following journeys:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主导航器（`Navigator`）将在iOS上是一个选项卡导航，在Android上是一个抽屉导航。这个导航器将是应用程序的根，并将使用两个嵌套的堆叠导航器（`ProductsNavigator`和`PurchaseNavigator`），它们将涵盖以下旅程：
- en: '`ProductsNavigator`: ProductList | ProductDetail'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductsNavigator`：ProductList | ProductDetail'
- en: '`PurchaseNavigator`: MyCart | Payment | PaymentConfirmation'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PurchaseNavigator`：MyCart | Payment | PaymentConfirmation'
- en: Each step in each journey is a specific screen in the app.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个旅程中的每一步都是应用程序中的特定屏幕。
- en: Login and registration are not steps in those journeys since they will be treated
    as pop-up screens displaying only if they are needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注册不是这些旅程中的步骤，因为它们将被视为弹出屏幕，只在需要时显示。
- en: 'The last step in this file is in charge of setting up Redux, applying all the
    reducers and middleware (only `redux-thunk` in our case), which will be in place
    for this project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的最后一步是设置Redux，应用所有的reducers和中间件（在我们的情况下只有`redux-thunk`），这将为这个项目做好准备：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once `store` is created, we pass it to the provider in the root of our app to
    make sure the state will be shared among all the screens. Before moving into each
    individual screen, let's create our reducers and actions so that we can have them
    available to be used when building the screens.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`store`被创建，我们将它传递给应用程序的根提供程序，以确保状态将在所有屏幕之间共享。在进入每个单独的屏幕之前，让我们创建我们的reducers和actions，以便在构建屏幕时可以使用它们。
- en: Reducers
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: 'In previous chapters, we split our Redux-specific code (reducers, actions,
    and action creators) in the standard way that is documented in Redux''s documentation.
    To make it easy to maintain in the future, we will use a different approach for
    this app: Redux Ducks ([https://github.com/erikras/ducks-modular-redux](https://github.com/erikras/ducks-modular-redux)).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们按照Redux文档中记录的标准方式拆分了我们的Redux特定代码（reducers、actions和action creators）。为了便于将来的维护，我们将为这个应用使用不同的方法：Redux
    Ducks（[https://github.com/erikras/ducks-modular-redux](https://github.com/erikras/ducks-modular-redux)）。
- en: Redux Ducks is a proposal for bundling together reducers, action types, and
    actions when using Redux. Instead of creating separate folders for reducers and
    actions, they are put together in files based on which kind of functionality they
    handle, reducing the number of files to deal with when implementing new features.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Ducks是在使用Redux时捆绑在一起的减速器、操作类型和操作的提案。它们不是创建减速器和操作的单独文件夹，而是根据它们处理的功能类型将它们放在一起的文件中，从而减少了在实现新功能时需要处理的文件数量。
- en: 'Let''s start with the `products` reducer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`products`减速器开始。
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This file handles all the business logic related to products in our app. Let''s
    review each action creator and how it modifies the state when processed by the
    reducer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件处理了我们应用程序中与产品相关的所有业务逻辑。让我们审查每个操作创建者以及它们在被减速器处理时如何修改状态：
- en: '`addProductToCart()`: This will dispatch the `ADD_TO_CART` action, which will
    be picked up by the reducer. If the provided product is already present in the
    cart inside the state, it will increase the quantity by one item. Otherwise, it
    will insert the product into the cart and set its quantity to one.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addProductToCart()`: 这将分派`ADD_TO_CART`操作，减速器将捕获该操作。如果提供的产品已经存在于状态中的购物车中，它将增加一个项目的数量。否则，它将把产品插入购物车并将其数量设置为一。'
- en: '`removeProductFromCart()`: This action does the opposite to the previous one.
    It decreases the quantity of this product if already present in the cart stored
    in the state. If the quantity of this product is one, the reducer will remove
    the product from the cart.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeProductFromCart()`: 这个操作与上一个操作相反。如果购物车中已经存在该产品，则减少该产品的数量。如果该产品的数量为一，减速器将从购物车中删除该产品。'
- en: '`fetchProducts()`: This is an asynchronous action and therefore will return
    a function for `redux-thunk` to pick it up. It will make a `GET` request (implemented
    by the `get()` function in the `api.json` file) to the API to the `/products`
    endpoint. It will also handle the response from this endpoint, dispatching a `FETCH_SUCCESS`
    action when the request is successfully fulfilled, or a `FETCH_ERROR` action in
    case the request is errored out.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchProducts()`: 这是一个异步操作，因此将返回一个函数供`redux-thunk`使用。它将向API的`/products`端点发出`GET`请求（由`api.json`文件中的`get()`函数实现）。它还将处理来自该端点的响应，在请求成功完成时分派一个`FETCH_SUCCESS`操作，或者在请求出错时分派一个`FETCH_ERROR`操作。'
- en: '`resetCart()`: This dispatches a `RESET_CART` action, which will be used by
    the reducer to clear all the cart details from the state.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetCart()`: 这将分派一个`RESET_CART`操作，减速器将使用它来从状态中清除所有购物车详细信息。'
- en: As we are following Redux Ducks recommendation, all these actions are put together
    in the same file making it easy to determine what actions do and what effect they
    cause in the application state.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循Redux Ducks的建议，所有这些操作都放在同一个文件中，这样很容易确定操作的作用以及它们对应用状态造成的影响。
- en: 'Let''s move now to the next reducer: the `user` reducer:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到下一个减速器：`user`减速器：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The action creators in this reducer are quite straightforward:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个减速器中的操作创建者非常直接：
- en: '`login()`: This takes an `email` and `password` to dispatch the `LOGIN` action
    and then makes a `POST` request to the `/login` endpoint to validate the credentials.
    If the API call becomes successful, the action creator will dispatch a `LOGIN_SUCCESS`
    action logging the user in. In case the request fails, it will dispatch a `LOGIN_ERROR`
    action so the user can know what happened.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login()`: 这需要一个`email`和`password`来分派`LOGIN`操作，然后向`/login`端点发出`POST`请求以验证凭据。如果API调用成功，操作创建者将分派`LOGIN_SUCCESS`操作以登录用户。如果请求失败，它将分派一个`LOGIN_ERROR`操作，以便用户知道发生了什么。'
- en: '`register()`: This is similar to the `login()` action creator; it will dispatch
    a `REGISTER` action, then a `REGISTER_SUCCESS` or `REGISTER_ERROR`, depending
    on how the API call returns. If the registration was successful, the user data
    will be stored in the application''s state, flagging that the user has logged
    in.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register()`: 这类似于`login()`操作创建者；它将分派一个`REGISTER`动作，然后根据API调用的返回方式分派一个`REGISTER_SUCCESS`或`REGISTER_ERROR`。如果注册成功，用户数据将存储在应用程序状态中，标记用户已登录。'
- en: '`logout()`: This dispatches a `LOGOUT` action, which will make the reducer
    clear the `user` object in the application state.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout()`: 这将分派一个`LOGOUT`动作，这将使减速器清除应用程序状态中的`user`对象。'
- en: 'The last reducer deals with payments data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个减速器处理支付数据：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are only two action creators in this reducer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个减速器中只有两个操作创建者：
- en: '`pay()`: This takes a user, a cart, and a credit card and calls the `/pay`
    endpoint in the API to make a payment. If the payment is successful, it triggers
    a `PAY_SUCCESS` action, otherwise, it triggers a `PAY_ERROR` action to notify
    the user.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pay()`: 这需要一个用户、一个购物车和一个信用卡，并调用API中的`/pay`端点来进行付款。如果付款成功，它会触发一个`PAY_SUCCESS`动作，否则，它会触发一个`PAY_ERROR`动作来通知用户。'
- en: '`resetPayment()`: This clears any payment data by triggering the `RESET_PAYMENT`
    action.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetPayment()`: 通过触发`RESET_PAYMENT`动作来清除任何支付数据。'
- en: We have seen these action creators contact the API in several ways. Let's now
    create some API methods, so the action creators can interact with the application's
    backend.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到这些操作创建者以几种方式联系API。现在让我们创建一些API方法，这样操作创建者就可以与应用程序的后端进行交互。
- en: API
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: 'The API service we will be using will use two HTTP methods (`GET` and `POST`)
    and four endpoints (`/products`, `/login`, `/register`, and `/pay`). We will mock
    up this service for testing and development reasons but will leave the implementation
    open to plug in external endpoints easily at a later stage:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的API服务将使用两种HTTP方法（`GET`和`POST`）和四个端点（`/products`，`/login`，`/register`和`/pay`）。出于测试和开发原因，我们将模拟此服务，但将在以后的阶段留下实现插入外部端点的可能性：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All calls are wrapped inside a `setTimeout()` function with 1-second delays
    to simulate network activity so indicators can be tested. The service only replies
    successfully when credentials are `test@test.com/test`. On the other hand, the
    `pay()` service only returns a successful response when the CVC/CVV code is `123`.
    The register call just returns the provided data as successfully registered user
    data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有调用都包装在一个`setTimeout()`函数中，间隔1秒，以模拟网络活动，以便进行测试。只有当凭据为`test@test.com/test`时，服务才会成功回复。另一方面，`pay()`服务只有在CVC/CVV代码为`123`时才会返回成功的响应。注册调用只是将提供的数据作为成功注册的用户数据返回。
- en: This setTimeout() trick is used to mock asynchronous calls up as they would
    happen with a real backend. It is an useful way to develop front-end solutions
    before the backend or testing environments are ready.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种setTimeout()技巧用于模拟异步调用，就像在真实后端发生的情况一样。这是在后端或测试环境准备好之前开发前端解决方案的有用方式。
- en: Let's now move on to the screens in the application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续应用程序中的屏幕。
- en: ProductList
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表
- en: 'Our home screen displays a list of products available to be purchased:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主屏幕显示了可供购买的产品列表：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Right after this screen is mounted, it will retrieve the latest list of available
    products by invoking `this.props.fetchProducts();`. This will trigger a re-render
    in the screen, so all the available books are displayed on the screen. For that
    to happen, we rely on Redux updating the state (through the product reducer) and
    injecting the new state into this screen by calling the `connect` method, to which
    we will need to pass `mapStateToProps` and `mapStateActionsToProps` functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕挂载后，它将通过调用`this.props.fetchProducts();`来检索最新的可用产品列表。这将触发屏幕重新渲染，因此所有可用的书籍都会显示在屏幕上。为了实现这一点，我们依赖于Redux更新状态（通过产品reducer）并通过调用`connect`方法将新状态注入到此屏幕中，我们需要传递`mapStateToProps`和`mapStateActionsToProps`函数。
- en: '`mapStateToProps` will be in charge of extracting the list of products from
    `state` while `mapStateActionsToProps` will connect each action with the `dispatch()`
    function, which will connect those actions with the Redux state, applying each
    triggered action to all the reducers. In this screen, we are only interested in
    product-related actions, so we will bind only `ProductActions` and the `dispatch`
    function together through the `bindActionCreators` Redux function.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps`将负责从`state`中提取产品列表，而`mapStateActionsToProps`将把每个操作与`dispatch()`函数连接起来，该函数将这些操作与Redux状态连接起来，将每个触发的操作应用于所有reducer。在此屏幕上，我们只对与产品相关的操作感兴趣，因此我们将只通过`bindActionCreators`
    Redux函数将`ProductActions`和`dispatch`函数绑定在一起。'
- en: Inside the `render` method, we use the `map` function to translate the list
    of retrieved products into several `<ListItem/>` components, which will be displayed
    inside `<List/>`. Above this list, we will display `<Spinner/>` while waiting
    for the network request to be fulfilled: `{this.props.loading && <Spinner />}`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们使用`map`函数将检索到的产品列表转换为多个`<ListItem/>`组件，这些组件将显示在`<List/>`内。在此列表上方，我们将显示`<Spinner/>`，同时等待网络请求的完成：`{this.props.loading
    && <Spinner />}`。
- en: 'We also added property validation through the `prop-types` library:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过`prop-types`库添加了属性验证。
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means we will get a warning every time this component receives a wrongly
    typed prop, or it actually fails to receive one of the required props. In this
    case, we expect to receive:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当此组件接收到错误类型的prop时，或者实际上未能接收到所需的prop时，我们将收到警告。在这种情况下，我们期望接收到：
- en: A function named `fetchProducts`, which will request the list of available products
    to the API. It will be provided by Redux through `mapStateActionsToProps` as defined
    on this screen.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`fetchProducts`的函数，它将通过API请求可用产品的列表。它将由Redux通过`mapStateActionsToProps`在此屏幕上定义的方式提供。
- en: A `products` array that contains the list of available products. This will be
    injected by Redux through the previously stated `mapStateToProps` function.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含可用产品列表的`products`数组。这将通过先前提到的`mapStateToProps`函数由Redux注入。
- en: A loading Boolean to flag network activity (also provided by Redux through `mapStateToProps`).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于标记网络活动的加载布尔值（也通过`mapStateToProps`由Redux提供）。
- en: A navigation object provided by `react-navigation` automatically. We mark it
    as type `any` as it is an external object, which may change its type out of our
    control.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由`react-navigation`自动提供的导航对象。我们将其标记为`any`类型，因为它是一个外部对象，可能会在我们的控制之外改变其类型。
- en: All these will be available to be used inside our component's props (`this.props`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将可用于在我们组件的props（`this.props`）中使用。
- en: 'The last thing to note about this container is how we are going to deal with
    the user actions. In this screen, there is only one action: the user clicking
    on a product item to see its details:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此容器的最后一件事是我们将如何处理用户操作。在此屏幕上，只有一个操作：用户点击产品项以查看其详细信息：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the user taps on a specific product, this screen will call the `navigate`
    function in the `navigation` prop to move to our next screen, `ProductDetail`.
    Instead of saving the selected product in the state through an action, we will
    pass it directly using `navigation` options to simplify our store.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击特定产品时，这个屏幕将调用`navigation`属性中的`navigate`函数，移动到我们的下一个屏幕`ProductDetail`。我们将直接使用`navigation`选项传递所选产品，而不是通过动作将其保存在状态中，以简化我们的存储。
- en: ProductDetail
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ProductDetail
- en: 'This screen will show the user all the details about the selected product and
    allow her to add this selected product to her cart:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕将向用户显示有关所选产品的所有详细信息，并允许她将所选产品添加到她的购物车中。
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ProductDetail` requires Redux to provide it with the user details stored in `state`.
    This is achieved by calling the `connect` method, passing a `mapStateToProps`
    function which will extract the user from the specified `state` and return it
    to be injected as `prop` in the screen. It also requires an action from Redux: `addProductToCart`.
    This action just stores the selected product in the store when the user expressee
    her wish to buy it.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetail`需要Redux提供存储在`state`中的用户详细信息。这是通过调用`connect`方法实现的，传递一个`mapStateToProps`函数，该函数将从指定的`state`中提取用户并将其返回为屏幕中的`prop`注入。它还需要来自Redux的动作：`addProductToCart`。当用户表示希望购买时，此动作只是将所选产品存储在存储中。'
- en: 'The `render()` method in this screen shows `<ScrollView />` wrapping the book
    image, price, description (we will display a fake `lorem ipsum` description for
    now), and a `Buy!` button, which will be connected to the `addProductToCart` action
    provided by Redux:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕中，`render()` 方法显示了`<ScrollView />`包裹着书籍图片、价格、描述（我们现在将显示一个虚假的`lorem ipsum`描述），以及一个`Buy!`按钮，它将连接到Redux提供的`addProductToCart`动作。
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `onBuyPress()` method invokes the mentioned action and does a small navigation
    trick afterwards. It goes back by calling the `goBack()` method on the `navigation`
    object to remove the `ProductDetail` screen from the navigation stack, as the
    user won't need it anymore after adding the product to the cart. Immediately after
    doing this, the `onBuyPress()` method will invoke the `navigate` method on the
    `navigation` object to be moved and display the state of the user's cart in the
    `MyCart` screen. We are using `setTimeout` here to make sure we wait until the
    previous call (`this.props.navigation.goBack();`) has finished all the navigation
    tasks and the object is again ready for us to use. Waiting for `0` seconds should
    be enough, since we just want to wait for the call stack to be cleared.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBuyPress()`方法调用了上述动作，并在之后进行了一个小的导航技巧。它通过在`navigation`对象上调用`goBack()`方法来返回，从导航堆栈中移除`ProductDetail`屏幕，因为用户在将产品添加到购物车后不再需要它。在这之后，`onBuyPress()`方法将在`navigation`对象上调用`navigate`方法，以移动并在`MyCart`屏幕中显示用户购物车的状态。我们在这里使用`setTimeout`来确保我们等待前一个调用（`this.props.navigation.goBack();`）完成所有导航任务，并且对象再次准备好供我们使用。等待`0`秒应该足够，因为我们只是想等待调用堆栈被清除。'
- en: Let's take a look at what the `MyCart` screen looks like now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`MyCart`屏幕现在是什么样子的。
- en: MyCart
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyCart
- en: 'This screen expects Redux to inject the cart stored in the state, so it can
    render all the items in the cart for the user to review before confirming the
    purchase:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕期望Redux注入存储在状态中的购物车，以便它可以渲染用户在确认购买之前审查的所有购物车中的物品：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Apart from the cart itself, as we can see in the `propTypes` definition, this
    screen needs the action `removeProductFromCart` from `ProductActions`, and the
    `navigation` object to be provided to navigate to the `Payment` screen when the
    user is ready to confirm her purchase.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了购物车本身，正如我们在`propTypes`定义中所看到的，这个屏幕需要来自`ProductActions`的`removeProductFromCart`动作，以及提供给`navigation`对象的`navigation`对象，以便在用户准备确认购买时导航到`Payment`屏幕。
- en: 'In summary, the user can take three actions from here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，用户可以从这里执行三个操作：
- en: Removing an item from the cart by clicking on the Trash icon on each product
    row (invoking `this.onTrashPress()`)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击每个产品行上的垃圾桶图标从购物车中移除商品（调用`this.onTrashPress()`）
- en: Navigating to the `Payment` screen to complete her purchase (invoking `this.props.navigation.navigate('Payment')`)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到“支付”屏幕以完成她的购买（调用`this.props.navigation.navigate('Payment')`）
- en: Navigating to the home screen to keep buying products (invoking `this.props.navigation.navigate('Home')`)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到主屏幕以继续购买产品（调用`this.props.navigation.navigate('Home')`）
- en: Let's continue to the purchase journey by reviewing the `Payment` screen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续购买之旅，查看“支付”屏幕。
- en: Payment
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支付
- en: 'We will use the `react-native-credit-card-input` library to capture the user''s
    credit card details. For this screen to work, we will request the cart, the user,
    and several important actions from Redux:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`react-native-credit-card-input`库来捕获用户的信用卡详细信息。为了使此屏幕正常工作，我们将从Redux请求购物车、用户和几个重要操作：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a complex component. Let''s take a look at the props validation to
    understand its signature:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的组件。让我们看一下props验证，以了解其签名：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following props need to be passed for the component to work properly:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要传递以下props才能使组件正常工作：
- en: '`user`: We need the user to check if she is logged in. In case she is not,
    we will display the login/registration components instead of the credit card input.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`: 我们需要用户来检查她是否已登录。如果她没有登录，我们将显示登录/注册组件，而不是信用卡输入。'
- en: '`cart`: We need it to calculate and display the total to be charged to the
    credit card.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cart`: 我们需要它来计算并显示要向信用卡收取的总费用。'
- en: '`login`: This action will be invoked if the user decides to log in from this
    screen.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`: 如果用户决定从此屏幕登录，将调用此操作。'
- en: '`register`: This action will be invoked if the user decides to register from
    this screen.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register`: 如果用户决定从此屏幕注册，将调用此操作。'
- en: '`logout`: This action is needed for the `<LoginOrRegister />` component to
    work, so it needs to be provided from Redux so it can be injected into the child
    `<LoginOrRegister />` component.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout`: 此操作对于`<LoginOrRegister />`组件的工作是必需的，因此需要从Redux提供，以便可以将其注入到子`<LoginOrRegister
    />`组件中。'
- en: '`pay`: This action will be triggered when the user has entered valid credit
    card details and pressed the Pay now button.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pay`: 当用户输入有效的信用卡详细信息并按下“立即支付”按钮时，将触发此操作。'
- en: '`loading`: This is a flag for the child `<LoginOrRegister />` component to
    work properly.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`: 这是用于使子`<LoginOrRegister />`组件正常工作的标志。'
- en: '`paying`: This flag will be used to display a spinner while the payment is
    being confirmed.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paying`: 此标志将用于在确认付款时显示旋转器。'
- en: '`error`: This is a description of the last error to have happened when trying
    to pay or log in/register.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`: 这是在尝试支付或登录/注册时发生的最后一个错误的描述。'
- en: '`paymentConfirmed`: This flag will let the component know when/if the payment
    has gone through correctly.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paymentConfirmed`: 当/如果支付正确通过时，此标志将通知组件。'
- en: '`navigation`: The `navigation` object used to navigate to other screens.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigation`: 用于导航到其他屏幕的`navigation`对象。'
- en: 'This component also has its own state:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件还有其自己的状态：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both attributes in this state will be provided by `<CreditCardInput />` (the
    main component form `react-native-credit-card-input` ) and will hold the user's
    credit card details and their validity together.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态中的两个属性将由`<CreditCardInput />`（`react-native-credit-card-input`主要组件表单）提供，并将保存用户的信用卡详细信息及其有效性。
- en: 'To detect when the payment has been confirmed, we will use the React method `componentWillReceiveProps`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测支付是否已确认，我们将使用React方法`componentWillReceiveProps`：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method just detects when the prop `paymentConfirmed` changes from `false`
    to `true` in order to navigate to the `PaymentConfirmation` screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是检测当`paymentConfirmed`属性从`false`变为`true`时，以便导航到`PaymentConfirmation`屏幕。
- en: PaymentConfirmation
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支付确认
- en: 'A simple screen displays a summary of the purchase just confirmed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的屏幕显示了刚确认的购买的摘要：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first thing this screen does is to save the app''s state related to the
    cart in the own component''s state:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕的第一件事是保存与购物车相关的应用程序状态在自己的组件状态中：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is necessary because we want to reset the cart and payment details right
    after this screen is shown as it won't be needed on any further occasion. This
    is done by invoking both the `resetCart()` and `resetPayment()` actions provided
    by Redux.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必要的，因为我们希望在显示此屏幕后立即重置购物车和付款详情，因为在以后的任何场合都不需要它。这是通过调用Redux提供的`resetCart()`和`resetPayment()`操作来完成的。
- en: The `render` method just maps the items in the cart (now saved in the component's
    state) into a list of views so the user can review her order. At the bottom of
    these views, we will display a button labeled Continue Shopping, which will return
    the user to the `ProductList` screen by calling the `continueShopping` method.
    Besides navigating to the `ProductList` screen, we need to reset the navigation
    so the purchase journey can be started from scratch the next time the user wants
    to buy some items. This is achieved by creating a reset navigation action and
    invoking `this.props.navigation.dispatch(resetAction);`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法只是将购物车中的项目（现在保存在组件状态中）映射到视图列表中，以便用户可以查看她的订单。在这些视图的底部，我们将显示一个名为“继续购物”的按钮，通过调用`continueShopping`方法，它将返回用户到`ProductList`屏幕。除了导航到`ProductList`屏幕，我们还需要重置导航，以便下次用户想购买一些物品时可以从头开始购买旅程。这是通过创建重置导航操作并调用`this.props.navigation.dispatch(resetAction);`来实现的。'
- en: The method `continueShopping` calls `NavigationActions.reset` to clear the navigation
    stack and go back to the home screen. This method is usually called at the end
    of a user journey.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`continueShopping`方法调用`NavigationActions.reset`来清除导航堆栈并返回到主屏幕。这个方法通常在用户旅程结束时调用。'
- en: 'This screen completes the purchase journey, so let''s focus now in a different
    part of the application: the user profile.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕完成了购买过程，所以现在让我们专注于应用程序的另一个部分：用户个人资料。
- en: MyProfile
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyProfile
- en: 'As we saw before, only logged-in users can complete purchases so we need a
    way for the users to log in, log out, register, and review their account details.
    This will be achieved by the `MyProfile` screen and the `<LonginOrRegister />`
    component:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，只有登录用户才能完成购买，所以我们需要一种让用户登录、注销、注册和查看其帐户详细信息的方式。这将通过`MyProfile`屏幕和`<LonginOrRegister
    />`组件实现：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This screen receives the user from the app's state and a number of actions (`login`,
    `register`, and `logout`), which will be fed into the `<LoginOrRegister />` component
    to enable login and registration. Most of the logic, therefore, will be deferred
    to the `<LoginOrRegister />` component, leaving the `MyProfile` screen with the
    tasks of listing the user's account details and displaying a button for logging
    her out.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕从应用程序状态中接收用户和一些操作（`登录`，`注册`和`注销`），这些操作将被传递到`<LoginOrRegister />`组件中以启用登录和注册。因此，大部分逻辑将被推迟到`<LoginOrRegister
    />`组件，留下`MyProfile`屏幕来列出用户的帐户详细信息并显示一个注销按钮。
- en: Let's review what the `<LoginOrRegister />` component does and how.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`<LoginOrRegister />`组件的功能和工作原理。
- en: LoginOrRegister
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LoginOrRegister
- en: 'Actually, this component is compounded by two sub-components: `<Login />` and
    `<Register />`. The only task of `<LoginOrRegister />` is to save the state of
    which component (`<Login />` or `<Register />`) should be displayed, showing it
    accordingly.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个组件由两个子组件组成：`<Login />`和`<Register />`。`<LoginOrRegister />`的唯一任务是保存应该显示哪个组件（`<Login
    />`或`<Register />`）的状态，并相应地显示它。
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The state in this component can be changed by their child components as it
    passes a function to do so to each child:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中的状态可以被它们的子组件改变，因为它向每个子组件传递了一个函数来做到这一点：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's now take a look at how the `<Login />` and `<Register />` components will
    use these props to update their parents' state, switching from one view to another.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`<Login />`和`<Register />`组件将如何使用这些props来更新它们父组件的状态，从一个视图切换到另一个视图。
- en: Login
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: 'The login view will be displayed by default on the parent component. Its task
    is to capture login information and call the `login` action once the user pushes
    the `Login` button:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 登录视图将默认显示在父组件上。它的任务是捕获登录信息，并在用户按下`登录`按钮时调用`登录`操作：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Two inputs capture the email and the password and save them into the component
    state as the inputs are being changed. Once the user has finished entering her
    credentials, she will press the `Login` button and trigger the login action passing
    the email and password from the component's state.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 两个输入框捕获电子邮件和密码，并在输入更改时将它们保存到组件状态中。一旦用户完成输入她的凭据，她将按下`登录`按钮并触发登录操作，从组件状态传递电子邮件和密码。
- en: There is also a `<LinkButton />` labeled `or Register`, which will invoke (when
    pressed) the `this.props.changeToRegister()` function passed by its parent, `<LoginOrRegister
    />`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个标有`或注册`的`<LinkButton />`，当按下时将调用其父组件`<LoginOrRegister />`传递的`this.props.changeToRegister()`函数。
- en: Register
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: 'Similarly to the login form, the `<Register />` component is a list of input
    fields saving its changes into the component state until the user is confident
    enough to press the `Register` button:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录表单类似，`<Register />`组件也是一个保存其更改到组件状态的输入字段列表，直到用户有足够的信心按下`注册`按钮：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, `<LinkButton />` at the bottom of the view will invoke `this.props.changeToLogin()`
    when pressed to switch to the login view.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，视图底部的`<LinkButton />`在按下时将调用`this.props.changeToLogin()`以切换到登录视图。
- en: Sales
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销售
- en: 'We added one last screen to demonstrate how different journeys can be linked
    together reusing screens and components. In this case, we will create a list of
    products with their prices reduced, which can be added directly to the cart for
    a quick purchase:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了最后一个屏幕来演示如何将不同的旅程链接在一起，重用屏幕和组件。在这种情况下，我们将创建一个产品列表，其价格已经降低，可以直接添加到购物车进行快速购买：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will use the same full list of available products, already stored in Redux''s
    state, to filter (by reduced price) and map into an appealing list item that are
    ready to be added to the cart by triggering the `onBuyPress()` method, which in
    turn triggers `addProductToCart()`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Redux状态中已经存储的可用产品的完整列表，通过降价来筛选并映射成一个吸引人的列表项，通过触发`onBuyPress()`方法将其添加到购物车，这将触发`addProductToCart()`：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Besides triggering this Redux action, `onBuyPress()` navigates to the `MyCart`
    screen, but it does so after the call stack is cleared to ensure the product has
    been added to the cart correctly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了触发这个Redux动作，`onBuyPress()`还导航到`MyCart`屏幕，但是在清除调用堆栈后才这样做，以确保产品已正确添加到购物车中。
- en: At this stage, the purchase journey will kick in again allowing the user to
    log in (if not logged in yet), pay for the items, and confirm the purchase.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，购买旅程将再次开始，允许用户登录（如果尚未登录），支付商品，并确认购买。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we developed several common functionalities present in most
    e-commerce apps, such as user login and registration, retrieving data from an
    API, purchase journeys, and payments.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了大多数电子商务应用程序中常见的几个功能，例如用户登录和注册、从API检索数据、购买流程和支付。
- en: We tied all the screens with a common app state managed through Redux, which
    makes this app scalable and easily maintainable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Redux将所有屏幕与一个共同的应用程序状态绑定在一起，这使得该应用程序具有可扩展性和易于维护性。
- en: With maintainability in mind, we added properties validation for all our components
    and screens. Moreover, we enforced standard code formatting and linting, using
    ESLint, so that the app is ready for various team members to align and develop
    comfortable new features or maintain the current ones.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可维护性，我们为所有组件和屏幕添加了属性验证。此外，我们使用ESLint强制执行标准代码格式和代码检查，以便应用程序可以轻松地为各种团队成员对齐和开发新功能或维护当前功能。
- en: Finally, we also added API mocking for the developers to work locally without
    needing a backend when building the mobile app.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还为开发人员添加了API模拟，以便他们在构建移动应用程序时可以在本地工作，而无需后端支持。
