- en: '*Chapter 10*: Building an Onboarding Screen'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：构建入职屏幕'
- en: We've been through so much that we can say it's finally time to start building
    more than just components. We'll begin by creating a really important part of
    any application and that's the onboarding screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经历了很多，可以说现在终于是时候开始构建不仅仅是组件了。我们将首先创建任何应用程序中非常重要的部分，即入职屏幕。
- en: We'll go over what exactly an onboarding screen is and its purpose in an app.
    We'll understand that there are many types of onboarding screens, but we'll focus
    on creating just one of those types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍入职屏幕到底是什么，以及它在应用程序中的目的。我们将了解到有许多类型的入职屏幕，但我们将专注于创建其中的一种。
- en: By learning how to create this type of screen, we'll learn lots of cool new
    concepts we haven't been exposed to until now. These new concepts will be helpful
    for you in the future for building lots of different types of screens. By learning
    a lot of new things, we can surpass our creative limitations and be more prepared
    for future challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何创建这种类型的屏幕，我们将学到许多我们到目前为止还没有接触过的新概念。这些新概念将对你未来构建许多不同类型的屏幕非常有帮助。通过学习许多新东西，我们可以超越我们的创造限制，并为未来的挑战做好更充分的准备。
- en: We'll learn about animation and how to create a cool animation for our screens.
    This will open the door to creating a smoother user experience for our customers.
    We'll understand what interpolation and extrapolation mean and how we can use
    them to build animations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习动画以及如何为我们的屏幕创建一个酷炫的动画。这将为我们的客户打开创建更流畅用户体验的大门。我们将了解插值和外推的含义，以及如何使用它们来构建动画。
- en: We'll also go more in-depth regarding Hooks and how to use `useRef`. And yes,
    we will also learn about a new surprise Hook that is going to help us find the
    size of our screens even faster than before.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更深入地了解Hooks以及如何使用`useRef`。是的，我们还将学习一个新的惊喜Hook，它将帮助我们比以往更快地找到屏幕的大小。
- en: Last but not least, we'll learn how to use a cool component that's more performant
    than any tool we've used until now. This cool component is called `FlatList` and
    it's going to help us create a cool onboarding experience for us and our users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们将学习如何使用一个比我们到目前为止使用的任何工具更高效的酷组件。这个酷组件叫做`FlatList`，它将帮助我们为我们和我们的用户创建一个酷炫的入职体验。
- en: By the end of this chapter, we'll have a great onboarding screen that we'll
    use as the main opening screen for the next chapter's app project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有一个很棒的入职屏幕，我们将把它用作下一章应用项目的主要开屏。
- en: 'This chapter will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What's an onboarding screen and where can we use it?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是入职屏幕，我们在哪里可以使用它？
- en: Creating a new project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Paginator
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页器
- en: Adding the automatic scrolling functionality
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自动滚动功能
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 10` that contains all the code we've written
    in this chapter. To use that project, please follow the instructions in the `README.md`
    file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问GitHub [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)
    查看本章的代码。您将找到一个名为`Chapter 10`的文件夹，其中包含我们在本章中编写的所有代码。要使用该项目，请按照`README.md`文件中的说明进行操作。
- en: What's an onboarding screen and where can we use it?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是入职屏幕，我们在哪里可以使用它？
- en: We should start this chapter by understanding what exactly an onboarding screen
    is. An onboarding screen is like a short introduction to your app before it's
    used. It's the first screen that welcomes the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从理解入职屏幕的确切含义开始这一章。入职屏幕就像是在应用使用之前对应用的简短介绍。这是欢迎用户的第一个屏幕。
- en: The onboarding of your app should have a specific goal when it comes to welcoming
    users. You'll have to make sure that your onboarding will help users understand
    how they're supposed to be using the app, while also exciting them about the features
    they'll be able to use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用的入职应该在欢迎用户方面有一个具体的目标。您必须确保您的入职将帮助用户了解他们应该如何使用应用，同时也让他们对他们将能够使用的功能感到兴奋。
- en: If you've made sure that the onboarding screen is going to be a great experience
    for your users, then you can expect more engagement from them in the first few
    days of them using the app. High engagement means happy users, which means your
    app is creating a really good user experience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确保入职屏幕对用户来说是一次很棒的体验，那么您可以期待在用户开始使用应用的最初几天里获得更多的参与度。高参与度意味着用户很满意，这意味着您的应用正在创造一个非常好的用户体验。
- en: The onboarding screen should only appear to first-time users. We all know how
    annoying it would be to redo a tutorial in a game. Even though it should only
    take about 30 seconds to 1 minute to go through it, this could still make a returning
    user annoyed with the experience.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 入职屏幕应该只出现在首次使用的用户面前。我们都知道在游戏中重新做教程会有多烦人。即使只需要大约30秒到1分钟来完成，这也可能让回头用户对体验感到恼火。
- en: 'I''d recommend reading more about onboardings by going to Google''s Material
    website, where they recommend different design ideas and guidelines for creating
    a good onboarding screen for Android phones: [https://material.io/design/communication/onboarding.html](https://material.io/design/communication/onboarding.html).
    Of course, most of the same rules apply to iOS as well.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议阅读更多关于入职的内容，可以去谷歌的Material网站，他们推荐了不同的设计理念和指南，用于为安卓手机创建一个好的入职屏幕：[https://material.io/design/communication/onboarding.html](https://material.io/design/communication/onboarding.html)。当然，大部分规则也适用于iOS。
- en: Now that we've figured out what an onboarding screen is, as well as where and
    when to use one, it's time for us to figure out what exactly this onboarding screen
    would look like for our app. Also, this is a good time for us to talk about what
    type of app this will be.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了入职屏幕是什么，以及何时何地使用它，是时候弄清楚对于我们的应用来说，这个入职屏幕究竟会是什么样子了。同时，这也是我们讨论这将是什么类型的应用的好时机。
- en: The next chapter is going to focus solely on the logic part of our app, while
    this chapter will focus on creating the onboarding we need for our app. The app
    in question will be a stopwatch/timer app. Knowing this, I decided to have an
    onboarding experience where the user learns about the utility of the app.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于我们应用的逻辑部分，而本章将专注于为我们的应用创建所需的入职屏幕。所涉及的应用将是一个秒表/计时器应用。鉴于此，我决定设计一个入职体验，让用户了解应用的实用性。
- en: 'Let''s take a look at what our onboarding screen for this app will look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们为这个应用设计的入职屏幕会是什么样子：
- en: '![Figure 10.1 – The onboarding screen we''re going to create'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - 我们将创建的入职屏幕'
- en: '](Images/Figure_10.01_B17074_new.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.01_B17074_new.jpg)'
- en: Figure 10.1 – The onboarding screen we're going to create
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 我们将创建的入职屏幕
- en: This looks pretty cool, right? It will be formed of four different screens,
    each of which will have a different image, title, and description. We'll have
    the ability to swipe left/right to advance and read all the screens while also
    pressing the **Next** button, which is going to swipe for us. The small four dots
    behind the text are going to be animated to show us which screen we are on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很酷，对吧？它将由四个不同的屏幕组成，每个屏幕都有不同的图像、标题和描述。我们将能够向左/向右滑动以前进并阅读所有屏幕，同时也可以按下“下一步”按钮，它将为我们滑动。文本后面的四个小点将被动画显示，以告诉我们当前在哪个屏幕上。
- en: I honestly love the way it looks, and I can't wait to finish this onboarding
    screen so that we can start creating the full app. By the end of this chapter,
    you'll be ready to start creating onboarding screens.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，我真的很喜欢它的外观，我迫不及待地想完成这个入门屏幕，这样我们就可以开始创建完整的应用程序了。在本章结束时，你将准备好开始创建入门屏幕。
- en: Now, let's start working on our screen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始工作在我们的屏幕上。
- en: Creating a new project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Now that we know what our project will look like and why we need this screen,
    it's time to start working on it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的项目将是什么样子，以及为什么需要这个屏幕，是时候开始工作了。
- en: Before coding, let's gather the images that we're going to use for this project.
    I've used the images from [https://undraw.co](https://undraw.co), which provides
    open source `.svg` and `.png` images. I've downloaded four different `.png` images
    and placed them in the `assets/onboarding` folder. The `onboarding` folder is
    a new folder I've created in the `assets` folder specifically for this screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码之前，让我们收集我们将在这个项目中使用的图像。我使用了来自[https://undraw.co](https://undraw.co)的图像，该网站提供开源的`.svg`和`.png`图像。我下载了四个不同的`.png`图像，并将它们放在`assets/onboarding`文件夹中。`onboarding`文件夹是我专门为这个屏幕在`assets`文件夹中创建的新文件夹。
- en: 'Let''s start by opening the terminal window and moving to the directory that
    you usually use for your projects. Now, let''s write our usual command and get
    right into it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开终端窗口并移动到你通常用于项目的目录开始。现在，让我们写下我们通常的命令，开始吧：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have a new project, let''s install Galio. We can do this by using
    the following terminal command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新项目，让我们安装Galio。我们可以使用以下终端命令来做到这一点：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we've set everything up, let's open our project and start coding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，让我们打开我们的项目并开始编码。
- en: First, we'll begin by doing the same old trick we've always done, and that is
    going into our `App.js` file and deleting everything inside `View` in our `App()`
    function. I've left out the `<StatusBar />` component just for the sake of it
    as you may wish to style or hide it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从做我们一直在做的老把戏开始，那就是进入我们的`App.js`文件，并删除`App()`函数中`View`内的所有内容。我故意略过了`<StatusBar
    />`组件，因为你可能希望对其进行样式设置或隐藏。
- en: Now, in our main folder, let's create a folder called `components`. This is
    where we'll place every component we're going to create for this beautiful app.
    By the end of this chapter, you'll have three files in this folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的主文件夹中，让我们创建一个名为`components`的文件夹。这是我们将放置为这个美丽的应用程序创建的每个组件的地方。在本章结束时，你将在这个文件夹中有三个文件。
- en: Now that our folder has been created, create a new file inside it called `Onboarding.js`.
    This will serve as our main screen. Now, let's quickly create and export this
    component so that we can import it into our main `App.js` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的文件夹已经创建好了，在其中创建一个名为`Onboarding.js`的新文件。这将作为我们的主屏幕。现在，让我们快速创建并导出这个组件，以便我们可以将其导入到我们的主`App.js`文件中。
- en: 'We''ve already done this a lot of times but this time we''ll be using `SafeAreaView`
    instead of a `Block` or `View` component as the parent component for our screen.
    We''re using this one because we want to make sure everything is taken care of
    in case the users of our app have a phone with a notch:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做过很多次了，但这一次我们将使用`SafeAreaView`而不是`Block`或`View`组件作为屏幕的父组件。我们使用这个是因为我们希望确保一切都被照顾到，以防我们应用的用户有一个带有刘海的手机：
- en: '![Figure 10.2 – Onboarding component ready to be imported'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - 准备好导入的入职组件'
- en: '](Images/Figure_10.02_B17074.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.02_B17074.jpg)'
- en: Figure 10.2 – Onboarding component ready to be imported
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 准备好导入的入职组件
- en: 'Now that we''ve finished coding this function, let''s go ahead and import it
    into `App.js`. Once imported, we can use it inside our main function. Now, the
    main function should look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了编写这个函数，让我们继续将其导入到`App.js`中。一旦导入，我们就可以在我们的主函数中使用它。现在，主函数应该看起来像这样：
- en: '![Figure 10.3 – The main App function with Onboarding imported'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 - 导入Onboarding的主App函数'
- en: '](Images/Figure_10.03_B17074.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.03_B17074.jpg)'
- en: Figure 10.3 – The main App function with Onboarding imported
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - 导入Onboarding的主App函数
- en: Now, we're ready to continue developing our app. Because we've imported the
    `Onboarding` component inside our `App` function, we can see whatever we're going
    to modify and add our `Onboarding` component every time we save the file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备继续开发我们的应用。因为我们已经在`App`函数中导入了`Onboarding`组件，所以每次保存文件时，我们都可以看到我们要修改和添加我们的`Onboarding`组件。
- en: Let's get back to `Onboarding.js` and think of how we should start working on
    our onboarding screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`Onboarding.js`，考虑一下我们应该如何开始处理我们的入职屏幕。
- en: 'By looking at *Figure 10.1*, we know that there are three main identifiable
    parts to this screen. Remember when we discussed that we need to always look at
    screens in terms of bigger containers to understand how to create the layout before
    we start coding? Well, this is the same thing, so let''s split our screen into
    those three main parts:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看*图10.1*，我们知道这个屏幕有三个主要可识别的部分。还记得我们讨论过需要始终从更大的容器的角度来看待屏幕，以了解如何在开始编码之前创建布局吗？好吧，这就是同样的道理，所以让我们将我们的屏幕分成这三个主要部分：
- en: '**OnboardingItem**: This area is the upper part of the screen, before the four
    dots. It''s going to include a picture, a title, and a description. This area
    needs to be set as one big area because it''s going to change with every swipe.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnboardingItem**：这个区域是屏幕上部，四个点之前的部分。它将包括一张图片，一个标题和一个描述。这个区域需要被设置为一个大区域，因为它将随着每次滑动而改变。'
- en: '**Pagination**: The four small dots display where we''re situated in this big
    slider. This way, we always know how much more there is to read until we get to
    the last slide.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页**：四个小点显示了我们在这个大滑块中的位置。这样，我们总是知道还有多少内容要阅读，直到我们到达最后一张幻灯片。'
- en: '**Next button**: This button is going to move the slides without the need to
    swipe, while also being the last thing we need to press to move on from the onboarding
    screen to the home screen.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一步按钮**：这个按钮将移动幻灯片，而无需滑动，同时也是我们需要按下的最后一件事，从入职屏幕转到主屏幕。'
- en: Knowing that there are three parts should make things easier to sketch. First
    of all, we should start with the main area, which is also the biggest one. Let's
    go to our `components` folder and create a new file called `OnboardingItem.js`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 知道有三个部分应该会让事情更容易绘制。首先，我们应该从主区域开始，这也是最大的区域。让我们进入我们的`components`文件夹，创建一个名为`OnboardingItem.js`的新文件。
- en: OnboardingItem
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnboardingItem
- en: As we mentioned previously, this component should render the top of our screen,
    which contains a picture, some text, and a description. Let's do just that. Go
    ahead and import the `Block` and `Text` components from `'galio-framework'` and
    `Image` and `StyleSheet` from `'react-native'`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个组件应该渲染屏幕顶部，其中包含一张图片、一些文本和描述。让我们就这样做。继续从`'galio-framework'`中导入`Block`和`Text`组件，以及从`'react-native'`中导入`Image`和`StyleSheet`。
- en: 'Once we''ve imported everything we need, it''s time to start building our component.
    We''ll begin by having a main `<Block />` component, which will be hosted inside
    our `<Image />`, and another `<Block />` component. The second `<Block />` component
    will have two `<Text />` components as children – one for the title and one for
    the description. This second `<Block />` component will be used to split the screen
    into the main area, which is going to take up some more space because it''s going
    to be an image, and the secondary area, which should be smaller because it only
    contains text:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了所有需要的东西，就是开始构建我们的组件的时候了。我们将首先有一个主要的`<Block />`组件，它将被放在我们的`<Image />`中，并且另一个`<Block
    />`组件。第二个`<Block />`组件将有两个`<Text />`组件作为子元素 - 一个用于标题，一个用于描述。这个第二个`<Block />`组件将被用来将屏幕分成主要区域，它将占用更多的空间，因为它将是一张图片，和次要区域，它应该更小，因为它只包含文本。
- en: '![Figure 10.4 – The OnboardingItem component'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 - OnboardingItem组件'
- en: '](Images/Figure_10.04_B17074.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.04_B17074.jpg)'
- en: Figure 10.4 – The OnboardingItem component
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - OnboardingItem组件
- en: As you can see, there's a small surprise here. First of all, I've imported `useWindowDimensions`.
    This is a `hook` function that returns the width or height of the screen. This
    is an easy way to make sure that the width of your components is equal to the
    width of your screen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里有一个小惊喜。首先，我导入了`useWindowDimensions`。这是一个返回屏幕宽度或高度的`hook`函数。这是一个简单的方法，可以确保你的组件的宽度等于屏幕的宽度。
- en: I've also imported a prop called `item`. Because this is an onboarding screen,
    we'll have at least four screens with a different type of text or image. We'll
    pass an object, along with all the necessary information, through this prop called
    `item`. This way, we can make sure everything will go to the exact spot we want
    it to go, as well as that we won't have to keep wasting time writing props for
    every single part of our component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我还导入了一个名为`item`的属性。因为这是一个入职屏幕，我们将至少有四个屏幕，每个屏幕都有不同类型的文本或图像。我们将通过这个名为`item`的属性传递一个对象，以及所有必要的信息。这样，我们可以确保一切都会到达我们想要到达的确切位置，而且我们不必再浪费时间为组件的每个部分编写属性。
- en: 'All the styles have been applied already, but we haven''t discussed them much
    yet. So, let''s look at these styles for a second:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的样式已经应用了，但我们还没有讨论过它们。所以，让我们看一下这些样式：
- en: '![Figure 10.5 – Styles for our OnboardingItem component'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 - 我们的OnboardingItem组件的样式'
- en: '](Images/Figure_10.05_B17074.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.05_B17074.jpg)'
- en: Figure 10.5 – Styles for our OnboardingItem component
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 - 我们的OnboardingItem组件的样式
- en: 'As we can see, the container has a property of `flex: 1`, which tells our main
    `<Block />` component to take up as much space as it can. We gave our `image`
    a `flex: 0.7` property because we want it to occupy 70% of the space, while `title`
    and `description` only need to occupy 30% of the space. The other styles are just
    the usual text styles where we set `fontSize` and `fontWeight`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所看到的，容器有一个`flex: 1`的属性，告诉我们的主要`<Block />`组件尽可能占据空间。我们给我们的`image`一个`flex:
    0.7`的属性，因为我们希望它占据70%的空间，而`title`和`description`只需要占据30%的空间。其他样式只是通常的文本样式，我们设置了`fontSize`和`fontWeight`。'
- en: Tip of the Day
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每日提示
- en: I cannot stress enough the importance of looking at the pictures to understand
    the code. I believe you should look at the picture first, try to make all the
    connections inside your brain, and then see if you got *lucky*. I wouldn't call
    it luck, though; I'd call it more of an educated guess.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法再次强调看图片来理解代码的重要性。我相信你应该先看图片，尝试在脑海中建立所有的连接，然后看看你是否*幸运*。不过我不会称之为运气，我会称之为更多的是一个经过深思熟虑的猜测。
- en: 'Now that our `OnboardingItem` component has been created, we''re ready to import
    it into our `Onboarding.js` file, which is where our main screen resides. We all
    know how to import a component but just to make sure, the line we must write for
    this looks as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`OnboardingItem`组件，我们准备将它导入到我们的`Onboarding.js`文件中，这是我们的主屏幕所在的地方。我们都知道如何导入一个组件，但为了确保，我们必须写下以下行：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we've done this, we can start using `FlatList` to render all our items
    on the screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做到了这一点，我们可以开始使用`FlatList`在屏幕上呈现所有的项目。
- en: FlatList
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FlatList
- en: As we mentioned earlier, we don't want to repeat ourselves, so we won't write
    the same code four times inside our main onboarding component. The first thing
    that may come to your mind is to use the `.map()` function. This is a good guess,
    but React Native has a component that is usually used because of its better performance.
    It also has some props built into it that are lifesavers in situations like this.
    This component is called `FlatList`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们不想重复自己，所以我们不会在我们的主要onboarding组件内写四次相同的代码。你脑海中可能首先想到的是使用`.map()`函数。这是一个好猜测，但React
    Native有一个组件通常被使用，因为它的性能更好。它还有一些内置的props，在这种情况下可以拯救生命。这个组件叫做`FlatList`。
- en: To use this component, we need to prove it with an array of elements that must
    be mapped to the component we've been creating. Earlier, I mentioned that our
    `OnboardingItem` component will accept a prop called `item`. This prop is going
    to be an object inside this array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个组件，我们需要用一个元素数组来证明它，这些元素必须映射到我们一直在创建的组件上。我之前提到过，我们的`OnboardingItem`组件将接受一个名为`item`的prop。这个prop将是数组中的一个对象。
- en: If we look at *Figure 10.4*, we can figure out what our object should look like
    from the way we've used it inside our component. We know that it needs to have
    a `title`, `description`, and `image`, but it also needs an `id`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下*图10.4*，我们可以从我们在组件内部使用它的方式来确定我们的对象应该是什么样子的。我们知道它需要有一个`title`，`description`和`image`，但它还需要一个`id`。
- en: 'Let''s create a new file called `slides.js` in our root (main) folder. This
    is where the array containing all the objects that provide the information our
    onboarding needs will reside, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的根（主）文件夹中创建一个名为`slides.js`的新文件。这是包含我们onboarding需要的所有对象信息的数组所在的地方，如下面的截图所示：
- en: '![Figure 10.6 – The array with all the information needed by the FlatList component'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 包含FlatList组件所需信息的数组'
- en: '](Images/Figure_10.06_B17074.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.06_B17074.jpg)'
- en: Figure 10.6 – The array with all the information needed by the FlatList component
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - 包含FlatList组件所需信息的数组
- en: Don't forget that you can have any type of information you'd like. The titles,
    descriptions, or images don't have to be identical to mine. Remember that when
    we started creating our app, I told you to download some images and place them
    inside the `./assets/onboarding` folder. These are the images I've chosen, and
    I imported them using the `require` keyword.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记你可以拥有任何类型的信息。标题、描述或图片不必与我的相同。记住，当我们开始创建我们的应用程序时，我告诉过你要下载一些图片并将它们放在`./assets/onboarding`文件夹中。这些就是我选择的图片，我使用`require`关键字导入它们。
- en: The `require` keyword is used just like `import` in that it tells the JavaScript
    engine that it needs the file to be located at the specified destination.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`关键字的使用方式与`import`一样，它告诉JavaScript引擎需要将文件定位到指定的位置。'
- en: 'Now that we have the array with data for `FlatList` ready it''s time to go
    back to our `Onboarding.js` file and import this new file just like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了用于`FlatList`的数据数组，是时候回到我们的`Onboarding.js`文件，并像这样导入这个新文件了：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s make sure we have the rest of the imports ready for when we need
    them as we need some more components. First of all, we''ll remove the `Text` import
    and we''ll import the `Block` and `Button` components from `''galio-framework''`.
    Secondly, we''ll add `FlatList` to the list of imported components:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保当我们需要时，我们已经准备好其余的导入，因为我们需要一些更多的组件。首先，我们将删除`Text`导入，并从`'galio-framework'`导入`Block`和`Button`组件。其次，我们将将`FlatList`添加到导入组件的列表中：
- en: '![Figure 10.7 – New imports added to the Onboarding.js file'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7-添加到Onboarding.js文件的新导入'
- en: '](Images/Figure_10.07_B17074.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.07_B17074.jpg)'
- en: Figure 10.7 – New imports added to the Onboarding.js file
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7-添加到Onboarding.js文件的新导入
- en: Now that everything has been imported, we're ready to start developing the screen.
    We'll delete our `<Text />` component from within the `<SafeAreaView />` component
    and use a `<Block />` component with the `flex={3}` prop instead.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经导入，我们准备开始开发屏幕。我们将从`<SafeAreaView />`组件中删除我们的`<Text />`组件，并改用带有`flex={3}`属性的`<Block
    />`组件。
- en: 'Inside of this `<Block />` component, our `<FlatList />` component will start
    its own life. Let''s take a look at how I''ve implemented this component before
    explaining how it works:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`<Block />`组件内部，我们的`<FlatList />`组件将开始自己的生活。让我们先看看我是如何实现这个组件的，然后再解释它是如何工作的：
- en: '![Figure 10.8 – FlatList implemented in our onboarding screen'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8-在我们的引导屏幕中实现的FlatList'
- en: '](Images/Figure_10.08_B17074.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.08_B17074.jpg)'
- en: Figure 10.8 – FlatList implemented in our onboarding screen
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8-在我们的引导屏幕中实现的FlatList
- en: As you can see, implementing this seems pretty straightforward. By the way,
    if you were to copy this code into your editor right now (assuming you've been
    following along with everything else as well) and try to check out your app on
    the simulator, you would see a fully working onboarding screen. Yes, it doesn't
    look as good as what we showcased at the beginning of this chapter, but it's working
    – we can slide left and right and check all the information we've been writing
    in our `slides.js` file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，实现这个似乎非常简单。顺便说一句，如果你现在将这段代码复制到你的编辑器中（假设你之前也一直在跟着做其他事情），并尝试在模拟器上查看你的应用程序，你会看到一个完全工作的引导屏幕。是的，它看起来不像我们在本章开头展示的那样好，但它是工作的-我们可以左右滑动并查看我们在`slides.js`文件中编写的所有信息。
- en: 'Now, let''s look at how this component works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个组件是如何工作的：
- en: First, we'll begin with the `data` prop. This is where we're offering our `FlatList`
    component the array it needs to start rendering each element.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`data`属性开始。这是我们向`FlatList`组件提供数组以开始渲染每个元素的地方。
- en: Then, we have the `renderItem` prop, which is where we use a function to render
    the item we need. In this case, we need multiple instances of `<OnboardingItem
    />`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`renderItem`属性，这是我们使用函数来渲染我们需要的项目的地方。在这种情况下，我们需要多个`<OnboardingItem />`的实例。
- en: Remember when I said we're going to pass this component the prop called `item`?
    This is because we only need to pass an object from the array. Our `FlatList`
    component will pass each object to a different `<OnboardingItem />` component.
    Once we've done this, we can capture that object and use it in any way we see
    fit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我说过我们将向这个组件传递一个叫做 `item` 的 prop 吗？这是因为我们只需要从数组中传递一个对象。我们的 `FlatList` 组件将把每个对象传递给不同的
    `<OnboardingItem />` 组件。一旦我们做到了这一点，我们就可以捕获那个对象，并以任何我们认为合适的方式使用它。
- en: The `keyExtractor` prop is used to extract a unique key for a specific item
    at the respective index.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`keyExtractor` prop 用于提取特定项目在相应索引处的唯一键。'
- en: These keys are used for caching so that React can keep track of each item individually
    and only rerender the one that must be rerendered. Do you remember how we were
    using the `key` prop when we were rendering items with the `.map()` function?
    This is the same but all the work is done by this prop. This is why we needed
    an `id` key inside our objects for the `slides` array.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些键用于缓存，以便 React 可以单独跟踪每个项目，并且只重新渲染必须重新渲染的项目。你还记得我们在使用 `.map()` 函数渲染项目时是如何使用
    `key` 属性的吗？这是一样的，但所有的工作都是由这个属性完成的。这就是为什么我们需要在 `slides` 数组的对象中有一个 `id` 键。
- en: The rest of the props are used mainly for layout purposes. I'd strongly encourage
    you just play around with those props by turning them on and off. For example,
    the `horizontal` prop makes our list, well, horizontal.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的 props 主要用于布局目的。我强烈鼓励你们通过打开和关闭这些 props 来玩耍。例如，`horizontal` prop 使我们的列表，嗯，水平。
- en: Now that we've successfully built our list of elements, which is the first step
    of creating a great onboarding experience, let's start building the paginator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功构建了我们的元素列表，这是创建一个出色的入门体验的第一步，让我们开始构建分页器。
- en: Paginator
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这四个小点在屏幕上显示分页器。它的主要目的是向用户显示他们当前正在查看的幻灯片，同时显示进度的感觉。这个小组件实现起来并不那么困难，但我们要使用的功能确保这个东西能够正常工作对我们来说是新的。
- en: The paginator is displayed on the screen by those four small dots. Its main
    purpose is to show the user which slide they're currently looking at while also
    displaying a sense of progress. This small component is not that hard to implement,
    but the features we're going to use to make sure this thing is working correctly
    are new to us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 分页器
- en: One of the most important objects we're going to work with for this component
    is the `Animated` object. This is needed because we're looking at animating the
    width and the opacity of our dots. This is also important because we want to make
    sure that the animation happens at the right moment. The right moment is, of course,
    while the user interacts with `FlatList`. If your finger moves from right to left,
    we want the animation to also move at the same pace as your finger.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个组件工作的最重要的对象之一是 `Animated` 对象。这是因为我们要动画化我们的点的宽度和不透明度。这也很重要，因为我们希望确保动画发生在正确的时刻。当然，正确的时刻是当用户与
    `FlatList` 交互时。如果你的手指从右向左移动，我们希望动画也以与你的手指相同的速度移动。
- en: We're also going to use a cool new Hook called `useRef`. This Hook is used when
    we need a mutable object that persists for the entire lifetime of your component.
    `useRef` will not cause your component to rerender when its value is changed because
    it's not a state variable, but it's a really good way to make sure that you'll
    get the same `ref` object on every render.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个很酷的新 Hook，叫做 `useRef`。当我们需要一个在组件整个生命周期内持续存在的可变对象时，就会使用这个 Hook。`useRef`
    不会导致组件在其值更改时重新渲染，因为它不是一个状态变量，但这确实是一种确保您在每次渲染时都会得到相同 `ref` 对象的好方法。
- en: 'So, let''s get started on this cool little component, which I''m sure you''re
    going to find helpful and reusable for future applications. We''ll start in `Onboarding.js`.
    Let''s begin by importing `useState` and `useRef` from `''react''`. We''ll also
    import `Animated` from `''react-native''`. After importing all of this, we''re
    ready to move on:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始这个很酷的小组件，我相信你会发现它对未来的应用程序很有帮助和可重用性。我们将从`Onboarding.js`开始。让我们首先从`'react'`中导入`useState`和`useRef`。我们还将从`'react-native'`中导入`Animated`。导入所有这些之后，我们就准备好继续了：
- en: '![Figure 10.9 – Fresh new imports for our Onboarding component'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 – 我们Onboarding组件的全新导入'
- en: '](Images/Figure_10.09_B17074.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.09_B17074.jpg)'
- en: Figure 10.9 – Fresh new imports for our Onboarding component
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 我们Onboarding组件的全新导入
- en: 'Now, let''s start implementing everything we need for our `Paginator` component.
    We''ll begin by creating two new ref objects that we''re going to implement in
    our `FlatList` component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现我们`Paginator`组件所需的一切。我们将首先创建两个新的引用对象，然后在我们的`FlatList`组件中实现它们：
- en: '![Figure 10.10 – Our newly created refs'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 – 我们新创建的引用'
- en: '](Images/Figure_10.10_B17074.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.10_B17074.jpg)'
- en: Figure 10.10 – Our newly created refs
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 我们新创建的引用
- en: Let's explain how this works. First of all, we'll begin with `scrollX`. This
    variable has a lot going on, so let's start from the beginning. We're creating
    a new ref object using the `useRef` Hook and we're initializing this new variable
    with `Animated.Value(0)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这是如何工作的。首先，我们将从`scrollX`开始。这个变量有很多事情要做，所以让我们从头开始。我们使用`useRef` Hook创建一个新的引用对象，并用`Animated.Value(0)`初始化这个新变量。
- en: '`Animated.Value` creates a value that can be animated. If we were to initialize
    this variable with just a number, such as `0`, React Native wouldn''t know how
    to handle it when it comes to animations.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animated.Value` 创建一个可以被动画化的值。如果我们只用一个数字比如`0`来初始化这个变量，React Native 在处理动画时就不知道该怎么处理了。'
- en: 'The `useRef` Hook returns an object that looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` Hook 返回一个像这样的对象：'
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To access the value stored in `current`, we must write `scrollX.current`. A
    workaround for this is to let JavaScript know we want to access that value by
    chaining `.current` to our `useRef` Hook.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`current`中存储的值，我们必须写`scrollX.current`。一个解决方法是让JavaScript知道我们想要通过在`useRef`
    Hook后面链接`.current`来访问那个值。
- en: 'The `viewConfig` variable works just as you''d expect it to work. Here, we
    must create a new ref object and initialize it with the object shown in *Figure
    10.10*, `{ viewAreaCoveragePercentThreshold: 50 }`. Now, let''s use these two
    new variables with our `FlatList` component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewConfig`变量的工作方式就像你期望的那样。在这里，我们必须创建一个新的引用对象，并用*图10.10*中显示的对象`{ viewAreaCoveragePercentThreshold:
    50 }`来初始化它。现在，让我们在我们的`FlatList`组件中使用这两个新变量：'
- en: '![Figure 10.11 – Implementing our new variables inside FlatList'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 – 在FlatList中实现我们的新变量'
- en: '](Images/Figure_10.11_B17074.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.11_B17074.jpg)'
- en: Figure 10.11 – Implementing our new variables inside FlatList
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 在FlatList中实现我们的新变量
- en: Things might look a bit complicated right now, but it's a lot easier than it
    looks. With that, we've added two new props to our `<FlatList />` component called
    `onScroll` and `viewabilityConfig`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能看起来有点复杂，但实际上比看起来要简单得多。有了这个，我们为我们的`<FlatList />`组件添加了两个新的props，分别是`onScroll`和`viewabilityConfig`。
- en: The `viewabilityConfig` prop is here to support our `pagingEnabled` prop, which
    is telling our list of components to move to the next or previous slide based
    on how far the user has swiped. By setting the `viewAreaCoveragePercentThreshold`
    value of `viewabilityConfig` to 50, we're telling our component to only go to
    the next slide if the user has already swiped more than or equal to 50% of our
    current slide.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewabilityConfig`属性在这里支持我们的`pagingEnabled`属性，它告诉我们的组件列表根据用户滑动的距离移动到下一个或上一个幻灯片。通过将`viewabilityConfig`的`viewAreaCoveragePercentThreshold`值设置为50，我们告诉我们的组件只有在用户已经滑动了当前幻灯片的50%或更多时才会转到下一个幻灯片。'
- en: 'The `onScroll` prop is firing a function every time the user scrolls through
    the slides of our onboarding screen. You might be wondering what `Animated.event`:
    does? It maps an animated value to an event value. I agree, the function looks
    pretty chaotic, but it''s pretty easy to understand if we learn how to read it.
    So, we''re mapping our `scrollX` value to the `nativeEvent.contentOffset.x` event
    value. This event value is usually passed to the `onScroll` callback, so remember
    that you might see or use this more often than you think.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`onScroll`属性在用户滚动我们的引导屏幕的幻灯片时触发一个函数。你可能想知道`Animated.event`是什么？它将一个动画值映射到一个事件值。我同意，这个函数看起来很混乱，但如果我们学会如何阅读它，就很容易理解。所以，我们将我们的`scrollX`值映射到`nativeEvent.contentOffset.x`事件值。这个事件值通常传递给`onScroll`回调函数，所以记住你可能会经常看到或使用它。'
- en: The `Animated.event` function accepts two arguments. The first argument is the
    array of values that we're going to want to map to our **Animated** values. This
    `event()` function does this by calling the `setValue()` function on the mapped
    outputs; in this case, on `scrollX`. The second argument is a `configuration`
    object, which we're using to tell React Native that we don't want to use the native
    drivers for our animation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animated.event`函数接受两个参数。第一个参数是我们要映射到我们的**Animated**值的值数组。这个`event()`函数通过在映射的输出上调用`setValue()`函数来实现这一点；在这种情况下，是在`scrollX`上。第二个参数是一个`configuration`对象，我们在这里告诉React
    Native我们不想使用本地驱动程序来进行动画。'
- en: You might assume that by using the native drivers, we might have better performance
    and this is correct. The reason why we don't want to use the native drivers in
    this specific use case is because we're going to animate the width of our dots
    and right now, React Native can't use the native driver to animate width or layout
    properties in general.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为通过使用本地驱动程序，我们可能会有更好的性能，这是正确的。我们之所以不想在这种特定的用例中使用本地驱动程序的原因是因为我们将要动画化我们的点的宽度，而现在，React
    Native不能使用本地驱动程序来动画化宽度或一般的布局属性。
- en: Now that we know why we need `scrollX` and `viewConfig`, we should start building
    our new component. Create a new file inside the `components/` folder called `Paginator.js`.
    Now that we've created a new file, we should start building our functional component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道为什么我们需要`scrollX`和`viewConfig`，我们应该开始构建我们的新组件。在`components/`文件夹内创建一个名为`Paginator.js`的新文件。现在我们已经创建了一个新文件，我们应该开始构建我们的功能组件。
- en: 'We''ll start by importing everything necessary from `''react-native''`; that
    is, `StyleSheet`, `View`, `Animated`, and `useWindowDimensions`. The next step
    is building our function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`'react-native'`中导入所有必要的内容；即`StyleSheet`、`View`、`Animated`和`useWindowDimensions`。下一步是构建我们的函数：
- en: '![Figure 10.12 – Paginator component almost completed'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12 – Paginator组件几乎完成'
- en: '](Images/Figure_10.12_B17074.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.12_B17074.jpg)'
- en: Figure 10.12 – Paginator component almost completed
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – Paginator组件几乎完成
- en: There's a bunch of new stuff here, so let's start explaining everything from
    top to bottom.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新东西，所以让我们从上到下开始解释一切。
- en: This component, which we've called `Paginator`, accepts two props called `data`
    and `scrollX`. `data` is the array of objects we passed to `FlatList`, while `scrollX`
    is the `Animated` value we defined in our `Onboarding.js` file (our parent component).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件，我们称之为`Paginator`，接受两个名为`data`和`scrollX`的props。`data`是我们传递给`FlatList`的对象数组，而`scrollX`是我们在`Onboarding.js`文件（我们的父组件）中定义的`Animated`值。
- en: We've already discussed that the `useWindowDimensions()` Hook returns the `width`
    and `height` properties of our screen, so that should be easy to understand.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过`useWindowDimensions()` Hook返回屏幕的`width`和`height`属性，所以这应该很容易理解。
- en: 'We''ve given the styles of `flexDirection: ''row''` and a `height` of `64px`
    to our `<View />` component, which contains the *soul* of our component. We''ve
    done this to make sure the dots we''ll be creating are going to be sitting nicely
    in a row.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '我们给`<View />`组件的样式设置了`flexDirection: ''row''`和`height`为`64px`，这个组件包含了我们组件的*灵魂*。我们这样做是为了确保我们将要创建的点会很好地排列在一行中。'
- en: After that, we used the `.map()` function to map over the array. As you can
    see, the `map()` function accepts a callback function that takes in two arguments.
    The first one, `_`, will be our element, while the second one, `i`, is going to
    give us the index of that element.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`.map()`函数来映射数组。正如你所看到的，`map()`函数接受一个回调函数，该函数接受两个参数。第一个参数`_`将是我们的元素，而第二个参数`i`将给出该元素的索引。
- en: 'So, for each element in our array, we''re creating a dot. How do we do that?
    Let''s jump straight to our `return` statement to find out. Here, we''re returning
    a `<View />` component with `styles.dot` applied to it. The reason why we''re
    calling it `<Animated.View />` is because we want to animate this component. But
    before we start to animate it, this could just be a normal `<View />` component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于数组中的每个元素，我们都在创建一个点。我们如何做到这一点呢？让我们直接跳到我们的`return`语句来找出答案。在这里，我们返回一个应用了`styles.dot`的`<View
    />`组件。我们之所以称它为`<Animated.View />`是因为我们想要动画化这个组件。但在我们开始动画化它之前，这可能只是一个普通的`<View
    />`组件：
- en: '![Figure 10.13 – Styles for our dots'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13 – 我们的点的样式'
- en: '](Images/Figure_10.13_B17074.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.13_B17074.jpg)'
- en: Figure 10.13 – Styles for our dots
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 我们的点的样式
- en: These are the styles we were using to create the dots. As you can see, there
    is no `width`, which is because we want to animate the width of the dot. However,
    if we were to never animate it, we could've just gone right ahead and given it
    a `width` of `10px`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们用来创建点的样式。正如你所看到的，没有`width`，这是因为我们想要动画化点的宽度。然而，如果我们永远不想要动画化它，我们本来可以直接给它一个`width`为`10px`。
- en: So, let's get back to how we animate the width of our dots. As you can see,
    we have a variable called `inputRange` that is an array of values based on the
    width of the screen and our dot's index. As we know, a slide occupies the full
    width of the screen. Knowing that, we can understand that a slide has changed
    when `contentOffset.x` is equal to the width of the screen. It's called `contentOffset`
    because it gives us the offset between two elements. It starts at `0` when the
    first slide is on the screen. Once that slide moves out of the screen and the
    next slide comes in, the difference between the last slide and the next one is
    equal to the width of the screen. Understanding how `contentOffset` works enables
    us to think of a way to start creating animations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们回到如何动画化我们点的宽度。正如你所看到的，我们有一个名为`inputRange`的变量，它是基于屏幕宽度和我们点的索引的值数组。我们知道，幻灯片占据了屏幕的整个宽度。知道这一点，我们可以理解当`contentOffset.x`等于屏幕宽度时，幻灯片已经改变了。它被称为`contentOffset`，因为它给出了两个元素之间的偏移量。当第一张幻灯片在屏幕上时，它从`0`开始。一旦该幻灯片移出屏幕，下一张幻灯片进入时，最后一张幻灯片和下一张幻灯片之间的差值等于屏幕的宽度。了解`contentOffset`的工作原理使我们能够考虑一种开始创建动画的方法。
- en: '*What exactly makes an animation?* I feel like this is a great place where
    we can define how exactly an animation works. Let''s imagine we have a box on
    the screen and whenever someone presses a button, we want that box to appear.
    Of course, it can suddenly appear on the screen, but that doesn''t look that good.
    This is where animations come in. Instead of suddenly appearing on the screen,
    what if we had a smoother transition? What if the box transitioned into existence
    over some time? That would look more like an animation, right?'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*到底是什么构成了动画？* 我觉得这是一个很好的地方，我们可以定义动画是如何工作的。让我们想象屏幕上有一个盒子，每当有人按下按钮，我们希望那个盒子出现。当然，它可以突然出现在屏幕上，但那看起来不太好。这就是动画发挥作用的地方。与其突然出现在屏幕上，不如我们有一个更平滑的过渡。如果盒子在一段时间内过渡到存在状态呢？那看起来更像是一个动画，对吧？'
- en: 'This is the same concept we''re applying here: we want the movement of our
    dots to be completely in sync with the movement of our slides. So, we need our
    dot''s width to grow at the same time as we move our finger on the screen because
    this creates a smoother experience for our users.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在这里应用的概念相同：我们希望我们点的移动完全与幻灯片的移动同步。因此，我们需要我们点的宽度在我们在屏幕上移动手指的同时增长，因为这会为我们的用户创造更流畅的体验。
- en: Keeping that in mind, we've mapped the animated value of `scrollX` to our `nativeEvent.contentOffset.x`
    event value. Now, we can access the exact amount of change between two elements
    in our horizontal list via `scrollx`. Based on that amount, we need to change
    the width.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，我们已经将`scrollX`的动画值映射到我们的`nativeEvent.contentOffset.x`事件值。现在，我们可以通过`scrollx`访问水平列表中两个元素之间的确切变化量。根据这个量，我们需要改变宽度。
- en: 'But there''s a *problem*: our dot''s `height` is `10px`, so if we want our
    dot to be, well, a dot, then we''d need `width` to be `10px` as well. The problem
    is that our `scrollX` will go way beyond `10px` because our screen''s width is
    bigger, so how can we let React Native know that we want our current dot to have
    a bigger width and the rest of the dots to have a width of `10px`? With **interpolation**.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个*问题*：我们点的`高度`是`10px`，所以如果我们希望我们的点是一个点，那么我们也需要`宽度`是`10px`。问题是我们的`scrollX`会远远超过`10px`，因为我们屏幕的宽度更大，那么我们如何让React
    Native知道我们希望我们当前的点具有更大的宽度，而其余的点的宽度为`10px`呢？通过**插值**。
- en: Interpolation
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值
- en: So, let's recap for a second. We want the dot corresponding to the slide we're
    viewing at this moment to have a bigger width (let's say, `20px`) than the ones
    that are corresponding to the slides that are out of our view. The only way we
    can do this is with interpolation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们简要回顾一下。我们希望与我们正在查看的幻灯片对应的点具有比我们视野之外的幻灯片对应的点更大的宽度（假设为`20px`）。我们唯一能做到这一点的方法就是插值。
- en: Interpolation is the way we're estimating the output of a function based on
    the input we've provided.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是我们根据提供的输入来估计函数输出的方式。
- en: Let's assume we have a function where all we know about it is that `f(0) = 0`
    and `f(10) = 20`. Can you guess what `f(5)` will be equal to?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数，我们只知道`f(0) = 0`和`f(10) = 20`。你能猜到`f(5)`将等于多少吗？
- en: '![](Images/B17074_Table_1.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/B17074_Table_1.jpg)'
- en: Based on this table, we could suggest `10` as the answer to our question because
    `5` is between `0` and `10` and we know the answer should be between `0` and `20`.
    This intuitive approach is what interpolation does.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个表格，我们可以建议`10`作为我们问题的答案，因为`5`介于`0`和`10`之间，而我们知道答案应该介于`0`和`20`之间。这种直观的方法就是插值所做的事情。
- en: 'So, now that we know how our values need to behave, we can take a look at the
    interpolation function for our dot''s width:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们知道我们的值需要如何行为，我们可以看一下点宽度的插值函数：
- en: '![Figure 10.14 – The interpolate function'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.14 – 插值函数'
- en: '](Images/Figure_10.14_B17074.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.14_B17074.jpg)'
- en: Figure 10.14 – The interpolate function
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 - 插值函数
- en: So, we want this function to return a value between `10` and `20` based on the
    user's current position. Our `inputRange` variable, as we mentioned earlier, is
    defined by the index of that specific slide and the width of the screen. The first
    value in our `inputRange` variable is represented by the previous slide, the second
    value is represented by the current slide, and the third value is represented
    by the next slide. Based on that input, we've created an `outputRange` where we
    know that the previous slide's dot should have a width of `10px`, the current
    slide dot's width should be `20px`, and the next slide's dot width should be `10px`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们希望这个函数根据用户当前位置返回一个介于`10`和`20`之间的值。我们的`inputRange`变量，正如我们之前提到的，是由特定幻灯片的索引和屏幕宽度定义的。`inputRange`变量中的第一个值由前一个幻灯片表示，第二个值由当前幻灯片表示，第三个值由下一个幻灯片表示。基于这个输入，我们创建了一个`outputRange`，在这个范围内，我们知道前一个幻灯片的点应该有`10px`的宽度，当前幻灯片的点的宽度应该是`20px`，下一个幻灯片的点的宽度应该是`10px`。
- en: Guessing which value should be returned based on `inputRange` is React Native's
    job, but what we're really interested in is the value itself. Now, we can go to
    our `<Animated.View />` component and have the width of each dot equal to `dotWidth`,
    which is the value that's given to us by interpolation. Now, the width will change
    at the same time as the user swipes their finger.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`inputRange`猜测应返回哪个值是React Native的工作，但我们真正感兴趣的是值本身。现在，我们可以去我们的`<Animated.View
    />`组件，让每个点的宽度等于`dotWidth`，这是插值给我们的值。现在，宽度将随着用户滑动手指而改变。
- en: Extrapolation
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外推
- en: We also have another cool little thing here called `extrapolate`. So, we know
    our `inputRange` is only taking the previous, current, and next slide into consideration,
    but what about the fourth one? Because we haven't specified any value for the
    fourth one, React Native can start guessing what the width should be for itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个很酷的小东西叫做`extrapolate`。所以，我们知道我们的`inputRange`只考虑了前一个、当前和下一个幻灯片，但第四个呢？因为我们没有为第四个指定任何值，React
    Native可以开始猜测宽度应该是多少。
- en: If we run the code without a little help from extrapolation, we might see some
    weird results. I encourage you to delete the `extrapolate` line and see what happens
    for yourself.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有外推的情况下运行代码，可能会看到一些奇怪的结果。我鼓励你删除`extrapolate`行，看看发生了什么。
- en: We can solve those weird results by adding `extrapolate` to our `interpolate`
    function. This will tell React Native *what should happen outside of the ranges
    we've provided* and what kind of pattern the outside values should follow. This
    is great when we have no idea what the boundaries of our range are. In this case,
    the solution will be to **clamp** your ranges. This means that whatever comes
    before or after that range, we'll keep the last given value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`extrapolate`添加到我们的`interpolate`函数中来解决这些奇怪的结果。这将告诉React Native*在我们提供的范围之外应该发生什么*，以及外部值应该遵循什么样的模式。当我们不知道范围的边界时，这非常有用。在这种情况下，解决方案将是**夹紧**你的范围。这意味着无论范围之前或之后发生什么，我们都将保留最后给定的值。
- en: 'By using `extrapolate: ''clamp''`, you''re going to clamp the range from both
    sides, but if a specific case requires it, you can always clamp only the side
    of the range that you need. This means you could clamp to the left of the range
    or the right as well.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用`extrapolate: ''clamp''`，你将夹紧范围的两侧，但如果特定情况需要，你也可以只夹紧你需要的范围的一侧。这意味着你可以夹紧范围的左侧或右侧。'
- en: Tip
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The default mode for extrapolation is `extend`, which is React Native guessing
    the values of our range.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 外推的默认模式是`extend`，这是React Native猜测我们范围的值。
- en: Great! Now that we've explained how to interpolate and extrapolate, we've understood
    how (and based on what) the `dotWidth` variable changes. Because this is all done
    with a `scrollX` animated value, we've placed the `dotWidth` variable inside a
    `<Animated.View />`. Now, our width changes based on our scrolling behavior.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经解释了如何插值和外推，我们已经理解了`dotWidth`变量是如何改变的（以及基于什么）。因为这一切都是用`scrollX`动画值完成的，我们已经将`dotWidth`变量放在了`<Animated.View
    />`中。现在，我们的宽度根据我们的滚动行为而改变。
- en: What's left? Well, I feel like it'd be cool to see the opacity changing as well.
    The current dot should have an opacity equal to `1`, while the other dots should
    have an opacity of `0.4`. Based on this information, try to do this by yourself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下什么？嗯，我觉得看到不透明度也在变化会很酷。当前的点应该具有等于`1`的不透明度，而其他点应该具有`0.4`的不透明度。根据这些信息，试着自己做一下。
- en: If you couldn't do it, worry not! This is a lot easier than it may seem. Let
    me show you!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做不到，不要担心！这比看起来要容易得多。让我来演示给你看！
- en: '![Figure 10.15 – Animating the opacity of our dots'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15 – 动画化我们的点的不透明度'
- en: '](Images/Figure_10.15_B17074.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.15_B17074.jpg)'
- en: Figure 10.15 – Animating the opacity of our dots
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 动画化我们的点的不透明度
- en: Doesn't look that hard, right? We've done the same thing we've done with `dotWidth`
    but this time, we've created a new variable called `opacity`. We know that the
    opacity of an element is between `0` and `1`, so we've changed `outputRange` so
    that it fits our needs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来并不难，对吧？我们做了和`dotWidth`一样的事情，但这次我们创建了一个名为`opacity`的新变量。我们知道元素的不透明度在`0`和`1`之间，所以我们改变了`outputRange`以适应我们的需求。
- en: After that, we introduced our opacity value inside the `style` prop of our `<Animated.View
    />` component.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在`<Animated.View />`组件的`style`属性中引入了我们的不透明度值。
- en: 'Now that we''re done with the `Paginator` component, we should implement it
    inside our `Onboarding.js` file. We know how to do that already: import the component
    and then place it underneath the `<Block />` component, which has a `flex` of
    `3` applied to it. Don''t forget to pass it the necessary props.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Paginator`组件，我们应该在`Onboarding.js`文件中实现它。我们已经知道如何做了：导入组件，然后将其放在具有`flex`为`3`的`<Block
    />`组件下面。不要忘记传递必要的props。
- en: We've learned a lot of things about how animation should work by building this
    `Paginator` component and for that, I must congratulate you! We've made some impressive
    progress in this chapter. Now, it's time to start adding some functionality to
    our screen. Let's learn how we can do that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建这个`Paginator`组件，我们学到了很多关于动画应该如何工作的东西，对此我必须向你表示祝贺！在本章中，我们取得了一些令人印象深刻的进展。现在，是时候开始为我们的屏幕添加一些功能了。让我们学习如何做到这一点。
- en: Automatic scrolling
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动滚动
- en: 'To finish building this project, we''re going to have to create a button that
    moves the slides whenever we press it. We already have the `<Button />` component
    imported from `''galio-framework''`, so let''s implement it underneath our `<Paginator
    />` component:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个项目的构建，我们需要创建一个按钮，当我们按下它时移动幻灯片。我们已经从'galio-framework'导入了`<Button />`组件，所以让我们在`<Paginator
    />`组件下面实现它：
- en: '![Figure 10.16 – The Button component added to our onboarding screen'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16 – 将按钮组件添加到我们的引导屏幕上'
- en: '](Images/Figure_10.16_B17074.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.16_B17074.jpg)'
- en: Figure 10.16 – The Button component added to our onboarding screen
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 将按钮组件添加到我们的引导屏幕上
- en: As you can see, I've implemented `Button` below `<Paginator />`. I've added
    the same color our images and dots are and removed the shadow via the `shadowless`
    prop. Now that we know that our function needs to be called whenever we press
    the button, we need to create a function and then link it to our `onPress` prop.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我在`<Paginator />`下面实现了`Button`。我添加了与我们的图像和点相同的颜色，并通过`shadowless`属性去除了阴影。现在我们知道我们的函数需要在按下按钮时被调用，我们需要创建一个函数，然后将其链接到我们的`onPress`属性。
- en: But before we do that, we need to make sure we have anything in place for our
    button to work whenever we need it to.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这之前，我们需要确保我们已经准备好让我们的按钮在需要时起作用。
- en: First, we need to think about how we can get to the next slide without swiping
    through our list of slides. Well, we'll need a reference to the `FlatList` component.
    Having a reference to that object allows us to control it from an external function
    whenever we want.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑如何在不通过滑动列表的情况下到达下一张幻灯片。嗯，我们需要一个对`FlatList`组件的引用。拥有对该对象的引用允许我们在需要时从外部函数控制它。
- en: Secondly, we need to keep track of our slides as we need to know which slide
    we are on at all times. We can do that with a state variable that keeps track
    of the index that's currently being displayed on the screen.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要跟踪我们的幻灯片，因为我们需要始终知道我们在哪张幻灯片上。我们可以通过一个状态变量来实现，该变量跟踪当前在屏幕上显示的索引。
- en: Now, let's start solving these issues first before we look at what else we need
    to do to make sure this works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先解决这些问题，然后再看看我们需要做什么来确保这个工作。
- en: 'Let''s create a state variable using the `useState` Hook, which we''ve already
    imported:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们已经导入的`useState` Hook来创建一个状态变量：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here is where we're going to store the index of the currently shown slide.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将存储当前显示幻灯片的索引。
- en: 'Now, let''s create a ref variable:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个ref变量：
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we've finished creating our ref variable, we should apply it to our `<FlatList
    />` component. We can do that using `ref={slidesRef}`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成创建我们的ref变量，我们应该将它应用到我们的`<FlatList />`组件上。我们可以使用`ref={slidesRef}`来做到这一点。
- en: Next, we're going to use a prop that's already available to us from `FlatList`
    called `onViewableItemsChange`. Whenever you scroll through `FlatList`, the items
    on `FlatList` will change as well. When those items change, this function is called,
    telling you what current `viewableItems` are available. This prop should always
    be used with `viewabilityConfig`. The `onViewableItemsChange` function will be
    called whenever the corresponding conditions of `viewabilityConfig` are met.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`FlatList`已经提供给我们的一个属性，叫做`onViewableItemsChange`。每当你滚动`FlatList`时，`FlatList`上的项目也会发生变化。当这些项目发生变化时，将调用这个函数，告诉你当前有哪些`viewableItems`。这个属性应该始终与`viewabilityConfig`一起使用。当满足`viewabilityConfig`的相应条件时，`onViewableItemsChange`函数将被调用。
- en: 'This will help us make sure we always have the right index for our displayed
    slide. So, inside the function, we''ll have to make sure that we set the current
    index to the one being displayed:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们确保我们始终有正确的索引来显示幻灯片。因此，在函数内部，我们必须确保将当前索引设置为正在显示的索引：
- en: '[PRE7]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looking at this might seem a little bit weird but as we discussed earlier, the
    function will return what current `viewableItems` there are.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有点奇怪，但正如我们之前讨论的那样，该函数将返回当前的`viewableItems`。
- en: The thing is… only one item can be displayed at a time, so the array of `viewableItems`
    is going to have a single element inside of it. Because what we're interested
    in is the index of that element, we're setting the `currentIndex` state variable
    so that it's equal to `viewableItems[0].index`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是...一次只能显示一个项目，所以`viewableItems`数组将只有一个元素。因为我们感兴趣的是该元素的索引，所以我们设置`currentIndex`状态变量，使其等于`viewableItems[0].index`。
- en: 'Now that we know which slide is currently being displayed, the next step is
    to just scroll to `currentIndex + 1`. For example, if we''re viewing the first
    slide, that means our `currentIndex` should be equal to `0`. Naturally, the next
    slide is going to be `currentIndex + 1`, which means `1`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道当前显示的幻灯片是哪一个，下一步就是滚动到`currentIndex + 1`。例如，如果我们正在查看第一张幻灯片，那么我们的`currentIndex`应该等于`0`。自然而然，下一张幻灯片将是`currentIndex
    + 1`，也就是`1`：
- en: '![Figure 10.17 – The final Onboarding component'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17 - 最终的Onboarding组件'
- en: '](Images/Figure_10.17_B17074.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_10.17_B17074.jpg)'
- en: Figure 10.17 – The final Onboarding component
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 - 最终的Onboarding组件
- en: Now that we've finished with `viewableItemsChanged` and we've used the variable
    with our `onViewableItemsChange` prop, let's explain how the `scrollTo` function
    works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`viewableItemsChanged`，并且使用了我们的`onViewableItemsChange`属性的变量，让我们解释一下`scrollTo`函数是如何工作的。
- en: As you can see, we've created a function called `scrollTo` that is called whenever
    we press our button. This function checks for `currentIndex` because we want different
    types of behaviors based on whether we're displaying the last slide or not. If
    this is the last slide, we won't do anything yet, but if it's the first three
    slides, we want it to scroll to the next one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们创建了一个名为`scrollTo`的函数，每当我们按下按钮时就会调用它。这个函数检查`currentIndex`，因为我们希望基于是否显示最后一张幻灯片来采取不同类型的行为。如果这是最后一张幻灯片，我们暂时不做任何事情，但如果是前三张幻灯片，我们希望它滚动到下一张幻灯片。
- en: As you can see, scrolling to the next slide is pretty easy – all we have to
    do is use the reference we have to the `<FlatList />` component and use the `scrollToIndex`
    function. That function needs an argument where we're telling it which index exactly
    to jump to.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，滚动到下一张幻灯片非常容易 - 我们所要做的就是使用我们对`<FlatList />`组件的引用，并使用`scrollToIndex`函数。该函数需要一个参数，告诉它要跳转到哪个索引。
- en: Now, we can hit **save**, reload our application, and there we have it – a beautiful
    onboarding screen with some cool little animations and a nice feature that scrolls
    the slides without us touching anything besides a button. It has been a long journey
    but I'm pretty sure you think it was worth it, now that we've seen what we're
    capable of.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以点击**保存**，重新加载我们的应用程序，然后我们就拥有了一个漂亮的入职屏幕，带有一些很酷的小动画，以及一个很好的功能，可以在我们除了按钮之外什么都不触摸的情况下滚动幻灯片。这是一个漫长的旅程，但我相信你会觉得这是值得的，现在我们已经看到了我们的能力。
- en: In the next chapter, we're going to build the rest of our app but for a nice
    experience, we're going to use this onboarding screen for our app. This will ensure
    that at the end of the slides, our button will jump us straight to the app.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建我们应用程序的其余部分，但为了获得良好的体验，我们将在我们的应用程序中使用这个入职屏幕。这将确保在幻灯片的末尾，我们的按钮将直接跳转到应用程序。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was one of the hardest challenges we've overcome so far. We've
    been through so many new concepts but in the end, we can happily say that we've
    successfully managed to create a great onboarding experience for our users. Even
    better, we've created a nice onboarding experience that we'll enjoy whenever we
    brag about our app.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是我们迄今为止克服的最艰难的挑战之一。我们经历了很多新概念，但最终，我们可以高兴地说，我们成功地为我们的用户创建了一个很棒的入职体验。更好的是，我们创建了一个很好的入职体验，每当我们吹嘘我们的应用程序时，我们都会享受到它。
- en: We started by discovering how this app will look and then went through all the
    necessary steps to produce that app. We saw what it takes to create a nice list
    of elements, which brought us to `FlatList`. We used this component at the core
    of our onboarding screen, and you'll surely keep using it in the future whenever
    you encounter big lists of elements.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先发现了这个应用程序的外观，然后经历了所有必要的步骤来制作该应用程序。我们看到了创建一个漂亮的元素列表需要什么，这让我们接触到了`FlatList`。我们在我们的入门屏幕的核心使用了这个组件，将来当你遇到大量元素的列表时，你肯定会继续使用它。
- en: We also learned how to create animations and how exactly interpolation works.
    By doing this, we managed to create a cool little paginator that displays the
    current slide our users are seeing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何创建动画，以及插值是如何工作的。通过这样做，我们成功地创建了一个很酷的小分页器，显示我们的用户正在看到的当前幻灯片。
- en: Finally, we even discovered that we can make things work without swiping left
    or right, just by pressing a button. For this, we used a reference object that
    is called from another function whenever we pressed that button.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们甚至发现我们可以通过按按钮而不是左右滑动来使事情运转。为此，我们使用了一个引用对象，每当我们按下按钮时，它就会从另一个函数中调用。
- en: This chapter might have been a lot, but I feel like you were ready for it. I
    hope you're prepared for the next chapter as well because we're going to finish
    this mobile app!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章可能有点多，但我觉得你已经准备好了。我希望你也为下一章做好了准备，因为我们将完成这个移动应用程序！
