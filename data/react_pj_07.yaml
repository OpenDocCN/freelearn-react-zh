- en: Build a Full Stack E-Commerce Application with React Native and GraphQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和GraphQL构建全栈电子商务应用程序
- en: If you're reading this, this means you've reached the final part of this book,
    which uses React to build web applications. In the preceding chapters, you've
    already used the core features of React, such as rendering components, state management
    with Context, and Hooks. You've learned how to create a PWA and an SSR application
    and how to add routing to your React application. Also, you know how to add testing
    to a React application with Jest and Enzyme. Let's add GraphQL to the list of
    things you've learned about so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在阅读本文，这意味着您已经到达了本书的最后部分，该部分使用React构建Web应用程序。在前面的章节中，您已经使用了React的核心功能，如渲染组件、使用Context进行状态管理和Hooks。您已经学会了如何创建PWA和SSR应用程序，以及如何将路由添加到您的React应用程序中。此外，您还知道如何使用Jest和Enzyme向React应用程序添加测试。让我们将GraphQL添加到您迄今为止学到的东西列表中。
- en: In this chapter, you will not only build the frontend of an application, but
    also the backend. For this, GraphQL will be used, which can best be defined as
    a query language for APIs. Using mock data and Apollo Server, you'll extend a
    GraphQL server that exposes a single endpoint for your React application. On the
    frontend side, this endpoint will be consumed using Apollo Client, which helps
    you handle sending requests to the server and state management for this data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您不仅将构建应用程序的前端，还将构建后端。为此，将使用GraphQL，它最好被定义为API的查询语言。使用模拟数据和Apollo Server，您将扩展一个GraphQL服务器，为您的React应用程序公开一个单一的端点。在前端方面，将使用Apollo
    Client来消耗此端点，它将帮助您处理向服务器发送请求以及此数据的状态管理。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Querying and mutating data with GraphQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL查询和变异数据
- en: Consuming GraphQL with Apollo Client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apollo Client消耗GraphQL
- en: Handling state management with GraphQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL处理状态管理
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a full stack e-commerce application that has
    a GraphQL server as a backend and consumes this server in React using Apollo Client.
    For both the backend and frontend, an initial application is available to get
    you started quickly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个全栈电子商务应用程序，后端使用GraphQL服务器，并在React中使用Apollo Client消耗此服务器。对于后端和前端，都有一个初始应用程序可供您快速开始。
- en: The build time is 3 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为3小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch7-initial](https://github.com/PacktPublishing/React-Projects/tree/ch7-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch7](https://github.com/PacktPublishing/React-Projects/tree/ch7).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建的项目是基于GitHub上可以找到的初始版本构建的：[https://github.com/PacktPublishing/React-Projects/tree/ch7-initial](https://github.com/PacktPublishing/React-Projects/tree/ch7-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch7](https://github.com/PacktPublishing/React-Projects/tree/ch7)。
- en: 'The initial project consists of both a boilerplate application based on Create
    React App to get you started quickly and a GraphQL server that you can run locally.
    You can find the application in the `client` directory and the GraphQL server
    can be found in the `server` directory. Both the initial application and the GraphQL
    server need dependencies installed and need to be running at all times during
    development, which you can do by running the following commands in both the `client`
    and `server` directories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 初始项目包括一个基于Create React App的样板应用程序，可以让您快速开始，并且一个GraphQL服务器，您可以在本地运行。您可以在`client`目录中找到应用程序，`server`目录中可以找到GraphQL服务器。初始应用程序和GraphQL服务器都需要安装依赖项，并且在开发过程中需要始终运行，您可以通过在`client`和`server`目录中运行以下命令来实现：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will install all of the dependencies that are needed to run both
    the React application and the GraphQL server, including `react`, `react-scripts`, `graphql`, and `apollo-server`.
    If you'd like to know about all of the dependencies that were installed, please
    have a look at the `package.json` files in both the `client` and `server` directories.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将安装运行React应用程序和GraphQL服务器所需的所有依赖项，包括`react`，`react-scripts`，`graphql`和`apollo-server`。如果您想了解安装的所有依赖项，请查看`client`和`server`目录中的`package.json`文件。
- en: After the installation process has finished, both the GraphQL server and the
    React application will be started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，将启动GraphQL服务器和React应用程序。
- en: Getting started with the initial React application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用初始React应用程序
- en: 'Since the React application is created by Create React App, it will automatically
    launch in your browser at `http://localhost:3000/`. This initial application doesn''t
    show any data as it still needs to be connected to the GraphQL server, which you''ll
    do later on in this chapter. At this point, the application will, therefore, render
    only a header with the title Ecommerce Store and a subheader as well, which looks
    something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React应用程序是由Create React App创建的，它将自动在浏览器中启动，网址是`http://localhost:3000/`。这个初始应用程序不显示任何数据，因为它仍然需要连接到GraphQL服务器，这将在本章后面进行。因此，此时应用程序将仅呈现一个标题为Ecommerce
    Store的标题和一个子标题，看起来像这样：
- en: '![](assets/63e36de1-c18c-4f1d-9701-6906f169f375.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63e36de1-c18c-4f1d-9701-6906f169f375.png)'
- en: 'The structure of this initial React application is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始React应用程序的结构如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `client/src` directory, you'll find the entry point to the application,
    which is `index.js`. This file will refer to the `App` component in `App.js`.
    The `App` component has a `Router` component that either renders the `Products` or `Cart` component,
    dependent on which URL the user is visiting. When no specific route is specified,
    the `Products` component will be rendered which consists of a `SubHeader` component,
    with `Button` to the `Cart` component, and a `map` function that returns a list
    of `ProductItem` components that display product information. The `/cart` route will
    render the `Cart` component that also has `SubHeader`, this time with `Button` to
    go back to the previous page. Also, again return a list of products will be returned
    and the `Totals` component will show the total number of products in the cart.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client/src`目录中，您将找到应用程序的入口点，即`index.js`。该文件将引用`App.js`中的`App`组件。`App`组件具有一个`Router`组件，根据用户访问的URL，它将呈现`Products`或`Cart`组件。当未指定特定路由时，将呈现`Products`组件，其中包括`SubHeader`组件，带有指向`Cart`组件的`Button`，以及返回显示产品信息的`ProductItem`组件列表的`map`函数。`/cart`路由将呈现`Cart`组件，该组件还具有`SubHeader`，这次带有返回到上一页的`Button`。同样，将返回产品列表，并且`Totals`组件将显示购物车中产品的总数。
- en: Getting started with the GraphQL server
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用GraphQL服务器
- en: Although you won't be making any code changes to the GraphQL server, it's important
    to know how the server is functioning and what the basic concepts of GraphQL are.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您不会对GraphQL服务器进行任何代码更改，但了解服务器的运行方式和GraphQL的基本概念是很重要的。
- en: GraphQL is best described as a query language for APIs and is defined as a convention
    for retrieving data from an API. Often, GraphQL APIs are compared to RESTful APIs,
    which is a well-known convention for sending HTTP requests that are dependant
    on multiple endpoints that will all return a separate data collection. As opposed
    to the well-known RESTful APIs, a GraphQL API will provide a single endpoint that
    lets you query and/or mutate data sources such as a database. You can query or
    mutate data by sending a document containing either a query or mutation operation
    to the GraphQL server. Whatever data is available can be found in the schema of
    the GraphQL server, which consists of types that define what data can be queried
    or mutated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 最好被描述为 API 的查询语言，并被定义为从 API 检索数据的约定。通常，GraphQL API 被比作 RESTful API，后者是发送
    HTTP 请求的众所周知的约定，这些请求依赖于多个端点，这些端点将返回单独的数据集。与众所周知的 RESTful API 相反，GraphQL API 将提供一个单一的端点，让您查询和/或改变数据源，比如数据库。您可以通过向
    GraphQL 服务器发送包含查询或变异操作的文档来查询或改变数据。无论可用的数据是什么，都可以在 GraphQL 服务器的模式中找到，该模式由定义可以查询或改变的数据的类型组成。
- en: 'The GraphQL server can be found in the `server` directory and provides a backend
    for the frontend React application that you''ll build in this chapter. This server is
    created using Express and Apollo Server, where Express is a framework to create
    APIs using JavaScript and Apollo Server is an open source package that helps you
    create GraphQL servers with a limited amount of code. After making sure you''ve
    run the `npm install` and `npm start` commands in the `server` directory, the
    GraphQL API becomes available on `http://localhost:4000/graphql` Apollo Server
    will run your GraphQL server on port `4000` by default. On this page in the browser,
    the GraphQL Playground will be displayed, and is where you can use and explore
    the GraphQL server. An example of this playground can be seen in the following
    screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器可以在 `server` 目录中找到，并为您在本章中构建的前端 React 应用程序提供后端支持。该服务器使用 Express 和
    Apollo Server 创建，其中 Express 是一个使用 JavaScript 创建 API 的框架，而 Apollo Server 是一个开源包，可以帮助您使用有限的代码创建
    GraphQL 服务器。确保您已在 `server` 目录中运行了 `npm install` 和 `npm start` 命令后，GraphQL API
    就可以在 `http://localhost:4000/graphql` 上使用。Apollo Server 默认会在端口 `4000` 上运行您的 GraphQL
    服务器。在浏览器的这个页面上，将显示 GraphQL Playground，您可以在其中使用和探索 GraphQL 服务器。以下是该 Playground
    的示例截图：
- en: '![](assets/2cee33f7-0d54-4d36-9b16-c3a05978bb0e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2cee33f7-0d54-4d36-9b16-c3a05978bb0e.png)'
- en: 'With this playground, you can send queries and mutations to the GraphQL server,
    which you can type on the left-hand side of this page. The queries and mutations
    that you''re able to send can be found in SCHEMA for this GraphQL server, which
    you can find by clicking on the green button labeled SCHEMA. This button will
    open an overview of SCHEMA, which shows you all of the possible return values
    of the GraphQL server:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个 Playground，您可以向 GraphQL 服务器发送查询和变异，您可以在本页面的左侧输入。您可以在此 GraphQL 服务器的 SCHEMA
    中找到可以发送的查询和变异，点击标有 SCHEMA 的绿色按钮即可找到。该按钮将打开 SCHEMA 的概述，显示 GraphQL 服务器的所有可能返回值：
- en: '![](assets/77154966-8d2a-4b7f-8485-4931c58619bb.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/77154966-8d2a-4b7f-8485-4931c58619bb.png)'
- en: 'Whenever you describe a query or mutation on the left-hand side of this page,
    the output that is returned by the server will be displayed on the right-hand
    side of the playground. The way a GraphQL query is constructed will determine
    the structure of the returned data since GraphQL follows the principle of *ask
    for what you need, get exactly that*. Since GraphQL queries always return predictable
    results, this means we can have a query that looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您在此页面的左侧描述查询或突变时，服务器返回的输出将显示在播放器的右侧。构造GraphQL查询的方式将决定返回数据的结构，因为GraphQL遵循“请求所需内容，获得确切内容”的原则。由于GraphQL查询始终返回可预测的结果，这意味着我们可以有这样的查询：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will return an output that will follow the same structure of the query
    that''s defined in the document that you sent to the GraphQL server and has the
    following format:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个输出，其结构将遵循您发送到GraphQL服务器的文档中定义的查询的相同结构，并具有以下格式：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Applications that are using GraphQL are often fast and stable because they control
    the data they get, not the server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GraphQL的应用程序通常快速且稳定，因为它们控制获取的数据，而不是服务器。
- en: In the next section, you'll connect the GraphQL server to the React web application
    using Apollo, and send documents to the server from your application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将使用Apollo将GraphQL服务器连接到React Web应用程序，并从应用程序向服务器发送文档。
- en: Building a full stack e-commerce application with React, Apollo, and GraphQL
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React、Apollo和GraphQL构建全栈电子商务应用程序
- en: In this section, you'll connect the React web application to the GraphQL server.
    Apollo Server is used to create a single GraphQL endpoint that uses dynamic mock
    data as a source. Apollo Client is used by React to consume this endpoint and
    handle state management for your application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将连接React Web应用程序到GraphQL服务器。Apollo Server用于创建一个使用动态模拟数据作为源的单个GraphQL端点。React使用Apollo
    Client来消耗此端点并处理应用程序的状态管理。
- en: Adding GraphQL to a React application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将GraphQL添加到React应用程序
- en: With the GraphQL server in place, let's move on to the part where you make requests
    to this server from a React application. For this, you'll use Apollo packages
    that help you add an abstraction layer between your application and the server.
    That way, you don't have to worry about sending documents to the GraphQL endpoint
    yourself by using, for example, `fetch`, and can send documents directly from
    a component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL服务器已经就位，让我们继续进行从React应用程序向该服务器发出请求的部分。为此，您将使用Apollo软件包，该软件包可帮助您在应用程序和服务器之间添加一个抽象层。这样，您就不必担心自己通过例如`fetch`发送文档到GraphQL端点，而是可以直接从组件发送文档。
- en: 'As we mentioned previously, you can use Apollo to connect to the GraphQL server;
    for this, Apollo Client will be used. With Apollo Client, you can set up the connection
    with the server, handle queries and mutations, and enable caching for data that''s
    been retrieved from the GraphQL server, among other things. Apollo Client is added
    to your application by following these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以使用Apollo连接到GraphQL服务器；为此，将使用Apollo Client。使用Apollo Client，您可以建立与服务器的连接，处理查询和突变，并为从GraphQL服务器检索的数据启用缓存，等等。通过以下步骤将Apollo
    Client添加到您的应用程序：
- en: 'To install Apollo Client and its related packages, you need in order to run
    the following command from the `client` directory where the React application
    is initialized:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Apollo Client及其相关软件包，您需要在初始化React应用程序的`client`目录中运行以下命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will install not only Apollo Client but also the other dependencies you
    need to use Apollo Client and GraphQL in your React application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装不仅Apollo Client，还将安装您在React应用程序中使用Apollo Client和GraphQL所需的其他依赖项：
- en: '`apollo-link-http` will connect with the GraphQL server'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-link-http`将与GraphQL服务器连接'
- en: '`react-apollo` will provide the components you need to send queries to and
    mutations and handle the data flow'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-apollo`将提供您发送查询和突变以及处理数据流所需的组件。'
- en: '`graphql` and `graphql-tag` will handle GraphQL and write in the query language'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql`和`graphql-tag`将处理GraphQL并编写查询语言'
- en: 'These packages should be imported into the file where you want to create the
    Apollo Client, which, in this case, would be `client/src/App.js`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些包应该被导入到您想要创建Apollo Client的文件中，在这种情况下，将是`client/src/App.js`：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now you can define the `client` constant using the `ApolloClient` class and
    use `HttpLink` to make the connection with the GraphQL server; therefore, create
    a `client` constant like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用`ApolloClient`类定义`client`常量，并使用`HttpLink`与GraphQL服务器建立连接；因此，可以创建如下的`client`常量：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within the `return` function for the `App` component, you need to add `ApolloProvider`
    and pass `client` you''ve just created as a prop:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件的`return`函数中，您需要添加`ApolloProvider`并将刚刚创建的`client`作为属性传递：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After these steps, all of the components that are nested within `ApolloProvider`
    can access this `client` and send documents with queries and/or mutations to the
    GraphQL server. The method for getting data from `ApolloProvider` is similar to
    how the context API interacts with the Context value and will be demonstrated
    in the next part of this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些步骤，所有嵌套在`ApolloProvider`中的组件都可以访问此`client`并发送带有查询和/或突变的文档到GraphQL服务器。从`ApolloProvider`获取数据的方法类似于上下文API与上下文值的交互，并将在本节的下一部分中进行演示。
- en: Sending GraphQL queries with React
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React发送GraphQL查询
- en: The `react-apollo` package doesn't only export a Provider but also methods to
    consume the value from this Provider. That way, you can easily get any value using
    the client that was added to the Provider. One of those methods is `Query`, which
    helps you to send a document containing a query to the GraphQL server, without
    having to use a `fetch` function, for example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-apollo`包不仅导出Provider，还导出了从此Provider中消耗值的方法。这样，您可以使用添加到Provider的客户端轻松获取任何值。其中之一是`Query`，它可以帮助您发送包含查询的文档到GraphQL服务器，而无需使用`fetch`函数，例如。'
- en: Since a `Query` component should always be nested inside an `ApolloProvider`
    component, they can be placed in any component that's been rendered within `App`.
    One of those is the `Products` component in `client/src/components/Product/Products.js`.
    This component is being rendered for the `/` route and should display products
    that are available in the e-commerce store.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Query`组件应始终嵌套在`ApolloProvider`组件内，它们可以放置在已在`App`中呈现的任何组件中。其中之一是`client/src/components/Product/Products.js`中的`Products`组件。该组件被呈现为`/`路由，并应显示电子商务商店中可用的产品。
- en: 'To send a document from the `Products` component, follow these steps, which
    will guide you in the process of sending documents using `react-apollo`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要从“Products”组件发送文档，请按照以下步骤进行操作，这些步骤将指导您使用“react-apollo”发送文档的过程：
- en: 'The query to get products from the GraphQL server can be found using the introspection
    methods in the playground or from the `server/typeDefs.js` file, and looks as
    follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用播放器中的内省方法或`server/typeDefs.js`文件找到从GraphQL服务器获取产品的查询，并且如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Sending this document with a query to the GraphQL server will return an array
    consisting of objects with product information, which has a limit of 10 products
    by default. The result will be returned in JSON format and will consist of different
    products every time you send the requests, since the data is mocked by the GraphQL
    server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询将此文档发送到GraphQL服务器将返回一个由产品信息对象组成的数组，默认情况下每次返回10个产品。结果将以JSON格式返回，并且每次发送请求时都会包含不同的产品，因为数据是由GraphQL服务器模拟的。
- en: 'In the `Products` component, you can import the `Query` component from `react-apollo`
    and define a constant for the named `getProducts` query. Also, you need to import
    `gql` from `graphql-tag` to use the GraphQL query language inside your React file,
    which is given as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Products`组件中，您可以从`react-apollo`导入`Query`组件并为命名为`getProducts`的查询定义一个常量。此外，您需要从`graphql-tag`导入`gql`，以在React文件中使用GraphQL查询语言，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The imported `Query` component can be returned from `Products` and handle the
    data fetching process based on the query that you pass to it as a prop. In the
    same way as the context API, `Query` can consume the data from the Provider by
    returning a `data` variable. You can iterate over the `products` field from this
    object and return a list of `ProductItem` components by adding the `Query` component:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入的`Query`组件可以从`Products`返回，并根据您作为prop传递给它的查询处理数据获取过程。与上下文API一样，`Query`可以通过返回`data`变量来消耗Provider中的数据。您可以遍历此对象中的`products`字段，并通过添加`Query`组件返回`ProductItem`组件的列表：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Not only will the `Query` component return a `data` object, but it will also
    return the `loading` and `error` variables. So, instead of setting a default value
    for the `loading` prop, you can use this value and return a loading message if
    its value is `true`. For the `error` variable, you apply the same approach. Also,
    the default value for the `Products` prop is hereby no longer used and can be
    deleted:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Query`组件不仅会返回一个`data`对象，还会返回`loading`和`error`变量。因此，您可以使用这个值而不是为`loading` prop设置默认值，并在其值为`true`时返回加载消息。对于`error`变量，您也可以采用相同的方法。此外，`Products`
    prop的默认值不再使用，可以删除：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will send a document with the `GET_PRODUCTS` query to the GraphQL server
    when your application mounts and subsequently display the product information
    in the list of the `ProductItem` components. After adding the logic to retrieve
    the product information from the GraphQL server, your application will look similar
    to the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序挂载并随后在`ProductItem`组件的列表中显示产品信息时，将向GraphQL服务器发送带有`GET_PRODUCTS`查询的文档。在添加逻辑以从GraphQL服务器检索产品信息之后，您的应用程序将类似于以下内容：
- en: '![](assets/9ed5e8e6-fb2d-4da5-a311-f510e4fede79.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ed5e8e6-fb2d-4da5-a311-f510e4fede79.png)'
- en: 'Since the `Cart` component on the `/cart` route also needs to query data from
    the GraphQL server, changes to the `src/components/Cart/Cart.js` file should be
    made as well. Just like we did for `Products`, a `Query` component should be added
    to retrieve data from the server and can be done by following these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`/cart`路由上的`Cart`组件还需要从GraphQL服务器查询数据，因此还应该对`src/components/Cart/Cart.js`文件进行更改。就像我们为`Products`所做的那样，应该添加一个`Query`组件来从服务器检索数据，并且可以通过以下步骤完成：
- en: 'Start by importing the dependencies that are needed to send queries to the
    GraphQL server, which are `react-apollo` to get the `Query` component and `graphql-tag`
    to use the GraphQL query language to define the query you want to send to GraphQL:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入发送查询到GraphQL服务器所需的依赖项，即`react-apollo`以获取`Query`组件和`graphql-tag`以使用GraphQL查询语言来定义要发送到GraphQL的查询。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, you can define `query`, which should be sent in the document. This
    will retrieve the information for `cart`, including any `products` that might
    be in `cart`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可以定义`query`，应该在文档中发送。这将检索`cart`的信息，包括可能在`cart`中的任何`products`：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the existing code for the `Cart` component with the following, where
    the `Query` component is implemented and the `Cart` component only receives the `match`
    and `history` props. Therefore, you''d need to replace the code for this component
    with the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`Cart`组件的现有代码，其中实现了`Query`组件，而`Cart`组件仅接收`match`和`history` props。因此，您需要用以下内容替换此组件的代码：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This won''t show any products yet as the cart is empty; the cart will be filled
    with products in the next section. However, let''s proceed by adding a `Query` component
    to the button to the cart with a placeholder counter in `SubHeader` for the `/` route.
    Therefore, a new file called `CartButton.js` can be created in the `client/src/components/Cart` directory.
    In this file, a `Query` component will return data from a query that requests
    the total number of products in the cart. Also, we can add a value to the `Button` component
    by adding the following code to this file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于购物车是空的，所以现在不会显示任何产品；购物车将在下一节中填满产品。然而，让我们继续在`SubHeader`的`/`路由中为购物车的按钮添加一个`Query`组件，以及一个占位符计数。因此，在`client/src/components/Cart`目录中可以创建一个名为`CartButton.js`的新文件。在这个文件中，一个`Query`组件将从一个查询中返回购物车中产品的总数。此外，我们可以通过在这个文件中添加以下代码来为`Button`组件添加一个值：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This `CartButton` component replaces `Button`, which is now being displayed
    with a placeholder count for the number of products in the cart, in the `client/src/components/Header/SubHeader.js` file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`CartButton`组件替换了`Button`，现在在`client/src/components/Header/SubHeader.js`文件中显示为购物车中产品数量的占位符计数：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With all of the components that show either a product or cart information connected
    to the GraphQL Client, you can proceed by adding mutations that add products to
    the cart. How to add mutations to the application and send document container
    mutations to the GraphQL server will be shown in the final part of this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有显示产品或购物车信息的组件都连接到GraphQL Client，你可以继续添加将产品添加到购物车的变异。如何将变异添加到应用程序并将文档容器变异发送到GraphQL服务器将在本节的最后部分中展示。
- en: Handling mutations with Apollo Client
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo Client处理变异
- en: Mutating data makes using GraphQL more interesting because when data is mutated,
    some side effects should be executed. For example, when a user adds a product
    to their cart, the data for the cart should be updated throughout the component
    as well. This is quite easy when you're using Apollo Client since the Provider
    handles this in the same way the context API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的变异使得使用GraphQL更加有趣，因为当数据发生变异时，一些副作用应该被执行。例如，当用户将产品添加到购物车时，购物车的数据也应该在整个组件中更新。当你使用Apollo
    Client时，这是相当容易的，因为Provider以与上下文API相同的方式处理这个问题。
- en: 'Before writing your first mutation, the definitions of the executable queries
    for the cart should be moved to a constants file. That way, you can easily import
    them into other components to reuse and execute them as a side effect. Creating
    the new constants file and moving all the GraphQL queries and mutations to it
    requires that we make the following changes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写第一个变异之前，应该将购物车的可执行查询的定义移动到一个常量文件中。这样，你就可以轻松地将它们导入到其他组件中以便重用，并将它们作为副作用执行。创建新的常量文件并将所有的GraphQL查询和变异移动到其中需要我们做出以下更改：
- en: 'In the `client/src` directory, you should create a new file called `constants.js`
    and place the two already defined queries here, which can be found in the `Cart` and
    `CartButton` components. Also, you will need to import `graphql-tag` to use the
    GraphQL query language by adding the following code block to that newly created
    file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client/src`目录中，你应该创建一个名为`constants.js`的新文件，并将两个已经定义的查询放在这里，这些查询可以在`Cart`和`CartButton`组件中找到。此外，你需要导入`graphql-tag`，以便在新创建的文件中添加以下代码块来使用GraphQL查询语言：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `Cart` component, you can remove the definition to `GET_CART`, and import
    that definition from `client/src/constants.js` in the `client/src/components/Cart/Cart.js` file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cart`组件中，你可以删除对`GET_CART`的定义，并在`client/src/components/Cart/Cart.js`文件中从`client/src/constants.js`导入该定义：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the `CartButton` component in `CartButton.js`, you should apply the same
    changes, but this time for the `GET_CART_TOTAL` query, which can also be imported
    from the `constants` file and deleted from the `CartButton.js` file:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`CartButton.js`中的`CartButton`组件，您应该应用相同的更改，但这次是针对`GET_CART_TOTAL`查询，它也可以从`constants`文件中导入，并从`CartButton.js`文件中删除：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Any new definition of a query or mutation that relates to the components in
    the directory should be placed in this file from now on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何与目录中的组件相关的查询或变异的新定义都应从现在开始放在这个文件中。
- en: 'Since you want your users to be able to add products to the cart, a definition
    of a mutation can be added to this file. The mutation to add products to the cart
    looks as follows, which takes the `productId` parameter to add a product to the
    cart. The following mutation can return the fields for the cart in return, just
    like a query can:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您希望用户能够将产品添加到购物车，因此可以在此文件中添加一个变异的定义。添加产品到购物车的变异如下，它需要`productId`参数来将产品添加到购物车。以下变异可以返回购物车的字段，就像查询一样：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can already test this mutation by trying it out on the GraphQL Playground
    that''s available at `http://localhost:4000/graphql`. Here, you''d need to add
    the mutation in the upper-left box of this page. The variable that you want to
    include in this mutation for `productId` must be placed in the bottom-left box
    of this page, called QUERY VARIABLES. This would result in the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`http://localhost:4000/graphql`上可用的GraphQL Playground上尝试此变异来测试此变异。在这里，您需要在此页面的左上角框中添加变异。您想要包含在此变异中的`productId`变量必须放在此页面的左下角框中，称为查询变量。这将导致以下输出：
- en: '![](assets/e5a46cd3-5b66-4afe-90ae-fd607da0aa40.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e5a46cd3-5b66-4afe-90ae-fd607da0aa40.png)'
- en: 'To be able to use this mutation from your React application, you will need
    to make the following changes to some files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从您的React应用程序中使用此变异，您需要对一些文件进行以下更改：
- en: 'Create a new exported constant in the `client/src/constants.js` file and add
    the mutation to it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client/src/constants.js`文件中创建一个新的导出常量，并将变异添加到其中：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Currently, there''s no button to add a product to the cart yet, so you can
    create a new file in the `Cart` directory and call this `AddToCartButton.js`.
    In this file, you can add the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，还没有按钮可以将产品添加到购物车，因此您可以在`Cart`目录中创建一个新文件，并将其命名为`AddToCartButton.js`。在这个文件中，您可以添加以下代码：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This new `AddToCartButton` takes `productId` as a prop and has a `Mutation` component
    from `react-apollo`, which uses the `Mutation` you created in `client/src/constants.js`.
    The output of `Mutation` is the actual function to call this mutation, which takes
    an object containing the inputs as a parameter. Clicking on the `Button` component
    will execute the mutation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`AddToCartButton`将`productId`作为prop，并且具有来自`react-apollo`的`Mutation`组件，该组件使用您在`client/src/constants.js`中创建的`Mutation`。`Mutation`的输出是调用此变异的实际函数，它以包含输入的对象作为参数。单击`Button`组件将执行变异。
- en: 'This button should be displayed next to the products in the list in the `Products` component,
    where each product is displayed in a `ProductItem` component. This means, you
    will need to import `AddCartButton` in `''src/components/Products/ProductItem.js''`
    and pass a `productId` prop to it by using the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此按钮应显示在`Products`组件中列表中的产品旁边，其中每个产品都显示在`ProductItem`组件中。这意味着，您需要在`'src/components/Products/ProductItem.js'`中导入`AddCartButton`并通过以下代码传递`productId`
    prop给它：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, when you open the React application in the browser, a button will be displayed
    next to the product titles. If you click this button, the mutation will be sent
    to the GraphQL server and the product will be added to the cart. However, you
    won't see any changes to the button that displays Cart (0) in the `SubHeader` component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在浏览器中打开React应用程序时，将会在产品标题旁边显示一个按钮。如果您点击此按钮，变更将被发送到GraphQL服务器，并且产品将被添加到购物车中。但是，您不会看到显示购物车（0）的按钮在`SubHeader`组件中的任何变化。
- en: 'To update `CartButton`, you will need to specify that, when the mutation to
    the cart takes place, other queries should be executed again. This can be done
    by setting the `refetchQueries` prop on the `Mutation` component in `client/src/components/Cart/AddToCartButton.js`.
    This prop takes an array of objects with information about the queries that should
    be requested. These queries are the `GET_CART_TOTAL` query, which is executed
    by `CartButton`, and the `GET_CART` query from the `Cart` component. To do this,
    make the following changes:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新`CartButton`，您需要指定当购物车发生变更时，其他查询也应该再次执行。这可以通过在`client/src/components/Cart/AddToCartButton.js`中的`Mutation`组件上设置`refetchQueries`属性来完成。该属性接受一个包含有关应该请求的查询信息的对象数组。这些查询是由`CartButton`执行的`GET_CART_TOTAL`查询，以及`Cart`组件中的`GET_CART`查询。要做到这一点，请进行以下更改：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, every time you send a mutation in a document to the GraphQL server from
    this component, both the `GET_CART` and `GET_CART_TOTAL` queries will be sent
    as well. If the results have changed, the `CartButton` and `Cart` components will
    be rendered with this new output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当您从此组件向GraphQL服务器发送文档中的变更时，`GET_CART`和`GET_CART_TOTAL`查询也将被发送。如果结果发生了变化，`CartButton`和`Cart`组件将以新的输出进行渲染。
- en: In this section, you've added some logic to send queries and mutations to the
    GraphQL server, by using the GraphQL client from Apollo. This client has other
    features as well, such as local state management, which you'll learn about in
    the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您已经添加了一些逻辑，通过使用Apollo的GraphQL客户端向GraphQL服务器发送查询和变更。这个客户端还有其他功能，比如本地状态管理，您将在下一部分学习到。
- en: Managing local state
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理本地状态
- en: Not only can you use Apollo Client to manage the data that is fetched from the
    GraphQL server, but you can also use it for managing the local state. With Apollo,
    it becomes easy to combine local state with data from the GraphQL server since
    you can also use queries and mutations to deal with the local state.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅可以使用Apollo Client来管理从GraphQL服务器获取的数据，还可以用它来管理本地状态。使用Apollo，很容易将本地状态与从GraphQL服务器获取的数据结合起来，因为您还可以使用查询和变更来处理本地状态。
- en: A good example of information you might want to put in your local state for
    this e-commerce store is the number of products that should be requested from
    the GraphQL server. In the first part of this chapter, you already created a query
    that takes a parameter called `limit`, which defines how many products will be
    returned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将信息放入本地状态以便在这个电子商务商店中使用，比如应该从GraphQL服务器请求多少产品的数量。在本章的第一部分，您已经创建了一个带有名为`limit`的参数的查询，该参数定义了将返回多少产品。
- en: 'To add local state to your application, some changes need to made to the setup
    of Apollo Client, after which you need to make the following changes as well:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要向应用程序添加本地状态，需要对Apollo Client的设置进行一些更改，之后还需要进行以下更改：
- en: 'In the `client/src/App.js` file, you need to detach the `cache` constant; that
    way, you can use the `writeData` method to add new values to `cache`. Also, you
    will need to add local `resolvers` and `typeDefs` to `client`, which will be used
    next to `resolvers` and `typeDefs` from the GraphQL server. To do this, change
    the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client/src/App.js`文件中，您需要分离`cache`常量；这样，您就可以使用`writeData`方法向`cache`添加新值。此外，您还需要向`client`添加本地`resolvers`和`typeDefs`，这将在下一个`resolvers`和`typeDefs`之后使用GraphQL服务器。要做到这一点，更改以下代码：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code block, the schema is extended with a `Query` type that
    has a field for `limit`, meaning you can query `client` for this value. Also,
    an initial value for `limit` is written to `cache`. This means the value for `limit`
    will always be `5` when the application first mounts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中，模式通过具有`limit`字段的`Query`类型进行了扩展，这意味着您可以查询`client`获取此值。此外，`limit`的初始值被写入了`cache`。这意味着当应用程序首次挂载时，`limit`的值将始终为`5`。
- en: 'Let''s also add all of the queries related to products to the `client/src/constants.js` file. 
    This can be added to the `client/src/components/Products` directory by adding
    the following code to the file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还将与产品相关的所有查询添加到`client/src/constants.js`文件中。这可以通过将以下代码添加到`client/src/components/Products`目录中的文件中来实现：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the query for `products` to use `limit` from the local state, a small change
    has to be made to the `GET_PRODUCTS` query:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让`products`查询使用本地状态中的`limit`，必须对`GET_PRODUCTS`查询进行一些小改动：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `query` will now use the `limit` variable to request the number of products,
    instead of the predefined value of `10` in your GraphQL server. By adding `@client`,
    the Apollo Client will know to get this value from `cache`, meaning the local
    state.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`查询`现在将使用`limit`变量来请求产品的数量，而不是在GraphQL服务器中预定义的`10`值。通过添加`@client`，Apollo Client将知道从`cache`获取这个值，意味着本地状态。
- en: 'In the `Products` component, these queries should be imported from the `constants.js`
    file, and the value for `limit` should be requested with a `Query` component from
    `react-apollo`. Also, the value for `limit` that is returned by `Query` should
    be sent in the `variables` prop when requesting the `GET_PRODUCTS` query. Therefore,
    make the following changes to use the updated query and pass the variables to
    it:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Products`组件中，这些查询应该从`constants.js`文件中导入，并且应该使用`react-apollo`中的`Query`组件请求`limit`的值。此外，通过`Query`返回的`limit`值应在请求`GET_PRODUCTS`查询时发送到`variables`属性。因此，进行以下更改以使用更新后的查询并将变量传递给它：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the previous changes, the returned value from the `GET_LIMIT` query will
    be sent as a variable to the `GET_PRODUCTS` query, where you need to make sure
    this value is an integer by using `parseInt`. If you look at the application in
    the browser now, 5 products will be displayed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的更改，从`GET_LIMIT`查询返回的值将作为变量发送到`GET_PRODUCTS`查询，您需要确保使用`parseInt`将该值转换为整数。如果您现在在浏览器中查看应用程序，将显示5个产品。
- en: 'Next, to have an initial value for `limit`, this value can also be set dynamically.
    Therefore, you can use the `writeData` method again to update the cache. This
    should be done from a different component that can access the client. To accomplish
    this, you need to create a component in the `client/src/components/Products` directory in
    the new `Filter.js` file. In this file, you can place the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了给`limit`设置一个初始值，这个值也可以动态设置。因此，您可以再次使用`writeData`方法来更新缓存。这应该从可以访问客户端的不同组件中完成。为了实现这一点，您需要在`client/src/components/Products`目录中的新的`Filter.js`文件中创建一个组件。在这个文件中，您可以放置以下代码：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This `Filter` component uses `ApolloConsumer` to get the value for the client
    from `ApolloProvider`, which is similar to how the React context API works. From
    any component that is nested in `ApolloProvider`, you will be able to get the
    client value by using the Consumer from `react-apollo`. The client will be used
    to write data to the cache,  and this data is retrieved from the value of the
    select drop-down menu.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Filter`组件使用`ApolloConsumer`从`ApolloProvider`获取客户端的值，这类似于React上下文API的工作原理。从任何嵌套在`ApolloProvider`中的组件中，您都可以使用`react-apollo`中的Consumer来获取客户端值。客户端将用于向缓存写入数据，并且这些数据是从选择下拉菜单的值中检索出来的。
- en: 'The `Filter` component should also be added to the `Products` component so
    that it can actually be used to change the value for `limit`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Filter`组件还应该添加到`Products`组件中，以便实际上可以用它来更改`limit`的值：'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since the `Query` component for `GET_PRODUCTS` is nested in the `Query` component
    for `GET_LIMIT`, whenever the `GET_LIMIT` query is sent, this query will also
    be sent. So, when you use the select drop-down menu to change `limit`, the `GET_PRODUCTS` query will
    be sent and the number of products that are displayed will have changed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GET_PRODUCTS`的`Query`组件嵌套在`GET_LIMIT`的`Query`组件中，每当发送`GET_LIMIT`查询时，此查询也将被发送。因此，当您使用选择下拉菜单更改`limit`时，将发送`GET_PRODUCTS`查询，并且显示的产品数量将发生变化。
- en: 'With these changes, your application uses the Apollo Client for getting data
    from the GraphQL server and for handling local state management. Also, users can
    now filter the number of products that they''ll see in your application, which
    will make your application look similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些变化，您的应用程序将使用Apollo Client从GraphQL服务器获取数据并处理本地状态管理。此外，用户现在可以过滤在您的应用程序中看到的产品数量，这将使您的应用程序看起来类似于以下内容：
- en: '![](assets/dbb4a244-fbe1-4671-823c-1347303ead6e.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dbb4a244-fbe1-4671-823c-1347303ead6e.png)'
- en: The buttons to add a product to the cart were added in the previous section,
    while the functionality of the cart will be handled in the next section, when
    you add authentication to the project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中添加了将产品添加到购物车的按钮，而购物车的功能将在下一节中处理，当您向项目添加身份验证时。
- en: Using authentication with React and GraphQL
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React和GraphQL进行身份验证
- en: When the users have added products to the cart, you want them to be able to
    checkout, but before that, the users should be authenticated as you want to know
    who's buying the product. Handling authentication in React will also require an
    interaction with the backend, since you need to store the user's information somewhere
    or check whether the user exists.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将产品添加到购物车时，您希望他们能够结账，但在此之前，用户应该经过身份验证，因为您想知道谁在购买产品。在React中处理身份验证还需要与后端进行交互，因为您需要将用户信息存储在某个地方或检查用户是否存在。
- en: For authentication in frontend applications, most of the time, **JSON Web Tokens**
    (**JWTs**) are used, which are encrypted tokens that can easily be used to share
    user information with a backend. The JWT will be returned by the backend when
    the user is successfully authenticated and often, this token will have an expiration
    date. With every request that the user should be authenticated for, the token
    should be sent so that the backend server can determine whether the user is authenticated
    and allowed to take this action. Although JWTs can be used for authentication
    since they're encrypted, no private information should be added to them since
    the tokens should only be used to authenticate the user. Private information can
    only be sent from the server when a document with the correct JWT has been sent.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端应用程序中进行身份验证时，大多数情况下会使用**JSON Web Tokens**（**JWTs**），这是加密令牌，可以轻松地用于与后端共享用户信息。当用户成功经过身份验证时，后端将返回JWT，并且通常，此令牌将具有到期日期。用户应经过身份验证的每个请求都应发送令牌，以便后端服务器可以确定用户是否经过身份验证并且被允许执行此操作。尽管JWT可以用于身份验证，因为它们是加密的，但不应向其中添加私人信息，因为令牌只应用于对用户进行身份验证。只有在发送具有正确JWT的文档时，才可以从服务器发送私人信息。
- en: React Router and authentication
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Router和身份验证
- en: The GraphQL server for this project has already been set up to handle authentication
    and will return a JWT token when the correct user information has been sent to
    it. When the user wants to check out the cart, the application will look for a
    JWT token in the local or session storage and redirect the user either to the
    checkout page or the login page. For this, private routes should be added to `react-router`,
    which are only available when the user is authenticated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的GraphQL服务器已经设置好处理身份验证，并且将在向其发送正确的用户信息时返回JWT令牌。当用户想要查看购物车时，应用程序将在本地或会话存储中查找JWT令牌，并将用户重定向到结账页面或登录页面。为此，应该在`react-router`中添加私人路由，只有在用户经过身份验证时才可用。
- en: 'Adding a private route requires that we make the following changes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 添加私人路由需要我们进行以下更改：
- en: 'New routes for the checkout and the login pages must be added to the `Router`
    component in the `client/src/components/App.js` file, where the user can either
    checkout or log in. For this, you must import the `Checkout` and `Login` components
    that have already been created and a `Redirect` component from `react-router-dom`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client/src/components/App.js`文件的`Router`组件中必须添加新的结账和登录页面路由，用户可以在其中进行结账或登录。为此，您必须从`react-router-dom`中导入已经创建的`Checkout`和`Login`组件以及`Redirect`组件：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After importing these, routes must be added to `Switch` in `Router`, making
    them available to the user:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入这些后，必须将路由添加到`Router`中的`Switch`，使其对用户可用：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the current situation, the user can navigate to the `login` and `checkout`
    pages without being authenticated. To check whether the user is authenticated,
    the render props method for the `Route` component can be used. In this method,
    you must check whether or not a JWT is stored in the session storage for this
    user. Currently, no token is stored in the session storage since this will be
    added later on. But you can still create the function to check for it by adding
    the following function:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前情况下，用户可以在未经身份验证的情况下导航到`login`和`checkout`页面。要检查用户是否经过身份验证，可以使用`Route`组件的渲染属性方法。在这种方法中，您必须检查该用户的会话存储中是否存储了JWT。目前，会话存储中没有存储令牌，因为这将在以后添加。但是您仍然可以通过添加以下函数来创建检查它的功能：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are many ways to store a JWT, such as using the local storage, session
    storage, cookies, or a local state in the form of the `apollo-link-state` package.
    As long as you follow the protocol of JWT, encrypt no private information in the
    token, and add an expiration date to it, all of these places can be considered
    as a safe place to store the token.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多存储 JWT 的方法，例如使用本地存储、会话存储、cookies 或者 `apollo-link-state` 包中的本地状态。只要遵循 JWT
    的协议，在令牌中不加密私人信息，并为其添加到期日期，所有这些地方都可以被视为存储令牌的安全位置。
- en: 'After this, the render props method is used for the checkout route to check
    whether the user is authenticated or not. If not, the user will be redirected
    to the login page using the `Redirect` component. Otherwise, the user will see
    the `Checkout` component, which will receive the router props that are returned
    by the render props method. To make this happen, make the following changes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用渲染 props 方法来检查结帐路由中用户是否经过身份验证。如果没有经过身份验证，用户将使用 `Redirect` 组件被重定向到登录页面。否则，用户将看到
    `Checkout` 组件，该组件将接收由渲染 props 方法返回的路由 props。要实现这一点，请进行以下更改：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you try to visit the `http://localhost:3000/checkout` route in your browser,
    you'll always be redirected to the `/login` route since no JWT has been stored
    in the session storage yet. In the next part of this section, you'll add the logic
    to retrieve the JWT from the GraphQL server by sending a mutation with login information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试访问浏览器中的 `http://localhost:3000/checkout` 路由时，您将始终被重定向到 `/login` 路由，因为会话存储中尚未存储
    JWT。在本节的下一部分中，您将添加逻辑，通过发送带有登录信息的 mutation 来从 GraphQL 服务器检索 JWT。
- en: Receiving JWT from the GraphQL server
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 GraphQL 服务器接收 JWT
- en: 'The GraphQL server has already been set up to handle authentication since we
    sent a document containing a mutation with our login information to it. When you
    send the correct username and password, the server will return a JWT containing
    your username and expiration date. Sending a query to the GraphQL server can be
    done by using a `Mutation` component from `react-apollo` or by using the React
    Apollo Hooks, which offer you more flexibility. Logging in can be done from the
    `Login` component, which you can find in the `client/src/components/Checkout/Login.js` file,
    where the following changes need to be made to authenticate the user:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器已经设置好处理身份验证，因为我们向其发送了包含带有我们的登录信息的 mutation 的文档。当您发送正确的用户名和密码时，服务器将返回一个包含您的用户名和到期日期的
    JWT。可以通过使用 `react-apollo` 中的 `Mutation` 组件或使用提供更多灵活性的 React Apollo Hooks 来向 GraphQL
    服务器发送查询。登录可以从 `Login` 组件中完成，您可以在 `client/src/components/Checkout/Login.js` 文件中找到该组件，在那里需要进行以下更改以对用户进行身份验证：
- en: 'The React Apollo Hook for the mutation will need a document that will be sent
    to the GraphQL server. This mutation can also be defined in the `client/src/constants.js` file,
    which is  where you''ve defined all of the other queries and mutations as well:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于 mutation 的 React Apollo Hook 需要一个将发送到 GraphQL 服务器的文档。这个 mutation 也可以在 `client/src/constants.js`
    文件中定义，那里您也定义了所有其他查询和 mutation：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Login` component in `client/src/components/Checkout/Login.js` is already
    using `useState` Hooks to control the value of the input fields for `userName`
    and `password`. The `useMutation` Hook can be imported from `react-apollo` and
    you can use this Hook to replace a `Mutation` component and still have the same
    functionalities. This Hook can also be used from anywhere within `ApolloProvider`
    and returns a login function that will send the document to the GraphQL server.
    Adding this is done by importing the Hook and passing the `LOGIN_USER` mutation
    from `client/src/constants.js` to it:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “client/src/components/Checkout/Login.js”中的“Login”组件已经在使用“useState” Hooks来控制“userName”和“password”的输入字段的值。可以从“react-apollo”中导入“useMutation”
    Hook，并可以使用此Hook来替换“Mutation”组件并仍具有相同的功能。此Hook还可以从“ApolloProvider”中的任何位置使用，并返回一个登录函数，该函数将文档发送到GraphQL服务器。通过导入Hook并将“client/src/constants.js”中的“LOGIN_USER”
    mutation传递给它来添加此操作：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: React Apollo Hooks can be used from the `react-apollo` package, but if you only
    want to use the Hooks, you can install `@apollo/react-hooks` instead by executing `npm
    install @apollo/react-hooks`. GraphQL components such as `Query` or `Mutation` are
    available in both the `react-apollo` and `@apollo/react-components` packages.
    Using these packages will decrease the size of your bundle as you're only importing
    the features you need.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从“react-apollo”包中使用React Apollo Hooks，但如果只想使用Hooks，可以通过执行“npm install @apollo/react-hooks”安装“@apollo/react-hooks”来代替。GraphQL组件，如“Query”或“Mutation”，在“react-apollo”和“@apollo/react-components”包中都可用。使用这些包将减少捆绑包的大小，因为您只导入所需的功能。
- en: 'After creating the `loginUser` function, this can be added to the `onClick`
    event from `Button`, and the values for `userName` and `password` should be passed
    to this function as variables:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建“loginUser”函数后，可以将其添加到“Button”的“onClick”事件中，并将“userName”和“password”的值作为变量传递给此函数：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Clicking `Button` will send the document containing the `userName` and `password`
    values to the GraphQL server and if successful, it returns the JWT for this user.
    However, this token should also be stored in the session storage and as the `loginUser`
    function returns a promise, the `onClick` event should become an asynchronous
    function. That way, you can wait for the `loginUser` function to resolve and store
    the token afterward or send an error message if no token was returned:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“Button”将发送包含“userName”和“password”值的文档到GraphQL服务器，如果成功，它将返回此用户的JWT。但是，此令牌还应存储在会话存储中，并且由于“loginUser”函数返回一个promise，“onClick”事件应该成为一个异步函数。这样，您可以等待“loginUser”函数解析并在之后存储令牌，或者如果没有返回令牌，则发送错误消息：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, the user should be redirected to the `checkout` page if the authentication
    succeeded. SInce the `Login` component is rendered by the checkout route using
    the render props method, it received the props from `react-router`. To redirect
    the user back, you can use the `history` prop from `react-router` to push the
    user to the `checkout` page:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果身份验证成功，用户应该被重定向到“结账”页面。由于“登录”组件是通过渲染props方法由结账路由渲染的，它从“react-router”接收了props。要将用户重定向回去，可以使用来自“react-router”的“history”props将用户推到“结账”页面：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Every user that has a token stored in their session storage is now able to visit
    the `checkout` page for as long as the token is stored there. You can delete the
    token from the session storage by going to the Application tab in the Developer
    tools of your browser; there, you'll find another tab called Session Storage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要会话存储中存储有令牌的用户就能访问“结账”页面。您可以通过转到浏览器的开发者工具中的应用程序选项卡，在那里，您会找到另一个名为会话存储的选项卡来从会话存储中删除令牌。
- en: 'Since you want your users to be able to navigate from the `cart` page to the
    `checkout` page, you should add `Button` in the `Cart` component that lets the
    user navigate using a `Link` component from `react-router-dom`. If the user isn''t
    authenticated yet, this will redirect the user to the login page; otherwise, it
    will redirect them to the checkout page. Also, the button should only be displayed
    when there are products in the cart. To add this `Button`, the following changes
    need to be made in `client/src/components/Cart/Cart.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您希望用户能够从`cart`页面导航到`checkout`页面，您应该在`Cart`组件中添加一个`Button`，让用户可以使用`react-router-dom`中的`Link`组件进行导航。如果用户尚未经过身份验证，这将重定向用户到登录页面；否则，它将重定向他们到结账页面。此外，只有在购物车中有产品时才应显示该按钮。要添加此`Button`，需要在`client/src/components/Cart/Cart.js`中进行以下更改：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You''ve now added the functionality to proceed to the final checkout page of
    your application, which makes the `/cart` route look like this in your application
    after adding a product to it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经添加了继续应用程序的最终结账页面的功能，这使得在向其添加产品后，您的应用程序中的`/cart`路由如下所示：
- en: '![](assets/04e28956-c90e-4df3-a258-8f53df1cf079.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04e28956-c90e-4df3-a258-8f53df1cf079.png)'
- en: In the final part of this section, you'll add this token to the document that
    you send to the GraphQL server, where the token is validated to make sure the
    user is authenticated for a certain action.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，您将向发送到GraphQL服务器的文档中添加这个令牌，该令牌将被验证以确保用户对某个操作进行了身份验证。
- en: Passing JWT to the GraphQL server
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JWT传递给GraphQL服务器
- en: The user's authentication details in the form of the JWT are now stored in the
    session storage, and the route to the checkout page is now private. But for the
    user to check out, this token should also be sent to the GraphQL server, along
    with every document for the server, to validate whether the user is actually authenticated
    or whether the token has expired. Therefore, you need to extend the setup of the
    Apollo Client to also send the token when you make a request to the server and
    prefix it with `Bearer`, since this is how a JWT is recognized.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的身份验证细节以JWT的形式现在存储在会话存储中，结账页面的路由现在是私有的。但是为了让用户结账，这个令牌也应该被发送到GraphQL服务器，以及每个发送到服务器的文档，以验证用户是否真的被认证，或者令牌是否已经过期。因此，您需要扩展Apollo
    Client的设置，以便在向服务器发出请求时也发送令牌，并在前面加上`Bearer`，因为这是JWT的识别方式。
- en: 'Follow these steps to pass the JWT to the GraphQL server:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将JWT传递给GraphQL服务器：
- en: 'You need to install an Apollo package to deal with adding values to the Context
    since you need the `setContext` method to do this. This method is available from
    the `apollo-link-Context` package, which you can install from `npm`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要安装一个Apollo包来处理向上下文添加值，因为您需要`setContext`方法来做到这一点。这个方法可以从`apollo-link-Context`包中获得，您可以从`npm`安装：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Apollo Client is created in the `client/src/components/App.js` file, where
    you import the `setContext` method from `apollo-link-Context`. Also, the creation
    of the link to the GraphQL server must be decoupled as this should also take the
    authentication details, that is, `token`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apollo Client是在`client/src/components/App.js`文件中创建的，您可以从`apollo-link-Context`中导入`setContext`方法。此外，与GraphQL服务器的链接的创建必须解耦，因为这也应该带有身份验证细节，即`token`：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, you can use the `setContext` method to extend the request headers that
    are being sent to the GraphQL server so that it also include the token that can be
    retrieved from the session storage. The token that you retrieve from the session
    storage must be prefixed with `Bearer` since the GraphQL server expects the JWT
    token in that format:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用`setContext`方法来扩展发送到GraphQL服务器的请求头，以便它也包括可以从会话存储中检索到的令牌。您从会话存储中检索到的令牌必须以`Bearer`为前缀，因为GraphQL服务器期望以这种格式接收JWT令牌：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Together with the `HttpLink` method, the `authLink` constant must be used in
    the setup of Apollo Client; this will make sure the Context value from `authLink`
    is being added to the headers being sent by `httpLink`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`HttpLink`方法一起，必须在设置Apollo Client时使用`authLink`常量；这将确保从`authLink`添加到由`httpLink`发送的标头的上下文值：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you visit the application in the browser again and make sure you are logged
    in by either going to the `checkout` or `login` page, you will see that the requests
    are still sent to the GraphQL server. The difference can be seen when you open
    the Developer tools of your browser and go to the Network tab. The requests to
    the server now have different header information since a field called `authorization`
    is also sent, which has a value that looks like Bearer eyAABBB....
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次在浏览器中访问应用程序，并确保已登录，方法是转到`checkout`或`login`页面，您会看到请求仍然发送到GraphQL服务器。当您打开浏览器的开发者工具并转到网络选项卡时，可以看到请求到服务器的标头信息不同。因为还发送了一个名为`authorization`的字段，其值看起来像Bearer
    eyAABBB....
- en: When the user goes to the checkout page, there should be a button to finalize
    the order. This button will call a function that completes the cart. As the user
    must be authenticated to create an order, the token must be sent with this request
    that sends the `completeCart` mutation. This mutation completes the cart and clears
    its content, after which the contents of the checkout page change.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户转到结账页面时，应该有一个按钮来完成订单。此按钮将调用一个完成购物车的函数。由于用户必须经过身份验证才能创建订单，因此必须将令牌与发送`completeCart`变异的请求一起发送。此变异完成购物车并清除其内容，之后结账页面的内容会发生变化。
- en: 'Adding this feature to the `checkout` page requires making the following changes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将此功能添加到`checkout`页面需要进行以下更改：
- en: 'The `completeCart` mutation has the following shape and can be found in `client/constants.js`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`completeCart`变异具有以下形状，并且可以在`client/constants.js`中找到：'
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It must be imported into the `client/src/components/Checkout/Checkout.js` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 必须导入到`client/src/components/Checkout/Checkout.js`文件中：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The mutation can be sent to the GraphQL server by using a `useMutation` Hook,
    which can be imported from `react-apollo`. At the beginning of the `Checkout`
    component, the Hook can be added with the `COMPLETE_CART` mutation as a parameter.
    The Hook returns the function to send the mutation and the data that was returned
    from the mutation:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用从`react-apollo`导入的`useMutation` Hook将变异发送到GraphQL服务器。在`Checkout`组件的开头，可以使用`COMPLETE_CART`变异作为参数添加Hook。
    Hook返回发送变异的函数和从变异返回的数据：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `completeCart` function must be added to the `Button` component as an `onClick`
    prop so that when the button is clicked, that function will be called. Also, you
    must check whether the `COMPLETE_CART` mutation returns a value for the `complete` field,
    which indicates whether the cart was completed or not. If it was, the checkout
    is complete and a different message can be displayed to the user:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须将`completeCart`函数添加到`Button`组件作为`onClick`属性，以便单击按钮时将调用该函数。此外，您必须检查`COMPLETE_CART`变异是否返回`complete`字段的值，该字段指示购物车是否已完成。如果是，则结账已完成，并且可以向用户显示不同的消息：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This concludes the checkout process for the user and this chapter, where you've
    used React and GraphQL to create an e-commerce application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了用户的结账流程和本章，您已经使用React和GraphQL创建了一个电子商务应用程序。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've created a full stack React application that uses GraphQL
    as its backend. Using Apollo Server and mock data, the GraphQL server was created,
    which takes queries and mutations to provide you with data. This GraphQL server
    is used by a React application that uses Apollo Client to send and receive data
    from the server and to handle local state management. Authentication is handled
    by the GraphQL server using JWT and in the frontend by React and `react-router`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经创建了一个使用GraphQL作为后端的全栈React应用程序。使用Apollo服务器和模拟数据，创建了GraphQL服务器，该服务器接受查询和变异以提供数据。这个GraphQL服务器被一个使用Apollo
    Client的React应用程序使用，用于向服务器发送和接收数据以及处理本地状态管理。身份验证由GraphQL服务器使用JWT处理，在前端由React和`react-router`处理。
- en: That's it! You've completed the seventh chapter of this book and have already
    created seven web applications with React. By now, you should feel comfortable
    with React and its features and be ready to learn some more. In the next chapter,
    you'll be introduced to React Native and learn how you can use your React skills
    to build a mobile application by creating a house listing application with React
    Native and Expo.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您已经完成了本书的第七章，并且已经使用React创建了七个Web应用程序。到目前为止，您应该对React及其功能感到满意，并准备学习更多。在下一章中，您将介绍React
    Native，并学习如何使用React技能来创建一个移动应用程序，通过使用React Native和Expo创建一个房源列表应用程序。
- en: Further reading
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Creating an Apollo Server from scratch: [https://www.apollographql.com/docs/apollo-server/essentials/server](https://www.apollographql.com/docs/apollo-server/essentials/server)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建Apollo服务器：[https://www.apollographql.com/docs/apollo-server/essentials/server](https://www.apollographql.com/docs/apollo-server/essentials/server)
- en: GraphQL: [https://graphql.org/learn/](https://graphql.org/learn/)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL：[https://graphql.org/learn/](https://graphql.org/learn/)
- en: JWT tokens: [https://jwt.io/introduction/](https://jwt.io/introduction/)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT令牌：[https://jwt.io/introduction/](https://jwt.io/introduction/)
