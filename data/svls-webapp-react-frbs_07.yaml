- en: Using Firebase Cloud Messaging and Cloud Functions with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中使用Firebase Cloud Messaging和Cloud Functions
- en: 'In the previous chapters, we explored some of the Firebase products, such as
    Realtime Database, Authentication, Cloud Firestore, and Cloud Storage. However,
    we haven''t seen some of the advanced features yet, such as Realtime messaging
    and serverless app development. Now we are ready to explore them, so let''s discuss
    two more products from Firebase platform: Firebase Cloud Messaging and Cloud Functions.
    Firebase Cloud Messaging is a messaging platform to send free messages across
    different platforms: Android, iOS, and web. Cloud Functions allow you to have
    serverless apps, meaning that you can run your custom application logic without
    a server.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们探讨了一些Firebase产品，比如实时数据库、身份验证、Cloud Firestore和Cloud Storage。然而，我们还没有看到一些高级功能，比如实时消息传递和无服务器应用开发。现在我们准备好探索它们了，所以让我们讨论Firebase平台的另外两个产品：Firebase
    Cloud Messaging和Cloud Functions。Firebase Cloud Messaging是一个消息平台，可以在不同平台（Android、iOS和Web）上免费发送消息。Cloud
    Functions允许你拥有无服务器应用，这意味着你可以在没有服务器的情况下运行自定义应用逻辑。
- en: 'Here''s a list of topics that we''ll focus on in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将重点关注的主题列表：
- en: Key features of **Firebase Cloud Messaging** (**FCM**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firebase Cloud Messaging**（**FCM**）的主要特点'
- en: Setup of Firebase for Javascript Web App
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript Web应用的Firebase设置
- en: Client app setup to receive notifications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端应用设置以接收通知
- en: Server setup to send the notifications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器设置以发送通知
- en: Key features of Cloud Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Functions的主要特点
- en: Setup of Firebase SDK for Cloud Functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Cloud Functions设置Firebase SDK
- en: Life cycle of a Cloud Function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Function的生命周期
- en: Triggering functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发函数
- en: Deployment and execution of a function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和执行函数
- en: Termination of a function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的终止
- en: Let's first start with FCM, and then we will go through the Cloud Functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从FCM开始，然后我们将介绍Cloud Functions。
- en: Firebase Cloud Messaging (FCM)
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase Cloud Messaging（FCM）
- en: 'FCM provides a platform that helps you send the messages and notifications
    to the app user in real-time using service workers. You can send hundreds of billions
    of messages per day for free across different platforms: Android, iOS, and web
    (Javascript). You can also schedule the message delivery, immediately or in future.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: FCM提供了一个平台，帮助你使用服务工作者实时向应用用户发送消息和通知。你可以免费跨不同平台发送数百亿条消息，包括Android、iOS和Web（JavaScript）。你还可以安排消息的发送时间，立即或在将来。
- en: 'There are two main components in  FCM implementation: a trusted environment
    that includes an app server or a Cloud function to send the messages, and an iOS,
    Android, or web (JavaScript) client app that receives the messages.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FCM实现中有两个主要组件：一个受信任的环境，包括一个应用服务器或Cloud函数来发送消息，以及一个iOS、Android或Web（JavaScript）客户端应用来接收消息。
- en: If you know about the **Google Cloud Messaging** (**GCM**), you might have a
    question of how FCM is different from GCM. The answer to this question is that
    FCM is the latest and improved version of GCM. It inherits all the infrastructure
    of GCM and carries improvements for the simplified client development. Just note
    that GCM is not deprecated and Google is still supporting it. However, the new
    client-side features will only come to FCM and hence as per Google recommendation,
    you should upgrade from GCM to FCM.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解**Google Cloud Messaging**（**GCM**），你可能会问FCM与GCM有何不同。对这个问题的答案是，FCM是GCM的最新和改进版本。它继承了GCM的所有基础设施，并对简化客户端开发进行了改进。只是要注意，GCM并没有被弃用，Google仍在支持它。然而，新的客户端功能只会出现在FCM上，因此根据Google的建议，你应该从GCM升级到FCM。
- en: Though it supports different platforms, Android, iOS, and Web, we will mainly
    talk about web (Javascript) in this chapter. Let's now look at the key features
    of FCM.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它支持不同的平台，包括Android、iOS和Web，但在本章中我们主要讨论Web（JavaScript）。现在让我们来看看FCM的主要特点。
- en: Key features of FCM
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FCM的关键功能
- en: The key features of GCM include Downstream messages, Upstream Messages, and
    Versatile messaging. Let's see what these feature are in brief in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GCM的关键功能包括下行消息、上行消息和多功能消息。让我们在下一部分简要地看一下这些功能是什么。
- en: Sending downstream messages
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送下行消息
- en: 'The downstream messages are sent to users from the server on behalf of a client
    app. FCM messages can be divided into two categories: Notification Messages and
    Data Messages.  The notification messages are directly displayed to user. Some
    examples of the notification messages are alert messages, chat messages, or messages
    to notify client app to start some processing; let''s message backups. The data
    messages need to be handled in your client app code. Some examples are chat messages
    or any messages specific to your app. We will talk more about these message types
    in the next section of FCM Messages.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下行消息是代表客户端应用程序从服务器发送给用户的。FCM消息可以分为两类：通知消息和数据消息。通知消息直接显示给用户。通知消息的一些示例是警报消息、聊天消息，或者通知客户端应用程序启动一些处理的消息备份。数据消息需要在客户端应用程序代码中处理。一些示例是聊天消息或任何特定于您的应用程序的消息。我们将在FCM消息的下一部分更多地讨论这些消息类型。
- en: Sending upstream messages
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送上行消息
- en: The upstream messages are sent back from devices to the server via an FCM channel.
    You can send acknowledgments, chat messages, and other messages from devices back
    to your server over a reliable FCM channel.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上行消息通过FCM通道从设备发送回服务器。您可以通过可靠的FCM通道将确认、聊天消息和其他消息从设备发送回服务器。
- en: Versatile message targeting
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多功能消息定位
- en: FCM is quite flexible and allows you to send the messages to the target audience
    on a single device, a group of devices, or to all the subscribers who listen to
    a topic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FCM非常灵活，允许您向单个设备、一组设备或所有订阅特定主题的订阅者发送消息。
- en: FCM messages
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FCM消息
- en: 'Using FCM, you can send two types of messages to the clients: Notification
    Messages and Data Messages. The maximum payload size for both kinds of messages
    is 4 KB when using Firebase SDK. However, when you send messages from the Firebase
    console, it enforces a 1024 character limit.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FCM，您可以向客户端发送两种类型的消息：通知消息和数据消息。使用Firebase SDK时，这两种消息的最大有效负载大小为4 KB。但是，当您从Firebase控制台发送消息时，它会强制执行1024个字符的限制。
- en: The notification messages are handled by FCM SDK automatically, since they are
    just display messages. You can use notification messages when you want FCM to
    display a notification on your client app's behalf. Notification messages contain
    a predefined set of keys and can also contain an optional data payload.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通知消息由FCM SDK自动处理，因为它们只是显示消息。当您希望FCM代表您的客户端应用程序显示通知时，可以使用通知消息。通知消息包含一组预定义的键，还可以包含可选的数据有效负载。
- en: 'The notification message object looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通知消息对象如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data messages are handled by a client app and contain the user-defined
    keys. They look as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据消息由客户端应用程序处理，并包含用户定义的键。它们如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will see what a token is in the upcoming sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分看到什么是令牌。
- en: Setup of Firebase for Javascript web app
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Javascript Web应用程序设置Firebase
- en: 'FCM allows you to receive notification messages in your web application running
    in different browsers with the support of service worker. The service worker is
    a browser script that runs in the background and provides features such as offline
    data capability, background data syncing, push notifications, and more. The service
    worker support is available in the following browsers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: FCM允许您在不同浏览器中的Web应用程序中接收通知消息，并支持服务工作者。服务工作者是在后台运行的浏览器脚本，提供离线数据功能、后台数据同步、推送通知等功能。服务工作者支持在以下浏览器中使用：
- en: 'Chrome: 50+'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome：50+
- en: 'Firefox: 44+'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox：44+
- en: 'Opera Mobile: 37+'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera Mobile：37+
- en: Using service workers, people can carry out some malicious activities, such
    as filtering the responses or hijacking connections. To avoid that, service workers
    can only be used on pages served over HTTPS. Hence, you will need a valid SSL
    certificate on your server if you want to use FCM. Note that in the local environment,
    you don't need SSL; it works at localhost without any issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务工作者，人们可以进行一些恶意活动，比如过滤响应或劫持连接。为了避免这种情况，服务工作者只能在通过HTTPS提供的页面上使用。因此，如果您想使用FCM，您将需要在服务器上拥有有效的SSL证书。请注意，在本地环境中，您不需要SSL；它可以在本地主机上正常工作。
- en: Installing Firebase and Firebase CLI
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Firebase和Firebase CLI
- en: 'If you are starting with a new React project, the easiest way to get started
    is with the React Starter Kit. You can create a React project using the following command and
    then install **firebase** and **firebase-tools**. If it is an existing React and
    Firebase project, you can skip the installation steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要开始一个新的React项目，最简单的方法是使用React Starter Kit开始。您可以使用以下命令创建一个React项目，然后安装**firebase**和**firebase-tools**。如果这是一个现有的React和Firebase项目，您可以跳过安装步骤：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can install Firebase using the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装Firebase：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will also need to install the Firebase CLI to run your project on a server.
    It can be installed using the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装Firebase CLI以在服务器上运行您的项目。可以使用以下命令进行安装：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we will extend the Helpdesk application with FCM implementation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用FCM实现来扩展Helpdesk应用程序。
- en: Configuring the browser to receive messages
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置浏览器以接收消息
- en: 'First of all, you will need to add a web app manifest from [https://developers.google.com/web/fundamentals/web-app-manifest/file](https://developers.google.com/web/fundamentals/web-app-manifest/file)
    in our project and add the following to it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要从[https://developers.google.com/web/fundamentals/web-app-manifest/file](https://developers.google.com/web/fundamentals/web-app-manifest/file)中添加一个Web应用程序清单到我们的项目中，并将以下内容添加到其中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It tells the browser that FCM is allowed to send the messages to this App. The
    `103953800507` value is hard-coded and must be the same in any of your App. The
    web app manifest is a simple JSON file and will contain the configuration metadata
    related to your project, such as the start URL of your App and App icon details.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉浏览器允许FCM向此应用程序发送消息。`103953800507`的值是硬编码的，在任何您的应用程序中必须相同。Web应用程序清单是一个简单的JSON文件，将包含与您的项目相关的配置元数据，例如您的应用程序的起始URL和应用程序图标详细信息。
- en: We have created a `manifest.json` file in the root folder of the code and added
    the preceding content to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码的根文件夹中创建了一个`manifest.json`文件，并将上述内容添加到其中。
- en: Client app setup to receive notifications
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端应用程序设置以接收通知
- en: To allow your app to receive notifications in your browser, it will have to
    get permissions from the user. To do so, we will add a piece of code that will
    show a consent dialog to let the user grant your app permission to receive notifications
    in your browser.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的应用程序在浏览器中接收通知，它将需要从用户那里获得权限。为此，我们将添加一段代码，显示一个同意对话框，让用户授予您的应用程序在浏览器中接收通知的权限。
- en: 'We will add the `componentWillMount()` method to our `index.jsx` file present
    under the home directory, since we want to show the dialog once the user is successfully
    logged in to the app:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主目录下的`index.jsx`文件中添加`componentWillMount()`方法，因为我们希望在用户成功登录到应用程序后显示对话框：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that you will need to import the `firebase` object using the following
    line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要使用以下行导入`firebase`对象：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you add the preceding code, restart your server and log in to the app.
    It should show the following dialog box to the users of your app:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了上述代码，请重新启动服务器并登录到应用程序。它应该向您的应用程序用户显示以下对话框：
- en: '![](Images/1bf6efe5-7577-4d8e-83b2-968da0b20687.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1bf6efe5-7577-4d8e-83b2-968da0b20687.png)'
- en: Once user gives permissions then only your browser will receive the notifications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用户授予权限后，您的浏览器才能接收通知。
- en: 'Now, let''s write a function to get the registration token:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数来获取注册令牌：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding function will retrieve the current access token that will need
    to be sent to the server to subscribe for the notifications. You can implement
    logic to send this token to the server in the `sendTokenToServer()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将检索当前访问令牌，需要将其发送到服务器以订阅通知。您可以在`sendTokenToServer()`方法中实现将此令牌发送到服务器的逻辑。
- en: 'The registration token may change when your web app deletes the registration
    token or a user clears browser data. In case of the latter, will need to call
    `getToken()` to retrieve the new token. Since there are chances that the registration
    token might get changed, you should also monitor refresh token to get the new
    token. FCM fires a callback whenever a token is generated so that you can get
    a new token. The `onTokenRefresh()` callback fires whenever a new token is generated,
    so calling the `getToken()` method in its context ensures that you are having
    a current registration token. You can write a function like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注册令牌可能在您的Web应用程序删除注册令牌或用户清除浏览器数据时更改。在后一种情况下，将需要调用`getToken()`来检索新令牌。由于注册令牌可能会更改，您还应该监视刷新令牌以获取新令牌。FCM在生成令牌时触发回调，以便您可以获取新令牌。`onTokenRefresh()`回调在生成新令牌时触发，因此在其上下文中调用`getToken()`方法可以确保您拥有当前的注册令牌。您可以编写一个类似这样的函数：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once you get the token, you can send it to your app server by implementing a
    method like `sendTokenToServer(refreshedToken)` to store it and if you are using
    React and Firebase Realtime Database, you can directly store it in the database.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得令牌，您可以通过实现类似`sendTokenToServer(refreshedToken)`的方法将其发送到您的应用服务器以存储它，如果您正在使用React和Firebase实时数据库，您可以直接将其存储在数据库中。
- en: All these functions will be added to the `index.jsx` file. We will call the `getToken()`
    function from the `componentWillMount()` method, whereas `refreshToken()` will
    be called from constructor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数将被添加到`index.jsx`文件中。我们将从`componentWillMount()`方法中调用`getToken()`函数，而`refreshToken()`将从构造函数中调用。
- en: Now, after all this setup, we will add the actual functionality of receiving
    the messages in our client app.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在完成所有这些设置之后，我们将在客户端应用程序中添加接收消息的实际功能。
- en: Depending on the page status, whether it is running in the background or in
    the foreground (it has focus) or it is closed or hidden behind tabs, the behavior of
    messages differs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据页面状态，无论是在后台运行还是在前台（具有焦点）运行，还是关闭或隐藏在标签后面，消息的行为都会有所不同。
- en: In order to receive messages, a page must handle the `onMessage()` callback,
    and to handle `onMessage()`, there must be a Firebase messaging service worker
    defined in your app.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收消息，页面必须处理`onMessage()`回调，并且要处理`onMessage()`，您的应用程序中必须定义一个Firebase消息服务工作者。
- en: 'We will create a file called `firebase-messaging-sw.js` under the root directory
    of the project and write the following code in it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目的根目录下创建一个名为`firebase-messaging-sw.js`的文件，并在其中编写以下代码：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternatively, you can specify an existing service worker with `useServiceWorker`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`useServiceWorker`指定现有的服务工作者。
- en: Note that you will need to update the message `senderId` value, which you can
    get from the Firebase console for your project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要更新消息`senderId`值，您可以从Firebase控制台获取您的项目的值。
- en: If you want to show a notification message when your web page is in the background,
    you need to set `setBackgroundMessageHandler` to handle the messages. You can
    also customize the message, such as setting a custom title and icon. You can check
    it in the preceding code snippet. The messages received while the app is in the
    background trigger a display notification in the browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在您的网页处于后台时显示通知消息，您需要设置`setBackgroundMessageHandler`来处理这些消息。您还可以自定义消息，例如设置自定义标题和图标。您可以在上面的代码片段中检查它。在应用程序处于后台时接收到的消息会触发浏览器中的显示通知。
- en: 'Now you can handle the `OnMessage()` event on your web page. We will add a
    constructor in our `index.js` file so that it registers the callback on page load:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在您的网页上处理`OnMessage()`事件。我们将在我们的`index.js`文件中添加一个构造函数，以便在页面加载时注册回调函数：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now our client is ready to receive the notification messages. Let's configure
    our backend to send the notifications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的客户端已准备好接收通知消息。让我们配置后端以发送通知。
- en: Server setup to send the notifications
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器设置以发送通知
- en: The first step is to enable FCM API for your project. You can go to [https://console.developers.google.com/apis/api/fcm.googleapis.com/overview?project=<project-id>](https://console.developers.google.com/apis/api/fcm.googleapis.com/overview?project=%3Cproject-id%3E)
    and enable it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为您的项目启用FCM API。您可以转到[https://console.developers.google.com/apis/api/fcm.googleapis.com/overview?project=<project-id>](https://console.developers.google.com/apis/api/fcm.googleapis.com/overview?project=%3Cproject-id%3E)并启用它。
- en: To send the notification from a trusted environment, we will need an Oauth2
    access token and the client registration token that we get in the client app.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要从受信任的环境发送通知，我们将需要Oauth2访问令牌和我们在客户端应用程序中获取的客户端注册令牌。
- en: 'To get the Oauth2 access token, we will need the private keys from your service
    account. Once you generate the private key, save the JSON file containing your
    private key at some secure place. We will use Google API Client Library at [https://developers.google.com/api-client-library/](https://developers.google.com/api-client-library/) to
    retrieve the access token, so install the `npm` module for `googleapis` using
    the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Oauth2访问令牌，我们将需要来自您服务帐户的私钥。一旦生成私钥，请将包含私钥的JSON文件保存在某个安全的地方。我们将使用Google API客户端库在[https://developers.google.com/api-client-library/](https://developers.google.com/api-client-library/)检索访问令牌，因此请使用以下命令安装`googleapis`的`npm`模块：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following function needs to be added to our `main.js` file to get the access
    token:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数需要添加到我们的`main.js`文件中以获取访问令牌：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It will show you an access token in your browser when you hit the `http://localhost:3000/getAccessToken`
    URL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问`http://localhost:3000/getAccessToken` URL时，它将在浏览器中显示您的访问令牌。
- en: 'You will see something like this in your browser:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，您将看到类似以下的内容：
- en: '![](Images/1215aa7b-ea9b-43a1-8680-4368f5efdda8.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1215aa7b-ea9b-43a1-8680-4368f5efdda8.png)'
- en: Obviously, in a real application, you won't show this token in browser or print
    it in browser console for security reasons, and you will use it internally.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在实际应用中，出于安全原因，您不会在浏览器中显示此令牌或在浏览器控制台中打印它，并且您将在内部使用它。
- en: 'This access token will be passed in the `Authorization` header of the request,
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此访问令牌将在请求的`Authorization`标头中传递，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So now you have the access token. Also, if you remember, we talked about the `sendTokenToServer(currentToken)`
    method when setting up the client app, which sends the token to the server. You
    must have stored it in your database or cache, which can now be used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了访问令牌。此外，如果您还记得，当设置客户端应用程序时，我们谈到了`sendTokenToServer(currentToken)`方法，该方法将令牌发送到服务器。您现在必须已将其存储在数据库或缓存中，现在可以使用。
- en: Now we are ready to send our first notification message. To send the message,
    we will be using the latest HTTP v1 `send` requests.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备发送我们的第一条通知消息。要发送消息，我们将使用最新的HTTP v1“发送”请求。
- en: 'Our request will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的请求将如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will replace all tokens and update the URL with your project ID, and then
    you should be able to send your first message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您将替换所有令牌并使用您的项目ID更新URL，然后您应该能够发送您的第一条消息。
- en: 'I''ve used a rest client to send the message and, since my browser is running
    in background, it shows the notification message in a system tray. You can see
    that in the next screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个rest客户端来发送消息，并且由于我的浏览器在后台运行，它会在系统托盘中显示通知消息。您可以在下一个截图中看到：
- en: '![](Images/4af8d08c-b8c1-4528-9d2c-b842921e4e5a.png)Postman chrome tool extension;
    the purpose is just to show the request and response of sending the FCM notification
    message'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/4af8d08c-b8c1-4528-9d2c-b842921e4e5a.png)Postman chrome工具扩展；目的只是显示发送FCM通知消息的请求和响应
- en: 'The request body looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请求正文如下：
- en: '![](Images/51c64a73-50bf-428d-86c1-fc39315717ad.png)Postman chrome tool extension;
    the purpose of the image is just to show the body of the request that we sent
    earlier'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/51c64a73-50bf-428d-86c1-fc39315717ad.png)Postman chrome工具扩展；图片的目的只是显示我们之前发送的请求的正文
- en: 'Here are the important things to note about the message request:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于消息请求的重要注意事项：
- en: URL: `https://fcm.googleapis.com/v1/projects/<projectid>/messages:send`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: URL：`https://fcm.googleapis.com/v1/projects/<projectid>/messages:send`
- en: 'Header: contains two key-value pairs:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头：包含两个键值对：
- en: '`Content-Type`: `application/json`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type`：`application/json`'
- en: '`Authorization`: `Bearer` <access token>'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authorization`：`Bearer` <访问令牌>'
- en: 'Request body: Contains the message object with the following key values:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求正文：包含具有以下键值的消息对象：
- en: '`token`: <registration token for the client app to send the message to>'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token`：<注册令牌，用于向客户端应用发送消息>'
- en: '`notification`: It contains the configuration for your notiification message'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notification`：它包含您的通知消息的配置'
- en: Yeah, so now we have FCM integrated in our app to send the notification message
    to a single device where an app is running in the background. However, you would
    want to send the notifications to a group of devices or may want to send the messages
    to a topic to which clients have subscribed. The basic concept will remain the
    same, but there will be changes in the configuration. You can refer to those topics
    in the firebase documentation at [https://firebase.google.com/docs/cloud-messaging](https://firebase.google.com/docs/cloud-messaging).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，现在我们已经在我们的应用程序中集成了FCM，以便将通知消息发送到后台运行应用程序的单个设备。但是，您可能希望将通知发送到一组设备，或者可能希望将消息发送到客户端已订阅的主题。基本概念将保持不变，但配置将发生变化。您可以在firebase文档中参考这些主题[https://firebase.google.com/docs/cloud-messaging](https://firebase.google.com/docs/cloud-messaging)。
- en: We will see Cloud Functions in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到云函数。
- en: Cloud Functions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云函数
- en: Generally, any software application has some kind of backend logic that gets
    deployed on the server to be accessible through the internet. In case of big enterprise-level
    applications such as Banking or Finance, it may be worth to manage a server or
    cluster of servers. However, in case of small applications or the application
    where you want to execute certain logic depending on some user events, such as
    data changes in database or on API requests from mobile app or a web application,
    managing a server may be an overhead in terms of efforts as well as cost. However,
    when you use the Firebase platform, you don't need to worry about it as it provides
    **Cloud Functions **that lets you run code based on events emitted by specific
    Firebase products without managing servers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何软件应用都有一些后端逻辑，这些逻辑部署在服务器上，通过互联网访问。在大型企业级应用程序（如银行或金融）的情况下，可能值得管理一个服务器或一组服务器。然而，在小型应用程序或您希望根据某些用户事件执行特定逻辑的应用程序中，例如数据库中的数据更改或来自移动应用程序或Web应用程序的API请求，管理服务器可能会增加工作量和成本。但是，当您使用Firebase平台时，您不需要担心这一点，因为它提供了**云函数**，让您根据特定Firebase产品发出的事件运行代码，而无需管理服务器。
- en: Key features of Cloud Functions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云函数的关键特性
- en: Cloud Functions come with a lot features, including easy integration with other
    Firebase Products and third-party APIs, and powerful security and privacy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数具有许多功能，包括与其他Firebase产品和第三方API的轻松集成，以及强大的安全性和隐私。
- en: The key features of the Cloud Functions are discussed in the following subtopics.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数的关键特性在以下子主题中讨论。
- en: Seamless integration with other Firebase Products and third-party APIs
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他Firebase产品和第三方API的无缝集成
- en: Cloud Functions can be seamlessly integrated with other Firebase Products and
    third-party APIs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数可以与其他Firebase产品和第三方API无缝集成。
- en: 'Your custom functions can be executed on specific events, which can be emitted
    by the listed Firebase products:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您的自定义函数可以在特定事件上执行，这些事件可以由列出的Firebase产品发出：
- en: Cloud Firestore Triggers
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云Firestore触发器
- en: Realtime Database Triggers
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时数据库触发器
- en: Firebase Authentication Triggers
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase身份验证触发器
- en: Google Analytics for Firebase Triggers
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase分析触发器
- en: Cloud Storage Triggers
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云存储触发器
- en: Cloud Pub/Sub Triggers
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云Pub/Sub触发器
- en: HTTP Triggers
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP触发器
- en: You can use Firebase Admin SDK for seamless integration of across different
    Firebase products. It is very useful in some of the most common application requirements.
    Let's say that you want to generate database indexes or audit logs when something
    changes in your real-time database; you can write a cloud function that is executed
    based on Realtime database triggers. The other way around, you can do some database
    operation based on specific user behavior. Similarly, you can integrate Cloud
    Functions with **Firebase Cloud Messaging** (**FCM**) to notify users when specific
    events occur in your database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Firebase Admin SDK来实现不同Firebase产品的无缝集成。在一些最常见的应用需求中非常有用。假设您想要在实时数据库中的某些内容发生变化时生成数据库索引或审计日志；您可以编写一个基于实时数据库触发器执行的云函数。反过来，您可以根据特定用户行为执行一些数据库操作。同样地，您可以将云函数与Firebase云消息传递（FCM）集成，以便在数据库中发生特定事件时通知用户。
- en: Cloud Functions integration is not limited to only Firebase products; you can
    also integrate Cloud Functions with some third-party API services—by writing webhooks.
    Let's say you are part of a development team and want to update your Slack channel
    when somebody commits the code to Git. You can use the Git Webhook API, which
    will trigger your Cloud Function that executes logic to send the message to the
    Slack Channel. Similarly, you may use third-party Auth provider APIs, such as
    LinkedIn, to allow user login.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数的集成不仅限于Firebase产品；您还可以通过编写Webhook将云函数与一些第三方API服务集成。假设您是开发团队的一部分，并且希望在有人提交代码到Git时更新Slack频道。您可以使用Git
    Webhook API，它将触发您的云函数执行逻辑以将消息发送到Slack频道。同样，您可以使用第三方Auth提供程序API，例如LinkedIn，以允许用户登录。
- en: No server to maintain
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需维护服务器
- en: Cloud Functions run your code without requiring you to purchase or maintain
    any servers. You can write a Javascript or Typescript function and deploy it with
    a single command on the cloud. You don't need to worry about server maintenance or
    scaling. Firebase platform will automatically manage it for you. The scaling of
    the server instances happens precisely, depending on the workload.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数在无需购买或维护任何服务器的情况下运行您的代码。您可以编写JavaScript或TypeScript函数，并使用云上的单个命令部署它。您不需要担心服务器的维护或扩展。Firebase平台将自动为您管理。服务器实例的扩展发生得非常精确，具体取决于工作负载。
- en: Private and secure
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私密和安全
- en: The application business logic should be hidden from client side and must be
    secure enough to prevent any manipulation or reverse engineering of the code. Cloud
    Functions is fully secured, so it always remains private and will always do what
    you want.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的业务逻辑应该对客户端隐藏，并且必须足够安全，以防止对代码的任何操纵或逆向工程。云函数是完全安全的，因此始终保持私密，并始终按照您的意愿执行。
- en: Life cycle of a function
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的生命周期
- en: 'Life cycle of a Cloud function can be roughly divided into five stages, which
    are these:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数的生命周期大致可以分为五个阶段，分别是：
- en: You write code for a new function and define the conditions when the function
    should get executed. The function definition or code also contains the details
    of the event provider, such as Realtime database or FCM.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写新函数的代码，并定义函数应在何时执行的条件。函数定义或代码还包含事件提供程序的详细信息，例如实时数据库或FCM。
- en: You deploy the function using the Firebase CLI, and Firebase connects it to
    the event provider defined in the code.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Firebase CLI部署函数，并将其连接到代码中定义的事件提供程序。
- en: When the event provider generates the event that matches the conditions defined
    in the function, it gets executed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事件提供程序生成与函数中定义的条件匹配的事件时，它将被执行。
- en: Google automatically scales the number of instances based on the workload.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google会根据工作负载自动扩展实例的数量。
- en: Whenever you update the code of a function or delete a function, Google will
    automatically update or clean up the instances, respectively.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当您更新函数的代码或删除函数时，Google都会自动更新或清理实例。
- en: Let's now create a simple Cloud function with Realtime database provider and
    deploy it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在使用实时数据库提供程序创建一个简单的云函数并部署它。
- en: Setup of Firebase SDK for Cloud Functions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Firebase SDK以用于云函数
- en: It is necessary to have Firebase CLI installed to proceed further to initialize
    the Cloud Functions. You can install the Firebase CLI, as given in the next section,
    if not done already.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续初始化云函数之前，必须安装Firebase CLI。如果尚未安装，可以按照下一节中的说明安装Firebase CLI。
- en: Firebase CLI
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase CLI
- en: 'We have already seen in [*Chapter 5*](5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml), *User
    Profile and Access Management,* how to install it but here''s the command, just
    for reference:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第5章*]（5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml）*用户配置文件和访问管理*中看到了如何安装它，但这里是命令，仅供参考：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we have the Firebase CLI installed, we will log in to the firebase console
    using this command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Firebase CLI，我们将使用以下命令登录到firebase控制台：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command will open up a browser URL and will ask you to log in. After a
    successful login, you can go to the next step—initialization of the Firebase project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将打开一个浏览器URL，并要求你登录。成功登录后，你可以进行下一步——初始化Firebase项目。
- en: Initializing the Firebase Cloud project
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Firebase云项目
- en: 'Let''s create an empty project directory called cloud-functions. We will run
    the following command from the newly created cloud -functions directory to initialize
    the Cloud Functions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为cloud-functions的空项目目录。我们将从新创建的cloud-functions目录中运行以下命令来初始化云函数：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command will walk you through a wizard with different steps and will create
    the necessary files for your projects. It will ask for your preferred language:
    Javascript or TypeScript. We will go with the Typescript for this sample. It will
    also ask you whether you want to associate any existing firebase projects or want
    to create a new project to associate with it. We will select an existing project.
    It also asks you if you want it to install the required node dependencies. We
    will say yes so that it installs all the necessary node packages. If you want
    to manage the dependencies yourself, you can say no to it. The following screenshot
    shows how the wizard looks:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将引导你通过一个包含不同步骤的向导，并将为你的项目创建必要的文件。它会询问你喜欢的语言：Javascript还是TypeScript。我们将选择Typescript作为示例。它还会问你是否想要关联任何现有的firebase项目或者想要创建一个新项目来关联。我们将选择一个现有的项目。它还会问你是否要安装所需的node依赖。我们会选择是，这样它就会安装所有必要的node包。如果你想自己管理依赖，可以选择否。以下截图显示了向导的外观：
- en: '![](Images/e455db7d-42ab-45ad-895e-b49c8e8aea67.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e455db7d-42ab-45ad-895e-b49c8e8aea67.png)'
- en: 'The final structure will look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结构将如下所示：
- en: '![](Images/a16ae49d-f10b-44ef-bc87-e8075278941f.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a16ae49d-f10b-44ef-bc87-e8075278941f.png)'
- en: 'Let''s understand some of these files specific to Cloud function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些特定于云函数的文件：
- en: '`firebase.json`: It includes properties of your project. It contains a property
    called "source", which points to the `functions` folder for your Cloud function
    code. If you want to point to some other folder, you change it here. It also includes
    a property called "predeploy", which essentially contains the command to build
    and run your code.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`firebase.json`：它包含了项目的属性。它包含一个名为"source"的属性，指向`functions`文件夹，用于存放云函数代码。如果你想指向其他文件夹，可以在这里更改。它还包括一个名为"predeploy"的属性，基本上包含了构建和运行代码的命令。'
- en: '`.firebaserc`: It contains projects that are associated with this directory.
    It helps you quickly switch between projects.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.firebaserc`：它包含了与该目录相关联的项目。它可以帮助你快速切换项目。'
- en: '`functions/src/index.ts`: This is the main source file where all your Cloud
    function code will go. By default, a function called `helloworld` will already
    be there in this file. However, it is commented out by default.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functions/src/index.ts`：这是主要的源文件，所有的云函数代码都将放在这里。默认情况下，这个文件中已经有一个名为`helloworld`的函数。但是，默认情况下它是被注释掉的。'
- en: '`functions/package.json`: Contains NPM dependencies of this project.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functions/package.json`：包含了该项目的NPM依赖。'
- en: If you are a  Windows user, you may have to change the value of the property
    "predeploy" in your `firebase.json` file from "`npm` --prefix  `$RESOURCE_DIR`
    run build" to "`npm` --prefix `%RESOURCE_DIR%` run build", as it sometimes gives
    an error when you try to deploy your function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Windows用户，你可能需要将`firebase.json`文件中的"predeploy"属性的值从"`npm` --prefix `$RESOURCE_DIR`
    run build"改为"`npm` --prefix `%RESOURCE_DIR%` run build"，因为有时在尝试部署函数时会出现错误。
- en: 'Once the setup is complete, we are good to go with the deployment of our first
    cloud function. For this sample, we will write a simple function call `greetUser`,
    which accepts the name of user in the `request` parameter and show a greeting
    message in response:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们就可以部署我们的第一个云函数了。对于这个示例，我们将编写一个简单的函数调用 `greetUser`，它接受 `request` 参数中的用户名称，并在响应中显示问候消息：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First of all, we need to import f*irebase-functions *to make our functions work.
    Also, note that the Cloud Function is implemented by calling `functions.https`,
    which essentially means that we are using an HTTP trigger.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 f*irebase-functions *来使我们的函数工作。还要注意，云函数是通过调用 `functions.https` 来实现的，这基本上意味着我们正在使用
    HTTP 触发器。
- en: The `greetUser()` Cloud function is an HTTP endpoint. If you know ExpressJS
    programming, you must have noted that the syntax resembles ExpressJS endpoint,
    which executes a function with request and response objects when a user hits the
    endpoint. Actually, the event handler for an HTTP function listens for the `onRequest()`
    event, which supports routers and apps managed by the Express web framework. The
    response object is used to send response back to the user, in our case, a text
    message, which the user will see in the browser.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`greetUser()` 云函数是一个 HTTP 端点。如果您了解 ExpressJS 编程，您一定注意到语法类似于 ExpressJS 端点，当用户点击端点时，它执行一个带有请求和响应对象的函数。实际上，HTTP
    函数的事件处理程序监听 `onRequest()` 事件，支持由 Express web 框架管理的路由器和应用程序。响应对象用于向用户发送响应，在我们的情况下是文本消息，用户将在浏览器中看到。'
- en: Deployment and execution of Cloud Function
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和执行云函数
- en: 'We need to use the following command to deploy our `helloworld` Cloud function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用以下命令来部署我们的 `helloworld` 云函数：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command will deploy our function, and you should see the following response
    in your Command Prompt:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将部署我们的函数，您应该在命令提示符中看到以下响应：
- en: '![](Images/11742558-0610-45d0-9c6e-ea55e5cf23a2.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11742558-0610-45d0-9c6e-ea55e5cf23a2.png)'
- en: If the deployment has been completed successfully, you will see the function
    URL, such as `https://us-central1-seat-booking.cloudfunctions.net/greetUser`,
    which can now be used to trigger the execution of the Cloud Function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部署成功完成，您将看到函数 URL，例如 `https://us-central1-seat-booking.cloudfunctions.net/greetUser`，现在可以用来触发云函数的执行。
- en: 'The function URL includes the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 URL 包括以下内容：
- en: '`us-central1`: This is the region in which your function is deployed'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-central1`：这是您的函数部署的区域'
- en: '`seat-booking`: This is the Firebase project ID'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seat-booking`：这是 Firebase 项目 ID'
- en: '`cloudfunction.net`: This is the default domain'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloudfunction.net`：这是默认域'
- en: '`greetUser`: This is the name of the function deployed'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`greetUser`：这是部署的函数名称'
- en: We need to append pass name property as a request parameter to see that name
    in the greeting message.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将名称属性作为请求参数附加以查看在问候消息中看到的名称。
- en: 'You should see the following output when you hit that URL from your browser:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从浏览器中点击该 URL 时，您应该看到以下输出：
- en: '![](Images/06c84a54-7799-4579-ac0d-8ded26f83360.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06c84a54-7799-4579-ac0d-8ded26f83360.png)'
- en: So we have successfully created a Cloud function, yay!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们成功创建了一个云函数，耶！
- en: 'Most developers would want to unit test their functions before deploying them
    on production or test environments. You can deploy and test your functions locally
    using the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员希望在将函数部署到生产或测试环境之前对其进行单元测试。您可以使用以下命令在本地部署和测试您的函数：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It will start a local server and show a URL that you can hit to test your function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它将启动一个本地服务器，并显示一个 URL，您可以点击以测试您的函数：
- en: '![](Images/7f9cb413-d1ac-413e-a1e9-02cf5f0856a9.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7f9cb413-d1ac-413e-a1e9-02cf5f0856a9.png)'
- en: In this example, we saw how we can trigger a function through an HTTP request
    using `functions.https`. Let's explore all Triggering Functions now.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了如何通过 `functions.https` 使用 HTTP 请求触发函数。现在让我们探索所有触发函数。
- en: Triggering Functions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发函数
- en: Cloud Functions can be executed in response to the events generated by other
    Firebase products, which are essentially triggers for the Cloud Functions. We
    have seen the list of all triggers in the Key Features section. We will talk about
    Realtime Database Triggers, Authentication Triggers, Cloud storage Triggers, and
    Cloud Firestore Triggers, which are most relevant to this book. The rest three
    can be explored in the Firebase documentation at [https://firebase.google.com/docs/functions/](https://firebase.google.com/docs/functions/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Functions 可以响应其他 Firebase 产品生成的事件而执行。这些事件本质上是 Cloud Functions 的触发器。我们已经在关键特性部分看到了所有触发器的列表。我们将讨论与本书最相关的实时数据库触发器、身份验证触发器、云存储触发器和云
    Firestore 触发器。其余三个可以在 Firebase 文档中进行探索：[https://firebase.google.com/docs/functions/](https://firebase.google.com/docs/functions/)。
- en: Realtime Database Triggers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时数据库触发器
- en: We can create Cloud Functions, which can respond to Realtime database changes
    to execute certain tasks. We can create a new function for Realtime Database events
    with `functions.database`*. *To specify when the function gets executed, we need
    to use one of the event handlers that are available to handle different database
    events. We also need to specify the database path to which the function will listen
    for events.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建 Cloud Functions，以响应实时数据库更改来执行某些任务。我们可以使用 `functions.database`* 创建一个新的实时数据库事件函数。*为了指定函数何时执行，我们需要使用可用于处理不同数据库事件的事件处理程序之一。我们还需要指定函数将监听事件的数据库路径。
- en: 'Given here are the events that are supported by Cloud Functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 Cloud Functions 支持的事件：
- en: '`onWrite()` : It triggers when data is created, destroyed, or changed in the
    Realtime Database'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWrite()`：当实时数据库中的数据被创建、销毁或更改时触发'
- en: '`onCreate()`: It triggers when new data is created in the Realtime Database'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`：当实时数据库中创建新数据时触发'
- en: 'onUpdate(): It triggers when data is updated in the Realtime Database'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: onUpdate()：当实时数据库中的数据更新时触发
- en: 'onDelete(): It triggers when data is deleted from the Realtime Database'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: onDelete()：当实时数据库中的数据被删除时触发
- en: 'We can see the sample Realtime database function, which listens to users path
    in the database, and, whenever there is any change in the data of any user, it
    converts the name to uppercase and sets it as a sibling of the user''s database.
    Here, we are using a wildcard `{userId}`, which essentially means any `userId`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到示例实时数据库函数，它监听数据库中的用户路径，每当任何用户的数据发生变化时，将其名称转换为大写并将其设置为用户数据库的同级。在这里，我们使用了通配符
    `{userId}`，它实质上表示任何 `userId`：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `event.data` is a DeltaSnapshot. iT has a property called 'previous' that
    lets you check what was saved to the database before the event. The previous property
    returns a new DeltaSnapshot where all methods refer to the previous value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`event.data` 是一个 DeltaSnapshot。它有一个名为 'previous' 的属性，让您可以检查事件发生前保存在数据库中的内容。previous
    属性返回一个新的 DeltaSnapshot，其中所有方法都指向先前的值。
- en: Authentication triggers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证触发器
- en: Using Authentication triggers, we can execute function code in response to the
    creation and deletion of a user via Firebase Authentication.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用身份验证触发器，我们可以在 Firebase 身份验证创建和删除用户时执行函数代码。
- en: 'To create a Cloud function that is executed if a new user is created, we can
    use the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个在创建新用户时执行的 Cloud 函数，我们可以使用以下代码：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'According to the Firebase documentation, user creation events for Cloud Functions
    occur in the following scenarios:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Firebase 文档，Cloud Functions 的用户创建事件发生在以下情况下：
- en: The developer creates an account using the Firebase Admin SDK
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员使用Firebase Admin SDK创建帐户
- en: A user creates an email account and password
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户创建电子邮件帐户和密码
- en: A user signs in for the first time using a federated identity provider
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户首次使用联合身份提供者登录
- en: A user signs in to a new anonymous auth session for the first time
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户首次匿名身份验证登录
- en: A Cloud Functions event is *not* triggered when a user signs in for the first
    time using a custom token. If you would like to access attributes of a newly created
    user, you can do so using the `event.data`object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户首次使用自定义令牌登录时，不会触发Cloud Functions事件。如果您想要访问新创建用户的属性，可以使用`event.data`对象进行访问。
- en: 'For example, you can get the user''s email and name as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以按以下方式获取用户的电子邮件和姓名：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Apart from user creation, if you want to trigger a function on user deletion,
    you can do it using the `onDelete()` event handler:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户创建，如果您想要在用户删除时触发函数，可以使用`onDelete()`事件处理程序进行操作：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Cloud Storage Triggers
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Storage触发器
- en: 'With Cloud Storage Triggers, you can execute a Firebase Cloud Function in response
    to create, update, or delete operation of files and folders in Cloud Storage.
    We can create a new function for Cloud Storage events with *functions.storage.*
    Depending on the requirement, you can have a function that listens for all changes
    on the default storage bucket, or you can restrict it to a specific bucket by
    specifying the bucket name:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cloud Storage触发器，您可以对Cloud Storage中的文件和文件夹的创建、更新或删除操作执行Firebase Cloud Function。我们可以使用*functions.storage.*为Cloud
    Storage事件创建一个新的函数。根据需求，您可以创建一个监听默认存储桶上所有更改的函数，或者可以通过指定存储桶名称来限制它：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example, we can write a function that compresses the uploaded files to
    reduce the size:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个将上传的文件压缩以减小大小的函数：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The *change* event gets triggered whenever an object is created, modified, or
    deleted.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*change*事件在对象创建、修改或删除时触发。'
- en: 'The following attributes are exposed by Cloud Storage functions, which can
    be used to do the further processing of files:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Storage函数公开了以下属性，可用于进一步处理文件：
- en: '`event.data`: Represents the storage object.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data`：表示存储对象。'
- en: '`event.data.bucket`: The storage bucket inside which the file is stored.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data.bucket`：文件存储的存储桶。'
- en: '`event.data.name`: The file path in the bucket.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data.name`：存储桶中的文件路径。'
- en: '`event.data.contentType`: The file content type.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data.contentType`：文件内容类型。'
- en: '`event.data.resourceState`: Two possible values: `exists` or `not_exists`.
    The `not_exists` value is set if the file / folder has been deleted.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data.resourceState`：两个可能的值：`exists`或`not_exists`。如果文件/文件夹已被删除，则设置为`not_exists`。'
- en: '`event.data.metageneration`: Number of times the metadata of the file has been
    generated; for new objects, the initial value is `1`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data.metageneration`：文件元数据生成的次数；对于新对象，初始值为`1`。'
- en: A most common use case for a Firebase Cloud Function is to further process a
    file, for example, compress the file or generate thumbnails of an image file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase Cloud Function的最常见用例是进一步处理文件，例如压缩文件或生成图像文件的缩略图。
- en: HTTP Triggers
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP触发器
- en: We have already seen an example of HTTP endpoint called `greetUser()`, which
    covers most of the essential parts of HTTP endpoints. There's just one important
    point to note, that we should always terminate our functions properly; else, they
    might continue to run, and the system will forcibly terminate it. We can end our
    function with `send()`, `redirect()`, or `end()`*.*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个名为`greetUser()`的HTTP端点的示例，它涵盖了大部分HTTP端点的基本部分。只有一个重要的要点需要注意，我们应该始终正确终止我们的函数；否则，它们可能会继续运行，系统将强制终止它。我们可以使用`send()`、`redirect()`或`end()`来结束我们的函数。
- en: 'Consider this example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Also, if you are using Firebase hosting and want to connect your HTTP endpoint
    with some custom domain, you can do that as well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您正在使用Firebase托管，并希望将您的HTTP端点与某个自定义域连接起来，您也可以这样做。
- en: Cloud Firestore Triggers
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Firestore触发器
- en: Using Cloud Firestore Triggers, your Cloud function can listen to the events
    emitted by Cloud Firestore whenever there is a change in the data on the specified
    path your function listens to.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cloud Firestore触发器，您的云函数可以监听Cloud Firestore发出的事件，每当指定路径上的数据发生更改时，您的函数就会监听到。
- en: At a high level, it works similarly to the Realtime database triggers. You can
    use the `functions.firestore` object to listen to the specific events.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，它的工作方式类似于实时数据库触发器。您可以使用`functions.firestore`对象来监听特定事件。
- en: 'It supports four events: create, update, delete, and write, as listed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持四个事件：创建、更新、删除和写入，如下所列：
- en: '`onWrite()`: It triggers when any document is created, updated, or deleted'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWrite()`: 当任何文档被创建、更新或删除时触发'
- en: '`onCreate()`: It triggers when a new document is created'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 当创建新文档时触发'
- en: '`onUpdate()`: It triggers when any value in an existing document is changed'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate()`: 当现有文档中的任何值更改时触发'
- en: '`onDelete()`: It triggers when a document is deleted'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDelete()`: 当文档被删除时触发'
- en: 'If you want to execute a function whenever a specific document gets changed,
    you can write a function like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在特定文档更改时执行函数，可以编写如下函数：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will now talk about Cloud function termination.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论云函数终止。
- en: Function termination
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数终止
- en: The advantage of the Cloud Functions is that you don't need to procure any servers
    on your own, so you just need to pay charges for the duration that your Cloud
    Function runs. This also gives you a responsibility that you terminate your function
    properly and don't keep your function running in an infinite loop, otherwise it
    will incur extra charges in your bill.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数的优势在于您无需自行采购任何服务器，因此您只需要支付云函数运行的时间。这也给了您一个责任，即正确终止您的函数，不要让您的函数陷入无限循环，否则将在您的账单中产生额外费用。
- en: 'To terminate your function and manage its life cycle properly, you can follow
    these recommended approaches:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确终止函数并管理其生命周期，您可以遵循以下推荐方法：
- en: Resolve asynchronous processing functions by returning a JavaScript promise
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过返回JavaScript promise解决异步处理函数
- en: End HTTP functions with `res.redirect()`, `res.send()`, or `res.end()`
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`res.redirect()`、`res.send()`或`res.end()`结束HTTP函数
- en: End a synchronous function with a `return;` statement
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`return;`语句结束同步函数
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about two advanced features of Firebase: Firebase
    Cloud Messaging and Firebase Cloud Functions. Using these two features, you can
    develop a highly interactive serverless app.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Firebase的两个高级功能：Firebase Cloud Messaging和Firebase Cloud Functions。使用这两个功能，您可以开发一个高度交互式的无服务器应用程序。
- en: FCM is a messaging platform for reliable message delivery of downstream and
    upstream messages. We also discussed different message types and saw when to use
    one over another. To have practical experience on FCM, we enhanced our Helpdesk
    application to send and receive notifications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: FCM是一个可靠的消息传递平台，用于下行和上行消息的可靠传递。我们还讨论了不同的消息类型，并看到何时使用其中一种。为了在FCM上有实际经验，我们增强了我们的Helpdesk应用程序以发送和接收通知。
- en: We also spoke about Firebase Cloud Functions and saw how it helps to have a
    serverless app. We covered how to develop a cloud function and deploy it on the
    server. We also explored the different types of triggers, such as Realtime database
    triggers, HTTP triggers, Cloud Firestore triggers, Cloud Storage Triggers, and
    Auth triggers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还谈到了Firebase云函数，看到它如何帮助实现无服务器应用。我们介绍了如何开发云函数并将其部署到服务器上。我们还探讨了不同类型的触发器，如实时数据库触发器、HTTP触发器、Cloud
    Firestore触发器、Cloud Storage触发器和Auth触发器。
- en: In the next chapter, we will cover other advanced and interesting features,
    such as Firebase Cloud Storage and integration of Firebase application with Google
    Cloud.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖其他高级和有趣的功能，比如Firebase云存储和将Firebase应用与Google Cloud集成。
