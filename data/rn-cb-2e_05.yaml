- en: Implementing Complex User Interfaces - Part III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施复杂用户界面-第三部分
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Creating a map app
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建地图应用程序
- en: Creating an audio player
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建音频播放器
- en: Creating an image carousel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像轮播
- en: Adding push notifications to your app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将推送通知添加到您的应用程序
- en: Implementing browser-based authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施基于浏览器的身份验证
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll cover some of the more advanced features you might need
    to add to an app. The applications we'll build in this chapter include building
    a fully functional audio player, map integration, and implementing browser-based
    authentication so that your app can connect to public APIs for developers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍您可能需要添加到应用程序的一些更高级功能。本章中我们将构建的应用程序包括构建完全功能的音频播放器，地图集成以及实施基于浏览器的身份验证，以便您的应用程序可以连接到开发人员的公共API。
- en: Creating a map app
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地图应用程序
- en: Using a mobile device is a portable experience, so it's no surprise that maps
    are a common part of many iOS and Android applications. Your app may need to tell
    a user where they are, where they're going, or where other users are in real time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动设备是一种便携式体验，因此地图是许多iOS和Android应用程序的常见部分并不奇怪。您的应用程序可能需要告诉用户他们在哪里，他们要去哪里，或者其他用户实时在哪里。
- en: In this recipe, we'll be making a simple app that uses Google Maps on Android,
    and Apple's Maps app on iOS, to display a map centered on the user's location.
    We will be using Expo's `Location` helper library to get the latitude and longitude
    of the user and will use that data to render the map using Expo's `MapView` component.
    `MapView` is an Expo ready version of the react-native-maps package created by
    Airbnb, so you can expect the react-native-maps documentation to apply, which
    can be found at [https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将制作一个简单的应用程序，该应用程序在Android上使用Google Maps，在iOS上使用Apple的地图应用程序，以显示以用户位置为中心的地图。我们将使用Expo的`Location`辅助库来获取用户的纬度和经度，并将使用这些数据来使用Expo的`MapView`组件渲染地图。`MapView`是由Airbnb创建的react-native-maps包的Expo版本，因此您可以期望react-native-maps文档适用，该文档可以在[https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)找到。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need to create a new app for this recipe. Let's call it `map-app`. Since
    the user pin in this recipe will use a custom icon, we'll also need an image for
    that. I used the icon You Are Here by Maico Amorim, which you can download from
    [https://thenounproject.com/term/you-are-here/12314/](https://thenounproject.com/term/you-are-here/12314/).
    Feel free to use any image you'd like to represent the user pin. Save the image
    to the `assets` folder in the root of the project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个示例创建一个新的应用程序。让我们称之为`map-app`。由于此示例中的用户图标将使用自定义图标，因此我们还需要一个图像。我使用了Maico
    Amorim的图标You Are Here，您可以从[https://thenounproject.com/term/you-are-here/12314/](https://thenounproject.com/term/you-are-here/12314/)下载。随意使用任何您喜欢的图像来代表用户图标。将图像保存到项目根目录的`assets`文件夹中。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start by opening `App.js` and adding our imports:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先打开`App.js`并添加我们的导入：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let''s define the `App` class and the initial `state`. In this recipe, `state`
    will only need to keep track of the user''s `location`, which we initialize to
    `null`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义`App`类和初始`state`。在这个示例中，`state`只需要跟踪用户的`位置`，我们将其初始化为`null`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we''ll define the `componentDidMount` life cycle hook, which will ask
    the user to grant permission to access the user''s location via the device''s
    geolocation. If the user grants the app permission to use its location, the return
    object will have a `status` property with the value `''granted''`. If granted,
    we''ll get the user''s location with `this.getLocation`, defined in the next step:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`componentDidMount`生命周期钩子，它将要求用户授予访问设备地理位置的权限。如果用户授予应用程序使用其位置的权限，返回的对象将具有一个值为`'granted'`的`status`属性。如果授予了权限，我们将使用`this.getLocation`获取用户的位置，这是在下一步中定义的：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `getLocation` function is simple. It grabs the location information from
    the device''s GPS using the `getCurrentPositionAsync` method of the `Location`
    component, then saves that location information to `state`. That information contains
    the latitude and longitude of the user, which we''ll use when we render the map:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getLocation`函数很简单。它使用`Location`组件的`getCurrentPositionAsync`方法从设备的GPS中获取位置信息，然后将该位置信息保存到`state`中。该信息包含用户的纬度和经度，在渲染地图时我们将使用它：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s use that location information to render our map. First, we''ll
    check that a `location` has been saved on `state`. If so, we''ll render the `MapView`,
    and otherwise render `null`. The only property we need to set to render our map
    is the `initialRegion` property, which defines the location the map should display
    when it is first rendered. We''ll pass this property on the object with the latitude
    and longitude saved to `state`, and define a starting zoom level with `latitudeDelta`
    and `longitudeDelta`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用该位置信息来渲染我们的地图。首先，我们将检查`state`上是否保存了一个`location`。如果是，我们将渲染`MapView`，否则渲染`null`。我们需要设置的唯一属性来渲染地图是`initialRegion`属性，它定义了地图在首次渲染时应该显示的位置。我们将在具有保存到`state`的纬度和经度的对象上传递这个属性，并使用`latitudeDelta`和`longitudeDelta`定义一个起始缩放级别：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the `MapView`, we''ll need to add a marker at the user''s current location.
    The `Marker` component is part of the `MapView` parent component, so in the JSX
    we''ll define a `MapView.Marker` child element of the `MapView` element. This
    element takes the user''s location, a title, and description for displaying when
    the icon is tapped, and a custom image via the `image` property:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MapView`中，我们需要在用户当前位置添加一个标记。`Marker`组件是`MapView`的父组件的一部分，所以在JSX中，我们将定义`MapView.Marker`作为`MapView`元素的子元素。这个元素需要用户的位置、标题和描述以在图标被点击时显示，以及通过`image`属性定义一个自定义图像：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s define our `render` function. It simply renders the map within
    a containing `View` element:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的`render`函数。它简单地在一个包含的`View`元素中渲染地图：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, let''s add our styles. We''ll set `flex` to `1` on both the container
    and the map, so that both fill the screen:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加我们的样式。我们将在容器和地图上都将`flex`设置为`1`，以便两者都填满屏幕：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we open the app, we''ll see a map rendered with our custom user icon
    at the location provided by the device! Unfortunately, Google Maps integration
    may not work in the Android emulator, so a real device may be needed to test the
    Android implementation of the app. Check out the *There''s more...* section at
    the end of this recipe for more information. Don''t be surprised that the iOS
    app running on a simulator displays the user''s location in San Francisco; this
    is due to how Xcode location defaults work. Run it on a real iOS device to see
    it render your location:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们打开应用程序，我们将看到一个地图在设备提供的位置上渲染了我们自定义的用户图标！不幸的是，Google地图集成可能无法在Android模拟器中工作，因此可能需要一个真实的设备来测试应用程序的Android实现。查看本食谱末尾的*还有更多...*部分以获取更多信息。不要惊讶，iOS应用程序在模拟器上运行时显示用户的位置在旧金山；这是由于Xcode位置默认设置的工作方式。在真实的iOS设备上运行它，以查看它是否渲染了你的位置：
- en: '![](assets/d2f4cb86-df1e-47df-bab4-248b6f2f34a3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2f4cb86-df1e-47df-bab4-248b6f2f34a3.png)'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By making use of the `MapView` component provided by Expo, the implementation
    of a map in your React Native app is now a much simpler and straightforward process
    than it once was.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Expo提供的`MapView`组件，在你的React Native应用中实现地图现在比以前简单直接得多。
- en: In *step 3*, we made use of the `Permissions` helper library. `Permissions`
    has a method called `askAsync`, which takes one parameter defining what type of
    permissions your app would like to request from the user. `Permissions` also has
    constants for each type of permission you can request from the user. These permission
    types include `LOCATION`, `NOTIFICATIONS` (which we'll use later in this chapter),
    `CAMERA`, `AUDIO_RECORDING`, `CONTACTS`, `CAMERA_ROLL`, and `CALENDAR`. Since
    we need the location in this recipe, we passed in the constant `Permissions.LOCATION`.
    Once the `askAsync` return promise resolves, the return object will have a `status`
    property and an `expiration` property. If the user has allowed the requested permission,
    `status` will be set to the `'granted'`string. If granted, we will fire off our
    `getLocation` method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们利用了`Permissions`帮助库。`Permissions`有一个叫做`askAsync`的方法，它接受一个参数，定义了你的应用想要从用户那里请求什么类型的权限。`Permissions`还为你可以从用户那里请求的每种类型的权限提供了常量。这些权限类型包括`LOCATION`，`NOTIFICATIONS`（我们将在本章后面使用），`CAMERA`，`AUDIO_RECORDING`，`CONTACTS`，`CAMERA_ROLL`和`CALENDAR`。由于我们在这个示例中需要位置，我们传入了常量`Permissions.LOCATION`。一旦`askAsync`返回promise解析，返回对象将有一个`status`属性和一个`expiration`属性。如果用户已经允许了请求的权限，`status`将被设置为`'granted'`字符串。如果被授予，我们将触发我们的`getLocation`方法。
- en: In *step 4*, we defined the function that gets the location from the device's
    GPS. We call the `getCurrentPositionAsync` method of the `Location` component.
    This method will return an object with a `coords` property and a `timestamp` property.
    The `coords` property gives us access to the `latitude` and `longitude`, as well
    as the `altitude`, `accuracy` (radius of uncertainty for the location, measured
    in meters), `altitudeAccuracy` (accuracy of the altitude value, in meters (iOS
    only)), `heading`, and `speed`. Once received, we save the location to `state`
    so that the `render` function will be called, and our map will be rendered.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了从设备GPS获取位置的函数。我们调用`Location`组件的`getCurrentPositionAsync`方法。这个方法将返回一个带有`coords`属性和`timestamp`属性的对象。`coords`属性让我们可以访问`latitude`和`longitude`，以及`altitude`，`accuracy`（位置的不确定性半径，以米为单位测量），`altitudeAccuracy`（高度值的精度，以米为单位（仅限iOS）），`heading`和`speed`。一旦接收到，我们将位置保存到`state`中，这样`render`函数将被调用，我们的地图将被渲染。
- en: 'In *step 5*, we defined the `renderMap` method to render the map. First, we
    check whether there is a location, and if there is, we render the `MapView` element.
    This element only requires us to define the value for one property: `initialRegion`.
    This property takes an object with four properties: `latitude`, `longitude`, `latitudeDelta`,
    and `longitudeDelta`. We set the `latitude` and `longitude` equal to those in
    the `state` object, and provide initial values for `latitudeDelta` and `longitudeDelta`.
    These last two properties dictate the initial zoom level that the map should be
    rendered at; the larger this number is, the more zoomed out the map will be. I
    suggest experimenting with these two values to see how they affect the rendered
    map.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了`renderMap`方法来渲染地图。首先，我们检查是否有位置，如果有，我们渲染`MapView`元素。这个元素只需要我们定义一个属性的值：`initialRegion`。这个属性接受一个带有四个属性的对象：`latitude`，`longitude`，`latitudeDelta`和`longitudeDelta`。我们将`latitude`和`longitude`设置为`state`对象中的值，并为`latitudeDelta`和`longitudeDelta`提供初始值。这两个属性决定了地图应该以什么初始缩放级别进行渲染；这个数字越大，地图就会显示得越远。我建议尝试这两个值，看看它们如何影响渲染的地图。
- en: In *step 6*, we added the marker to the map by adding a `MapView.Marker` element
    as a child of the `MapView` element. We defined the coordinates by passing the
    info saved on `state` (`state.location.coords`) to the `coords` property, and
    set a `title` and `description` for the marker's popup when tapped. We were also
    able to easily define a custom pin by inlining our custom image with a `require`
    statement in the `image` property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们通过将`MapView.Marker`元素作为`MapView`元素的子元素添加到地图上。我们通过将保存在`state`（`state.location.coords`）上的信息传递给`coords`属性来定义坐标，并在被点击时为标记的弹出窗口设置了`title`和`description`。我们还可以通过在`image`属性中使用`require`语句内联我们的自定义图像来轻松定义自定义图钉。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As mentioned previously, you can read the docs for the react-native-maps project
    to learn more about the features of this excellent library ([https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)).
    For instance, you can easily customize the appearance of your Google map by using
    Google Maps Styling Wizard ([https://mapstyle.withgoogle.com/](https://mapstyle.withgoogle.com/))
    to generate a `mapStyle` JSON object, then pass that object to the `MapView` component's `customMapStyle`
    property. Or, you could add geometric shapes to your map with the `Polygon` and
    `Circle` components.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以阅读react-native-maps项目的文档，了解这个优秀库的更多功能（[https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)）。例如，您可以使用Google地图样式向导（[https://mapstyle.withgoogle.com/](https://mapstyle.withgoogle.com/)）轻松自定义Google地图的外观，生成`mapStyle`
    JSON对象，然后将该对象传递给`MapView`组件的`customMapStyle`属性。或者，您可以使用`Polygon`和`Circle`组件向地图添加几何形状。
- en: Once you're ready to deploy your app, there are a few follow-up steps that you
    will need to take to take to ensure the map works properly on Android. You can
    read the details on how deploying to a standalone Android app with a `MapView` component
    works in the Expo documentation at [https://docs.expo.io/versions/latest/sdk/map-view#deploying-to-a-standalone-app-on-android](https://docs.expo.io/versions/latest/sdk/map-view#deploying-to-a-standalone-app-on-android).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备部署您的应用程序，您需要采取一些后续步骤来确保地图在Android上正常工作。您可以阅读Expo文档中有关如何使用`MapView`组件部署到独立Android应用程序的详细信息：[https://docs.expo.io/versions/latest/sdk/map-view#deploying-to-a-standalone-app-on-android](https://docs.expo.io/versions/latest/sdk/map-view#deploying-to-a-standalone-app-on-android)。
- en: There is a known issue that could cause problems when rendering Google Maps
    within the Android simulator. You can refer to the following GitHub link for more
    information: [https://github.com/react-native-community/react-native-maps/issues/942](https://github.com/react-native-community/react-native-maps/issues/942).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android模拟器中渲染Google地图可能会出现问题。您可以参考以下GitHub链接获取更多信息：[https://github.com/react-native-community/react-native-maps/issues/942](https://github.com/react-native-community/react-native-maps/issues/942)。
- en: Creating an audio player
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建音频播放器
- en: Audio players are another common interface built into many applications. Whether
    your app needs to play audio files stored locally on the device or stream audio
    from a remote location, Expo's `Audio` component comes to the rescue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放器是许多应用程序内置的常见界面。无论您的应用程序需要在设备上本地播放音频文件还是从远程位置流式传输音频，Expo的`Audio`组件都可以帮助您。
- en: 'In this recipe, we''ll be building a full-fledged basic audio player, with
    play/pause, next track, and previous track functionality. For simplicity, we''ll
    be hardcoding the information for the tracks we''ll be using, but in a real-world
    scenario, you''ll likely be working with similar objects to what we''re defining:
    an object with a track title, album name, artist name, and a URL to a remote audio
    file. I''ve chosen three random live tracks from the Internet Archive''s Live
    Music Archive ([https://archive.org/details/etree](https://archive.org/details/etree)).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将构建一个功能齐全的基本音频播放器，具有播放/暂停、下一曲和上一曲功能。为简单起见，我们将硬编码我们将使用的曲目信息，但在现实世界的情况下，您可能会使用类似我们定义的对象：一个带有曲目标题、专辑名称、艺术家名称和远程音频文件URL的对象。我从互联网档案馆的现场音乐档案中随机选择了三个现场曲目（[https://archive.org/details/etree](https://archive.org/details/etree)）。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to create a new app for this recipe. Let's call it `audio-player`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个食谱创建一个新的应用。让我们称之为`audio-player`。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening up `App.js` and adding the dependencies we''ll need:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`App.js`并添加我们需要的依赖开始：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An audio player needs audio to play. We''ll create a `playlist` array to hold
    the audio tracks. Each track is represented by an object with a `title`, `artist`, `album`,
    and `uri`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音频播放器需要音频来播放。我们将创建一个`playlist`数组来保存音频曲目。每个曲目由一个带有`title`、`artist`、`album`和`uri`的对象表示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll define our `App` class and initial `state` object with four properties:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的`App`类和初始的`state`对象，其中包含四个属性：
- en: '`isPlaying` for defining whether the player is playing or paused'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPlaying`用于定义播放器是正在播放还是暂停'
- en: '`playbackInstance` to hold the `Audio` instance'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbackInstance`用于保存`Audio`实例'
- en: '`volume` and `currentTrackIndex` for the currently playing track'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`和`currentTrackIndex`用于当前播放的曲目'
- en: '`isBuffering` to display a `Buffering...` message while the track is buffering
    at the beginning of playback'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isBuffering`用于在曲目在播放开始时缓冲时显示`缓冲中...`消息'
- en: 'As shown in following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的代码：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s define the `componentDidMount` life cycle hook next. We''ll use this
    method to configure the `Audio` component via the `setAudioModeAsync` method,
    passing in an `options` object with a few recommended settings. These will be
    discussed more in the *How it works...* section at the end of the recipe. After
    this, we''ll load the audio with `loadAudio`, defined in the next step:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们接下来定义`componentDidMount`生命周期钩子。我们将使用这个方法通过`setAudioModeAsync`方法配置`Audio`组件，传入一个带有一些推荐设置的`options`对象。这些将在食谱末尾的*它是如何工作...*部分进行更多讨论。之后，我们将使用`loadAudio`加载音频，定义在下一步中：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `loadAudio` function will handle loading the audio for our player. First,
    we''ll create a new instance of `Audio.Sound`. We''ll then call the `setOnPlaybackStatusUpdate`
    method on our new `Audio` instance, passing in a handler that will be called whenever
    the state of playback within the instance has changed. Finally, we call `loadAsync`
    on the instance, passing it a source from the `playlist` array, as well as a status
    object with the volume and a `shouldPlay` property set to the `isPlaying` value
    of `state`. The third parameter dictates whether we want to wait for the file
    to finish downloading before it is played, so we pass in `false`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loadAudio`函数将处理我们播放器的音频加载。首先，我们将创建一个新的`Audio.Sound`实例。然后，我们将在我们的新`Audio`实例上调用`setOnPlaybackStatusUpdate`方法，传入一个处理程序，每当实例内的播放状态发生变化时将被调用。最后，我们在实例上调用`loadAsync`，传入一个来自`playlist`数组的源，以及一个带有音量和`state`的`isPlaying`值的`shouldPlay`属性的状态对象。第三个参数决定我们是否希望在播放之前等待文件下载完成，因此我们传入`false`：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We still need to define the callback for handling status updates. All we need
    to do in this function is set the value of `isBuffering` on `state` to the `isBuffering`
    value on the `status` parameter that was passed in from the `setOnPlaybackStatusUpdate`
    function call:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要定义处理状态更新的回调。在这个函数中，我们需要做的就是将从`setOnPlaybackStatusUpdate`函数调用中传入的`status`参数上的`isBuffering`值设置到`state`上的`isBuffering`值：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our app now knows how to load an audio file from the `playlist` array and update
    `state` with the current buffering status of the loaded audio file, which we''ll
    use later in the `render` function to display a message to the user. All that''s
    left is to add the behavior for the player itself. First, we''ll handle the play/pause
    state. The `handlePlayPause` method checks the value of `this.state.isPlaying`
    to determine whether the track should be played or paused, and calls the associated
    method on the `playbackInstance` accordingly. Finally, we need to update the value
    of  `isPlaying `for `state`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用现在知道如何从`playlist`数组中加载音频文件，并更新`state`中加载的音频文件的当前缓冲状态，我们稍后将在`render`函数中使用它向用户显示消息。现在剩下的就是为播放器本身添加行为。首先，我们将处理播放/暂停状态。`handlePlayPause`方法检查`this.state.isPlaying`的值，以确定是否应播放或暂停曲目，并相应地调用`playbackInstance`上的关联方法。最后，我们需要更新`state`中的`isPlaying`的值：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s define the function for handling skipping to the previous track.
    First, we''ll clear the current track from the `playbackInstance` by calling `unloadAsync`.
    We''ll update the `currentTrackIndex` value of `state` to either one less than
    the current value, or `0` if we''re at the beginning of the `playlist` array.
    Then, we''ll call `this.loadAudio` to load the proper track:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义处理跳转到上一首曲目的函数。首先，我们通过调用`unloadAsync`从`playbackInstance`中清除当前曲目。然后，我们将`state`中的`currentTrackIndex`值更新为当前值减一，或者如果我们在`playlist`数组的开头，则更新为`0`。然后，我们将调用`this.loadAudio`来加载正确的曲目：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Not surprisingly, `handleNextTrack` is the same as the preceding function,
    but this time we''ll either add `1` to the current index, or set the index to
    `0` if we''re at the end of the `playlist` array:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毫不奇怪，`handleNextTrack`与前面的函数相同，但这次我们要么将当前索引加`1`，要么如果我们在`playlist`数组的末尾，则将索引设置为`0`：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It''s time to define our `render` function. We will need three basic pieces
    in our UI: a `''Buffering...''` message when the track is playing but still buffering,
    a section for displaying information for the current track, and a section to hold
    the player''s controls. The `''Buffering...''`  message will only display if both
    `this.state.isBuffering` and `this.state.isPlaying` are `true`. The song info
    is rendered via the `renderSongInfo` method, which we''ll define in *step 12*:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候定义我们的`render`函数了。在我们的UI中，我们需要三个基本部分：当曲目正在播放但仍在缓冲时显示“缓冲中…”的消息，用于显示当前曲目信息的部分，以及用于保存播放器控件的部分。当且仅当`this.state.isBuffering`和`this.state.isPlaying`都为`true`时，“缓冲中…”消息才会显示。歌曲信息是通过`renderSongInfo`方法呈现的，我们将在*步骤12*中定义：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The player controls are made up of three `TouchableOpacity` button elements,
    each with a corresponding icon from the Feather icon library. You can find more
    information on using icons in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*. We''ll determine whether to display the Play
    icon or the Pause icon depending on the value of `this.state.isPlaying`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放器控件由三个`TouchableOpacity`按钮元素组成，每个按钮都有来自Feather图标库的相应图标。您可以在[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)中找到有关使用图标的更多信息，*实现复杂用户界面-第一部分*。根据`this.state.isPlaying`的值，我们将确定是显示播放图标还是暂停图标：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `renderSongInfo` method returns basic JSX for displaying the metadata associated
    with the track currently playing:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`renderSongInfo` 方法返回用于显示当前播放的曲目相关元数据的基本 JSX：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All that''s left to add are the styles. The styles defined here are well-covered
    ground by now, and don''t go beyond centering, colors, font size, and adding padding
    and margins:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的就是添加样式。这里定义的样式现在已经是老生常谈了，不超出居中、颜色、字体大小以及添加填充和边距的范围：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can now check out your app in the simulator, and you should have a fully
    working audio player! Note that audio playback in the Android emulator may be
    too slow for the playback to work properly, and may sound very choppy. Open the
    app on a real Android device to hear the track playing properly:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在模拟器中查看您的应用，应该有一个完全正常工作的音频播放器！请注意，Android模拟器中的音频播放速度可能太慢，无法正常工作，并且可能听起来非常杂乱。在真实的Android设备上打开应用程序以听到音轨正常播放：
- en: '![](assets/21780eb9-bf05-4182-bad9-c53978ff19b1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21780eb9-bf05-4182-bad9-c53978ff19b1.png)'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 4*, we initialized options on the `Audio` component once the app finished
    loading via the `componentDidMount` method. The `Audio` component's `setAudioModeAsync`
    method takes an option object as its only parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，一旦应用程序完成加载，我们就在`componentDidMount`方法中对`Audio`组件进行了初始化。`Audio`组件的`setAudioModeAsync`方法将一个选项对象作为其唯一参数。
- en: 'Let''s review some of the options we used in this recipe:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些我们在这个配方中使用的选项：
- en: '`interruptionModeIOS` and `interruptionModeAndroid` set how the audio in your
    app should interact with the audio from other applications on the device. We used
    the `Audio` component''s `INTERRUPTION_MODE_IOS_DO_NOT_MIX` and `INTERRUPTION_MODE_ANDROID_DO_NOT_MIX` enums,
    respectively, to declare that our app''s audio should interrupt any other applications
    playing audio.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interruptionModeIOS` 和 `interruptionModeAndroid` 设置了您的应用中的音频应该如何与设备上其他应用程序的音频进行交互。我们分别使用了`Audio`组件的`INTERRUPTION_MODE_IOS_DO_NOT_MIX`和`INTERRUPTION_MODE_ANDROID_DO_NOT_MIX`枚举来声明我们的应用音频应该中断任何其他正在播放音频的应用程序。'
- en: '`playsInSilentModeIOS` is a Boolean that determines whether your app should
    play audio when the device is in silent mode.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playsInSilentModeIOS` 是一个布尔值，用于确定当设备处于静音模式时，您的应用是否应该播放音频。'
- en: '`shouldDuckAndroid` is a Boolean that determines whether your app''s audio
    should lower in volume (duck) when audio from another app interrupts your app.
    While this setting defaults to `true`, I''ve added it to the recipe so that you''re
    aware that it''s an option.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldDuckAndroid` 是一个布尔值，用于确定当另一个应用的音频中断您的应用时，您的应用的音频是否应该降低音量（减小）。虽然此设置默认为`true`，但我已将其添加到配方中，以便您知道这是一个选项。'
- en: In *step 5*, we defined the `loadAudio` method, which performs the heavy lifting
    in this recipe. First, we created a new instance of the `Audio.Sound` class and
    saved it to the  `playbackInstance` variable for later use. Next, we set the `source`
    and `status` variables that will be passed into the `loadAsync` function on the
    `playbackInstance` for actually loading the audio file. In the `source` object,
    we set the `uri` property to the corresponding `uri` property on the object in
    the `playlist` array at the index stored in `this.state.currentTrackIndex`. In
    the `status` object, we set the volume to the `volume` value saved on `state`,
    and set `shouldPlay`, a Boolean that determines whether the audio should be playing,
    initially to `this.state.isPlaying`. And, since we want to stream the remote MP3
    file instead of waiting for the entire file to download, we pass `false` the third,
    `downloadFirst`, parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了`loadAudio`方法，该方法在这个示例中承担了大部分工作。首先，我们创建了`Audio.Sound`类的新实例，并将其保存到`playbackInstance`变量中以供以后使用。接下来，我们设置将传递到`playbackInstance`的`loadAsync`函数的`source`和`status`变量，用于实际加载音频文件。在`source`对象中，我们将`uri`属性设置为`playlist`数组中对象中的相应`uri`属性的索引存储在`this.state.currentTrackIndex`中。在`status`对象中，我们将音量设置为`state`上保存的`volume`值，并将`shouldPlay`设置为一个布尔值，用于确定音频是否应该播放，最初设置为`this.state.isPlaying`。由于我们希望流式传输远程MP3文件而不是等待整个文件下载，因此我们将第三个参数`downloadFirst`设置为`false`。
- en: Before calling the `loadAsync` method, we first called `setOnPlaybackStatusUpdate `of `playbackInstance`, which
    takes a callback function that should be called when the state of `playbackInstance`
    has changed. We defined that handler in *step 6*. The handler simply saves the
    `isBuffering` value from the callback's `status` parameter to the `isBuffering`
    property of `state`, which will fire a rerender, updating the 'Buffering...' message
    in the UI accordingly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`loadAsync`方法之前，我们首先调用了`playbackInstance`的`setOnPlaybackStatusUpdate`，它接受一个回调函数，当`playbackInstance`的状态发生变化时应该被调用。我们在*步骤6*中定义了该处理程序。该处理程序简单地将回调的`status`参数中的`isBuffering`值保存到`state`的`isBuffering`属性中，这将触发重新渲染，相应地更新UI中的'缓冲中...'消息。
- en: In *step 7*, we defined the `handlePlayPause` function for toggling play and
    pause functionality in the app. If there's a track playing, `this.state.isPlaying`
    will be `true`, so we'll call the `pauseAsync` function on the `playbackInstance` otherwise,
    we'll call `playAsync` to start playing the audio again. Once we've played or
    paused, we update the value of `isPlaying` on `state`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们定义了`handlePlayPause`函数，用于在应用程序中切换播放和暂停功能。如果有曲目正在播放，`this.state.isPlaying`将为`true`，因此我们将在`playbackInstance`上调用`pauseAsync`函数，否则，我们将调用`playAsync`来重新开始播放音频。一旦我们播放或暂停，我们就会更新`state`上的`isPlaying`的值。
- en: In *step 8* and *step 9*, we created the functions that handle skipping to the
    next and previous tracks. Each of these functions increases or decreases the value
    of `this.state.currentTrackIndex` as appropriate, so that by the time `this.loadAudio`
    is called at the bottom of each function, it will load the track associated with
    the object in the `playlist` array at the new index.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8*和*步骤9*中，我们创建了处理跳转到下一首和上一首曲目的函数。每个函数根据需要增加或减少`this.state.currentTrackIndex`的值，因此在每个函数底部调用`this.loadAudio`时，它将加载与`playlist`数组中对象相关联的曲目的新索引。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The features of our current app are more basic than you'll find in most audio
    players, but all the tools you need for building a feature-rich audio player are
    at your disposal. For instance, you could display the current track time in the
    UI by tapping into the `positionMillis` property on the `status` parameter in
    the `setOnPlaybackStatusUpdate` callback. Or, you could use a React Native `Slider`
    component to allow the user to adjust the volume or playback rate. Expo's `Audio`
    component provides all the building blocks for a great audio player app.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前应用程序的功能比大多数音频播放器更基本，但您可以利用所有工具来构建功能丰富的音频播放器。例如，您可以通过在`setOnPlaybackStatusUpdate`回调中利用`status`参数上的`positionMillis`属性在UI中显示当前曲目时间。或者，您可以使用React
    Native的`Slider`组件允许用户调整音量或播放速率。Expo的`Audio`组件提供了构建出色音频播放器应用程序的所有基本组件。
- en: Creating an image carousel
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像轮播
- en: There are all kinds of applications that make use of image carousels. Any time
    there's a collection of images that you'd like your user to be able to peruse,
    a carousel is likely among the most effective UI patterns for accomplishing the
    task.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种应用程序使用图像轮播。每当有一组图像，您希望用户能够浏览时，轮播很可能是实现任务的最有效的UI模式之一。
- en: There are a number of packages in the React Native community for handling the
    creation of carousels, but in my experience none are more stable or more versatile
    than react-native-snap-carousel ([https://github.com/archriss/react-native-snap-carousel](https://github.com/archriss/react-native-snap-carousel)).
    This package provides a great API for customizing the look and behavior of your
    carousel, and supports Expo app development without the need for ejecting. You
    can easily change how slides appear as they slide in and out of the carousel frame
    via the Carousel component's `layout` property, and as of version 3.6, you can
    even create custom interpolations!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native社区中有许多软件包用于处理轮播的创建，但根据我的经验，没有一个比react-native-snap-carousel ([https://github.com/archriss/react-native-snap-carousel](https://github.com/archriss/react-native-snap-carousel))更稳定或更多功能。该软件包为自定义轮播的外观和行为提供了出色的API，并支持Expo应用程序开发，无需弹出。您可以通过Carousel组件的`layout`属性轻松更改幻灯片在轮播框架中滑入和滑出时的外观，截至3.6版本，您甚至可以创建自定义插值！
- en: While you are not limited to only displaying images with this package, we'll
    be building a carousel that just displays images along with a caption to keep
    the recipe simple. We'll be using the excellent license-free photo site [unsplash.com](http://www.unsplash.com)
    to get random images for displaying in our carousel via the Unsplash Source project
    hosted at [source.unsplash.com](http://source.unsplash.com). Unsplash Source allows
    you to easily request random images from Unsplash without needing to access the
    official API. You can visit the Unsplash Source site for more information on how
    it works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您不仅限于使用此软件包显示图像，但我们将构建一个仅显示图像的轮播，以及一个标题，以保持配方简单。我们将使用优秀的免费许可照片网站[unsplash.com](http://www.unsplash.com)通过托管在[source.unsplash.com](http://source.unsplash.com)的Unsplash
    Source项目获取用于在我们的轮播中显示的随机图像。Unsplash Source允许您轻松地从Unsplash请求随机图像，而无需访问官方API。您可以访问Unsplash
    Source网站以获取有关其工作原理的更多信息。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to create a new app for this recipe. Let's call this app `carousel`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个配方创建一个新的应用程序。让我们把这个应用叫做“轮播”。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start by opening `App.js` and importing dependencies:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从打开`App.js`并导入依赖项开始：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let''s define the `App` class and the initial `state` object. The `state`
    has three properties: a Boolean for whether we''re currently displaying the carousel
    or not, a `layoutType` property for setting the layout style of our carousel,
    and an array of `imageSearchTerms` we''ll use later to get images from Unsplash
    Source. Feel free to change the `imageSearchTerms` array to your heart''s content:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义 `App` 类和初始 `state` 对象。`state` 有三个属性：一个布尔值，用于指示我们当前是否正在显示轮播图，一个 `layoutType`
    属性，用于设置我们轮播图的布局样式，以及一个我们稍后将用于从 Unsplash Source 获取图像的 `imageSearchTerms` 数组。请随意更改
    `imageSearchTerms` 数组：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s define the `render` method next. We''ll just check the value of `this.state.showCorousel`
    and either show the carousel or the controls accordingly:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义 `render` 方法。我们只需检查 `this.state.showCorousel` 的值，然后相应地显示轮播图或控件：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s create the `renderControls` function. This will be the layout
    the user sees when they first open the app, and consists of a React Native `Picker`
    for selecting a layout type to use in the carousel and a button for opening the
    carousel. The `Picker` has three options available: default, tinder, and stack:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `renderControls` 函数。这将是用户在首次打开应用程序时看到的布局，包括用于在轮播图中选择布局类型的 React Native
    `Picker` 和用于打开轮播图的按钮。`Picker` 有三个可用选项：默认、tinder 和 stack：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s define the `toggleCarousel` function. This function simply sets the
    value of `showCarousel` on `state` to its opposite. By defining a toggle function,
    we can use the same function to both open and close the carousel:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义 `toggleCarousel` 函数。该函数只是将 `state` 上的 `showCarousel` 的值设置为其相反值。通过定义一个切换函数，我们可以使用相同的函数来打开和关闭轮播图：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similarly, the `updateLayoutType` method just updates the `layoutType` on `state`
    to the `layoutType` value passed into it from the `Picker` component:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，`updateLayoutType` 方法只是更新 `state` 上的 `layoutType` 到从 `Picker` 组件传入的 `layoutType`
    值：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `renderCarousel` function returns the markup for the carousel. It''s made
    up of a button for closing the carousel and the `Carousel` component itself. This
    component takes a `layout` property, as set by the `Picker`. It also has a `data` property,
    which takes the data that should be looped over for each carousel slide, and a
    `renderItem` callback that handles the rendering of each individual slide:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`renderCarousel` 函数返回轮播图的标记。它由一个用于关闭轮播图的按钮和 `Carousel` 组件本身组成。该组件接受一个 `layout`
    属性，由 `Picker` 设置。它还有一个 `data` 属性，用于接收应该循环播放每个轮播幻灯片的数据，以及一个 `renderItem` 回调函数，用于处理每个单独幻灯片的渲染：'
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We still need the function that handles the rendering of each slide. This function
    receives one object parameter containing the next item in the array passed to
    the `data` property. We''ll return an `Image` component that uses the `item` parameter
    value to get a random item from Unsplash Source that''s `350x350` in size. We''ll
    also add a `Text` element to display the type of image being displayed:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要处理每个幻灯片的渲染的函数。该函数接收一个对象参数，其中包含传递给 `data` 属性的数组中的下一个项目。我们将返回一个使用 `item`
    参数值从 Unsplash Source 获取 `350x350` 大小的随机项目的 `Image` 组件。我们还将添加一个 `Text` 元素来显示正在显示的图像类型：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last thing we''ll need is some styles to lay out our UI. The `container`
    styles apply to the main wrapping `SafeAreaView` element, so we set `justifyContent`
    to `''space-evenly''` so that the `Picker` and `TouchableOpacity` components fill
    up the screen. To display the close button in the top-right corner of the screen,
    we''ll apply `flexDirection: ''row` and `justifyContent: ''flex-end''` to the
    wrapping element. The rest of the styles are just dimensions, colors, padding,
    margins, and font size:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们需要的最后一件事是一些样式来布局我们的UI。`container`样式适用于主要包装`SafeAreaView`元素，因此我们将`justifyContent`设置为`''space-evenly''`，以便`Picker`和`TouchableOpacity`组件填满屏幕。为了在屏幕右上角显示关闭按钮，我们将`flexDirection:
    ''row`和`justifyContent: ''flex-end''`应用于包装元素。其余的样式只是尺寸、颜色、填充、边距和字体大小：'
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ve completed our carousel app. It probably won''t win any design awards,
    but it''s a working carousel app with smooth, native-feeling behavior:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的轮播应用程序。它可能不会赢得任何设计奖，但它是一个具有流畅、本地感觉行为的工作轮播应用程序：
- en: '![](assets/611a73a0-ec0a-4a09-bf88-c819dbece914.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/611a73a0-ec0a-4a09-bf88-c819dbece914.png)'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step* 4, we defined the `renderControls` function, which renders the UI
    when the app is first launched. This is the first recipe in which we've used the
    `Picker` component. It's a part of the core React Native library and provides
    the drop-down type selector used to select options in many applications. The `selectedValue`
    property is the value tied to whichever item is currently selected in the picker.
    By setting it to `this.state.layoutType`, we'll default the selection to the `'default'`
    layout, and keep the values synced when a different `Picker` item is selected.
    Each item in the picker is represented by a `Picker.Item` component. Its `label`
    property defines the display text for the item, and the `value` property represents
    the string value for the item. Since we provided the `onValueChange` property
    with the `updateLayoutType` function, it will be called whenever a new item is
    selected, which in turn will update `this.state.layoutType` accordingly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤*4中，我们定义了`renderControls`函数，该函数在应用程序首次启动时呈现UI。这是我们第一次使用`Picker`组件的示例。它是React
    Native核心库的一部分，并提供下拉类型选择器，用于在许多应用程序中选择选项。`selectedValue`属性是与选择器中当前选定项目绑定的值。通过将其设置为`this.state.layoutType`，我们将默认选择为“默认”布局，并在选择不同的`Picker`项目时保持值同步。选择器中的每个项目都由`Picker.Item`组件表示。其`label`属性定义了项目的显示文本，`value`属性表示项目的字符串值。由于我们将`onValueChange`属性与`updateLayoutType`函数一起使用，每当选择新项目时都会调用它，从而相应地更新`this.state.layoutType`。
- en: In *step* 7, we defined the JSX for the carousel. The carousel's `data` and
    `renderItem` properties are required, and work together to render each slide in
    the carousel. When the carousel is instantiated, the array passed into the `data` property
    will be looped over, and the `renderItem` callback function will be called for
    each item in the area, with that item passed into the `renderItem` as a parameter.
    We also set the `sliderWidth` and `itemWidth` properties, which are required for
    horizontal carousels.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤*7中，我们定义了轮播图的JSX。轮播图的`data`和`renderItem`属性是必需的，并且一起工作以呈现轮播图中的每个幻灯片。当实例化轮播图时，传递到`data`属性的数组将被循环处理，并且`renderItem`回调函数将针对区域中的每个项目调用，该项目作为参数传递到`renderItem`中。我们还设置了`sliderWidth`和`itemWidth`属性，这些属性对于水平轮播图是必需的。
- en: In *step 8*, we defined the `renderItem` function that gets called for each
    entry in the array passed into `data`. We set the source of the returned `Image` component
    to an Unsplash source URL, which will return a random image of the type requested.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8*中，我们定义了`renderItem`函数，该函数对传递到`data`中的数组中的每个条目调用。我们将返回的`Image`组件的源设置为Unsplash源URL，该URL将返回所请求类型的随机图像。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a few things we could do to improve this recipe. We could make use
    of the `Image.prefetch()` method to download the first image before opening the
    carousel, so that the image is ready right away, or add an input to allow the
    user to select their own image search terms.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些事情我们可以做来改进这个配方。我们可以利用`Image.prefetch()`方法在打开轮播图之前下载第一张图片，这样图片就可以立即准备好，或者添加一个输入框，允许用户选择自己的图片搜索词。
- en: The react-native-snap-carousel package provides a great way to build a multimedia
    carousel for a React Native app. There are a number of features we didn't have
    the time to cover here, including parallax images and custom pagination. For the
    adventurous developer, the package provides a way to create custom interpolations,
    allowing you to make your own layouts beyond the three built-in layouts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: react-native-snap-carousel包为React Native应用程序提供了一个很好的构建多媒体轮播图的方式。我们在这里没有时间涵盖的一些功能包括视差图片和自定义分页。对于有冒险精神的开发人员，该包提供了一种创建自定义插值的方式，使您可以创建超出三种内置布局之外的自定义布局。
- en: Adding push notifications to your app
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将推送通知添加到您的应用程序
- en: Push notifications are a great way to provide a constant feedback loop between
    the app and the user by continually providing app-specific data that's relevant
    to the user. Messaging applications send notifications when new messages arrive.
    Reminder applications display a notification to remind the user of a task at a
    specific time or location. A podcast app might use notifications to inform the
    user that a new episode has been published. A shopping app could use notifications
    to alert the user to check out a limited-time deal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是提供应用程序和用户之间持续反馈循环的一种很好的方式，不断提供与用户相关的应用程序特定数据。消息应用程序在有新消息到达时发送通知。提醒应用程序显示通知以提醒用户在特定时间或位置执行任务。播客应用程序可以使用通知通知用户新的一集已经发布。购物应用程序可以使用通知提醒用户查看限时优惠。
- en: Push notifications are a proven way to increase user interaction and retention.
    If your app makes use of time-sensitive or event-based data, push notifications
    could be a valuable asset. In this recipe, we'll be using Expo's push notification
    implementation, which simplifies some of the setup that would be required with
    a vanilla React Native project. If the needs of your app demand a non-Expo project,
    I would recommend considering the react-native-push-notification package at [https://github.com/zo0r/react-native-push-notification](https://github.com/zo0r/react-native-push-notification).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是增加用户互动和留存的一种有效方式。如果您的应用程序使用与时间敏感或基于事件的数据，推送通知可能是一项有价值的资产。在这个配方中，我们将使用Expo的推送通知实现，它简化了一些在原生React
    Native项目中所需的设置。如果您的应用程序需要非Expo项目，我建议考虑使用react-native-push-notification包 [https://github.com/zo0r/react-native-push-notification](https://github.com/zo0r/react-native-push-notification)。
- en: In this recipe, we'll be making a very simplistic messaging app with push notifications.
    We'll request proper permissions, then register a push notification token to an
    Express server we'll be building. We'll also render a `TextInput` for the user
    to enter a message into. When the Send button is pressed, the message will be
    sent to our server, and the server will send a push notification via Expo's push
    notification server, with the message from the app, to all devices that have registered
    a token with our Express server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将制作一个非常简单的消息应用程序，并添加推送通知。我们将请求适当的权限，然后将推送通知令牌注册到我们将构建的Express服务器上。我们还将渲染一个`TextInput`，让用户输入消息。当用户按下发送按钮时，消息将被发送到我们的服务器，服务器将通过Expo的推送通知服务器向所有已在我们的Express服务器上注册令牌的设备发送来自应用程序的消息的推送通知。
- en: 'Thanks to Expo''s built-in push notification service, the complicated work
    of creating a notification for each native device is offloaded to an Expo hosted
    backend. The Express server we build in this recipe will just pass off JSON objects
    for each push notification to the Expo backend, and the rest is taken care of.
    The following diagram from the Expo docs ([https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications))
    illustrates the life cycle of a push notification:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Expo内置的推送通知服务，为每个本机设备创建通知的复杂工作被转移到了Expo托管的后端。我们在这个教程中构建的Express服务器只会将每个推送通知的JSON对象传递给Expo后端，其余工作都会被处理。Expo文档中的以下图表([https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications))说明了推送通知的生命周期：
- en: '![](assets/c8f284dd-63b9-47fe-8645-0c9a31c52862.png)Image source: [https://docs.expo.io/versions/latest/guides/push-notifications/](https://docs.expo.io/versions/latest/guides/push-notifications/)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8f284dd-63b9-47fe-8645-0c9a31c52862.png)图片来源：[https://docs.expo.io/versions/latest/guides/push-notifications/](https://docs.expo.io/versions/latest/guides/push-notifications/)'
- en: While implementing push notifications using Expo is less setup work than it
    would otherwise be, the requirements of the technology still mean we will need
    to run a server for handling registrations and sending notifications, which means
    this recipe will be a little longer than most. Let's get started!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Expo实现推送通知比起其他方式少了一些设置工作，但技术的要求仍然意味着我们需要运行一个服务器来处理注册和发送通知，这意味着这个教程会比大多数教程长一些。让我们开始吧！
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: One of the first things we'll need to do in this app is request permission from
    the device to use push notifications. Unfortunately, push notification permissions
    do not work properly in emulators, so a real device will be needed to test this
    app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们需要做的第一件事是请求设备允许使用推送通知。不幸的是，推送通知权限在模拟器中无法正常工作，因此需要一个真实设备来测试这个应用程序。
- en: We'll also need to be able to access the push notification server from an address
    outside of the localhost. In a real-world setup, the push notification server
    would already have a public URL, but in a development environment, the easiest
    solution is to create a tunnel that exposes the development push notification
    server to the internet. We'll be using the ngrok tool for this purpose, since
    it is a mature, robust, and incredibly easy-to-use solution. You can read more
    about the software at [https://ngrok.com](https://ngrok.com).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够从本地主机之外的地址访问推送通知服务器。在真实环境中，推送通知服务器已经有一个公共URL，但在开发环境中，最简单的解决方案是创建一个隧道，将开发推送通知服务器暴露给互联网。为此目的，我们将使用ngrok工具，因为它是一个成熟、强大且非常易于使用的解决方案。您可以在[https://ngrok.com](https://ngrok.com)了解更多关于该软件的信息。
- en: 'First, install `ngrok` globally via `npm` using the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令通过`npm`全局安装`ngrok`：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once it''s installed, you can create a tunnel from the internet to a port on
    your local machine by executing `ngrok` with the `https` parameter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过使用`ngrok`和`https`参数在互联网和本地机器上的端口之间创建隧道：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We'll use this command later in the recipe to expose the development server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本教程中稍后使用这个命令来暴露开发服务器。
- en: 'Let''s create a new app for this recipe. We''ll call it `push-notifications`.
    We''re going to need three extra npm packages for this recipe: `express` for the
    push notification server, `esm` for using ES6 syntax support on the server, and
    `expo-server-sdk` for processing push notifications. Install them with `yarn`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个教程创建一个新的应用程序。我们将其命名为`push-notifications`。我们将需要三个额外的npm包来完成这个教程：`express`用于推送通知服务器，`esm`用于在服务器上使用ES6语法支持，`expo-server-sdk`用于处理推送通知。使用`yarn`安装它们：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, install them using `npm`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`npm`安装它们：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start with building the `App`. We''ll start that by adding the dependencies
    we need to `App.js`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从构建`App`开始。我们将通过向`App.js`添加我们需要的依赖项来开始：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''re going to declare two constants for the API endpoints on our server,
    but the `url` will be generated by `ngrok` when we run the server later in the
    recipe, so we''ll update the value of these constants at that point:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在服务器上声明两个API端点的常量，但是`url`将在教程后面运行服务器时由`ngrok`生成，因此我们将在那时更新这些常量的值：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s create the `App` component and initialize the `state` object. We''ll
    need a `notification` property to hold notifications received by the `Notifications`
    listener, which we will define in a later step:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`App`组件并初始化`state`对象。我们需要一个`notification`属性来保存`Notifications`侦听器接收到的通知，我们将在后面的步骤中定义：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s define the method that will handle registering the push notification
    token to the server. We''ll ask for notification permission from the user via
    the `askAsync` method on the `Permissions` component. If permission is granted,
    get the token from the device from the `getExpoPushTokenAsync` method of the `Notifications`
    component:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个方法来处理将推送通知令牌注册到服务器。我们将通过`Permissions`组件上的`askAsync`方法向用户请求通知权限。如果获得了权限，就从`Notifications`组件的`getExpoPushTokenAsync`方法获取设备上的令牌：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we have the appropriate token, we''ll send it over to the push notification
    server for registration. We will then make a `POST` request to `PUSH_REGISTRATION_ENDPOINT`,
    sending a `token` object and `user` object in the request body. I''ve hardcoded
    the values in the user object, but in a real app this would be the metadata you''ve
    stored for the current user:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们获得了适当的令牌，我们将将其发送到推送通知服务器进行注册。然后，我们将向`PUSH_REGISTRATION_ENDPOINT`发出`POST`请求，发送`token`对象和`user`对象到请求体中。我已经在用户对象中硬编码了值，但在真实应用中，这将是您为当前用户存储的元数据：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After the token is registered, we''ll set up an event listener to listen to
    any notifications that occur while the app is open and foregrounded. In certain
    cases, we will need to manually handle displaying the information from an incoming
    push notification. Check the *How it works...* section at the end of this recipe
    for more on why this is necessary and how it can be leveraged. We''ll define the
    handler in the next step:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册令牌后，我们将设置一个事件侦听器来监听应用程序在打开和前台运行时发生的任何通知。在某些情况下，我们需要手动处理来自传入推送通知的信息显示。查看本教程末尾的*工作原理...*部分，了解为什么需要这样做以及如何利用它。我们将在下一步中定义处理程序：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Whenever a new notification is received, the `handleNotification` method will
    be run. We''ll just store the new notification passed to this callback on the
    `state` object for later use in the `render` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当收到新通知时，`handleNotification`方法将被运行。我们将只是将传递给此回调的新通知存储在`state`对象中，以便稍后在`render`函数中使用：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We want our app to ask for permission to use push notifications, and to register
    the push notification token when the app launches. We''ll utilize the `componentDidMount`
    life cycle hook to run our `registerForPushNotificationsAsync` method:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望我们的应用程序在启动时请求使用推送通知的权限，并注册推送通知令牌。我们将利用`componentDidMount`生命周期钩子来运行我们的`registerForPushNotificationsAsync`方法：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The UI will be very minimal to keep the recipe simple. It''s made up of a `TextInput`
    for the message text, a Send button for sending the message, and a `View` for
    displaying any notifications heard by the notification listener:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UI将非常简单，以保持教程简单。它由一个用于消息文本的`TextInput`，一个用于发送消息的发送按钮，以及一个用于显示通知的`View`组成：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `TextInput` component defined in the previous step is missing the method
    it needs for its `onChangeText` property. Let''s create that method next. It just
    saves the text input by the user to `this.state.messageText` so it can be used
    by the `value` property and elsewhere:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中定义的`TextInput`组件缺少其`onChangeText`属性所需的方法。让我们接下来创建这个方法。它只是将用户输入的文本保存到`this.state.messageText`中，以便可以被`value`属性和其他地方使用。
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `TouchableOpacity` component''s `onPress` property calls the `sendMessage`
    method to send the message text when the user presses the button. In this function,
    we''ll just take the message text and `POST` it to the `MESSAGE_ENDPOINT` on our
    push notification server. The server will handle things from there. Once the message
    is sent, we''ll clear the `messageText` property on `state`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TouchableOpacity`组件的`onPress`属性调用`sendMessage`方法，在用户按下按钮时发送消息文本。在这个函数中，我们将获取消息文本并将其`POST`到我们推送通知服务器上的`MESSAGE_ENDPOINT`。服务器将处理后续操作。消息发送后，我们将清除`state`中的`messageText`属性。'
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last piece we need for the `App` is the styles. These styles are straightforward,
    and should all look quite familiar by now:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App`所需的最后一部分是样式。这些样式很简单，现在应该都很熟悉了。'
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the React Native app portion out of the way, let''s move on to the server
    portion. First, we''ll create a new `server` folder in the root of the project
    with an `index.js` file inside of it. Let''s start by importing `express` to run
    the server and `expo-server-sdk` to handle the registration and sending of push
    notifications. We''ll create an Express server app and store it in the `app` const,
    and a new instance of the Expo server SDK in the `expo` const. We''ll also add a
    `savedPushTokens` array for storing any tokens that are registered with the React
    Native app, and a `PORT_NUMBER` const for the port we want to run the server on:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native应用程序部分完成后，让我们继续进行服务器部分。首先，在项目的根目录中创建一个新的`server`文件夹，并在其中创建一个`index.js`文件。让我们首先导入`express`来运行服务器，以及`expo-server-sdk`来处理注册和发送推送通知。我们将创建一个Express服务器应用并将其存储在`app`常量中，以及一个Expo服务器SDK的新实例存储在`expo`常量中。我们还将添加一个`savedPushTokens`数组来存储在React
    Native应用中注册的任何令牌，以及一个`PORT_NUMBER`常量来指定服务器要运行的端口号。
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our server will need to expose two endpoints (one for registering tokens, and
    one for accepting messages from the React Native app), so we''ll create two functions
    that will be executed when these routes are hit. We''ll define the `saveToken`
    function first. It just takes a token, checks whether it''s stored in the `savedPushTokens`
    array, and pushes it to the array if it isn''t there already:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的服务器需要公开两个端点（一个用于注册令牌，一个用于接受来自React Native应用的消息），因此我们将创建两个函数，当命中这些路由时将执行这些函数。首先我们将定义`saveToken`函数。它只是获取一个令牌，检查它是否存储在`savedPushTokens`数组中，如果尚未存储，则将其推送到数组中。
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The other function our server needs is a handler for sending push notifications
    when a message is received from the React Native app. We''ll loop over all of
    the tokens that have been saved to the `savedPushTokens` array and create a message
    object for each token. Each message object has a title of `Message received!`,
    which will display in bold on the push notification, and the message text as the
    body of the notification:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们服务器需要的另一个函数是在接收来自React Native应用的消息时发送推送通知的处理程序。我们将遍历所有保存在`savedPushTokens`数组中的令牌，并为每个令牌创建一个消息对象。每个消息对象的标题为`收到消息！`，这将以粗体显示在推送通知中，消息文本作为通知的正文。
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once we have an array of messages, we can send them to Expo''s server, which
    in turn will send the push notification to all registered devices. We''ll send
    the messages array via the expo server''s `chunkPushNotifications` and `sendPushNotificationsAsync`
    methods, and `console.log` the success receipts, or an error, as appropriate to
    the server console. There''s more on how this works in the *How it works... *section
    at the end of this recipe:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了消息数组，我们可以将它们发送到Expo的服务器，然后Expo的服务器将把推送通知发送到所有注册设备。我们将通过expo服务器的`chunkPushNotifications`和`sendPushNotificationsAsync`方法发送消息数组，并根据情况将成功收据或错误记录到服务器控制台上。关于这个工作原理的更多信息，请参阅本教程末尾的*工作原理...*部分：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now that we have the functions defined for handling push notifications and messages,
    let's expose those functions by creating API endpoints. If you're not familiar
    with Express, it's a powerful and easy-to-use framework for running a web server
    in Node. You can quickly get up to speed on the basics of routing with the basic
    routing docs at [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了处理推送通知和消息的函数，让我们通过创建API端点来公开这些函数。如果您对Express不熟悉，它是一个在Node中运行Web服务器的强大且易于使用的框架。您可以通过基本路由文档快速了解基本路由的基础知识：[https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)。
- en: 'We''ll be working with JSON data, so the first step will be applying the JSON
    parser middleware with a call to `express.json()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JSON数据，因此第一步将是使用`express.json()`调用应用JSON解析器中间件：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Even though we won''t really be using the root path (`/`) of the server, it''s
    good practice to define one. We''ll just respond with a message that the server
    is running:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们实际上不会使用服务器的根路径(`/`)，但定义一个是个好习惯。我们将只回复一条消息，表示服务器正在运行：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, let''s implement the endpoint for saving a push notification token.
    When a `POST` request is sent to the `/token` endpoint, we''ll pass the token
    value to the `saveToken` function and return a response stating that the token
    was received:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现保存推送通知令牌的端点。当向`/token`端点发送`POST`请求时，我们将把令牌值传递给`saveToken`函数，并返回一个声明已收到令牌的响应：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Likewise, the `/message` endpoint will take the `message` from the request
    body and pass it to the `handlePushTokens` function for processing. Then, we''ll
    send back a response that the message was received:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`/message`端点将从请求体中获取`message`并将其传递给`handlePushTokens`函数进行处理。然后，我们将发送一个响应，表示已收到消息：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The last piece to the server is the call to Express''s `listen` method on the
    server instance, which will start the server:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器的最后一部分是对服务器实例调用Express的`listen`方法，这将启动服务器：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''re going to need a way to start the server, so we''ll add a custom script
    to the `package.json` file called serve. Open the `package.json` file and update
    it to have a scripts object with a new `serve` script. With this added, we can
    run the server with yarn via the `yarn run serve` command or with `npm` via the 
    command `npm run serve`. The `package.json` file should look something like this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种启动服务器的方法，因此我们将在`package.json`文件中添加一个名为serve的自定义脚本。打开`package.json`文件并更新它，使其具有一个新的`serve`脚本的scripts对象。添加了这个之后，我们可以通过`yarn
    run serve`命令或`npm run serve`命令使用yarn运行服务器或使用npm运行服务器。`package.json`文件应该看起来像这样：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ve got all the code in place, let''s use it! As mentioned previously, push
    notification permissions do not work properly on the emulator, so a real device
    will be needed to test the push notification functionality. First, we''ll fire
    up our newly created server by running the following commands:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经把所有的代码放在了一起，让我们来使用它吧！如前所述，推送通知权限在模拟器上无法正常工作，因此需要一个真实设备来测试推送通知功能。首先，我们将通过运行以下命令来启动我们新创建的服务器：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You should be greeted by the `Server Online` message we defined in the `listen`
    method call in *step 21*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会看到我们在*步骤21*中定义的`listen`方法调用中定义的`Server Online`消息：
- en: '![](assets/410ec457-c70d-469f-a885-07a9b98c66bc.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/410ec457-c70d-469f-a885-07a9b98c66bc.png)'
- en: 'Next, we''ll need to run `ngrok` to expose our server to the internet. Open
    a new Terminal window and create an `ngrok` tunnel with the following command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行`ngrok`来将我们的服务器暴露到互联网上。打开一个新的终端窗口，并使用以下命令创建一个`ngrok`隧道：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should see the `ngrok` interface in the Terminal. This displays the URLs
    generated by `ngrok`. In this case, `ngrok` is forwarding my server located at
    `http://localhost:3000` to the URL `http://ddf558bd.ngrok.io`. Let''s copy that
    URL:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中看到`ngrok`界面。这显示了`ngrok`生成的URL。在这种情况下，`ngrok`正在将我的位于`http://localhost:3000`的服务器转发到URL`http://ddf558bd.ngrok.io`。让我们复制该URL：
- en: '![](assets/bd7818a2-f122-4c7c-8107-9b599085a897.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bd7818a2-f122-4c7c-8107-9b599085a897.png)'
- en: 'You can test that the server is running and accessible from the internet by
    visiting the generated URL in a browser. Navigating directly to this URL behaves
    exactly the same as navigating to `http://localhost:3000`, which means the `GET`
    endpoint we defined in previous step should run. That function returns the Push
    Notification Server Running string, and should display in your browser:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中访问生成的URL来测试服务器是否正在运行并且可以从互联网访问。直接导航到此URL的行为与导航到`http://localhost:3000`完全相同，这意味着我们在上一步中定义的`GET`端点应该运行。该函数返回`Push
    Notification Server Running`字符串，并应在浏览器中显示：
- en: '![](assets/9261690a-6d72-4e3d-8fb6-f9295621a921.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9261690a-6d72-4e3d-8fb6-f9295621a921.png)'
- en: 'Now that we''ve confirmed that the server is running, let''s update the React
    Native app to use the correct server URL. In *step 2*, we added to constants to
    hold our API endpoints, but we didn''t have the correct URL yet. Let''s update
    these URLs to reflect the tunnel URL generated by `ngrok`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经确认服务器正在运行，让我们更新React Native应用程序以使用正确的服务器URL。在*步骤2*中，我们添加了常量来保存我们的API端点，但是我们还没有正确的URL。让我们更新这些URL以反映`ngrok`生成的隧道URL：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As mentioned previously, you''ll need to run this app on a real device for
    the permissions request to work correctly. As soon as you open the app, you should
    be prompted by the device, asking if you''d like to allow the app to send notifications:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，您需要在真实设备上运行此应用程序，以便权限请求能够正确工作。一旦您打开应用程序，设备应该会提示您是否要允许该应用程序发送通知：
- en: '![](assets/767c5400-2b08-4fdb-a32d-b8c7d958b410.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/767c5400-2b08-4fdb-a32d-b8c7d958b410.jpg)'
- en: As soon as Allow is selected, the push notification token will be sent to the
    server's `/token` endpoint to be saved. This should also print the associated
    `console.log` statement in the server Terminal with the saved token. In this case,
    my iPhone's push token is the string
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了“允许”，推送通知令牌将被发送到服务器的`/token`端点以进行保存。这也应该在服务器终端中打印出相关的`console.log`语句与保存的令牌。在这种情况下，我的iPhone的推送令牌是字符串。
- en: '`ExponentPushToken[g5sIEbOm2yFdzn5VdSSy9n]`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExponentPushToken[g5sIEbOm2yFdzn5VdSSy9n]`：'
- en: '![](assets/d7795f23-8301-4b8a-a9b2-194f92f7d37e.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d7795f23-8301-4b8a-a9b2-194f92f7d37e.png)'
- en: At this point, if you have a second Android or iOS device, go ahead and open
    the React Native app on that device as well. If not, don't worry. There's another
    easy way to test that our push notification functionality is working without using
    a second device.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，如果您有第二个Android或iOS设备，请继续在该设备上打开React Native应用程序。如果没有，不用担心。还有另一种简单的方法可以测试我们的推送通知功能是否正常工作，而无需使用第二个设备。
- en: 'You can use the React Native app''s text input to send a message to other registered
    devices.. If you''ve got a second device that has registered a token with the
    server, it should receive a push notification corresponding to the newly sent
    message. You should also see two new instances of `console.log` in the server:
    one that displays the received message, and another that displays the `receipts`
    array received back from the Expo servers. Each receipt object in the array will
    have a `status` property with the value `''ok''` if the operation was successful:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用React Native应用程序的文本输入向其他注册设备发送消息。如果您有第二个已向服务器注册令牌的设备，它应该会收到与新发送的消息相对应的推送通知。您还应该在服务器上看到两个新的`console.log`实例：一个显示接收到的消息，另一个显示从Expo服务器返回的`receipts`数组。数组中的每个receipt对象都将具有一个`status`属性，如果操作成功，则该属性的值为`'ok'`：
- en: '![](assets/edda5d92-00c3-4943-a4b3-f253ab9fe1a2.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edda5d92-00c3-4943-a4b3-f253ab9fe1a2.png)'
- en: 'If you don''t have a second device to test on, you can use Expo''s push notification
    tool, hosted at [https://expo.io/dashboard/notifications](https://expo.io/dashboard/notifications).
    Just copy the `push token` from the server Terminal and paste it into the input
    labeled EXPO PUSH TOKEN (from your app). To emulate a message sent from our React
    Native app, set MESSAGE TITLE to `Message received!`,  MESSAGE BODY to the message
    text you''d like to send, and check the Play Sound checkbox. If you like, you
    can also emulate the `data` object by providing a JSON object with a key of `"message"`
    and a value of your message text,such as `{ "message": "This is a test message."
    }`. The received message should then look something like this screenshot:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果您没有第二个设备进行测试，可以使用Expo的推送通知工具，托管在[https://expo.io/dashboard/notifications](https://expo.io/dashboard/notifications)。只需从服务器终端复制`push
    token`并将其粘贴到标有EXPO PUSH TOKEN（来自您的应用程序）的输入中。要模拟从我们的React Native应用程序发送的消息，请将MESSAGE
    TITLE设置为`Message received!`，将MESSAGE BODY设置为您想要发送的消息文本，并选中Play Sound复选框。如果愿意，还可以通过提供具有`"message"`键和您的消息文本值的JSON对象来模拟`data`对象，例如`{
    "message": "This is a test message." }`。然后接收到的消息应该看起来像这个屏幕截图：'
- en: '![](assets/02ed0e2b-79a7-4e72-a36c-8281d44c2e37.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02ed0e2b-79a7-4e72-a36c-8281d44c2e37.jpg)'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The recipe we built here is a little contrived, but the core concepts needed
    to request permissions, register tokens, accept app data, and send push notifications
    in response to app data are all there.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的配方有点牵强，但请求权限、注册令牌、接受应用程序数据以及响应应用程序数据发送推送通知所需的核心概念都在这里。
- en: 'In *step 4*, we defined the first part of the `registerForPushNotificationsAsync`
    function. We began by asking the user for their permission to send them notifications
    from our app via the `Permissions.askAsync` method, passing in the constant for
    the push notifications permission, `Permissions.NOTIFICATIONS`. We then saved
    the `status` property from the resolved `return` object, which will have the value
    `''granted''` if the user granted permission. If we don''t get permission, we `return`
    right away; otherwise, we get the token from Expo''s `Notifications` component
    by calling `getExpoPushTokenAsync`. This function returns a token string, which
    will be in the following format:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了`registerForPushNotificationsAsync`函数的第一部分。我们首先通过`Permissions.askAsync`方法询问用户是否允许我们通过`Permissions.NOTIFICATIONS`常量发送通知。然后我们保存了解析后的`return`对象的`status`属性，如果用户授予权限，则该属性的值将为`'granted'`。如果我们没有获得权限，我们将立即`return`；否则，我们通过调用`getExpoPushTokenAsync`从Expo的`Notifications`组件中获取令牌。此函数返回一个令牌字符串，格式如下：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In *step 5*, we defined the `POST` call to the server's registration endpoint
    (`/token`). This function sends the token in the request body, which is then saved
    on the server using the `saveToken` function defined in *step 14*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了对服务器注册端点（`/token`）的`POST`调用。此函数将令牌发送到请求正文中，然后使用在*步骤14*中定义的`saveToken`函数在服务器上保存。
- en: In *step 6*, we created an event listener that will listen for any new incoming
    push notifications. This is done by calling `Notifications.addListener` and passing
    in a callback function to be executed every time a new notification is received. On
    iOS devices, the system is designed to only produce a push notification if the
    app sending the push notification isn't open and foregrounded. That means if you
    try to send your user a push notification while they're currently using your app,
    they will never receive it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们创建了一个事件监听器，用于监听任何新的推送通知。这是通过调用`Notifications.addListener`并传入一个回调函数来实现的，每次接收到新通知时都会执行该函数。在iOS设备上，系统设计为仅在发送推送通知的应用程序未打开并处于前台时才产生推送通知。这意味着如果您尝试在用户当前使用您的应用程序时发送推送通知，他们将永远不会收到。
- en: To overcome this issue, Expo suggests manually displaying the push notification
    data from within your app. This `Notifications.addListener` method was created
    to fulfill this need. When a push notification is received, the callback passed
    to `addListener` will be executed and will receive the new notification object
    as a parameter. In *step 7*, we saved this notification to `state` so that the
    UI would be re-rendered accordingly. We only displayed the message text in a `Text`
    component in this recipe, but you could also use a modal for a more notification-like
    presentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Expo建议手动在应用程序内显示推送通知数据。`Notifications.addListener`方法就是为了满足这个需求而创建的。当接收到推送通知时，传递给`addListener`的回调将被执行，并将新的通知对象作为参数接收。在*步骤7*中，我们将此通知保存到`state`中，以便相应地重新渲染UI。在本教程中，我们只在`Text`组件中显示了消息文本，但您也可以使用模态框进行更类似通知的呈现。
- en: In *step 11*, we created the `sendMessage` function, which posts the message
    text stored on `state` to the server's `/message` endpoint. This will execute
    the `handlePushToken` server function defined in *step 15*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们创建了`sendMessage`函数，该函数将存储在`state`中的消息文本发布到服务器的`/message`端点。这将执行在*步骤15*中定义的`handlePushToken`服务器函数。
- en: In *step 13*, we started working on the server, which utilizes Express and the
    Expo server SDK. A new server is created with express by calling `express()` directly,
    as a local const, usually named `app` by convention. We were able to create a
    new Expo server SDK instance with `new Expo()`, storing it in the `expo` const.
    We later used the Expo server SDK to send the push notification using `expo`,
    define routes using `app` in *st**eps 17* to  *step 20*, and initiate the server
    by calling `app.listen()` in *step 22*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们开始在服务器上使用Express和Expo服务器SDK。通过直接调用`express()`创建一个新的服务器，通常按惯例将其命名为`app`。我们能够使用`new
    Expo()`创建一个新的Expo服务器SDK实例，并将其存储在`expo`常量中。稍后我们使用Expo服务器SDK使用`expo`发送推送通知，在*步骤17*到*步骤20*中使用`app`定义路由，并在*步骤22*中通过调用`app.listen()`启动服务器。
- en: In *step 14*, we defined the `saveToken` function, which will be executed when
    the `/token` endpoint is used by the React Native app to register a token. This
    function saves the incoming token to the `savedPushTokens` array, to be used later
    when a message arrives from a user. In a real app, this is where you would likely
    want to save the tokens to a persistent database of some kind, such as SQL, MongoDB,
    or Firebase Database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤14*中，我们定义了`saveToken`函数，当React Native应用程序使用`/token`端点注册令牌时将执行该函数。此函数将传入的令牌保存到`savedPushTokens`数组中，以便稍后在用户发送消息时使用。在真实的应用程序中，这通常是您希望将令牌保存到持久性数据库（如SQL、MongoDB或Firebase数据库）的地方。
- en: 'In *step 15*, we started defining the `handlePushTokens` function, which runs
    when the React Native app uses the `/message` endpoint. The function loops over
    the `savedPushTokens ` array for processing. Each token is checked for validity
    using the Expo server SDK''s `isExpoPushToken `method, which takes in a token
    and returns `true` if the token is valid. If it''s invalid, we log an error to
    the server console. If it''s valid, we push a new notification object onto the
    local `notifications` array for batch processing in the next step. Each notification
    object requires a `to` property with the value set to a valid Expo push token.
    All other properties are optional. The optional properties we set were as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤15*中，我们开始定义`handlePushTokens`函数，当React Native应用程序使用`/message`端点时运行。该函数循环处理`savedPushTokens`数组。使用Expo服务器SDK的`isExpoPushToken`方法检查每个令牌的有效性，该方法接受一个令牌并返回`true`如果令牌有效。如果无效，我们将在服务器控制台上记录错误。如果有效，我们将在下一步的批处理中将新的通知对象推送到本地`notifications`数组中。每个通知对象都需要一个`to`属性，其值设置为有效的Expo推送令牌。所有其他属性都是可选的。我们设置的可选属性如下：
- en: '**Sound**: Can be default to play the default notification sound or `null`
    for no sound'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声音**：可以默认播放默认通知声音，或者对于无声音为`null`'
- en: '**Title**: The title of the push notification, usually displayed in bold'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：推送通知的标题，通常以粗体显示'
- en: '**Body**: The body of the push notification'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：推送通知的正文'
- en: '**Data**: A custom data JSON object'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：自定义数据JSON对象'
- en: 'In *step 16*, we used the Expo server SDK''s `chunkPushNotifications` instance
    method to create an array of data chunks optimized for sending to Expo''s push
    notification server. We then looped over the chunks, and sent each chunk to Expo''s
    push notification server via the `expo.sendPushNotificationsAsync` method. It
    returned a promise that resolved to an array of receipts for each push notification.
    If the process is successful, there will be a `{ status: ''ok'' }` object for
    each notification in the array.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '在*步骤16*中，我们使用Expo服务器SDK的`chunkPushNotifications`实例方法创建了一个优化发送到Expo推送通知服务器的数据块数组。然后我们循环遍历这些块，并通过`expo.sendPushNotificationsAsync`方法将每个块发送到Expo的推送通知服务器。它返回一个解析为每个推送通知的收据数组的promise。如果过程成功，数组中将有一个`{
    status: ''ok'' }`对象。'
- en: This endpoint's behavior is simpler than a real server would probably be, because
    most message applications would have a more complicated way of handling a message.
    At the very least, there would likely be a list of recipients that would dictate
    which registered devices would in turn receive a particular push notification.
    The logic was intentionally kept simple to portray the basic flow.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点的行为比真实服务器可能要简单，因为大多数消息应用程序处理消息的方式可能更复杂。至少，可能会有一个接收者列表，指定注册设备将接收特定推送通知。逻辑被故意保持简单，以描绘基本流程。
- en: In *step 18*, we defined the first accessible route on our server, the root
    (`/`) path. Express provides the `get` and `post` helper methods for easily making
    API endpoints for `GET` and `POST` requests respectively. The callback function
    receives a request object and response object as parameters. All server URLs need
    to respond to the request; otherwise, the request would time out. The response
    is sent via the `send` method on the response object. This route doesn't process
    any data, so we just returned the string indicating that our server is running.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤18*中，我们在服务器上定义了第一个可访问的路由，即根（`/`）路径。Express提供了`get`和`post`辅助方法，用于轻松地创建`GET`和`POST`请求的API端点。回调函数接收请求对象和响应对象作为参数。所有服务器URL都需要响应请求；否则，请求将超时。响应通过响应对象上的`send`方法发送。这个路由不处理任何数据，所以我们只返回指示我们的服务器正在运行的字符串。
- en: In *step 19* and *step 20*, we defined `POST` endpoints for `/token` and `/message`,
    which will execute `saveToken` and `handlePushTokens` respectively. We also added
    `console.log` statements to each, to log the token and the message to the server
    Terminal for ease of development.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤19*和*步骤20*中，我们为`/token`和`/message`定义了`POST`端点，分别执行`saveToken`和`handlePushTokens`。我们还在每个端点中添加了`console.log`语句，以便在服务器终端上记录令牌和消息，便于开发。
- en: In *step 21*, we defined the `listen` method on our Express server, which starts
    the server. The first parameter is the port number to listen for requests on,
    and the second parameter is a callback function, usually used to `console.log`
    a message to the server Terminal that the server has been started.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤21*中，我们在Express服务器上定义了`listen`方法，启动了服务器。第一个参数是要监听请求的端口号，第二个参数是回调函数，通常用于在服务器终端上`console.log`一条消息，表示服务器已启动。
- en: 'In *step 22*, we added a custom script to the `package.json` file of our project.
    Any command that can be run in the Terminal can be made a custom npm script by
    adding a `scripts` key to the `package.json` file set to an object whose keys
    are the name of the custom script, and whose values are the command that should
    be executed when that custom script is run. In this recipe, we defined a custom
    scripted named `serve` that runs the `node -r esm server/index.js `command. This
    command runs our server file (`server/index.js`) with Node, using the `esm` npm
    package we installed at the beginning of this recipe. Custom scripts can be executed
    with `npm`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤22*中，我们在项目的`package.json`文件中添加了一个自定义脚本。可以通过在`package.json`文件中添加一个`scripts`键，将可以在终端中运行的任何命令设置为自定义npm脚本，其键是自定义脚本的名称，值是运行该自定义脚本时应执行的命令。在这个示例中，我们定义了一个名为`serve`的自定义脚本，运行`node
    -r esm server/index.js`命令。这个命令使用我们在本示例开始时安装的`esm` npm包在Node中运行我们的服务器文件（`server/index.js`）。自定义脚本可以使用`npm`执行：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'They can also be executed using `yarn`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`yarn`执行：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There's more...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Push notifications can be complicated, but thankfully Expo simplifies the process
    in a number of ways. There's great documentation on Expo's push notification service,
    which covers the specifics of notification timing, Expo server SDKs in other languages,
    and how to implement notifications over HTTP/2\. I encourage you to read more
    at [https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知可能会很复杂，但幸运的是，Expo以多种方式简化了这个过程。Expo的推送通知服务有很好的文档，涵盖了通知定时、其他语言中的Expo服务器SDK以及如何通过HTTP/2实现通知的具体内容。我鼓励你在[https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications)上阅读更多。
- en: Implementing browser-based authentication
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于浏览器的身份验证
- en: In the *Logging in with Facebook *recipe in [Chapter 8](b41f8c20-f817-4b29-992b-18f8bcd6f071.xhtml), *Working
    with Application Logic and Data*, we will cover using the Expo `Facebook` component
    to create a login workflow for providing our app with the user's basic Facebook
    account information. Expo also provides a `Google` component, which provides similar
    functionality for getting a user's Google account information. But what do we
    do if we want to create a login workflow that uses account information from a
    different site? In this case, Expo provides the `AuthSession` component.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](b41f8c20-f817-4b29-992b-18f8bcd6f071.xhtml)的*使用Facebook登录*示例中，我们将介绍使用Expo的`Facebook`组件创建登录工作流程，以提供用户的基本Facebook账户信息给我们的应用程序。Expo还提供了一个`Google`组件，用于获取用户的Google账户信息的类似功能。但是，如果我们想要创建一个使用来自不同网站的账户信息的登录工作流程，我们该怎么办呢？在这种情况下，Expo提供了`AuthSession`组件。
- en: '`AuthSession` is built on Expo''s `WebBrowser` component, which we''ve already
    used in [Chapter 4](c6579db8-eca6-469d-8134-6e3c64b5c2fa.xhtml), *Implementing
    Complex User Interfaces – Part II*. The typical login workflow consists of four
    steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthSession` 是建立在 Expo 的 `WebBrowser` 组件之上的，我们在[第 4 章](c6579db8-eca6-469d-8134-6e3c64b5c2fa.xhtml)
    *实现复杂用户界面 - 第二部分* 中已经使用过。典型的登录流程包括四个步骤：'
- en: The user initiates the login process
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户启动登录流程
- en: The web browser opens to the login page
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网页浏览器打开到登录页面
- en: The authentication provider provides a redirect on successful login
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证提供程序在成功登录时提供重定向
- en: The React Native app handles the redirect
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native 应用程序处理重定向
- en: In this app, we'll be using the Spotify API to get Spotify account information
    for our app via user login. Head over to [https://beta.developer.spotify.com/dashboard/applications](https://beta.developer.spotify.com/dashboard/applications) to
    create a new Spotify dev account (if you don't already have one) and a new app.
    The app can be named whatever you like. Once the app is created with Spotify,
    you'll see a client ID string displayed in the information for your app. We'll
    need this ID when building the React Native app.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将使用 Spotify API 通过用户登录来获取我们应用程序的 Spotify 账户信息。前往 [https://beta.developer.spotify.com/dashboard/applications](https://beta.developer.spotify.com/dashboard/applications)
    创建一个新的 Spotify 开发者账户（如果你还没有），以及一个新的应用。应用可以取任何你喜欢的名字。创建完应用后，你会在应用信息中看到一个客户端 ID
    字符串。在构建 React Native 应用程序时，我们将需要这个 ID。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will need a new app for this recipe. Let's name the app `browser-based-auth`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新的应用程序来完成这个教程。让我们将应用命名为 `browser-based-auth`。
- en: The redirect URI also needs to be whitelisted in the Spotify app we created
    previously. The redirect should be in the form of `https://auth.expo.io/@YOUR_EXPO_USERNAME/YOUR_APP_SLUG`.
    Since my Expo username is `warlyware`, and since this React Native app we're building
    is named `browser-based-auth`, my redirect URI is `https://auth.expo.io/@warlyware/browser-based-auth`.
    Be sure to add this to the Redirect URIs list in the settings of the Spotify app.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向 URI 也需要在之前创建的 Spotify 应用中列入白名单。重定向应该是 `https://auth.expo.io/@YOUR_EXPO_USERNAME/YOUR_APP_SLUG`
    的形式。由于我的 Expo 用户名是 `warlyware`，并且由于我们正在构建的这个 React Native 应用程序名为 `browser-based-auth`，我的重定向
    URI 是 `https://auth.expo.io/@warlyware/browser-based-auth`。请确保将其添加到 Spotify 应用的设置中的重定向
    URI 列表中。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start by opening `App.js` and importing the dependencies we will be
    using:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从打开 `App.js` 并导入我们将要使用的依赖项开始。
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s also declare the `CLIENT_ID` as a constant to be used later. Copy the
    client ID for the Spotify app we created previously so that we can save it in
    the `CLIENT_ID` const:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也声明 `CLIENT_ID` 为一个常量，以便以后使用。复制之前创建的 Spotify 应用的客户端 ID，以便我们可以将其保存在 `CLIENT_ID`
    常量中：
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s create the `App` class and the initial `state`. The `userInfo` property
    will hold the user information we receive back from the Spotify API, and `didError`
    is a Boolean for tracking whether an error occurred during login:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建 `App` 类和初始 `state`。`userInfo` 属性将保存我们从 Spotify API 收到的用户信息，`didError`
    是一个布尔值，用于跟踪登录过程中是否发生错误：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, let''s define the method that logs the user in to Spotify. The `AuthSession`
    component''s `getRedirectUrl` method provides the redirect URL needed for returning
    to the React Native app after login, which is the same redirect URI we saved in
    the Spotify app in the *Getting ready* section of this recipe. We''ll then use
    the redirect URL in the login request, which we''ll launch with the `AuthSession.startAsync`
    method, passing in an options object with the `authUrl` property set to the Spotify
    endpoint for authorizing user data with an app. There''s more information on this
    URL in the *How it works... *section at the end of this recipe:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义将用户登录到Spotify的方法。 `AuthSession`组件的`getRedirectUrl`方法提供了在登录后返回到React
    Native应用程序所需的重定向URL，这是我们在本示例的*准备就绪*部分中保存在Spotify应用程序中的相同重定向URI。 然后，我们将在登录请求中使用重定向URL，我们将使用`AuthSession.startAsync`方法启动登录请求，传入一个选项对象，其中`authUrl`属性设置为用于授权用户数据的Spotify端点。
    有关此URL的更多信息，请参阅本示例末尾的*它是如何工作...*部分：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We saved the results of hitting the Spotify endpoint for user authentication
    in the local `results `variable. If the `type` property on the results object
    returns anything other than `''success''`, then an error occurred, so we''ll update
    the `didError` property of `state` accordingly. Otherwise, we''ll hit the `/me`
    endpoint with the access token we received from authorization to get the user''s
    info, which we''ll save to `this.state.userInfo`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将点击Spotify端点以进行用户身份验证的结果保存在本地`results`变量中。 如果结果对象上的`type`属性返回的不是“success”，那么就会发生错误，因此我们将相应地更新`state`的`didError`属性。
    否则，我们将使用从授权接收到的访问令牌点击`/me`端点以获取用户信息，然后将其保存到`this.state.userInfo`中：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now that the `auth` related methods are defined, let''s create the `render`
    function. We''ll use the `FontAwesome` Expo icon library to display the Spotify
    logo, add a button to allow the user to log in, and add methods for rendering
    either an error or the user info, depending on the value of `this.state.didError`.
    We''ll also disable the login button once there''s data saved on the `userInfo`
    property of `state`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`auth`相关的方法已经定义，让我们创建`render`函数。 我们将使用`FontAwesome` Expo图标库来显示Spotify标志，添加一个按钮允许用户登录，并添加渲染错误或用户信息的方法，具体取决于`this.state.didError`的值。
    一旦在`state`的`userInfo`属性上保存了数据，我们还将禁用登录按钮：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, let''s define the JSX for handling errors. The template just displays
    a generic error message to indicate that the user should try again:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义处理错误的JSX。 模板只是显示一个通用的错误消息，表示用户应该再试一次：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `displayResults` function will be a `View` component that displays the
    user''s image, username, and email address if there is `userInfo` saved to `state`,
    otherwise it will prompt the user to log in:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`displayResults`函数将是一个`View`组件，如果`state`中保存了`userInfo`，则显示用户的图像，用户名和电子邮件地址，否则它将提示用户登录：'
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The styles for this recipe are quite simple. It uses a column flex layout,
    applies the Spotify color scheme of black and green, and adds font sizes and margins:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例的样式非常简单。 它使用了列式弹性布局，应用了Spotify的黑色和绿色配色方案，并添加了字体大小和边距：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, if we look at the app, we should be able to log in to Spotify, and see
    the associated image, username, and email address for the account used to log
    in:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们查看应用程序，我们应该能够登录到Spotify，并看到与用于登录的帐户关联的图像，用户名和电子邮件地址：
- en: '![](assets/5d4f47b5-36b9-4733-87ff-2fa6f8554563.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d4f47b5-36b9-4733-87ff-2fa6f8554563.png)'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 4*, we created the method for handling the Spotify login process. The
    `AuthSession.startAsync` method just needed an `authUrl`, which was provided by
    the Spotify Developers documentation. The four pieces required are the `Client-ID`,
    the redirect URI for handling the response from Spotify, a `scope` parameter indicating
    the scope of user information the app is requesting, and a `response_type` parameter
    of `token`. We only need basic information from the user, so we requested a scope
    type of `user-read-email`. For information on all the scopes available, check
    the documentation at [https://beta.developer.spotify.com/documentation/general/guides/scopes/](https://beta.developer.spotify.com/documentation/general/guides/scopes/).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们创建了处理Spotify登录过程的方法。`AuthSession.startAsync`方法只需要一个`authUrl`，这是由Spotify开发者文档提供的。所需的四个部分是`Client-ID`，用于处理来自Spotify的响应的重定向URI，指示应用程序请求的用户信息范围的`scope`参数，以及`response_type`参数为`token`。我们只需要用户的基本信息，因此我们请求了`user-read-email`的范围类型。有关所有可用范围的信息，请查看[https://beta.developer.spotify.com/documentation/general/guides/scopes/](https://beta.developer.spotify.com/documentation/general/guides/scopes/)上的文档。
- en: In *step 5*, we completed the Spotify login handler. If the login was not successful,
    we updated `didError` on `state` accordingly. If it was successful, we used that
    response to access the Spotify API endpoint for getting user data ([https://api.spotify.com/v1/me](https://api.spotify.com/v1/me)).
    We defined the `Authorization` header of the `GET` request with `Bearer ${results.params.access_token}`
    to validate the request, as per Spotify's documentation. On the success of this
    request, we stored the returned user data in the `userInfo` `state` object, which
    re-rendered the UI and displayed the user's information.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们完成了Spotify登录处理程序。如果登录不成功，我们相应地更新了`state`上的`didError`。如果成功，我们使用该响应访问Spotify
    API端点以获取用户数据（[https://api.spotify.com/v1/me](https://api.spotify.com/v1/me)）。我们根据Spotify的文档，使用`Bearer
    ${results.params.access_token}`定义了`GET`请求的`Authorization`标头来验证请求。在此请求成功后，我们将返回的用户数据存储在`userInfo`
    `state`对象中，这将重新呈现UI并显示用户信息。
- en: For a deeper dive into Spotify's auth process, you can find the guide at [https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/](https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解Spotify的认证过程，您可以在[https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/](https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/)找到指南。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Expo Permissions docs: [https://docs.expo.io/versions/latest/sdk/permissions](https://docs.expo.io/versions/latest/sdk/permissions)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo权限文档：[https://docs.expo.io/versions/latest/sdk/permissions](https://docs.expo.io/versions/latest/sdk/permissions)
- en: Expo `MapView` docs: [https://docs.expo.io/versions/latest/sdk/map-view](https://docs.expo.io/versions/latest/sdk/map-view)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo `MapView`文档：[https://docs.expo.io/versions/latest/sdk/map-view](https://docs.expo.io/versions/latest/sdk/map-view)
- en: Airbnb's React Native Maps package: [https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Airbnb的React Native Maps包：[https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)
- en: Expo Audio docs: [https://docs.expo.io/versions/latest/sdk/audio](https://docs.expo.io/versions/latest/sdk/audio)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo音频文档：[https://docs.expo.io/versions/latest/sdk/audio](https://docs.expo.io/versions/latest/sdk/audio)
- en: React Native Image Prefetch docs: [https://facebook.github.io/react-native/docs/image.html#prefetch](https://facebook.github.io/react-native/docs/image.html#prefetch)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native Image Prefetch文档：[https://facebook.github.io/react-native/docs/image.html#prefetch](https://facebook.github.io/react-native/docs/image.html#prefetch)
- en: React Native Snap Carousel Custom Interpolations docs: [https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native Snap Carousel自定义插值文档：[https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md)
- en: Expo Push Notifications docs: [https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo推送通知文档：[https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications)
- en: Express Basic Routing guide: [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express基本路由指南：[https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)
- en: esm package: [https://github.com/standard-things/esm](https://github.com/standard-things/esm)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: esm软件包：[https://github.com/standard-things/esm](https://github.com/standard-things/esm)
- en: Expo server SDK for Node: [https://github.com/expo/exponent-server-sdk-node](https://github.com/expo/exponent-server-sdk-node)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于Node的Expo服务器SDK：[https://github.com/expo/exponent-server-sdk-node](https://github.com/expo/exponent-server-sdk-node)
- en: ngrok package: [https://github.com/inconshreveable/ngrok](https://github.com/inconshreveable/ngrok)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ngrok软件包：[https://github.com/inconshreveable/ngrok](https://github.com/inconshreveable/ngrok)
