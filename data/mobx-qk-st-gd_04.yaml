- en: Crafting the Observable Tree
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可观察树
- en: 'Defining the reactive model of your application is usually the first step when
    working with MobX and React. We know very well that this is all in the realm of
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序的响应模型通常是使用MobX和React时的第一步。我们非常清楚，这都属于以下领域：
- en: Observables, which represent the application state
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables, which represent the application state
- en: Actions, which mutate it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作，改变它
- en: Reactions, which produce side effects by observing the changing observables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactions, which produce side effects by observing the changing observables
- en: When defining the observable state, MobX gives you various tools to carefully
    control observability. In this chapter, we will explore this side of MobX and
    take a deeper look at *crafting the observable tree*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义可观察状态时，MobX为您提供了各种工具来精确控制可观察性。在本章中，我们将探讨MobX的这一方面，并深入研究*创建可观察树*。
- en: 'The topics that will be covered in this chapter are the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The shape of data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的形状
- en: Controlling observability with various decorators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种装饰器控制可观察性
- en: Creating computed properties
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计算属性
- en: Modeling MobX stores with classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类建模MobX存储
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要掌握JavaScript编程语言。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter04](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter04)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter04](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter04)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2uYmln9](http://bit.ly/2uYmln9)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2uYmln9](http://bit.ly/2uYmln9)'
- en: The shape of data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据的形状
- en: 'The data that we deal with within an application comes in all shapes and sizes.
    However, these different shapes are fairly limited and can be listed as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中处理的数据以各种形状和大小出现。然而，这些不同的形状相当有限，可以列举如下：
- en: '**Singular values**: These include primitives like numbers, booleans, strings,
    null, undefined, dates, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Singular values**: These include primitives like numbers, booleans, strings,
    null, undefined, dates, and so on.'
- en: '**Lists**: Your typical list of items where each item is one of a kind. It
    is generally a good practice to avoid putting items of different data types in
    the same list. This creates homogenous lists which are easy to reason about.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**: 您典型的项目列表，其中每个项目都是独一无二的。通常最好避免将不同数据类型的项目放在同一个列表中。这样可以创建易于理解的同质列表。'
- en: '**Hierarchy**: Many of the structures we see in UI are hierarchical, like a
    hierarchy of files and f0lders, parent-child relationships, groups and items,
    and so on.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**: 我们在UI中看到的许多结构都是分层的，比如文件和文件夹的层次结构，父子关系，组和项目等等。'
- en: '**Composite**: A combination of some or all of the preceding shapes. Most real
    world data is in this form.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**: 一些或所有前述形状的组合。大多数现实世界的数据都是这种形式。'
- en: MobX gives us the API to model each of these shapes and we have already seen
    some examples of this in earlier chapters. However, MobX makes one distinction
    between singular values and other kinds like arrays and maps. This is reflected
    in the API as well, where `observable()` can *only* be used to create objects,
    arrays, and maps. Creating an observable out of a singular value requires us to
    box it with the `observable.box()` API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MobX给了我们API来模拟每个形状，我们已经在之前的章节中看到了一些例子。然而，MobX在单一值和其他类型（如数组和映射）之间做了一个区分。这也反映在API中，`observable()`只能用来创建对象、数组和映射。将单一值创建为observable需要我们使用`observable.box()`API来包装它。
- en: Controlling observability
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制可观察性
- en: MobX, by default, applies deep observability on your objects, arrays, and maps.
    This allows you to see changes happening at any level in the observable tree.
    Although this a great default to start with, at some point, you will have to pay
    more attention to limit the observability. Cutting down on the observability also
    improves performance as there are fewer things to track from the point of view
    of MobX.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MobX对您的对象、数组和映射应用深度可观察性。这使您可以看到可观察树中任何级别的变化。虽然这是一个很好的默认值，但在某些时候，您将不得不更加关注限制可观察性。减少可观察性也可以提高性能，因为MobX需要跟踪的内容更少。
- en: 'There are two distinct ways in which you can control observability:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方式可以控制可观察性：
- en: By using the various `@decorators` inside classes
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在类内部使用各种`@decorators`
- en: By using the `decorate()` API
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`decorate()` API
- en: Using @decorators
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@decorators
- en: 'Decorators are a syntactic feature that allow you to attach behavior to a class
    and its fields. We have already seen this in [Chapter 3](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070),
    *A React App with MobX*, so the following code should be very familiar:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种语法特性，允许您将行为附加到类及其字段上。我们已经在[第3章](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070)中看到了这一点，*使用MobX创建React应用*，因此以下代码应该非常熟悉：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the `@observable` decorator, you can make properties of a class into observables.
    This is the recommended approach to start modeling your observables. By default, `@observable`
    applies deep observability, but there are some specialized decorators that give
    you more control.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@observable`装饰器，您可以将类的属性变成可观察的。这是开始建模可观察对象的推荐方法。默认情况下，`@observable`应用深度可观察性，但还有一些专门的装饰器可以让您更好地控制。
- en: '`@observable` is a shorter form or an alias of `@observable.deep`, which is
    the default decorator. It applies *deep observability* at all levels of objects,
    arrays, and maps. However, the deep observation stops at places where the object
    has a *constructor or a prototype*. Such objects are usually instances of classes
    and are expected to have their own *observable properties*. MobX chooses to skip
    such objects during deep observation.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`@observable`是`@observable.deep`的缩写形式或别名，这是默认的装饰器。它在对象、数组和映射的所有级别上应用*深度可观察性*。然而，深度观察在对象具有*构造函数或原型*的地方停止。这样的对象通常是类的实例，并且预计具有自己的*可观察属性*。MobX选择在深度观察期间跳过这样的对象。'
- en: Creating shallow observables with @observable.shallow
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@observable.shallow创建浅观察对象
- en: This decorator prunes the observability to just the first level of the data,
    also called **one-level-deep** observation, and is particularly useful for observable
    arrays and maps. In the case of arrays, it will monitor a reference change (for
    example, assigning a new array) of the array itself, and the addition and removal
    of items in the array. If you have items in the array that have properties, they
    would not be considered in the shallow observation. Similarly, for maps, only
    the addition and removal of keys is considered, along with the reference change
    of the map itself. Values of the keys in the observable map are left as-is and
    not considered for observation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器将可观察性修剪到数据的第一层，也称为**一级深度**观察，对于可观察数组和映射特别有用。对于数组，它将监视数组本身的引用更改（例如，分配一个新数组），以及数组中项目的添加和删除。如果数组中有具有属性的项目，则这些属性不会被视为浅观察。同样，对于映射，只考虑键的添加和删除，以及映射本身的引用更改。可观察映射中键的值保持不变，不被视为观察对象。
- en: The following snippet shows the application of the `@observable.shallow` decorator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`@observable.shallow`装饰器的应用。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We chose to apply this decorator to the `results` property of the `BookSearchStore`.
    It is clear that that we are not particularly observing the properties of each
    individual result. In fact, they are read only objects that will never change
    values, so it makes sense that we prune the observability to just the addition
    and removal of items, and reference changes in the `results` array. Thus, `observable.shallow`
    is the right choice here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择将这个装饰器应用到`BookSearchStore`的`results`属性上。很明显，我们并不特别观察每个单独结果的属性。事实上，它们是只读对象，永远不会改变值，因此我们只需要将可观察性修剪到项目的添加和移除以及`results`数组中的引用更改。因此，`observable.shallow`在这里是正确的选择。
- en: A subtle point to remember here is that the `length` property of the array (`size`,
    in the case of maps) is also observable. Can you figure out why it is observable?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的一个微妙的点是数组的`length`属性（在地图的情况下是`size`）也是可观察的。你能想出它为什么是可观察的吗？
- en: Creating reference-only observables with @observable.ref
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@observable.ref创建仅引用的可观察对象
- en: If you are *not* interested in any changes happening inside a data structure
    (object, array, map) and only in the *change in value*, `@observable.ref` is what
    you are looking for. It will only monitor reference changes to the observable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您*不*对数据结构（对象、数组、地图）内发生的任何更改感兴趣，而只对*值的更改*感兴趣，那么`@observable.ref`就是您要找的东西。它只会监视可观察对象的引用更改。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the `validations` observable is always assigned a
    new value. Since we are never modifying the properties of this object, it is better
    to mark it as `@observable.ref`. This way, we only track reference changes to
    `validations` and nothing else.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`validations`可观察性总是被分配一个新值。由于我们从未修改此对象的属性，最好将其标记为`@observable.ref`。这样，我们只跟踪`validations`的引用更改，而不跟踪其他任何东西。
- en: Creating structural observables with @observable.struct
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@observable.struct创建结构可观察对象
- en: MobX has a built-in behavior to track changes in values and works well for primitives
    like strings, numbers, booleans, and so on. However, it becomes less than ideal
    when dealing with *objects*. Every time a new object is assigned to the observable,
    it will be considered as a change, and reactions will fire. What you really need
    is a *structural check* where the *properties* of your object are compared instead
    of the *object reference,* and then decide if there is a change. That is the purpose
    of `@observable.struct`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MobX具有内置行为来跟踪值的更改，并且对于诸如字符串、数字、布尔值等基元类型非常有效。但是，在处理*对象*时，它变得不太理想。每当将新对象分配给可观察对象时，它都将被视为更改，并且反应将触发。您真正需要的是*结构检查*，其中比较对象的*属性*而不是*对象引用*，然后决定是否有更改。这就是`@observable.struct`的目的。
- en: It does a deep comparison based on *property values* rather then relying on
    the top-level reference. You can think of this as a refinement over the `observable.ref`
    decorator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于*属性值*进行深度比较，而不是依赖顶层引用。您可以将其视为对`observable.ref`装饰器的改进。
- en: 'Let''s look at the following code, where we create an `@observable.struct`
    for the `location` property:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码，我们为`location`属性创建一个`@observable.struct`：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that `autorun()` fires once immediately and then does not react to the
    next location (`{ x: 0, y: 0}`). Since the structural value is the same `(0, 0)`,
    it is not treated as a change and hence no notifications are fired. It''s only
    when we set the location to a different `(x, y)` value that `autorun()` is triggered.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`autorun()`立即触发一次，然后不会对下一个位置（`{ x: 0, y: 0}`）做出反应。由于结构值相同（0, 0），它不被视为更改，因此不会触发通知。只有当我们将位置设置为不同的（x,
    y）值时，`autorun()`才会被触发。'
- en: 'We can now represent the level of observability of the decorators, as in the
    following diagram. `@observable` (in this case, `@observable.deep`) is the most
    powerful, followed by `@observable.shallow`, `@observable.ref`, and finally `@observable.struct`.
    As you get more fine-grained with the observable decorators, you can prune the
    surface area to track in the observable tree. This is shown with the orange-colored
    shapes. The more observables there are, the greater the tracking area is for MobX:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以表示装饰器的可观察性级别，如下图所示。`@observable`（在这种情况下，`@observable.deep`）是最强大的，其次是`@observable.shallow`，`@observable.ref`，最后是`@observable.struct`。随着可观察装饰器的细化，您可以修剪可观察树中的表面积。这用橙色形状表示。可观察的越多，MobX的跟踪区域就越大：
- en: '![](../images/00023.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: Using the decorate() API
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用decorate() API
- en: The use of `@decorators` is definitely very convenient and readable, but it
    does require some setup with Babel (using *babel-plugin-transform-decorators-legacy*)
    or turning on the `experimentalDecorators` flag in the compiler options for TypeScript.
    With version 4, MobX introduced an *ES5* API for decorating the observable properties
    of an object or class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@decorators`绝对非常方便和可读，但它确实需要一些Babel设置（使用*babel-plugin-transform-decorators-legacy*）或在TypeScript的编译器选项中打开`experimentalDecorators`标志。MobX在版本4中引入了用于装饰对象或类的可观察属性的*ES5*
    API。
- en: 'Using the `decorate()` API, you can selectively target properties and specify
    the observability. The following code snippet should make this clear:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`decorate()` API，您可以有选择地针对属性并指定可观察性。以下代码片段应该可以说明这一点：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `target` can be an object prototype or a class type. The second argument
    is an object containing the target properties that you want to decorate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`可以是对象原型或类类型。第二个参数是一个包含要装饰的目标属性的对象。'
- en: In the preceding example, notice the way that we are applying the decorators
    to the class type. From a developer standpoint, it feels natural to use them when
    you don't have the syntax support of `@decorators`. In fact, the `decorate()`
    API can also be used for other kinds of decorators such as `action`, `action.bound`,
    and `computed`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意我们将装饰器应用于类类型的方式。从开发人员的角度来看，在没有`@decorators`语法支持时使用它们感觉很自然。事实上，`decorate()`
    API也可以用于其他类型的装饰器，如`action`，`action.bound`和`computed`。
- en: Decorating with observable()
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用observable()进行装饰
- en: The `decorate()` style of the API also works when declaring observables using
    the `observable()` API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`decorate()` API时，声明可观察性也适用于`observable()` API。
- en: '`observable(properties, decorators, options)`:Its arguments are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable(properties, decorators, options)`:它的参数如下：'
- en: '`properties`*:* Declare the properties of the observable object'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`properties`*:* 声明可观察对象的属性'
- en: '`decorators`: An object defining the decorators for the properties'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decorators`: 定义属性装饰器的对象'
- en: '`options`: Options for setting default observability and a debug-friendly name
    (`{ deep: false|true, name: string }`)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`: 用于设置默认可观察性和调试友好名称的选项 (`{ deep: false|true, name: string }`)'
- en: 'The second argument to `observable()` is where you specify the decorators for
    various properties in your object. This works exactly like the `decorate()` call,
    as can be seen in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable()`的第二个参数是您在对象中为各种属性指定装饰器的地方。这与`decorate()`调用的工作方式完全相同，如下面的代码片段所示：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the second argument, we have applied the various decorators to control the
    *observability*, apply *actions,* and mark *computed properties*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个参数中，我们已经应用了各种装饰器来控制*可观察性*，应用*操作*，并标记*计算属性*。
- en: When using the `observable()` API, it is not required to mark the computed properties
    explicitly. MobX will convert any `getter` property of the passed in object into
    a computed property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`observable()`API时，不需要显式标记计算属性。MobX将把传入对象的任何`getter`属性转换为计算属性。
- en: Similarly, for the `modified` property, there is actually no need to decorate
    since `observable()` by default makes everything deeply observable. We only have
    to specify the properties that need a different treatment. In other words, only
    specify decorators for the exceptional properties.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`modified`属性，实际上没有必要进行装饰，因为`observable()`默认会使所有内容深度可观察。我们只需要指定需要不同处理的属性。换句话说，只为特殊属性指定装饰器。
- en: Extending the observability
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展可观察性
- en: When modeling the client state, it is best to pre-define the observability we
    need in our reactive system. This bakes in all the constraints and scope of the
    observable data in your domain. However, the real world is always unforgiving
    and there will be times where you need runtime abilities to extend the observability.
    This is where the `extendObservable()` API comes in. It allows you to mix in additional
    properties at runtime and make them observable as well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模客户端状态时，最好预先定义我们在响应式系统中需要的可观察性。这样可以将领域中的可观察数据的所有约束和范围都固定下来。然而，现实世界总是不可饶恕的，有时您需要在运行时扩展可观察性。这就是`extendObservable()`API的用武之地。它允许您在运行时混入额外的属性，并使它们也可观察。
- en: 'In the following example, we are extending the observability of the `cart` for
    festive offers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们正在扩展`cart`的可观察性以适应节日优惠：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *first* argument to `extendObservable()` is the target object that we want
    to extend. The second argument is the list of observable properties and actions
    that will be mixed into the target object. The third argument is the list of decorators
    that will be applied to the properties.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`extendObservable()`的*第一个*参数是我们要扩展的目标对象。第二个参数是将混入目标对象的可观察属性和操作的列表。第三个参数是将应用于属性的装饰器的列表。'
- en: In the preceding example, we want to add more observables to the **cart** for
    tracking festive offers. This can only be done at runtime based on an active festive
    season. The `applyFestiveOffers()` function is called when that condition is met.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们想要为**购物车**添加更多可观察的内容，以跟踪节日优惠。这只能在运行时根据活动的节日季节来完成。当满足条件时，将调用`applyFestiveOffers()`函数。
- en: '`extendObservable()` is in fact the superset of `observable()`, and`observable.object()`. `observable()`
    is really `extendObservable({}, object)`. It is no coincidence that this looks
    similar to `decorate()`. MobX strives to keep the API consistent and intuitive.
    While `extendObservable()` takes an actual object in its first argument, `decorate()`
    requires it to be classes and object prototypes.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`extendObservable()`实际上是`observable()`和`observable.object()`的超集。`observable()`实际上是`extendObservable({},
    object)`。这看起来与`decorate()`相似并非巧合。MobX努力保持API一致和直观。虽然`extendObservable()`的第一个参数是实际对象，但`decorate()`要求它是类和对象原型。'
- en: '*[Fun Fact]* Before the introduction of `decorate()`, `extendObservable()`
    was used to extend `this` inside the *class constructor*: `extendObservable(this,
    { })`. Of course, now the recommended approach is to use `decorate()`, which can
    be applied directly on a class or object prototype.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*[趣闻]*在引入`decorate()`之前，`extendObservable()`被用来在*类构造函数*内部扩展`this`：`extendObservable(this,
    { })`。当然，现在推荐的方法是使用`decorate()`，它可以直接应用于类或对象原型。'
- en: One point to ponder on is that an *observable Map* could also be used to add
    observable properties on the fly. However, they can only be *state carrying* properties
    and not *actions* or *computed-properties*. When you want to dynamically add *actions*
    and *computed properties* as well, go for `extendObservable()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值得思考的一点是，*observable Map*也可以用于动态添加可观察属性。但是，它们只能是*状态承载*属性，而不是*操作*或*计算属性*。当您想要动态添加*操作*和*计算属性*时，可以使用`extendObservable()`。
- en: Derived state with @computed
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@computed派生状态
- en: One of the core philosophies of MobX is that the observable state should be
    as minimal as possible. Everything else should be ***derived*** via computed properties.
    This perspective makes sense when we talk about state management in UI. The UI
    is always nuanced on the same observable state and needs different views of the
    state depending on the context and task. This means that there are many possibilities
    for deriving a view-centric state (or representation) within the same UI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的一个核心理念是可观察状态应尽可能简化。其他一切都应该通过计算属性***派生***出来。当我们谈论UI中的状态管理时，这种观点是有道理的。UI始终对相同的可观察状态进行微妙的处理，并根据上下文和任务的不同需要状态的不同视图。这意味着在同一个UI中有许多可能性来派生基于视图的状态（或表示）。
- en: An example of such a view-centric state is a table view and a chart view of
    the same list of observables. Both are operating on the same state but need different
    representations to satisfy the UI (the view) needs. Such representations are prime
    candidates for state derivations. MobX recognizes this core requirement and provides
    ***computed properties***, which are specialized observables that derive their
    value from other dependent observables.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于视图的状态的一个例子是相同可观察对象列表的表视图和图表视图。两者都在相同的状态上操作，但需要不同的表示来满足UI（视图）的需求。这样的表示是状态派生的主要候选对象。MobX认识到了这一核心需求，并提供了***计算属性***，这些计算属性是从其他依赖的可观察对象派生其值的专门的可观察对象。
- en: '*Computed properties* are very efficient and cache the computation. Although
    the computed property is re-evaluated whenever the dependent observables change,
    no notifications are fired if the new value matches the previously cached value.
    Additionally, computed properties also get garbage collected if there are no more
    observers of the computed property. This automatic cleanup also adds to the efficiency.
    *Caching* and *automatic clean-up* are the main reasons why MobX recommends liberal
    usage of computed properties.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算属性*非常高效并且缓存计算结果。虽然计算属性在依赖的可观察对象发生变化时会重新评估，但如果新值与先前缓存的值匹配，则不会触发通知。此外，如果没有计算属性的观察者，计算属性也会被垃圾回收。这种自动清理也增加了效率。*缓存*和*自动清理*是MobX建议大量使用计算属性的主要原因。'
- en: Using computed properties, we can create separate observables as needed by the
    UI. As your application grows in size, you will possibly need more derivations
    that depend on the core state. These derivations (computed properties) can be
    mixed in using `extendObservable()`, as and when needed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算属性，我们可以根据UI的需要创建单独的可观察对象。随着应用程序规模的增长，您可能需要更多依赖于核心状态的派生。这些派生（计算属性）可以在需要时使用`extendObservable()`混合进来。
- en: 'MobX offers three different ways in which you can create computed properties:
    using the `@computed` decorator, the `decorate()` API, or using the `computed()`
    function. These can be seen in the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MobX提供了三种不同的方式来创建计算属性：使用`@computed`装饰器，`decorate()` API，或者使用`computed()`函数。这些可以在以下代码片段中看到：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the `computed()` function directly has the feel of working with boxed
    observables. You have to use the `get()` method on the returned computed function
    to retrieve the value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用`computed()`函数的感觉就像是在使用包装的可观察对象。您必须使用返回的计算函数上的`get()`方法来检索值。
- en: You also have the option of using the `observe()` method of the `computed()`
    function. By attaching an observer, you can get the changed value. This technique
    can also be used to handle side effects or reactions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`computed()`函数的`observe()`方法。通过附加观察者，您可以获得更改后的值。这种技术也可以用于处理副作用或反应。
- en: Both of these APIs can be seen in the preceding code snippet. This usage is
    not very common, but can be leveraged when dealing with boxed observables directly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个API都可以在前面的代码片段中看到。这种用法并不是很常见，但在直接处理装箱可观察对象时可以利用。
- en: Structural equality
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构相等
- en: If the return value of a computed property is a primitive, it is easy to know
    when there is a new value. MobX compares the previous value of the computed property
    with the newly evaluated value and then fires notifications if they differ. Thus,
    value comparisons become important to ensure notifications are fired only on a
    *real change*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算属性的返回值是一个原始值，那么很容易知道是否有新值。MobX会将计算属性的先前值与新计算的值进行比较，然后在它们不同时触发通知。因此，值比较变得重要，以确保通知只在*真正的改变*时触发。
- en: For objects, this is not straightforward. The default comparison is done based
    on reference checks (using the `===` operator). This treats the objects as being
    different even though the values within them are exactly the same.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象来说，这并不是一件简单的事情。默认比较是基于引用检查进行的（使用`===`运算符）。这会导致对象被视为不同，即使它们内部的值完全相同。
- en: 'In the following example, the `metrics` computed property generates a new object
    every time the `start` or `end` properties change. Since the `autorun` (defined
    in the constructor) depends on `metrics`, it runs the side effect every time `metrics`
    changes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`metrics`计算属性每次`start`或`end`属性更改时都会生成一个新对象。由于`autorun`（在构造函数中定义）依赖于`metrics`，它会在每次`metrics`更改时运行副作用：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, notice that `metrics` doesn''t really change, even though the `start` and `end` properties
    are changing. This can be seen with the *autorun* side effect, which keeps printing
    the same delta value. This happens because the `metrics` computed property is
    returning a new object on each evaluation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，即使`start`和`end`属性在更改，`metrics`实际上并没有改变。这可以通过*autorun*副作用来看出，它一直打印相同的增量值。这是因为`metrics`计算属性在每次评估时都返回一个新对象：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The way to fix this is to use the `@computed.struct` decorator, which does a
    deep comparison of the object structure. This ensures that no notifications are
    fired when a re-evaluation of the `metrics` property gives back the same structure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题的方法是使用`@computed.struct`装饰器，它会对对象结构进行深度比较。这确保在重新评估`metrics`属性时返回相同结构时不会触发任何通知。
- en: 'This is one way to safeguard a costly reaction that depends on such a computed
    observable. Decorate it with `computed.struct` to ensure only a real change in
    the object structure is considered for notification. Conceptually, it is very
    similar to the `observable.struct` decorator that we saw in the previous section
    of this chapter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种保护依赖于这样一个计算可观察对象的昂贵反应的方法。使用`computed.struct`装饰它，以确保只有对象结构的真正改变被视为通知。在概念上，这与我们在本章前一节中看到的`observable.struct`装饰器非常相似：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In practice, it is rare to use the `computed.struct` observable. The computed
    value only changes when the dependent observables change. When any of the dependent
    observables change, a new, computed value has to be created, and in most real
    world apps, it is different most of the time. Thus, you don't really need to decorate
    with `computed.struct`, since most computed values will be very different from
    each other in successive evaluations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，很少使用`computed.struct`可观察对象。计算值只有在依赖的可观察对象发生变化时才会改变。当任何依赖的可观察对象发生变化时，必须创建一个新的计算值，在大多数真实世界的应用程序中，它在大多数情况下是不同的。因此，你不需要真的使用`computed.struct`修饰，因为大多数计算值在连续评估中都会非常不同。
- en: Modeling the stores
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模存储
- en: It can seem like a daunting task when you start to model the client state for
    your React Application with MobX. An idea that can help you on this journey is
    the simple realization that *your application is just a collection of features*,
    composed together to form a cohesive unit. By starting with the simplest feature,
    you can string the rest of the app together, one feature at a time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用MobX为你的React应用程序建模客户端状态时，这似乎是一项艰巨的任务。一个可以帮助你在这个过程中的想法是简单地意识到*你的应用程序只是一组特性*，组合在一起形成一个连贯的单元。通过从最简单的特性开始，你可以逐个特性地串联整个应用程序。
- en: 'This style of thinking guides you to model your feature-level-stores first.
    The app-level-store (also called the Root Store) is just a composition of these
    feature stores with a shared communication channel. In the MobX world, you start
    with a *class* to describe the feature store. Depending on the complexity, you
    can break the feature store into many sub stores. The feature store acts as the
    coordinator of all the sub stores. This is the classic *divide and conquer* approach
    to modeling software:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思维方式指导你首先对特性级别的存储进行建模。应用级别的存储（也称为根存储）只是这些特性存储的组合，具有共享的通信渠道。在MobX世界中，你首先使用一个*类*来描述特性存储。根据复杂程度，你可以将特性存储分解为许多子存储。特性存储充当所有子存储的协调者。这是对软件建模的经典*分而治之*方法：
- en: '![](../images/00024.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: Let's take an example to illustrate this approach to modeling the reactive client
    state. In the *book-search* app that we built in the previous section, we want
    to add the ability to create wishlists. A wishlist can contain items that you
    would like to purchase in the future. You should be able to create as many wishlists
    as you want. Let's model the wishlist feature with MobX. We will not worry about
    the React side of things and instead just focus on using MobX to model the client
    state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来说明这种建模响应式客户端状态的方法。在我们之前构建的*图书搜索*应用中，我们想要添加创建愿望清单的功能。愿望清单可以包含你将来想要购买的物品。你应该能够创建任意多个愿望清单。让我们使用MobX来建模愿望清单功能。我们不会担心React方面的事情，而是专注于使用MobX来建模客户端状态。
- en: '**The Wishlist feature**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单功能**'
- en: This adds the ability to create wishlists. A wishlist has a name and contains
    a list of items to be purchased in the future. One can create as many wishlists
    as needed. A wishlist item has the title of the item and a flag to track if it
    is purchased.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了创建愿望清单的能力。愿望清单有一个名称，并包含一个将来要购买的物品列表。可以根据需要创建任意多个愿望清单。愿望清单项具有物品的标题和一个标志来跟踪是否已购买。
- en: The first step in modeling with MobX is to identify the *observable state* and
    the *actions* that can mutate it. We are not going to worry about *reactions*
    (or *observers*) as of now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MobX进行建模的第一步是确定*可观察状态*和可以改变它的*操作*。我们现在不会担心*反应*（或*观察者*）。
- en: Observable state
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察状态
- en: 'We will start with a *class*, `WishListStore`, to track all the details of
    the wishlist feature. This is our *feature-level-store* that contains the observable
    state for the entire feature. Based on the description we saw earlier, let''s
    distill the core observable state:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个*类*“WishListStore”开始，来跟踪愿望清单功能的所有细节。这是我们的*特性级存储*，其中包含整个特性的可观察状态。根据我们之前看到的描述，让我们提炼核心可观察状态：
- en: An array of wishlists, where each item is an instance of a `WishList` class
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个愿望清单数组，其中每个项目都是`WishList`类的一个实例
- en: The `WishList` has a *name* and contains an array of `WishListItem` instances
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WishList`有一个*名称*，并包含`WishListItem`实例的数组'
- en: Each `WishListItem` has a *title* and a boolean *purchased* property
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个“WishListItem”都有一个*标题*和一个布尔值*purchased*属性
- en: An interesting thing to note here is that we have extracted some vocabulary
    from the earlier description. This includes `WishListStore`, `WishList`, and `WishListItem`,
    which form the backbone of our feature. Identifying this vocabulary is the hard
    part and can take a few iterations to get to the right terms. It's no wonder that *naming
    things* is classified as one of the two hard problems in Computer Science!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的一件事是，我们从之前的描述中提取了一些词汇。这包括`WishListStore`，`WishList`和`WishListItem`，它们构成了我们特性的支柱。识别这些词汇是困难的部分，可能需要几次迭代才能找到正确的术语。难怪“命名事物”被归类为计算机科学中的两个难题之一！
- en: 'In code, we can now capture this observable state as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们现在可以这样捕获这个可观察状态：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice the use of the `observable.shallow` decorator for arrays. We don''t
    need deep observation for them. The individual items (`WishListItem`) have their
    own observable properties. The wishlist feature is represented by the singleton
    instance of the `WishListStore` (`store`). Since we will be creating instances
    of `WishList` and `WishListItem`, we can add constructor functions to make this
    easier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数组的`observable.shallow`装饰器的使用。我们不需要对它们进行深层观察。单独的项目（`WishListItem`）有它们自己的可观察属性。愿望清单功能由`WishListStore`（`store`）的单例实例表示。由于我们将创建`WishList`和`WishListItem`的实例，我们可以添加构造函数来使这更容易：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Derived state
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生状态
- en: Now that the core observable state has been established, we can give some consideration
    to the derived state. Derived state (derivations) are computed properties that
    depend on other observables. It is helpful to think of the derivations in the
    context of how the core observable state is consumed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在核心可观察状态已经建立，我们可以考虑一下派生状态。派生状态（推导）是依赖于其他可观察属性的计算属性。在消费核心可观察状态的上下文中考虑派生状态是有帮助的。
- en: 'One common use case when you have arrays is to think of the empty state. There
    is usually some visual indication that the list is empty. Rather than testing
    the `array.length`, which is quite low-level, it is better to expose a computed
    property called `isEmpty`. Such computed properties focus on the *semantics* of
    our store rather than dealing directly with the core observables:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有数组时，一个常见的用例是考虑空状态。通常有一些视觉指示列表是空的。与其测试`array.length`，这是相当低级的，不如暴露一个名为`isEmpty`的计算属性。这样的计算属性关注我们存储的*语义*，而不是直接处理核心可观察状态：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, if we want to know the purchased items from the `WishList`, there
    is no need to define any new observable state. It can be derived from the `items`
    by filtering the `purchased` property. That is the definition for the `purchasedItems` 
    *computed property*. I'll leave it as an exercise for the reader to define this
    computed property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想知道从`WishList`中购买的物品，就不需要定义任何新的可观察状态。它可以从`items`通过过滤`purchased`属性来派生。这就是`purchasedItems`的定义*计算属性*。我将把定义这个计算属性留给读者作为练习。
- en: You should always think of the *observable state* as a combination of a minimal
    *core state* and a *derived state*. Think of the following equation to ensure
    that you are not putting too much into your core state. What can be derived should
    always lie in the *derived state:*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终将*observable state*视为最小*core state*和*derived state*的组合。请考虑以下方程式，以确保您没有将太多内容放入核心状态中。可以派生的内容应始终位于*derived
    state*中：
- en: '![](../images/00025.jpeg)In real-world apps, it is quite possible that a property
    being tracked in one store may move to another due to refactoring. For example,
    the `purchased` property of a `WishListItem` could be tracked by a separate store
    (for example, `ShoppingCartStore`). In such a case, the `WishListItem` can make
    it a *computed property* and depend on the external store to keep track of it.
    Doing so does not change anything on the UI since the way you read `purchased`
    still stays the same. Also, MobX makes it simple to keep the `purchased` property
    always up-to-date because of the implicit dependency created via the computed
    property.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，很可能由于重构而将在一个存储中跟踪的属性移动到另一个存储中。例如，`WishListItem`的`purchased`属性可以由一个单独的存储（例如`ShoppingCartStore`）跟踪。在这种情况下，`WishListItem`可以将其设置为*computed
    property*并依赖外部存储来跟踪它。这样做不会改变UI上的任何内容，因为您读取`purchased`的方式仍然保持不变。此外，由于计算属性隐式创建的依赖关系，MobX使得保持`purchased`属性始终保持最新变得简单。
- en: Actions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: 'Once the observable state is identified, it is natural to include the *actions*
    that can mutate it. These are the operations which will be invoked by the user,
    and exposed by the React interface. In the case of the wishlist feature, this
    includes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了observable state，就自然而然地包括可以改变它的*actions*。这些是用户将调用的操作，并由React接口公开。在愿望清单功能的情况下，这包括：
- en: Creating a new `WishList`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的`WishList`
- en: Deleting a wishlist
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除愿望清单
- en: Renaming a wishlist
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名愿望清单
- en: Adding items (`WishListItem`) to a wishlist
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目（`WishListItem`）添加到愿望清单
- en: Removing items from a wishlist
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从愿望清单中删除项目
- en: 'Actions that add or remove wishlists go into the top-level, `WishListStore`,
    while actions concerning items in a wishlist will be placed in the `WishList`
    class. The renaming of a wishlist can also go into the `WishList` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将添加或删除愿望清单的操作放入顶层的`WishListStore`中，而涉及愿望清单中项目的操作将放在`WishList`类中。愿望清单的重命名也可以放在`WishList`类中：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: MobX gives a convenient API on *observable arrays* to remove items. Using the
    `remove()` method, you can remove items that match by value or reference. The
    method returns *true* if the item was found and removed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: MobX为*observable arrays*提供了方便的API来移除项目。使用`remove()`方法，您可以删除与值或引用匹配的项目。如果找到并删除了该项目，则该方法将返回*true*。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Once you make the broad cuts on the observable state, it is time to tailor
    it further with the observable decorators. This gives you better control of the
    observability and improves the performance of the MobX reactivity system. We have
    seen two different ways of doing this: one with the `@decorator` syntax and the
    other using the `decorate()` API.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对observable state进行了广泛的切割，就可以使用observable decorators进一步定制它。这样可以更好地控制可观察性，并改善MobX响应性系统的性能。我们已经看到了两种不同的方法：一种是使用`@decorator`语法，另一种是使用`decorate()`API。
- en: It is also possible to add new *observable properties* on the fly with `extendObservable()`.
    In fact, you can even add new *actions* and *computed properties* with `extendObservable()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`extendObservable()`动态添加新的*observable properties*。实际上，您甚至可以使用`extendObservable()`添加新的*actions*和*computed
    properties*。
- en: '*Observable State = Core State + Derived State*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Observable State = Core State + Derived State*'
- en: The *core state* and the *derived state* are two aspects of the *observable
    state* in MobX. This is easy to model with classes and decorators, as shown in
    the preceding sections. Once you identify the vocabulary of your feature, they
    become the class names that encapsulate the *observable state*. To handle the
    complexity of the feature, you can break it into smaller classes and compose them
    in the *feature store*. These *feature stores* are then composed in the top-level
    *root store*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心状态*和*派生状态*是MobX中*可观察状态*的两个方面。这很容易用类和装饰器来建模，就像前面的章节中所示的那样。一旦你确定了你的功能的词汇，它们就成为封装*可观察状态*的类名。为了处理功能的复杂性，你可以将其分解为较小的类，并将它们组合在*功能存储*中。然后这些*功能存储*再组合在顶层的*根存储*中。'
- en: 'Now that we have a deeper understanding of defining and crafting the *observables*,
    it''s time we look at the other pillars of MobX: *actions* and *reactions*. That
    is where we are heading with the next chapter.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对定义和构建*可观察对象*有了更深入的理解，是时候我们来看看MobX的其他支柱：*actions*和*reactions*。这就是我们下一章要讨论的内容。
