- en: '*Chapter 5*: Why Galio?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：为什么选择Galio？'
- en: In the previous chapter, we created our first screen. After creating it with
    plain React Native code, we went ahead and imported some Galio components, which
    helped us style and create the layout in a much easier and simpler manner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了我们的第一个屏幕。在用普通的React Native代码创建它之后，我们继续导入了一些Galio组件，这些组件帮助我们以更加简单和轻松的方式进行样式和布局的创建。
- en: This chapter is going to be a better introduction to Galio. We'll learn how
    to use it and why most programmers look for a **user interface** (**UI**) solution
    such as Galio to solve most of their developing processes. As we saw in the last
    chapter, just using the core `react-native` components means the code gets really
    large and hard to maintain. Galio components come packed with many different props
    that make life a lot easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将更好地介绍Galio。我们将学习如何使用它，以及为什么大多数程序员寻找类似Galio这样的用户界面（UI）解决方案来解决他们大部分的开发过程。正如我们在上一章中看到的，仅仅使用核心的`react-native`组件意味着代码变得非常庞大且难以维护。Galio组件打包了许多不同的属性，使生活变得更加轻松。
- en: We'll also learn about the benefits of using an open source library, how that
    creates a community of people willing to help each other, and how you can step
    in and add value to the library as you see fit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解使用开源库的好处，以及如何创建一个愿意互相帮助的人群社区，以及你如何可以根据自己的意愿为库增加价值。
- en: This conversation is going to open a lot of new doors that you never thought
    even existed before. It will create some sort of new mentality, expanding your
    vision on what a developer really is and how they communicate.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这次对话将打开许多你以前从未想到的新大门。它将创造一种新的心态，扩展你对开发者真正是什么以及他们如何交流的视野。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Beautiful mobile app development with Galio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Galio进行美丽的移动应用开发
- en: Using Galio in your apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用中使用Galio
- en: Discovering the benefits of Galio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现Galio的好处
- en: By the end of this chapter, you should be able to understand the reasons why
    people choose Galio to quickly start working on their projects. You'll understand
    how to install it and use it in your apps and what role certain components have
    in your app. Learning about certain components sure is helpful, but don't shy
    away—all programmers use Google to discover solutions to their problems, and I
    highly encourage you to do the same if you feel some things require further explanation
    or have changed during the course of time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够理解人们为什么选择Galio来快速开始他们的项目。你将了解如何安装它并在你的应用中使用它，以及某些组件在你的应用中扮演的角色。了解某些组件肯定是有帮助的，但不要躲避——所有程序员都使用Google来发现他们的问题的解决方案，我强烈鼓励你在需要进一步解释或在时间过程中发生变化的情况下也这样做。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 05` that contains all the code we've written
    inside this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问GitHub上的[https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)来查看本章的代码。你会发现一个名为`Chapter
    05`的文件夹，其中包含了本章中我们编写的所有代码。为了使用该项目，请按照`README.md`文件中的说明进行操作。
- en: Beautiful mobile app development with Galio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Galio进行美丽的移动应用开发
- en: We have so many examples of mobile applications that don't look really good.
    Multiple different social media apps are being created by random people thinking
    that they'll hit the next jackpot, just like Facebook did. The most usual problem
    I've identified with most of these apps, on top of the bugs you're always going
    to find inside a beginner developer's app, is the design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多移动应用程序的例子，它们看起来并不真的好看。许多不同的社交媒体应用程序都是由随机的人创建的，他们认为他们会像Facebook一样大获成功。我发现大多数这些应用程序的最常见问题是设计问题，除了你总是会在初学者开发的应用程序中发现的错误。
- en: The layout is quickly created and they do not pay any attention to how the **user
    experience** (**UX**) might end up because of their design. They think that just
    because they have a nice idea, they don't really need to pay attention to anything
    else.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 布局很快就创建好了，他们并没有注意到他们的设计可能会因为**用户体验**（**UX**）而受到影响。他们认为只要他们有一个好主意，就不需要注意其他任何事情。
- en: I disagree. I honestly believe that you could sell anything as long as the design
    is sleek and the UX is top-notch. The reason why I believe this is mostly that
    I usually use the *1-minute rule*. This is something personal that I've created
    for myself. Basically, once I install an app, I only take somewhere around a minute
    to try to see what's going on with that specific app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我不同意。我真诚地相信只要设计时尚，用户体验一流，你就可以销售任何东西。我之所以这样认为，主要是因为我通常使用*1分钟规则*。这是我为自己创建的一些个人规则。基本上，一旦我安装了一个应用程序，我只需要大约一分钟的时间来尝试看看这个特定应用程序发生了什么。
- en: Why a minute? Well, we're using mobile apps because we want things to be fast
    and easy to use. We're always looking for a mobile app alternative to our web-related
    activities just because we want to have easier and faster access. We want to be
    able to check some information and maybe do some activities. If I can't figure
    out how to use your application in 1 minute, then I'll uninstall it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要等一分钟呢？嗯，我们使用移动应用程序是因为我们希望事情变得快速和易于使用。我们总是在寻找移动应用程序的替代方案，因为我们希望更轻松和更快速地访问我们的网络相关活动。我们希望能够查看一些信息，甚至可能做一些活动。如果我在1分钟内无法弄清楚如何使用你的应用程序，那么我会卸载它。
- en: What does that say about the way we should build our apps? We should have the
    user in mind at all times and only use enough information for them to not have
    to think about how to use our app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们应该如何构建我们的应用程序有什么影响？我们应该时刻考虑用户，并且只使用足够的信息，让他们不必考虑如何使用我们的应用程序。
- en: Galio comes in handy because it uses the same process—easy, fast, and straightforward.
    You don't have to think too much about how wide a button should be or what the
    pixel size should be in your app. It comes pre-packed with all the tools you need
    to design and produce your best idea.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Galio很方便，因为它使用相同的流程——简单，快速和直接。你不必太在意按钮应该有多宽，或者你的应用程序中像素大小应该是多少。它预先装载了你设计和制作最佳想法所需的所有工具。
- en: 'Let''s start by seeing how buttons look and the many different ways of styling
    we have for them. We''ll be using buttons in almost any situation inside our app,
    so I figured that this would be a great start. Have a look at the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看按钮的外观和我们为它们提供的许多不同样式。我们几乎在应用程序的任何情况下都会使用按钮，所以我觉得这将是一个很好的开始。看一下以下的截图：
- en: '![Figure 5.1 – Buttons displayed inside an app'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 应用程序中显示的按钮'
- en: '](Images/Figure_5.1_B17074.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 5.1 – Buttons displayed inside an app
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 应用程序中显示的按钮
- en: As you can see, we have lots of different ways of displaying a button, from
    bright colors and shadows to shadowless and plain. You could have squares, or
    even—straight up—just a circle and an icon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有很多不同的方式来显示按钮，从明亮的颜色和阴影到无阴影和简单。你可以有方形，甚至——直截了当地——只是一个圆圈和一个图标。
- en: 'Let''s take a look at how easily this can be implemented in our app. Here''s
    the code for the buttons shown in *Figure 5.1*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在我们的应用程序中如何轻松实现。这是图5.1中显示的按钮的代码：
- en: '![Figure 5.2 – Code for the buttons in Figure 5.1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 - 图5.1中按钮的代码'
- en: '](Images/Figure_5.2_B17074.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.2_B17074.jpg)'
- en: Figure 5.2 – Code for the buttons in Figure 5.1
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 图5.1中按钮的代码
- en: So, as far as we can see, we have props for everything. Some require more or
    less work from us, but at the same time, the ease of just editing everything from
    inside the component is worth it every time. Just because we wanted to capitalize
    a button and have it capitalized all the time, we can use the `capitalize` prop.
    Or maybe we want the text to always be uppercase; that's fine—we've got a prop
    for that as well. It really makes the developing process incredibly easy and accessible
    to anybody.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就我们所看到的，我们为所有事情都有props。有些需要我们更多或更少的工作，但与此同时，只需从组件内部编辑一切的便利性每次都是值得的。只是因为我们想要将按钮大写并使其始终大写，我们可以使用`capitalize`
    prop。或者也许我们希望文本始终是大写的；那没问题——我们也有一个prop。这真的使得开发过程变得非常容易，任何人都可以轻松使用。
- en: We've discussed how an app should look and feel good for our users. But that
    should be transposed into our development process as well. That's why I honestly
    believe that clear and beautiful code will almost always equal a beautiful product.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过应用程序应该对我们的用户看起来和感觉良好。但这也应该转化到我们的开发过程中。这就是为什么我真诚地相信，清晰而美丽的代码几乎总是等于一个美丽的产品。
- en: 'Now, let''s take a look at another cool component from the Galio package—the
    `Accordion`. You never know when you need a beautiful-looking accordion to create
    more space for your content. You can see a representation of this here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看Galio包中另一个很酷的组件——`Accordion`。你永远不知道何时需要一个外观漂亮的手风琴来为你的内容创建更多的空间。你可以在这里看到它的表示：
- en: '![Figure 5.3 – Accordion component as displayed on your screen'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 手机屏幕上显示的手风琴组件'
- en: '](Images/Figure_5.3_B17074.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.3_B17074.jpg)'
- en: Figure 5.3 – Accordion component as displayed on your screen
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 手机屏幕上显示的手风琴组件
- en: 'This component is incredibly easy to use. It needs a `View` (or `Block`) component
    with a specified height and an array of objects defining the content inside the
    component. Here''s the code relating to this component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件非常容易使用。它需要一个具有指定高度的`View`（或`Block`）组件和定义组件内部内容的对象数组。以下是与此组件相关的代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should basically be pretty easy for anyone to configure and use when needed.
    The objects inside the array must have certain keys so that our component can
    identify and understand where to place that content. An object might look something
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上对于任何人来说都应该很容易配置和在需要时使用。数组内的对象必须具有特定的键，以便我们的组件可以识别和理解在哪里放置内容。对象可能看起来像这样：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It doesn't look that hard, right? If we want to use an icon, as we saw when
    we created our first item (in [*Chapter 1*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015)*,
    Introduction to React Native and Galio,*), all we have to do is add the `icon`
    key inside our object, which is going to contain the `name`, `family`, and `size`
    values of the specified icon we want to use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来并不那么难，对吧？如果我们想使用一个图标，就像我们在创建第一个项目时看到的那样（在[*第1章*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015)*，React
    Native和Galio简介*），我们所要做的就是在对象内添加`icon`键，其中将包含我们想要使用的指定图标的`name`、`family`和`size`值。
- en: This is basically how all of Galio's components are built. They are straightforward
    and good-looking, ready to be used to create a new app in seconds.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是Galio所有组件的构建方式。它们直截了当，外观良好，可以立即用于在几秒钟内创建新应用程序。
- en: 'We should check out another component before moving forward, so let''s see
    how easy it is to customize and use a checkbox with Galio. Have a look at the
    following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该查看另一个组件，看看使用Galio自定义和使用复选框有多容易。看一下以下截图：
- en: '![Figure 5.4 – Checkbox component as displayed on your screen'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 - 复选框组件在您的屏幕上显示'
- en: '](Images/Figure_5.4_B17074.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.4_B17074.jpg)'
- en: Figure 5.4 – Checkbox component as displayed on your screen
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 复选框组件在您的屏幕上显示
- en: 'This looks complicated if it is to be created with the core React Native components,
    but we''re in luck because Galio makes it as easy as just writing a single line,
    as illustrated here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用核心React Native组件创建这个布局，看起来会很复杂，但我们很幸运，因为Galio使它变得如此简单，只需写一行代码，如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, we can set the color, the direction, and even the icon, all inside
    our component. They look beautiful to both write and display as they are without
    any modification. This makes us proud of our library as we really take pride in
    the way it looks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以在我们的组件内设置颜色、方向，甚至图标。它们在没有任何修改的情况下写入和显示都很美丽。这让我们为我们的库感到自豪，因为我们真的为它的外观感到自豪。
- en: Now, let's take a look at how easy it is to create a basic layout with the `Block`
    component. We'll be using this component for layout design only, and we'll color
    every square so that we have a better understanding of what each element is exactly
    displaying.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用`Block`组件创建基本布局有多容易。我们将仅在布局设计中使用此组件，并为每个方块着色，以便更好地理解每个元素实际显示的内容。
- en: Using Galio in your apps
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用Galio
- en: Now, let's see Galio in action. One of the greatest features of Galio—besides
    the way it looks or the ease of writing code—is our `Block` component, which is
    basically a `View` component but with superpowers. Why do we say superpowers?
    We could easily use this component to both create our layout and easily style
    everything just by using props.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Galio的实际效果。Galio最大的特点之一是我们的`Block`组件，它基本上是一个带有超能力的`View`组件。为什么说是超能力呢？我们可以轻松使用此组件来创建布局，并且只需使用props就可以轻松地为所有内容设置样式。
- en: So, let's put this into action and see how easy it is to create a basic layout
    with the `Block` component. I'll take you step by step and show you the most usual
    ways of using `Block` while also demonstrating the most common ways of arranging
    the layout. You can find the project in our GitHub repository or you can follow
    along by coding with me.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们付诸行动，看看使用`Block`组件创建基本布局有多容易。我将逐步向您展示使用`Block`的最常见方式，并演示布局的最常见排列方式。您可以在我们的GitHub存储库中找到该项目，或者可以跟着我一起编码。
- en: 'I''ll start by creating a new Expo project. After that, I''ll install Galio
    via the command line by writing the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建一个新的Expo项目开始。之后，我将通过命令行安装Galio，写入以下代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have everything installed, I'll skip the whole process of organizing
    our files as we're using this for demonstration purposes. So, we're going to be
    writing our code directly into our `App.js` file, in our entry point—the `App`
    function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有内容，我将跳过整个组织文件的过程，因为我们只是用于演示目的。因此，我们将直接将代码编写到我们的`App.js`文件中，即我们的入口点
    - `App`函数中。
- en: 'We''re going to import our `Block` component via the `import` function under
    our other imports, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过`import`函数在其他导入项下导入我们的`Block`组件，就像这样：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I'll delete everything inside the `App` function and I'll start by creating
    my first `Block` component. This will be used to keep all the elements inside
    because, as we know, we can't return more than one component in a function, so
    in conclusion, that one component will have to encapsulate the other components
    inside it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我将删除“App”函数内的所有内容，然后开始创建我的第一个“Block”组件。这将用于将所有元素放在内部，因为我们知道，在函数中我们不能返回多个组件，所以总之，一个组件将必须将其他组件封装在内部。
- en: 'We''ll use the `flex` prop on it, which will make our `Block` have the property
    of `flex: 1` so that it will stretch both horizontally and vertically, covering
    the entire screen.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在其中使用“flex”属性，这将使我们的“Block”具有“flex: 1”的属性，以便它可以水平和垂直拉伸，覆盖整个屏幕。'
- en: Now we're done with this, let's use the `style` prop. As we said, each `Block`
    element will have a `backgroundColor` property so that we can more easily identify
    which one is which. Inside our `style` prop, we'll write `styles.container`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了这一点，让我们使用“style”属性。正如我们所说，每个“Block”元素都将具有“backgroundColor”属性，以便我们可以更容易地识别哪个是哪个。在我们的“style”属性内，我们将写“styles.container”。
- en: 'Remember that we have a `styles` object below it that has all the styles we
    can use via the `StyleSheet.create` function. We''ll delete everything inside
    the container there, and we''re only going to write `backgroundColor: ''#F94144''`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，在下面有一个“styles”对象，其中包含我们可以通过“StyleSheet.create”函数使用的所有样式。我们将删除容器内的所有内容，只写“backgroundColor:
    ''#F94144''”。'
- en: Let's save, and now, our screen should be some sort of red. Fun fact, this color
    is called **Red Salsa**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 保存一下，现在，我们的屏幕应该是一种红色。有趣的是，这种颜色叫做**红色莎莎**。
- en: Now that everything is working, let's go ahead and start creating our layout
    of boxes and see how easy it is to arrange elements inside our app with the `Block`
    component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都正常运行，让我们继续开始创建我们的盒子布局，看看使用“Block”组件在我们的应用程序中排列元素有多容易。
- en: By the way, you should also remove unnecessary imports such as `StatusBar`,
    `Text`, and `View`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，您还应该删除不必要的导入，比如“StatusBar”，“Text”和“View”。
- en: We'll now start by creating three `Blocks` inside our main `Block` component.
    As we know, all the components inside React Native are arranged in a column from
    top to bottom, so we're basically going to create three rows of `Blocks`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在主“Block”组件内创建三个“Blocks”。正如我们所知，React Native中的所有组件都是从上到下排列的，所以我们基本上要创建三行“Blocks”。
- en: 'Each of these rows will have the `style` prop on them, and in order from top
    to bottom, the styles will be called `styles.row1`, `styles.row2`, and `styles.row3`.
    Now, we''ll go inside our `styles` object and create `row1`, `row2`, and `row3`
    styles. Each of them will have only one property and that is `backgroundColor`,
    with values in order from `row1` to `row3`, like this: `#F3722C`, `#90BE6D`, `#277DA1`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行中的每一个都将在它们上面使用“style”属性，从上到下的顺序，样式将被称为“styles.row1”，“styles.row2”和“styles.row3”。现在，我们将进入我们的“styles”对象并创建“row1”，“row2”和“row3”样式。它们每个都只有一个属性，那就是“backgroundColor”，值的顺序从“row1”到“row3”，就像这样：“#F3722C”，“#90BE6D”，“#277DA1”。
- en: 'Now, if we save, we''ll see nothing. Well, that''s because our `Block` element
    does not have a size set, so it doesn''t know how much space it needs to occupy.
    Remember what we did with the last one? We used `flex`, so let''s use the `flex`
    prop and all three of our components, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们保存，我们将看不到任何东西。那是因为我们的“Block”元素没有设置大小，所以它不知道需要占用多少空间。还记得我们上次做的吗？我们使用了“flex”，所以让我们在所有三个组件上使用“flex”属性，如下所示：
- en: '![Figure 5.5 – The code we''ve used to create our three rows'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5-我们用来创建三行的代码'
- en: '](Images/Figure_5.5_B17074.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.5_B17074.jpg)'
- en: Figure 5.5 – The code we've used to create our three rows
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5-我们用来创建三行的代码
- en: 'Hit **Save**, and we suddenly see three colors from top to bottom: orange,
    green, and blue; more exactly: Orange Red, Pistachio, and CG Blue.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**，突然间我们从上到下看到了三种颜色：橙色，绿色和蓝色；更确切地说：橙红色，开心果色和CG蓝色。
- en: 'Because of the `flex: 1` property that gets applied when we use the `flex`
    prop, each of them gets equal space inside the main `Block` component. Now, the
    cool thing regarding this `flex` property is that we can use it to set the amount
    of space we need.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '由于使用`flex`属性时应用了`flex: 1`属性，每个组件在主`Block`组件内获得了相等的空间。现在，关于这个`flex`属性的酷炫之处在于我们可以使用它来设置我们需要的空间量。'
- en: Let's go ahead, and for the first row, we'll set it to `flex={2}`; for the second
    one, we'll leave it as it is; and for the third one, we'll set it to `flex={3}`.
    Now, we can see that each box has a different amount of space allocated. This
    is all thanks to the fact that React Native uses a **flex system** to create the
    layout; we're just profiting from how easily accessible it is to use it with Galio.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，对于第一行，我们将把它设置为`flex={2}`；对于第二行，我们将保持原样；对于第三行，我们将把它设置为`flex={3}`。现在，我们可以看到每个框都分配了不同的空间。这都归功于React
    Native使用**flex系统**来创建布局；我们只是利用了Galio与之搭配使用的便利性。
- en: 'Now, let''s see how it does the math when we set all these numbers to the `flex`
    property. Because we''ve left the second one as it was, that will be transformed
    when rendered to `flex={1}`. We''ll do the math between the three flexes and end
    up with the following: `2+1+3 = 5`. So, in a nutshell, we can say *the first row
    is two parts of five*, *the second one is one part*, and *the third one is three
    parts*. The numbers used here are specific to our app, but you might have different
    numbers. The main idea is to understand the fact that those numbers are dividing
    the space they have at their disposal—a bigger number gives us more space while
    a smaller number gives us less.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们将所有这些数字设置为`flex`属性时它是如何进行计算的。因为我们将第二个保持原样，当渲染时它将被转换为`flex={1}`。我们将对三个flex进行计算，得到以下结果：`2+1+3
    = 5`。所以，简而言之，我们可以说*第一行是五份中的两份*，*第二行是一份*，*第三行是三份*。这里使用的数字是特定于我们的应用程序，但你可能有不同的数字。主要的想法是要理解这些数字正在分配它们所拥有的空间——一个更大的数字给我们更多的空间，而一个更小的数字给我们更少的空间。
- en: Now, let's use the first row to put another set of `Block` components and use
    more props. Yes—we do have a lot of props to go along with this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用第一行来放置另一组`Block`组件并使用更多的属性。是的——我们确实有很多属性可以与之搭配使用。
- en: We'll start by typing out one component for now and create a style called `row1el`.
    Apply that style to our new `Block` and use the `#577590` color. Well, yeah—nothing
    shows up, but let's use two more props to make it show up. We'll write `width={50}`
    and `height={50}`. This will set the width and height of our `Block` component
    in pixels.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先只输入一个组件，并创建一个名为`row1el`的样式。将该样式应用到我们的新`Block`上，并使用`#577590`颜色。嗯，是的——什么都没有显示出来，但让我们使用两个更多的属性来让它显示出来。我们将写`width={50}`和`height={50}`。这将以像素为单位设置我们的`Block`组件的宽度和高度。
- en: 'Let''s center this element by using the `middle` prop on the parent component.
    The parent component is our first row. As you can see now, our dark blue `block`
    element is in the middle of our first row:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在父组件上使用`middle`属性来使这个元素居中。父组件是我们的第一行。现在你可以看到，我们深蓝色的`block`元素位于第一行的中间：
- en: '![Figure 5.6 – Our code with the newest elements inside of it'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 我们的代码中包含最新的元素'
- en: '](Images/Figure_5.6_B17074.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.6_B17074.jpg)'
- en: Figure 5.6 – Our code with the newest elements inside of it
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 我们的代码中包含最新的元素
- en: 'Now, for the second row, let''s go inside our `styles.row2` object and add
    padding. We''ll add `padding: 30`, and we can observe how our second row got suddenly
    taller. That''s because our whole layout (the three rows) is built with flex,
    which is not setting an absolute size in pixels; the component now wants more
    space.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，对于第二行，让我们进入我们的`styles.row2`对象并添加填充。我们将添加`padding: 30`，我们可以观察到我们的第二行突然变得更高了。那是因为我们整个布局（三行）都是用flex构建的，它不是以像素为单位设置绝对大小；组件现在需要更多的空间。'
- en: 'Inside our second row, we''ll create another `Block` with props of `flex`,
    `middle`, and `style={styles.row2gal}`. Now, for our `row2gal`, we''ll have `backgroundColor:
    ''#F9844A''`. Let''s add three `Block` components inside of this one. Each of
    them will have the following props: `width={30}`, `height={30}`, and `style`.
    The styles will be named in order, from top to bottom, `row2p1`, `row2p2`, and
    `row2p3`. Following the exact order of our styles, we''ll have for each of them
    the `backgroundColor` property set to `''#4D908E''`, `''#43AA8B''`, and `''#F94144''`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的第二行内，我们将创建另一个具有`flex`、`middle`和`style={styles.row2gal}`属性的`Block`。现在，对于我们的`row2gal`，我们将有`backgroundColor:
    ''#F9844A''`。让我们在其中添加三个`Block`组件。它们每个将具有以下属性：`width={30}`、`height={30}`和`style`。样式将按顺序命名，从上到下依次为`row2p1`、`row2p2`和`row2p3`。按照我们的样式的确切顺序，对于每个样式，我们将设置`backgroundColor`属性为`''#4D908E''`、`''#43AA8B''`和`''#F94144''`。'
- en: Now, if we hit **Save**, we'll see that our `Blocks` are positioned in a column.
    Let's solve this by using in the parent component the `row` prop. Now, we've got
    them in a row—that's pretty cool, right? Let's use the `middle` prop as well,
    and `space="evenly"`. Save and see how it looks. Our elements are now centered
    and they have even space between them and the left and right margins of the parent
    component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击**保存**，我们会看到我们的`Blocks`被定位在一列中。让我们通过在父组件中使用`row`属性来解决这个问题。现在，我们把它们放在了一行中
    - 这很酷，对吧？让我们也使用`middle`属性，以及`space="evenly"`。保存并查看效果。我们的元素现在居中，并且它们与父组件的左右边距之间有均匀的空间。
- en: 'Now, let''s go to the second `Block` and use the `bottom` prop. This will make
    the second element go below the first and third ones. Kind of funny—it looks like
    a face, right? See if you agree:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入第二个`Block`并使用`bottom`属性。这将使第二个元素位于第一个和第三个元素下方。有点有趣 - 看起来像一张脸，对吧？看看你是否同意：
- en: '![Figure 5.7 – Our code after we''ve filled the second row'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 - 我们填充第二行后的代码'
- en: '](Images/Figure_5.7_B17074.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.7_B17074.jpg)'
- en: Figure 5.7 – Our code after we've filled the second row
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 - 我们填充第二行后的代码
- en: You can see how easy it is to create a basic layout by only using `Block`. Now,
    before moving forward, you should take your time, and instead of `bottom` maybe
    use the `top` prop on another component and see how it works. Or, instead of `space="evenly"`,
    you could use `space="between"` or `space="around"`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到仅使用`Block`就可以轻松创建基本布局。现在，在继续之前，你应该花些时间，而不是使用`bottom`，也许在另一个组件上使用`top`属性，看看它是如何工作的。或者，而不是使用`space="evenly"`，你可以使用`space="between"`或`space="around"`。
- en: This becomes fun really fast as we actually have full creative control by using
    those components. The best part of this is you can create a full screen made out
    of `Blocks` and then just populate every `Block` element with the component that
    you want to have. Honestly, these features alone would be enough for me to start
    loving Galio. Good thing we have even more features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些组件，我们实际上可以完全控制创意。最好的部分是你可以创建一个由`Blocks`组成的全屏幕，然后只需用你想要的组件填充每个`Block`元素。老实说，这些功能本身就足以让我开始喜欢Galio。幸好我们还有更多功能。
- en: Now that we've used some Galio features in our app, let's move forward and look
    at what type of benefits Galio offers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的应用程序中使用了一些Galio功能，让我们继续前进，看看Galio提供了哪些好处。
- en: Discovering the benefits of Galio
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现Galio的好处。
- en: Now that we've been through several of the benefits of using Galio—such as the
    ease of writing code, how beautiful it looks, and how cool it is to create a layout
    with it—we're ready to see other benefits of using it, and I feel the best place
    we should start our journey is GitHub.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用Galio的几个好处，比如编写代码的便利性，它的美观程度，以及使用它创建布局的酷炫之处，我们准备看看使用它的其他好处，我觉得我们应该开始我们的旅程的最佳地点是GitHub。
- en: 'You can see the Galio icon here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到Galio的图标：
- en: '![Figure 5.8 – Screenshot taken from Galio''s landing page'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 - 从Galio的登陆页面截取的屏幕截图'
- en: '](Images/Figure_5.8_B17074.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_5.8_B17074.jpg)'
- en: Figure 5.8 – Screenshot taken from Galio's landing page
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 - 从Galio的登陆页面截取的屏幕截图
- en: As I've said, we're lucky to have this great community as there's always someone
    reaching out to help you. You can also help out other people, which we always
    encourage. I feel that Galio's community might be best defined by the word *collective*.
    In the music industry, this word is mostly used to define a group of people with
    similar interests that just work together and help each other because they know
    that more people means faster and easier development for everybody.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，我们很幸运有这样一个伟大的社区，总有人伸出援手帮助你。你也可以帮助其他人，我们总是鼓励这样做。我觉得Galio的社区可能最好地用“集体”这个词来定义。在音乐行业，这个词通常用来定义一群有着相似兴趣的人，他们一起合作，互相帮助，因为他们知道更多的人意味着更快更容易的发展。
- en: Let's take a look at some ways you could help and be part of this community.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可以如何帮助并成为这个社区的一部分。
- en: First of all, we have the Discord server, which is where most of our developers
    hang out and discuss random things but also bugs and how to solve specific questions.
    This place is basically a big chat room where everybody is having fun.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有Discord服务器，这是我们大多数开发者聚集讨论各种事情，包括错误和如何解决特定问题。这个地方基本上是一个大型的聊天室，每个人都在开心地交谈。
- en: Anybody can join it and ask questions, or even report a bug or something that
    is not working. Maybe you feel the design could be improved and you want to pitch
    a whole new look to Galio and its community. You can do that there with no worries
    of someone laughing at you or not taking you seriously.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以加入并提出问题，甚至报告错误或一些不起作用的东西。也许你觉得设计可以改进，想要给Galio和它的社区一个全新的外观。你可以在那里做到这一点，不用担心有人会嘲笑你或不认真对待你。
- en: On top of the Discord server, we have the GitHub repository and the website.
    The GitHub repository is where we keep everything that's code-related. This is
    where we maintain the code, answer issues, create new development plans for the
    future, create hotfixes for certain products, and work with **pull requests**
    (**PRs**).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Discord服务器，我们还有GitHub存储库和网站。GitHub存储库是我们保存所有与代码相关的东西的地方。这是我们维护代码、回答问题、为未来创建新的开发计划、为某些产品创建热修复，并与**pull
    requests**（**PRs**）一起工作的地方。
- en: A PR refers to when someone wants to help out with a library. So, they start
    by creating a **fork**, which is the act of cloning someone's repository. Then,
    they make their own modifications, and then the new copy of the repository is
    submitted as a **PR**. that will be then verified by an admin and accepted or
    rejected depending on if the code respects the rules and if it's part of the development
    plan.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PR是指当有人想要帮助一个库时。所以，他们首先创建一个**fork**，这是克隆某人的存储库的行为。然后，他们进行自己的修改，然后新的存储库副本被提交为**PR**。然后由管理员验证并根据代码是否符合规则以及是否符合开发计划的一部分来接受或拒绝。
- en: 'Our website is mostly where we want to showcase people''s apps and news about
    Galio. It''s where we present Galio to the world but it''s also where we keep
    a really important part of the whole library: the documentation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网站主要是我们想要展示人们的应用程序和有关Galio的新闻的地方。这是我们向世界展示Galio的地方，但也是我们保留整个库中非常重要的部分的地方：文档。
- en: The documentation is your go-to place anytime you want to learn more information
    about a specific component or how to use a feature of Galio, such as, for example…
    the **GalioTheme** feature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是您随时想要了解有关特定组件或如何使用Galio功能的更多信息的首选位置，例如……**GalioTheme**功能。
- en: Everything related to Galio—such as the colors, sizes, and layout rules—is stored
    in our default theme. This can be found in the `theme` folder inside our library.
    Every component inherits its styling rules from that file. The coolest thing is
    that you can actually rewrite our theme file with only the things you want to
    modify by using our theme components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与Galio相关的所有内容，如颜色、大小和布局规则，都存储在我们的默认主题中。这可以在我们的库内部的`theme`文件夹中找到。每个组件都从该文件中继承其样式规则。最酷的是，您实际上可以使用我们的主题组件，仅重写您想要修改的内容来重写我们的主题文件。
- en: For example, let's say you want a different color code for `primary`. You can
    override our primary color with your own color and use it with Galio as though
    it's always been there.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要为`primary`设置不同的颜色代码。您可以用自己的颜色覆盖我们的主色，并将其与Galio一起使用，就好像它一直存在一样。
- en: 'To use the GalioTheme feature, you''d have to import `theme`, `withGalio`,
    and `GalioProvider` from our library. Let''s take a small example here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GalioTheme功能，您需要从我们的库中导入`theme`、`withGalio`和`GalioProvider`。让我们举个小例子：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will create a `customTheme` object that will contain two keys: `SIZES`
    and `COLORS`. If you only want to modify the colors, you can use just that specific
    key. Then, you need to encapsulate your component with our **higher-order component**
    (**HoC**), called `GalioProvider`. We''ll also need to pass our new `customTheme`
    object to Galio via the `theme` prop.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含两个键`SIZES`和`COLORS`的`customTheme`对象。如果您只想修改颜色，您可以只使用特定的键。然后，您需要使用我们的**高阶组件**（**HoC**）`GalioProvider`来封装您的组件。我们还需要通过`theme`属性将新的`customTheme`对象传递给Galio。
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An HoC is an advanced React feature that can be more easily defined as a function
    that returns a component and improves that component in some way. Let's say you're
    Tony Stark, and the HoC is the Iron Man suit. The suit is made of iron gloves,
    boots, armor, and helmet, and Tony with iron boots can fly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HoC是一种高级的React功能，可以更容易地定义为返回一个组件并以某种方式改进该组件的函数。假设您是托尼·斯塔克，HoC就是钢铁侠套装。套装由铁手套、靴子、盔甲和头盔组成，而穿上铁靴的托尼可以飞行。
- en: Now, the `customTheme` constants will overwrite the default Galio theme constants.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`customTheme`常量将覆盖默认的Galio主题常量。
- en: But wait—maybe you don't want to change our theme but you want to use our constants
    inside your styling. Using our design system might help you design your layout
    faster, and we're always using Galio's constants inside different products we're
    creating for our clients.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等——也许您不想改变我们的主题，而是想在样式中使用我们的常量。使用我们的设计系统可能有助于更快地设计布局，我们总是在为客户创建的不同产品中使用Galio的常量。
- en: 'Exporting a React component using the `withGalio` function enables your component
    to consume Galio''s React Context and pass down a theme in your component as a
    prop or as an argument for the `styles` object. Let''s take a look at how this
    is done—I''m sure you''ll understand it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`withGalio`函数导出React组件使您的组件能够使用Galio的React上下文，并将主题作为属性或作为`styles`对象的参数传递给您的组件。让我们看看如何做到这一点——我相信您会理解的：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because we're using the `withGalio` function to export our component, Galio
    will pass down to the object we've selected (in this case, it's `styles`) all
    the constant theme variables we have inside our library. So, that's why we're
    able to use `theme` as an argument inside our `styles` object and change the `backgroundColor`
    property to that Facebook color we have inside our library.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用`withGalio`函数来导出我们的组件，Galio将向我们选择的对象（在本例中是`styles`）传递我们库中所有的常量主题变量。因此，我们能够在我们的`styles`对象内使用`theme`作为参数，并将`backgroundColor`属性更改为我们库中的Facebook颜色。
- en: You'll find a table with all the information regarding our constants on our
    documentation website, which is at [https://galio.io/docs](https://galio.io/docs).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的文档网站上找到有关我们常量的所有信息的表格，网址为[https://galio.io/docs](https://galio.io/docs)。
- en: As you can see, Galio is fully packed with lots of cool features that will help
    us develop any mobile app extremely fast and, in the end, make it really good-looking.
    So, why not give it a try? We'll code all of our projects with Galio from now
    on. This will be a mandatory import at the beginning of each app we'll do from
    now on in this book. We'll use more of Galio's components than React Native's
    ones.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Galio充满了许多很酷的功能，将帮助我们极快地开发任何移动应用，并最终使其看起来非常漂亮。那么，为什么不试一试呢？我们将从现在开始使用Galio编写所有项目。这将成为本书中每个应用程序开始时的强制导入。我们将使用更多的Galio组件，而不是React
    Native的组件。
- en: Given this, we'll learn more and more about how to use Galio and how to design
    great apps until we can start coding our own ideas. Maybe one of us will actually
    create a great app with a lot of value for society—something that will change
    the world.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将学会如何使用Galio，如何设计出色的应用程序，直到我们能够开始编写自己的想法。也许我们中的某个人实际上会创建一个对社会有很大价值的伟大应用程序——这将改变世界。
- en: It's nice to dream about how many things we'll be able to do once we acquire
    more and more knowledge. This daydreaming and constant focus on your objective
    is going to prove one of the greatest weapons in learning how to code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 梦想着我们掌握更多知识后能做多少事情真是件美好的事情。这种白日梦和对目标的持续关注将成为学习编码的最强大武器之一。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've been through multiple examples of why Galio is such a
    great library. By the end of it, you must've figured out that Galio really deserves
    to be one of the libraries under your belt—one library to rule them all. This
    will act like your main package with which you'll create incredibly stunning apps,
    both visually for our users and our programming buddies who want to help us out
    with the code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经通过多个示例说明了Galio为何是如此出色的库。到最后，你一定已经意识到Galio真的应该成为你的库之一——一个库来统治它们所有。这将成为你的主要包，你将用它来创建令人惊叹的应用程序，无论是视觉上对我们的用户，还是对想要帮助我们编写代码的编程伙伴。
- en: Don't be afraid of looking into Galio's core code. You might learn a lot of
    things from just experiencing and understanding Galio's code. You might even be
    able to create your own library.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕查看Galio的核心代码。你可能会从体验和理解Galio的代码中学到很多东西。你甚至可能能够创建自己的库。
- en: So, we've discovered that Galio is really cool because the code is easy to use.
    We just have a few props that can change the whole world in terms of speed of
    coding and easy access to specific parameters. We've also seen how great Galio
    looks out of the box. I mean… this library is gorgeous. Sometimes, I wouldn't
    even edit the styling; I'd just use Galio styles because of how great they look.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们发现Galio真的很酷，因为代码易于使用。我们只有一些可以改变整个世界的属性，无论是编码速度还是对特定参数的轻松访问。我们还看到了Galio开箱即用的优势。我的意思是...这个库很华丽。有时，我甚至不会编辑样式；我只会使用Galio样式，因为它们看起来很棒。
- en: We've also seen how easy it is to create a layout with the `Block` component
    and how placing objects on the screen is a lot easier than we thought as long
    as we know just a few props that go along with the `Block` component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到使用`Block`组件创建布局有多么容易，以及只要我们了解与`Block`组件配套的一些属性，放置对象在屏幕上就比我们想象的要容易得多。
- en: After that, we discussed what a great community Galio has and how we can take
    part in it. We haven't gone too deep into GitHub as this is out of the scope of
    this book, but we've definitely learned a lot about how that community works and
    how we can take part in it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们讨论了Galio拥有一个多么伟大的社区，以及我们如何参与其中。虽然这超出了本书的范围，我们并没有深入研究GitHub，但我们确实学到了很多关于这个社区的运作方式以及我们如何参与其中。
- en: At the end of this, we discussed some more advanced features of Galio—or, to
    be more correct, features that use more advanced features of React because they're
    really easy to use if we want to use them from Galio.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了Galio的一些更高级的功能，或者更准确地说，使用了React的更高级功能，因为如果我们想要从Galio中使用它们，它们真的很容易使用。
- en: In the end, we can say that Galio creates an easy access route for everybody
    into the mobile developing world, and I think it's safe to say we're all grateful
    for its existence.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以说Galio为每个人进入移动开发世界创造了一条简单的途径，我想可以说我们都对它的存在表示感激。
- en: The next chapter is going to cover the basics of the mobile UI. We'll figure
    out how to build a clean-looking UI for our apps while learning some guidelines
    and rules on how to provide our users with the best UX we can create.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将涵盖移动UI的基础知识。我们将学习如何为我们的应用构建一个清晰的UI，同时学习一些关于如何为用户提供最佳用户体验的指导方针和规则。
