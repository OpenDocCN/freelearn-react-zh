- en: Observables, Actions, and Reactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observables、Actions和Reactions
- en: Describing the structure of the client state is the first step in UI development.
    With MobX, you do this by creating your tree of **observables**. As the user interacts
    with the app, actions are invoked on your observable state, which in turn can
    cause reactions (aka side-effects). Continuing from [Chapter 1](part0023.html#LTSU0-58c2559ca4304cecab9bc46f496bc070), *Introduction
    to State Management*, we will now take a deeper look at the core concepts of MobX.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 描述客户端状态的结构是UI开发的第一步。使用MobX，您可以通过创建**observables**树来实现这一点。当用户与应用程序交互时，在observable状态上调用操作，这将引起反应（也称为副作用）。继续阅读[第1章](part0023.html#LTSU0-58c2559ca4304cecab9bc46f496bc070)，*状态管理简介*，我们现在将更深入地了解MobX的核心概念。
- en: 'The topics covered in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: Creating the various kinds of observables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建各种类型的observables
- en: Setting up the actions that mutate the observables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置改变observable的操作
- en: Using reactions to handle external changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反应来处理外部变化
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要使用JavaScript编程语言。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter02](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter02)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter02](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter02)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2NEww85](http://bit.ly/2NEww85)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2NEww85](http://bit.ly/2NEww85)'
- en: Observables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observables
- en: 'Data is the lifeblood of your UI. Going back to the equation that defines the
    relationship between data and UI, we know that the following is true:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是UI的命脉。回到定义数据和UI之间关系的方程式，我们知道以下是真的：
- en: '![](../images/00014.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: 'So, it makes sense to focus on *defining the structure* of data that will drive
    the UI. In MobX, we do this with the observables. Take a look at this diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，专注于*定义将驱动UI的数据结构*是有意义的。在MobX中，我们使用observable来做到这一点。看一下这个图表：
- en: '![](../images/00015.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: '*Observables*, as the name suggests, are entities that can be observed. They
    keep track of changes happening to their values and notify all the *observers*.
    This seemingly simple behavior has powerful implications when you start designing
    the structure of your client-state. In the preceding diagram, every circle represents
    an **Observable**, and every diamond is an **Observer**. An observer can observe
    one or more observables and get notified when any of them change value.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Observables*，顾名思义，是可以被观察的实体。它们跟踪其值发生的变化并通知所有*观察者*。当您开始设计客户端状态的结构时，这种看似简单的行为具有强大的影响。在前面的图表中，每个圆代表一个**Observable**，每个菱形代表一个**Observer**。观察者可以观察一个或多个observable，并在它们中任何一个值发生变化时得到通知。'
- en: Creating observables
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建observables
- en: 'The simplest way to create an observable is to use the `observable()` function.
    Take a look at the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建observable的最简单方法是使用`observable()`函数。看一下以下内容：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`item` is now an `observable` object and will start tracking changes to its
    properties. You can use this object as a regular JavaScript object without any
    special API to *get* or *set* its values. In the preceding snippet, you can also
    create an observable `item` using `observable.object()`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`item`现在是一个`observable`对象，并将开始跟踪其属性的变化。您可以将此对象用作常规JavaScript对象，而无需任何特殊的API来*获取*或*设置*其值。在前面的片段中，您还可以使用`observable.object()`创建一个observable
    `item`。'
- en: 'In the following snippet, we can see simple mutations made to the observables,
    like any regular JavaScript code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，我们可以看到对可观察对象进行的简单变化，就像任何常规的JavaScript代码一样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Observable objects only track the properties provided in the initial value given
    to `observable()` or `observable.object()`. This means if you add new properties
    later, they will not become observable automatically. This is an important characteristic
    to remember about observable objects. They are like records or classes with a
    fixed set of attributes. If you do need dynamic tracking of properties, you should
    consider using *observable maps*; these will be covered further ahead in the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象只会跟踪在`observable()`或`observable.object()`中提供的初始值中提供的属性。这意味着如果以后添加新属性，它们不会自动变为可观察的。这是关于可观察对象需要记住的一个重要特性。它们就像具有固定属性集的记录或类。如果你确实需要动态跟踪属性，你应该考虑使用*可观察映射*；这将在本章后面进一步介绍。
- en: Internally, MobX takes care of transparently tracking the property changes and
    notifying the corresponding observers. We will look into this internal behavior
    in a later chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，MobX会透明地跟踪属性的变化并通知相应的观察者。我们将在后面的章节中探讨这种内部行为。
- en: 'The `observable()` function automatically converts an *object*, an *array*,
    or a *map* into an observable entity. This automatic conversion is *not applied*
    for other types of data—such as JavaScript primitives (number, string, boolean,
    null, undefined), functions, or for class- instances (objects with prototypes).
    So, if you call `observable(20)`, it will fail with an error, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable()`函数会自动将*对象*、*数组*或*映射*转换为可观察实体。这种自动转换*不适用*于其他类型的数据，比如JavaScript原始类型（数字、字符串、布尔值、null、undefined）、函数，或者类实例（带有原型的对象）。因此，如果你调用`observable(20)`，它将会失败并显示错误，如下所示：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As suggested in the error, we have to use the more specialized `observable.box()`
    to convert primitive values into an observable. Observables that wrap *primitives*, *functions*,
    or *class-instances* are called **boxed observables**. Take a look at this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如错误中所建议的，我们必须使用更专门的`observable.box()`将原始值转换为可观察值。包装*原始值*、*函数*或*类实例*的可观察值被称为**包装的可观察值**。看一下这个：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have to use the `get()` and `set()` methods of a boxed observable instead
    of directly reading or assigning to it. These methods give us the observability
    that is inherent to MobX.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用包装的可观察对象的`get()`和`set()`方法，而不是直接读取或分配给它。这些方法给了我们MobX固有的可观察性。
- en: 'Besides objects and singular values, you can also create observables out of
    arrays and maps. They have a corresponding API, as can be seen in this table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象和单一值，你还可以将数组和映射转换为可观察对象。它们有相应的API，可以在这个表格中看到：
- en: '| objects | `observable.object({ })` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `observable.object({ })` |'
- en: '| arrays | `observable.array([ ])` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `observable.array([ ])` |'
- en: '| maps | `observable.map(value)` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 映射 | `observable.map(value)` |'
- en: '| primitives, functions, class-instances | `observable.box(value)` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 原始值、函数、类实例 | `observable.box(value)` |'
- en: As we mentioned earlier, `observable()` will automatically convert an object,
    array, or a map into an observable. It is shorthand for `observable.object()`,
    `observable.array()`, or `observable.map()`, respectively. For primitives, functions,
    and class-instances, you should use the `observable.box()` API. Although, in practice,
    the use of `observable.box()` is fairly rare. It is more common to use `observable.object()`, `observable.array()`, or `observable.map()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`observable()`会自动将对象、数组或映射转换为可观察对象。它是`observable.object()`、`observable.array()`或`observable.map()`的简写。对于原始值、函数和类实例，你应该使用`observable.box()`API。尽管在实践中，使用`observable.box()`相当罕见。更常见的是使用`observable.object()`、`observable.array()`或`observable.map()`。
- en: MobX applies *deep observability* when creating an observable. This means MobX
    will automatically observe every property, at every level, in the object-tree,
    array, or map. It also tracks additions or removals in the cases of arrays and
    maps. This behavior works well for most scenarios but could be excessive in some
    cases. There are special decorators that you can apply to control this observability.
    We will look into this in [Chapter 4](part0065.html#1TVKI0-58c2559ca4304cecab9bc46f496bc070), *Crafting
    the Observable Tree*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MobX在创建observable时应用*深度可观察性*。这意味着MobX将自动观察对象树、数组或映射中的每个级别的每个属性。它还会跟踪数组和映射的添加或删除。这种行为对大多数情况都很有效，但在某些情况下可能过于严格。有一些特殊的装饰器可以应用于控制这种可观察性。我们将在[第4章](part0065.html#1TVKI0-58c2559ca4304cecab9bc46f496bc070)中进行探讨，*构建可观察树*。
- en: Observable arrays
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable arrays
- en: 'Using `observable.array()` is very similar to using an `observable()`. You
    pass an array as initial value or start with an empty array. In the following
    code example, we are starting with an empty array:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`observable.array()`与使用`observable()`非常相似。您可以将数组作为初始值传递，或者从空数组开始。在以下代码示例中，我们从一个空数组开始：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Do note that the observable array is *not* a real JavaScript array, even though
    it has the same API as a JS Array. When you are passing this array to other libraries
    or APIs, you can convert it into a JS Array by calling `toJS()`, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，observable数组*不是*真正的JavaScript数组，尽管它具有与JS数组相同的API。当您将此数组传递给其他库或API时，可以通过调用`toJS()`将其转换为JS数组，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: MobX will apply deep observability to observable arrays, which means it will
    track additions and removals of items from the array and also track property changes
    happening to each item in the array.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: MobX将对observable数组应用*深度可观察性*，这意味着它将跟踪数组中项目的添加和删除，还将跟踪数组中每个项目发生的属性更改。
- en: Observable maps
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable maps
- en: You can make an observable map with the `observable.map()` API. In principle,
    it works the same way as `observable.array()` and `observable.object()`, but it
    is meant for ES6 Maps. The observable map instance shares the same API as a regular
    ES6 Map. Observable maps are great for tracking dynamic changes to the keys and
    values. This is in stark contrast to observable objects*,* which do not track
    properties that are added after creation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`observable.map()` API创建一个observable map。原则上，它的工作方式与`observable.array()`和`observable.object()`相同，但它适用于ES6
    Maps。observable map实例与常规的ES6 Map共享相同的API。Observable maps非常适合跟踪键和值的动态变化。这与observable
    objects形成鲜明对比，后者不会跟踪在创建后添加的属性。
- en: 'In the following code example, we are creating a dynamic dictionary of Twitter-handles
    to names. This is a great fit for an observable map, as we are *adding* keys after
    creation. Take a look at this code block:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们正在创建一个动态的Twitter句柄到名称的字典。这非常适合使用observable map，因为我们在创建后*添加*键。看一下这段代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A note on observability
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于可观察性的说明
- en: When you use the `observable()` API, MobX will apply *deep observability* to
    the observable instance. This means it will track changes happening to the observable
    object, array, or map and do it for every property, at every level. In the cases
    of arrays and maps, it will also track the additions and removals of entries.
    Any new entry in an array or a map is also made into a deep observable. This is
    definitely a great sensible default and works well for most situations. However,
    there will be cases where you may not want this default.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`observable()` API时，MobX将对observable实例应用*深度可观察性*。这意味着它将跟踪发生在observable对象、数组或映射上的更改，并且会对每个级别的每个属性进行跟踪。在数组和映射的情况下，它还将跟踪条目的添加和删除。数组或映射中的任何新条目也将成为深度可观察的。这绝对是一个很好的合理默认值，并且适用于大多数情况。但是，在某些情况下，您可能不希望使用这个默认值。
- en: 'You can change this behavior at the time of creating the observable. Instead
    of using `observable()`, you can use the sibling APIs (`observable.object()`,
    `observable.array()`, `observable.map()`) to create the observable. Each of these
    takes an extra argument for setting options on the observable instance. Take a
    look at this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在创建可观察性时改变这种行为。你可以使用兄弟API（`observable.object()`，`observable.array()`，`observable.map()`）来创建可观察性，而不是使用`observable()`。每个API都接受一个额外的参数来设置可观察实例的选项。看一下这个：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By passing in `{ deep: false }` as an option, you can effectively *prune* the
    observability just to the first level. This means the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '通过将`{ deep: false }`作为选项传递进去，你可以有效地*修剪*可观察性，只到第一级。这意味着以下内容：'
- en: For observable objects, MobX only observes the initial set of properties. If
    the value of property is an object, an array, or a map, it won't do any further
    observation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可观察对象，MobX只观察初始属性集。如果属性的值是对象、数组或映射，它不会进行进一步的观察。
- en: 'Note that the `{ deep: false }` option is the third argument for `observable.object()`.
    The second argument, called **decorators**, gives you more fine-grained control
    over the observability. We will be covering this in a later chapter. For now,
    you can just pass an empty object as the second argument.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`{ deep: false }`选项是`observable.object()`的第三个参数。第二个参数称为**装饰器**，可以更精细地控制可观察性。我们将在后面的章节中进行介绍。现在，你可以将一个空对象作为第二个参数传递。'
- en: For observable arrays, MobX only observes the addition and removal of items
    in the array. If an item is an object, an array, or a map, it won't do any further
    observation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可观察数组，MobX只观察数组中项目的添加和移除。如果一个项目是对象、数组或映射，它不会进行进一步的观察。
- en: For observable maps, MobX only observes the addition and removal of items in
    the map. If the value of a key is an object, an array, or a map, it won't do any
    further observation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可观察映射，MobX只观察映射中项目的添加和移除。如果键的值是对象、数组或映射，它不会进行进一步的观察。
- en: 'Now, it is worth mentioning that `observable()` internally calls one of the
    preceding APIs and sets the option to `{ deep: true }`. This is the reason `observable()` has
    deep observability.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '现在值得一提的是，`observable()`在内部调用前面的API之一，并将选项设置为`{ deep: true }`。这就是`observable()`具有深层可观察性的原因。'
- en: The computed observable
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算可观察性
- en: The observables we have seen so far have a direct correspondence with the shape
    of the client-state. If you are representing a list of items, you would use an
    observable array in your client-state. Similarly, each item in a list can be an observable
    object or an observable map. The story does not stop there. MobX gives you yet
    another kind of observable, called a **computed property** or a **computed observable**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的可观察性与客户端状态的形状直接对应。如果你要表示一个项目列表，你会在客户端状态中使用一个可观察数组。同样，列表中的每个项目可以是一个可观察对象或可观察映射。故事并不止于此。MobX还给你另一种可观察性，称为**计算属性**或**计算可观察性**。
- en: A computed property is not an observable that is inherent to the client state.
    Instead, it is an observable that *derives its value* from other observables.
    Now, *why would that be useful*? you may ask. Let's take an example to see the
    benefits.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性不是客户端状态固有的可观察性。相反，它是一个*从其他可观察性派生其值*的可观察性。现在，*为什么会有用*？你可能会问。让我们举个例子来看看好处。
- en: 'Consider the `cart` observable, which tracks a list of items. Take a look at
    this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑跟踪项目列表的`cart`可观察性。看一下这个：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s say you want to have a `description` property that describes the `cart`
    in this format: There `{is, are} {no, one, n} item{s}` in the cart.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个描述`cart`的`description`属性，格式如下：购物车中有{no, one, n}个项目。
- en: 'For zero items, the description says this: *There are no items in the cart*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于零个项目，描述如下：购物车中没有项目。
- en: When there is only one item, the description becomes this: *There is one item
    in the cart*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个项目时，描述变为：*购物车中有一个项目*。
- en: For two or more items *(n)*, the description should be: *There are* *n* *items
    in the cart*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个或更多个项目*(n)*，描述应该是：*购物车中有* *n* *个项目*。
- en: 'Let''s ponder how we can go about modeling this property. Consider the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下如何对这个属性进行建模。考虑以下内容：
- en: Clearly, the `description` is not an inherent property of the cart. Its value
    depends on `items.length`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，`description`不是购物车的固有属性。它的值取决于`items.length`。
- en: We can add an observable property called `description`, but then we have to
    update it anytime `items` or `items.length` changes. That is extra work and easy
    to forget. Also, we run the risk of someone modifying the description from the
    outside.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加一个名为`description`的可观察属性，但是我们必须在`items`或`items.length`发生变化时更新它。这是额外的工作，容易忘记。而且，我们有可能会有人从外部修改描述。
- en: Description should just be a getter with no setter. If someone is observing
    description, they should be notified anytime it changes.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述应该只是一个没有setter的getter。如果有人观察描述，他们应该在任何时候都会收到通知。
- en: 'As you can tell from the preceding analysis, we can''t seem to fit this behavior
    into any of the previously-discussed observable types. What we need here is the
    computed property. We can define a *computed* description property by simply adding
    a `get-property` to the `cart` observable. It will derive its value from `items.length`.
    Take a look at this code block:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的分析可以看出，我们似乎无法将这种行为归类为先前讨论过的任何可观察类型。我们需要的是计算属性。我们可以通过简单地向`cart`可观察对象添加`get-property`来定义一个*computed*描述属性。它将从`items.length`派生其值。看一下这段代码：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, you can simply read `cart.description` and always get the latest description.
    Anyone observing this property would be automatically notified when `cart.description`
    changes, which will happen if you add or remove items from the cart.The following
    is an example of how this computed property can be used:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需读取`cart.description`，就可以始终获得最新的描述。任何观察此属性的人在`cart.description`发生变化时都会自动收到通知，如果您向购物车中添加或删除商品，这种情况就会发生。以下是如何使用这个计算属性的示例：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that it also satisfies all of the criteria from the previous brainstorming
    on the `description` property. I'll let you, the reader, confirm this is the case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它还满足了先前对`description`属性的所有标准的所有标准。我会让您，读者，确认这是否属实。
- en: '*Computed properties*, also known as **derivations**, are one of the most powerful
    tools in the MobX toolbox. By thinking of your client-state in terms of a minimal
    set of observables and augmenting it with derivations (computed properties), you
    can model a variety of scenarios effortlessly. Computed properties derive their
    value from other observables. If any of these depending observables change, the
    computed property changes as well.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*Computed properties*，也称为**derivations**，是MobX工具箱中最强大的工具之一。通过将客户端状态视为一组最小的可观察对象，并用派生（计算属性）来增强它，您可以轻松地对各种情况进行建模。计算属性的值取决于其他可观察对象。如果其中任何一个依赖的可观察对象发生变化，计算属性也会发生变化。'
- en: You can build a computed property out of other computed properties too. MobX
    internally builds a dependency tree to keep track of the observables. It also
    caches the value of the computed property to avoid unnecessary computation. This
    is an important characteristic that greatly improves the performance of the MobX
    reactivity system. Unlike JavaScript get properties, which are always eagerly
    evaluated, computed properties memoize (aka cache) the value and only evaluate
    when the dependent observables change.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用其他计算属性构建计算属性。MobX在内部构建依赖树以跟踪可观察对象。它还缓存计算属性的值，以避免不必要的计算。这是一个重要的特性，极大地提高了MobX反应性系统的性能。与JavaScript的get属性不同，后者总是急切地评估，计算属性会记忆（又名缓存）值，并且只在相关的可观察对象发生变化时进行评估。
- en: As you develop experience using MobX, you will realize that *computed properties*
    are possibly your best observable-friends.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着使用MobX的经验的积累，您会意识到*计算属性*可能是您最好的可观察对象朋友。
- en: Better syntax with decorators
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的装饰器语法
- en: All of our examples so far have used the *ES5 API* of MobX. However, there is
    a special form of the API, which gives us a very convenient way of expressing
    the observables. This is made possible with the `@decorator` syntax.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的示例都使用了MobX的*ES5 API*。然而，API的特殊形式给了我们一种非常方便的表达可观察对象的方式。这是通过`@decorator`语法实现的。
- en: 'The decorator syntax is still a pending proposal (as of this writing) for inclusion
    in the JavaScript language standard. But that doesn''t stop us from using it,
    as we have **Babel** to help us out. By using the Babel plugin, `transform-decorators-legacy`,
    we can transpile the decorator syntax into regular ES5 code. If you are using
    TypeScript, you can also enable decorator support by setting your `{ experimentalDecorators:
    true}` compiler option in your `tsconfig.json`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '装饰器语法仍然是JavaScript语言标准的一个待定提案（截至目前为止）。但这并不妨碍我们使用它，因为我们有**Babel**来帮助我们。通过使用Babel插件`transform-decorators-legacy`，我们可以将装饰器语法转译为常规的ES5代码。如果您使用TypeScript，还可以通过在`tsconfig.json`中设置`{
    experimentalDecorators: true}`编译器选项来启用装饰器支持。'
- en: 'The decorator syntax is *only available for classes* and can be used for class
    declarations, properties and methods. Here is an equivalent `Cart` observable,
    expressed with decorators:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法*仅适用于类*，可用于类声明、属性和方法。以下是使用装饰器表达的等效`Cart`可观察对象：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the use of decorators to *decorate* the observable properties. The default
    `@observable` decorator does deep observation on all the properties of the value.
    It is actually a shorthand for using `@observable.deep`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用装饰器来*装饰*可观察属性。默认的`@observable`装饰器对值的所有属性进行深度观察。实际上，它是使用`@observable.deep`的简写。
- en: 'Similarly, we have the `@observable.shallow` decorator, which is a *rough*
    equivalent of setting the `{ deep: false }` option on the observable. It works
    for objects, arrays, and maps. We will cover the more technically correct ES5
    equivalent of `observable.shallow` in [Chapter 4](part0065.html#1TVKI0-58c2559ca4304cecab9bc46f496bc070) ,
    *Crafting the Observable Tree*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，我们有`@observable.shallow`装饰器，它是在可观察对象上设置`{ deep: false }`选项的*粗略*等效。它适用于对象、数组和映射。我们将在[第4章](part0065.html#1TVKI0-58c2559ca4304cecab9bc46f496bc070)中介绍`observable.shallow`的更技术上正确的ES5等效。'
- en: 'The snippet below shows the `items` and `metadata` properties, marked as *shallow
    observables*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段显示了`items`和`metadata`属性，标记为*浅观察对象*：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will be covering a few more decorators in a later chapter, but we did not
    want to wait until then to discuss the decorator syntax. We definitely think you
    should pick decorators as your first choice for declaring observables. Note that
    they are only available inside classes. However, the vast majority of the time,
    you will be using classes to model your observable tree, so decorators greatly
    help in making it more readable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中介绍更多的装饰器，但我们不想等到那时才讨论装饰器语法。我们认为你应该首选装饰器来声明可观察对象。请注意，它们只在类内部可用。然而，绝大多数情况下，您将使用类来建模您的可观察树，所以装饰器在使其更可读方面非常有帮助。
- en: Actions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动
- en: Although you can change an observable directly, it is highly recommended that
    you use *actions* to do it. If you remember, in the previous chapter, we saw that
    actions are the ones that cause a state-change. The UI simply fires the actions
    and expects some observables to be mutated. Actions hide the details of how the
    mutation should happen or what observables should be affected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以直接更改可观察对象，但强烈建议您使用*actions*来执行。如果您还记得，在上一章中，我们看到动作是导致状态变化的原因。UI只是触发动作，并期望一些可观察对象被改变。动作隐藏了变异应该如何发生或哪些可观察对象应该受到影响的细节。
- en: 'The diagram below is a reminder that **UI** can modify the **State** only via
    an **Action**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表提醒我们，**UI**只能通过**Action**来修改**State**：
- en: '![](../images/00016.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: 'Actions introduce *vocabulary* into the UI and give declarative names to the
    operations that mutate the state. MobX embraces this idea completely and makes
    actions a *first-class* concept. To create an action, we simply wrap the mutating
    function inside the `action()` API. This gives us back a function that can be
    invoked just like the original passed-in function. Take a look at this code block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 行动在UI中引入了*词汇*，并为改变状态的操作提供了声明性的名称。MobX完全接受了这个想法，并将行动作为*一流*的概念。要创建一个动作，我们只需在`action()`API中包装变异函数。这会给我们一个可以像原始传入的函数一样调用的函数。看一下这段代码：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding snippet, we have introduced two actions: `addItem()` and `removeItem()`,
    which add and remove an item to and from the `cart` observable. Since `action()` returns
    a function that forwards arguments to the passed-in function, we can invoke `addItem()` and
    `removeItem()` with the required arguments.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们介绍了两个动作：`addItem()`和`removeItem()`，它们向`cart`可观察对象添加和移除项目。由于`action()`返回一个将参数转发给传入函数的函数，我们可以使用所需的参数调用`addItem()`和`removeItem()`。
- en: Besides improving the readability of the code, actions also boost performance
    of MobX. By default, when you modify an observable, MobX will *immediately* fire
    a notification for the change. If you are modifying a bunch of observables together,
    you would rather fire the change notifications after all of them are modified.
    This would reduce the noise of too many notifications and also treat the set of
    changes as one *atomic transaction*. These are, in essence, the core responsibilities
    of an `action()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改善代码的可读性外，动作还提高了MobX的性能。默认情况下，当您修改一个可观察对象时，MobX会*立即*发出更改的通知。如果您一起修改一堆可观察对象，您可能希望在所有这些对象都被修改后再发出更改通知。这将减少太多通知的噪音，并将一组更改视为一个*原子事务*。这实质上是一个`action()`的核心责任。
- en: Enforcing the use of actions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制使用动作
- en: It should come as no surprise that MobX strongly recommends using *actions*
    for modifying observables. In fact, this can be made mandatory by configuring
    MobX to always enforce this policy, also called the **strict mode**. The `configure()`
    function can be used to set the `enforceActions` option to true. MobX will now
    throw an error if you try to modify an observable outside of an action.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，MobX强烈建议使用*actions*来修改可观察对象。事实上，通过配置MobX始终强制执行此策略，也称为**strict mode**，可以使此操作成为强制性的。`configure()`函数可用于将`enforceActions`选项设置为true。如果尝试在动作之外修改可观察对象，MobX现在将抛出错误。
- en: 'Going back to our previous example with `cart`, if we try to modify it *outside* an
    *action*, MobX will fail with an error, as you can see from the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前关于`cart`的例子，如果我们尝试在*动作*之外*修改*它，MobX将会出现错误，如下例所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is one little thing to remember regarding the use of `configure({ enforceActions:
    true })`: It will only throw errors if there are observers watching the observables
    that you are trying to mutate. If there are no observers for those observables,
    MobX will safely ignore it. This is because there is no risk of triggering reactions
    too early. However, if you do want to be strict about this, you can also set `{
    enforceActions: ''strict'' }`. This will throw an error even if there are no observers
    attached to the mutating observables.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '关于使用`configure({ enforceActions: true })`有一件小事需要记住：它只会在有观察者观察您尝试改变的可观察对象时才会抛出错误。如果没有观察者观察这些可观察对象，MobX将安全地忽略它。这是因为没有触发反应过早的风险。但是，如果您确实想严格执行此操作，还可以设置`{
    enforceActions: ''strict'' }`。即使没有观察者附加到变异的可观察对象，这也会抛出错误。'
- en: Decorating actions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰动作
- en: 'The use of decorators is pervasive in MobX. Actions also get special treatment
    with the `@action` decorator to mark class methods as actions. With decorators,
    the `Cart` class can be written as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在MobX中是无处不在的。动作也通过`@action`装饰器获得特殊处理，以将类方法标记为动作。使用装饰器，`Cart`类可以编写如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, we used `@action.bound` for the `removeItem()` action.
    This is a special form that pre-binds the instance of the class to the method.
    This means you can pass around the reference to `removeItem()` and be assured
    that the `this` value always points to the instance of the Cart.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为`removeItem()`动作使用了`@action.bound`。这是一种特殊形式，可以预先绑定类的实例到该方法。这意味着您可以传递对`removeItem()`的引用，并确保`this`值始终指向Cart的实例。
- en: 'A different way of declaring the `removeItem` action with a pre-bound `this`
    is with the use of class properties and arrow-functions. This can be seen in the
    following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类属性和箭头函数预先绑定`this`声明`removeItem`动作的另一种方式是。以下代码中可以看到这一点：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `removeItem` is a *class-property* whose value is an *arrow-function*.
    Because of the *arrow-function*, it binds to the *lexical* `this`, which is the
    instance of the `Cart`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`removeItem`是一个*类属性*，其值是一个*箭头函数*。由于*箭头函数*，它绑定到*词法*`this`，即`Cart`的实例。
- en: Reactions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应
- en: '**Reactions** can really change the world for your app. They are the side-effect
    causing behaviors that react to the changes in observables. Reactions complete
    the core triad of MobX and act as the observers of the observables. Take a look
    at this diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reactions**确实可以改变您的应用程序世界。它们是对可观察对象变化做出反应的副作用行为。反应完成了MobX的核心三部曲，并充当可观察对象的观察者。看一下这个图表：'
- en: '![](../images/00017.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: MobX gives you three different ways to express your reactions or side-effects.
    These are `autorun()`, `reaction()`, and `when()`. Let's see each of these in
    turn.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MobX为您提供了三种不同的方式来表达您的反应或副作用。这些是`autorun()`，`reaction()`和`when()`。让我们依次看看每一个。
- en: autorun()
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: autorun()
- en: '`autorun()` is a long-running side-effect that takes in a function (`effect-function`)
    as its argument. The `effect-function` function is where you apply all your side-effects.
    Now, these side-effects may depend on one or more observables. MobX will automatically
    keep track of any change happening to these *dependent* observables and re-execute
    this function to apply the side-effect. It''s easier to see this in code, as shown
    here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`autorun()` 是一个长时间运行的副作用，它接受一个函数（`effect-function`）作为参数。`effect-function` 函数是你应用所有副作用的地方。现在，这些副作用可能依赖于一个或多个
    observables。MobX 将自动跟踪这些 *dependent* observables 的任何变化，并重新执行此函数以应用副作用。在代码中更容易看到这一点，如下所示：'
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example we are logging an *observable* (`this.items.length`)
    to the console. The logging happens *immediately* and also any time the observable
    changes. This is the defining characteristic of `autorun()`; it runs immediately
    and also on every change to the dependent observables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将一个 *observable*（`this.items.length`）记录到控制台。记录会*立即*发生，也会在 observable
    变化时发生。这是 `autorun()` 的定义特征；它立即运行，并且在 dependent observables 变化时也会运行。
- en: 'We mentioned earlier that `autorun()` is a long-running side-effect and continues
    as long as you don''t explicitly stop it. But then, how do you actually stop it?
    Well, the return-value of `autorun()` is a function that is in fact a `disposer-function`.
    By calling it, you can cancel the `autorun()` side-effect. Take a look at this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到 `autorun()` 是一个长时间运行的副作用，只要你不明确停止它，它就会继续。但是，你如何实际停止它呢？嗯，`autorun()` 的返回值实际上是一个函数，它实际上是一个
    `disposer-function`。通过调用它，你可以取消 `autorun()` 的副作用。看一下这个：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding snippet, we are storing the return-value of `autorun()` (a
    `disposer-function`) in a class property: `cancelAutorun`. By invoking it just
    after instantiating `Cart`, we have canceled the side-effect. Now `autorun()`
    only prints once, and never again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们将 `autorun()` 的返回值（一个 `disposer-function`）存储在一个类属性中：`cancelAutorun`。在实例化
    `Cart` 后立即调用它，我们取消了副作用。现在 `autorun()` 只打印一次，再也不会打印了。
- en: 'Quick Reader Question: Why does it print only once? Since we are cancelling
    immediately, shouldn''t `autorun()` skip printing altogether? The answer to this
    is to refresh the core characteristic of `autorun`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 快速阅读者问题：为什么它只打印一次？因为我们立即取消了，`autorun()` 不应该完全跳过打印吗？对此的答案是刷新 `autorun` 的核心特征。
- en: reaction()
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reaction()
- en: '`reaction()` is yet another kind of reaction in MobX. Yes, the choice of the
    API name was intentional. `reaction()` is similar to `autorun()` but waits for
    a change in the observables before executing the `effect-function`. `reaction()`
    in fact takes two arguments, which are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`reaction()` 是 MobX 中另一种反应的方式。是的，API 名称的选择是有意的。`reaction()` 类似于 `autorun()`，但在执行
    `effect-function` 之前等待 observables 的变化。`reaction()` 实际上接受两个参数，如下所示：'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`tracker-function` is where all the observables are tracked. Any time the tracked
    observables change, it will re-execute. It is supposed to return a value that
    is used to compare it to the previous run of `tracker-function`. If these return-values
    differ, the `effect-function` is executed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracker-function` 是跟踪所有 observables 的地方。任何时候跟踪的 observables 发生变化，它都会重新执行。它应该返回一个值，用于与上一次运行的
    `tracker-function` 进行比较。如果这些返回值不同，就会执行 `effect-function`。'
- en: By breaking up the activity of a reaction into a change-detecting function (`tracker`
    function) and the `effect` function, `reaction()` gives us more fine-grained control
    over when a side-effect should be caused. It is no longer just dependent on the
    observables it is tracking inside the `tracker` function. Instead, it now depends
    on the data returned by the tracker function. The `effect` function receives this
    data in its input. Any observables used in the effect function are not tracked.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将反应的活动分解为一个检测变化的函数（`tracker`函数）和`effect`函数，`reaction()`使我们对何时引起副作用有了更精细的控制。它不再仅仅依赖于`tracker`函数内部跟踪的可观察对象。相反，它现在取决于`tracker`函数返回的数据。`effect`函数接收这些数据作为输入。在效果函数中使用的任何可观察对象都不会被跟踪。
- en: Just like `autorun()`, you also get a `disposer` function as the return-value
    of `reaction()`. This can be used to cancel the side-effect anytime you want.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`autorun()`一样，你还会得到一个`disposer`函数作为`reaction()`的返回值。这可以用来随时取消副作用。
- en: 'We can put this into practice with an example. Let''s say you want to be notified
    anytime an item in your `Cart` changes its price. After all, you don''t want to
    purchase something that suddenly shoots up in price. At the same time, you don''t
    want to miss out on a great deal as well. So, getting a notification when the
    price changes is a useful thing to have. We can implement this by using `reaction()`,
    as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个例子来实践这一点。假设你想在你的`购物车`中的任何物品价格变化时得到通知。毕竟，你不想购买突然涨价的东西。与此同时，你也不想错过一个好的交易。因此，当价格变化时得到通知是一个有用的功能。我们可以通过使用`reaction()`来实现这一点，如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding snippet, we are setting up a price tracker in *comment 1*,
    as a *reaction to track price changes*. Notice that it takes two functions as
    inputs. The first function (`tracker-function`) finds the item with the given
    `name` and returns its price as the output of the `tracker` function. Any time
    it changes, the corresponding `effect` function is executed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们在*注释1*中设置了一个价格跟踪器，作为*跟踪价格变化的反应*。请注意，它接受两个函数作为输入。第一个函数（`tracker-function`）找到具有给定`name`的物品，并将其价格作为`tracker`函数的输出返回。每当它变化时，相应的`effect`函数就会被执行。
- en: The console logs also print only when the price changes. This is exactly the
    behavior we wanted and achieved through a `reaction()`. Now that you are notified
    of the price changes, you can make better buying decisions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志也只在价格变化时打印。这正是我们想要的行为，并通过`reaction()`实现了。现在你已经被通知价格变化，你可以做出更好的购买决策。
- en: A reactive UI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式UI
- en: On the topic of reactions, it is worth mentioning that the UI is one of the
    most glorious reactions (or side-effect) you can have in an app. As we saw in
    the earlier chapter, *UI* depends on data and applies a transformation function
    to generate the visual representation. In the MobX world, this UI is also reactive,
    in the sense that it reacts to the changes in data and automatically re-renders
    itself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到反应时，值得一提的是UI是应用程序中最辉煌的反应（或副作用）之一。正如我们在前一章中看到的那样，*UI*依赖于数据，并应用转换函数来生成视觉表示。在MobX世界中，这个UI也是响应式的，它对数据的变化做出反应，并自动重新渲染自己。
- en: MobX provides a companion library called ***mobx-react*** that has bindings
    to React. By using a decorator function (`observer()`***) ***from `mobx-react`,
    you can transform a react component to observe the observables used in the `render()`
    function. When they change, a re-render of the react component is triggered. Internally,
    `observer()` creates a wrapper component that uses a plain `reaction()` to watch
    the observables and re-render as a side-effect. This is why we treat UI as being
    just another side-effect, albeit a very visible and obvious one.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MobX提供了一个名为***mobx-react***的伴侣库，它与React绑定。通过使用来自`mobx-react`的装饰器函数（`observer()`***），您可以将React组件转换为观察`render()`函数中使用的可观察对象。当它们发生变化时，会触发React组件的重新渲染。在内部，`observer()`创建一个包装组件，该组件使用普通的`reaction()`来监视可观察对象并重新渲染为副作用。这就是为什么我们将UI视为另一个副作用，尽管是一个非常显而易见的副作用。
- en: 'A short example of using `observer()` is shown next. We are using a **stateless
    functional component,** which we are passing to the observer. Since we are reading
    the `item` observable, the component will now react to changes in `item`. After
    two seconds, when we update `item`, the `ItemComponent` will automatically re-render.
    Take a look at this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了使用`observer()`的简短示例。我们使用了一个**无状态函数组件**，将其传递给observer。由于我们正在读取`item`可观察对象，因此组件现在将对`item`的更改做出反应。两秒后，当我们更新`item`时，`ItemComponent`将自动重新渲染。看一下这个：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will cover `mobx-react` in [Chapter 3](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070), *A
    React App with MobX*, and also throughout this book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070)中涵盖`mobx-react`，*使用MobX的React应用程序*，并且在整本书中都会涉及。
- en: when()
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: when()
- en: As the name suggests, `when()` only executes the `effect-function` *when a condition
    is met* and automatically disposes the side-effect after that. Thus, `when()`
    is a one-time side-effect compared to `autorun()` and `reaction()`, which are
    long-running. The `predicate` function normally relies on some observables to
    do the conditional checks. If the observables change, the `predicate` function
    will be re-evaluated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`when()`仅在满足条件时执行`effect-function`，并在此之后自动处置副作用。因此，与`autorun()`和`reaction()`相比，`when()`是一次性副作用。`predicate`函数通常依赖于一些可观察对象来进行条件检查。如果可观察对象发生变化，`predicate`函数将被重新评估。
- en: '`when()` takes two arguments, which are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()`接受两个参数，如下所示：'
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `predicate`function is expected to return a Boolean value. When it becomes
    `true`, the `effect` function is executed, and the `when()` is automatically disposed.
    Note that `when()` also gives you back a `disposer` function that you can call
    to prematurely cancel the side-effect.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`predicate`函数预计返回一个布尔值。当它变为`true`时，执行`effect`函数，并且`when()`会自动处置。请注意，`when()`还会返回一个`disposer`函数，您可以调用它来提前取消副作用。'
- en: 'In this following code block, we are monitoring the availability of an item
    and notifying the user when it is back in stock. This is the case of a one-time
    effect that you don''t really have to continuously monitor. It''s only when the
    item count in the inventory goes above zero, that you execute the side-effect
    of notifying the user. Take a look at this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们正在监视物品的可用性，并在其重新上架时通知用户。这是一次性效果，您不必持续监视。只有当库存中的物品数量超过零时，您才会执行通知用户的副作用。看一下这个：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`when()` here takes two arguments. The `predicate`function returns true when
    the `item.quantity` is greater than zero. The `effect` function simply notifies
    (via `console.log`) that the item is available in the store. When the predicate
    becomes true, `when()` executes the side-effect and automatically disposes itself.
    Thus, when we add two pairs of shoes into the inventory, `when()` executes and
    logs the availability.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`when()`接受两个参数。`predicate`函数在`item.quantity`大于零时返回true。`effect`函数只是通过`console.log`通知物品在商店中可用。当predicate变为true时，`when()`执行副作用并自动处理自身。因此，当我们将两双鞋子添加到库存时，`when()`执行并记录可用性。
- en: Notice that when we add one more pair of shoes into the inventory, no logs are
    printed. This is because at this time `when()` has been disposed and is no longer
    monitoring the availability of *Shoes*. This is the one-time effect of `when()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们将一双鞋子添加到库存中时，不会打印任何日志。这是因为此时`when()`已被处理并且不再监视*Shoes*的可用性。这是`when()`的一次性效果。
- en: when() with a promise
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有promise的when()
- en: 'There is a special version of `when()`, which takes only one argument (the
    `predicate` function), and gives back a promise instead of the `disposer` function.
    This is a nice trick where you can skip using the `effect` function and instead
    wait for `when()` to resolve before executing the effect. This is easier to see
    in code, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()`还有一个特殊版本，只接受一个参数（`predicate`函数），并返回一个promise而不是`disposer`函数。这是一个很好的技巧，您可以跳过使用`effect`函数，而是等待`when()`解析后再执行效果。在代码中更容易看到，如下所示：'
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In *comment 1*, we are waiting for the availability of the item using `when()`
    that only takes the `predicate` function. By using the `async-await` operators
    to wait for the promise, we get clean, readable code. Any code that follows the
    `await` statement is automatically scheduled to execute after the promise resolves.
    This is a nicer form of using `when()` if you prefer *not* to pass an effect callback.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*注释1*中，我们正在使用只接受`predicate`函数的`when()`来等待物品的可用性。通过使用`async-await`操作符等待promise，我们可以得到清晰、可读的代码。在`await`语句后面的任何代码都会在promise解析后自动安排执行。如果您*不*想传递一个效果回调，这是使用`when()`的更好方式。
- en: '`when()` is also very efficient and does not poll the `predicate` function
    to check for changes. Instead, it relies on the MobX reactivity system to re-evaluate
    the `predicate` function, when the underlying observables change.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()`也非常高效，不会轮询`predicate`函数以检查更改。相反，它依赖于MobX反应性系统在基础可观察对象发生变化时重新评估`predicate`函数。'
- en: Quick recap on reactions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于反应的快速回顾
- en: MobX offers a couple of ways to execute side-effects, but you have to identify
    which one fits your needs. Here is a quick round-up that can help you in making
    the right choice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: MobX提供了几种执行副作用的方式，但您必须确定哪种适合您的需求。以下是一个快速总结，可以帮助您做出正确的选择。
- en: 'We have three ways of running side-effects:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种运行副作用的方式：
- en: '`autorun( effect-function: () => {} )`: Useful for long-running side-effects.
    The `effect` function executes immediately and also anytime the dependent observables
    (used within it) change. It returns a `disposer`function that can be used to cancel
    anytime.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`autorun( effect-function: () => {} )`：对于长时间运行的副作用很有用。`effect`函数立即执行，也会在其中使用的依赖可观察对象（在其内部使用）发生变化时执行。它返回一个`disposer`函数，可以随时用于取消。'
- en: '`reaction( tracker-function: () => data, effect-function: (data) => {} )`: Also
    for long-running side-effects. It executes the `effect` function only when the
    data returned by the `tracker` function is different. In other words, `reaction()`
    waits for a change in the observables before any side-effects are run. It also
    gives back a `disposer` function to cancel the effect prematurely.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reaction( tracker-function: () => data, effect-function: (data) => {} )`:
    也用于长时间运行的副作用。只有当`tracker`函数返回的数据不同时，才执行`effect`函数。换句话说，`reaction()`在可观察对象发生变化之前等待。它还返回一个`disposer`函数，以提前取消效果。'
- en: '`when( predicate-function: () => boolean, effect-function: () => {} )`: Useful
    for one-off effects. The `predicate` function is evaluated anytime its dependent
    observables change. It executes the `effect` function only when the `predicate`
    function returns `true`***.*** `when()` automatically disposes itself after running
    the `effect` function. There is a special form of `when()` that only takes in
    the `predicate` function and returns a promise. Use it with `async-await` for
    a simpler `when()`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`when( predicate-function: () => boolean, effect-function: () => {} )`: 用于一次性效果。`predicate`函数在其依赖的可观察对象发生变化时进行评估。只有当`predicate`函数返回`true`时，才执行`effect`函数。`when()`在运行`effect`函数后会自动处理自身。还有一种特殊形式的`when()`，只接受`predicate`函数并返回一个promise。可以与`async-await`一起使用以简化`when()`。'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The story of MobX revolves around observables. Actions mutate these observables.
    Derivations and Reactions observe and react to changes to these observables. Observables,
    actions, and reactions form the core triad.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的故事围绕着可观察对象展开。操作改变这些可观察对象。派生和反应观察并对这些可观察对象的变化做出反应。可观察对象、操作和反应构成了核心三元组。
- en: We have seen several ways to shape your observables with objects, arrays, maps,
    and boxed observables. Actions are the recommended way to modify observables.
    They add to the vocabulary of operations and boost performance by minimizing change
    notifications. Reactions are the observers that react to changes in observables.
    They are the ones causing side-effects in the app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种用对象、数组、映射和包装可观察对象来塑造你的可观察对象的方法。操作是修改可观察对象的推荐方式。它们增加了操作的词汇量，并通过最小化变更通知来提高性能。反应是观察者，它们对可观察对象的变化做出反应。它们是导致应用程序产生副作用的原因。
- en: Reactions come in three flavors, `autorun()`, `reaction()`, and`when()`, and
    distinguish themselves as being long-running or one-time. `when()`, the only one-time
    effector, comes in a simpler form, where it can return a promise, given a `predicate`
    function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 反应有三种形式，`autorun()`、`reaction()`和`when()`，它们以长时间运行或一次性运行的方式区分自己。`when()`是唯一的一次性效果器，它有一个更简单的形式，可以在给定`predicate`函数的情况下返回一个promise。
