- en: The React Component Lifecycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件生命周期
- en: The goal of this chapter is for you to learn about the lifecycle of React components
    and how to write code that responds to lifecycle events. You'll learn why components
    need a lifecycle in the first place. Then, you'll implement several components
    that initialize their properties and state using these methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让您了解React组件的生命周期以及如何编写响应生命周期事件的代码。您将学习为什么组件首先需要生命周期。然后，您将使用这些方法实现几个初始化其属性和状态的组件。
- en: Next, you'll learn about how to optimize the rendering efficiency of your components
    by avoiding rendering when it isn't necessary. Then, you'll see how to encapsulate
    imperative code in React components and how to clean up when components are unmounted.
    Finally, you'll learn how to capture and handle errors using new React 16 lifecycle
    methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何通过避免在不必要时进行渲染来优化组件的渲染效率。然后，您将了解如何在React组件中封装命令式代码以及在组件卸载时如何进行清理。最后，您将学习如何使用新的React
    16生命周期方法捕获和处理错误。
- en: Why components need a lifecycle
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件为什么需要生命周期
- en: React components go through a lifecycle. In fact, the `render()` method that
    you've implemented in your components so far in this book is actually a lifecycle
    method. Rendering is just one lifecycle event in a React component.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: React组件经历生命周期。实际上，您在本书中迄今为止在组件中实现的`render()`方法实际上是一个生命周期方法。渲染只是React组件中的一个生命周期事件。
- en: For example, there are lifecycle events for when the component is mounted to
    the DOM, when the component is updated, and so on. Lifecycle events are yet another
    moving part, so you'll want to keep them to a minimum. As you'll learn in this
    chapter, some components do need to respond to lifecycle events to perform initialization,
    render heuristics, clean up after the component when it's unmounted from the DOM,
    or to handle errors thrown by the component.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当组件挂载到DOM时，当组件更新时等都有生命周期事件。生命周期事件是另一个移动部分，因此您希望将其保持最少。正如您将在本章中学到的那样，一些组件确实需要响应生命周期事件以执行初始化、渲染启发式、在组件从DOM中卸载时进行清理，或者处理组件抛出的错误。
- en: 'The following diagram gives you an idea of how a component flows through its
    lifecycle, calling the corresponding methods in turn:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表让您了解组件如何通过其生命周期流程，依次调用相应的方法：
- en: '![](Images/d221b7fd-e25f-492e-a4bb-dc37f6939493.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d221b7fd-e25f-492e-a4bb-dc37f6939493.png)'
- en: 'These are the two main lifecycle flows of a React component. The first happens
    when the component is initially rendered. The second happens whenever the component
    is updated. Here''s a rough overview of each of the methods:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是React组件的两个主要生命周期流程。第一个发生在组件初始渲染时。第二个发生在组件更新时。以下是每个方法的大致概述：
- en: '`getDerivedStateFromProps()`: This method allows you to update the state of
    the component based on property values of the component. This method is called
    when the component is initially rendered and when it receives new property values.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDerivedStateFromProps()`: 此方法允许您根据组件的属性值更新组件的状态。当组件首次渲染和接收新的属性值时，将调用此方法。'
- en: '`render()`: Returns the content to be rendered by the component. This is called
    when the component is first mounted to the DOM, when it receives new property
    values, and when `setState()` is called.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`: 返回组件要渲染的内容。当组件首次挂载到DOM时，当它接收新的属性值时以及调用`setState()`时都会调用此方法。'
- en: '`componentDidMount()`: This is called after the component is mounted to the
    DOM. This is where you can perform component initialization work, such as fetching
    data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount()`: 这在组件挂载到DOM后调用。这是您可以执行组件初始化工作的地方，例如获取数据。'
- en: '`shouldComponentUpdate()`: You can use this method to compare new state or
    props with current state or props. Then, you can return false if there''s no need
    to re-render the component. This method is used to to make your components more
    efficient.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate()`: 您可以使用此方法将新状态或属性与当前状态或属性进行比较。然后，如果不需要重新渲染组件，可以返回false。此方法用于使您的组件更有效。'
- en: '`getSnapshotBeforeUpdate()`: This method lets you perform operations directly
    on DOM elements of your component before they''re actually committed to the DOM.
    The difference between this method and `render()` is that `getSnapshotBeforeUpdate()`
    isn''t asynchronous. With `render()`, there''s a good chance that the DOM structure
    could change between when it''s called and when the changes are actually made
    in the DOM.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSnapshotBeforeUpdate()`: 此方法允许您在实际提交到DOM之前直接在组件的DOM元素上执行操作。此方法与`render()`的区别在于`getSnapshotBeforeUpdate()`不是异步的。使用`render()`时，调用它和实际在DOM中进行更改之间的DOM结构可能会发生变化的可能性很大。'
- en: '`componentDidUpdate()`: This is called when the component is updated. It''s
    rare that you''ll have to use this method.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate()`: 当组件更新时调用此方法。您很少需要使用此方法。'
- en: The other lifecycle method that isn't included in this diagram is `componentWillUnmount()`.
    This is the only lifecycle method that's called when a component is about to be
    removed. We'll see an example of how to use this method at the end of the chapter.
    On that note, let's get coding.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表中未包括的另一个生命周期方法是`componentWillUnmount()`。这是组件即将被移除时调用的唯一生命周期方法。我们将在本章末尾看到如何使用此方法的示例。在此之前，让我们开始编码。
- en: Initializing properties and state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化属性和状态
- en: In this section, you'll see how to implement initialization code in React components.
    This involves using lifecycle methods that are called when the component is first
    created. First, you'll implement a basic example that sets the component up with
    data from the API. Then, you'll see how state can be initialized from properties,
    and also how state can be updated as properties change.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到如何在React组件中实现初始化代码。这涉及使用在组件首次创建时调用的生命周期方法。首先，您将实现一个基本示例，该示例使用来自API的数据设置组件。然后，您将看到如何从属性初始化状态，以及如何在属性更改时更新状态。
- en: Fetching component data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取组件数据
- en: 'When your components are initialized you''ll want to populate their state or
    properties. Otherwise, the component won''t have anything to render other than
    its skeleton markup. For instance, let''s say you want to render the following
    user list component:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化组件时，您将希望填充其状态或属性。否则，组件除了其骨架标记之外将没有任何内容可渲染。例如，假设您想要渲染以下用户列表组件：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are three pieces of data that this JSX relies on:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此JSX依赖于三个数据：
- en: '`loading`: This message is displayed while fetching API data'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载中：在获取API数据时显示此消息
- en: '`error`: This message is displayed if something goes wrong'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`: 如果出现问题，将显示此消息'
- en: '`users`: Data fetched from the API'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`: 从API获取的数据'
- en: 'There are two helper components used here: `ErrorMessage` and `LoadingMessage`.
    They''re used to format the `error` and the `loading` state, respectively. However,
    if `error` or `loading` are null, you don''t want to have to introduce imperative
    logic into your component to handle this scenario. This is why you''re using a
    cool little trick with `Immutable.js` maps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用了两个辅助组件：`ErrorMessage`和`LoadingMessage`。它们分别用于格式化`error`和`loading`状态。但是，如果`error`或`loading`为null，您不希望在组件中引入命令式逻辑来处理此情况。这就是为什么您使用`Immutable.js`映射的一个很酷的小技巧：
- en: You create a map that has a single **key-value pair**. The key is null, and
    the value is null.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个具有单个**键值对**的映射。键为null，值也为null。
- en: You call `get()` with either an `error` or a `loading` property. If the `error`
    or `loading` property is null, then the key is found and nothing is rendered.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`error`或`loading`属性调用`get()`。如果`error`或`loading`属性为null，则找到键并且不渲染任何内容。
- en: '`get()` accepts a second parameter that''s returned if no key is found. This
    is where you pass in your *truthy* value and avoid imperative logic altogether.
    This specific component is simple, but the technique is especially powerful when
    there are more than two possibilities.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get()`接受第二个参数，如果找不到键，则返回该参数。这是您传递您的*真值*值并完全避免命令逻辑的地方。这个特定的组件很简单，但是当存在两种以上可能性时，这种技术尤其强大。'
- en: 'How should you go about making the API call and using the response to populate
    the `users` collection? The answer is to use a container component that makes
    the API call and then renders the `UserList` component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该如何进行API调用并使用响应来填充`users`集合？答案是使用一个容器组件进行API调用，然后渲染`UserList`组件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's take a look at the `render()` method. It's job is to render the `<UserList>`
    component, passing in `this.state` as properties. The actual API call happens
    in the `componentDidMount()` method. This method is called after the component
    is mounted into the DOM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`render()`方法。它的工作是渲染`<UserList>`组件，并将`this.state`作为属性传递。实际的API调用发生在`componentDidMount()`方法中。此方法在组件挂载到DOM后调用。
- en: Due to the naming of `componentDidMount()`, React developers think that it's
    bad to wait until the component is mounted to the DOM before issuing requests
    for component data. In other words, the user experience might suffer if React
    has to perform a lot of work before the request is even sent. In reality, fetching
    data is an asynchronous task and initiating it before or after `render()` makes
    no real difference as far as your application is concerned.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`componentDidMount()`的命名，React开发人员认为在发出组件数据的请求之前等待组件挂载到DOM是不好的。换句话说，如果React在发送请求之前必须执行大量工作，用户体验可能会受到影响。实际上，获取数据是一个异步任务，在`render()`之前或之后启动它对您的应用程序来说没有真正的区别。
- en: You can read more about this here: [https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里阅读更多信息：[https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html)
- en: 'Once the API call returns with data, the `users` collection is populated, causing
    the `UserList` to re-render itself, only this time, it has the data it needs. Let''s
    take a look at the `users()` mock API function call used here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API调用返回数据，`users`集合就会被填充，导致`UserList`重新渲染自身，只是这一次，它有了需要的数据。让我们来看看这里使用的`users()`模拟API函数调用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It returns a promise that's resolved with an array after 2 seconds. Promises
    are a good tool for mocking things like API calls because they enable you to use
    more than HTTP calls as a data source in your React components. For example, you
    might be reading from a local file or using a library that returns promises that
    resolve data from various sources.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个在2秒后解析为数组的promise。Promise是模拟诸如API调用之类的东西的好工具，因为它们使您能够在React组件中使用不止HTTP调用作为数据源。例如，您可能正在从本地文件中读取数据，或者使用返回解析来自各种来源的数据的库。
- en: 'Here''s what the `UserList` component renders when the `loading` state is a
    string, and the `users` state is an empty array:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当`loading`状态为字符串，`users`状态为空数组时，`UserList`组件渲染如下：
- en: '![](Images/96766a75-d06b-4aa7-bd38-854a10e61098.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/96766a75-d06b-4aa7-bd38-854a10e61098.png)'
- en: 'Here''s what it renders when `loading` is `null` and `users` is non-empty:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当`loading`为`null`且`users`不为空时，它渲染如下：
- en: '![](Images/e2a88063-51bf-4331-b5cc-544e7d75ea7b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e2a88063-51bf-4331-b5cc-544e7d75ea7b.png)'
- en: I want to reiterate the separation of responsibilities between the `UserListContainer`
    and the `UserList` components. Because the container component handles the lifecycle
    management and the actual API communication, you can create a generic user list
    component. In fact, it's a functional component that doesn't require any state,
    which means you can reuse it in other container components throughout your application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我想再次强调`UserListContainer`和`UserList`组件之间的责任分离。因为容器组件处理生命周期管理和实际的API通信，你可以创建一个通用的用户列表组件。事实上，它是一个不需要任何状态的功能组件，这意味着你可以在应用程序中的其他容器组件中重用它。
- en: Initializing state with properties
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性初始化状态
- en: The preceding example showed you how to initialize the state of a container
    component by making an API call in the `componentDidMount()` lifecycle method.
    However, the only populated part of the component state is the `users` collection.
    You might want to populate other pieces of state that don't come from API endpoints.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子向你展示了如何通过在`componentDidMount()`生命周期方法中进行API调用来初始化容器组件的状态。然而，组件状态中唯一填充的部分是`users`集合。你可能想填充其他不来自API端点的状态部分。
- en: 'For example, the `error` and `loading` state messages have default values set
    when the state is initialized. This is great, but what if the code that is rendering
    `UserListContainer` wants to use a different loading message? You can achieve
    this by allowing properties to override the default state. Let''s build on the
    `UserListContainer` component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当状态初始化时，`error`和`loading`状态消息已经设置了默认值。这很好，但是如果渲染`UserListContainer`的代码想要使用不同的加载消息怎么办？你可以通过允许属性覆盖默认状态来实现这一点。让我们继续完善`UserListContainer`组件：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `loading` property no longer has a default string value. Instead, `defaultProps` provides
    default values for properties. The new lifecycle method is `getDerivedStateFromProps()`.
    It uses the `loading` property to set the `loading` state the state. Since the
    `loading` property has a default value, it's safe to just change the state. The
    method is called before the component mounts and on subsequent re-renders of the
    component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`loading`属性不再具有默认字符串值。相反，`defaultProps`为属性提供默认值。新的生命周期方法是`getDerivedStateFromProps()`。它使用`loading`属性来设置`loading`状态。由于`loading`属性有一个默认值，所以只需改变状态是安全的。该方法在组件挂载之前和组件的后续重新渲染时被调用。'
- en: This method is static because of internal changes in React 16\. The expectation
    is that this method behaves like a pure function and has no side-effects. If this
    method were an instance method, you would have access to the component context
    and side-effects would be commonplace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是静态的，因为在React 16中有内部变化。预期这个方法的行为像一个纯函数，没有副作用。如果这个方法是一个实例方法，你将可以访问组件上下文，并且副作用将很常见。
- en: The challenge with this new React 16 method is that it's called on initial render
    and on subsequent re-renders. Prior to React 16, you could use the `componentWillMount()`
    method for code that you only want to run prior to the initial render. In this
    example, you have to check whether there are values in the `users` collection
    before setting the `loading` state to null – you don't know if this is the initial
    render or the 40th render.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的React 16方法的挑战在于它在初始渲染和后续重新渲染时都会被调用。在React 16之前，你可以使用`componentWillMount()`方法来运行只在初始渲染之前运行的代码。在这个例子中，你必须检查`users`集合中是否有值，然后再将`loading`状态设置为null
    - 你不知道这是初始渲染还是第40次渲染。
- en: 'Let''s see how we can pass state data to `UserListContainer` now:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将状态数据传递给`UserListContainer`：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what the initial loading message looks like when `UserList` is first
    rendered:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次渲染`UserList`时，初始加载消息是什么样子的：
- en: '![](Images/70f311e6-6a6c-4c1f-8d6c-dcd3eb3496c3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/70f311e6-6a6c-4c1f-8d6c-dcd3eb3496c3.png)'
- en: Just because the component has state doesn't mean that you can't allow for customization.
    Next, you'll learn a variation on this concept—updating component state with properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为组件有状态并不意味着你不能进行定制。接下来，你将学习这个概念的一个变种——使用属性更新组件状态。
- en: Updating state with properties
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性更新状态
- en: You've seen how the `componentDidMount()` and `getDerivedStateFromProps()` lifecycle
    methods help get your component the data it needs. There's one more scenario that
    you need to consider—re-rendering the component container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了`componentDidMount()`和`getDerivedStateFromProps()`生命周期方法如何帮助你的组件获取所需的数据。还有一个情景你需要考虑——重新渲染组件容器。
- en: 'Let''s take a look at a simple `button` component that tracks the number of
    times it''s been clicked:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的`button`组件，它会跟踪被点击的次数：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s implement a container component for this feature:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个功能实现一个容器组件：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same approach as the preceding example is used here. The `getDerivedStateFromProps()`
    method is called before every render and this is where you can use prop values
    to figure out if and how the component state should be updated. Let''s see how
    to re-render this component and whether or not the state behaves as expected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子相同的方法在这里也被使用。`getDerivedStateFromProps()`方法在每次渲染之前被调用，这是你可以使用属性值来确定组件状态是否应该更新的地方。让我们看看如何重新渲染这个组件以及状态是否如预期般行为：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sure enough, everything goes as planned. Whenever the button is clicked, the
    click counter is updated. `<MyFeature>` is re-rendered every 3 seconds, toggling
    the `disabled` state of the button. When the button is re-enabled and clicking
    resumes, the counter continues from where it left off.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，一切都按计划进行。每当按钮被点击时，点击计数器都会更新。`<MyFeature>`每3秒重新渲染一次，切换按钮的`disabled`状态。当按钮重新启用并且点击恢复时，计数器会从上次停止的地方继续。
- en: 'Here is what the `MyButton` component looks like when first rendered:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`MyButton`组件在首次渲染时的样子：
- en: '![](Images/81a1ef60-a155-482b-aa83-29f6abb95d2b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/81a1ef60-a155-482b-aa83-29f6abb95d2b.png)'
- en: 'Here''s what it looks like after it has been clicked a few times and the button
    has moved into a disabled state:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在点击了几次后，按钮进入禁用状态后的样子：
- en: '![](Images/da9f9124-eb36-41c7-b4bb-beb8438a46c6.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/da9f9124-eb36-41c7-b4bb-beb8438a46c6.png)'
- en: Optimize rendering efficiency
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化渲染效率
- en: The next lifecycle method you're going to learn about is used to implement heuristics
    that improve component rendering performance. You'll see that if the state of
    a component hasn't changed, then there's no need to render. Then, you'll implement
    a component that uses specific metadata from the API to determine whether or not
    the component needs to be re-rendered.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你要学习的下一个生命周期方法用于实现改进组件渲染性能的启发式。你会发现，如果组件的状态没有改变，那么就没有必要进行渲染。然后，你将实现一个组件，该组件使用来自API的特定元数据来确定是否需要重新渲染组件。
- en: To render or not to render
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染还是不渲染
- en: The `shouldComponentUpdate()` lifecycle method is used to determine whether
    or not the component will render when asked to. For example, if this method were
    implemented, and returned false, the entire lifecycle of the component is short-circuited,
    and no render happens. This can be an important check to have in place if the
    component is rendering a lot of data and is re-rendered frequently. The trick
    is knowing whether or not the component state has changed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate()`生命周期方法用于确定当被要求渲染时组件是否会进行渲染。例如，如果实现了这个方法，并返回false，那么组件的整个生命周期都会被中断，不会进行渲染。如果组件渲染了大量数据并且经常重新渲染，这个检查就非常重要。关键是要知道组件状态是否已经改变。'
- en: 'This is the beauty of immutable data—you can easily check if it has changed.
    This is especially true if you''re using a library such as `Immutable.js` to control
    the state of the component. Let''s take a look at a simple list component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是不可变数据的美妙之处——你可以轻松地检查它是否发生了变化。如果你正在使用`Immutable.js`等库来控制组件的状态，这一点尤为真实。让我们看一个简单的列表组件：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `items` state is initialized to an `Immutable.js` `List` with `5000` items
    in it. This is a fairly large collection, so you don't want the virtual DOM inside
    React to constantly diff this list. The virtual DOM is efficient at what it does,
    but not nearly as efficient as code that can perform a simple should or shouldn't
    render check. The `shouldComponentRender()` method that you've implemented here
    does exactly that. It compares the new state with the current state; if they're
    the same object, completely sidestep the virtual DOM.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`状态初始化为一个包含5000个项目的`Immutable.js` `List`。这是一个相当大的集合，所以你不希望React内部的虚拟DOM不断地对比这个列表。虚拟DOM在它所做的事情上是高效的，但远不及能执行简单的渲染检查的代码高效。你在这里实现的`shouldComponentRender()`方法正是这样做的。它比较新状态和当前状态；如果它们是相同的对象，完全绕过虚拟DOM。'
- en: 'Now, let''s put this component to work and see what kind of efficiency gains
    you get:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让这个组件开始工作，看看你能获得什么样的效率提升：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''re rendering `<MyList>`, over and over, in a loop. Each iteration has
    5,000 list items to render. Since the state doesn''t change, the call to `shouldComponentUpdate()`
    returns `false` on every one of these iterations. This is important for performance
    reasons, because there are a lot of them. You''re not going to have code that
    re-renders a component in a tight loop, in a real application. This code is meant
    to stress the rendering capabilities of React. If you were to comment out the
    `shouldComponentUpdate()` method, you''d see what I mean. Here''s what the performance
    profile looks like for this component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在循环渲染`<MyList>`。每次迭代都有5000个列表项要渲染。由于状态没有改变，`shouldComponentUpdate()`的调用在每次迭代中都返回`false`。出于性能原因，这很重要，因为迭代次数很多。在真实应用中，你不会有代码在紧密循环中重新渲染组件。这段代码旨在测试React的渲染能力。如果你注释掉`shouldComponentUpdate()`方法，你就会明白我的意思。这个组件的性能概况如下：
- en: '![](Images/1ade8d3e-1c1c-4b04-80df-f819ab16b356.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1ade8d3e-1c1c-4b04-80df-f819ab16b356.png)'
- en: 'The initial render takes the longest—a few hundred milliseconds. But then you
    have all of these tiny time slices that are completely imperceptible to the user
    experience. These are the result of `shouldComponentUpdate()` returning false.
    Let''s comment out this method now and see how this profile changes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 初始渲染时间最长——几百毫秒。但接下来有很多微小的时间片段，对用户体验完全不可感知。这些是`shouldComponentUpdate()`返回false的结果。现在让我们注释掉这个方法，看看这个概况会如何改变：
- en: '![](Images/703a99d7-f415-4b53-9187-3dac6cf212be.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/703a99d7-f415-4b53-9187-3dac6cf212be.png)'
- en: Without `shouldComponentUpdate()`, the end result is much larger time slices
    with a drastically negative impact on user experience.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`shouldComponentUpdate()`，最终结果是更长的时间片段，对用户体验有极大的负面影响。
- en: 'You may notice that we''re actually changing state using `setIn()` on the `Immutable.js` map.
    This should result in a state change, right? This will actually return the same
    `Immutable.js` instance for the simple reason that the value we''ve set is the
    same as the current value: `0`. When no change happens, `Immutable.js` methods
    return the same object, since it didn''t mutate.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我们实际上是使用`Immutable.js`的`setIn()`来改变状态。这应该会导致状态改变，对吧？实际上，这将返回相同的`Immutable.js`实例，原因很简单，我们设置的值与当前值相同：`0`。当没有发生改变时，`Immutable.js`方法返回相同的对象，因为它没有发生变化。
- en: Using metadata to optimize rendering
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元数据优化渲染
- en: 'In this section, you''ll learn how to use metadata that''s part of the API
    response to determine whether or not the component should re-render itself. Here''s
    a simple user details component:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用API响应的元数据来确定组件是否应该重新渲染自己。这里是一个简单的用户详情组件：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `shouldComponentUpdate()` method is comparing the new `modified` state to
    the old `modified` state. This code makes the assumption that the `modified` value
    is a date that reflects when the data returned from the API was actually modified.
    The main downside to this approach is that the `shouldComponentUpdate()` method
    is now tightly coupled with the API data. The advantage is that you get a performance
    boost in the same way that you would with immutable data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate()`方法正在比较新的`modified`状态和旧的`modified`状态。这段代码假设`modified`值是一个反映API返回的数据实际修改时间的日期。这种方法的主要缺点是`shouldComponentUpdate()`方法现在与API数据紧密耦合。优点是，你可以像使用不可变数据一样获得性能提升。'
- en: 'Here''s how this heuristic looks in action:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个启发式方法的实际效果：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `MyUser` component is now entirely dependent on the `modified` state. If
    it's not greater than the previous `modified` value, no render happens.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyUser`组件现在完全依赖于`modified`状态。如果它不大于先前的`modified`值，就不会发生渲染。'
- en: 'Here''s what the component looks like after it''s been rendered twice:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染两次后，组件的外观如下：
- en: '![](Images/3d9f4de2-3f1b-4acf-87f7-dac82c2e2a53.png)In this example, I didn''t
    use immutable state data. Throughout this book, I''ll use plain JavaScript objects
    as state for simple examples. `Immutable.js` is a great tool for this job, so
    I''ll be using it a lot. At the same time, I want to make it clear that `Immutable.js`
    doesn''t need to be used in every situation.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我没有使用不可变状态数据。在本书中，我将使用普通的JavaScript对象作为简单示例的状态。`Immutable.js`是这项工作的好工具，所以我会经常使用它。与此同时，我想明确指出`Immutable.js`并不需要在每种情况下都使用。
- en: Rendering imperative components
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染命令式组件
- en: 'Everything you''ve rendered so far in this book has been straightforward declarative
    HTML. Life is never so simple: sometimes your React components need to implement
    some imperative code under the covers.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，你渲染的所有内容都是直接的声明式HTML。生活从来都不是那么简单：有时你的React组件需要在底层实现一些命令式的代码。
- en: This is the key—hiding the imperative operations so that the code that renders
    your component doesn't have to touch it. In this section, you'll implement a simple
    jQuery UI button React component so that you can see how the relevant lifecycle
    methods help you to encapsulate imperative code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关键——隐藏命令式操作，使渲染组件的代码不必触及它。在本节中，你将实现一个简单的jQuery UI按钮React组件，以便你可以看到相关的生命周期方法如何帮助你封装命令式代码。
- en: Rendering jQuery UI widgets
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染jQuery UI小部件
- en: The jQuery UI widget library implements several widgets on top of standard HTML.
    It uses a progressive enhancement technique whereby the basic HTML is enhanced
    in browsers that support newer features. To make these widgets work, you first
    need to render HTML into the DOM somehow; then, make imperative function calls
    to create and interact with the widgets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI小部件库在标准HTML之上实现了几个小部件。它使用渐进增强技术，在支持新功能的浏览器中增强基本HTML。为了使这些小部件工作，你首先需要以某种方式将HTML渲染到DOM中；然后，进行命令式函数调用来创建和与小部件交互。
- en: 'In this example, you''ll create a React button component that acts as a wrapper
    around the jQuery UI widget. Anyone using the React component shouldn''t need
    to know that behind the scenes, it''s making imperative calls to control the widget.
    Let''s see what the button component looks like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将创建一个React按钮组件，作为jQuery UI小部件的包装器。使用React组件的人不需要知道，在幕后，它正在进行命令式调用来控制小部件。让我们看看按钮组件的样子：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The jQuery UI button widget expects a `<button>` element, so this is what's
    rendered by the component. An `onClick()` handler from the component props is
    assigned as well. There's also a `ref` property used here, which assigns the `button`
    argument to `this.button`. The reason this is done is so that the component has
    direct access to the underlying DOM element of the component. Generally, components
    don't need access to any DOM elements, but here, you need to issue imperative
    commands to the element.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI按钮小部件期望`<button>`元素，因此组件呈现为此。还分配了来自组件属性的`onClick()`处理程序。这里还使用了`ref`属性，它将`button`参数分配给`this.button`。这样做的原因是，组件可以直接访问组件的底层DOM元素。通常，组件不需要访问任何DOM元素，但在这里，您需要向元素发出命令。
- en: 'For example, in the `componentDidMount()` method,  the `button()` function
    is called and passes it properties from the component. The `componentDidUpdate()`
    method does something similar, which is called when property values change. Now,
    let''s take a look at the button container component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`componentDidMount()`方法中，调用了`button()`函数，并将其属性传递给组件。`componentDidUpdate()`方法执行类似的操作，当属性值更改时调用。现在，让我们看一下按钮容器组件：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You have a container component that controls the state, which is then passed
    to `<MyButton>` as properties.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个控制状态的容器组件，然后将其作为属性传递给`<MyButton>`。
- en: The `{...data}` syntax is called JSX spread attributes. This allows you to pass
    objects to elements as attributes. You can read more about this feature here.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`{...data}`语法称为JSX扩展属性。这允许您将对象作为属性传递给元素。您可以在此处阅读更多关于此功能的信息。'
- en: 'The component has a default `onClick()` handler function. But, you can pass
    a different click handler in as a property. Additionally, it''s automatically
    bound to the component context, which is useful if the handler needs to change
    the button state. Let''s look at an example of this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件具有默认的`onClick()`处理函数。但是，您可以将不同的点击处理程序作为属性传递。此外，它会自动绑定到组件上下文，如果处理程序需要更改按钮状态，则这很有用。让我们看一个例子：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, you have three jQuery UI button widgets, each controlled by a React component
    with no imperative code in sight. Here''s how the buttons look:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有三个jQuery UI按钮小部件，每个都由一个React组件控制，看不到任何命令式代码。按钮的外观如下：
- en: '![](Images/3ef4d930-c2a8-4938-ba32-055e764f300d.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3ef4d930-c2a8-4938-ba32-055e764f300d.png)'
- en: Cleaning up after components
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件之后进行清理
- en: In this section, you'll learn how to clean up after components. You don't have
    to explicitly unmount components from the DOM—React handles that for you. There
    are some things that React doesn't know about and therefore cannot clean up for
    you after the component is removed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习如何在组件之后进行清理。您不必显式地从DOM中卸载组件-React会为您处理。有一些React不知道的东西，因此在组件被移除后无法为您清理。
- en: It's for these types of cleanup tasks that the `componentWillUnmount()` lifecycle
    method exists. One use case for cleaning up after React components is asynchronous
    code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正是为了这些清理任务，`componentWillUnmount()`生命周期方法存在。清理React组件之后的一个用例是异步代码。
- en: For example, imagine a component that issues an API call to fetch some data
    when the component is first mounted. Now, imagine that this component is removed
    from the DOM before the API response arrives.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个组件，在组件首次挂载时发出API调用以获取一些数据。现在，想象一下，在API响应到达之前，该组件从DOM中移除。
- en: Cleaning up asynchronous calls
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理异步调用
- en: If your asynchronous code tries to set the state of a component that has been
    unmounted, nothing will happen. A warning will be logged, and the state isn't
    set. It's actually very important that this warning is logged; otherwise, you
    would have a hard time trying to solve subtle race condition bugs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的异步代码尝试设置已卸载的组件的状态，将不会发生任何事情。会记录一个警告，并且状态不会被设置。记录这个警告实际上非常重要；否则，您将很难解决微妙的竞争条件错误。
- en: 'The correct approach is to create cancellable asynchronous actions. Here''s
    a modified version of the `users()` API function that you implemented earlier
    in the chapter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是创建可取消的异步操作。这是你在本章前面实现的`users()` API函数的修改版本：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The trick is the `cancellable()` function, which wraps a promise with a new
    promise. The new promise has a `cancel()` method, which rejects the promise if
    called. It doesn't alter the actual asynchronous behavior that the promise is
    synchronizing. However, it does provide a generic and consistent interface for
    use within React components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是`cancellable()`函数，它用新的promise包装了一个promise。新的promise有一个`cancel()`方法，如果调用则拒绝promise。它不会改变promise同步的实际异步行为。然而，它确实为在React组件中使用提供了一个通用和一致的接口。
- en: 'Now let''s take a look at a container component that has the ability to cancel
    asynchronous behavior:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个具有取消异步行为能力的容器组件：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `onClickCancel()` handler actually replaces the user list. This calls the
    `componentWillUnmount()` method, where you can cancel `this.job`. It's also worth
    noting that when the API call is made in `componentDidMount()`, a reference to
    the promise is stored in the component. This is necessary otherwise you would
    have no way to cancel the async call.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickCancel()`处理程序实际上替换了用户列表。这调用了`componentWillUnmount()`方法，在那里您可以取消`this.job`。值得注意的是，当在`componentDidMount()`中进行API调用时，会在组件中存储对promise的引用。否则，您将无法取消异步调用。'
- en: 'Here''s what the component looks like when rendered during a pending API call:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行挂起的API调用期间呈现组件时，组件的样子如下：
- en: '![](Images/98f270e9-d5a8-4163-8080-aba152c213eb.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/98f270e9-d5a8-4163-8080-aba152c213eb.png)'
- en: Containing errors with error boundaries
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用错误边界包含错误
- en: A new feature of React 16 – **error boundaries** – lets you handle unexpected
    component failures. Rather than have every component of your application know
    how to deal with any errors that it might encounter, **error boundaries** are
    a mechanism that you can use to wrap components with error-handling behavior.
    The best way to think of error boundaries is as `try`/`catch` syntax for JSX.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React 16的一个新功能——**错误边界**——允许您处理意外的组件失败。与其让应用程序的每个组件都知道如何处理可能遇到的任何错误，**错误边界**是一个机制，您可以使用它来包装具有错误处理行为的组件。最好将错误边界视为JSX的`try`/`catch`语法。
- en: Let's revisit the first example from this chapter where you fetched component
    data using an API function. The `users()` function accepts a Boolean argument,
    which, when true, causes the promise to reject. This is something that you'll
    want to handle, but not necessarily in the component that made the API call. In
    fact, the `UserListContainer` and `UserList` components are already set up to
    handle API errors like this. The challenge is that if you have lots of components,
    this is a lot of error handling code. Further, the error handling is specific
    to that one API call – what if something else goes wrong?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新访问本章中的第一个示例，其中您使用API函数获取了组件数据。`users()`函数接受一个布尔参数，当为true时，会导致promise被拒绝。这是您想要处理的事情，但不一定是在进行API调用的组件中。实际上，`UserListContainer`和`UserList`组件已经设置好了处理这样的API错误。挑战在于，如果有很多组件，这将是大量的错误处理代码。此外，错误处理是特定于一个API调用的——如果其他地方出了问题怎么办？
- en: 'Here''s the modified source for `UserListContainer` that you can use for this
    example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以用于此示例的`UserListContainer`的修改后源代码：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This component is mostly the same as it was in the first example. The first
    difference is the call to `users()` where it''s now passing true:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件大部分与第一个示例中的相同。第一个区别是对`users()`的调用，现在它传递了true：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This call will fail, resulting in the error state being set. The second difference
    is in the `render()` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将失败，导致错误状态被设置。第二个区别在于`render()`方法：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Instead of forwarding the error state onto the `UserList` component, it's passing
    the error back to the component tree by throwing an error instead of attempting
    to render more components. The key design change here is that this component is
    now making the assumption that there is some sort of error boundary in place further
    up in the component tree that will handle these errors accordingly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是将错误状态转发到`UserList`组件，而是通过抛出错误而不是尝试渲染更多组件将错误传递回组件树。这里的关键设计变化是，该组件现在假设在组件树的更高位置有某种错误边界，将相应地处理这些错误。
- en: You might be wondering why the error is thrown in render instead of being thrown
    when the promise is rejected in `componentDidMount()`. The problem is that fetching
    data asynchronously like this means that there's no way for the React internals
    to actually catch exceptions that are thrown from within async promise handlers.
    The easiest solution for asynchronous actions that could cause a component to
    fail is to store the error in the component state, but to throw the error before
    actually rendering anything if it's there.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么错误在渲染时抛出，而不是在`componentDidMount()`中拒绝承诺时抛出。问题在于像这样异步获取数据意味着React内部实际上无法捕获从异步承诺处理程序中抛出的异常。对于可能导致组件失败的异步操作，最简单的解决方案是将错误存储在组件状态中，但如果存在错误，则在实际渲染任何内容之前抛出错误。
- en: 'Now let''s create the error boundary itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建错误边界本身：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is where the `componentDidCatch()` lifecycle method is utilized by setting
    the error state of this component when it catches an error. When it's rendered,
    an error message is rendered if the `error` state is set. Otherwise, render the
    child components as usual.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`componentDidCatch()`生命周期方法的用法，当它捕获到错误时，设置该组件的错误状态。当渲染时，如果设置了`error`状态，则渲染错误消息。否则，像往常一样渲染子组件。
- en: 'Here''s how you can use this `ErrorBoundary` component:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用这个`ErrorBoundary`组件：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Any errors that are thrown by `UserListContainer` or any of its children will
    be caught and handled by `ErrorBoundary`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListContainer`或其任何子级抛出的任何错误都将被`ErrorBoundary`捕获和处理：'
- en: '![](Images/cba62616-0a38-4e25-93ca-d2bc108b927f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cba62616-0a38-4e25-93ca-d2bc108b927f.png)'
- en: 'Now you can remove the argument that''s passed to `users()` in `UserListContainer`
    to stop it from failing. In the `UserList` component, let''s say that you have
    an error that tries to call `toUpperCase()` on a number:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以删除传递给`UserListContainer`中的`users()`的参数，以阻止其失败。在`UserList`组件中，假设您有一个错误，尝试在数字上调用`toUpperCase()`：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You''ll get a different error thrown, but since it''s under the same boundary
    as the previous error, it''ll be handled the same way:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得不同的错误抛出，但由于它位于与先前错误相同的边界下，它将以相同的方式处理：
- en: '![](Images/6a30a766-067f-4b42-a24a-d7bdb6cfb950.png)If you''re running your
    project with `create-react-app` and `react-scripts`, you might notice an error
    overlay for every error in your application, even those that are handled by error
    boundaries. If you close the overlay using the **x** in the top right, you can
    see how your component handles the error in your app.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6a30a766-067f-4b42-a24a-d7bdb6cfb950.png)如果您使用`create-react-app`和`react-scripts`运行项目，您可能会注意到应用程序中的每个错误都会有一个错误叠加层，即使这些错误已被错误边界处理。如果您使用右上角的**x**关闭叠加层，您可以看到您的组件如何处理应用程序中的错误。'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned a lot about the lifecycle of React components.
    We started things off with a discussion on why React components need a lifecycle
    in the first place. It turns out that React can't do everything automatically
    for us, so we need to write some code that's run at the appropriate time during
    the components' lifecycles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多关于React组件生命周期的知识。我们首先讨论了为什么React组件首先需要生命周期。原来React不能自动完成所有工作，所以我们需要编写一些代码，在组件生命周期的适当时间运行。
- en: Next, you implemented several components that were able to fetch their initial
    data and initialize their state from JSX properties. Then, you learned how to
    implement more efficient React components by providing a `shouldComponentRender()`
    method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您实现了几个组件，它们能够从JSX属性中获取初始数据并初始化它们的状态。然后，您学会了通过提供`shouldComponentRender()`方法来实现更高效的React组件。
- en: You learned how to hide the imperative code that some components need to implement
    and how to clean up after asynchronous behavior. Finally, you learned how to use
    the new error boundary functionality from React 16.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何隐藏一些组件需要实现的命令式代码，以及如何在异步行为之后进行清理。最后，您学会了如何使用React 16的新错误边界功能。
- en: In the following chapter, you'll learn techniques that help to ensure that your
    components are being passed the right properties.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习一些技术，以确保您的组件被传递了正确的属性。
- en: Test your knowledge
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的知识
- en: Is `render()` a lifecycle method?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render()`是一个生命周期方法吗？'
- en: Yes, `render()` is no different from any other lifecycle method.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，`render()`与任何其他生命周期方法没有区别。
- en: No, `render()` is simply called to get the content of the component.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，`render()`只是用来获取组件的内容。
- en: Which of the following is a valid use of the `componentWillUnmount()` method?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是`componentWillUnmount()`方法的有效用法？
- en: Do delete DOM elements that were added by the component.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除组件添加的DOM元素。
- en: To cancel an asynchronous action that will fail if the component us unmounted.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消组件卸载时将失败的异步操作。
- en: To log that the component is about to unmount.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件即将卸载时记录日志。
- en: Which lifecycle method is used by an error boundary component?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个生命周期方法被错误边界组件使用？
- en: '`componentDidCatch()`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentDidCatch()`'
- en: '`componentWillCatch()`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentWillCatch()`'
- en: '`componentError()`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentError()`'
- en: Further Reading
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can visit following links for more information:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问以下链接获取更多信息：
- en: '[https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)'
- en: '[https://reactjs.org/docs/state-and-lifecycle.html](https://reactjs.org/docs/state-and-lifecycle.html)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/state-and-lifecycle.html](https://reactjs.org/docs/state-and-lifecycle.html)'
