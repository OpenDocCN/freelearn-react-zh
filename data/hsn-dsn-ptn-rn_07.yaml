- en: Navigation Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航模式
- en: The crucial part of almost every application is navigation. To this day, this
    topic gives headaches to many React Native developers. Let’s see which libraries
    are available and which one will suit your project. This chapter starts with a
    breakdown of the available libraries. Then, we will introduce a new project and
    play with it. We will focus on one library at a time. Once we finish this, I will
    walk you through the patterns that are used, and what these imply, while you write
    the navigation code. Remember to try the code on your machine and your phone.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序的关键部分是导航。直到今天，这个话题仍然让许多React Native开发人员头疼。让我们看看有哪些可用的库，以及哪一个适合您的项目。本章从可用库的分解开始。然后，我们将介绍一个新项目并进行操作。我们将一次专注于一个库。完成后，我将带您了解所使用的模式以及这些模式意味着什么，同时您编写导航代码。记得在您的计算机和手机上尝试这些代码。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下内容：
- en: Why are there many alternative libraries for routing in React Native?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么React Native有许多替代路由库？
- en: What are the challenges that navigation libraries face?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航库面临的挑战是什么？
- en: What is the difference between native navigation and JavaScript navigation?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地导航和JavaScript导航有什么区别？
- en: How to use Tab navigation, Drawer navigation, and Stack navigation.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用选项卡导航、抽屉导航和堆栈导航。
- en: 'The basics of native solutions: you will eject the Create React Native App
    for the first time.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地解决方案的基础知识：您将首次弹出创建React Native应用程序。
- en: React Native navigation alternatives
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native导航替代方案
- en: 'Usually, if you are a beginner and you try to Google for *React Native navigation*,
    you will end up with a headache. The number of available alternatives is high.
    There are a few reasons why this is so:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您是初学者，并尝试在Google上搜索*React Native导航*，您最终会头疼。可用的替代方案数量很多。这是有几个原因的：
- en: Some early libraries are not maintained anymore, as maintainers have simply
    quit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些早期的库不再得到维护，因为维护者已经退出
- en: Some companies with resources started a library and then changed their employees
    focus to other things
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些资源充足的公司开始了一个库，然后将员工的重点转移到其他事情上
- en: Some solutions are proven to be inefficient, or a better solution is implemented
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些解决方案被证明效率低下，或者实施了更好的解决方案
- en: There is an architectural reason for different approaches, which leads to a
    need to maintain different solutions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同方法有架构上的原因，导致需要维护不同的解决方案
- en: We will focus on the last point here, as it is vital to understand which library
    fits your needs. We will discuss the solutions so that, at the end of this chapter,
    you will know which library to choose for your project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里专注于最后一点，因为了解哪个库适合您的需求至关重要。我们将讨论解决方案，以便在本章结束时，您将知道为您的项目选择哪个库。
- en: Designers navigation patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计师的导航模式
- en: Before we dive into the world of libraries, I would like to show you different
    ways of designing navigation in your application. Usually, this is work for the
    project's designer; however, once you understand the trade-offs, it will be easier
    to add a code pattern layer on top of it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解库的世界之前，我想向您展示在应用程序中设计导航的不同方式。通常，这是项目设计师的工作；然而，一旦您了解了权衡，添加代码模式层将会更容易。
- en: 'The mobile app consists of screens and transitions. Altogether, these can be
    represented by the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序由屏幕和过渡组成。总的来说，这些可以用以下图表表示：
- en: '![](Images/d751e3ad-7a4c-4b30-b7ae-8e0143930d68.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d751e3ad-7a4c-4b30-b7ae-8e0143930d68.png)'
- en: This is an example diagram representing the screens of a tasks application
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代表任务应用程序屏幕的示例图表
- en: 'The main takeaways from the preceding diagram are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表的主要要点如下：
- en: Each app consists of top-level screens (**Homepage**, **Projects**, and **Search**)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序都包括顶层屏幕（**主页**、**项目**和**搜索**）
- en: From top-level screens, you can navigate forward and deeper down the tree (**Projects**
    => **Project task list**)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从顶层屏幕，您可以向前导航并深入树中（**项目** => **项目任务列表**）
- en: Sometimes, you transition backwards (**Task** => **Project task list**)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，您会向后过渡（**任务** => **项目任务列表**）
- en: With this in mind, let's look into the components that will help us make these
    transitions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们看看将帮助我们进行这些转换的组件。
- en: Navigation to top-level screens
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到顶层屏幕
- en: 'Navigation to top-level screens is usually done using one or more of the following
    three alternatives:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用以下三种替代方案之一导航到顶层屏幕：
- en: 'Classical bottom navigation, like the one we already implemented. This usually
    uses icons or a combination of icons and text. Depending on the choice made, this allows
    us to place between two to five links. This is usually avoided on tablet designs:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典底部导航，就像我们已经实现的那样。这通常使用图标或图标和文本的组合。根据所做的选择，这允许我们放置两到五个链接。这在平板设计上通常是避免的：
- en: '![](Images/6f7d2d47-ab2f-4f80-80ac-53b235e4d5d2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6f7d2d47-ab2f-4f80-80ac-53b235e4d5d2.png)'
- en: An example of classic bottom navigation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 经典底部导航的一个例子
- en: 'The navigation drawer, opened from the side of the screen. This contains a
    list of links, possibly more than five. This can be sophisticated and can include
    a user profile at the top. This tends to be opened by a hamburger icon placed
    in one of the upper corners:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航抽屉，从屏幕侧边打开。其中包含一个链接列表，可能超过五个。这可能是复杂的，并且可以在顶部包括用户配置文件。这往往是通过位于一个上角的汉堡图标打开的：
- en: '![](Images/b6344c65-d72c-4d1c-a21d-ea7dcf667f36.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b6344c65-d72c-4d1c-a21d-ea7dcf667f36.png)'
- en: An example of drawer navigation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉导航的一个例子
- en: Tabs, which are placed at the top of the screen and appear as pairs, at the
    least. The number of tabs can exceed four, and in such a case, tabs can be scrolled
    horizontally. This is used not only for top-level navigation, but for any navigation
    between screens of the same depth.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签，放置在屏幕顶部，成对出现，至少如此。标签的数量可以超过四个，在这种情况下，标签可以水平滚动。这不仅用于顶层导航，还用于同一深度屏幕之间的任何导航。
- en: Navigating between different levels of the graph
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图表的不同级别之间导航
- en: Once we reach a certain level, sometimes we want to explore that particular
    area even further. In the case of the Tasks application, this would mean choosing
    a project or choosing a specific task within the project itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达一定级别，有时我们想进一步探索特定区域。在任务应用程序的情况下，这意味着选择一个项目或在项目内选择特定任务。
- en: 'Usually, to navigate down the graph, we use the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了在图表中向下导航，我们使用以下方法：
- en: Containers, including lists, cards, image list, and image cards
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器，包括列表、卡片、图像列表和图像卡片
- en: Simple buttons, text links, or icons
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单按钮、文本链接或图标
- en: 'However, to go back up the graph, usually we use the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了回到图表的上方，通常我们使用以下方法：
- en: A back icon, such as an arrow, usually positioned  in the upper left corner
    or bottom left corner
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回图标，如箭头，通常位于左上角或左下角
- en: A button or link, with text such as back | cancel | start over
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮或链接，文本如返回|取消|重新开始
- en: A cross icon positioned in the relevant part of the edit/create screen
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑/创建屏幕的相关部分放置的交叉图标
- en: To some of you, this knowledge comes naturally; however, I have bumped into
    proposals or early drafts of designs that clearly confused these concepts and,
    in the end, terribly affected the user experience. Experimenting is good, but
    only in a controlled environment that uses standard and well-known patterns, which
    feel natural for most of the users.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你们中的一些人来说，这些知识是自然而然的；然而，我遇到了一些明显混淆了这些概念的提案或早期设计草案，最终严重影响了用户体验。尝试是好的，但只能在使用标准和众所周知的模式的受控环境中进行，这些模式对大多数用户来说是自然的。
- en: For experimenting with design, you should implement A/B tests. These require
    the ability to run different versions of the app in production for different subsets
    of users. Thanks to analytics, you can later assess whether A or B was a better
    choice. Finally, all of the users can be migrated to the winning scenario.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设计实验，您应该实施A/B测试。这需要能够在生产中为不同的用户子集运行应用程序的不同版本。借助分析，您可以随后评估A或B哪个选择更好。最终，所有用户都可以迁移到获胜的方案。
- en: Navigating on the same level of the graph
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图的同一级别上导航
- en: In more complex apps, aside from the top-level navigation, you will also need
    to horizontally transition between different screens that are on the same depth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中，除了顶层导航之外，您还需要在相同深度的不同屏幕之间进行水平过渡。
- en: 'To transition between screens on the same level, you can use the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在同一级别的屏幕之间进行过渡，您可以使用以下方法：
- en: Tabs, similar to that discussed in the top-level navigation section
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项卡，类似于顶层导航部分讨论的内容
- en: Screen swipes (literally swiping between screens)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕滑动（字面上在屏幕之间滑动）
- en: Swiping in a container (for instance, to see either task description, connected
    tasks or task, comments) can be connected with tabs
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中滑动（例如，查看任务描述、连接任务或任务评论）可以与选项卡连接
- en: Left or right arrows, or dots indicating your position within the level
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左右箭头，或指示您在级别内位置的点
- en: Similarly, you can use these for collections of data too. Collections of data,
    however, provide more freedom to use lists or less constrained containers that
    take advantage of top/bottom swipes, too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以用这些来处理数据集合。然而，数据集合提供更多自由，可以使用列表或不受限制的容器，利用顶部/底部滑动。
- en: Bearing in mind how designers are solving problems of navigation, let's now
    discuss how to make it performant and how to maintain the navigation graph.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记设计师们如何解决导航问题，现在让我们讨论如何使其性能良好以及如何维护导航图。
- en: Developers' navigation patterns
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者的导航模式
- en: 'To be honest, it all comes down to this—is a JavaScript implementation good
    enough? If so, let''s use it for our benefit (that is, tracking, control in JavaScript,
    logs, and so on). Over time, it looks like the React Native community managed
    to create something stable, called React Navigation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，一切都归结于这一点——JavaScript实现是否足够好？如果是，让我们为自己的利益使用它（即，跟踪、JavaScript中的控制、日志等）。随着时间的推移，看起来React
    Native社区设法创建了一个稳定的东西，称为React Navigation：
- en: '"React Navigation is entirely made up of React components and the state is
    managed in JavaScript on the same thread as the rest of your app. This is what
    makes React Navigation great in many ways but it also means that your app logic
    contends for CPU time with React Navigation — there''s only so much JavaScript
    execution time available per frame."'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “React Navigation完全由React组件组成，并且状态在JavaScript中管理，与应用程序的其余部分在同一线程上。这在许多方面使React
    Navigation变得很棒，但这也意味着您的应用逻辑与React Navigation竞争CPU时间——每帧可用的JavaScript执行时间有限。”
- en: '- React Navigation official documentation, available at:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '- React Navigation官方文档，可在以下网址找到：'
- en: '[https://reactnavigation.org/docs/en/limitations.html](https://reactnavigation.org/docs/en/limitations.html).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactnavigation.org/docs/en/limitations.html](https://reactnavigation.org/docs/en/limitations.html)。'
- en: However, as discussed in the preceding quote, this competes with your application
    for CPU cycles. This means it is draining resources and slowing down the application
    to some extent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前面的引用所讨论的，这与您的应用程序竞争CPU周期。这意味着它在一定程度上耗尽资源并减慢应用程序的速度。
- en: 'Pros of JavaScript navigation are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript导航的优点如下：
- en: You can tweak and extend the solution using JavaScript code.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用JavaScript代码调整和扩展解决方案。
- en: Current implementations are performant enough for small to medium apps.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的实现对于中小型应用程序来说性能足够好。
- en: The state is managed in JavaScript and easily integrates with state management
    libraries such as Redux.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态在JavaScript中管理，并且很容易与Redux等状态管理库集成。
- en: The API is decoupled from native APIs. This means that if React Native eventually
    goes beyond Android and iOS, the API will stay the same, and once implemented
    by the library maintainers, this will enable you to use the same solution for
    yet another platform.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API与本机API解耦。这意味着如果React Native最终超越Android和iOS，API将保持不变，并且一旦由库维护者实施，这将使您能够为另一个平台使用相同的解决方案。
- en: Easy to learn.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易学。
- en: Good for beginners.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合初学者。
- en: 'Cons of JavaScript navigation are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript导航的缺点如下：
- en: It is very tough to implement in a performant way.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能方面实施起来非常困难。
- en: It may still be too slow for large applications.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大型应用程序来说可能仍然太慢。
- en: Some animations slightly differ from the native ones.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些动画与本机动画略有不同。
- en: Some gestures or animations may be entirely different than the native ones (for
    instance, if the native system changes the defaults, or there is inconsistency
    because of historical changes).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些手势或动画可能与本机的完全不同（例如，如果本机系统更改了默认设置，或者由于历史更改而不一致）。
- en: It is hard to integrate with native code.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难与本机代码集成。
- en: Routing should be static, as per current documentation.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据当前文档，路由应该是静态的。
- en: Some solutions, which you would expect to be present if you have ever created
    native navigation, may not be available (for instance, a connection with the native
    lifecycle).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些解决方案，如果您曾经创建过本机导航，可能不可用（例如，与本机生命周期的连接）。
- en: Limited international support (for instance, as of July 2018, the Right-to-Left
    is not supported by some JavaScript navigation libraries, including React Navigation).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的国际支持（例如，截至2018年7月，某些JavaScript导航库不支持从右到左，包括React Navigation）。
- en: On the other hand, let's look at Native navigation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，让我们看看本机导航。
- en: 'Pros of Native navigation are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本机导航的优点如下：
- en: Native navigation can be optimized by the system library that may, for instance,
    containerize navigation stacks
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本机导航可以通过系统库进行优化，例如，容器化导航堆栈
- en: Native navigation outperforms JavaScript navigation
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本机导航优于JavaScript导航
- en: It leverages each system's unique capabilities
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用了每个系统的独特能力
- en: The ability to leverage the native life cycle and hook to it with animations
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够利用本机生命周期并通过动画连接到它
- en: Most implementations integrate with state management libraries
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数实现都集成了状态管理库
- en: 'Cons of Native navigation are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本机导航的缺点如下：
- en: Sometimes it defeats React Native's purpose – it diverges navigation across
    systems, instead unifying it.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时它违背了React Native的初衷-它使导航在系统之间分歧，而不是统一。
- en: It is tough to provide a consistent API across platforms, or it is even not
    consistent at all.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难在各个平台上提供一致的API，或者根本不一致。
- en: Single source of truth is no longer true – our state leaks to the native code
    that manages the state internally within the specific platform. This kills time-traveling.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一真相不再成立-我们的状态泄漏到在特定平台内部管理状态的本机代码。这会破坏时间旅行。
- en: Problematic state synchronization – the chosen library either does not promise
    immediate state synchronization at all, or implements different locks that slow
    down the application to an extent that usually kills the purpose.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题状态同步 - 所选择的库要么根本不承诺立即状态同步，要么实现了不同的锁定，这会使应用程序变慢，通常会破坏其目的。
- en: Some experts argue that developers of NavigatorIOS library (as of July 2018,
    still mentioned in official React Native documentation) did a great job of working
    on it, but its future is uncertain.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专家认为NavigatorIOS库的开发人员（截至2018年7月，仍在官方React Native文档中提到）在开发工作上做得很好，但它的未来是不确定的。
- en: It requires working with tools and configuration of the native systems.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要使用本地系统的工具和配置。
- en: It is aimed at experienced developers.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它旨在针对有经验的开发人员。
- en: You need to take into account all of this and make the right trade-offs before
    choosing either one. But before we dive into the code, please focus on the next
    section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择其中一个之前，你需要考虑所有这些并做出正确的权衡。但在我们深入代码之前，请专注于下一节。
- en: Restructuring your application
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构你的应用程序
- en: No-one likes huge monolithic code bases with all features intertwined. What
    can we do to prevent this as the application grows? Make sure to wisely locate
    code files and have a standardized way of doing so.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人喜欢庞大的单片代码库，所有功能都交织在一起。随着应用程序的增长，我们可以做些什么来防止这种情况发生？确保明智地定位代码文件，并且有一种标准化的做法。
- en: 'An example of a monolithic code base that will cause you a headache once it
    surpasses 10,000 lines is the following one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦超过10,000行，会让你头痛的单片代码库的一个例子是：
- en: '![](Images/20583eb7-7b0d-4ace-9024-327e5662b0ff.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/20583eb7-7b0d-4ace-9024-327e5662b0ff.png)'
- en: An example of a directory structure that is not good enough for large projects
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个目录结构的例子，对于大型项目来说并不够好
- en: Imagine one directory with 1,200 reducers to scroll through. You would probably
    use search instead. Believe me, this also becomes tough with 1,200 reducers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有1,200个减速器的目录。你可能会使用搜索。相信我，这在有1,200个减速器的情况下也会变得困难。
- en: 'Instead, it is much better to group code by features. Thanks to this, we will
    have a clear scope of files to look at while investigating a certain isolated
    part of the application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，更好的做法是按功能对代码进行分组。由此，我们将清楚地了解在调查应用程序的某个独立部分时要查看的文件范围：
- en: '![](Images/44efa3e0-6d89-497a-be46-6d182e8ce91a.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/44efa3e0-6d89-497a-be46-6d182e8ce91a.png)'
- en: An example of a directory structure that may be good for medium to large projects
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对于中大型项目可能有好处的目录结构的例子
- en: To see this new structure in action, please check the code files of `Example
    1` from the `src` folder in  [Chapter 7](f5f1ab36-54de-49a6-b245-e0145fe78bf0.xhtml), *Navigation
    Patterns*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种新结构的实际效果，请查看[第7章](f5f1ab36-54de-49a6-b245-e0145fe78bf0.xhtml)中`src`文件夹中的`Example
    1`的代码文件，*导航模式*。
- en: If you have ever worked with microservices, think of it as if you wanted your
    features to be simple micro services within your frontend code base. A screen
    may ask them to operate by sending data, and expects a certain output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过微服务，可以将其想象成你希望你的功能在前端代码库中成为简单的微服务。一个屏幕可能会要求它们通过发送数据来运行，并期望特定的输出。
- en: In some architectures, every such entity also creates its own Flux store. This
    is a good separation of concerns for large projects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些架构中，每个这样的实体也会创建自己的Flux存储。这对于大型项目来说是一个很好的关注点分离。
- en: React Navigation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Navigation
- en: 'Browsers have a navigation solution baked in, React Native needs to have an
    own one, and there is a reason behind this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器内置了导航解决方案，React Native需要有自己的解决方案，这其中是有原因的：
- en: '"In a web browser, you can link to different pages using an anchor (<a>) tag.
    When the user clicks on a link, the URL is pushed to the browser history stack.
    When the user presses the back button, the browser pops the item from the top
    of the history stack, so the active page is now the previously visited page. React
    Native doesn''t have a built-in idea of a global history stack like a web browser
    does -- this is where React Navigation enters the story."'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: “在 Web 浏览器中，您可以使用锚点（<a>）标签链接到不同的页面。当用户点击链接时，URL 将被推送到浏览器历史堆栈中。当用户按下返回按钮时，浏览器将从历史堆栈的顶部弹出项目，因此活动页面现在是先前访问的页面。React
    Native 没有像 Web 浏览器那样内置全局历史堆栈的概念 - 这就是 React Navigation 进入故事的地方。”
- en: '- React Navigation official documentation, available at:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '- React Navigation 官方文档，可在以下网址找到：'
- en: '[https://reactnavigation.org/docs/en/hello-react-navigation.html](https://reactnavigation.org/docs/en/hello-react-navigation.html).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactnavigation.org/docs/en/hello-react-navigation.html](https://reactnavigation.org/docs/en/hello-react-navigation.html)。'
- en: To sum this up, our mobile navigation can be handled not only like that seen
    in a browser, but also in any custom way we please. This is thanks to historical
    reasons, as some screen changes are usually tied to particular animations that
    users of the specific operating system do recognize. Thus, it is wise to follow
    them as closely as possible to resemble the native feel.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们的移动导航不仅可以像在浏览器中看到的那样处理，而且可以按照我们喜欢的任何自定义方式处理。这要归功于历史原因，因为一些屏幕更改通常与特定操作系统的用户所认可的特定动画相关联。因此，尽可能地遵循它们以使其类似于原生感觉是明智的。
- en: Using React Navigation
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Navigation
- en: 'Let''s start our journey with React Navigation by installing the library with
    the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令安装 React Navigation 库开始我们的旅程：
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the library is installed, let's try the easiest path and use a stack navigation
    system that resembles the type seen in a browser.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库安装完成，让我们尝试最简单的路径，使用一个类似于浏览器中看到的堆栈导航系统。
- en: For those of you who do not know, or have forgotten what a stack is, the name
    stack comes from a real-life analogy to a set of items stacked on top of each
    other. Item can be pushed to the stack (placed at the top), or popped from the
    stack (taken from the top).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不知道或忘记堆栈是什么的人，堆栈这个名字来源于现实生活中一组物品堆叠在一起的类比。物品可以被推到堆栈中（放在顶部），或者从堆栈中弹出（从顶部取出）。
- en: A special structure, pushing this idea further, resembles a horizontal stack
    with access from both the bottom and top. Such a structure is called a queue;
    however, we will not use queues in this book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的结构，进一步推动这个想法，类似于一个水平堆栈，可以从底部和顶部访问。这样的结构被称为队列；然而，在本书中我们不会使用队列。
- en: 'In the previous section, I made a refactor of our file structure. As part of
    the refactor, I created a new file, called `TaskListScreen`, which is made up
    of features from our code base:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我对我们的文件结构进行了重构。作为重构的一部分，我创建了一个新文件，名为`TaskListScreen`，它由我们代码库中的特性组成：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `withGeneralLayout` HOC is also part of the refactor and all it does is
    wrap the screen with a header and bottom bar. Such a wrapped `TaskList` component
    is ready to be called a `Screen` and be provided straight to the React Navigation
    setup:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`withGeneralLayout` HOC 也是重构的一部分，它所做的就是用头部和底部栏包装屏幕。这样包装的 `TaskList` 组件准备好被称为
    `Screen` 并直接提供给 React Navigation 设置：'
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we use a `createStackNavigator` function that expects two objects:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个期望两个对象的 `createStackNavigator` 函数：
- en: An object representing all of the screens that should be handled by this `StackNavigator`.
    Each of the screens should specify a component that represents this screen and
    path. You can also use `navigationOptions` to customize your screen. In our case,
    we do not want the default header bar.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表应该由这个`StackNavigator`处理的所有屏幕的对象。每个屏幕都应该指定一个代表该屏幕和路径的组件。您还可以使用`navigationOptions`来自定义您的屏幕。在我们的情况下，我们不想要默认的标题栏。
- en: An object representing the settings of the navigator itself. You probably want
    to define the initial route name and its parameters.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表导航器本身的设置对象。您可能想要定义初始路由名称及其参数。
- en: Having done this, we have finished the hello world of navigation – we have one
    screen working.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些，我们已经完成了导航的hello world - 我们有一个屏幕在工作。
- en: Multiple screens with React Navigation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Navigation的多个屏幕
- en: 'It''s time to add a Task screen to our `StackNavigator`. Use your newly learned
    syntax and create a placeholder screen for task details. The following is my implementation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向我们的`StackNavigator`添加一个任务屏幕了。使用你新学到的语法，为任务详情创建一个占位符屏幕。以下是我的实现：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This time, I also pass `navigationOptions`, as I want to use the default navigator
    top bar with a specific title:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我还传递了`navigationOptions`，因为我想使用具有特定标题的默认导航器顶部栏：
- en: '![](Images/65bb51fc-698b-4430-911b-02d7092141a3.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/65bb51fc-698b-4430-911b-02d7092141a3.png)'
- en: An example of how the new Task screen could look
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 新任务屏幕可能的样子
- en: 'To navigate to Task Details, we will need a separate link or button that will
    take us there. Let''s create a reusable one in the top of our directory structure,
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到任务详情，我们需要一个单独的链接或按钮，可以带我们到那里。让我们在我们的目录结构的顶部创建一个可重用的链接，如下所示：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last line in the preceding snippet uses the `withNavigation` HOC, which
    is part of React Navigation. This HOC provides the navigation prop to `NavigateButton`.
    `To`, `data`, and `text` need to be passed manually to the component:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段的最后一行使用了`withNavigation` HOC，这是React Navigation的一部分。这个HOC为`NavigateButton`提供了导航属性。`To`、`data`和`text`需要手动传递给组件：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s it! Let''s look at the following result. Use your skills from [Chapter
    3,](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml) *Styling Patterns*, if you feel
    the design needs a little polish:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！让我们看看以下的结果。如果你觉得设计需要一点润色，可以使用[第三章](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml)
    *样式模式*中学到的技巧：
- en: '![](Images/ed751d62-83e8-4209-a870-e3a580005433.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ed751d62-83e8-4209-a870-e3a580005433.png)'
- en: Each Task row is now displaying a Details link
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务行现在都显示了一个详情链接
- en: You can now tap the Details button to navigate to the Task Details screen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以点击详情按钮导航到任务详情屏幕。
- en: Tab navigation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签导航
- en: 'As we already have the bottom icon controls in place, it will be very straightforward
    to make them work. This is a classic example for tab navigation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经放置了底部图标控件，使它们工作将非常简单。这是标签导航的一个经典示例：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Please note the use of shorthand for creating screens. Instead of using an
    object, I pass the component directly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用缩写创建屏幕的用法。我直接传递组件，而不是使用对象：
- en: '![](Images/c3ca77f7-38a2-4c25-a493-303606816378.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c3ca77f7-38a2-4c25-a493-303606816378.png)'
- en: By default, React Navigation will create a bottom bar for us
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Navigation会为我们创建一个底部栏
- en: 'To disable the bar, we need to pass the appropriate prop, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用标题栏，我们需要传递适当的属性，如下所示：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we need to make our icons respond to a user''s touch. First, create a `NavigateIcon`
    component that you can reuse in your app. Check the repository for a full code
    sample, but an example is provided here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让我们的图标响应用户的触摸。首先，创建一个`NavigateIcon`组件，你可以在你的应用程序中重用。查看存储库以获取完整的代码示例，但这里提供了一个示例：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is fairly straightforward to replace existing icons with the `NavigateIcon`,
    as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用`NavigateIcon`相当简单地替换现有的图标，如下所示：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last thing to take care of is the general layout. The `Search` and `Notifications`
    screens should display our custom bottom navigation. This is surprisingly easy
    thanks to the HOC pattern we have learned:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是一般布局。`Search`和`Notifications`屏幕应该显示我们的自定义底部导航。由于我们学到的HOC模式，这 surprisingly容易：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The results are shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![](Images/db515245-8a78-4128-88b4-36cf98f04933.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/db515245-8a78-4128-88b4-36cf98f04933.png)'
- en: The Search screen with its placeholder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索屏幕及其占位符。
- en: Please fix the header name by adding a configuration object to the `withGeneralLayout`
    HOC.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过向`withGeneralLayout` HOC添加配置对象来修复标题名称。
- en: Drawer navigation
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽屉导航
- en: 'It''s time to implement drawer navigation to allow users to access less commonly
    used screens, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现抽屉导航，以便用户访问不常用的屏幕，如下所示：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we have our default drawer ready, let''s add an icon which will show it.
    The hamburger icon is the most popular, and is usually placed within one of the
    header corners:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的默认抽屉已准备就绪，让我们添加一个图标来显示它。汉堡图标是最受欢迎的，通常放置在标题的一个角落：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, just place it in the header part of the `GeneralAppView` component and
    style it appropriately:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需将其放在`GeneralAppView`组件的标题部分并适当地进行样式设置：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s it, our drawer is fully functional. Your drawer might look something
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们的抽屉功能完全可用。您的抽屉可能看起来像这样：
- en: '![](Images/d22aea70-bfc0-4cc9-8961-7ae12d831c35.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d22aea70-bfc0-4cc9-8961-7ae12d831c35.png)'
- en: Opened drawer menu on the iPhone X simulator.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPhone X模拟器上打开抽屉菜单。
- en: You can open the drawer by clicking the hamburger icon in the upper right corner.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击右上角的汉堡图标来打开抽屉。
- en: Issues with duplicated data
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复数据的问题
- en: 'The task list component fetches the data necessary to display the list on its
    successful mounting. However, there is no mechanism implemented to prevent duplication
    of data. This book is not meant to provide recipes for common problems. However,
    let''s think of a few solutions you could implement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表组件在成功挂载时获取显示列表所需的数据。然而，没有实现防止数据重复的机制。本书不旨在为常见问题提供解决方案。然而，让我们考虑一些您可以实施的解决方案：
- en: Change the API and rely on unique task identifiers (such as ID, UUID, or GUID).
    Make sure you filter to only allow unique ones.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改API并依赖于唯一的任务标识符（如ID、UUID或GUID）。确保只允许唯一的标识符。
- en: Clear data on every request. This is good; however, in our case we would lose
    unsaved (API-related) tasks.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次请求都清除数据。这很好；然而，在我们的情况下，我们会丢失未保存的（与API相关的）任务。
- en: Maintain status, and only request once. This would work in our simple use case
    only. In more complex apps, you will need to update data more often.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持状态，并且只请求一次。这只适用于我们简单的用例。在更复杂的应用程序中，您将需要更频繁地更新数据。
- en: Okay, bearing this in mind, let's finally dive into the library based on a native
    navigation solution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，牢记这一点，让我们最终深入基于本地导航解决方案的库。
- en: React Native Navigation
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native Navigation
- en: In this section, we will play with a native solution for navigation. React Native
    Navigation is a wrapper on the native navigation for Android and iOS.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用本地解决方案进行导航。React Native Navigation是Android和iOS本地导航的包装器。
- en: Our goal is to recreate what we have achieved in the previous section, but with
    React Navigation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是重新创建我们在上一节中实现的内容，但使用React Navigation。
- en: A few words on the setup
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于设置的几句话
- en: One of the biggest challenges you may face in this section is setting up the
    library. Please follow the most up-to-date installation instructions. Take your
    time—it may take over 8 hours if you are not familiar with the tools and ecosystem.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您可能会面临的最大挑战之一是设置库。请遵循最新的安装说明。花点时间——如果您不熟悉工具和生态系统，可能需要超过8小时。
- en: Follow the installation instructions at the following link: [https://github.com/wix/react-native-navigation](https://github.com/wix/react-native-navigation).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下链接中的安装说明进行安装：[https://github.com/wix/react-native-navigation](https://github.com/wix/react-native-navigation)。
- en: This book uses the API from version 2 of React Native Navigation. To use the
    same code examples, you will need to install version 2 too.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用React Native Navigation第2版的API。要使用相同的代码示例，您也需要安装第2版。
- en: You may also need to either eject Create React Native App, or bootstrap another
    project with `react-native init` and copy the key files there. If you struggle
    with the process, try using the code from `src/Chapter 7/Example 6/` (just React
    Native) or `src/Chapter 7/Example 7/` (the whole React Native Navigation setup).
    I used `react-native init` and copied all of the important stuff there.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要要么退出Create React Native App，要么使用`react-native init`引导另一个项目并将关键文件复制到那里。如果您在这个过程中遇到困难，请尝试使用`src/Chapter
    7/Example 6/`（只是React Native）或`src/Chapter 7/Example 7/`（整个React Native Navigation设置）中的代码。我使用了`react-native
    init`并将所有重要的东西都复制到那里。
- en: There will be certainly errors on your path to a working setup. Don't get upset;
    search for any errors on StackOverflow or GitHub issues with React Native and
    React Native Navigation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现可工作的设置过程中，肯定会出现错误。不要沮丧；在StackOverflow上搜索任何错误或在React Native和React Native Navigation的GitHub问题中搜索。
- en: Basics of React Native Navigation
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native Navigation的基础知识
- en: 'The first big change is the lack of the `AppRegistry` and the `registerComponent`
    call. Instead, we will use `Navigation.setRoot(...)` and it will do the job. The
    `setRoot` function should only be invoked if we are certain that the application
    was launched successfully, as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重大变化是缺少`AppRegistry`和`registerComponent`的调用。相反，我们将使用`Navigation.setRoot(...)`来完成工作。只有在确定应用程序成功启动时，才应调用`setRoot`函数，如下所示：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our root/entry file will then only invoke the React Native Navigation function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的根/入口文件将只调用React Native Navigation函数：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay. The more interesting part is what we put into the `setRoot` function.
    Basically, we have a choice here: either stack navigation or tab navigation. Following
    our previous application, the top-level one will be tab navigation (drawer navigation
    is decoupled in React Native Navigation).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。更有趣的部分是我们放入`setRoot`函数的内容。基本上，我们在这里有一个选择：堆栈导航或标签导航。根据我们之前的应用程序，顶层应用将是标签导航（抽屉导航在React
    Native Navigation中是解耦的）。
- en: At the time of writing this book, using the default built-in bottom bar is the
    only option to retain previous capabilities. Once library authors release version
    2 of RNN and fix `Navigation.mergeOptions(...)`, you will be able to implement
    custom bottom bars.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，使用默认内置的底部栏是保留先前功能的唯一选项。一旦库作者发布RNN的第2版并修复`Navigation.mergeOptions(...)`，您就可以实现自定义底部栏。
- en: 'First, let''s remove the default top bar and customize the bottom bar:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们移除默认的顶部栏并自定义底部栏：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Having done that, we are ready to define the tabs. The very first thing to
    do in React Native Navigation is register the screens:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这一点，我们准备定义标签。在React Native Navigation中要做的第一件事是注册屏幕：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we have all of the basic three screens registered, we can proceed with
    tab definitions, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们注册了所有基本的三个屏幕后，我们可以按照以下方式进行标签定义：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We define every single tab out of the three – `Tasks`, `Search`, and `Notifications`.
    With regard to `Tasks`, this is another navigator. The `Stack` navigator can be
    configured as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个单独的标签 - `Tasks`，`Search`和`Notifications`。关于`Tasks`，这是另一个导航器。`Stack`导航器可以配置如下：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding snippet, the `bottomTab` options set the text and icon in
    the bottom bar:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，`bottomTab`选项设置了底部栏中的文本和图标：
- en: '![](Images/742b3f87-12e2-4516-a3ec-fac4f7712eb2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/742b3f87-12e2-4516-a3ec-fac4f7712eb2.png)'
- en: The Tasks tab with React Native Navigation
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native Navigation的任务选项卡
- en: Further investigation
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步调查
- en: I'll leave the investigation of how to implement navigation elements, such as
    the Drawer or Task Detail screens, to those of you who are brave enough. At the
    time of writing, React Native Navigation v2 is quite unstable and I chose not
    to publish any more snippets from this library. For most readers, this should
    be enough to get the overall feeling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把如何实现导航元素（如抽屉或任务详情屏幕）的调查留给那些勇敢的人。在撰写本文时，React Native Navigation v2相当不稳定，我选择不再发布来自该库的任何片段。对于大多数读者来说，这应该足够让他们对整体感觉有所了解。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we finally expanded our application with far more views than
    before. You have learned different approaches to navigation in mobile applications.
    In the React Native world, it is either native navigation, JavaScript navigation,
    or a hybrid of the two. Along with learning navigation itself, we have used components
    including `StackNavigation`, `TabNavigation`, and `DrawerNavigation`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们最终扩展了我们的应用程序，比以前有更多的视图。您已经学会了移动应用程序中不同的导航方法。在React Native世界中，要么是原生导航，要么是JavaScript导航，或者两者的混合。除了学习导航本身，我们还使用了包括`StackNavigation`、`TabNavigation`和`DrawerNavigation`在内的组件。
- en: For the first time, we have also ejected the Create React Native App and installed
    native code from the native navigation library. We are starting to dive really
    deeply into React Native. Now is the time to step back and refresh our JavaScript
    knowledge. We will learn patterns that are not only beneficial in React Native,
    but in JavaScript overall.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次将Create React Native App弹出，并从原生导航库中安装了原生代码。我们开始深入研究React Native。现在是时候退后一步，更新我们的JavaScript知识了。我们将学习不仅在React
    Native中有益的模式，而且在整个JavaScript中都有益的模式。
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'React Navigation common mistakes – from the official documentation, available
    at:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Navigation常见错误-来自官方文档，可在以下链接找到：
- en: '[https://reactnavigation.org/docs/en/common-mistakes.html](https://reactnavigation.org/docs/en/common-mistakes.html).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactnavigation.org/docs/en/common-mistakes.html](https://reactnavigation.org/docs/en/common-mistakes.html)。'
- en: 'Thousand ways to navigate in React Native, by Charles Mangwa:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Charles Mangwa的《在React Native中导航的千种方式》：
- en: '[https://www.youtube.com/watch?v=d11dGHVVahk.](https://www.youtube.com/watch?v=d11dGHVVahk)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=d11dGHVVahk.](https://www.youtube.com/watch?v=d11dGHVVahk)'
- en: 'Navigation playground for React Navigation:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Navigation的导航游乐场：
- en: '[https://expo.io/@react-navigation/NavigationPlayground](https://expo.io/@react-navigation/NavigationPlayground).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://expo.io/@react-navigation/NavigationPlayground](https://expo.io/@react-navigation/NavigationPlayground)。'
- en: 'Expo documentation on navigation:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo关于导航的文档：
- en: '[https://docs.expo.io/versions/v29.0.0/guides/routing-and-navigation](https://docs.expo.io/versions/v29.0.0/guides/routing-and-navigation).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.expo.io/versions/v29.0.0/guides/routing-and-navigation](https://docs.expo.io/versions/v29.0.0/guides/routing-and-navigation)。'
- en: 'Material Design on Tabs:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的Material Design：
- en: '[https://material.io/design/components/tabs.html#placement](https://material.io/design/components/tabs.html#placement).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://material.io/design/components/tabs.html#placement](https://material.io/design/components/tabs.html#placement)。'
- en: 'Section on Navigation within the Awesome React Native repository:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Awesome React Native存储库中关于导航的部分：
- en: '[https://github.com/jondot/awesome-react-native#navigation](https://github.com/jondot/awesome-react-native#navigation).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jondot/awesome-react-native#navigation](https://github.com/jondot/awesome-react-native#navigation)。'
