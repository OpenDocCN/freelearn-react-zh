- en: Optimizing the Performance of Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的应用的性能
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Optimizing our JavaScript code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化我们的JavaScript代码
- en: Optimizing the performance of custom UI components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化自定义UI组件的性能
- en: Keeping animations running at 60 FPS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持动画以60 FPS运行
- en: Getting the most out of ListView
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用ListView
- en: Boosting the performance of our app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升我们应用的性能
- en: Optimizing the performance of native iOS modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化原生iOS模块的性能
- en: Optimizing the performance of native Android modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化原生Android模块的性能
- en: Optimizing the performance of native iOS UI components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化原生iOS UI组件的性能
- en: Optimizing the performance of native Android UI components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化原生Android UI组件的性能
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Performance is a key requirement of almost every single piece of technology
    in software development. React Native was introduced to solve the issue of poor
    performance that existed in hybrid apps that wrap web applications in a native
    container. React Native has an architecture that lends itself to both flexibility
    and excellent performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是软件开发中几乎每一个技术的关键要求。React Native被引入是为了解决混合应用中存在的性能不佳的问题，这些混合应用将Web应用程序包装在本地容器中。React
    Native具有既灵活又出色性能的架构。
- en: 'When considering the performance of a React Native app, it is important to
    think about the big picture of how React Native works. There are three major parts
    to a React Native app, and their relative performance is depicted in the following
    diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑React Native应用的性能时，重要的是要考虑React Native的工作方式的整体情况。React Native应用有三个主要部分，它们的相对性能如下图所示：
- en: '![](assets/5e5d3840-ef23-43ba-b367-5883966d71e8.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5e5d3840-ef23-43ba-b367-5883966d71e8.png)'
- en: The recipes in this chapter focus on using lower-level functions that take up
    less memory and have fewer operations, thus lowering the time it takes for a task
    to complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的配方侧重于使用占用更少内存并具有更少操作的低级函数，从而降低任务完成所需的时间。
- en: Optimizing our JavaScript code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我们的JavaScript代码
- en: It's safe to say that your React Native apps will probably be written mostly
    in JavaScript. There may be some native modules and custom UI components, but
    for the most part, all of the views and business logic will likely be written
    in JSX and JavaScript. And if you're using modern JavaScript development techniques,
    you'll also be using language constructs introduced with ES6, ES7, and beyond.
    These may be available natively as part of the JavaScript interpreter bundled
    with React Native (JavaScriptCore) or polyfilled by the Babel transpiler. Since
    JavaScript probably constitutes the majority of any given React Native app, this
    should be the first part we optimize in order to squeeze extra performance out
    of the app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，您的React Native应用可能主要是用JavaScript编写的。可能会有一些原生模块和自定义UI组件，但大部分视图和业务逻辑可能都是用JSX和JavaScript编写的。如果您使用现代JavaScript开发技术，您还将使用ES6、ES7及更高版本引入的语言构造。这些可能作为React
    Native捆绑的JavaScript解释器（JavaScriptCore）的一部分本地可用，也可能由Babel转译器进行填充。由于JavaScript可能构成任何给定的React
    Native应用的大部分，这应该是我们优化的第一部分，以便从应用中挤出额外的性能。
- en: This recipe will provide some helpful tips for optimizing JavaScript code to
    make it as performant as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将提供一些有用的提示，以优化JavaScript代码，使其尽可能高效。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is not necessarily dependent on React Native, since it focuses on
    the JavaScript that's used to write any React app. Some of these suggestions are
    micro-optimizations that will probably only improve performance on older/slower
    devices. Depending on which devices you intend to support, some tips will go further
    than others.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧不一定依赖于React Native，因为它侧重于用于编写任何React应用程序的JavaScript。其中一些建议是微优化，可能只会提高旧版/较慢设备的性能。根据您打算支持的设备，一些技巧会比其他技巧更有效。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first optimization to look at is speeding up iterations. Often, you''ll
    likely be using functions that take iterator functions as arguments (`forEach`,
    `filter`, and `map`). As a rule of thumb, these will be slower than doing a standard
    `for` loop. If the size of the collection you''re iterating over is very large,
    this could make a difference. Here''s an example of a faster filter function:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要考虑的第一个优化是加快迭代速度。通常，您可能会使用将迭代器函数作为参数的函数（`forEach`，`filter`和`map`）。一般来说，这些方法比使用标准的`for`循环要慢。如果您要迭代的集合非常大，这可能会有所不同。以下是一个更快的filter函数的示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When optimizing iterations, it can also be more performant to ensure that you
    store the variables you are accessing on the iteration, somewhere close by:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在优化迭代时，还可以更有效地确保将您正在访问的变量存储在迭代附近的某个地方：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also optimize your logical expressions. Keep your fastest and closest
    executing statements on the left:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以优化逻辑表达式。将执行速度最快且最接近的语句放在左边：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While modern JavaScript (ES6, ES7, and so on) constructs can be more enjoyable
    to develop with, some of their features execute more slowly than their ES5 counterparts.
    These features can include `for of`, `generators`, `Object.assign`, and others.
    A good reference for performance comparisons can be found at [https://kpdecker.github.io/six-speed/](https://kpdecker.github.io/six-speed/).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然现代JavaScript（ES6，ES7等）构造可能更容易开发，但它们的一些特性执行速度比它们的ES5对应物要慢。这些特性包括`for of`，`generators`，`Object.assign`等。有关性能比较的良好参考资料可以在[https://kpdecker.github.io/six-speed/](https://kpdecker.github.io/six-speed/)找到。
- en: It can be helpful to avoid `try-catch` statements, since they can affect the
    optimization made by the interpreter (as is the case in V8).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免使用`try-catch`语句可能会有所帮助，因为它们会影响解释器的优化（就像在V8中一样）。
- en: Arrays should have members that are all of the same type. If you need to have
    a collection where the type can vary, use an object.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组应该有相同类型的成员。如果需要一个类型可以变化的集合，可以使用对象。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: JavaScript performance is a topic of constant debate. It is sometimes difficult
    to keep up with the latest in performance metrics, since Google, Apple, Mozilla,
    and the global open source community is always hard at work improving their JavaScript
    engines. For React Native, we focus on WebKit's JavaScriptCore.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript性能是一个不断争论的话题。由于谷歌、苹果、Mozilla和全球开源社区一直在努力改进他们的JavaScript引擎，因此有时很难跟上最新的性能指标。对于React
    Native，我们关注的是WebKit的JavaScriptCore。
- en: Optimizing the performance of custom UI components
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化自定义UI组件的性能
- en: While building your React Native app, it's a safe bet that you will be creating
    custom UI components. These components can either be compositions of several other
    components or a component that builds on top of an existing component and adds
    more functionality. With added functionality, complexity also increases. This
    increased complexity leads to more operations, and in turn, the potential for
    slowdowns. Fortunately, there are some ways to make sure that our custom UI components
    are performing the best they can. This recipe shows several techniques for getting
    the most out of our components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建React Native应用程序时，可以肯定会创建自定义UI组件。这些组件可以是由几个其他组件组成的，也可以是在现有组件的基础上构建并添加更多功能的组件。随着功能的增加，复杂性也会增加。这种增加的复杂性会导致更多的操作，从而可能导致减速。幸运的是，有一些方法可以确保我们的自定义UI组件性能最佳。本文介绍了几种技术，以便充分利用我们的组件。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires that you have a React Native app with some custom components.
    As these performance suggestions may or may not provide value to your app, use
    discretion when you choose to apply these to your code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本文要求您有一个带有一些自定义组件的React Native应用程序。由于这些性能建议可能对您的应用程序提供或不提供价值，请谨慎选择是否将其应用于您的代码。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The first optimization we should look at is what is tracked in the `state` object
    of a given component. We should make sure that all the objects we have in the
    `state` are being used, and that each can potentially change, causing a desired
    re-render.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该首先查看的优化是跟踪给定组件的`state`对象中的内容。我们应该确保`state`中的所有对象都被使用，并且每个对象都可能发生变化，从而引起所需的重新渲染。
- en: Take a look at the `render` function of each component. The overall goal is
    to keep this function performing as fast as possible, so try to ensure that no
    long-running processes occur within it. If you can, cache computations and constant
    values outside the `render` function so that they are not instantiated every time.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看每个组件的`render`函数。总体目标是使该函数尽可能快地执行，因此请尽量确保其中不会发生长时间运行的过程。如果可以的话，缓存计算和常量值，使其在`render`函数之外不会每次实例化。
- en: 'If you have conditional JSX that may return in the `render` function, `return`
    as early as possible. Here''s a trivial example:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`render`函数中可能返回条件性JSX，请尽早`return`。以下是一个微不足道的例子：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The most important optimization we can make is to skip the `render` method
    altogether if it isn''t needed. This is done by implementing the `shouldComponentUpdate`
    method and returning `false` from it, making it a pure component. Here''s how
    we can make a component a `PureComponent`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进行的最重要的优化是如果不需要，可以完全跳过`render`方法。这是通过实现`shouldComponentUpdate`方法并从中返回`false`来实现的，使其成为纯组件。以下是如何使组件成为`PureComponent`的方法：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The majority of your React Native apps will consist of custom components. There
    will be a mix of stateful and stateless components. As highlighted in *step 2*,
    the overall goal is to render our component in the shortest amount of time possible.
    Another gain can be achieved if a component can be architected to only have to
    render the component once and then be left untouched, as covered in *step 4*.
    For more information on how pure components are used and how they can be beneficial,
    check out [https://60devs.com/pure-component-in-react.html](https://60devs.com/pure-component-in-react.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数React Native应用程序将由自定义组件组成。将有一些有状态和无状态的组件。正如在*步骤2*中所强调的，总体目标是以尽可能短的时间渲染我们的组件。如果一个组件只需要渲染一次，然后保持不变，那么也可以实现另一个收益，就像在*步骤4*中介绍的那样。有关纯组件的使用方法和其益处的更多信息，请访问[https://60devs.com/pure-component-in-react.html](https://60devs.com/pure-component-in-react.html)。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find some more information about React component performance optimizations
    in the official documentation at [https://reactjs.org/docs/optimizing-performance.html](https://reactjs.org/docs/optimizing-performance.html).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档[https://reactjs.org/docs/optimizing-performance.html](https://reactjs.org/docs/optimizing-performance.html)中找到有关React组件性能优化的更多信息。
- en: Keeping animations running at 60 FPS
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持动画以60FPS运行
- en: An important aspect of any quality mobile app is the fluidity of the user interface.
    Animations are used to provide a rich user experience, and any jank or jitter
    can negatively affect this. Animations will likely be used for all kinds of interactions,
    from changing between views, to reacting to a user's touch interaction on a component.
    One of the most important factors in creating high-quality animations is making
    sure that they do not block the JavaScript thread. To keep animations fluid and
    not interrupt UI interactions, the render loop has to render each frame in 16.67
    ms, so that 60 FPS can be achieved.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何高质量移动应用程序的重要方面是用户界面的流畅性。动画用于提供丰富的用户体验，任何卡顿或抖动都可能对此产生负面影响。动画可能会用于各种交互，从在视图之间切换到对组件上的用户触摸交互做出反应。创建高质量动画的最重要因素之一是确保它们不会阻塞JavaScript线程。为了保持动画流畅并且不中断UI交互，渲染循环必须在16.67毫秒内渲染每一帧，以便实现60FPS。
- en: In this recipe, we will take a look at several techniques for improving the
    performance of animations. These techniques focus in particular on preventing
    JavaScript execution from interrupting the main thread.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将介绍几种改善动画性能的技术。这些技术特别关注于防止JavaScript执行中断主线程。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll assume that you have a React Native app that has some
    animations defined.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们假设您有一个定义了一些动画的React Native应用程序。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First and foremost, when debugging animation performance in React Native, we'll
    want to enable the performance monitor. To do so, show the Dev Menu (shake the
    device or *cmd* + *D* from the simulator) and tap Show Perf Monitor.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在调试React Native中的动画性能时，我们需要启用性能监视器。要这样做，显示开发菜单（摇动设备或从模拟器中使用*cmd* + *D*）并点击显示性能监视器。
- en: 'The output in iOS will look something like the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS中的输出将类似于以下截图：
- en: '![](assets/736fdab4-9302-4864-919c-976104b70754.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/736fdab4-9302-4864-919c-976104b70754.png)'
- en: 'The output in Android will look something like the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中的输出将类似于以下截图：
- en: '![](assets/4bccef67-4132-4af7-a859-3cacb76cf832.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4bccef67-4132-4af7-a859-3cacb76cf832.png)'
- en: If you are looking to animate a component's transition (`opacity`) or dimensions
    (`width`, `height`), then make sure to use `LayoutAnimation`. You can find an
    example of using `LayoutAnimation` in [Chapter 6](84fe882a-ef68-470e-8c13-d220b128d4e0.xhtml), *Adding
    Basic* *Animations to Your App*, in the *Expanding and collapsing containers* recipe.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要对组件的过渡（`opacity`）或尺寸（`width`，`height`）进行动画处理，则确保使用`LayoutAnimation`。您可以在[第6章](84fe882a-ef68-470e-8c13-d220b128d4e0.xhtml)的*向您的应用程序添加基本动画*中找到使用`LayoutAnimation`的示例，在*展开和折叠容器*的教程中。
- en: If you want to use `LayoutAnimation` on Android, you need to add the following
    code when your application starts: `UIManager.setLayoutAnimationEnabledExperimental
    && UIManager.setLayoutAnimationEnabledExperimental(true)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Android上使用`LayoutAnimation`，则需要在应用程序启动时添加以下代码：`UIManager.setLayoutAnimationEnabledExperimental
    && UIManager.setLayoutAnimationEnabledExperimental(true)`。
- en: 'If you need finite control over the animations, it is recommended that you
    use the `Animated` library that comes with React Native. This library allows you
    to offload all of the animation work onto the native UI thread. To do so, we have
    to add the `useNativeDriver` property to our `Animated` call. Let''s take a sample
    `Animated` example and offload it to the native thread:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要对动画有限的控制，建议您使用React Native附带的`Animated`库。该库允许您将所有动画工作卸载到本地UI线程上。为此，我们必须将`useNativeDriver`属性添加到我们的`Animated`调用中。让我们以一个示例`Animated`示例并将其卸载到本地线程：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Currently, only a subset of the functionality of the Animated library supports
    native offloading. Please refer to the *There's more...* section for a compatibility
    guide.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，仅动画库的部分功能支持本地卸载。请参考*还有更多...*部分以获取兼容性指南。
- en: 'If you are unable to offload your animation work onto the native thread, there
    is still a solution for providing a smooth experience. We can use the `InteractionManager`
    to execute a task after the animations have completed:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您无法将动画工作卸载到本地线程上，仍然有解决方案可以提供流畅的体验。我们可以使用`InteractionManager`在动画完成后执行任务：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, if you are still suffering from poor performance, you'll have to either
    rethink your animation strategy or implement the poorly performing view as a custom
    UI view component on the target platform(s). This would mean implementing both
    your view and animation natively using the iOS and/or Android SDK. In [Chapter
    11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*,
    we covered creating custom UI components in the *Rendering custom iOS view components* and
    *Rendering custom Android view components* recipes.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果您仍然遇到性能问题，您将不得不重新考虑您的动画策略，或者在目标平台上将性能不佳的视图实现为自定义UI视图组件。这意味着使用iOS和/或Android
    SDK本地实现您的视图和动画。在[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中，*添加本地功能*，我们介绍了在*渲染自定义iOS视图组件*和*渲染自定义Android视图组件*中创建自定义UI组件的方法。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The tips in this recipe focus on the simple goal of preventing the JavaScript
    thread from locking. The moment our JavaScript thread begins to drop frames (lock),
    we lose the ability to interact with our application, even if it's for a fraction
    of a second. It may seem inconsequential, but the effect is felt immediately by
    a savvy user. The focus of the tips in this recipe is to offload animations onto
    the GPU. When the animation is running on the main thread (the native layer, rendered
    by the GPU), the user can interact with the app freely without stuttering, hanging,
    jank, or jitters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的提示侧重于防止JavaScript线程锁定的简单目标。一旦我们的JavaScript线程开始丢帧（锁定），即使只有一小部分时间，我们也失去了与应用程序交互的能力。这似乎微不足道，但敏锐的用户立即就能感受到影响。本食谱中的提示的重点是将动画卸载到GPU上。当动画在主线程上运行（由GPU渲染的本地层），用户可以自由地与应用程序交互，而不会出现卡顿、挂起、抖动或颤动。
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here''s a quick reference for where `useNativeDriver` is usable:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`useNativeDriver`可用的快速参考：
- en: '| **Function** | **iOS** | **Android** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **iOS** | **Android** |'
- en: '| `style`, `value`, `propertys` | **√** | **√** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `style`, `value`, `propertys` | **√** | **√** |'
- en: '| `decay` |  | **√** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `decay` |  | **√** |'
- en: '| `timing` | **√** | **√** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `timing` | **√** | **√** |'
- en: '| `spring` |  | **√** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `spring` |  | **√** |'
- en: '| `add` | **√** | **√** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `add` | **√** | **√** |'
- en: '| `multiply` | **√** | **√** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `multiply` | **√** | **√** |'
- en: '| `modulo` | **√** |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `modulo` | **√** |  |'
- en: '| `diffClamp` | **√** | **√** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `diffClamp` | **√** | **√** |'
- en: '| `interpoloate` | **√** | **√** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `interpoloate` | **√** | **√** |'
- en: '| `event` |  | **√** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `event` |  | **√** |'
- en: '| `division` | **√** | **√** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `division` | **√** | **√** |'
- en: '| `transform` | **√** | **√** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `transform` | **√** | **√** |'
- en: Getting the most out of ListView
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用ListView
- en: React Native provides a pretty performant list component out of the box. It
    is extremely flexible, supports rendering almost any component you can imagine
    inside of it, and renders them rather quickly. If you'd like to read some more
    examples of how to work with `ListView`, there are a couple of recipes in this
    book, including *Displaying a list of items* in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App*, that use it. The React Native `ListView` is built
    on top of `ScrollView` to achieve the flexibility of rendering variable-height
    rows with any view component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: React Native提供了一个非常高性能的列表组件。它非常灵活，支持在其中渲染几乎任何您可以想象的组件，并且渲染速度相当快。如果您想阅读更多关于如何使用`ListView`的示例，本书中有一些示例，包括[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中的*显示项目列表*，*创建一个简单的React
    Native应用程序*。React Native的`ListView`是建立在`ScrollView`之上的，以实现使用任何视图组件呈现可变高度行的灵活性。
- en: The major performance and resource drawback of the `ListView` component occurs
    when you are working with an extremely large list. As the user scrolls through
    the list, the next page of rows is rendered at the bottom. The invisible rows
    at the top can be set to be removed from the render tree, which we will cover
    shortly. However, the references to the rows are still in memory as long as the
    component is mounted. Naturally, as our component uses up the available memory,
    there will be less room for quickly accessible storage for the upcoming components.
    This recipe will cover dealing with some of these potential performance and memory
    resource issues.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`组件的主要性能和资源缺点是当您使用非常大的列表时发生。当用户滚动列表时，下一页的行在底部被渲染。顶部的不可见行可以设置为从渲染树中删除，我们将很快介绍。但是，只要组件被挂载，行的引用仍然在内存中。当我们的组件使用可用内存时，将会减少快速访问存储给即将到来的组件的空间。这个示例将涵盖处理一些潜在的性能和内存资源问题。'
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we assume that you have a React Native app that is making use
    of a `ListView`, preferably with a large dataset.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们假设您有一个使用`ListView`的React Native应用程序，最好是使用大型数据集。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start with some optimizations we can make to our vanilla `ListView` component.
    If we set the `initialListSize` property to `1`, we can speed up the initial rendering.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"在某些情况下，该功能可能存在错误（内容丢失）-使用时需自担风险。"'
- en: Next, we can bump up the `pageSize` if the component being rendered in each
    row is not complex.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果每行中呈现的组件不复杂，我们可以增加`pageSize`。
- en: Another optimization is setting the `scrollRenderAheadDistance` to a comfortable
    value. If you can expect users to rarely scroll past the initial viewport, or
    that they're likely to scroll slowly, then you can lower the value. This prevents
    the `ListView` from rendering too many rows in advance.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个优化是将`scrollRenderAheadDistance`设置为舒适的值。如果您可以预期用户很少会滚动到初始视口之外，或者他们可能会滚动得很慢，那么您可以降低该值。这可以防止`ListView`提前渲染太多行。
- en: 'Finally, the last optimization we can make use of is the `removeClippedSubviews`
    property. However, the official documentation states the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以利用`removeClippedSubviews`属性进行最后的优化。然而，官方文档指出：
- en: '"The feature may have bugs (missing content) in some circumstances - use at
    your own risk."'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对我们的原始`ListView`组件进行一些优化开始。如果我们将`initialListSize`属性设置为`1`，我们可以加快初始渲染。
- en: 'Combining *steps 1 to step 4* can be seen in the following example code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*步骤1到步骤4*的组合可以在以下示例代码中看到：'
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As with developing any app, the more flexible and complex something is, the
    slower it performs. `ListView` is an excellent example of this concept. It is
    extremely flexible, since it can render any `View` in a row, but it can quickly
    bring your application to a halt if not used carefully. The result of the optimizations
    defined in *step 1* to *step 4* will vary across different situations based on
    what you are rendering and the data structure that is being used by the `ListView`.
    You should experiment with these values until you find a good balance. As a last
    resort, if you are still unable to achieve the required performance benchmark,
    you can look at some of the community modules that provide new `ListView` implementations
    or alternatives.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与开发任何应用一样，某样东西越灵活和复杂，性能就越慢。`ListView`就是这个概念的一个很好的例子。它非常灵活，因为它可以在一行中呈现任何`View`，但如果不小心使用，它可能会迅速使您的应用停滞不前。在*步骤1*到*步骤4*中定义的优化结果将根据您正在呈现的内容和`ListView`使用的数据结构在不同情况下有所不同。您应该尝试这些值，直到找到一个良好的平衡。作为最后的手段，如果您仍然无法达到所需的性能基准，可以查看一些提供新的`ListView`实现或替代方案的社区模块。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The following is a list of some of the third-party `ListView` implementations
    that promise increased performance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些第三方`ListView`实现的列表，承诺提高性能：
- en: '`recyclerlistview`: This library is the most robust alternative to `ListView`,
    boasting a long list of improvements and features, including support for staggered
    grid layouts, horizontal mode, and footer support. The repository is located at
    [https://github.com/Flipkart/recyclerlistview](https://github.com/Flipkart/recyclerlistview).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recyclerlistview`：这个库是`ListView`的最强大的替代品，拥有一长串的改进和功能，包括支持交错网格布局、水平模式和页脚支持。存储库位于[https://github.com/Flipkart/recyclerlistview](https://github.com/Flipkart/recyclerlistview)。'
- en: '`react-native-sglistview`: This takes `removeClippedSubviews` to the next level
    by flushing the memory when the offscreen rows are removed from the render tree.
    The repository is located at [https://github.com/sghiassy/react-native-sglistview](https://github.com/sghiassy/react-native-sglistview).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-sglistview`：这将`removeClippedSubviews`提升到一个新的水平，当屏幕外的行从渲染树中移除时，会刷新内存。存储库位于[https://github.com/sghiassy/react-native-sglistview](https://github.com/sghiassy/react-native-sglistview)。'
- en: Boosting the performance of our app
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升我们应用的性能
- en: The reason for React Native's existence is building native apps with JavaScript.
    This is different than similar frameworks such as Ionic or Cordova hybrid applications,
    which wrap a web application written in JavaScript and attempt to emulate native
    app behavior. Those web applications only have access to native APIs for performing
    processing, but cannot render native views inside their apps. This is one major
    benefit to React Native apps, thus making them inherently faster than hybrid apps.
    Since it's so much more performant out of the box, we generally do not have to
    worry about overall performance as much as we would with a hybrid web app. Still,
    with a little extra effort, a slight improvement in performance might be achievable.
    This recipe will provide some quick wins that we can use to build faster React
    Native apps.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: React Native存在的原因是使用JavaScript构建原生应用。这与Ionic或Cordova混合应用等类似框架不同，后者包装了用JavaScript编写的Web应用，并尝试模拟原生应用行为。这些Web应用只能访问原生API来执行处理，但无法在应用内部呈现原生视图。这是React
    Native应用的一个主要优势，因此使它们本质上比混合应用更快。由于它的性能在开箱即用时更高，我们通常不必像处理混合Web应用那样担心整体性能。不过，通过一点额外的努力，可能可以实现性能的轻微改进。本文将提供一些快速的方法，可以用来构建更快的React
    Native应用。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: The simplest optimization we can make is to not output any statements to the
    console. Performing a `console.log` statement is not as trivial a task as you'd
    imagine for the framework, so it's recommended to remove all console statements
    when you are ready to bundle your final app.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以做的最简单的优化是不输出任何语句到控制台。执行`console.log`语句并不像您想象的那样简单，因此建议在准备捆绑最终应用程序时删除所有控制台语句。
- en: 'If you use a lot of console statements during development, you can have Babel
    automatically remove them when creating the bundle by using the `transform-remove-console` plugin.
    This can be installed into the project via the Terminal using `yarn`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在开发过程中使用了大量控制台语句，您可以使用`transform-remove-console`插件让Babel在创建捆绑时自动删除它们。这可以通过使用`yarn`在终端中将其安装到项目中。
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, you can use `npm`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以使用`npm`：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the package installed, you can add it to the project by adding a `.babelrc`
    file containing the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了该软件包后，您可以通过添加包含以下代码的`.babelrc`文件将其添加到项目中：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, make sure that when you're analyzing your performance, your app is running
    in production mode, preferably on a device. If you are curious about how to do
    this, you can refer to the *Deploying test builds to HockeyApp* recipe in Chapter
    13, *Deploying Our App*.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请确保在分析性能时，您的应用程序处于生产模式下运行，最好在设备上。如果您想了解如何做到这一点，您可以参考第13章*部署我们的应用程序*中的*将测试构建部署到HockeyApp*的配方。
- en: Sometimes, when you are animating the position or layout of a `View`, you may
    notice performance dips in the UI thread. You can mitigate this by setting the
    `shouldRasterizeIOS` and `renderToHardwareTextureAndroid` properties to true for
    iOS and Android platforms. Be mindful that this may increase memory usage significantly,
    so be sure to test the performance after these changes as well.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，当您在动画化`View`的位置或布局时，您可能会注意到UI线程的性能下降。您可以通过将`shouldRasterizeIOS`和`renderToHardwareTextureAndroid`属性设置为iOS和Android平台的true来减轻这种情况。请注意，这可能会显著增加内存使用量，因此请确保在这些更改后测试性能。
- en: If you find that you need to transition views using a navigation state change
    while also performing synchronous, potentially long-running processes, it can
    become a performance bottleneck. This commonly occurs when building a `DataSource`
    for a `ListView` or when transforming data to power the upcoming view. You should
    experiment with processing only an initial subset of the data, enough to render
    the UI quickly enough. Once the animation completes between page transitions,
    you can use `InteractionManager` to load the rest of the data. You can refer to
    the *Keeping animations running at 60 FPS* recipe for more information on how
    to use `InteractionManager`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您发现需要在执行同步的、潜在的长时间运行的过程的同时进行视图转换，这可能会成为性能瓶颈。当构建`ListView`的`DataSource`或转换数据以支持即将到来的视图时，通常会发生这种情况。您应该尝试仅处理数据的初始子集，足以快速渲染UI。一旦页面转换之间的动画完成，您可以使用`InteractionManager`来加载其余的数据。您可以参考*保持动画以60
    FPS运行*的配方，了解如何使用`InteractionManager`的更多信息。
- en: Finally, if you have identified a particular component or task that is slowing
    down your app, and cannot find a viable solution, then you should consider moving
    it to the native thread by creating a native module or native UI component to
    implement this piece of functionality.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果您已经确定了减慢应用程序速度的特定组件或任务，并且找不到可行的解决方案，那么您应该考虑通过创建本机模块或本机UI组件将其移动到本机线程来实现这一功能。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe covers some higher-level and broader-scoped tips for all React Native
    apps. The most significant performance gains you will likely see from these tips
    are from moving a component to the native layer, as covered in *step 7*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程涵盖了一些更高级和更广泛的适用于所有React Native应用程序的技巧。您可能会从这些技巧中看到的最显著的性能提升是将组件移动到本地层，如*步骤7*中所述。
- en: Optimizing the performance of native iOS modules
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化原生iOS模块的性能
- en: Often, when building a React Native app, you will need to work with native Android
    and iOS code. You may have built these native modules to expose some extra functionality
    provided by a native API, or perhaps your app needed to perform an intensive background
    task.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建React Native应用程序时，通常需要使用原生Android和iOS代码。您可能已经构建了这些原生模块，以公开本地API提供的一些额外功能，或者您的应用程序需要执行密集的后台任务。
- en: As was touched on earlier, working in the native layer really allows you to
    make use of a device's full capacity. However, it doesn't mean that the code we
    write will automatically be the fastest it could be. There's always room to optimize
    and achieve performance gains.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，工作在本地层确实允许您充分利用设备的容量。但这并不意味着我们编写的代码将自动成为最快的。总是有优化和实现性能提升的空间。
- en: In this recipe, we will provide some tips on how to make your Objective-C code
    run a bit faster using the iOS SDKs. We will also consider how React Native and
    the React Native bridge, which is used to communicate between the JavaScript and
    the native layers, fit into the bigger picture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将提供一些关于如何使用iOS SDK使您的Objective-C代码运行得更快的技巧。我们还将考虑React Native和React
    Native桥接，它用于在JavaScript和本地层之间进行通信，如何融入更大的画面。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should have a React Native app that uses native modules that
    have been created for iOS. If you need help with writing native modules, take
    a look at the *Exposing custom iOS modules* recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您应该有一个使用为iOS创建的原生模块的React Native应用程序。如果您需要帮助编写原生模块，请查看[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中的*暴露自定义iOS模块*教程，*添加原生功能*。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First and foremost, when working with native modules, we have to be mindful
    of the data going through the React Native bridge. Keeping the data in cross-bridge
    events and callbacks to a minimum is always the goal, since the data serialization
    between Objective-C and JavaScript is very slow.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，当使用原生模块时，我们必须注意通过React Native桥传递的数据。始终保持跨桥事件和回调中的数据最少化是目标，因为Objective-C和JavaScript之间的数据序列化非常缓慢。
- en: If you need to keep data cached in memory for consumption by the native module,
    keep it stored in a local property or field variable. Native modules are singletons.
    Do this instead of returning a large object to store in the React Native component.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要将数据缓存在内存中，以便原生模块使用，可以将其存储在本地属性或字段变量中。原生模块是单例。这样做可以避免返回一个大对象以存储在React Native组件中。
- en: Sometimes, we have to leverage classes that are large because they are robust
    in their feature set. For the Objective-C and iOS side of things, instead of instantiating
    something like `NSDateFormatter` in your method each time that you expose the
    feature via `RCT_EXPORT_METHOD`, store the reference of this class as a property
    or an instance variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，我们必须利用因功能集而强大而庞大的类。对于Objective-C和iOS方面的事情，与其每次通过`RCT_EXPORT_METHOD`公开功能时在您的方法中实例化类似`NSDateFormatter`，不如将该类的引用存储为属性或实例变量。
- en: 'Furthermore, native methods such as `NSDateFormatter` are often extremely heavy,
    so avoiding them is advisable where possible. For instance, if your application
    can deal with just UNIX timestamps, then you can easily get an `NSDate` object
    from a timestamp with the following function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，诸如`NSDateFormatter`之类的原生方法通常非常耗费资源，因此在可能的情况下应避免使用它们。例如，如果您的应用程序只能处理UNIX时间戳，那么您可以轻松地使用以下函数从时间戳获取`NSDate`对象：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The most significant performance optimization you can make, if the situation
    presents itself, is spawning asynchronous background threads to handle intensive
    processing. React Native fits this model well, since it uses an asynchronous messaging/event
    system to communicate between the JavaScript and native threads. When your background
    process is complete, you can either invoke a callback/promise or fire an event
    for the JavaScript thread to pick up. To learn how to create and leverage background
    processes in React Native iOS native modules, check out the *Background processing
    on iOS* recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果情况允许，您可以进行最重要的性能优化，即生成异步后台线程来处理密集处理。React Native非常适合这种模型，因为它使用异步消息/事件系统在JavaScript和原生线程之间进行通信。当后台进程完成时，您可以调用回调/承诺，或者触发一个事件供JavaScript线程处理。要了解如何在React
    Native iOS原生模块中创建和利用后台进程，请查看[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)的*在iOS上进行后台处理*。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Objective-C code executes very quickly – almost as quickly as vanilla C. Therefore,
    the optimizations we perform do not have much to do with executing tasks but rather
    with how things are instantiated and by not blocking native threads. The biggest
    performance boost you'll see is by property using the **Grand Central Dispatch**
    (**GCD**) to spawn background processes, as described in *step 5*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C代码执行非常快 - 几乎和纯C一样快。因此，我们进行的优化与执行任务的方式无关，而是与实例化方式和不阻塞原生线程有关。您将看到的最大性能提升是通过使用**Grand
    Central Dispatch**（**GCD**）生成后台进程，如*步骤5*中所述。
- en: Optimizing the performance of native Android modules
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化原生Android模块的性能
- en: While developing your React Native application, you may find yourself writing
    native Android modules to either create cross-platform features on both iOS and
    Android or to make use of native APIs that have not been wrapped as first-party
    modules for Android but that do exist on iOS. Hopefully, you found some useful
    advice on working with native modules in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发React Native应用程序时，您可能会发现自己编写原生Android模块，以创建跨平台功能（在iOS和Android上）或者利用尚未作为一方模块包装的Android原生API。希望您在[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)的*添加原生功能*中找到了一些有用的关于使用原生模块的建议。
- en: In this recipe, we will cover several techniques for speeding up our React Native
    Android native modules. Many of these techniques are limited to general development
    on Android,  and a few will address communicating with the React Native JavaScript
    layer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将介绍几种加快React Native Android原生模块速度的技术。其中许多技术仅限于Android上的一般开发，还有一些将涉及与React
    Native JavaScript层的通信。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should have a React Native app that makes use of the native
    modules you created for Android. If you need help with writing native modules,
    please take a look at the *Exposing custom Android modules* recipe in [Chapter
    11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您应该有一个使用您为Android创建的原生模块的React Native应用程序。如果您需要帮助编写原生模块，请查看[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)的*暴露自定义Android模块*配方。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First and foremost, just as with iOS native modules, you'll want to limit the
    amount of data crossing the React Native bridge. Keeping the data that's in events
    and callbacks to a minimum will help to avoid slowdowns caused by the serialization
    between Java and JavaScript. Also, as with iOS, try to keep data cached in memory
    to be used by the native module; keep it stored in a private field. Native modules
    are singletons. This should be leveraged instead of returning a large object to
    store in the React Native component.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，与iOS原生模块一样，您需要限制通过React Native桥传输的数据量。将事件和回调中的数据保持最少将有助于避免由Java和JavaScript之间的序列化引起的减速。此外，与iOS一样，尽量将数据缓存在内存中供原生模块使用；将其存储在私有字段中。原生模块是单例。这应该被利用，而不是返回一个大对象存储在React
    Native组件中。
- en: When writing Java code for Android, you should do your best to avoid creating
    short-term objects. If you can, use primitives, especially for datasets such as
    arrays.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为Android编写Java代码时，您应尽量避免创建短期对象。如果可能的话，尤其是对于数组等数据集，使用基本类型。
- en: It is better to reuse objects instead of relying on the garbage collector to
    pick up an unused reference and instantiate a new object.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好重用对象，而不是依赖垃圾收集器来回收未使用的引用并实例化一个新对象。
- en: 'The Android SDK provides a memory-efficient data structure for replacing the
    use of a `Map`, which maps integers to objects, called `SparseArray`. Using it
    can reduce memory usage and improve performance. Here''s an example:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android SDK提供了一种内存高效的数据结构，用于替代`Map`的使用，它将整数映射到对象，称为`SparseArray`。使用它可以减少内存使用并提高性能。以下是一个例子：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is also `SparseIntArray`, which maps integers to integers, and `SparseBooleanArray`,
    which maps integers to Boolean values.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`SparseIntArray`，它将整数映射到整数，以及`SparseBooleanArray`，它将整数映射到布尔值。
- en: While it may sound counterintuitive to developers used to OOP development in
    Java, avoiding the use of getters and setters by accessing the instance field
    directly can also improve performance.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然对于习惯于在Java中进行面向对象编程的开发人员来说可能听起来有些反直觉，但是通过直接访问实例字段来避免使用getter和setter也可以提高性能。
- en: If you're ever working with `String` concatenation, make use of `StringBuilder`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您曾经使用`String`连接，可以使用`StringBuilder`。
- en: Lastly, the most significant performance optimization you can make, if possible,
    is spawning asynchronous background threads to perform heavy computations by leveraging
    React Native's asynchronous messaging/event system to communicate between the
    JavaScript and native threads. When your background process is complete, you can
    either invoke a callback/promise or fire an event for the JavaScript thread to
    pick up. To learn how to create background processes in React Native Android native
    modules, please read the *Background processing on Android* recipe in [Chapter
    11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果可能的话，您可以进行最重要的性能优化，即通过利用React Native的异步消息/事件系统在JavaScript和本地线程之间进行通信，从而生成异步后台线程来执行繁重的计算。当后台进程完成时，您可以调用回调/承诺，或者触发一个事件，让JavaScript线程接手。要了解如何在React
    Native Android原生模块中创建后台进程，请阅读[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中的*在Android上进行后台处理*。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The majority of the tips in this recipe revolve around efficient memory management.
    The Android OS uses a traditional-style garbage collector similar to the desktop
    Java VM. When the garbage collector kicks in, it can take anywhere between 100-200
    ms to free memory. *Steps 3-6* all provide suggestions that reduce the app's memory
    usage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的大部分提示都围绕着高效的内存管理。Android操作系统使用类似桌面Java虚拟机的传统垃圾收集器。当垃圾收集器启动时，释放内存可能需要100-200毫秒。*步骤3-6*都提供了减少应用程序内存使用的建议。
- en: Optimizing the performance of native iOS UI components
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化原生iOS UI组件的性能
- en: React Native provides us with an excellent foundation to build almost any kind
    of user interface using built-in components and styling. Components built in Objective-C
    using the iOS SDK, OpenGL, or some other drawing library will generally perform
    better than composing the prebuilt components using JSX. When using these native
    view components, there are some use cases that may have a negative impact on app
    performance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: React Native为我们提供了一个优秀的基础，可以使用内置组件和样式构建几乎任何类型的用户界面。使用Objective-C使用iOS SDK、OpenGL或其他绘图库构建的组件通常比使用JSX组合预构建组件性能更好。在使用这些原生视图组件时，可能会有一些用例对应用程序性能产生负面影响。
- en: This recipe will focus on getting the most out of the iOS UIKit SDK when rendering
    custom views. Our goal is to render everything as quickly as possible for our
    application to run at 60 FPS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将专注于在渲染自定义视图时充分利用iOS UIKit SDK。我们的目标是尽可能快地渲染所有内容，以使我们的应用程序以60 FPS运行。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should have a React Native app that renders custom native
    UI components you have written for iOS. If you need help with wrapping UI components
    in React Native, please take a look at the *Exposing custom iOS view components* recipe
    in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你应该有一个渲染你为iOS编写的自定义原生UI组件的React Native应用程序。如果你需要帮助在React Native中包装UI组件，请查看[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中的*暴露自定义iOS视图组件*配方，*添加原生功能*。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: As mentioned previously, only pass data across the React Native bridge when
    it is unavoidable to do otherwise, since data serialization between Objective-C
    and JavaScript types is slow.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，只有在无法避免的情况下才通过React Native桥传递数据，因为Objective-C和JavaScript类型之间的数据序列化速度很慢。
- en: If there is data that you need to store for referencing sometime in the near
    future, it's better to store it in the native class that you initialized. Depending
    on your application, you can either store it as a property on the `ViewManager`,
    a singleton that serves instances of the `View`, or a property on the `View` itself.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有数据需要在不久的将来引用，最好将其存储在你初始化的原生类中。根据你的应用程序，你可以将其存储为`ViewManager`的属性，为`View`的实例提供服务的单例，或者`View`本身的属性。
- en: If your view component involves rendering multiple `UIView` instances as children
    of a parent `UIView` container, make sure all the instances have the `opaque`
    property set to `true`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的视图组件涉及将多个`UIView`实例渲染为父`UIView`容器的子级，请确保所有实例的`opaque`属性设置为`true`。
- en: If you are rendering an image inside your view component (not using the React
    Native `Image` component), then setting your image to be the same dimension as
    the `UIImageView` component can help performance. Scaling, and other image transformations,
    are heavy operations that can impact frame rate.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在视图组件内部渲染图像（而不是使用React Native的`Image`组件），那么将图像设置为与`UIImageView`组件相同的尺寸可以提高性能。缩放和其他图像转换是影响帧率的重操作。
- en: 'One of the most impactful tweaks in writing iOS view components is avoiding
    offscreen rendering. Avoid doing the following with SDK functionality if possible:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写iOS视图组件时，避免离屏渲染是最有影响力的调整之一。如果可能的话，避免使用SDK功能进行以下操作：
- en: Using classes that start with the **Core Graphics** (**CG**) library
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以**Core Graphics**（**CG**）库开头的类
- en: Overriding the `drawRect` implementation of `UIView`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖`UIView`的`drawRect`实现
- en: Setting `shouldRasterize=YES`, or using `setMasksToBounds` or `setShadow` on
    your `UIView` instance's `layer` property
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`shouldRasterize=YES`，或者在`UIView`实例的`layer`属性上使用`setMasksToBounds`或`setShadow`
- en: Custom drawings using `CGContext`
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CGContext`进行自定义绘图
- en: 'If you need to add a shadow to your view, make sure to set the `shadowPath`
    to prevent offscreen rendering. Here''s an example of how the initialization and
    shadow definition should look:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要向视图添加阴影，请确保设置`shadowPath`以防止离屏渲染。以下是初始化和阴影定义的示例应该如何看起来：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe focused on some helpful tips that allow the GPU to do as much of
    the work as it can. The second part discussed how to keep the load on the GPU
    as low as possible. Enforcing the `opaque` property in *step 3* tells the GPU
    not to worry about checking the visibility of other components so that it can
    calculate transparency. *Steps 5* and *step 6* prevent offscreen rendering. Offscreen
    rendering generates bitmap images using the CPU (which is a slow process) and,
    more importantly, it keeps the GPU from rendering the view until the images have
    been generated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程侧重于一些有用的技巧，可以让GPU尽可能多地完成工作。第二部分讨论了如何尽可能减少GPU的负荷。在*步骤3*中强制执行`opaque`属性告诉GPU不要担心检查其他组件的可见性，以便它可以计算透明度。*步骤5*和*步骤6*防止了离屏渲染。离屏渲染使用CPU生成位图图像（这是一个缓慢的过程），更重要的是，它会使GPU在生成图像之前无法渲染视图。
- en: Optimizing the performance of native Android UI components
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化本地Android UI组件的性能
- en: Over the last few years, Android native UI performance has improved significantly.
    This is primarily due to its ability to render components and layouts using GPU
    hardware acceleration. In your React Native app, you may find yourself using custom
    view components, especially if you want to use a built-in Android feature that
    has not yet been wrapped as a React Native component. Even though the Android
    platform has made a conscious effort to increase the performance of its UI, the
    way components are rendered can quickly negate all of these benefits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，Android本地UI性能有了显著改善。这主要是由于其使用GPU硬件加速来渲染组件和布局的能力。在您的React Native应用程序中，您可能会发现自己使用自定义视图组件，特别是如果您想使用尚未作为React
    Native组件包装的内置Android功能。尽管Android平台已经有意增加了其UI的性能，但组件的渲染方式很快就会抵消所有这些好处。
- en: In this recipe, we'll discuss a few ways to get the best performance out of
    our custom Android view components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将讨论一些方法，以获得我们自定义Android视图组件的最佳性能。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should have a React Native application that renders custom
    native UI components you have written for Android. If you need help with wrapping
    UI components in React Native, check out the *Exposing custom Android view components* recipe
    in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您应该有一个React Native应用程序，用于渲染您为Android编写的自定义本地UI组件。如果您需要帮助在React Native中包装UI组件，请查看[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中的*公开自定义Android视图组件*教程，*添加本地功能*。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: As stated previously, only cross the React Native bridge with data when necessary.
    Keep the data in events and callbacks to a minimum as the data serialization between
    Java and JavaScript is slow.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，只有在必要时才通过React Native桥传递数据。将数据保留在事件和回调中最小化，因为Java和JavaScript之间的数据序列化很慢。
- en: If there is data that you need to store for referencing sometime in the near
    future, it's better to store it in the native class that you've initialized. Depending
    on your application, you can either store it as a property on the `SimpleViewManager`,
    a singleton that serves instances of the `View`, or a property on the `View` itself.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有数据需要在不久的将来进行引用存储，最好将其存储在您初始化的原生类中。根据您的应用程序，您可以将其存储为“SimpleViewManager”上的属性，这是一个为“View”的实例提供服务的单例，或者是“View”本身的属性。
- en: When building out views, consider that components often consist of other child
    components. These components are held in a hierarchy of layouts. Over-nesting
    layouts can become a very expensive operation. If you are using multi-level nested
    `LinearLayout` instances, try to replace them with a single `RelativeLayout`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建视图时，请考虑组件通常由其他子组件组成。这些组件以布局的层次结构保存。过度嵌套布局可能会变得非常昂贵。如果您正在使用多级嵌套的LinearLayout实例，请尝试用单个RelativeLayout替换它们。
- en: You can analyze the efficiency of your layout using the HierarchyViewer tool
     that's bundled inside the Android Device Monitor. To open it from the Android
    Device Monitor, click Window | Open Perspective... | Hierarchy View and select
    OK.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用HierarchyViewer工具来分析布局的效率，该工具已捆绑在Android设备监视器中。要从Android设备监视器中打开它，请单击窗口|打开透视图...|层次结构视图，然后选择确定。
- en: 'If you are performing repeated animations on your custom view natively in Java
    (not using the React Native Animated API), then you can leverage hardware layers
    to improve performance. Simply add a `withLayer` method call to your `animate`
    call. For example:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在Java中原生执行自定义视图上的重复动画（而不是使用React Native Animated API），那么您可以利用硬件层来提高性能。只需在animate调用中添加withLayer方法调用。例如：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unfortunately, there aren't that many optimizations you can perform when it
    comes to rendering Android UI components. They generally revolve around not over-nesting
    layouts, since this increases complexity by orders of magnitude. When you have
    layout performance issues, the app is most likely suffering from overusing the
    GPU, or overdrawing. Overdrawing occurs when the GPU renders a new view over an
    existing view that is already rendered. You can enable GPU Overdraw Debugging
    in the Android Developer Settings menu. The order of severity of overdrawing is
    No Color -> Blue -> Green -> Light Red -> Dark Red.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当涉及到渲染Android UI组件时，你可以执行的优化并不多。它们通常围绕着不要过度嵌套布局，因为这会增加复杂性数倍。当您遇到布局性能问题时，应用程序很可能受到GPU的过度使用或过度绘制的影响。过度绘制发生在GPU在已经渲染的现有视图上渲染新视图时。您可以在Android开发者设置菜单中启用GPU过度绘制调试。过度绘制的严重程度顺序为无颜色
    -> 蓝色 -> 绿色 -> 浅红色 -> 深红色。
- en: In *step 5*, we provided a quick tip for improving the performance of animations.
    This is particularly true for repeated animations, since it caches the animation
    output on the GPU and replays it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们提供了一个快速提示，用于改善动画的性能。这对于重复动画特别有效，因为它会将动画输出缓存到GPU上并重放。
