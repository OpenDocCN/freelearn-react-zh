- en: Managing Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖关系
- en: This chapter is dedicated to managing dependencies, namely libraries, that your
    mobile applications rely on. Most current applications abuse the singleton pattern.
    However, I strongly believe that, one day, JavaScript developers will adopt well-known
    **dependency injection** (**DI**) patterns. Even if they decide to use the singleton
    pattern, it will be way easier to refactor. In this chapter, we will focus on
    the React context and how libraries such as Redux leverage the DI mechanism. This
    is the safest alternative to use if you really want to step up your code and make
    it easily testable. We will dive into the code in the React Redux library, which
    uses the React context extensively. You will also understand why the JavaScript
    world is so slow to abandon the singleton pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论管理依赖关系，即您的移动应用程序所依赖的库。大多数当前的应用程序滥用了单例模式。然而，我坚信，总有一天，JavaScript开发人员会采用众所周知的**依赖注入**（**DI**）模式。即使他们决定使用单例模式，重构也会更容易。在本章中，我们将重点讨论React上下文以及Redux等库如何利用DI机制。这是您真正想要提升代码并使其易于测试的最安全选择。我们将深入研究React
    Redux库中的代码，该库广泛使用React上下文。您还将了解为什么JavaScript世界如此迟缓地放弃单例模式。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: The singleton pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The DI pattern and its flavors in ECMAScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript中的DI模式及其变体
- en: The storybook pattern, to increase productivity and document your components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: storybook模式，以提高生产力并记录您的组件
- en: The React context API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React上下文API
- en: How to manage large code bases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理大型代码库
- en: Get ready, as we will start off with the singleton pattern straightaway.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗，因为我们将立即开始单例模式。
- en: The singleton pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is a class that can have only one instance. By its design,
    whenever we attempt to create a new instance, it will either create an instance
    for the first time or return the one that was created previously.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一个只能有一个实例的类。按照其设计，每当我们尝试创建一个新实例时，它要么首次创建一个实例，要么返回先前创建的实例。
- en: How is this pattern useful? If we want to have a single manager for certain
    things, this comes in handy, whether it be an API manager or cache manager. For
    instance, if you need to authorize the API to get the token, you will only want
    to do this once. The first instance will initiate whatever work is necessary and
    then any other instance will reuse the work that has already been done. This use
    case was abused mostly by server-side applications, but more and more people have
    come to realize that there are better alternatives.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式有什么用？如果我们想要为某些事情有一个单一的管理器，这就很方便，无论是API管理器还是缓存管理器。例如，如果您需要授权API以获取令牌，您只想这样做一次。第一个实例将启动必要的工作，然后任何其他实例将重用已经完成的工作。这种用例主要被服务器端应用程序滥用，但越来越多的人意识到有更好的选择。
- en: Such use cases can nowadays be easily countered by better patterns. Instead
    of creating a singleton pattern, you could simply store the token in a cache,
    and in any new instance, verify if the token is already in the cache. If it is,
    you can skip authorization and use the token. This trick uses the well-known fact
    that a cache is the one centralized place for storing data. In this context, it
    serves as a singleton store for us. Whether it be a cache for a client or cloud
    server, it's exactly the same thing, with the exception that on the server, it
    may be more costly to call.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，这种用例可以很容易地通过更好的模式来对抗。您可以简单地将令牌存储在缓存中，然后在任何新实例中，验证令牌是否已经在缓存中。如果是，您可以跳过授权并使用令牌。这个技巧利用了一个众所周知的事实，即缓存是存储数据的一个集中的地方。在这种情况下，它为我们提供了一个单例存储。无论是客户端还是云服务器的缓存，它都是完全相同的，唯一的区别是在服务器上调用可能更昂贵。
- en: Implementing the singleton pattern in ECMAScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ECMAScript中实现单例模式
- en: 'Although using the singleton pattern is discouraged nowadays, it is very beneficial
    to learn how to create this mechanism. For this code example, we will use ECMAScript
    6 classes and ECMAScript 7 static fields:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如今不鼓励使用单例模式，但学习如何创建这种机制非常有益。在这个代码示例中，我们将使用ECMAScript 6类和ECMAScript 7静态字段：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are changing the behavior of the constructor. First, before returning anything,
    we need to check if the instance has already been created. If so, the current
    call returns that instance instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在改变构造函数的行为。首先，在返回任何内容之前，我们需要检查实例是否已经被创建。如果是，当前调用将返回该实例。
- en: Why using the singleton pattern is discouraged
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不鼓励使用单例模式
- en: '`Singleton` is sometimes treated as a `global` variable. If you attempt to
    import it from many different places and your use case is just sharing the same
    instance, you are probably abusing the pattern. This way, you tightly couple different
    pieces to the exact imported object. It is one of the vital signs of **code smell**
    if you use a `global` variable instead of passing it down.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Singleton`有时被视为`全局`变量。如果您尝试从许多不同的地方导入它，并且您的用例只是共享相同的实例，那么您可能滥用了该模式。这样，您将不同的部分紧密耦合到精确导入的对象上。如果您使用`全局`变量而不是传递它下去，这是**代码异味**的一个重要迹象。'
- en: 'On top of that, `Singleton` is very unpredictable in terms of testing. You
    receive something that is an effect of mutation. It may be a new object, or the
    object previously created. You may be tempted to use this to synchronize some
    form of a state. For instance, let''s look at the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Singleton`在测试方面非常不可预测。您会收到一个由突变效果产生的东西。它可能是一个新对象，也可能是先前创建的对象。您可能会被诱惑使用它来同步某种状态。例如，让我们看下面的例子：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This makes `Singleton` not only globally shared, but also globally mutable.
    This is a horrible story if you want to make it predictable. It generally defeats
    everything we learned about in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这使`Singleton`不仅在全局范围内共享，而且在全局范围内可变。如果您想要使其可预测，这是一个可怕的故事。它通常会打败我们在[第9章](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml)中学到的一切，*函数式编程模式的要素*。
- en: You need to reassure every consumer component that it is ready to handle any
    type of data that comes from a singleton. This requires an exponential number
    of tests, and thus kills productivity. This is unacceptable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要向每个使用单例模式的组件保证它已准备好处理来自单例的任何类型的数据。这需要指数数量的测试，因此会降低生产力。这是不可接受的。
- en: Later on in this chapter, you will find a solution that will fix all of these
    issues via DI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，您将找到一个通过DI解决所有这些问题的解决方案。
- en: The many singleton flavors in JavaScript
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的许多单例模式
- en: To be honest, beyond just the previous implementation, we can see many other
    variations in order to achieve the same thing. Let's discuss them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，除了之前的实现之外，我们可以看到许多其他变化，以达到相同的目的。让我们讨论一下。
- en: 'In the following code, the singleton has already been exported as an `instance`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，单例已经作为`instance`导出：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This looks like a good improvement unless your `Singleton` requires arguments.
    If so, the `Singleton` is exported in such a way that it is also harder to test
    and may only accept hard-coded dependencies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个很好的改进，除非你的`Singleton`需要参数。如果是这样，`Singleton`被导出的方式也更难测试，并且可能只接受硬编码的依赖项。
- en: 'Sometimes, your `Singleton` may be very small and only an object will be enough:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的`Singleton`可能非常小，只需要一个对象就足够了：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Refactoring this pattern we may lead to a well-known syntax for any mature
    JavaScript developer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重构这种模式可能会导致任何成熟的JavaScript开发人员都熟悉的语法：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last example may start worrying you, and you may have started asking yourself—am
    I unknowingly using singletons? I bet you are. But this is not the end of the
    world, as long as you inject them properly. Let's go through a section on ECMAScript
    and JavaScript module approaches. This is important knowledge for any JavaScript
    programmer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子可能会让你开始担心，并且你可能已经开始问自己——我是否在不知不觉中使用单例？我敢打赌你是。但只要你正确地注入它们，这并不是世界末日。让我们来看一下ECMAScript和JavaScript模块方法的部分。这对于任何JavaScript程序员来说都是重要的知识。
- en: Be careful, as some module bundlers do not guarantee that modules will be instantiated
    only once. Tools such as webpack may internally, for the sake of optimization
    or compatibility, instantiate some modules multiple times.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心，因为一些模块捆绑器不能保证模块只会被实例化一次。像webpack这样的工具可能会在内部多次实例化一些模块，以进行优化或兼容性。
- en: ES6 modules and beyond
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6模块及更高版本
- en: One of the best aspects of ES6 modules is the static nature of import and export
    declarations. Thanks to this, we can check at compile time if imports and exports
    are correct, perform injections (such as polyfills for older browsers), and bundle
    them together if necessary (like webpack does). These are amazing positives that
    save us a lot of runtime checking that would possibly slow our application down.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块的最大优点之一是导入和导出声明的静态性质。由于这一点，我们可以在编译时检查导入和导出是否正确，执行注入（例如为旧浏览器提供polyfill），并在必要时将它们捆绑在一起（就像webpack一样）。这些都是令人惊叹的积极因素，可以节省我们大量可能会减慢应用程序速度的运行时检查。
- en: However, some people abuse how ES6 modules work. The syntax is super easy—you
    can import module wherever and use it easily. This is a gotcha. You may not want
    to abuse importing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些人滥用了ES6模块的工作方式。语法非常简单——你可以在任何地方导入模块并轻松使用它。这是一个陷阱。你可能不想滥用导入。
- en: The DI pattern
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI模式
- en: 'Importing and using an imported value in the same file locks that file to the
    concrete implementation. For instance, check out the following app code implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中导入并使用导入的值会将该文件锁定到具体的实现。例如，看一下以下应用程序代码的实现：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code example, the `TasksSection` component is composed of two container
    components, `AddTaskContainer` and `TaskListContainer`. The important fact is
    that you cannot modify either of the container components if you are a consumer
    of the `TasksSection` component. You need to rely on the implementations provided
    by imported modules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`TasksSection`组件由两个容器组件`AddTaskContainer`和`TaskListContainer`组成。重要的事实是，如果你是`TasksSection`组件的使用者，你不能修改任何一个容器组件。你需要依赖于导入模块提供的实现。
- en: 'To fix this problem, we can use the DI pattern. We are essentially passing
    dependencies to the component as props. In this example, this would look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用DI模式。我们基本上是将依赖项作为props传递给组件。在这个例子中，这将如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If somebody is not interested in passing these components, we can create a container
    that will provide them. However, in cases where we want to substitute containers
    for something else, this comes in very handy, for instance, in tests or in storybooks!
    What is storybook? Keep reading.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人对传递这些组件不感兴趣，我们可以创建一个容器来提供它们。但是，在我们想要用其他东西替换容器的情况下，这非常方便，例如在测试或storybook中！什么是storybook？继续阅读。
- en: Using the DI pattern with storybooks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DI模式与storybook
- en: 'A storybook is a way to document your components. As your application grows,
    you may quickly end up with hundreds of components. If you build a serious application,
    most of them are aligned to a design specification and all of the expected features
    will have been implemented. The trick is knowing which props to send to achieve
    the expected result. Storybook makes this simple. When you implement a component,
    you also create a storybook for different scenarios. Check out the following trivial
    example for the `Button` component:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: storybook是记录您的组件的一种方式。随着应用程序的增长，您可能很快就会拥有数百个组件。如果您构建一个严肃的应用程序，大多数组件都与设计规范对齐，并且所有预期的功能都已实现。诀窍在于知道发送哪些props以实现预期的结果。storybook使这变得简单。当您实现一个组件时，您还为不同的场景创建一个storybook。查看以下关于“按钮”组件的微不足道的示例：
- en: '![](Images/a901b7cd-8918-498c-aa7e-6bceacaa1d6b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a901b7cd-8918-498c-aa7e-6bceacaa1d6b.png)'
- en: Example storybook of the Button component
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮组件的示例storybook
- en: By selecting scenarios in the left panel, you can quickly look up how components
    look with different props.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在左侧面板中选择场景，您可以快速查看组件在不同props下的外观。
- en: I have installed Storybook for you to play with in `src/Example 10/Exercise
    1`. You can launch Storybook by running either `yarn run ios:storybook` or `yarn
    run android:storybook` from that directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为您安装了Storybook，可以在`src/Example 10/Exercise 1`中进行操作。您可以通过从该目录运行`yarn run ios:storybook`或`yarn
    run android:storybook`来启动Storybook。
- en: If you would like to learn how to set up Storybook yourself, check out the official
    documentation at
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想学习如何自己设置Storybook，请查看官方文档
- en: '[https://github.com/storybooks/storybook/tree/master/app/react-native](https://github.com/storybooks/storybook/tree/master/app/react-native).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/storybooks/storybook/tree/master/app/react-native](https://github.com/storybooks/storybook/tree/master/app/react-native)。'
- en: Most of the configuration files you will need to add should go in the `storybook`
    directory within the project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加的大多数配置文件应该放在项目的“storybook”目录中。
- en: The installation command-line interface that storybook provides sets up playground
    stories for you. Those are the ones in the preceding screenshot (the `Button`
    with text and with emojis).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook提供的安装命令行界面为您设置了游乐场故事。这些是在前面的截图中的那些（带有文本和表情符号的“按钮”）。
- en: 'Time to add our own stories. Let''s start with something easy – the `TaskList`
    component. This component is ideal for storybooking because it is very well-developed.
    It handles errors, and displays various messages depending on the loading state
    or error state. It can display 0 tasks, 1 task, and 2 or more tasks. There are
    a lot of stories to look at:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加我们自己的故事了。让我们从一些简单的东西开始 - “TaskList”组件。这个组件非常适合用于故事编写，因为它非常完善。它处理错误，并根据加载状态或错误状态显示各种消息。它可以显示0个任务，1个任务和2个或更多任务。有很多故事可以看：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code example, we created our first story for the `TaskList`
    component. The `storiesOf` function comes with storybook. Then, in a decorator,
    we wrapped every story with a scrollable view and general styles that apply padding
    to the left and right. In the end, we created two stories using the `add` function:
    `TaskList` with only one story and `TaskList` with `7` stories.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们为`TaskList`组件创建了我们的第一个故事。`storiesOf`函数是storybook自带的。然后，在装饰器中，我们用可滚动的视图和一般样式包装了每个故事，这些样式适用于左右的填充。最后，我们使用`add`函数创建了两个故事：只有一个故事的`TaskList`和带有`7`个故事的`TaskList`。
- en: 'Unfortunately, our code breaks with the following error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的代码出现了以下错误：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The problem lies in the `NavButton` component that we have implemented. It
    uses the `withNavigation` HOC, which effectively requires context already:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在我们实现的`NavButton`组件上。它使用了`withNavigation` HOC，这实际上需要已经存在的上下文：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fortunately, `withNavigation` is already using the DI pattern thanks to relying
    on the React context. What we need to do is inject the required context (navigation)
    into our storybook example. To do so, we need to use `NavigationProvider` from
    react-navigation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`withNavigation`已经使用了DI模式，这要归功于依赖于React上下文。我们需要做的是将所需的上下文（导航）注入到我们的故事书示例中。为此，我们需要使用`react-navigation`中的`NavigationProvider`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can admire our two newly created stories:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以欣赏我们新创建的两个故事：
- en: '![](Images/bd519bd2-dfbe-4a6e-8f8a-766f61753db8.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bd519bd2-dfbe-4a6e-8f8a-766f61753db8.png)'
- en: TaskList component stories in storybook
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: storybook中的TaskList组件故事
- en: 'When you select one of them, it will be displayed on the simulator:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择其中一个时，它将显示在模拟器上：
- en: '![](Images/a7f76cf9-b2d7-42d4-b4cd-eb749922fec1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a7f76cf9-b2d7-42d4-b4cd-eb749922fec1.png)'
- en: TaskList stories displayed on the iPhone X simulators
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPhone X模拟器上显示的TaskList故事
- en: 'With a little more effort, we can add further stories to this storybook. For
    instance, let''s try loading an error case:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微努力一下，我们可以向这个故事书添加更多的故事。例如，让我们尝试加载一个错误情况：
- en: '![](Images/e53337d0-df47-4b21-a073-47c839445871.png)TaskList stories for loading
    state and error state'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e53337d0-df47-4b21-a073-47c839445871.png)加载状态和错误状态的TaskList故事'
- en: 'We can also create a story for a combination such as the one shown in the preceding
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为组合创建一个故事，就像前面截图中显示的那样：
- en: '![](Images/9501c3c3-a69e-4b5c-b1c8-11a730c51818.png)TaskList story with error
    and loading state'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9501c3c3-a69e-4b5c-b1c8-11a730c51818.png)带有错误和加载状态的TaskList故事'
- en: Nested stories with DI
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有DI的嵌套故事
- en: The preceding example is good enough. It creates a storybook, it is reusable,
    and everyone is happy. However, as the application grows and we add more stories,
    it is not always possible to fix this with a `Provider`, or the `Provider` may
    have been used in too many stories.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子已经足够好了。它创建了一个故事书，是可重用的，每个人都很高兴。然而，随着应用程序的增长和我们添加更多的故事，有时候不可能仅通过“Provider”来修复这个问题，或者“Provider”可能已经在太多的故事中使用了。
- en: 'In this section, we will refactor our code to be able to inject our own component
    instead of importing the `NavButton` container. As our goal is to retain the functionality
    that we had previously, in the storybook we will inject a `NavButton` story, which
    will take care of the navigation problem. However, in the normal app, we will
    inject the `NavButton` container just as before but into the `TaskList` container.
    The win here is the fact that we will not need to use `NavigationProvider` at
    all:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构我们的代码，以便能够注入我们自己的组件而不是导入`NavButton`容器。由于我们的目标是保留之前的功能，在故事书中我们将注入一个`NavButton`故事，它将解决导航问题。然而，在正常的应用程序中，我们将像以前一样将`NavButton`容器注入到`TaskList`容器中。这里的优势在于我们根本不需要使用`NavigationProvider`：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From now on, `TaskList` expects the `NavButton` component in props. We need
    to comply with these prop expectations, both in the container and in the storybook.
    The following is the code for the first container:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，`TaskList`期望在props中有`NavButton`组件。我们需要在容器和storybook中遵守这些props的期望。以下是第一个容器的代码：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Time for the fun part. We need to solve a storybook problem. To accomplish our
    goal with DI, we will create a separate storybook for `NavButton`. To fix the `TaskList`
    storybook, we will import the `NavButton` story and inject it as a `NavButton`
    component to the `TaskList` view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到了有趣的部分了。我们需要解决一个storybook的问题。为了实现我们的DI目标，我们将为`NavButton`创建一个单独的storybook。为了修复`TaskList`
    storybook，我们将导入`NavButton` story并将其注入为`TaskList`视图的`NavButton`组件。
- en: This may sound complicated, but let's see this in the following example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但让我们在以下示例中看看。
- en: 'To create the `NavButton` story, we need to refactor `NavButton` into a view
    and a container:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`NavButton` story，我们需要将`NavButton`重构为视图和容器：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The view is just the same as before—I have moved the code to `view.js` in the `NavigateButton`
    directory, next to the preceding container. We can now proceed with the creation
    of the storybook:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 视图与以前完全相同-我已将代码移动到`NavigateButton`目录中的`view.js`中，紧邻前一个容器。我们现在可以继续创建storybook：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code example, I have introduced a little improvement. Separation of
    concerns examples go into separate files so that they can be reused in areas other
    than just storybooks, for instance, in snapshot tests.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我引入了一个小的改进。关注点分离的示例放在单独的文件中，这样它们可以在除了storybook之外的其他领域中重用，例如快照测试。
- en: Mocking `navigation` is now very simple and straightforward. We just substitute
    the `navigation` object and the `navigate` function inside it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模拟`navigation`非常简单和直接。我们只需替换`navigation`对象和其中的`navigate`函数。
- en: 'We are now ready to inject that example as the `NavButton` component in the `TaskList`
    story:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将该示例作为`TaskList` story中的`NavButton`组件注入：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At the same time, our `scrollViewDecorator` is minimal:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们的`scrollViewDecorator`非常简洁：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: DI with React context
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React context进行DI
- en: In the previous section, we used DI in a very straightforward way by just injecting
    components. React comes with its own mechanism for DI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们通过简单地注入组件来非常直接地使用了DI。React自带了自己的DI机制。
- en: React context can be used to inject dependencies into components that are very
    far in the chain from the container component. This makes React context a great
    fit for global dependencies that are reused across the whole application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: React context可以用于将依赖项注入到距离容器组件非常远的组件中。这使得React context非常适合在整个应用程序中重用的全局依赖项。
- en: Good examples of such a global dependency are a theme configuration, a logger,
    a dispatcher, a logged in user object, or language options.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的全局依赖的好例子包括主题配置、日志记录器、调度程序、已登录用户对象或语言选项。
- en: Using the React Context API
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Context API
- en: 'To learn about the React Context API, we will use a simple language selector.
    I have created a component that allows us to select one of two languages, either
    English or Polish. It stores the selected language in the Redux store:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解React Context API，我们将使用一个简单的语言选择器。我创建了一个组件，允许我们选择两种语言中的一种，英语或波兰语。它将所选语言存储在Redux存储中：
- en: '![](Images/e705491b-1c10-44a5-8c0e-004dd261a186.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e705491b-1c10-44a5-8c0e-004dd261a186.png)'
- en: Language selector in the application's header and the left image shows English
    selected; the right image shows Polish selected
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序标题中的语言选择器，左侧图像显示选择了英语；右侧图像显示选择了波兰语
- en: 'Our goal is now to expose language through the React context API. To do so,
    we need to use the `createContext` function that was imported from React. This
    function will return an object containing the `Provider` and `Consumer` components:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过React上下文API来暴露语言。为此，我们需要使用从React导入的`createContext`函数。这个函数将返回一个包含`Provider`和`Consumer`组件的对象：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`LanguageConsumer` is used to get a value that traverses the component tree.
    The first `LanguageProvider` it encounters will provide the value; otherwise,
    if there is no `LanguageProvider`, the default value from the `createContext`
    call will be used.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`LanguageConsumer`用于获取遍历组件树的值。它遇到的第一个`LanguageProvider`将提供该值；否则，如果没有`LanguageProvider`，将使用`createContext`调用的默认值。'
- en: 'To ensure that every component has access to language, we should add `LanguageProvider`
    in the root, preferably in the screens component. To easily do so using already
    learned patterns, I have created a higher-order component called `withLanguageProvider`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个组件都可以访问语言，我们应该在根组件中添加`LanguageProvider`，最好是在屏幕组件中。为了方便使用已经学习的模式，我创建了一个称为`withLanguageProvider`的高阶组件：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use this utility to wrap the screen component in the following way:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个实用程序以以下方式包装屏幕组件：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Please notice the refactoring – we also provide the store in the same way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意重构 - 我们也以相同的方式提供存储。
- en: 'Having language in the context, we can proceed with the consumption in any
    lower level components, for instance, in the `TaskList` component:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上下文中的语言，我们可以在任何较低级别的组件中进行消费，例如在`TaskList`组件中：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is shown in following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下截图所示：
- en: '![](Images/6edefca5-8b92-41a6-8081-5d1f2842775a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6edefca5-8b92-41a6-8081-5d1f2842775a.png)'
- en: Example usage of LanguageConsumer in the TaskList component
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在TaskList组件中使用LanguageConsumer的示例用法
- en: Please note that this is only an example in order to learn about the context
    API. No actual translation is being performed. To add translations to your app,
    use the React Intl library from Yahoo!. It also exposes `Provider` for your convenience
    ([https://github.com/yahoo/react-intl](https://github.com/yahoo/react-intl)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是一个例子，目的是学习上下文API。并没有进行实际的翻译。要向应用程序添加翻译，可以使用Yahoo!的React Intl库。它还为您方便地暴露了`Provider`（[https://github.com/yahoo/react-intl](https://github.com/yahoo/react-intl)）。
- en: React Redux aside
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Redux之外
- en: 'If you paid close attention to the previous examples, you may have spotted
    an interesting part – `withStoreProvider.` This is a higher order component I
    made to wrap the root component with the `react-redux` store `Provider`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细注意之前的例子，你可能会发现一个有趣的部分 - `withStoreProvider`。这是我创建的一个高阶组件，用来用`react-redux`存储`Provider`包装根组件：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Provider` that is exposed is very similar to the React context API. The
    context was in the React library for a long time, along with an experimental API.
    However, the newest context API was introduced with React 16 and you may notice
    that old libraries still use their own custom providers. For instance, have a
    look at the react-redux `Provider` implementation, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露的`Provider`非常类似于React上下文API。上下文在React库中已经存在很长时间，还有一个实验性的API。然而，最新的上下文API是在React
    16中引入的，你可能会注意到旧的库仍然使用他们自己的自定义提供者。例如，看一下react-redux `Provider`的实现，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is how the react-redux `connect` function has access to your Redux store.
    Instead of the `Consumer` API, there is the `connect` function, which we use instead
    to access the store. You are probably already used to it. Treat this as a guideline
    on how to use exposed providers or consumers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是react-redux `connect`函数如何访问你的Redux存储。与`Consumer` API不同，这里有`connect`函数，我们用它来访问存储。你可能已经习惯了。把这当作如何使用暴露的提供者或消费者的指南。
- en: Managing the code base
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理代码库
- en: 'Our code base has started growing. We have taken the first steps in addressing
    the monolithic architecture problem and we have a pretty good file structure so
    far:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码库已经开始增长。我们已经迈出了解决庞大架构问题的第一步，到目前为止，我们的文件结构相当不错：
- en: '![](Images/d10fb327-4630-4fae-954a-403e2a60b131.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d10fb327-4630-4fae-954a-403e2a60b131.png)'
- en: Current src/ directory structure
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当前src/目录结构
- en: Although good enough for now, we should rethink our approach and create rules
    if we want to make this project bigger.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在还可以，但如果我们想要扩大这个项目，我们应该重新考虑我们的方法并制定规则。
- en: Quick wins
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速成功
- en: When a new developer joins the project, it may be a little challenging for them
    to understand our code base. Let's address a few easy fixes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的开发人员加入项目时，他们可能会对我们的代码库感到有些挑战。让我们解决一些简单的问题。
- en: To start with, where is the entry file for our application? It's in the root
    directory. However, there is no clear entry point in the source (`src/`) directory.
    This is okay, but it would be handy to have it close to the story and examples.
    At a glance, you will have examples, the storybook, and the app root to lookup.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的应用程序的入口文件在哪里？在根目录中。然而，在源代码（`src/`）目录中没有明确的入口点。这没关系，但将它放在靠近故事和示例的地方会很方便。一眼就可以看到示例、故事书和应用程序的根目录。
- en: 'In addition, we can refactor the current `ScreenRoot` component. It serves
    as `AppRoot` and is wrapped in two HOCs. As you already know, such coupling is
    not a good thing. I have made a little refactor. Have a look at the new structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以重构当前的`ScreenRoot`组件。它作为`AppRoot`，并被包裹在两个HOC中。如你所知，这样的耦合不是一件好事。我进行了一点重构。看看新的结构：
- en: '![](Images/aa2e4e2a-923a-4f62-90c2-59f141b9160c.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aa2e4e2a-923a-4f62-90c2-59f141b9160c.png)'
- en: The entry point to the application is now clearly visible (index.js)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点现在清晰可见（index.js）
- en: 'We have achieved a very quick win; it is now way easier to find the root component.
    Now, let''s look at the `components` and `features` directories:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经取得了一个非常快速的成功；现在找到根组件要容易得多。现在，让我们来看看`components`和`features`目录：
- en: '![](Images/6d248313-16ac-4508-9d0f-4d3b7302dcb5.png)Components and features
    directories'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6d248313-16ac-4508-9d0f-4d3b7302dcb5.png)组件和特性目录'
- en: 'The components folder was initially meant to collect stateless components.
    As the application grew, we quickly realized that having a shared directory for
    just stateless components is not enough. We want to reuse stateful ones too. Thus,
    we should rename the `components` directory to `common`. It better represents
    what the directory is:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 组件文件夹最初是用来收集无状态组件的。随着应用程序的增长，我们很快意识到仅仅为无状态组件创建一个共享目录是不够的。我们也想要重用有状态的组件。因此，我们应该将`components`目录重命名为`common`。这更好地代表了这个目录的内容：
- en: '![](Images/e908a4cc-3ecf-4206-830c-6a790af89d9b.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e908a4cc-3ecf-4206-830c-6a790af89d9b.png)'
- en: The Components directory has been renamed to common
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 组件目录已重命名为common
- en: Another issue that we will quickly notice is the fact that the language directory
    under features only creates confusion. It's primarily `LanguageSwitcher`, not
    the `language` in general. We have put this under features only because we want
    to consume the language in the app feature components. Is language context a feature?
    Not really; it is some sort of feature, but not in the context of user experience.
    This creates confusion.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会注意到的另一个问题是特性下的语言目录只会造成混淆。这主要是`LanguageSwitcher`，而不是一般的`language`。我们把这个放在特性下，只是因为我们想在应用程序特性组件中使用语言。语言上下文是一个特性吗？实际上不是；它是某种特性，但不是在用户体验的上下文中。这会造成混淆。
- en: 'We should do two things:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做两件事：
- en: Move the context to the common directory as we plan to reuse `LanguageConsumer`
    in the whole app.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上下文移到common目录，因为我们计划在整个应用程序中重用`LanguageConsumer`。
- en: Admit that we will not reuse the `LanguageSwitcher` component and place it within
    the layout directory as it is not meant to be used anywhere beyond layout components.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 承认我们不会重用`LanguageSwitcher`组件，并将其放在布局目录中，因为它不打算在布局组件之外的任何地方使用。
- en: 'Once we do this, our app structure is again cleaner:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做了，我们的应用结构就会再次变得更清晰：
- en: '![](Images/3e9c3f03-f0dd-4a3b-bddb-6ac07d3a18f2.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e9c3f03-f0dd-4a3b-bddb-6ac07d3a18f2.png)'
- en: Language directory has been split into LanguageSwitcher and LanguageContext
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 语言目录已分为LanguageSwitcher和LanguageContext
- en: '`LanguageContext` is now easy to find. Similarly, we do not need to bother
    about the `LanguageSwitcher` implementation until we change the layout.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易找到`LanguageContext`。同样，我们在不改变布局的情况下不需要担心`LanguageSwitcher`的实现。
- en: 'The util directory creates a similar confusion, just like the initial language
    directory does. We can safely move it to the `common` directory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: util目录创建了类似的混乱，就像最初的语言目录一样。我们可以将其安全地移动到`common`目录：
- en: '![](Images/eb0c5fb6-d2c5-4d95-82e4-d67d08135745.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/eb0c5fb6-d2c5-4d95-82e4-d67d08135745.png)'
- en: The refactored directory structure
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的目录结构
- en: Now, any new developer joining the project can quickly get a clear idea of it.
    `screens`, `layout`, `flux`, `features`, and `common` are all very self-explanatory
    names.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何新加入项目的开发人员都可以快速了解清楚。`screens`、`layout`、`flux`、`features`和`common`都是非常自解释的名称。
- en: Establishing conventions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立惯例
- en: Whenever you build a big project, relying on the developer's own judgement,
    like in the previous section, may not be enough. The inconsistency of approaches
    taken by different tech leads may quickly escalate and lead to tens of development
    hours being lost on exploring a code jungle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你构建一个大型项目时，依赖开发者自己的判断，就像在前面的部分中一样，可能是不够的。不同技术负责人采取的方法的不一致可能会迅速升级，并导致在探索代码迷宫上浪费数十个开发小时。
- en: If this sounds to you like a foreign problem, I can promise that in code bases
    with hundreds of developers working simultaneously every day, it is a very important
    pattern to establish clear guidelines and conventions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说听起来像一个外国问题，我可以承诺，在每天有数百名开发人员同时工作的代码库中，建立清晰的指南和惯例是非常重要的模式。
- en: 'Let''s have a look at a few examples:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子：
- en: '**Linter**: Takes care of the code appearance guidelines and enforces them
    automatically. It may also enforce certain usage patterns and favor certain options
    over others if there is a list of alternatives.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linter**：负责代码外观指南并自动强制执行它们。它还可以强制执行某些使用模式，并在有备选项列表时偏爱某些选项。'
- en: '**Flux architecture**: The general architecture of how to connect and structure
    JavaScript code to solve common usage patterns. Not enforced automatically.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flux架构**：连接和构造JavaScript代码以解决常见使用模式的一般架构。不会自动强制执行。'
- en: '**Pure reducers**: Reducers need to be as pure as an architectural decision
    of the Redux library. This is not enforced in the classic Flux architecture. This
    may or may not be enforced automatically.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯净的reducers**：Reducers需要像Redux库的架构决定一样纯净。这在经典的Flux架构中并不是强制执行的。这可能会自动执行，也可能不会。'
- en: '**Styles defined in JavaScript**: A solution that comes out of the box with
    React Native.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在JavaScript中定义的样式**：这是React Native默认提供的解决方案。'
- en: The list goes on. I hope it is enough to convince you that establishing conventions
    is a good thing. It does limit the available capabilities a little, but enables
    you to ship customer value much faster. React Native on its own is a good example
    that connects many different ecosystems to provide a unified way of developing
    mobile applications. It has proven to increase mobile developer's productivity
    significantly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 清单还在继续。我希望这足以说服你，建立惯例是一件好事。它确实会稍微限制可用的功能，但可以让你更快地交付客户价值。React Native本身就是一个很好的例子，它连接了许多不同的生态系统，提供了一种统一的开发移动应用程序的方式。它已被证明可以显著提高移动开发人员的生产力。
- en: 'All big software companies approach similar convention problems. Some of them
    are so common that companies invest money into making them open source to make
    a name for themselves. Thanks to this, we have the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有大型软件公司都面临类似的惯例问题。其中一些问题是如此普遍，以至于公司投资资金将它们开源，以树立自己的声誉。多亏了这一点，我们有了以下内容：
- en: React and React Native from Facebook
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React和React Native来自Facebook
- en: TypeScript, a typed language on top of ECMAScript from Microsoft
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript，微软的ECMAScript上的类型化语言
- en: eslint configuration from Airbnb
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Airbnb的eslint配置
- en: Internationalization library for React from Yahoo!
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Yahoo的React国际化库！
- en: Documentation on JavaScript from Mozilla
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Mozilla的JavaScript文档
- en: Material design guidelines from Google, and many many more
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Google的Material设计指南，以及许多其他内容
- en: This is changing the software world for the better.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这正在改变软件世界变得更好。
- en: I hope that you will apply this wisdom to your future projects. Please use it
    to enhance the productivity of your team and organization. If it is overkill right
    now, it is also a good sign that you have spotted that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您将这些智慧应用于未来的项目中。请用它来提高团队和组织的生产力。如果现在过度了，这也是一个很好的迹象，表明您已经发现了这一点。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has addressed the common problems of dependencies in your application.
    As you strive to deliver bulletproof applications, you will find these patterns
    useful in tests. On top of that, you have also learned what a storybook is, that
    is, something that documents use cases for your components. You now can easily
    compose components and storybooks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解决了应用程序中依赖项的常见问题。当您努力交付牢固的应用程序时，您会发现这些模式在测试中非常有用。除此之外，您还了解了storybook是什么，即记录组件用例的东西。现在您可以轻松地组合组件和storybook。
- en: Ecosystem also embraces these patterns, and we have used the React Context API
    to pass language context down the component chain. You also had a glimpse into
    the react-redux implementation of `Provider`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统也采纳了这些模式，我们已经使用了React Context API来将语言上下文传递到组件链中。您还可以一窥`Provider`的react-redux实现。
- en: Brace yourself for the last chapter, which introduces types into your applications.
    We will finally ensure that passed variables match consumer function expectations.
    This will enable us to type everything in the application, instead of using just
    `PropTypes` for React views.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好迎接最后一章，介绍如何将类型引入您的应用程序。我们最终将确保传递的变量与消费者函数的期望相匹配。这将使我们能够在应用程序中对所有内容进行类型化，而不仅仅是为React视图使用`PropTypes`。
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Directory structure guide by Atlaskit developers:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Atlaskit开发人员提供的目录结构指南：
- en: This guideline will teach you about how a big code base can be maintained. It
    is one of the many examples on how to approach the scalability of frontend code
    bases which are maintained by multiple developers every day
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南将教你如何维护一个大型的代码库。这是关于如何处理由多个开发人员每天维护的前端代码库的可扩展性的许多例子之一。
- en: ([https://atlaskit.atlassian.com/docs/guides/directory-structure](https://atlaskit.atlassian.com/docs/guides/directory-structure)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: （[https://atlaskit.atlassian.com/docs/guides/directory-structure](https://atlaskit.atlassian.com/docs/guides/directory-structure)）。
- en: 'How Airbnb Is Using React Native:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Airbnb如何使用React Native：
- en: 'Tech talk about the Airbnb techstack, which needs to ship to three different
    platforms: the browser, Android, and iOS. Learn about the challenges that developers
    at Airbnb have faced'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Airbnb技术堆栈的技术讨论，需要将其部署到三个不同的平台：浏览器、Android和iOS。了解Airbnb开发人员所面临的挑战。
- en: ([https://www.youtube.com/watch?v=8qCociUB6aQ](https://www.youtube.com/watch?v=8qCociUB6aQ)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: （[https://www.youtube.com/watch?v=8qCociUB6aQ](https://www.youtube.com/watch?v=8qCociUB6aQ)）。
- en: 'Rafael de Oleza - Building JavaScript bundles for React Native:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rafael de Oleza - 为React Native构建JavaScript捆绑包：
- en: Rafael explains how metro bundler in React Native works.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Rafael解释了React Native中的metro捆绑器是如何工作的。
- en: ([https://www.youtube.com/watch?v=tX2lg59Wm7g](https://www.youtube.com/watch?v=tX2lg59Wm7g)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （[https://www.youtube.com/watch?v=tX2lg59Wm7g](https://www.youtube.com/watch?v=tX2lg59Wm7g)）。
