- en: Implementing React Context
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现React上下文
- en: In the previous chapters, we learned about the most fundamental Hooks, such
    as the State Hook, the Reducer Hook, and the Effect Hook. We developed a small
    blog application using these Hooks. We have noticed during the development of
    our blog app, that we have to pass down the `user` state from the `App` component
    to the `UserBar` component, and from the `UserBar` component to the `Login`, `Register`,
    and `Logout` components. To avoid having to pass down the state like this, we
    are now going to learn about React context and Context Hooks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了最基本的Hooks，比如State Hook、Reducer Hook和Effect Hook。我们使用这些Hooks开发了一个小型的博客应用程序。在开发博客应用程序的过程中，我们注意到我们不得不从`App`组件传递`user`状态到`UserBar`组件，然后从`UserBar`组件传递到`Login`、`Register`和`Logout`组件。为了避免这样传递状态，我们现在要学习关于React上下文和上下文Hooks。
- en: We are going to begin by learning what React context is, and what providers
    and consumers are. Then, we are going to use Context Hooks as a context consumer,
    and discuss when context should be used. Finally, we are going to implement themes
    and global state via contexts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习什么是React上下文，提供者和消费者是什么。然后，我们将使用上下文Hooks作为上下文消费者，并讨论何时应该使用上下文。最后，我们将通过上下文实现主题和全局状态。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing React context as an alternative to passing down props
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入React上下文作为传递props的替代方法
- en: Implementing themes via context
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过上下文实现主题
- en: Using context for global state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用上下文来管理全局状态
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: The code for this chapter can be found on the GitHub repository: [hhttps://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Web-Development-with-Hooks/tree/master/Chapter05)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Web-Development-with-Hooks/tree/master/Chapter05)
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    you write the code yourself in order for you to be able to learn and understand
    properly. However, if you run into any issues, you can always refer to the code
    example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行提供的代码示例。重要的是您自己编写代码，以便能够正确学习和理解。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始本章。
- en: Introducing React context
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React上下文
- en: In the previous chapters, we passed down the `user` state and `dispatch` function
    from the `App` component, to the `UserBar` component; and then from the `UserBar`
    component to the `Logout`, `Login`, and `Register` components. React context provides
    a solution to this cumbersome way of passing down props over multiple levels of
    components, by allowing us to share values between components, without having
    to explicitly pass them down via props. As we are going to see, React context
    is perfect for sharing values across the whole application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们从`App`组件传递了`user`状态和`dispatch`函数到`UserBar`组件；然后从`UserBar`组件传递到`Logout`、`Login`和`Register`组件。React上下文提供了解决这种繁琐的跨多个组件级别传递props的方法，它允许我们在组件之间共享值，而无需通过props显式传递它们。正如我们将看到的，React上下文非常适合在整个应用程序中共享值。
- en: First, we are going to have a closer look at the problem of passing down props.
    Then, we are going to introduce React context as a solution to the problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更仔细地看一下传递props的问题。然后，我们将介绍React上下文作为解决方案。
- en: Passing down props
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递props
- en: 'Before learning about React context in depth, let''s recap what we implemented
    in the earlier chapters, in order to get a feeling for the problem that contexts
    solve:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入学习React上下文之前，让我们回顾一下我们在之前章节中实现的内容，以便对上下文解决的问题有所了解：
- en: 'In `src/App.js`, we defined the `user` state and the `dispatch` function:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，我们定义了`user`状态和`dispatch`函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we passed the `user` state and the `dispatch` function to the `UserBar`
    component (and the `CreatePost` component):'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`user`状态和`dispatch`函数传递给`UserBar`组件（以及`CreatePost`组件）：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `src/user/UserBar.js` component, we took the `user` state as a prop,
    and then passed it down to the `Logout` component. We also took the `dispatch`
    function as a prop, and passed it to the `Logout`, `Login`, and `Register` components:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/UserBar.js`组件中，我们将`user`状态作为prop，并将其传递给`Logout`组件。我们还将`dispatch`函数作为prop，并将其传递给`Logout`、`Login`和`Register`组件：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, we used the `dispatch` and `user` props in the `Logout`, `Login`, and
    `Register` components.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`Logout`、`Login`和`Register`组件中使用了`dispatch`和`user`props。
- en: React context allows us to skip steps 2 and 3, and jump straight from step 1
    to step 4\. As you can imagine, with larger apps, context becomes even more useful,
    because we might have to pass down props over many levels.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文允许我们跳过步骤2和3，直接从步骤1跳到步骤4。可以想象，对于更大的应用程序，上下文变得更加有用，因为我们可能需要在许多级别上传递props。
- en: Introducing React context
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React上下文
- en: React context is used to share values across a tree of React components. Usually,
    we want to share global values, such as the `user` state and the `dispatch` function,
    the theme of our app, or the chosen language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文用于在React组件树中共享值。通常，我们希望共享全局值，例如`user`状态和`dispatch`函数，应用程序的主题或所选择的语言。
- en: 'React context consists of two parts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文由两部分组成：
- en: The **provider**, which provides (sets) the value
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者，提供（设置）值
- en: The **consumer**, which consumes (uses) the value
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者，消耗（使用）值
- en: We are first going to look at how contexts work, using a simple example, and,
    in the next section, we are going to implement them in our blog app. We create
    a new project with the `create-react-app` tool. In our simple example, we are
    going to define a theme context, containing the primary color of an app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下上下文是如何工作的，使用一个简单的例子，然后在下一节中，我们将在我们的博客应用中实现它们。我们使用`create-react-app`工具创建一个新项目。在我们的简单示例中，我们将定义一个主题上下文，其中包含应用程序的主要颜色。
- en: Defining the context
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义上下文
- en: First, we have to define the context. The way this works has not changed since
    Hooks were introduced.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义上下文。自从引入Hooks以来，这种工作方式并没有改变。
- en: 'We simply use the `React.createContext(defaultValue)` function to create a
    new context object. We set the default value to `{ primaryColor: ''deepskyblue''
    }`, so our default primary color, when no provider is defined, will be `''deepskyblue''`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '我们只需使用`React.createContext(defaultValue)`函数创建一个新的上下文对象。我们将默认值设置为`{ primaryColor:
    ''deepskyblue'' }`，因此当没有提供者定义时，我们的默认主要颜色将是`''deepskyblue''`。'
- en: 'In `src/App.js`, add the following definition before the `App` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，在`App`函数之前添加以下定义：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note how we are exporting `ThemeContext` here, because we are going to need
    to import it for the consumer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里导出`ThemeContext`，因为我们将需要导入它作为消费者。
- en: That is all we need to do to define a context with React. Now we just need to
    define the consumer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用React定义上下文所需做的一切。现在我们只需要定义消费者。
- en: Defining the consumer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义消费者
- en: 'Now, we have to define the consumer in our `Header` component. We are going
    to do this in the traditional way for now, and in the next steps use Hooks to
    define the consumer:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在我们的`Header`组件中定义消费者。现在我们将以传统方式做这个，然后在下一步中使用Hooks来定义消费者：
- en: Create a new `src/Header.js` file
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/Header.js`文件
- en: 'First, we have to import `ThemeContext` from the `App.js` file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须从`App.js`文件中导入`ThemeContext`：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can define our component, where we use the `ThemeContext.Consumer`
    component and a `render` function as `children` prop, in order to make use of
    the context value:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的组件，在这里我们使用`ThemeContext.Consumer`组件和一个`render`函数作为`children`属性，以便利用上下文值：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the `render` function, we can now make use of the context value to set
    the `color` style of our `Header` component:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`函数中，我们现在可以利用上下文值来设置我们的`Header`组件的`color`样式：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we still need to import the `Header` component in `src/App.js`, by adding
    the following `import` statement:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们仍然需要在`src/App.js`中导入`Header`组件，通过添加以下`import`语句：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we replace the current `App` function with the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用以下代码替换当前的`App`函数：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using contexts like this works, but, as we have learned in the first chapter,
    using components with `render` function props in this way clutters our UI tree,
    and makes our app harder to debug and maintain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用上下文是有效的，但是，正如我们在第一章中学到的那样，以这种方式使用带有`render`函数props的组件会使我们的UI树混乱，并使我们的应用程序更难以调试和维护。
- en: Using Hooks
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks
- en: 'A better way to use contexts is with the `useContext` Hook! That way, we can
    use context values like any other value, in a similar way to the `useState` Hook:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文的更好方法是使用`useContext` Hook！这样，我们可以像使用`useState` Hook一样使用上下文值：
- en: 'Edit `src/Header.js`. First, we import the `useContext` Hook from React, and
    the `ThemeContext` object from `src/App.js`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/Header.js`。首先，我们从React中导入`useContext` Hook，以及从`src/App.js`中导入`ThemeContext`对象：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we create our `Header` component, where we now define the `useContext` Hook:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的`Header`组件，现在我们定义`useContext` Hook：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The rest of our component will be the same as before, except that, now, we
    can simply return our `Header` component, without using an additional component
    for the consumer:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们组件的其余部分将与以前相同，只是现在，我们可以简单地返回我们的`Header`组件，而不需要使用额外的组件来作为消费者：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, using Hooks makes our context consumer code much more concise.
    Furthermore, it will be easier to read, maintain, and debug.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用Hooks使我们的上下文消费者代码更加简洁。此外，它将更容易阅读，维护和调试。
- en: 'We can see that the header now has the color `deepskyblue`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到标题现在的颜色是`deepskyblue`：
- en: '![](assets/f75e52bf-5b27-4664-87f2-e2c67672250d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f75e52bf-5b27-4664-87f2-e2c67672250d.png)'
- en: A simple app with a Context Hook!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用上下文Hook的简单应用程序！
- en: As we can see, our theme context successfully provides the theme for the header.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的主题上下文成功为标题提供了主题。
- en: Defining the provider
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义提供程序
- en: Contexts use the default value that is passed to `React.createContext`, when
    there is no provider defined. This is useful for debugging the components when
    they are not embedded in the app. For example, we could debug a single component
    as a standalone component. In an app, we usually want to use a provider to provide
    the value for the context, which we are going to define now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有定义提供程序时，上下文使用传递给`React.createContext`的默认值。当组件没有嵌入在应用程序中时，这对于调试组件非常有用。例如，我们可以调试单个组件作为独立组件。在应用程序中，我们通常希望使用提供程序来提供上下文的值，我们现在将定义它。
- en: 'Edit `src/App.js`, and in our `App` function, we simply wrap the `Header` component
    with a `<ThemeContext.Provider>` component, where we pass `coral` as `primaryColor`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，在我们的`App`函数中，我们简单地用`<ThemeContext.Provider>`组件包装`Header`组件，其中我们将`coral`作为`primaryColor`传递：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now see that our header color changed from `deepskyblue` to `coral`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到我们的标题颜色从 `deepskyblue` 变为 `coral`：
- en: '![](assets/63746442-6a7f-4f42-a9a6-834f8c09f619.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63746442-6a7f-4f42-a9a6-834f8c09f619.png)'
- en: Our provider changed the color of the header
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的提供者改变了标题的颜色
- en: If we want to change the value of our context, we can simply adjust the `value` prop
    that is passed to the `Provider` component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更改上下文的值，我们可以简单地调整传递给`Provider`组件的`value`属性。
- en: Please note that the default value of a context is not used when we define a
    provider without passing the `value` prop to it! If we define a provider without
    a `value` prop, then the value of the context will be `undefined`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在没有将`value`属性传递给它的情况下定义提供者时，上下文的默认值不会被使用！如果我们定义一个没有`value`属性的提供者，那么上下文的值将是`undefined`。
- en: Now that we have defined a single provider for our context, let's move on to
    defining multiple, nested providers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的上下文定义了单个提供者，让我们继续定义多个嵌套提供者。
- en: Nested providers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套提供者
- en: 'With React context, it is also possible to define multiple providers for the
    same context. Using this technique, we can override the context value in certain
    parts of our app. Let''s consider the earlier example, and add a second header
    to it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React上下文，还可以为同一上下文定义多个提供者。使用这种技术，我们可以在应用程序的某些部分覆盖上下文值。让我们考虑之前的例子，并向其添加第二个标题：
- en: 'Edit `src/App.js`, and add a second `Header` component:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.js`，并添加第二个 `Header` 组件：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, define a second `Provider` component with a different `primaryColor`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用不同的`primaryColor`定义第二个`Provider`组件：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we open the app in our browser, the second header now has a different color
    from the first one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开应用程序，第二个标题现在与第一个标题的颜色不同：
- en: '![](assets/02a3debe-ceb4-486c-8073-c72a50c12595.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02a3debe-ceb4-486c-8073-c72a50c12595.png)'
- en: Overriding context values with nested providers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套提供者覆盖上下文值
- en: As we can see, we can override React context values by defining providers. Providers
    can also be nested, therefore overriding the values of other providers that are
    higher up in the component tree.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以通过定义提供者来覆盖React上下文的值。提供者也可以嵌套，因此可以覆盖组件树中较高提供者的值。
- en: Example code
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for the small theme context example can be found in the `Chapter05/chapter5_1` folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 小主题上下文示例的示例代码可以在`Chapter05/chapter5_1`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Alternative to contexts
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文的替代方案
- en: However, we should be careful, and not use React context too often, because
    it makes reusing components more difficult. We should only use contexts when we
    need to access data in many components, which are at different nesting levels.
    Furthermore, we need to make sure that we only use contexts for non-frequently
    changing data. Frequently changing values of contexts can cause our whole component
    tree to re-render, resulting in performance problems. That is why, for frequently
    changing values, we should use a state management solution such as Redux or MobX,
    instead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该小心，不要经常使用React上下文，因为这会使组件的重用变得更加困难。我们只应在需要在许多不同嵌套级别的组件中访问数据时使用上下文。此外，我们需要确保只使用上下文来存储不经常更改的数据。上下文频繁更改的值可能导致整个组件树重新渲染，从而导致性能问题。因此，对于频繁更改的值，我们应该使用Redux或MobX等状态管理解决方案。
- en: 'If we only want to avoid having to pass down props, we can pass down the rendered
    component instead of the data. For example, let''s say we have a `Page` component,
    which renders a `Header` component, which renders a `Profile` component, which
    then renders an `Avatar` component. We get a `headerSize` prop passed to the `Page`
    component, which we need in the `Header` component, but also in the `Avatar` component.
    Instead of passing down props through multiple levels, we could do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想避免传递props，我们可以传递渲染的组件而不是数据。例如，假设我们有一个`Page`组件，它渲染一个`Header`组件，后者又渲染一个`Profile`组件，然后渲染一个`Avatar`组件。我们在`Page`组件中得到一个`headerSize`属性，我们需要在`Header`组件中使用它，但也需要在`Avatar`组件中使用它。我们可以这样做，而不是通过多个级别传递props：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, only the `Page` component needs to know about the `headerSize` prop, and
    there is no need to pass it down further in the tree. In this case, contexts are
    not necessary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有`Page`组件需要知道`headerSize`属性，而且不需要在树中进一步传递。在这种情况下，上下文是不必要的。
- en: Such a pattern is called **inversion of control**, and it can make your code
    much cleaner than passing down props or using a context. However, we should not
    always use this pattern either, because it makes the higher-level component more
    complicated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为**控制反转**，它可以使您的代码比传递props或使用上下文更清晰。然而，我们也不应该总是使用这种模式，因为它会使高级组件变得更加复杂。
- en: Implementing themes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主题
- en: After learning how to implement themes in a small example, we are now going
    to implement themes in our blog app, using React context and Hooks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何在一个小例子中实现主题之后，我们现在要在我们的博客应用程序中使用React上下文和钩子来实现主题。
- en: Defining the context
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义上下文
- en: First, we have to define the context. Instead of defining it in the `src/App.js`
    file, in our blog app, we are going to create a separate file for the context.
    Having a separate file for contexts makes it easier to maintain them later on.
    Furthermore, we always know where to import the contexts from, because it is clear
    from the filename.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义上下文。在我们的博客应用程序中，我们将创建一个单独的文件来定义上下文，而不是在`src/App.js`文件中定义它。将上下文放在单独的文件中可以更容易地在以后进行维护。此外，我们总是知道从哪里导入上下文，因为文件名清晰明了。
- en: 'Let''s start defining a theme context:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义一个主题上下文：
- en: Create a new `src/contexts.js` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/contexts.js`文件。
- en: 'Then, we import `React`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导入`React`：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we define the `ThemeContext`. As before in our small example, we set
    the default `primaryColor` to `deepskyblue`. Additionally, we set the `secondaryColor`
    to `coral`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`ThemeContext`。与我们在小例子中一样，我们将默认的`primaryColor`设置为`deepskyblue`。此外，我们将`secondaryColor`设置为`coral`：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have defined our context, we can move on to defining the Context
    Hooks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了上下文，我们可以继续定义上下文钩子。
- en: Defining the Context Hooks
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义上下文钩子
- en: After defining the context, we are going to define our consumers, using Context
    Hooks. We start by creating a new component for the header, then define a Context
    Hook for our existing `Post` component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义上下文之后，我们将使用上下文钩子来定义我们的消费者。我们首先创建一个新的头部组件，然后为现有的`Post`组件定义一个上下文钩子。
- en: Creating the Header component
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建头部组件
- en: First, we create a new `Header` component, which is going to display `React
    Hooks Blog` in the `primaryColor` of our app.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的`Header`组件，它将在我们应用程序的`primaryColor`中显示`React Hooks Blog`。
- en: 'Let''s create the `Header` component now:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`Header`组件：
- en: Create a new `src/Header.js` file.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/Header.js`文件。
- en: 'In this file, we import `React`, and the `useContext` Hook:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们导入`React`和`useContext`钩子：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we import the `ThemeContext` from the previously created `src/contexts.js`
    file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从先前创建的`src/contexts.js`文件中导入`ThemeContext`：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we define our `Header` component, and the Context Hook. Instead of storing
    the context value in a `theme` variable, we use destructuring to directly extract
    the `primaryColor` value:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的`Header`组件和上下文钩子。我们不再将上下文值存储在`theme`变量中，而是使用解构直接提取`primaryColor`值：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we return the `h1` element, as we did before in our small example,
    and `export` the `Header` component:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回`h1`元素，就像我们在我们的小例子中做的那样，并`export` `Header`组件：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now our `Header` component is defined, and we can use it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`Header`组件，我们可以使用它了。
- en: Using the Header component
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Header`组件
- en: 'After creating the `Header` component, we are going to use it in the `App`
    component, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Header`组件后，我们将在`App`组件中使用它，如下所示：
- en: 'Edit `src/App.js`, and import the `Header` component:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并导入`Header`组件：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, render the `Header` component before the `UserBar` component:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`UserBar`组件之前呈现`Header`组件：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might want to refactor the `React Hooks Blog` value into a prop that is
    passed to the `App` component (app config), because we are already using it three
    times in this component.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将`React Hooks Blog`值重构为传递给`App`组件的prop（应用程序配置），因为我们在这个组件中已经使用了三次。
- en: Now, our `Header` component will be rendered in the app and we can move on to
    implementing the Context Hook in the Post component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Header`组件将在应用程序中呈现，我们可以继续在`Post`组件中实现上下文钩子。
- en: Implementing the Context Hook for the Post component
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`Post`组件的上下文钩子
- en: 'Next, we want to display the `Post` headers in the secondary color. To do this,
    we need to define a Context Hook for the `Post` component, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望用辅助颜色显示`Post`标题。为此，我们需要为`Post`组件定义一个上下文钩子，如下所示：
- en: 'Edit `src/post/Post.js`, and adjust the `import` statement to import the `useContext` Hook:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/Post.js`，并调整`import`语句以导入`useContext`钩子：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we import the `ThemeContext`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`ThemeContext`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we define a Context Hook in the `Post` component, and get the `secondaryColor` value
    from the theme, via destructuring:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Post`组件中定义一个上下文钩子，并通过解构从主题中获取`secondaryColor`值：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we use the `secondaryColor` value to style our `h3` element:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`secondaryColor`值来设置我们的`h3`元素的样式：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we look at our app now, we can see that both colors are used properly from
    the `ThemeContext`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看我们的应用程序，我们可以看到`ThemeContext`中两种颜色都被正确使用：
- en: '![](assets/95ba1a24-ae40-4a7f-b635-768d53db8fd0.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/95ba1a24-ae40-4a7f-b635-768d53db8fd0.png)'
- en: Our ThemeContext in action
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ThemeContext在行动
- en: As we can see, our app now uses the primary color for the main header, and the
    secondary color for the post titles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的应用程序现在使用主标题的主要颜色，以及帖子标题的辅助颜色。
- en: Defining the provider
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义提供程序
- en: Right now, our Context Hooks use the default value that is specified by the
    context, when no provider is defined. To be able to change the value, we need
    to define a provider.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的上下文钩子使用上下文指定的默认值，当没有定义提供程序时。为了能够更改值，我们需要定义一个提供程序。
- en: 'Let''s start defining the provider:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义提供程序：
- en: 'Edit `src/App.js`, and import the `ThemeContext`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并导入`ThemeContext`：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Wrap the whole app with the `ThemeContext.Provider` component, providing the
    same theme that we set as the default value earlier:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`ThemeContext.Provider`组件包装整个应用程序，提供与我们之前设置为默认值的相同主题：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our app should look exactly the same way as before, but now we are using the
    value from the provider!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序应该看起来和以前完全一样，但现在我们正在使用提供程序中的值！
- en: Dynamically changing the theme
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态更改主题
- en: Now that we have defined a provider, we can use it to dynamically change the
    theme. Instead of passing a static value to the provider, we are going to use
    a State Hook that defines the current theme. Then, we are going to implement a
    component that changes the theme.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个提供程序，我们可以使用它来动态改变主题。我们将不再向提供程序传递静态值，而是使用一个State Hook来定义当前主题。然后，我们将实现一个改变主题的组件。
- en: Using a State Hook with the context provider
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文提供程序的State Hook
- en: First, we are going to define a new State Hook, which we are going to use to
    set the value for the context provider.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个新的State Hook，我们将使用它来设置上下文提供程序的值。
- en: 'Let''s define a State Hook, and use it in the context provider:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个State Hook，并在上下文提供程序中使用它：
- en: 'Edit `src/App.js`, and import the `useState` Hook:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并导入`useState` Hook：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define a new State Hook at the beginning of the `App` component; here we set
    the default value to our default theme:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件的开头定义一个新的State Hook；在这里，我们将默认值设置为我们的默认主题：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we pass the `theme` value to the `ThemeContext.Provider` component:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`theme`值传递给`ThemeContext.Provider`组件：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our app is still going to look the same way as before, but we are now ready
    to dynamically change our theme!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序看起来仍然与以前一样，但现在我们已经准备好动态改变我们的主题了！
- en: Implementing the ChangeTheme component
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ChangeTheme组件
- en: The final part of our theme feature is a component that can be used to change
    the theme dynamically, by making use of the State Hook that we defined earlier.
    The State Hook is going to re-render the `App` component, which will change the
    value that is passed to the `ThemeContext.Provider`, which, in turn, is going
    to re-render all the components that make use of the `ThemeContext` Context Hook.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主题功能的最后部分是一个组件，可以通过利用我们之前定义的State Hook来动态改变主题。State Hook将重新渲染`App`组件，这将改变传递给`ThemeContext.Provider`的值，进而重新渲染所有使用`ThemeContext`
    Context Hook的组件。
- en: 'Let''s start implementing the `ChangeTheme` component:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现`ChangeTheme`组件：
- en: Create a new `src/ChangeTheme.js` file.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/ChangeTheme.js`文件。
- en: 'As always, we have to import `React` first, before we can define a component:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们必须先导入`React`，然后才能定义一个组件：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to be able to easily add new themes later on, we are going to create
    a constant `THEMES` array, instead of manually copying and pasting the code for
    the different themes. This is going to make our code much more concise, and easier
    to read:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够轻松地以后添加新的主题，我们将创建一个常量`THEMES`数组，而不是手动复制和粘贴不同主题的代码。这将使我们的代码更加简洁，更易于阅读：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is a good idea to give constant values that are hardcoded a special name,
    such as writing the whole variable name in caps. Later on, it might make sense
    to put all these configurable hardcoded values in a separate `src/config.js` file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 给硬编码的常量值一个特殊的名称是个好主意，比如用大写字母写整个变量名。以后，将所有这些可配置的硬编码值放在一个单独的`src/config.js`文件中可能是有意义的。
- en: 'Next, we define a component to render a single `theme`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个组件来渲染单个`theme`：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we render a link, and display a small preview of the theme, by showing
    the Primary and Secondary colors:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们渲染一个链接，并显示主题的小预览，显示主要颜色和次要颜色：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we set the cursor to `pointer`, in order to make the element appear clickable.
    We could also use an `<a>` element; however, this is not recommended if we do
    not have a valid link target, such as a separate page.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将光标设置为`pointer`，以使元素看起来可点击。我们也可以使用`<a>`元素；但是，如果我们没有有效的链接目标，比如一个单独的页面，这是不推荐的。
- en: 'Then, we define the `ChangeTheme` component, which accepts the `theme` and
    `setTheme` props:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`ChangeTheme`组件，它接受`theme`和`setTheme` props：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we define a function to check if a theme object is the currently active
    theme:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个函数来检查一个主题对象是否是当前活动的主题：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we use the `.map` function to render all of the available themes, and
    call the `setTheme` function when clicking on them:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`.map`函数来渲染所有可用的主题，并在点击它们时调用`setTheme`函数：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we can import and render the `ChangeTheme` component, after the `Header`
    component in `src/App.js`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`src/App.js`中的`Header`组件之后导入并渲染`ChangeTheme`组件：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we can see, we now have a way to change the theme in our app:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们现在有一种方法可以在我们的应用程序中更改主题：
- en: '![](assets/fc47c205-d957-4bc8-a052-0e4e8808abf4.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc47c205-d957-4bc8-a052-0e4e8808abf4.png)'
- en: Our app after changing the theme, using Context Hooks in combination with a
    State Hook
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更改主题后，使用上下文钩子与状态钩子相结合
- en: Now, we have a context that is consumed via Hooks, which can also be changed
    via Hooks!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个通过Hooks消耗的上下文，也可以通过Hooks进行更改！
- en: Example code
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for the theme feature in our blog app can be found in the `Chapter05/chapter5_2` folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的博客应用程序中主题功能的示例代码可以在`Chapter05/chapter5_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using context for global state
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文进行全局状态
- en: After learning how to use React context to implement themes in our blog app,
    we are now going to use a context to avoid having to manually pass down the `state`
    and `dispatch` props for our global app state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何使用React上下文在我们的博客应用程序中实现主题之后，我们现在将使用上下文来避免手动传递`state`和`dispatch` props以用于全局应用程序状态。
- en: Defining StateContext
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义StateContext
- en: We start by defining the context in our `src/contexts.js` file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在我们的`src/contexts.js`文件中定义上下文。
- en: 'In `src/contexts.js`, we define the `StateContext`, which is going to store
    the `state` value and the `dispatch` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/contexts.js`中，我们定义了`StateContext`，它将存储`state`值和`dispatch`函数：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We initialized the `state` value as an empty object, and the `dispatch` function
    as an empty function, which will be used when no provider is defined.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`state`值初始化为空对象，并将`dispatch`函数初始化为空函数，当没有提供程序时将使用它。
- en: Defining the context provider
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义上下文提供程序
- en: Now, we are going to define the context provider in our `src/App.js` file, which
    is going to get the values from the existing Reducer Hook.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的`src/App.js`文件中定义上下文提供程序，该提供程序将从现有的Reducer Hook中获取值。
- en: 'Let''s define the context provider for global state now:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为全局状态定义上下文提供程序：
- en: 'In `src/App.js`, import the `StateContext` by adjusting the existing `import`
    statement:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，通过调整现有的`import`语句导入`StateContext`：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we define a new context provider, by returning it from our `App` function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过从我们的`App`函数中返回它来定义一个新的上下文提供程序：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, our context provider provides the `state` object and the `dispatch` function
    to the rest of our app, and we can move on to consuming the context value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的上下文提供程序为我们的整个应用程序提供了`state`对象和`dispatch`函数，我们可以继续使用上下文值。
- en: Using StateContext
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用StateContext
- en: Now that we have defined our context and provider, we can use the `state` object
    and the `dispatch` function in various components.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了我们的上下文和提供程序，我们可以在各种组件中使用`state`对象和`dispatch`函数。
- en: 'We start by removing the props that we manually passed to our components in
    `src/App.js`. Delete the following code segments marked in bold:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先删除在`src/App.js`中手动传递给组件的props。删除以下用粗体标记的代码段：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we are using contexts, there is no need to pass down props manually anymore.
    We can now move on to refactoring the components.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用上下文，因此不再需要手动传递props。我们现在可以继续重构组件。
- en: Refactoring user components
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构用户组件
- en: First, we refactor the user components, and then we move on to the post components.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重构用户组件，然后再转向帖子组件。
- en: 'Let''s refactor the user-related components now:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重构与用户相关的组件：
- en: 'Edit `src/user/UserBar.js`, and also remove the props there (code marked in
    bold should be removed), since we do not need to manually pass them down anymore:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/UserBar.js`，并且移除那里的props（加粗标记的代码应该被移除），因为我们不再需要手动传递它们了：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we import the `useContext` Hook and the `StateContext` in `src/user/UserBar.js`,
    in order to be able to tell whether the user is logged in or not:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`src/user/UserBar.js`中导入`useContext` Hook和`StateContext`，以便能够判断用户是否已登录：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can use the Context Hook to get the `user` state from our `state` object:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Context Hook从我们的`state`对象中获取`user`状态：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Again, we import `useContext` and `StateContext` in `src/user/Login.js`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们在`src/user/Login.js`中导入`useContext`和`StateContext`：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we remove the `dispatch` prop, and use the Context Hook instead:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们移除`dispatch` prop，并使用Context Hook代替：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We repeat the same process in the `src/user/Register.js` component:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`src/user/Register.js`组件中重复相同的过程：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `src/user/Logout.js` component, we do the same, but also get the `user`
    state from the `state` object:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/Logout.js`组件中，我们做同样的事情，但也从`state`对象中获取`user`状态：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our user-related components now use a context instead of props. Let's move on
    to refactoring the post-related components.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的与用户相关的组件现在使用上下文而不是props。让我们继续重构与帖子相关的组件。
- en: Refactoring post components
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构帖子组件
- en: 'Now, all that is left to do is refactoring the post components; then our whole
    app will be using React context for global state:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的就是重构帖子组件；然后我们整个应用程序都将使用React上下文来管理全局状态：
- en: 'We start with the `src/post/PostList.js` component, where we import `useContext`
    and `StateContext`, remove the props, and use the Context Hook instead:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`src/post/PostList.js`组件开始，导入`useContext`和`StateContext`，移除props，并使用Context
    Hook代替：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We do the same for the `CreatePost` component, which is the last component
    that we need to refactor:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对`CreatePost`组件做同样的事情，这是我们需要重构的最后一个组件：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Our app works in the same way as before, but now we use a context for global
    state, which makes our code much cleaner, and avoids having to pass down props!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的工作方式与以前相同，但现在我们使用上下文来管理全局状态，这使我们的代码更清晰，并避免了必须传递props！
- en: Example code
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for the global state context in our blog app can be found in
    the `Chapter05/chapter5_3` folder.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们博客应用程序中全局状态上下文的示例代码可以在`Chapter05/chapter5_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first learned about React context as an alternative to passing
    down props over multiple levels of React components. We then learned about context
    providers and consumers, and the new way to define consumers, via Hooks. Next,
    we learned when it does not make sense to use contexts, and when we should use
    inversion of control instead. Then, we used what we learned in practice, by implementing
    themes in our blog app. Finally, we used React context for the global state in
    our blog app.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了React上下文作为在多个级别的React组件之间传递props的替代方法。然后，我们学习了上下文提供者和消费者，以及通过Hooks定义消费者的新方法。接下来，我们学习了何时不应该使用上下文，以及何时应该使用控制反转。然后，我们通过在博客应用程序中实现主题来实践所学的知识。最后，我们在博客应用程序中使用React上下文进行全局状态管理。
- en: In the next chapter, we are going to learn how to request data from a server,
    using React and Hooks. Then, we are going to learn about `React.memo` to prevent
    unnecessary re-rendering of components, and React Suspense to lazily load components
    when they are needed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用React和Hooks从服务器请求数据。然后，我们将学习`React.memo`来防止组件不必要地重新渲染，以及React
    Suspense来在需要时延迟加载组件。
- en: Questions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章学到的知识，请尝试回答以下问题：
- en: Which problem do contexts avoid?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文避免了哪些问题？
- en: What are the two parts that contexts consist of?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文由哪两部分组成？
- en: Are both parts required to be defined in order to use contexts?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上下文时，两部分都必须定义吗？
- en: What is the advantage of using Hooks, instead of traditional context consumers?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hooks而不是传统上下文消费者的优势是什么？
- en: What is an alternative to contexts, and when should we use it?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文的替代方案是什么，何时应该使用它？
- en: How can we implement dynamically changing contexts?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现动态更改上下文？
- en: When does it make sense to use contexts for state?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时使用上下文来管理状态是有意义的？
- en: Further reading
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have explored
    in this chapter, take a look at the following reading material:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章中探讨的概念感兴趣，可以查看以下阅读材料：
- en: Official docs on React context: [https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React上官方文档关于上下文：[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
- en: More information on composition versus inheritance: [https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关组合与继承的更多信息：[https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html)
- en: List of HTML color codes (if you want to define new themes): [https://www.rapidtables.com/web/color/html-color-codes.html.](https://www.rapidtables.com/web/color/html-color-codes.html)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML颜色代码列表（如果您想定义新主题）：[https://www.rapidtables.com/web/color/html-color-codes.html.](https://www.rapidtables.com/web/color/html-color-codes.html)
