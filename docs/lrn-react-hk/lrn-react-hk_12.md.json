["```jsx\nimport { ThemeContext } from '../contexts'\n\nexport default function SomeComponent () {\n    const theme = useContext(ThemeContext)\n\n    // ...\n```", "```jsx\nimport { useContext } from 'react'\nimport { ThemeContext } from '../contexts'\n```", "```jsx\nexport default function useTheme () {\n```", "```jsx\n    return useContext(ThemeContext)\n}\n```", "```jsx\nimport { useContext } from 'react'\nimport { StateContext } from '../contexts'\n\nexport default function useUserState () {\n    const { state } = useContext(StateContext)\n    return state.user\n}\n```", "```jsx\nimport { useContext } from 'react'\nimport { StateContext } from '../contexts'\n\nexport default function usePostsState () {\n    const { state } = useContext(StateContext)\n    return state.posts\n}\n```", "```jsx\nimport { StateContext } from '../contexts'\n\nexport default function SomeComponent () {\n    const { dispatch } = useContext(StateContext)\n\n    // ...\n```", "```jsx\nimport { useContext } from 'react'\nimport { StateContext } from '../contexts'\n```", "```jsx\nexport default function useDispatch (context = StateContext) {\n```", "```jsx\n    const { dispatch } = useContext(context)\n    return dispatch\n}\n```", "```jsx\nimport { useResource } from 'react-request-hook'\n```", "```jsx\nexport function useAPILogin () {\n    return useResource((username, password) => ({\n        url: `/login/${encodeURI(username)}/${encodeURI(password)}`,\n        method: 'get'\n    }))\n}\n```", "```jsx\nexport function useAPIRegister () {\n    return useResource((username, password) => ({\n        url: '/users',\n        method: 'post',\n        data: { username, password }\n    }))\n}\n```", "```jsx\nexport function useAPICreatePost () {\n    return useResource(({ title, content, author }) => ({\n        url: '/posts',\n        method: 'post',\n        data: { title, content, author }\n    }))\n}\n```", "```jsx\nexport function useAPIThemes () {\n    return useResource(() => ({\n        url: '/themes',\n        method: 'get'\n    }))\n}\n```", "```jsx\nimport { useState, useEffect, useCallback } from 'react'\nimport useUndo from 'use-undo'\nimport { useDebouncedCallback } from 'use-debounce'\n```", "```jsx\nexport default function useDebouncedUndo (timeout = 200) {\n```", "```jsx\n    const [ content, setInput ] = useState('')\n```", "```jsx\n    const [ undoContent, { set: setContent, ...undoRest } ] = useUndo('')\n```", "```jsx\n    const [ setDebounce, cancelDebounce ] = useDebouncedCallback(\n        (value) => {\n            setContent(value)\n        },\n        timeout\n    )\n```", "```jsx\n    useEffect(() => {\n        cancelDebounce()\n        setInput(undoContent.present)\n    }, [cancelDebounce, undoContent])\n```", "```jsx\n    const setter = useCallback(function setterFn (value) {\n        setInput(value)\n        setDebounce(value)\n    }, [ setInput, setDebounce ])\n```", "```jsx\n    return [ content, setter, undoRest ]\n}\n```", "```jsx\nimport useTheme from './useTheme'\nimport useDispatch from './useDispatch'\nimport usePostsState from './usePostsState'\nimport useUserState from './useUserState'\nimport useDebouncedUndo from './useDebouncedUndo'\n```", "```jsx\nexport { useTheme, useDispatch, usePostsState, useUserState, useDebouncedUndo }\n```", "```jsx\nexport * from './api'\n```", "```jsx\nimport { useTheme } from './hooks'\n```", "```jsx\n    const { primaryColor } = useTheme()\n```", "```jsx\nimport { useTheme } from './hooks'\n```", "```jsx\n    const { secondaryColor } = useTheme()\n```", "```jsx\nimport { useUserState } from '../hooks'\n```", "```jsx\n    const { state } = useContext(StateContext)\n    const { user } = state\n```", "```jsx\n    const user = useUserState()\n```", "```jsx\nimport { useDispatch } from '../hooks'\n```", "```jsx\n    const { dispatch } = useContext(StateContext)\n```", "```jsx\n    const dispatch = useDispatch()\n```", "```jsx\nimport { useDispatch } from '../hooks'\n```", "```jsx\n    const dispatch = useDispatch()\n```", "```jsx\nimport { useDispatch, useUserState } from '../hooks'\n```", "```jsx\n    const dispatch = useDispatch()\n    const user = useUserState()\n```", "```jsx\nimport { useUserState, useDispatch } from '../hooks'\n```", "```jsx\n    const user = useUserState()\n    const dispatch = useDispatch()\n```", "```jsx\nimport { usePostsState } from '../hooks'\n```", "```jsx\n    const posts = usePostsState()\n```", "```jsx\nimport { useResource } from 'react-request-hook'\n```", "```jsx\nimport { useAPIThemes } from './hooks'\n```", "```jsx\n    const [ themes, getThemes ] = useAPIThemes()\n```", "```jsx\nimport { useDispatch, useAPIRegister } from '../hooks'\n```", "```jsx\n    const [ user, register ] = useAPIRegister()\n```", "```jsx\nimport { useDispatch, useAPILogin } from '../hooks'\n```", "```jsx\n    const [ user, login ] = useAPILogin()\n```", "```jsx\nimport { useUserState, useDispatch, useAPICreatePost } from '../hooks'\n```", "```jsx\n    const [ post, createPost ] = useAPICreatePost()\n```", "```jsx\nimport { useUserState, useDispatch, useDebouncedUndo, useAPICreatePost } from '../hooks'\n```", "```jsx\n    const [ content, setInput ] = useState('')\n    const [ undoContent, {\n        set: setContent,\n        undo,\n        redo,\n        canUndo,\n        canRedo\n    } ] = useUndo('')\n\n    const [ setDebounce, cancelDebounce ] = useDebouncedCallback(\n        (value) => {\n            setContent(value)\n        },\n        200\n    )\n    useEffect(() => {\n        cancelDebounce()\n        setInput(undoContent.present)\n    }, [cancelDebounce, undoContent])\n```", "```jsx\n    const [ content, setContent, { undo, redo, canUndo, canRedo } ] = useDebouncedUndo()\n```", "```jsx\n    function handleContent (e) {\n        const { value } = e.target\n setInput(value)\n setDebounce(value)\n    }\n```", "```jsx\n    function handleContent (e) {\n        const { value } = e.target\n        setContent(value)\n    }\n```", "```jsx\nfunction useRegisterEffect (user, dispatch) {\n```", "```jsx\n    useEffect(() => {\n        if (user && user.data) {\n            dispatch({ type: 'REGISTER', username: user.data.username })\n        }\n    }, [dispatch, user])\n}\n```", "```jsx\n    useRegisterEffect(user, dispatch)\n```", "```jsx\nfunction useLoginEffect (user, dispatch, setLoginFailed) {\n```", "```jsx\n    useEffect(() => {\n        if (user && user.data) {\n            if (user.data.length > 0) {\n                setLoginFailed(false)\n                dispatch({ type: 'LOGIN', username: user.data[0].username })\n            } else {\n                setLoginFailed(true)\n            }\n        }\n        if (user && user.error) {\n            setLoginFailed(true)\n        }\n    }, [dispatch, user, setLoginFailed])\n}\n```", "```jsx\n    useLoginEffect(user, dispatch, setLoginFailed)\n```", "```jsx\n> npm install --save-dev @testing-library/react-hooks react-test-renderer\n```", "```jsx\nimport { useState, useCallback } from 'react'\n```", "```jsx\nexport default function useCounter (initialCount = 0) {\n```", "```jsx\n    const [ count, setCount ] = useState(initialCount)\n```", "```jsx\n    const increment = useCallback(() => setCount(count + 1), [])\n    const reset = useCallback(() => setCount(initialCount), [initialCount])\n```", "```jsx\n    return { count, increment, reset }\n}\n```", "```jsx\nimport { renderHook, act } from '@testing-library/react-hooks'\n```", "```jsx\nimport useCounter from './useCounter'\n```", "```jsx\ntest('should use counter', () => {\n```", "```jsx\n    const { result } = renderHook(() => useCounter())\n```", "```jsx\n    expect(result.current.count).toBe(0)\n    expect(typeof result.current.increment).toBe('function')\n})\n```", "```jsx\ntest('should increment counter', () => {\n    const { result } = renderHook(() => useCounter())\n```", "```jsx\n    act(() => result.current.increment())\n```", "```jsx\n    expect(result.current.count).toBe(1)\n})\n```", "```jsx\ntest('should use initial value', () => {\n    const { result } = renderHook(() => useCounter(123))\n```", "```jsx\n    expect(result.current.count).toBe(123)\n    act(() => result.current.increment())\n    expect(result.current.count).toBe(124)\n})\n```", "```jsx\ntest('should reset to initial value', () => {\n    let initial = 0\n```", "```jsx\n    const { result, rerender } = renderHook(() => useCounter(initial))\n```", "```jsx\n    initial = 123\n    rerender()\n```", "```jsx\n    act(() => result.current.reset())\n    expect(result.current.count).toBe(123)\n})\n```", "```jsx\nimport React from 'react'\nimport { ThemeContext } from '../contexts'\n```", "```jsx\nexport function ThemeContextWrapper ({ children }) {\n```", "```jsx\n    return (\n        <ThemeContext.Provider value={{ primaryColor: 'deepskyblue', secondaryColor: 'coral' }}>\n            {children}\n        </ThemeContext.Provider>\n    )\n}\n```", "```jsx\nimport { renderHook } from '@testing-library/react-hooks'\nimport { ThemeContextWrapper } from './testUtils'\nimport useTheme from './useTheme'\n```", "```jsx\ntest('should use theme', () => {\n    const { result } = renderHook(\n        () => useTheme(),\n        { wrapper: ThemeContextWrapper }\n    )\n```", "```jsx\n    expect(result.current.primaryColor).toBe('deepskyblue')\n    expect(result.current.secondaryColor).toBe('coral')\n```", "```jsx\nimport React, { useReducer } from 'react'\nimport { StateContext, ThemeContext } from '../contexts'\nimport appReducer from '../reducers' \n```", "```jsx\nexport function StateContextWrapper ({ children }) {\n    const [ state, dispatch ] = useReducer(appReducer, { user: '', posts: [], error: '' })\n```", "```jsx\n    return (\n        <StateContext.Provider value={{ state, dispatch }}>\n            {children}\n        </StateContext.Provider>\n    )\n}\n```", "```jsx\nimport { renderHook } from '@testing-library/react-hooks'\nimport { StateContextWrapper } from './testUtils'\nimport useDispatch from './useDispatch'\n```", "```jsx\ntest('should use dispatch', () => {\n    const { result } = renderHook(\n        () => useDispatch(),\n        { wrapper: StateContextWrapper }\n    )\n```", "```jsx\n    expect(typeof result.current).toBe('function')\n})\n```", "```jsx\nimport { renderHook, act } from '@testing-library/react-hooks'\nimport { StateContextWrapper } from './testUtils'\nimport useDispatch from './useDispatch'\nimport useUserState from './useUserState'\n```", "```jsx\ntest('should use user state', () => {\n    const { result } = renderHook(\n        () => useUserState(),\n        { wrapper: StateContextWrapper }\n    )\n\n    expect(result.current).toBe('')\n})\n```", "```jsx\ntest('should update user state on login', () => {\n    const { result } = renderHook(\n        () => ({ state: useUserState(), dispatch: useDispatch() }),\n        { wrapper: StateContextWrapper }\n    )\n\n    act(() => result.current.dispatch({ type: 'LOGIN', username: 'Test User' }))\n    expect(result.current.state).toBe('Test User')\n})\n```", "```jsx\ntest('should update user state on register', () => {\n    const { result } = renderHook(\n        () => ({ state: useUserState(), dispatch: useDispatch() }),\n        { wrapper: StateContextWrapper }\n    )\n\n    act(() => result.current.dispatch({ type: 'REGISTER', username: 'Test User' }))\n    expect(result.current.state).toBe('Test User')\n})\n```", "```jsx\nimport { renderHook, act } from '@testing-library/react-hooks'\nimport { StateContextWrapper } from './testUtils'\nimport useDispatch from './useDispatch'\nimport usePostsState from './usePostsState'\n```", "```jsx\ntest('should use posts state', () => {\n    const { result } = renderHook(\n        () => usePostsState(),\n        { wrapper: StateContextWrapper }\n    )\n\n    expect(result.current).toEqual([])\n})\n```", "```jsx\ntest('should update posts state on fetch action', () => {\n    const { result } = renderHook(\n        () => ({ state: usePostsState(), dispatch: useDispatch() }),\n        { wrapper: StateContextWrapper }\n    )\n\n    const samplePosts = [{ id: 'test' }, { id: 'test2' }]\n    act(() => result.current.dispatch({ type: 'FETCH_POSTS', posts: samplePosts }))\n    expect(result.current.state).toEqual(samplePosts)\n})\n```", "```jsx\ntest('should update posts state on insert action', () => {\n    const { result } = renderHook(\n        () => ({ state: usePostsState(), dispatch: useDispatch() }),\n        { wrapper: StateContextWrapper }\n    )\n\n    const post = { title: 'Hello World', content: 'This is a test', author: 'Test User' }\n    act(() => result.current.dispatch({ type: 'CREATE_POST', ...post }))\n    expect(result.current.state[0]).toEqual(post)\n})\n```", "```jsx\nfunction doSomething () {\n    // ...\n}\n```", "```jsx\n() => {\n    // ...\n}\n```", "```jsx\nasync function doSomething () {\n    // ...\n}\n```", "```jsx\nasync () => {\n    // ...\n}\n```", "```jsx\n() => {\n    fetchAPITodos()\n        .then(todos => dispatch({ type: FETCH_TODOS, todos }))\n}\n```", "```jsx\nasync () => {\n    const todos = await fetchAPITodos()\n    dispatch({ type: FETCH_TODOS, todos })\n}\n```", "```jsx\nimport { renderHook, act } from '@testing-library/react-hooks'\nimport useDebouncedUndo from './useDebouncedUndo'\n```", "```jsx\ntest('should use debounced undo', () => {\n    const { result } = renderHook(() => useDebouncedUndo())\n    const [ content, setter, undoRest ] = result.current\n\n    expect(content).toBe('')\n    expect(typeof setter).toBe('function')\n    expect(typeof undoRest.undo).toBe('function')\n    expect(typeof undoRest.redo).toBe('function')\n    expect(undoRest.canUndo).toBe(false)\n    expect(undoRest.canRedo).toBe(false)\n})\n```", "```jsx\ntest('should update content immediately', () => {\n    const { result } = renderHook(() => useDebouncedUndo())\n    const [ content, setter ] = result.current\n\n    expect(content).toBe('')\n    act(() => setter('test'))\n    const [ newContent ] = result.current\n    expect(newContent).toBe('test')\n})\n```", "```jsx\ntest('should debounce undo history update', async () => {\n    const { result, waitForNextUpdate } = renderHook(() => useDebouncedUndo())\n    const [ , setter ] = result.current\n\n    act(() => setter('test'))\n\n    const [ , , undoRest ] = result.current\n    expect(undoRest.canUndo).toBe(false)\n\n    await act(async () => await waitForNextUpdate())\n\n    const [ , , newUndoRest ] = result.current\n    expect(newUndoRest.canUndo).toBe(true)\n})\n```", "```jsx\n> npm test\n```", "```jsx\nconst [ state, setState ] = useState(initialState)\n```", "```jsx\nsetState(val => val + 1)\n```", "```jsx\nconst [ state, setState ] = useState(() => {\n    return computeInitialState()\n})\n```", "```jsx\nuseEffect(() => {\n    // do something\n})\n```", "```jsx\nuseEffect(() => {\n    const interval = setInterval(() => {}, 100)\n    return () => {\n        clearInterval(interval)\n    }\n})\n```", "```jsx\nuseEffect(() => {\n    // do something when state changes\n}, [state])\n```", "```jsx\nconst value = useContext(NameOfTheContext)\n```", "```jsx\nconst [ state, dispatch ] = useReducer(reducer, initialState, initFn)\n```", "```jsx\nconst memoizedVal = useMemo(\n    () => computeVal(a, b, c),\n    [a, b, c]\n)\n```", "```jsx\nconst memoizedCallback = useCallback(\n    () => doSomething(a, b, c),\n    [a, b, c]\n)\n```", "```jsx\nconst memoizedCallback = useMemo(\n    () => () => doSomething(a, b, c),\n    [a, b, c]\n)\n```", "```jsx\nconst refContainer = useRef(initialValue)\n```", "```jsx\nfunction AutoFocusField () {\n    const inputRef = useRef(null)\n    useEffect(() => inputRef.current.focus(), [])\n    return <input ref={inputRef} type=\"text\" />\n}\n```", "```jsx\nfunction WidthMeasure () {\n    const [ width, setWidth ] = useState(0)\n\n    const measureRef = useCallback(node => {\n        if (node !== null) {\n            setWidth(node.getBoundingClientRect().width)\n        }\n    }, [])\n\n    return <div ref={measureRef}>I am {Math.round(width)}px wide</div>\n}\n```", "```jsx\nfunction Timer () {\n    const intervalRef = useRef(null)\n\n    useEffect(() => {\n        intervalRef.current = setInterval(doSomething, 100)\n        return () => clearInterval(intervalRef.current)\n    })\n\n    // ...\n}\n```", "```jsx\nuseImperativeHandle(ref, createHandle, [dependencies])\n```", "```jsx\nfunction FocusableInput (props, ref) {\n    const inputRef = useRef()\n    useImperativeHandle(ref, () => ({\n        focus: () => inputRef.current.focus()\n    }))\n    return <input {...props} ref={inputRef} />\n}\nFocusableInput = forwardRef(FocusableInput)\n```", "```jsx\nfunction AutoFocus () {\n    const inputRef = useRef()\n    useEffect(() => inputRef.current.focus(), [])\n    return <FocusableInput ref={inputRef} />\n}\n```", "```jsx\nexport default function useDebouncedUndo (timeout = 200) {\n    const [ content, setInput ] = useState('')\n    const [ undoContent, { set: setContent, ...undoRest } ] = useUndo('')\n\n    useDebugValue('init')\n\n    const [ setDebounce, cancelDebounce ] = useDebouncedCallback(\n        (value) => {\n            setContent(value)\n            useDebugValue('added to history') },\n        timeout\n    )\nuseEffect(() => {\n        cancelDebounce()\n        setInput(undoContent.present)\n        useDebugValue(`waiting ${timeout}ms`)\n    }, [cancelDebounce, undoContent])\n\n    function setter (value) {\n        setInput(value)\n        setDebounce(value)\n    }\n\n    return [ content, setter, undoRest ]\n}\n```"]