["```jsx\nconst input = ['a', 'b', 'c']\nlet result = []\nfor (let i = 0; i < input.length; i++) {\n    result.push(input[i] + input[i])\n}\nconsole.log(result) // prints: [ 'aa', 'bb', 'cc' ]\n```", "```jsx\nconst input = ['a', 'b', 'c']\nlet result = input.map(str => str + str)\nconsole.log(result) // prints: [ 'aa', 'bb', 'cc' ]\n```", "```jsx\nclass Example extends React.Component {\n```", "```jsx\n        componentDidMount () {\n            fetch(`http://my.api/${this.props.name}`)\n                .then(...)\n        }\n```", "```jsx\n    componentDidUpdate (prevProps) {\n        if (this.props.name !== prevProps.name) {\n            fetch(`http://my.api/${this.props.name}`)\n                .then(...)\n        }\n    }\n}\n```", "```jsx\n        fetchData () {\n            fetch(`http://my.api/${this.props.name}`)\n                .then(...)\n        }\n```", "```jsx\n        componentDidMount () {\n            this.fetchData()\n        }\n\n        componentDidUpdate (prevProps) {\n            if (this.props.name !== prevProps.name) {\n                this.fetchData()\n```", "```jsx\n            }\n        }\n```", "```jsx\nimport authenticateUser, { AuthenticationContext } from './auth'\n```", "```jsx\nconst App = () => (\n    <AuthenticationContext.Consumer>\n        {user =>\n```", "```jsx\n                user ? `${user} logged in` : 'not logged in'\n```", "```jsx) instead of normal single quotes (`'`). Variables can be inserted via the `${variableName}` syntax. We can also use any JavaScript expressions within the `${}` brackets, for example,\u00a0`${someValue + 1}`.\n\n4.  Finally, we export our component after wrapping it with the `authenticateUser` context:\n\n```", "```jsx\n\nIn the previous example, we used the higher-order `authenticateUser` component to add authentication logic to our existing component. We then used `AuthenticationContext.Consumer` to inject the `user` object into our component through its render props.\n\nAs you can imagine, using many contexts will result in a large tree with many sub-trees, also called **wrapper hell**. For example, when we want to use three contexts, the wrapper hell looks as follows:\n\n```", "```jsx\n\nThis is not very easy to read or write, and it is also prone to errors if we need to change something later on. Furthermore, the wrapper hell makes debugging hard, because we need to look at a large component tree, with many components just acting as wrappers.\n\n# Hooks to the rescue!\n\nReact Hooks are based on the same fundamental principles as React. They try to encapsulate state management by using existing JavaScript features. As a result, we do not need to learn and understand specialized React features anymore; we can simply tap into our existing JavaScript knowledge in order to use Hooks.\n\nUsing Hooks, we can solve all the previously mentioned problems. We do not need to use class components anymore, because Hooks are simply functions that can be called in function components. We also do not need to use higher-order components and render props for contexts anymore, because we can simply use a Context Hook to get the data that we need. Furthermore, Hooks allow us to reuse stateful logic between components, without creating higher-order components.\n\nFor example, the aforementioned problems with life cycle methods could be solved using Hooks, as follows:\n\n```", "```jsx\n\nThe Effect Hook that was implemented here will automatically trigger when the component mounts, and whenever the `name` prop changes.\n\nFurthermore, the wrapper hell that was mentioned earlier could also be solved using Hooks, as follows:\n\n```", "```jsx\n\nNow that we know which problems Hooks can solve, let's get started using Hooks in practice!\n\n# Getting started with\u00a0React Hooks\n\nAs we can see, React Hooks solve many problems, especially of larger web applications. Hooks were added in React 16.8, and they allow us to use state, and various other React features, without writing a class. In this section, we are going to start out by initializing a project with `create-react-app`, then we will define a class component, and finally we will write the same component as a function component using Hooks. By the end of this section, we will have talked about the advantages of Hooks, and how we would go about migrating to a Hook-based solution.\n\n# Initializing a project with create-react-app\n\nTo initialize a React project, we can use the `create-react-app` tool, which sets up the environment for React development, including the following:\n\n*   Babel, so that we can use the JSX and ES6 syntaxes\n*   It even includes language extras beyond ES6, such as the object spread operator, which we are going to make use of later\n*   Additionally, we could even use TypeScript and Flow syntax\n\nFurthermore, `create-react-app` sets up the following:\n\n*   Autoprefixed **Cascading Style Sheets** (**CSS**), so that we do not need browser-specific prefixes such as `-webkit`\n*   A fast interactive unit test runner with code coverage reporting\n*   A live development server, which warns us about common mistakes\n*   A build script, which bundles JavaScript, CSS, and images for production, including hashes and sourcemaps\n*   An offline-first service worker and a web app manifest to meet all criteria of a **Progressive Web App** (**PWA**)\n*   Hassle-free updates for all the tools that have been previously listed\n\nAs we can see, the `create-react-app` tool makes React development a lot easier for us. It is the perfect tool for us to use in order to learn about React, as well as for deploying React applications in production.\n\n# Creating a new project\n\nIn order to set up a new project, we run the following command, which creates a new directory named `<app-name>`:\n\n```", "```jsx\n\nIf you prefer using the `yarn` package manager, you can run `yarn create react-app <app-name>`\u00a0instead.\n\nWe are now going to create a new project using `create-react-app`. Run the following command to create a new React project for the first example of the first chapter:\n\n```", "```jsx\n\nNow that we have initialized our\u00a0project, let's move on to starting the project.\n\n# Starting a project\n\nIn order to start a project in development mode, we have to run the `npm start` command. Run the following command:\n\n```", "```jsx\n\nNow, we can access our project by opening `http://localhost:3000` in our browser:\n\n![](assets/0a60f3e7-17d3-415e-bb06-6f135db4f8ec.png)\n\nOur first React app!\n\nAs we can see, with `create-react-app`, it is quite easy to set up a new React project!\n\n# Deploying a project\n\nTo build a project for production deployments, we simply run the `build` script:\n\n1.  Run the following command to build the project for production deployment:\n\n```", "```jsx\n\nUsing `yarn`, we can simply run `yarn build`. Actually, we can run any package script that does not conflict with the name of an internal `yarn` command in this way: `yarn <script-name>`, instead of `npm run-script <script-name>`.\n\n2.  We can then serve our static build folder with a web server, or by using the `serve` tool. First, we have to install it:\n\n```", "```jsx\n\n3.  Then, we can run the `serve` command, as follows:\n\n```", "```jsx\n\nThe `-s` flag of the `serve` command rewrites all not-found requests to `index.html`, allowing for client-side routing.\n\nNow, we can access the same app by opening `http://localhost:5000` in our browser. Please note that the `serve` tool does not automatically open the page in your browser.\n\nAfter learning about `create-react-app`, we are now going to write our first component with React.\n\n# Starting with a class component\n\nFirst, we start out with a traditional React class component, which lets us enter a name, which we then display in our app.\n\n# Setting up the project\u00a0\n\nAs mentioned before, we are going to use `create-react-app` to initialize our project. If you have not done so already, run the following command now:\n\n```", "```jsx\n\nNext we are going to define our app as a class component.\n\n# Defining the class component\n\nWe first write our app as a traditional class component, as follows:\n\n1.  First, we remove all code from the `src/App.js` file.\n2.  Next, in `src/App.js`, we import `React`:\n\n```", "```jsx\n\n3.  We then start defining our own class component\u2014`MyName`:\n\n```", "```jsx\n\n4.  Next, we have to define a\u00a0`constructor`\u00a0method, where we set the initial `state`\u00a0object, which will be an empty string. Here, we also need to make sure to call `super(props)`, in order to let the `React.Component`\u00a0constructor know about the\u00a0`props`\u00a0object:\n\n```", "```jsx\n\n5.  Now, we define a method to set the\u00a0`name`\u00a0variable, by using `this.setState`. As we will be using this method to handle input from a text field, we need to use `evt.target.value`\u00a0to get the value from the input field:\n\n```", "```jsx\n\n6.  Then, we define the `render`\u00a0method, where we are going to display an input field and the name:\n\n```", "```jsx\n\n7.  To get the\u00a0`name`\u00a0variable from the `this.state` object, we are going to use destructuring:\n\n```", "```jsx\n\nThe previous statement is the equivalent of doing the following:\n\n```", "```jsx\n\n8.  Then, we display the currently entered `name`\u00a0state variable:\n\n```", "```jsx\n\n9.  We display an `input` field, passing the handler method to it:\n\n```", "```jsx\n\n10.  Finally, we export our class component:\n\n```", "```jsx\n\nIf we were to run this code now, we would get the following error when entering text, because passing the handler method to `onChange` changes the `this` context:\n\nUncaught TypeError: Cannot read property 'setState' of undefined\n\n11.  So, now we need to adjust the\u00a0`constructor`\u00a0method and rebind the `this` context of our handler method to the class:\n\n```", "```jsx\n\nThere is the possibility of using arrow functions as class methods, to avoid having to re-bind the `this` context. However, to use this feature we need to install the Babel compiler plugin,\u00a0`@babel/plugin-proposal-class-properties`, as it is not a released JavaScript feature yet.\n\nFinally, our component works! As you can see, there is a lot of code required to get state handling to work properly with class components. We also had to rebind the `this` context, because otherwise our handler method would not work. This is not very intuitive, and is easy to miss while developing, resulting in an annoying developer experience.\n\n# Example code\n\nThe example code\u00a0can\u00a0be found in the\u00a0`Chapter01/chapter1_1`\u00a0folder.\n\nJust run\u00a0`npm install`\u00a0in order\u00a0to install all dependencies, and\u00a0`npm start`\u00a0to start the application; then visit\u00a0`http://localhost:3000`\u00a0in your browser (if it did not open automatically).\n\n# Using Hooks instead\n\nAfter using\u00a0a traditional class component to write our app, we are going to write the same app using Hooks. As before, our app is going to let\u00a0us enter a name, which we then display in our app.\n\nPlease note that it is only possible to use Hooks in React function components. You cannot use Hooks in a React class component!\n\nWe now start by setting up the project.\n\n# Setting up the project\n\nAgain, we use `create-react-app` to set up our project:\n\n```", "```jsx\n\nLet's get started with defining a function component using Hooks now.\n\n# Defining the function component\n\nNow, we define the same component as a function component:\n\n1.  First, we\u00a0remove all code\u00a0from the\u00a0`src/App.js`\u00a0file.\n2.  Next, in `src/App.js`, we import React, and the **`useState`\u00a0**Hook:\n\n```", "```jsx\n\n3.  We start with the function definition. In our case, we do not pass any arguments, because our component does not have any props:\n\n```", "```jsx\n\nThe next step would be to get the `name`\u00a0variable from the component state. However, we cannot use `this.state` in function components. We have already learned that Hooks are just JavaScript functions, but what does that really mean? It means that we can simply use Hooks from function components, just like any other JavaScript function!\n\nTo use state via Hooks, we call `useState()`\u00a0with our initial state as the argument. This function returns an array with two elements:\n\n*   *   The current state\n    *   A setter function to set the state\n\n4.  We can use destructuring to store these two elements in separate variables, as follows:\n\n```", "```jsx\n\nThe previous code is equivalent to the following:\n\n```", "```jsx\n\n5.  Now, we define the input handler function, where we make use of the\u00a0`setName`\u00a0setter function:\n\n```", "```jsx\n\nAs we are not dealing with classes now, there is no need to rebind `this` anymore!\n\n6.  Finally, we render our user interface by returning it from the function. Then, we export the function component:\n\n```", "```jsx\n\nAnd that's it\u2014we have successfully used Hooks for the first time! As you can see, the `useState`\u00a0Hook is a drop-in replacement for `this.state` and `this.setState`.\n\nLet's run our app by executing\u00a0`npm start`, and opening `http://localhost:3000` in our browser:\n\n![](assets/df481a51-52a2-4436-901c-f8ceeb300fa6.png)\n\nOur first React app with Hooks\n\nAfter implementing the same app with a class component and a function component, let's compare the solutions.\n\n# Example code\n\nThe example code\u00a0can\u00a0be found in the\u00a0`Chapter01/chapter1_2`\u00a0folder.\n\nJust run\u00a0`npm install`\u00a0in order\u00a0to install all dependencies, and\u00a0`npm start`\u00a0to start the application; then visit\u00a0`http://localhost:3000`\u00a0in your browser (if it did not open automatically).\n\n# Comparing the solutions\n\nLet's compare our two solutions, in order to see the differences between class components, and function components using Hooks.\n\n# Class component\n\nThe class component makes use of the `constructor`\u00a0method in order to define state, and needs to rebind `this` in order to pass the handler method to the `input` field. The full class component code looks as follows:\n\n```", "```jsx\n\nAs we can see, the class component needs a lot of boilerplate code to initialize the `state` object and handler functions.\n\nNow, let's take a look at the function component.\n\n# Function component with Hook\n\nThe function component makes use of the `useState`\u00a0Hook instead, so we do not need to deal with `this` or a `constructor`\u00a0method. The full function component code looks as follows:\n\n```", "```jsx\n\nAs we can see, Hooks make our code much more concise and easier to reason about. We do not need to worry about how things work internally anymore; we can simply use state, by accessing the `useState` function!\n\n# Advantages of Hooks\n\nLet's remind ourselves about the first principle of React:\n\nDeclarative: Instead of telling React\u00a0how\u00a0to do things, we tell it\u00a0what\u00a0we want it to do. As a result, we can easily design our applications, and React will efficiently update and render just the right components when the data changes.\n\nAs we have learned in this chapter, Hooks allow us to write code that tells React what we want. With class components, however, we need to tell React how to do things. As a result, Hooks are much more declarative than class components, making them a better fit in the React ecosystem.\n\nHooks being declarative also means that React can do various optimizations on our code, since it is easier to analyze functions and function calls rather than classes and their complex `this` behavior. Furthermore, Hooks make it easier to abstract and share common stateful logic between components. By using Hooks, we can avoid render props and higher-order components.\n\nWe can see that Hooks not only make our code more concise, and are easier to reason about for developers, but they also make the code easier to optimize for React.\n\n# Migrating to Hooks\n\nNow, you might be wondering: does that mean class components are deprecated, and we need to migrate everything to Hooks now? Of course not\u2014Hooks are completely opt-in. You can try Hooks in some of your components without rewriting any of your other code. The React team also does not plan on removing class components at the moment.\n\nThere is no rush to migrate everything to Hooks right now. It is recommended that you gradually adopt Hooks in certain components where they will be most useful. For example, if you have many components that deal with similar logic, you can extract the logic to a Hook. You can also use function components with Hooks side by side with class components.\n\nFurthermore, Hooks are 100% backward-compatible, and provide a direct API to all the React concepts that you already know about: **props**, **state**, **context**, **refs**, and **life cycle**. Furthermore, Hooks offer new ways to combine these concepts and encapsulate their logic in a much better way that does not lead to wrapper hell or similar problems. We are going to learn more about this later in the book.\n\n# The Hooks mindset\n\nThe main goal of Hooks is to decouple stateful logic from rendering logic. They allow us to define logic in separate functions and reuse them across multiple components. With Hooks, we do not need to change our component hierarchy in order to implement stateful logic. There is no need to define a separate component that provides the state logic to multiple components anymore, we can simply use a Hook instead!\n\nHowever, Hooks require a completely different mindset from classic React development. We should not think about the life cycle of components anymore. Instead, we should think about data flow. For example, we can tell Hooks to trigger when certain props or values from other Hooks change. We are going to learn more about this concept in [Chapter 4](6af201b4-073e-4911-8c3e-4d0256895702.xhtml), *Using the Reducer and Effect Hooks*. We should also not split components based on life cycle anymore. Instead, we can use Hooks to deal with common functionalities, such as fetching data, or setting up a subscription.\n\n# Rules of Hooks\n\nHooks are very flexible. However, there are certain limitations to using Hooks, which we should always keep in mind:\n\n*   Hooks can only be used in function components, not in class components\n*   The order of Hook definitions matters, and needs to stay the same; thus, we cannot put Hooks in `if` conditionals, loops, or nested functions\n\nWe are going to discuss these limitations in more detail, as well as how to work around them, throughout this book.\n\n# Overview of\u00a0various Hooks\n\nAs we learned in the previous section, Hooks provide a direct API to all React concepts. Furthermore, we can define our own Hooks in order to encapsulate logic without having to write a higher-order component, which causes a wrapper hell. In this section, we are going to give an overview of various Hooks, which we are going to learn about throughout the book.\n\n# Hooks provided by React\n\nReact already provides various Hooks for different functionalities. There are three basic Hooks, and a handful of additional Hooks.\n\n# Basic Hooks\n\nBasic Hooks provide the most commonly needed functionalities in stateful React apps. They are as follows:\n\n*   `useState`\n*   `useEffect`\n*   `useContext`\n\nLet's take a look at each of these in the following sections.\n\n# useState\n\nWe have already used this Hook. It returns a stateful value (`state`) and a setter function (`setState`) in order to update the value.\n\nThe\u00a0`useState`\u00a0Hook is used to deal with `state` in React. We can use it as follows:\n\n```", "```jsx\n\nThe `useState`\u00a0Hook replaces `this.state` and `this.setState()`.\n\n# useEffect\n\nThis Hook works similarly to adding a function on `componentDidMount`\u00a0and\u00a0`componentDidUpdate`. Furthermore, the Effect Hook allows for returning a cleanup function from it, which works similarly to adding a function to `componentWillUnmount`.\n\nThe\u00a0`useEffect`\u00a0Hook is used to deal with effectful code, such as timers, subscriptions, requests, and so on. We can use it as follows:\n\n```", "```jsx\n\nThe `useEffect`\u00a0Hook replaces the `componentDidMount`,\u00a0`componentDidUpdate`, and `componentWillUnmount` methods.\n\n# useContext\n\nThis Hook accepts a context object and returns the current context value.\n\nThe\u00a0`useContext`\u00a0Hook is used to deal with context in React. We can use it as follows:\n\n```", "```jsx\n\nThe `useContext`\u00a0Hook replaces context consumers.\n\n# Additional Hooks\n\nAdditional Hooks are either more generic variants of basic Hooks or are needed for certain edge cases. The additional Hooks we are going to look at are as follows:\n\n*   `useRef`\n*   `useReducer`\n*   `useMemo`\n*   `useCallback`\n*   `useLayoutEffect`\n*   `useDebugValue`\n\nLet's dive deeper into these additional Hooks in the following sections.\n\n# useRef\n\nThis Hook returns a mutable `ref` object, where the\u00a0`.current`\u00a0property is initialized to the passed argument (`initialValue`). We can use it as follows:\n\n```", "```jsx\n\nThe\u00a0`useRef` Hook is used to deal with references to elements and components in React. We can set a reference by passing the `ref` prop to an element or a component, as follows: `<ComponentName ref={refContainer} />`\n\n# useReducer\n\nThis Hook is an alternative to\u00a0`useState`, and works similarly to the Redux library. We can use it as follows:\n\n```", "```jsx\n\nThe\u00a0`useReducer` Hook is used to deal with complex state logic.\n\n# useMemo\n\nMemoization is an optimization\u00a0technique where the result of a function call is cached, and is then returned when the same input occurs again. The `useMemo` Hook allows us to compute a value and memoize it. We can use it as follows:\n\n```", "```jsx\n\nThe\u00a0`useMemo` Hook is useful for optimization\u00a0when we want to avoid re-executing expensive operations.\n\n# useCallback\n\nThis Hook allows us to pass an inline callback function, and an array of dependencies, and will return a memoized version of the callback function. We can use it as follows:\n\n```", "```jsx\n\nThe `useCallback` Hook is useful when passing callbacks to optimized child components. It works similarly to the `useMemo` Hook, but for callback functions.\n\n# useLayoutEffect\n\nThis Hook is identical to\u00a0`useEffect`, but it only fires after all **Document Object Model** (**DOM**) mutations. We can use it as follows:\n\n```", "```jsx\n\nThe `useLayoutEffect` Hook can be used to read information from the DOM.\n\nUse the `useEffect` Hook when possible, because `useLayoutEffect` will block visual updates and slow down your application.\n\nFinally, we are going to take a look at the last Hook provided by React at the time of writing.\n\n# useDebugValue\n\nThis Hook can be used to display a label in React DevTools when creating custom Hooks. We can use it as follows:\n\n```", "```jsx\n\nMake sure to use this Hook in custom Hooks to display the current state of your Hooks, as it will make it easier to debug them.\n\n# Community Hooks\n\nIn addition to all the Hooks that React provides, there are already plenty of libraries that have been published by the community. These libraries also provide Hooks.\u00a0The Hooks we are going to look into are as follows:\n\n*   `useInput`\n*   `useResource`\n*   `useDimensions`\n*   Navigation Hooks\n*   Life cycle Hooks\n*   Timer Hooks\n\nLet's see an overview of what these Hooks are in the following sections.\n\n# useInput\n\nThis Hook is used to easily implement input handling, and to synchronize the state of an `input` field with a variable. It can be used as follows:\n\n```", "```jsx\n\nAs we can see, Hooks greatly simplify dealing with input fields in React.\n\n# useResource\n\nThis Hook can be used to implement asynchronous data loading via requests in our application. We can use it as follows:\n\n```", "```jsx\n\nAs we can see, using a special Hook for dealing with fetching data is quite simple.\n\n# Navigation Hooks\n\nThese Hooks are part of the Navi library, and are used to implement routing via Hooks in React. The Navi library provides many more routing-related Hooks. We are going to learn about routing via Hooks, in depth, later on in the book. We can use them as follows:\n\n```", "```jsx\n\nAs we can see, Hooks make routing much easier to deal with.\n\n# Life cycle Hooks\n\nThe\u00a0`react-hookedup`\u00a0library provides various Hooks, including all life cycle listeners for React.\n\nPlease note that it is not recommended to think in terms of a component life cycle when developing with Hooks. These Hooks just provide a quick way to refactor existing components to Hooks. However, when developing new components, it is recommended that you think about data flow and dependencies, rather than life cycles.\n\nHere, we list two of them, but the library actually provides many more Hooks, which we will learn about later on. We can use the Hooks provided by `react-hookedup`\u00a0as follows:\n\n```", "```jsx\n\nAs we can see, Hooks can directly replace life cycle methods in class components.\n\n# Timer Hooks\n\nThe\u00a0`react-hookedup`\u00a0library also provides Hooks for\u00a0`setInterval`\u00a0and\u00a0`setTimeout`. These work similarly to calling\u00a0`setTimeout`\u00a0or\u00a0`setInterval`\u00a0directly, but as a React Hook, which will persist between re-renders. If we directly defined timers in our function component without Hooks, we would be resetting the timer every time the component re-renders.\n\nWe can pass the time in milliseconds as a second argument. We can use them as follows:\n\n```"]