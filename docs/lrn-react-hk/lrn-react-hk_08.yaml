- en: Implementing Requests and React Suspense
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现请求和React Suspense
- en: In the previous chapters, we learned how to use React context as an alternative
    to manually passing down props. We learned about context providers, consumers,
    and how to use Hooks as a context consumer. Next, we learned about inversion of
    control as an alternative to contexts. Finally, we implemented themes and global
    state, using contexts in our blog app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何使用React上下文作为手动传递props的替代方法。我们了解了上下文提供者、消费者以及如何使用Hooks作为上下文消费者。接下来，我们学习了作为上下文替代方法的控制反转。最后，我们在博客应用程序中使用上下文实现了主题和全局状态。
- en: In this chapter, we are going to set up a simple backend server, which will
    be generated from a **JavaScript Object Notation** (**JSON**) file, using the
    `json-server` tool. Then, we are going to implement requesting resources, by using
    an Effect Hook in combination with a State Hook. Next, we are going to do the
    same, using the `axios` and `react-request-hook` libraries. Finally, we are going
    to take a look at preventing unnecessary re-rendering, using `React.memo`, and
    lazily loading components through the use of React Suspense.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置一个简单的后端服务器，该服务器将从**JavaScript对象表示**（**JSON**）文件中生成，使用`json-server`工具。然后，我们将通过使用Effect
    Hook结合State Hook来实现请求资源。接下来，我们将使用`axios`和`react-request-hook`库做同样的事情。最后，我们将通过使用`React.memo`来防止不必要的重新渲染，并通过React
    Suspense来懒加载组件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Requesting resources using Hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks请求资源
- en: Preventing unnecessary re-rendering with `React.memo`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`React.memo`防止不必要的重新渲染
- en: Implementing lazy loading using React Suspense
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Suspense实现延迟加载
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: The code for this chapter can be found on the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter06)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter06)
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    you write the code yourself in order for you to be able to learn and understand
    properly. However, if you run into any issues, you can always refer to the code
    example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行提供的代码示例。重要的是您自己编写代码，以便您能够正确学习和理解。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始本章。
- en: Requesting resources with Hooks
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hooks请求资源
- en: In this section, we are going to learn how to request resources from a server,
    using Hooks. First, we are going to implement requests by only using the JavaScript
    `fetch` function, and the `useEffect`/`useState` Hooks. Then, we are going to
    learn how to request resources, using the `axios` library in combination with `react-request-hook`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Hooks从服务器请求资源。首先，我们将只使用JavaScript的`fetch`函数和`useEffect`/`useState`
    Hooks来实现请求。然后，我们将学习如何使用`axios`库结合`react-request-hook`来请求资源。
- en: Setting up a dummy server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置虚拟服务器
- en: Before we can implement requests, we need to create a backend server. Since
    we are focusing on the user interface at the moment, we are going to set up a
    dummy server, which will allow us to test out requests. We are going to use the
    `json-server` tool to create a full **Representational State Transfer** (**REST**)
    API from a JSON file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现请求之前，我们需要创建一个后端服务器。由于我们目前专注于用户界面，我们将设置一个虚拟服务器，这将允许我们测试请求。我们将使用`json-server`工具从JSON文件创建一个完整的**表述状态转移**（**REST**）API。
- en: Creating the db.json file
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建db.json文件
- en: 'To be able to use the `json-server` tool, first we need to create a `db.json`
    file, which is going to contain our full database for the server. The `json-server`
    tool will allow you to make the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用`json-server`工具，首先我们需要创建一个`db.json`文件，其中将包含服务器的完整数据库。`json-server`工具将允许您执行以下操作：
- en: '`GET` requests, to fetch data from the file'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`请求，用于从文件中获取数据'
- en: '`POST` requests, to insert new data into the file'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`请求，用于将新数据插入文件中'
- en: '`PUT` and `PATCH` requests, to adjust existing data'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`和`PATCH`请求，用于调整现有数据'
- en: '`DELETE` requests, to remove data'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除请求，用于删除数据
- en: For all modifying actions (`POST`, `PUT`, `PATCH`, and `DELETE`), the updated
    file will automatically be saved by the tool.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有修改操作（`POST`，`PUT`，`PATCH`和`DELETE`），更新后的文件将由工具自动保存。
- en: 'We can use our existing structure for posts, which we defined as the default
    state of the posts reducer. However, we need to make sure that we provide an `id` value,
    so that we can query the database later:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们为帖子定义的默认状态作为帖子减速器的现有结构。但是，我们需要确保提供一个`id`值，以便稍后可以查询数据库：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As for the users, we need to come up with a way to store usernames and passwords.
    For simplicity, we just store the password in plain text (do not do this in a
    production environment!). Here, we also need to provide an `id` value:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 至于用户，我们需要想出一种存储用户名和密码的方法。为简单起见，我们只是以明文形式存储密码（在生产环境中不要这样做！）。在这里，我们还需要提供一个`id`值：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, we are going to store themes in our database. In order to investigate
    whether pulling themes from our database works properly, we are now going to define
    a third theme. As always, each theme needs an `id` value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在我们的数据库中存储主题。为了调查是否正确地从我们的数据库中提取主题，我们现在将定义第三个主题。和往常一样，每个主题都需要一个`id`值：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, all that is left to do is to combine these three arrays into a single JSON
    object, by storing the posts array under a `posts` key, the users array under
    a `users` key, and the themes array under a `themes` key.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将这三个数组合并成一个单独的JSON对象，将帖子数组存储在`posts`键下，将用户数组存储在`users`键下，将主题数组存储在`themes`键下。
- en: 'Let''s start creating the JSON file that is used as a database for our backend
    server:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建用作后端服务器数据库的JSON文件：
- en: Create a new `server/` directory in the root of our application folder.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们应用程序文件夹的根目录中创建一个新的`server/`目录。
- en: 'Create a `server/db.json` file with the following contents. We can use the
    existing state from our Reducer Hook. However, since this is a database, we need
    to give each element an `id` value (marked in bold):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`server/db.json`文件，其中包含以下内容。我们可以使用Reducer Hook中的现有状态。但是，由于这是一个数据库，我们需要为每个元素提供一个`id`值（用粗体标记）：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the `json-server` tool, we simply need a JSON file as the database, and
    the tool will create a full REST API for us.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`json-server`工具，我们只需要一个JSON文件作为数据库，该工具将为我们创建一个完整的REST API。
- en: Installing the json-server tool
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装json-server工具
- en: 'Now, we are going to install and start our backend server by using the `json-server`
    tool:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过使用`json-server`工具安装并启动我们的后端服务器：
- en: 'First, we are going to install the `json-server` tool via `npm`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过`npm`安装`json-server`工具：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can start our backend server, by calling the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用以下命令启动我们的后端服务器：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `npx` command executes commands that were installed locally in a project.
    We need to use `npx` here, because we did not globally install the `json-server`
    tool (via `npm install -g json-server`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx`命令执行在项目中本地安装的命令。我们需要在这里使用`npx`，因为我们没有全局安装`json-server`工具（通过`npm install
    -g json-server`）。'
- en: We executed the `json-server` tool, and made it watch the `server/db.json` file
    that we created earlier. The `--watch` flag means that it will listen to changes
    to the file, and refresh automatically.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了`json-server`工具，并让它监视我们之前创建的`server/db.json`文件。`--watch`标志意味着它将监听文件的更改，并自动刷新。
- en: 'Now, we can go to `http://localhost:3000/posts/react-hooks` in order to see
    our post object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转到`http://localhost:3000/posts/react-hooks`来查看我们的帖子对象：
- en: '![](assets/0c6cd543-2149-4d60-b028-38817018abf5.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c6cd543-2149-4d60-b028-38817018abf5.png)'
- en: Our simple JSON server working and serving a post!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的JSON服务器正在工作并提供帖子！
- en: As we can see, the tool created a full REST API from the database JSON file
    for us!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个工具为我们从数据库JSON文件创建了一个完整的REST API！
- en: Configuring package.json
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置package.json
- en: Next, we need to adjust our `package.json` file, in order to start the server,
    in addition to our client (running via `webpack-dev-server`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整我们的`package.json`文件，以便启动服务器，以及我们的客户端（通过`webpack-dev-server`运行）。
- en: 'Let''s start adjusting the `package.json` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始调整`package.json`文件：
- en: 'First, we create a new package script called `start:server`, by inserting it
    in the `scripts` section of the `package.json` file. We also make sure that we
    change the port, so that it does not run on the same port as our client:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过将其插入到`package.json`文件的`scripts`部分中来创建一个名为`start:server`的新包脚本。我们还确保更改端口，以便它不在与我们的客户端相同的端口上运行：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we rename the `start` script to `start:client`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`start`脚本重命名为`start:client`：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we install a tool called `concurrently`, which lets us start the server
    and the client at the same time:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们安装一个名为`concurrently`的工具，它可以让我们同时启动服务器和客户端：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can define a new `start` script by using the `concurrently` command,
    and then passing the server and client commands as arguments to it:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`concurrently`命令定义一个新的`start`脚本，然后将服务器和客户端命令作为参数传递给它：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, running `npm start` will run the client, as well as the backend server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`npm start`将运行客户端，以及后端服务器。
- en: Configuring a proxy
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置代理
- en: Finally, we have to define a proxy, to make sure that we can request our API
    from the same **Uniform Resource Locator (URL)** as the client. This is needed
    because, otherwise, we would have to deal with cross-site requests, which are
    a bit more complicated to handle. We are going to define a proxy that will forward
    requests from `http://localhost:3000/api/` to `http://localhost:4000/`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个代理，以确保我们可以从与客户端相同的**统一资源定位符（URL）**请求我们的API。这是必需的，否则，我们将不得不处理跨站点请求，这更加复杂。我们将定义一个代理，将从`http://localhost:3000/api/`转发请求到`http://localhost:4000/`。
- en: 'Now, let''s configure the proxy:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置代理：
- en: 'First, we have to install the `http-proxy-middleware` package:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装`http-proxy-middleware`包：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we create a new `src/setupProxy.js` file, with the following contents:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的`src/setupProxy.js`文件，内容如下：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we have to define the target of our proxy, which will be the backend
    server, running at `http://localhost:4000`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义代理的目标，即后端服务器，运行在`http://localhost:4000`上：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we have to define a path-rewrite rule, which removes the `/api` prefix
    before forwarding the request to our server:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个路径重写规则，它在转发请求到我们的服务器之前移除了`/api`前缀：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding proxy configuration will link `/api` to our backend server; therefore,
    we can now start both the server and the client via the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代理配置将`/api`链接到我们的后端服务器；因此，我们现在可以通过以下命令同时启动服务器和客户端：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we can access the API by opening `http://localhost:3000/api/posts/react-hooks`!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过打开`http://localhost:3000/api/posts/react-hooks`来访问API！
- en: Defining routes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由
- en: By default, the `json-server` tool defines the following routes: [https://github.com/typicode/json-server#routes](https://github.com/typicode/json-server#routes).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`json-server`工具定义了以下路由：[https://github.com/typicode/json-server#routes](https://github.com/typicode/json-server#routes)。
- en: We can also define our own routes, by creating a `routes.json` file, where we
    can rewrite existing routes to other routes: [https://github.com/typicode/json-server#add-custom-routes](https://github.com/typicode/json-server#add-custom-routes).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过创建一个`routes.json`文件来定义自己的路由，我们可以将现有路由重写为其他路由：[https://github.com/typicode/json-server#add-custom-routes](https://github.com/typicode/json-server#add-custom-routes)。
- en: 'For our blog app, we are going to define a single custom route: `/login/:username/:password`.
    We are going to link this to a `/users?username=:username&password=:password`
    query, in order to find a user with the given username and password combination.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的博客应用程序，我们将定义一个单独的自定义路由：`/login/:username/:password`。我们将把这个路由链接到一个`/users?username=:username&password=:password`查询，以便找到具有给定用户名和密码组合的用户。
- en: 'We are now going to define the custom login route for our app:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为我们的应用程序定义自定义登录路由：
- en: 'Create a new `server/routes.json` file with the following contents:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`server/routes.json`文件，内容如下：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, adjust the `start:server` script in the `package.json` file, and add
    the `--routes` option, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整`package.json`文件中的`start:server`脚本，并添加`--routes`选项，如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, our server will be serving our custom login route, which we are going to
    use later on in this chapter! We can try logging in by opening the following URL
    in our browser: `http://localhost:3000/api/login/Daniel%20Bugl/supersecure42`.
    This returns a user object; therefore, the login was successful!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的服务器将为我们提供自定义登录路由，我们将在本章后面使用它！我们可以尝试通过在浏览器中打开以下URL来登录：`http://localhost:3000/api/login/Daniel%20Bugl/supersecure42`。这将返回一个用户对象；因此，登录成功了！
- en: 'We can see the user object being returned as text in our browser:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器中看到用户对象以文本形式返回：
- en: '![](assets/c041ed70-364f-4077-8550-429c49d306f2.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c041ed70-364f-4077-8550-429c49d306f2.png)'
- en: Accessing our custom route directly in the browser
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在浏览器中访问我们的自定义路由
- en: As we can see, accessing our custom route works! We can now use it to log in
    users.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，访问我们的自定义路由是有效的！我们现在可以使用它来登录用户。
- en: Example code
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter06/chapter6_1` folder.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter06/chapter6_1`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Implementing requests using Effect and State/Reducer Hooks
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Effect和State/Reducer Hooks实现请求
- en: Before we use a library to implement requests using Hooks, we are going to implement
    them manually, using an Effect Hook to trigger the request, and State/Reducer
    Hooks to store the result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用库来使用Hooks实现请求之前，我们将手动实现它们，使用Effect Hook来触发请求，使用State/Reducer Hooks来存储结果。
- en: Requests with Effect and State Hooks
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Effect和State Hooks进行请求
- en: First, we are going to request themes from our server, instead of hardcoding
    the list of themes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从服务器请求主题，而不是硬编码主题列表。
- en: 'Let''s implement requesting themes using an Effect Hook and a State Hook:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Effect Hook和State Hook来实现请求主题：
- en: 'In the `src/ChangeTheme.js` file, adjust the React `import` statement in order
    to import the `useEffect` and `useState` Hooks:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/ChangeTheme.js`文件中，调整React的`import`语句，以便导入`useEffect`和`useState` Hooks：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Remove the `THEMES` constant, which is all of the following code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`THEMES`常量，即以下所有代码：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `ChangeTheme` component, define a new `useState` Hook in order to store
    the themes:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChangeTheme`组件中，定义一个新的`useState` Hook来存储主题：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then define a `useEffect` Hook, where we are going to make the request:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后定义一个`useEffect` Hook，我们将在其中进行请求：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this Hook, we use `fetch` to request a resource; in this case, we request `/api/themes`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个Hook中，我们使用`fetch`来请求一个资源；在这种情况下，我们请求`/api/themes`：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Fetch makes use of the Promise API; therefore, we can use `.then()` in order
    to work with the result. First, we have to parse the result as JSON:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fetch利用了Promise API；因此，我们可以使用`.then()`来处理结果。首先，我们必须将结果解析为JSON：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we call `setThemes` with the themes array from our request:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用来自我们请求的主题数组调用`setThemes`：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can also shorten the preceding function to `.then(setThemes)`, as we are
    only passing down the `themes` argument from `.then()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将前面的函数缩短为`.then(setThemes)`，因为我们只传递了从`.then()`中获取的`themes`参数。
- en: 'For now, this Effect Hook should only trigger when the component mounts, so
    we pass an empty array as the second argument to `useEffect`. This ensures that
    the Effect Hook has no dependencies, and thus will only trigger when the component
    mounts:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，这个Effect Hook应该只在组件挂载时触发，所以我们将空数组作为第二个参数传递给`useEffect`。这确保了Effect Hook没有依赖项，因此只会在组件挂载时触发：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, all that is left to do is to replace the `THEMES` constant with our `themes`
    value from the Hook:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的事情就是用我们从Hook中获取的`themes`值替换`THEMES`常量：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, there are now three themes available, all loaded from our database
    through our server:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，现在有三个主题可用，都是通过我们的服务器从数据库加载的：
- en: '![](assets/5aa425f0-21e5-4624-9b93-3c1531df8414.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5aa425f0-21e5-4624-9b93-3c1531df8414.png)'
- en: Three themes loaded from our server by using hooks!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hooks从我们的服务器加载了三个主题！
- en: Our themes are now loaded from the backend server and we can move on to requesting
    posts via Hooks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主题现在是从后端服务器加载的，我们可以继续通过Hooks请求帖子。
- en: Requests with Effect and Reducer Hooks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Effect和Reducer Hooks进行请求
- en: We are now going to use our backend server to request the posts array, instead
    of hardcoding it as the default value for the `postsReducer`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用后端服务器来请求帖子数组，而不是将其硬编码为`postsReducer`的默认值。
- en: 'Let''s implement requesting posts using an Effect Hook and a Reducer Hook:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Effect Hook和Reducer Hook来请求帖子：
- en: '**Remove** the `defaultPosts` constant definition from `src/App.js`, which
    is all of the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除**`src/App.js`中的`defaultPosts`常量定义，即以下所有代码：'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace the `defaultPosts` constant in the `useReducer` function with an empty
    array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个空数组替换`useReducer`函数中的`defaultPosts`常量：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `src/reducers.js`, define a new action type, called `FETCH_POSTS`, in the
    `postsReducer` function. This action type will replace the current state with
    a new posts array:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/reducers.js`中，在`postsReducer`函数中定义一个新的动作类型，称为`FETCH_POSTS`。这个动作类型将用新的帖子数组替换当前状态：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In `src/App.js`, define a new `useEffect` Hook, which precedes the current
    one:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，定义一个新的`useEffect` Hook，位于当前的Hook之前：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this Hook, we again use `fetch` in order to request a resource; in this
    case, we request `/api/posts`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个Hook中，我们再次使用`fetch`来请求一个资源；在这种情况下，我们请求`/api/posts`：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we dispatch a `FETCH_POSTS` action with the `posts` array from our
    request:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用来自我们请求的`posts`数组分派了一个`FETCH_POSTS`动作：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For now, this Effect Hook should only trigger when the component mounts, so
    we pass an empty array as the second argument to `useEffect`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，这个Effect Hook应该只在组件挂载时触发，所以我们将空数组作为第二个参数传递给`useEffect`：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, the posts now get requested from the server! We can have a look
    at the DevTools Network tab to see the request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，现在帖子是从服务器请求的！我们可以查看DevTools Network标签以查看请求：
- en: '![](assets/317e2749-c1ab-4d39-9043-303e61250ac4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/317e2749-c1ab-4d39-9043-303e61250ac4.png)'
- en: Posts being requested from our server!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的服务器请求帖子！
- en: The posts are now being requested from the backend server. In the next section,
    we are going to use `axios` and the `react-request-hook` to request resources
    from our server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从后端服务器请求帖子。在下一节中，我们将使用`axios`和`react-request-hook`从服务器请求资源。
- en: Example code
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter06/chapter6_2` folder.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter06/chapter6_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Using axios and react-request-hook
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios和react-request-hook
- en: In the previous section, we used an Effect Hook to trigger the request, and
    a Reducer/State Hook to update the state, using the result from the request. Instead
    of manually implementing requests like this, we can use the `axios` and `react-request-hook`
    libraries to easily implement requests using Hooks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用Effect Hook触发请求，并使用Reducer/State Hook从请求的结果更新状态。与手动实现请求不同，我们可以使用`axios`和`react-request-hook`库轻松地使用Hooks来实现请求。
- en: Setting up the libraries
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置这些库
- en: Before we can start using `axios` and `react-request-hook`, we have to set up
    an `axios` instance and a `RequestProvider` component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`axios`和`react-request-hook`之前，我们必须设置一个`axios`实例和一个`RequestProvider`组件。
- en: 'Let''s get started setting up the libraries:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置这些库：
- en: 'First, we install the libraries:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们安装这些库：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we import them in `src/index.js`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`src/index.js`中导入它们：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we define an `axios` instance, where we set the `baseURL` to `http://localhost:3000/api/`—our
    backend server:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个`axios`实例，其中我们将`baseURL`设置为`http://localhost:3000/api/`—我们的后端服务器：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the config for our `axios` instance, we can also define other options, such
    as a default timeout for requests, or custom headers. For more information, check
    out the `axios` documentation: [https://github.com/axios/axios#axioscreateconfig](https://github.com/axios/axios#axioscreateconfig).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`axios`实例配置中，我们还可以定义其他选项，例如请求的默认超时时间或自定义标头。有关更多信息，请查看`axios`文档：[https://github.com/axios/axios#axioscreateconfig](https://github.com/axios/axios#axioscreateconfig)。
- en: 'Finally, we wrap our `<App />` component with the `<RequestProvider>` component.
    Remove the following line of code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用`<RequestProvider>`组件包装我们的`<App />`组件。删除以下代码行：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace it with this code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, our app is ready to use Resource Hooks!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已准备好使用Resource Hooks！
- en: Using the useResource Hook
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用useResource Hook
- en: A more powerful way of dealing with requests, is using the `axios` and `react-request-hook`
    libraries. Using these libraries, we have access to features that can cancel a
    single request, or even clear all pending requests. Furthermore, using these libraries
    makes it easier to deal with errors and loading states.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理请求的更强大的方法是使用`axios`和`react-request-hook`库。使用这些库，我们可以访问可以取消单个请求甚至清除所有待处理请求的功能。此外，使用这些库可以更容易地处理错误和加载状态。
- en: 'We are now going to implement the `useResource` Hook in order to request themes
    from our server:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现`useResource` Hook以从服务器请求主题：
- en: 'In `src/ChangeTheme.js`, import the `useResource` Hook from the `react-request-hook`
    library:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/ChangeTheme.js`中，从`react-request-hook`库中导入`useResource` Hook：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Remove the previously defined State and Effect Hooks.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除先前定义的State和Effect Hooks。
- en: 'Then, we define a `useResource` Hook within the `ChangeTheme` component. The
    Hook returns a value and a getter function. Calling the getter function will request
    the resource:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`ChangeTheme`组件中定义一个`useResource` Hook。该Hook返回一个值和一个getter函数。调用getter函数将请求资源：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are using the shorthand syntax for `() => { return { } }`, which is
    `() => ({ })`. Using this shorthand syntax allows us to concisely write functions
    that only return an object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`() => { return { } }`的简写语法，即`() => ({ })`。使用这种简写语法可以简洁地编写只返回对象的函数。
- en: 'In this Hook we pass a function, which returns an object with information about
    the request:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个Hook中，我们传递一个函数，该函数返回有关请求的信息的对象：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With `axios`, we only need to pass `/themes` as the `url`, because we already
    defined the `baseURL`, which contains `/api/`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`axios`，我们只需要将`/themes`作为`url`传递，因为我们已经定义了包含`/api/`的`baseURL`。
- en: 'The Resource Hook returns an object with a `data` value, an `isLoading` boolean,
    an `error` object, and a `cancel` function to cancel the pending request. Now,
    we pull out the `data` value and the `isLoading` boolean from the `themes` object:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Resource Hook返回一个带有`data`值、`isLoading`布尔值、`error`对象和`cancel`函数的对象，用于取消挂起的请求。现在，我们从`themes`对象中提取出`data`值和`isLoading`布尔值：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we define a `useEffect` Hook to trigger the `getThemes` function. We
    only want it to trigger once, when the component mounts; therefore, we pass an
    empty array as the second argument:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`useEffect` Hook来触发`getThemes`函数。我们只希望它在组件挂载时触发一次，因此我们将空数组作为第二个参数传递：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Additionally, we use the `isLoading` flag to display a loading message while
    waiting for the server to respond:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们使用`isLoading`标志在等待服务器响应时显示加载消息：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we rename the `themes` value to the `data` value that is returned
    from the `useResource` Hook, and add a conditional check to ensure the `data`
    value is already available:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`themes`值重命名为从`useResource` Hook返回的`data`值，并添加条件检查以确保`data`值已经可用：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If we have a look at our app now, we can see that the Loading themes... message
    gets displayed for a very short time, and, then the themes from our database get
    displayed! We can now move on to requesting posts using the Resource Hook.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在看一下我们的应用程序，我们会发现“加载主题…”的消息会在很短的时间内显示，然后从我们的数据库中显示主题！现在我们可以继续使用Resource
    Hook请求帖子。
- en: Using useResource with a Reducer Hook
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reducer Hook与useResource
- en: The `useResource` Hook already handles the state for the result of our request,
    so we do not need an additional `useState` Hook to store the state. If we already
    have an existing Reducer Hook, however, we can use it in combination with the
    `useResource` Hook.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`useResource` Hook已经处理了我们请求结果的状态，所以我们不需要额外的`useState` Hook来存储状态。然而，如果我们已经有一个现有的Reducer
    Hook，我们可以将其与`useResource` Hook结合使用。'
- en: 'We are now going to implement the `useResource` Hook in combination with a
    Reducer Hook in our app:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在我们的应用程序中实现`useResource` Hook与Reducer Hook的组合使用：
- en: 'In `src/App.js`, import the `useResource` Hook from the `react-request-hook`
    library:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，从`react-request-hook`库中导入`useResource` Hook：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remove the previously defined `useEffect` Hook that uses `fetch` to request
    `/api/posts`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除先前使用`fetch`请求`/api/posts`的`useEffect` Hook。
- en: 'Define a new `useResource` Hook, where we request `/posts`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的`useResource` Hook，在其中请求`/posts`：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define a new `useEffect` Hook, which simply calls `getPosts`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的`useEffect` Hook，简单地调用`getPosts`：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, define a `useEffect` Hook, which dispatches the `FETCH_POSTS` action,
    after checking if the data already exists:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个`useEffect` Hook，在检查数据是否已经存在后，触发`FETCH_POSTS`动作：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We make sure that this Effect Hook triggers every time the `posts` object updates:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确保这个Effect Hook在`posts`对象更新时触发：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, when we fetch new posts, a `FETCH_POSTS` action will be dispatched. Next,
    we move on to handling errors during requests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们获取新的帖子时，将会触发`FETCH_POSTS`动作。接下来，我们将处理请求期间的错误。
- en: Handling error state
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误状态
- en: We have already handled the loading state in the `ChangeTheme` component. Now,
    we are going to implement the error state for posts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`ChangeTheme`组件中处理了加载状态。现在，我们将实现帖子的错误状态。
- en: 'Let''s get started handling the error state for posts:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始处理帖子的错误状态：
- en: 'In `src/reducers.js`, define a new `errorReducer` function with a new action
    type, `POSTS_ERROR`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/reducers.js`中，使用新的动作类型`POSTS_ERROR`定义一个新的`errorReducer`函数：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add the `errorReducer` function to our `appReducer` function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`errorReducer`函数添加到我们的`appReducer`函数中：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In `src/App.js`, adjust the default state of our Reducer Hook:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`中，调整我们的Reducer Hook的默认状态：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Pull the `error` value out of the `state` object:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`state`对象中取出`error`值：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can adjust the existing Effect Hook that handles new data from the
    `posts` resource, by dispatching a `POSTS_ERROR` action in the case of an error:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以调整处理来自`posts`资源的新数据的现有Effect Hook，在出现错误的情况下分派`POSTS_ERROR`动作：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we display the error message before the `PostList` component:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`PostList`组件之前显示错误消息：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we only start the client now (via `npm run start:client`), the error will
    be displayed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在只启动客户端（通过`npm run start:client`），将显示错误：
- en: '![](assets/0638f515-47f9-46f4-a865-5e64b4ee4f9e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0638f515-47f9-46f4-a865-5e64b4ee4f9e.png)'
- en: Displaying an error when the request fails!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求失败时显示错误！
- en: As we can see, the Failed to fetch posts error gets displayed in our app, because
    the server is not running. We can now move on to implementing post creation via
    requests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，由于服务器未运行，我们的应用程序中显示了无法获取帖子的错误。现在我们可以继续通过请求实现帖子创建。
- en: Implementing post creation
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现帖子创建
- en: Now that we have a good grasp on how to request data from an API, we are going
    to use the `useResource` Hook for the creation of new data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了如何从API请求数据，我们将使用`useResource` Hook来创建新数据。
- en: 'Let''s get started implementing post creation using the Resource Hook:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Resource Hook实现帖子创建：
- en: 'Edit `src/post/CreatePost.js`, and import the `useResource` Hook:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/CreatePost.js`，并导入`useResource` Hook：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, define a new Resource Hook, below the other Hooks, but before our handler
    function definitions. Here, we set the method to `post` (creates new data) and
    we pass the data from the `createPost` function, to the request config:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在其他Hooks之后但在处理程序函数定义之前，定义一个新的Resource Hook。在这里，我们将方法设置为`post`（创建新数据），并将数据从`createPost`函数传递给请求配置：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we are using a shorthand syntax for array destructuring: we are ignoring
    the first element of the array, by not specifying a value name. Instead of writing
    `const [ post, createPost ]`, and then not using `post`, we just put a comma,
    as follows: `const [  , createPost ]`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了数组解构的简写语法：我们通过不指定值名称来忽略数组的第一个元素。我们不写`const [ post, createPost ]`，然后不使用`post`，而是直接写一个逗号，如下所示：`const
    [  , createPost ]`。
- en: 'Now, we can use the `createPost` function in our `handleCreate` handler function.
    We make sure that we keep the call to the `dispatch` function there, so that we
    immediately insert the new post client-side, while waiting for the server to respond.
    The added code is highlighted in bold:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`handleCreate`处理程序函数中使用`createPost`函数。我们确保保留对`dispatch`函数的调用，以便在等待服务器响应的同时立即在客户端插入新帖子。添加的代码已用粗体标出：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Please note that, in this simple example, we do not expect, or handle the failure
    of post creations. In this case, we dispatch the action even before the request
    completes. However, when implementing login, we are going to handle error states
    from the request, in order to check whether the user was logged in successfully.
    It is best practice to always handle error states in real-world applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个简单的例子中，我们不期望或处理帖子创建的失败。在这种情况下，我们甚至在请求完成之前就分派了动作。然而，在实施登录时，我们将处理来自请求的错误状态，以检查用户是否成功登录。在真实世界的应用程序中，始终处理错误状态是最佳实践。
- en: 'Note that when we insert a post now, the post will first be at the beginning
    of the list; however, after refreshing, it will be at the end of the list. Unfortunately,
    our server inserts new posts at the end of the list. Therefore, we are going to
    reverse the order, after fetching posts from the server. Edit `src/App.js`, and
    adjust the following code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，现在插入帖子时，帖子将首先出现在列表的开头；然而，刷新后，它将出现在列表的末尾。不幸的是，我们的服务器将新帖子插入到列表的末尾。因此，在从服务器获取帖子后，我们将颠倒顺序。编辑`src/App.js`，并调整以下代码：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, inserting a new post via the server works fine and we can move on to implementing
    registration!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过服务器插入新帖子运行良好，我们可以继续实施注册！
- en: Implementing registration
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施注册
- en: Next, we are going to implement registration, which is going to work in very
    similar way to creating posts.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实施注册，这将与创建帖子的方式非常相似。
- en: 'Let''s get started implementing registration:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实施注册：
- en: 'First, import the `useEffect` and `useResource` Hooks in `src/user/Register.js`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src/user/Register.js`中导入`useEffect`和`useResource`钩子：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, define a new `useResource` Hook, below the other Hooks, and before the
    handler functions. Unlike we did in the post creation, we now want to also store
    the resulting `user` object:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在其他钩子下面和处理程序函数之前定义一个新的`useResource`钩子。与我们在创建帖子时所做的不同，我们现在还希望存储生成的`user`对象：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, define a new `useEffect` Hook below the `useResource` Hook, which will
    dispatch a `REGISTER` action when the request completes:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`useResource`钩子下面定义一个新的`useEffect`钩子，当请求完成时将分派一个`REGISTER`动作：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Please note that, in this simple example, we do not expect, or handle the failure
    of registrations. In this case, we dispatch the action only after the successful
    creation of the user. However, when implementing login, we are going to handle
    error states from the request, in order to check whether the user was logged in
    successfully. It is best practice to always handle error states in real-world
    applications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个简单的例子中，我们不期望或处理注册的失败。在这种情况下，我们只在用户成功创建后分派动作。然而，在实施登录时，我们将处理来自请求的错误状态，以检查用户是否成功登录。在真实世界的应用程序中，始终处理错误状态是最佳实践。
- en: 'Finally, we adjust the form submit handler in order to call the `register`
    function, instead of directly dispatching the action:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调整表单提交处理程序，以调用`register`函数，而不是直接分派动作：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, if we enter a Username and Password, and press Register, a new user will
    be inserted into our `db.json` file and, just like before, we will be logged in.
    We now move on to implementing login via Resource Hooks.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们输入用户名和密码，然后点击注册，一个新用户将被插入到我们的`db.json`文件中，就像以前一样，我们将登录。我们现在继续通过资源钩子实施登录。
- en: Implementing login
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施登录
- en: Finally, we are going to implement login, via requests using our custom route.
    After doing so, our blog app will be fully connected to the server.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过使用我们的自定义路由来实施登录。这样做后，我们的博客应用程序将完全连接到服务器。
- en: 'Let''s get started implementing login:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实施登录：
- en: 'First, edit `src/user/Login.js` and import the `useEffect` and `useResource`
    Hooks:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑`src/user/Login.js`并导入`useEffect`和`useResource`钩子：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We define a new State Hook that will store a boolean to check if the login
    failed:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个新的State Hook，它将存储一个布尔值，用于检查登录是否失败：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we define a new State Hook for the Password field, because we did not
    handle it before:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为密码字段定义一个新的State Hook，因为之前我们没有处理它：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we define a handler function for the Password field, below the `handleUsername`
    function:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为密码字段定义一个处理函数，放在`handleUsername`函数下面：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we handle the value change in the `input` field:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们处理`input`字段中的值更改：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we can define our Resource Hook below the State Hooks, where we are going
    to pass `username` and `password` to the `/login` route. Since we are passing
    them as part of the URL, we need to make sure that we encode them properly first:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在State Hooks下面定义我们的Resource Hook，在这里我们将`username`和`password`传递给`/login`路由。由于我们将它们作为URL的一部分传递，我们需要确保首先正确地对它们进行编码：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Please note that it is not secure to send the password in cleartext via a GET
    request. We only do this for the sake of simplicity when configuring our dummy
    server. In a real world application, use a POST request for login instead and
    send the password as part of the POST data. Also make sure to use **Hypertext
    Transfer Protocol Secure (HTTPS)** so that the POST data will be encrypted.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过GET请求以明文发送密码是不安全的。我们之所以这样做，只是为了简化配置我们的虚拟服务器。在真实世界的应用程序中，应该使用POST请求进行登录，并将密码作为POST数据的一部分发送。还要确保使用**超文本传输安全协议（HTTPS）**，以便对POST数据进行加密。
- en: 'Next, we define an Effect Hook, which will dispatch the `LOGIN` action if the
    request completes successfully:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个Effect Hook，如果请求成功完成，它将分派`LOGIN`动作：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Because the login route returns either an empty array (login failed), or an
    array with a single user, we need to check whether the array contains at least
    one element:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为登录路由返回的要么是一个空数组（登录失败），要么是一个包含单个用户的数组，所以我们需要检查数组是否至少包含一个元素：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the array was empty, we set `loginFailed` to `true`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组为空，我们将`loginFailed`设置为`true`：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we get an error response from the server, we also set the login state to
    failed:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从服务器获得错误响应，我们还将登录状态设置为失败：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We make sure that the Effect Hook triggers whenever the `user` object from
    the Resource Hook updates:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确保Effect Hook在Resource Hook更新`user`对象时触发：
- en: '[PRE74]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we adjust the `onSubmit` function of `form`, in order to call the `login`
    function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调整`form`的`onSubmit`函数，以调用`login`函数：
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, below the Submit button, we display the Invalid username or password
    message, in case `loginFailed` was set to `true`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在提交按钮下面，我们显示“用户名或密码无效”的消息，以防`loginFailed`被设置为`true`：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As we can see, entering a wrong Username or Password (or no Password) will
    result in an error, while entering the correct Username/Password combination will
    log us in:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，输入错误的用户名或密码（或没有密码）将导致错误，而输入正确的用户名/密码组合将使我们登录：
- en: '![](assets/a5f6d839-c39e-459a-a083-674827a8ce51.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5f6d839-c39e-459a-a083-674827a8ce51.png)'
- en: Displaying an error message when the login failed
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录失败时显示错误消息
- en: Now, our app is fully connected to the backend server!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已完全连接到后端服务器！
- en: Example code
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter06/chapter6_3` folder.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter06/chapter6_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Preventing unnecessary re-rendering with React.memo
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React.memo防止不必要的重新渲染
- en: With class components we had `shouldComponentUpdate`, which would prevent components
    from re-rendering if the props did not change.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，我们有`shouldComponentUpdate`，它可以防止组件在props没有改变时重新渲染。
- en: 'With function components, we can do the same using `React.memo`, which is a
    higher-order component. `React.memo` memoizes the result, which means that it
    will remember the last rendered result, and, in cases where the props did not
    change, it will skip re-rendering the component:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数组件，我们可以使用`React.memo`来做同样的事情，这是一个高阶组件。`React.memo`会记住上次渲染的结果，如果props没有改变，它将跳过重新渲染组件：
- en: '[PRE77]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'By default, `React.memo` will act like the default definition of `shouldComponentUpdate`,
    and it will only shallowly compare the props object. If we want to do a special
    comparison, we can pass a function as a second argument to `React.memo`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`React.memo`将像`shouldComponentUpdate`的默认定义一样，它只会浅层比较props对象。如果我们想要进行特殊比较，可以将函数作为第二个参数传递给`React.memo`：
- en: '[PRE78]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Unlike `shouldComponentUpdate`, the function that is passed to `React.memo` returns
    `true` when the props are equal, and thus it should not update, which is the opposite
    of how `shouldComponentUpdate` works! After learning about `React.memo`, let's
    try it out in practice by implementing `React.memo` for the Post component.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与`shouldComponentUpdate`不同，传递给`React.memo`的函数在props相等时返回`true`，因此它不应该更新，这与`shouldComponentUpdate`的工作方式相反！学习了`React.memo`之后，让我们尝试在实践中实现`React.memo`来为Post组件。
- en: Implementing React.memo for the Post component
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Post组件中实现React.memo
- en: 'First, let''s find out when the `Post` component re-renders. To do this, we
    are going to add a `console.log` statement to our `Post` component, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找出`Post`组件何时重新渲染。为此，我们将向`Post`组件添加一个`console.log`语句，如下所示：
- en: 'Edit `src/post/Post.js`, and add the following debug output when the component
    renders:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/Post.js`，并在组件渲染时添加以下调试输出：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, open the app at `http://localhost:3000`, and open the DevTools (on most
    browsers: right-click | Inspect on the page). Go to the Console tab, and you should
    see the output twice, because we are rendering two posts:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`http://localhost:3000`的应用程序，并打开DevTools（在大多数浏览器上：右键单击|在页面上检查）。转到控制台选项卡，您应该看到输出两次，因为我们正在渲染两篇文章：
- en: '![](assets/cdef8b29-ea94-4c5a-8d74-673d1d9e6131.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cdef8b29-ea94-4c5a-8d74-673d1d9e6131.png)'
- en: The debug output when rendering two posts
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染两篇文章时的调试输出
- en: 'So far, so good. Now, let''s try logging in, and see what happens:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在，让我们尝试登录，并看看会发生什么：
- en: '![](assets/117dcf52-9fda-4279-b272-caa9eba73376.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/117dcf52-9fda-4279-b272-caa9eba73376.png)'
- en: Posts re-rendering after logging in
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后重新渲染文章
- en: 'As we can see, the Post components unnecessarily re-render after logging in,
    although their props did not change. We can use `React.memo` to prevent this,
    as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，登录后，文章组件不必要地重新渲染，尽管它们的props没有改变。我们可以使用`React.memo`来防止这种情况，如下所示：
- en: 'Edit `src/post/Post.js`, and remove the export default part of the function
    definition (marked in bold):'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/Post.js`，并删除函数定义的export default部分（用粗体标记）：
- en: '[PRE80]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, at the bottom of the file, export the Post component, after wrapping
    it with `React.memo()`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在文件底部，将Post组件包装在`React.memo()`中后导出：
- en: '[PRE81]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, refresh the page and log in again. We can see that the two posts get rendered,
    which produces the initial debug output. However, logging in now does not cause
    the Post components to re-render anymore!
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新页面并重新登录。我们可以看到两篇文章被渲染，这产生了初始的调试输出。然而，现在登录不再导致文章组件重新渲染了！
- en: 'If we wanted to do a custom check on whether the posts are equal, we could,
    for example, compare `title`, `content`, and `author`, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对文章是否相等进行自定义检查，我们可以比较`title`，`content`和`author`，如下所示：
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In our case, doing this will have the same effect, because React already does
    a shallow comparison of all props, by default. This function only becomes useful
    when we have deep objects to compare, or when we want to ignore changes in certain
    props. Please note that we should not prematurely optimize our code. Re-renders
    can be fine, since React is intelligent, and does not paint to the browser if
    nothing changed. Therefore, it might be overkill to optimize all re-renders, unless
    a certain case has already been identified as a performance bottleneck.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这样做将产生相同的效果，因为React默认已经对所有props进行了浅比较。当我们有深层对象需要比较，或者当我们想要忽略某些props的更改时，这个函数才会变得有用。请注意，我们不应该过早地优化我们的代码。重新渲染可能没问题，因为React是智能的，如果没有变化，它就不会在浏览器中绘制。因此，除非已经确定某种情况是性能瓶颈，否则优化所有重新渲染可能有些过度。
- en: Example code
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter06/chapter6_4` folder.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter06/chapter6_4`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Implementing lazy loading with React Suspense
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Suspense实现懒加载
- en: React Suspense allows us to let components wait before rendering. At the moment,
    React Suspense only allows us to dynamically load components with `React.lazy`.
    In the future, Suspense will support other use cases, such as data fetching.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: React Suspense允许我们在渲染之前让组件等待。目前，React Suspense只允许我们使用`React.lazy`动态加载组件。将来，Suspense将支持其他用例，比如数据获取。
- en: '`React.lazy` is another form of performance optimization. It lets us load a
    component dynamically in order to reduce the bundle size. Sometimes we want to
    avoid loading all of the components during the initial render, and only request
    certain components when they are needed.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.lazy`是另一种性能优化的形式。它让我们动态加载组件以减少捆绑包大小。有时我们希望在初始渲染时避免加载所有组件，只在需要时请求特定组件。'
- en: For example, if our blog has a member area, we only need to load it after the
    user has logged in. Doing this will reduce the bundle size for guests who only
    visit our blog to read blog posts. To learn about React Suspense, we are going
    to lazily load the `Logout` component in our blog app.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的博客有一个会员区域，我们只需要在用户登录后加载它。这样做将减少那些只访问我们博客阅读博文的访客的捆绑包大小。为了了解React Suspense，我们将在我们的博客应用程序中懒加载`Logout`组件。
- en: Implementing React.Suspense
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现React.Suspense
- en: First, we have to specify a loading indicator, which will be shown when our
    lazily-loaded component is loading. In our example, we are going to wrap the `UserBar`
    component with React Suspense.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定一个加载指示器，在我们的懒加载组件加载时显示。在我们的示例中，我们将使用React Suspense包装`UserBar`组件。
- en: 'Edit `src/App.js`, and replace the `<UserBar />` component with the following
    code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`，并用以下代码替换`<UserBar />`组件：
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, our app is ready for implementing lazy loading.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已准备好实现懒加载。
- en: Implementing React.lazy
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现React.lazy
- en: 'Next, we are going to implement lazy loading for the `Logout` component by
    wrapping it with `React.lazy()`, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用`React.lazy()`来实现`Logout`组件的懒加载：
- en: 'Edit `src/user/UserBar.js`, and remove the import statement for the `Logout`
    component:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/user/UserBar.js`，并删除`Logout`组件的导入语句：
- en: '[PRE84]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, define the `Logout` component via lazy loading:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过懒加载定义`Logout`组件：
- en: '[PRE85]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `import()` function dynamically loads the `Logout` component from the `Logout.js`
    file. In contrast to the static `import` statement, this function only gets called
    when `React.lazy` triggers it, which means it will only be imported when the component
    is needed.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`函数动态加载`Logout`组件从`Logout.js`文件中。与静态的`import`语句相反，这个函数只有在`React.lazy`触发时才会被调用，这意味着只有在需要组件时才会被导入。'
- en: 'If we want to see lazy loading in action, we can set Network Throttling to
    Slow 3G in Google Chrome:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看到延迟加载的效果，可以在Google Chrome中将网络节流设置为Slow 3G：
- en: '![](assets/a62969d1-50ad-4b34-98ac-b763d644f451.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a62969d1-50ad-4b34-98ac-b763d644f451.png)'
- en: Setting Network Throttling to Slow 3G in Google ChromeIn Firefox, we can do
    the same by setting Network Throttling to GPRS.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Chrome中将网络节流设置为Slow 3G，在Firefox中，我们可以通过将网络节流设置为GPRS来实现相同的效果。
- en: Safari unfortunately does not offer such a feature right now, but we can use
    the Network Link Conditioner tool from Apple's "Hardware IO tools": [https://developer.apple.com/download/more/](https://developer.apple.com/download/more/)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Safari目前还没有这样的功能，但我们可以使用苹果的“硬件IO工具”中的Network Link Conditioner工具：[https://developer.apple.com/download/more/](https://developer.apple.com/download/more/)
- en: 'If we refresh the page now, and then log in, we can first see the Loading...
    message, and then the `Logout` component will be shown. If we take a look at the
    Network logs, we can see that the `Logout` component was requested via the network:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在刷新页面，然后登录，我们首先可以看到“加载中…”的消息，然后会显示`Logout`组件。如果我们查看网络日志，我们可以看到`Logout`组件是通过网络请求的：
- en: '![](assets/5d3e7ef1-f8cb-4a8a-86dd-9bfe1c8f3a0e.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d3e7ef1-f8cb-4a8a-86dd-9bfe1c8f3a0e.png)'
- en: The Logout component being loaded via the network
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络加载的注销组件
- en: As we can see, the `Logout` component is now lazily loaded, which means that
    it will only be requested when needed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Logout`组件现在是懒加载的，这意味着只有在需要时才会被请求。
- en: Example code
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code can be found in the `Chapter06/chapter6_5` folder.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在`Chapter06/chapter6_5`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies, and `npm start` to
    start the application; then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序；然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first learned how to set up an API server from a JSON file.
    Then, we learned how to request resources using Effect and State/Reducer Hooks.
    Next, we learned how to request resources using the `axios` and `react-request-hook`
    libraries. Finally, we learned how to prevent unnecessary re-rendering using `React.memo`,
    and how to lazily-load components with React Suspense.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何从JSON文件设置API服务器。然后，我们学习了如何使用Effect和State/Reducer Hooks请求资源。接下来，我们学习了如何使用`axios`和`react-request-hook`库请求资源。最后，我们学习了如何使用`React.memo`来防止不必要的重新渲染，以及如何使用React
    Suspense来懒加载组件。
- en: In the next chapter, we are going to add routes to our application, and learn
    how to use Hooks for routing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的应用程序添加路由，并学习如何使用Hooks进行路由。
- en: Questions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章学到的知识，请尝试回答以下问题：
- en: How can we easily create a full REST API from a simple JSON file?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何可以轻松地从简单的JSON文件创建一个完整的REST API？
- en: What are the advantages of using a proxy to access our backend server during
    development?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代理访问后端服务器在开发过程中有哪些优势？
- en: Which combinations of Hooks can we use to implement requests?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些Hooks组合来实现请求？
- en: Which libraries can we use to implement requests?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些库来实现请求？
- en: How can we deal with loading states using `react-request-hook`?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用`react-request-hook`处理加载状态？
- en: How can we deal with errors using `react-request-hook`?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用`react-request-hook`处理错误？
- en: How can we prevent the unnecessary re-rendering of components?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何防止组件不必要的重新渲染？
- en: How can we reduce the bundle size of our app?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何减少应用程序的捆绑大小？
- en: Further reading
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have explored
    in this chapter, take a look at the following reading material:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对我们在本章中探讨的概念更感兴趣，可以查阅以下阅读材料：
- en: Official documentation of `json-server`: [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json-server`的官方文档：[https://github.com/typicode/json-server](https://github.com/typicode/json-server).'
- en: Official documentation of `concurrently`: [https://github.com/kimmobrunfeldt/concurrently](https://github.com/kimmobrunfeldt/concurrently).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrently`的官方文档：[https://github.com/kimmobrunfeldt/concurrently](https://github.com/kimmobrunfeldt/concurrently).'
- en: Official documentation of `axios`: [https://github.com/axios/axios](https://github.com/axios/axios).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axios`的官方文档：[https://github.com/axios/axios](https://github.com/axios/axios).'
- en: Official documentation of `react-request-hook`: [https://github.com/schettino/react-request-hook](https://github.com/schettino/react-request-hook).
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-request-hook`的官方文档：[https://github.com/schettino/react-request-hook](https://github.com/schettino/react-request-hook).'
- en: Create React App documentation on configuring proxies: [https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development#configuring-the-proxy-manually](https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development#configuring-the-proxy-manually).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Create React App关于配置代理的文档：[https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development#configuring-the-proxy-manually](https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development#configuring-the-proxy-manually).
- en: Fetching data with React Hooks: [https://www.robinwieruch.de/react-hooks-fetch-data](https://www.robinwieruch.de/react-hooks-fetch-data)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Hooks获取数据：[https://www.robinwieruch.de/react-hooks-fetch-data](https://www.robinwieruch.de/react-hooks-fetch-data)
- en: When to use `useMemo`: [https://kentcdodds.com/blog/usememo-and-usecallback](https://kentcdodds.com/blog/usememo-and-usecallback)
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用`useMemo`：[https://kentcdodds.com/blog/usememo-and-usecallback](https://kentcdodds.com/blog/usememo-and-usecallback)
