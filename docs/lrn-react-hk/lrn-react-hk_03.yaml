- en: Using the State Hook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用State Hook
- en: Now that you've learned about the principles of React and had an introduction
    to Hooks, we are going to learn about the State Hook in depth. We will start by
    learning how the State Hook works internally by reimplementing it ourselves. Next,
    we learn about some of the limitations of Hooks, and why they exist. Then, we
    will learn about possible alternative Hook APIs and their associated problems.
    Finally, we learn how to solve the common problems that result from the limitations
    of Hooks. By the end of this chapter, we will know how to use the State Hook in
    order to implement stateful function components in React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了React的原则，并且对Hooks有了介绍，我们将深入学习State Hook。我们将首先通过重新实现来学习State Hook的内部工作原理。接下来，我们将了解Hooks的一些限制以及它们存在的原因。然后，我们将学习可能的替代Hook
    API及其相关问题。最后，我们将学习如何解决由Hooks限制导致的常见问题。通过本章的学习，我们将知道如何使用State Hook来实现React中的有状态函数组件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reimplementing the `useState` Hook as a simple function, which accesses the
    global state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`useState` Hook重新实现为一个简单的函数，用于访问全局状态
- en: Comparing our reimplementation to real React Hooks and learning about the differences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的重新实现与真实的React Hooks进行比较，并了解它们之间的区别
- en: Learning about possible alternative Hook APIs and their trade-offs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习可能的替代Hook API及其权衡
- en: Solving common problems resulting from the limitations of Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决由Hooks限制导致的常见问题
- en: Solving problems with conditional Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决条件Hooks的问题
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了一个相当新的Node.js版本（v11.12.0或更高）。还需要安装Node.js的`npm`包管理器。
- en: The code for this chapter can be found in the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub仓库中找到：[https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter02)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been previously provided. It is
    important that you write the code yourself so that you learn and understand it
    properly. However, if you run into any issues, you can always refer to the code
    example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您自己编写代码。不要简单地运行之前提供的代码示例。重要的是您自己编写代码，以便正确地学习和理解它。但是，如果遇到任何问题，您可以随时参考代码示例。
- en: Now, let's get started with the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始本章的学习。
- en: Reimplementing the useState function
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新实现useState函数
- en: In order to get a better understanding of how Hooks work internally, we are
    going to reimplement the `useState` Hook from scratch. However, we are not going
    to implement it as an actual React Hook, but as a simple JavaScript function—just
    to get an idea of what Hooks are actually doing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Hooks的内部工作原理，我们将从头开始重新实现`useState` Hook。但是，我们不会将其实现为实际的React Hook，而是作为一个简单的JavaScript函数——只是为了了解Hooks实际在做什么。
- en: Please note that this reimplementation is not exactly how React Hooks work internally.
    The actual implementation is similar, and thus, it has similar constraints. However,
    the real implementation is much more complicated than what we will be implementing
    here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个重新实现并不完全是React Hooks内部的工作原理。实际的实现是类似的，因此具有类似的约束。然而，真实的实现要比我们在这里实现的要复杂得多。
- en: 'We are now going to start reimplementing the State Hook:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始重新实现State Hook：
- en: First, we copy the code from `chapter1_2`, where we are going to replace the
    current `useState` Hook with our own implementation.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`chapter1_2`中复制代码，我们将用我们自己的实现替换当前的`useState` Hook。
- en: 'Open `src/App.js` and remove the import of the Hook by removing the following
    line:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/App.js`并通过删除以下行来移除Hook的导入：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Replace it with these lines of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are going to need `ReactDOM` in order to force rerendering of the component
    in our reimplementation of the `useState` Hook. If we used actual React Hooks,
    this would be dealt with internally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`ReactDOM`来强制重新渲染我们的`useState` Hook的组件。如果我们使用实际的React Hooks，这将在内部处理。
- en: 'Now, we define our own `useState` function. As we already know, the `useState`
    function takes the `initialState` as an argument:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义我们自己的`useState`函数。正如我们已经知道的，`useState`函数将`initialState`作为参数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we define a value, where we will store our state. At first, this value
    will be set to `initialState`, which is passed as an argument to the function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个值，我们将在其中存储我们的状态。起初，这个值将被设置为传递给函数的`initialState`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we define the `setState` function, where we will set the value to something
    different, and force the rerendering of our `MyName` component:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`setState`函数，我们将在其中将值设置为不同的东西，并强制重新渲染我们的`MyName`组件：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we return the `value` and the `setState` function as an array:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`value`和`setState`函数作为数组返回：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The reason why we use an array, and not an object, is that we usually want
    to rename the `value` and `setState` variables. Using an array makes it easy to
    rename the variables through destructuring:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组而不是对象的原因是，我们通常想要重命名`value`和`setState`变量。使用数组使得通过解构很容易重命名变量：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, Hooks are simple JavaScript functions that deal with side effects,
    such as setting a stateful value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Hooks是处理副作用的简单的JavaScript函数，比如设置有状态的值。
- en: Our Hook function uses a closure to store the current value. The closure is
    an environment where variables exist and are stored. In our case, the function
    provides the closure, and the `value` variable is stored within that closure.
    The `setState` function is also defined within the same closure, which is why
    we can access the `value` variable within that function. Outside of the `useState`
    function, we cannot directly access the `value` variable unless we return it from
    the function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Hook函数使用闭包来存储当前值。闭包是一个环境，变量存在并被存储在其中。在我们的例子中，函数提供了闭包，`value`变量被存储在闭包中。`setState`函数也在同一个闭包中定义，这就是为什么我们可以在该函数中访问`value`变量。在`useState`函数之外，我们不能直接访问`value`变量，除非我们从函数中返回它。
- en: Problems with our simple Hook implementation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们简单的Hook实现存在的问题
- en: If we run our Hook implementation now, we are going to notice that when our
    component rerenders, the state gets reset, so we cannot enter any text in the
    field. This is due to the reinitialization of the `value` variable every time
    our component gets rendered, which happens because we call `useState` each time
    we render the component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的Hook实现，我们会注意到当我们的组件重新渲染时，状态被重置，所以我们无法在字段中输入任何文本。这是因为每次我们的组件重新渲染时`value`变量的重新初始化，这是因为我们每次渲染组件时都调用`useState`。
- en: In the upcoming sections, we are going to solve this problem by using a global
    variable and then turn the simple value into an array, allowing us to define multiple
    Hooks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将通过使用全局变量来解决这个问题，然后将简单值转换为数组，从而允许我们定义多个Hooks。
- en: Using a global variable
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局变量
- en: As we have learned, the value is stored within the closure that is defined by
    the `useState` function. Every time the component rerenders, the closure is reinitialized,
    which means that our value will be reset. To solve this, we need to store the
    value in a global variable, outside of the function. That way, the `value` variable
    will be in the closure outside of the function, which means that when the function
    gets called again, the closure will not be reinitialized.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，值存储在由 `useState` 函数定义的闭包中。每次组件重新渲染时，闭包都会被重新初始化，这意味着我们的值将被重置。为了解决这个问题，我们需要将值存储在函数之外的全局变量中。这样，`value`
    变量将在函数之外的闭包中，这意味着当函数再次被调用时，闭包不会被重新初始化。
- en: 'We can define a global variable as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个全局变量如下：
- en: 'First, we add the following line (in bold) above the `useState` function definition:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `useState` 函数定义之前，我们添加以下行（加粗）。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we replace the first line in our function with the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用以下代码替换我们函数中的第一行：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, our `useState` function uses the global `value` variable, instead of defining
    the `value` variable within its closure, so it will not be reinitialized when
    the function gets called again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `useState` 函数使用全局 `value` 变量，而不是在其闭包中定义 `value` 变量，因此当函数再次被调用时，它不会被重新初始化。
- en: Defining multiple Hooks
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义多个 Hook
- en: 'Our Hook function works! However, if we wanted to add another Hook, we would
    run into another problem: all the Hooks write to the same global `value` variable!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Hook 函数起作用了！但是，如果我们想要添加另一个 Hook，我们会遇到另一个问题：所有的 Hook 都写入同一个全局 `value` 变量！
- en: Let's take a closer look at this problem by adding a second Hook to our component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的组件添加第二个 Hook 来更仔细地研究这个问题。
- en: Adding multiple Hooks to our component
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的组件添加多个 Hook
- en: 'Let''s say we want to create a second field for the last name of the user,
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为用户的姓氏创建第二个字段，如下所示：
- en: 'We start by creating a new Hook at the beginning of our function, after the
    current Hook:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在函数开头创建一个新的 Hook，放在当前 Hook 之后：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we define another `handleChange` function:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义另一个 `handleChange` 函数：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we place the `lastName` variable after the first name:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 `lastName` 变量放在名字后面：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we add another `input` field:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加另一个 `input` 字段：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we try this out, we are going to notice that our reimplemented Hook function
    uses the same value for both states, so we are always changing both fields at
    once.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试这样做时，我们会注意到我们重新实现的 Hook 函数同时使用相同的值，所以我们总是同时更改两个字段。
- en: Implementing multiple Hooks
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多个 Hook
- en: In order to implement multiple Hooks, instead of having a single global variable,
    we should have an array of Hook values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现多个 Hook，我们应该有一个 Hook 值的数组，而不是一个单一的全局变量。
- en: 'We are now going to refactor the `value` variable to a `values` array so that
    we can define multiple Hooks:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将 `value` 变量重构为 `values` 数组，以便我们可以定义多个 Hook：
- en: 'Remove the following line of code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下代码行：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace it with the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码片段替换它：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, edit the first line of the `useState` function where we now initialize
    the value at the `currentHook` index of the `values` array:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编辑 `useState` 函数的第一行，我们现在在 `values` 数组的 `currentHook` 索引处初始化值：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also need to update the setter function, so that only the corresponding
    state value is updated. Here, we need to store the `currentHook` value in a separate
    `hookIndex` variable, because the `currentHook` value will change later. This
    ensures that a copy of the `currentHook` variable is created within the closure
    of the `useState` function. Otherwise, the `useState` function would access the
    `currentHook` variable from the outer closure, which gets modified with each call
    to `useState`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新setter函数，以便只更新相应的状态值。在这里，我们需要将`currentHook`的值存储在单独的`hookIndex`变量中，因为`currentHook`的值稍后会更改。这确保在`useState`函数的闭包中创建了`currentHook`变量的副本。否则，`useState`函数将访问外部闭包中的`currentHook`变量，该变量在每次调用`useState`时都会被修改。
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Edit the final line of the `useState` function, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`useState`函数的最后一行，如下所示：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using `values[currentHook++]`, we pass the current value of `currentHook` as
    an index to the `values` array, and then increase `currentHook` by one. This means
    that `currentHook` will be increased after returning from the function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`values[currentHook++]`，我们将`currentHook`的当前值作为索引传递给`values`数组，然后将`currentHook`增加一。这意味着在从函数返回后`currentHook`将增加。
- en: If we wanted to first increment a value and then use it, we could use the `arr[++indexToBeIncremented]`
    syntax, which first increments, and then passes the result to the array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想先增加一个值，然后再使用它，我们可以使用`arr[++indexToBeIncremented]`语法，它首先增加，然后将结果传递给数组。
- en: 'We still need to reset the `currentHook` counter when we start rendering our
    component. Add the following line (in bold) right after the component definition:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始渲染组件时，我们仍然需要重置`currentHook`计数器。在组件定义之后添加以下行（用粗体标出）：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, our simple reimplementation of the `useState` Hook works! The following
    screenshot highlights this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对`useState` Hook的简单重新实现有效！以下截图突出显示了这一点：
- en: '![](assets/de58db6c-14f4-478c-8f14-074080e7ee47.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de58db6c-14f4-478c-8f14-074080e7ee47.png)'
- en: Our custom Hook reimplementation works
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义Hook重新实现有效
- en: As we can see, using a global array to store our Hook values solved the problems
    that we had when defining multiple Hooks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用全局数组来存储我们的Hook值解决了在定义多个Hook时遇到的问题。
- en: Example code
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for the simple Hook reimplementation can be found in the `Chapter02/chapter2_1`
    folder.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简单Hook重新实现的示例代码可以在`Chapter02/chapter2_1`文件夹中找到。
- en: Just run `npm install` in order to install all the dependencies and `npm start`
    to start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`以安装所有依赖项，然后运行`npm start`启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Can we define conditional Hooks?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以定义条件Hook吗？
- en: What if we wanted to add a checkbox that toggles the use of the first name field?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加一个复选框来切换使用名字字段，该怎么办？
- en: 'Let''s find out by implementing such a checkbox:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现这样一个复选框来找出：
- en: 'First, we add a new Hook in order to store the state of our checkbox:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个新的Hook来存储复选框的状态：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we define a handler function:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个处理函数：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we render a checkbox:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们渲染一个复选框：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We do not want to show the first name if it is disabled. Edit the following
    existing line in order to add a check for the `enableFirstName` variable:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不想显示名字，可以编辑以下现有行以添加对`enableFirstName`变量的检查：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Could we put the Hook definition into an `if` condition, or a ternary expression,
    like we are in the following code snippet?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否可以将Hook定义放入`if`条件或三元表达式中，就像我们在以下代码片段中所做的那样？
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The latest version of `react-scripts` actually throws an error when defining
    conditional Hooks, so we need to downgrade the library for this example, by running
    the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，最新版本的`react-scripts`在定义条件钩子时会抛出错误，因此我们需要通过运行以下命令来降级库以进行示例：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we either use the Hook, or if the first name is disabled, we return the
    initial state and an empty setter function so that editing the input field will
    not work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要么使用钩子，要么如果名字被禁用，我们返回初始状态和一个空的setter函数，这样编辑输入字段就不起作用。
- en: 'If we now try out this code, we are going to notice that editing the last name
    still works, but editing the first name does not work, which is what we wanted.
    As we can see in the following screenshot, only editing the last name works now:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行这段代码，我们会注意到编辑姓氏仍然有效，但编辑名字不起作用，这正是我们想要的。正如我们在以下截图中所看到的，现在只有编辑姓氏有效：
- en: '![](assets/3d7b5e61-a873-4b2d-b8b3-2d7ef07896e6.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/3d7b5e61-a873-4b2d-b8b3-2d7ef07896e6.png)
- en: State of the app before checking the checkbox
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选复选框之前的应用状态
- en: 'When we click the checkbox, something strange happens:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击复选框时，会发生一些奇怪的事情：
- en: The checkbox is checked
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框已被选中
- en: The first name input field is enabled
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字输入字段已启用
- en: The value of the last name field is now the value of the first name field
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在姓氏字段的值是名字字段的值
- en: 'We can see the result of clicking the checkbox in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到单击复选框的结果：
- en: '![](assets/1796851e-7490-424a-8e4f-8892e2f9babd.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/1796851e-7490-424a-8e4f-8892e2f9babd.png)
- en: State of the app after checking the checkbox
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选复选框后的应用状态
- en: We can see that the last name state is now in the first name field. The values
    have been swapped because the order of Hooks matters. As we know from our implementation,
    we use the `currentHook` index in order to know where the state of each Hook is
    stored. However, when we insert an additional Hook in-between two existing Hooks,
    the order gets messed up.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到姓氏状态现在在名字字段中。值已经交换，因为钩子的顺序很重要。正如我们从我们的实现中所知，我们使用`currentHook`索引来知道每个钩子的状态存储在哪里。然而，当我们在两个现有钩子之间插入一个额外的钩子时，顺序就会混乱。
- en: 'Before checking the checkbox, the `values` array was as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在勾选复选框之前，`values`数组如下：
- en: '`[false, '''']`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[false, '''']`'
- en: Hook order: `enableFirstName`, `lastName`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子顺序：`enableFirstName`，`lastName`
- en: 'Then, we entered some text in the `lastName` field:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`lastName`字段中输入了一些文本：
- en: '`[false, ''Hook'']`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[false, ''Hook'']`'
- en: Hook order: `enableFirstName`, `lastName`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子顺序：`enableFirstName`，`lastName`
- en: 'Next, we toggled the checkbox, which activated our new Hook:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们切换复选框，激活了我们的新钩子：
- en: '`[true, ''Hook'', '''']`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[true, ''Hook'', '''']`'
- en: Hook order: `enableFirstName`, `name`, `lastName`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子顺序：`enableFirstName`，`name`，`lastName`
- en: As we can see, inserting a new Hook in-between two existing Hooks makes the `name` Hook
    steal the state from the next Hook (`lastName`) because it now has the same index
    that the `lastName` Hook previously had. Now, the `lastName` Hook does not have
    a value, which causes it to set the initial value (an empty string). As a result,
    toggling the checkbox puts the value of the `lastName` field into the `name` field.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在两个现有钩子之间插入一个新的钩子会使`name`钩子窃取下一个钩子（`lastName`）的状态，因为它现在具有与`lastName`钩子先前相同的索引。现在，`lastName`钩子没有值，这导致它设置初始值（空字符串）。因此，切换复选框会将`lastName`字段的值放入`name`字段中。
- en: Example code
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for the problem of the conditional Hook of our simple Hook
    reimplementation can be found in the `Chapter02/chapter2_2` folder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的钩子重新实现的条件钩子问题的示例代码可以在`Chapter02/chapter2_2`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Comparing our reimplementation with real Hooks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的重新实现与真实的Hooks进行比较
- en: Our simple Hook implementation already gives us an idea about how Hooks work
    internally. However, in reality, Hooks do not use global variables. Instead, they
    store state within the React component. They also deal with the Hook counter internally,
    so we do not need to manually reset the count in our function component. Furthermore,
    real Hooks automatically trigger rerenders of our component when the state changes.
    To be able to do this, however, Hooks need to be called from a React function
    component. React Hooks cannot be called outside of React, or inside React class
    components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的Hook实现已经让我们对Hooks内部工作原理有了一些了解。然而，在现实中，Hooks并不使用全局变量。相反，它们在React组件内部存储状态。它们还在内部处理Hook计数器，因此我们不需要在函数组件中手动重置计数。此外，当状态改变时，真正的Hooks会自动触发我们组件的重新渲染。然而，为了能够做到这一点，Hooks需要从React函数组件中调用。React
    Hooks不能在React之外或在React类组件内部调用。
- en: 'By reimplementing the `useState` Hook, we have learned a couple things:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新实现`useState` Hook，我们学到了一些东西：
- en: Hooks are simply functions that access React features
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks只是访问React功能的函数
- en: Hooks deal with side effects that persist across rerenders
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks处理持续存在于重新渲染中的副作用
- en: The order of Hook definitions matters
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook定义的顺序很重要
- en: The last point is especially important because it means that we cannot conditionally
    define Hooks. We should always have all the Hook definitions at the beginning
    of our function component, and never nest them within `if` or other constructs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点尤其重要，因为这意味着我们不能有条件地定义Hooks。我们应该始终在函数组件的开头定义所有的Hook，并且永远不要在`if`或其他结构中嵌套它们。
- en: 'Here we have also learned the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还学到了以下内容：
- en: React Hooks need to be called inside React function components
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks需要在React函数组件内部调用
- en: React Hooks cannot be defined conditionally, or in loops
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks不能有条件地定义，也不能在循环中定义
- en: We are now going to look at alternative Hook APIs that allow conditional Hooks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一下允许有条件Hooks的替代Hook API。
- en: Alternative Hook APIs
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代Hook API
- en: Sometimes, it would be nice to define Hooks conditionally or in loops, but why
    did the React team decide to implement Hooks like this? What are the alternatives?
    Let's go through a few of them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有条件地或在循环中定义Hooks可能会很好，但为什么React团队决定这样实现Hooks呢？有什么替代方案吗？让我们来看看其中的一些。
- en: Named Hooks
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名的Hooks
- en: 'We could give each Hook a name and then store the Hooks in an object instead
    of an array. However, this would not make for a nice API, and we would also always
    have to think of coming up with unique names for Hooks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给每个Hook一个名称，然后将Hooks存储在对象中，而不是数组中。然而，这不会产生一个好的API，并且我们还必须考虑想出唯一的Hook名称：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Furthermore, what would happen when the conditional is set to `false`, or an
    item is removed from the loop? Would we clear the Hook state? If we do not clear
    the Hook state, we might be causing memory leaks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当条件设置为`false`时，或者从循环中移除一个项目时会发生什么？我们会清除Hook状态吗？如果我们不清除Hook状态，可能会导致内存泄漏。
- en: Even if we solved all these problems, there would still be the problem of name
    collisions. If we, for example, create a custom Hook that makes use of the `useState` Hook,
    and call it `nameHook`, then we cannot call any other Hook `nameHook` in our component
    anymore, or we will cause a name collision. This is even the case for Hook names
    from libraries, so we need to make sure we avoid name collisions with Hooks that
    have been defined by libraries as well!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们解决了所有这些问题，仍然会存在名称冲突的问题。例如，如果我们创建一个自定义钩子，利用了`useState`钩子，并将其命名为`nameHook`，那么我们在组件中就不能再调用任何其他钩子`nameHook`，否则就会造成名称冲突。这甚至适用于来自库的钩子名称，因此我们需要确保避免与库定义的钩子发生名称冲突！
- en: Hook factories
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子工厂
- en: 'Alternatively, we could also create a Hook factory function, which uses `Symbol`
    internally, in order to give each Hook a unique key name:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以创建一个钩子工厂函数，它在内部使用`Symbol`，以便为每个钩子提供一个唯一的键名：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we could use the factory function as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式使用工厂函数：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, this means that we will need to instantiate each Hook twice: once
    outside of our component and once inside the function component. This creates
    more room for errors. For example, if we create two Hooks and copy and paste the
    boilerplate code, then we might make a mistake in the name of our Hook resulting
    from the factory function, or we might make a mistake when using the Hook inside
    the component.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着我们需要实例化每个钩子两次：一次在组件外部，一次在函数组件内部。这会增加出错的可能性。例如，如果我们创建两个钩子并复制粘贴样板代码，那么我们可能会在使用工厂函数生成的钩子名称时出错，或者在组件内部使用钩子时出错。
- en: This approach also makes it much harder to create custom Hooks, which forces
    us to write wrapper functions. Furthermore, it is harder to debug these wrapped
    functions than it is to debug a simple function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还使得创建自定义钩子变得更加困难，迫使我们编写包装函数。此外，调试这些包装函数比调试简单函数更加困难。
- en: Other alternatives
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他替代方案
- en: 'There were many proposed alternative APIs for React Hooks, but each of them
    suffered from similar problems: either making the API harder to use, harder to
    debug, or introducing the possibility of name collisions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于React Hooks，有许多提出的替代API，但它们每个都遇到了类似的问题：要么使API更难使用，更难调试，要么引入了名称冲突的可能性。
- en: In the end, the React team decided that the simplest API was to keep track of
    Hooks by counting the order in which they are called. This approach comes with
    its own downsides, such as not being able to call Hooks conditionally or in loops.
    However, this approach makes it very easy for us to create custom Hooks, and it
    is simple to use and debug. We also do not need to worry about naming Hooks, name
    collisions, or writing wrapper functions. The final approach for Hooks lets us
    use Hooks just like any other function!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，React团队决定，最简单的API是通过计算调用它们的顺序来跟踪Hooks。这种方法也有其缺点，比如不能在条件语句中或循环中调用Hooks。然而，这种方法使我们非常容易创建自定义Hooks，并且简单易用易调试。我们也不需要担心命名钩子、名称冲突或编写包装函数。最终的Hooks方法让我们可以像使用任何其他函数一样使用Hooks！
- en: Solving common problems with Hooks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决钩子的常见问题
- en: As we found out, implementing Hooks with the official API also has its own trade-offs
    and limitations. We are now going to learn how to overcome these common problems,
    which stem from the limitations of React Hooks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们发现的那样，使用官方API实现Hooks也有其自身的权衡和限制。我们现在将学习如何克服这些常见问题，这些问题源于React Hooks的限制。
- en: 'We will take a look at solutions that can be used to overcome these two problems:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看可以用来克服这两个问题的解决方案：
- en: Solving conditional Hooks
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决条件钩子
- en: Solving Hooks in loops
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中解决钩子
- en: Solving conditional Hooks
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决条件钩子
- en: So, how do we implement conditional Hooks? Instead of making the Hook conditional,
    we can always define the Hook and use it whenever we need it. If this is not an
    option, we need to split up our components, which is usually better anyway!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何实现条件Hooks呢？与其使Hook有条件，不如始终定义Hook并在需要时使用它。如果这不是一个选择，我们需要拆分我们的组件，这通常也更好！
- en: Always defining the Hook
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终定义Hook
- en: 'For simple cases, such as the first and last name example that we had previously,
    we can just always keep the Hook defined, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的情况，比如我们之前提到的名字示例，我们可以始终保持Hook的定义，如下：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Always defining the Hook is usually a good solution for simple cases.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 始终定义Hook通常是一个简单的解决方案。
- en: Splitting up components
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分组件
- en: Another way to solve conditional Hooks is to split up one component into multiple
    components and then conditionally render the components. For example, let's say
    we want to fetch user information from a database after the user logs in.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 解决条件Hooks的另一种方法是将一个组件拆分为多个组件，然后有条件地渲染这些组件。例如，假设我们想在用户登录后从数据库中获取用户信息。
- en: 'We cannot do the following, as using an `if` conditional could change the order
    of the Hooks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能这样做，因为使用`if`条件可能会改变Hook的顺序：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead, we have to create a separate component for when the user is logged
    in, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须为用户登录时创建一个单独的组件，如下所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using two separate components for the non-logged in and logged in state makes
    sense anyway, because we want to stick to the principle of having one functionality
    per component. So, usually, not being able to have conditional Hooks is not much
    of a limitation if we stick to best practices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为非登录和登录状态使用两个单独的组件总是有意义的，因为我们希望坚持一个组件一个功能的原则。因此，通常情况下，如果我们坚持最佳实践，不能使用条件Hooks并不是什么限制。
- en: Solving Hooks in loops
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决循环中的Hooks
- en: As for Hooks in loops, we can either use a single State Hook containing an array,
    or we can split up our components. For example, let's say we want to display all
    the users that are online.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 至于循环中的Hooks，我们可以使用包含数组的单个State Hook，或者我们可以拆分我们的组件。例如，假设我们想显示所有在线用户。
- en: Using an array
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组
- en: 'We could simply use an array that contains all `users`, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用包含所有`users`的数组，如下所示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, this might not always make sense. For example, we might not want to
    update the `user` state through the `OnlineUsers` component because we would have
    to select the correct `user` state from the array, and then modify the array.
    This might work, but it is quite tedious.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能并不总是有意义。例如，我们可能不希望通过`OnlineUsers`组件来更新`user`状态，因为我们需要从数组中选择正确的`user`状态，然后修改数组。这可能有效，但相当繁琐。
- en: Splitting up components
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分组件
- en: 'A better solution would be to use the Hook in the `UserInfo` component instead.
    That way, we can keep the state for each user up to date, without having to deal
    with array logic:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是在`UserInfo`组件中使用Hook。这样，我们可以保持每个用户的状态更新，而不必处理数组逻辑：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, using one component for each functionality keeps our code simple
    and concise, and also avoids the limitations of React Hooks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，为每个功能使用一个组件可以使我们的代码简单而简洁，并且避免了React Hooks的限制。
- en: Solving problems with conditional Hooks
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决条件Hooks的问题
- en: Now that we have learned about the different alternatives to conditional Hooks,
    we are going to solve the problem that we had in our small example project earlier. The
    simplest solution to this problem would be to always define the Hook, instead
    of conditionally defining it. In a simple project like this one, always defining
    the Hook makes the most sense.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了条件Hooks的不同替代方案，我们将解决之前在我们的小示例项目中遇到的问题。这个问题的最简单解决方案是总是定义Hook，而不是有条件地定义它。在这样一个简单的项目中，总是定义Hook是最合理的。
- en: 'Edit `src/App.js` and remove the following conditional Hook:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`src/App.js`并删除以下条件Hook：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace it with a normal Hook, such as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个普通的Hook替换它，比如以下内容：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, our example works fine! In more complex cases, it might not be feasible
    to always define the Hook. In that case, we would need to create a new component,
    define the Hook there, and then conditionally render the component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的示例运行良好！在更复杂的情况下，总是定义Hook可能不可行。在这种情况下，我们需要创建一个新组件，在那里定义Hook，然后有条件地渲染组件。
- en: Example code
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The example code for the simple solution to the conditional Hooks problem can
    be found in the `Chapter02/chapter2_3` folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 简单解决条件Hooks问题的示例代码可以在`Chapter02/chapter2_3`文件夹中找到。
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, and then visit `http://localhost:3000` in your browser
    (if it did not open automatically).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm install`来安装所有依赖项，然后运行`npm start`来启动应用程序，然后在浏览器中访问`http://localhost:3000`（如果没有自动打开）。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started out by reimplementing the `useState` function, by
    making use of global state and closures. We then learned that in order to implement
    multiple Hooks, we need to use a state array instead. By using a state array,
    however, we were forced to keep the order of Hooks consistent across function
    calls. This limitation made conditional Hooks and Hooks in loops impossible. We
    then learned about possible alternatives to the Hook API, their trade-offs, and
    why the final API was chosen. Finally, we learned how to solve the common problems
    that stem from the limitations of Hooks. We now have a solid understanding of
    the inner workings and limitations of Hooks. Furthermore, we learned about the
    State Hook in depth.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先通过使用全局状态和闭包重新实现了`useState`函数。然后我们了解到，为了实现多个Hooks，我们需要使用状态数组。然而，通过使用状态数组，我们被迫保持Hooks在函数调用中的顺序一致。这种限制使得条件Hooks和循环中的Hooks变得不可能。然后我们了解了Hook
    API的可能替代方案，它们的权衡以及为什么选择了最终的API。最后，我们学会了如何解决由Hooks限制引起的常见问题。我们现在对Hooks的内部工作原理和限制有了扎实的理解。此外，我们深入了解了State
    Hook。
- en: In the next chapter, we are going to create a blog application using the State
    Hook, and learn how to combine multiple Hooks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用State Hook创建一个博客应用程序，并学习如何结合多个Hooks。
- en: Questions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下我们在本章学到的内容，尝试回答以下问题：
- en: What problems did we run into while developing our own reimplementation of the
    `useState` Hook? How did we solve these problems?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发我们自己的`useState` Hook的重新实现时，我们遇到了什么问题？我们是如何解决这些问题的？
- en: Why are conditional Hooks not possible in the React implementation of Hooks?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在React的Hooks实现中条件Hooks不可能？
- en: What are Hooks, and what do they deal with?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hooks是什么，它们处理什么？
- en: What do we need to watch out for when using Hooks?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Hooks时，我们需要注意什么？
- en: What are the common problems of alternative API ideas for Hooks?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替代API想法的常见问题是什么？
- en: How do we implement conditional Hooks?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现条件Hooks？
- en: How do we implement Hooks in loops?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在循环中实现Hooks？
- en: Further reading
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in finding out more about the concepts that we have learned
    in this chapter, take a look at the following reading material:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章学习的概念想了解更多，请参考以下阅读材料：
- en: More information on flaws of alternative Hook APIs: [https://overreacted.io/why-do-hooks-rely-on-call-order/](https://overreacted.io/why-do-hooks-rely-on-call-order/)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关替代Hook API缺陷的更多信息：[https://overreacted.io/why-do-hooks-rely-on-call-order/](https://overreacted.io/why-do-hooks-rely-on-call-order/)
- en: Official comment on alternative Hook APIs: [https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方对替代Hook API的评论：[https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)
- en: Official documentation on why conditional Hooks do not work: [https://reactjs.org/docs/hooks-rules.html#explanation](https://reactjs.org/docs/hooks-rules.html#explanation)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关条件Hooks不起作用的官方文档：[https://reactjs.org/docs/hooks-rules.html#explanation](https://reactjs.org/docs/hooks-rules.html#explanation)
