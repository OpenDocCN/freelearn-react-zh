["```jsx\nnpm install -g typescript\n```", "```jsx\nfunction calculateTotalPrice(product, quantity, discount) {\n  var priceWithoutDiscount = product.price * quantity;\n  var discountAmount = priceWithoutDiscount * discount;\n  return priceWithoutDiscount - discountAmount;\n}\n```", "```jsx\ninterface IProduct {\n name: string;\n unitPrice: number;\n}\n\nfunction calculateTotalPrice(product: IProduct, quantity: number, discount: number): number {\n  var priceWithoutDiscount: number = product.price * quantity;\n  var discountAmount: number = priceWithoutDiscount * discount;\n  return priceWithoutDiscount - discountAmount;\n}\n```", "```jsx\nvar threeSquared: number = 3 ** 2;\nconsole.log(threeSquared);\n```", "```jsx\ntsc future\n```", "```jsx\nvar threeSquared = Math.pow(3, 2);\nconsole.log(threeSquared);\n```", "```jsx\nlet unitPrice: number;\n```", "```jsx\nvar unitPrice;\n```", "```jsx\nunitPrice = \"Table\";\n```", "```jsx\nfunction getTotal(unitPrice: number, quantity: number, discount: number): number {\n  const priceWithoutDiscount = unitPrice * quantity;\n  const discountAmount = priceWithoutDiscount * discount;\n  return priceWithoutDiscount - discountAmount;\n}\n```", "```jsx\nlet total: string = getTotal(500, \"one\", 0.1);\n```", "```jsx\nlet flag = false;\n```", "```jsx\nlet flag;\n```", "```jsx\nfunction logText(text: string): void {\n  console.log(text);\n}\n```", "```jsx\nfunction foreverTask(taskName: string): never {\n  while (true) {\n    console.log(`Doing ${taskName} over and over again ...`);\n  }\n}\n```", "```jsx`) and can include a JavaScript expression in curly braces prefixed with a dollar sign (`${expression}`). Template literals are great when we need to merge static text with variables.\n\n2.  Let's change the `foreverTask` function to break out of the loop:\n\n```", "```jsx\n\nThe TypeScript compiler quite rightly complains:\n\n![](assets/5d906286-d584-45cd-9574-abe194697c9f.png)\n\n3.  Let's now remove the `break` statement and the `never` type annotation. If we hover over the `foreverTask` function name with our mouse, we see that TypeScript has inferred the type to be `void`, which is not what we want in this example:\n\n![](assets/fad95219-2e7b-4f52-868c-f8c7d4e0f348.png)\n\nThe `never` type is useful in places where the code never returns. However, we will probably need to explicitly define the `never` type annotation because the TypeScript compiler isn't smart enough yet to infer that.\n\n# Enumerations\n\nEnumerations allow us to declare a meaningful set of friendly names that a variable can be set to. We use the `enum` keyword, followed by the name we want to give to it, followed by the possible values in curly braces.\n\nHere's an example:\n\n1.  Let's declare an `enum` for order statuses in the TypeScript playground:\n\n```", "```jsx\n\n2.  If we look at the transpiled JavaScript, we see that it looks very different:\n\n```", "```jsx\n\nThis is because enumerations don't exist in JavaScript, so the TypeScript compiler is transpiling the code into something that does exist.\n\n3.  Let's declare a `status` variable, setting the value to the `shipped` status:\n\n```", "```jsx\n\nNotice how we get nice IntelliSense when typing the value:\n\n![](assets/c0622af4-14b0-458e-9000-e13bab5ece8c.png)\n\n4.  By default, the numerical values start from `0` and increment. However, the starting value can be explicitly declared in the `enum`, as in the following example, where we set `Paid` to `1`:\n\n```", "```jsx\n\n5.  Let's set our `status` variable to the shipped status and log this to the console:\n\n```", "```jsx\n\nIf we run the program, we should see 2 output in the console:\n\n![](assets/769c4a7b-e932-4c2d-aa61-9c212d990806.png)\n\n6.  In addition, all the values can be explicitly declared, as in the following example:\n\n```", "```jsx\n\nEnumerations are great for data such as a status that is stored as a specific set of integers but actually has some business meaning. They make our code more readable and less prone to error.\n\n# Objects\n\nThe object type is shared with JavaScript and represents a non-primitive type. Objects can contain typed properties to hold bits of information.\n\nLet's work through an example:\n\n1.  Let's enter the following code into the TypeScript playground, which creates an object with several properties of information:\n\n```", "```jsx\n\nIf we hover over `name`, `turnover`, and `active`, we'll see that TypeScript has smartly inferred the types to be `string`, `number`, and `boolean` respectively.\n\n2.  If we hover over the `customer` variable name, we see something interesting:\n\n![](assets/c6e0e7db-5c1c-49ac-896f-f39a28d79730.png)\n\n3.  Rather than the type being `object`, it is a specific type with `name`, `turnover`, and `active` properties. On the next line, let's set the `turnover` property to some other value:\n\n```", "```jsx\n\nAs we type the turnover property, IntelliSense provides the properties that are available on the object:\n\n![](assets/3bce2651-60e6-4992-9238-86fe107cf2f5.png)\n\nWe used `const` to declare the `customer` variable and then was able to change one of its property values later in the program. Shouldn't this have thrown an error? Well, the customer variable reference hasn't changed \u2014 just some properties within it. So, this is fine with the TypeScript compiler.\n\n4.  This line of code is perfectly fine, so we don't get any complaints from the compiler. If we set the `turnover` to a value that has an incorrect type, we'll be warned as we would expect:\n\n![](assets/1f089aaa-2e42-4ec7-b030-d16f55f1c4b7.png)\n\n5.  Now let's set a property on `customer` that doesn't exist yet:\n\n```", "```jsx\n\nWe'll see that TypeScript complains:\n\n![](assets/d006bad6-416a-493b-981d-871147cb7938.png)\n\nThis makes sense if we think about it. We've declared `customer` with `name`, `turnover`, and `active` properties, so setting a `profit` property should cause an error. If we wanted a `profit` property, we should have declared it in the original declaration.\n\nIn summary, the `object` type is flexible because we get to define any properties we require, but TypeScript will narrow down the type to prevent us incorrectly typing a property name.\n\n# Arrays\n\nArrays are structures that TypeScript inherits from JavaScript. We add type annotations to arrays as usual, but with square brackets at the end to denote that this is an array type.\n\nLet's take a look at an example:\n\n1.  Let's declare the following array of numbers in the TypeScript playground:\n\n```", "```jsx\n\nHere, we have initialized the array as empty.\n\n2.  We can add an item to the array by using the array's `push` function. Let's add the number `1` to our array:\n\n```", "```jsx\n\nWe used `const` to declare the `numbers` variable and was able to change its array elements later in the program. The array reference hasn't changed \u2013 just the elements within it. So, this is fine with the TypeScript compiler.\n\n3.  If we add an element with an incorrect type, the TypeScript compiler will complain, as we would expect:\n\n![](assets/e45056fd-2fe2-4cfe-8524-f39b2ae21fdd.png)\n\n4.  We can use type inference to save a few keystrokes if we declare an array with some initial values. As an example, if we type in the following declaration and hover over the `numbers` variable, we'll see the type has been inferred as `number[]`.\n\n```", "```jsx\n\n5.  We can access an element in an array by using the element number in square brackets. Element numbers start at `0`.\n\nLet's take an example:\n\n1.  Let's log out the number of elements under the numbers variable declaration, as follows:\n\n```", "```jsx\n\n2.  Let's now click the Run option on the right-hand side of the TypeScript playground to run our program. A new browser tab should open with a blank page. If we press *F12* to open the Developer tools and go to the console section, we'll see 1, 3, and 5 output to the console.\n\n3.  There are several ways to iterate through elements in an array. One option is to use a `for` loop, as follows:\n\n```", "```jsx\n\nIf we run the program, we'll see 1, 3, and 5 output to the console again.\n\n4.  Arrays also have a useful function for iterating through their elements, called `forEach`. We can use this function as follows:\n\n```", "```jsx\n\n5.  `forEach` calls a nested function for each array element, passing in the array element. If we hover over the `num` variable, we'll see it has been correctly inferred as a `number`. We could have put a type annotation here, but we have saved ourselves a few keystrokes:\n\n![](assets/c63c876d-8896-4227-867d-f292fd967726.png)\n\nArrays are one of the most common types we'll use to structure our data. In the preceding examples, we've only used an array with elements having a number type, but any type can be used for elements, including objects, which in turn have their own properties.\n\n# Creating interfaces, types aliases, and classes\n\nIn the *Understanding basic types* section, we introduced ourselves to objects, which are types that can have their own properties. Interfaces, type aliases, and classes are ways that we can define an object structure before we start using it.\n\nFollowing here is the `customer` object we worked with, where we declared the `customer` variable with an initial object value:\n\n```", "```jsx\n\n1.  Let's try to declare the customer variable and set its value on a subsequent line:\n\n```", "```jsx\n\n2.  So far, so good. However, let's see what happens when we try to change the customers `turnover` value:\n\n```", "```jsx\n\n3.  The lack of IntelliSense when we type `turnover` isn't what we are used to. When we've finished typing the line, we get a compiler error:\n\n![](assets/7e69d3b3-6dbf-4e19-874b-146b8a5d60e8.png)\n\nThe TypeScript compiler doesn't know about the properties in the `customer` object and so thinks there's a problem.\n\nSo, we need another way of defining an object structure with the ability to set property values later in the program. That's where interfaces, type aliases, and classes come in; they let us define the structure of an object by letting us define our own types.\n\n# Interfaces\n\nAn interface is a contract that defines a type with a collection of property and method definitions without any implementation. Interfaces don't exist in JavaScript, so they are purely used by the TypeScript compiler to enforce the contract by type checking.\n\nWe create an interface with the `interface` keyword, followed by its name, followed by the bits that make up the `interface` in curly braces:\n\n```", "```jsx\n\n# Properties\n\nProperties are one of the elements that can be part of an interface. Properties can hold values associated with an object. So, when we define a property in an interface, we are saying that objects that implement the interface must have the property we have defined.\n\nLet's start to play with an interface in the TypeScript playground:\n\n1.  Enter the following interface:\n\n```", "```jsx\n\n2.  The preceding example creates a `Product` interface with `name` and `unitPrice` properties. Let's go on to use this interface by using it as the type for a `table` variable:\n\n```", "```jsx\n\n3.  Let's try to set a property that doesn't exist in the interface:\n\n```", "```jsx\n\nAs expected, we get a type error:\n\n![](assets/21c3b0c0-bab7-46c6-b4dd-157ad1354b35.png)\n\n4.  Properties on an interface can reference another interface because an interface is just a type. The following example shows an `OrderDetail` interface making use of a `Product` interface:\n\n```", "```jsx\n\nThis gives us the flexibility to create complex object structures, which is critical when writing large, complex apps.\n\n# Method signatures\n\nInterfaces can contain method signatures as well. These won't contain the implementation of the method; they define the contracts for when interfaces are used in an implementation.\n\nLet's look at an example:\n\n1.  Let's add a method to the `OrderDetail` interface we just created. Our method is called `getTotal` and it has a `discount` parameter of type `number` and returns a `number`:\n\n```", "```jsx\n\nNotice that the `getTotal` method on the interface doesn't specify anything about how the total is calculated \u2013 it just specifies the method signature that should be used.\n\n2.  Having adjusted our `OrderDetail` interface, our `tableOrder` object, which implemented this interface, will now be giving a compilation error. So, let's resolve the error by implementing `getTotal`:\n\n```", "```jsx\n\nNotice that the implemented method has the same signature as in the `OrderDetail` interface.\n\nThe method implementation uses the `this` keyword to get access to properties on the object. If we simply referenced `product.unitPrice` and `quantity` without `this`, we would get a compilation error, because TypeScript would assume these variables are local within the method.\n\n3.  Let's tweak the method signature to discover what we can and can't do. We'll start by changing the parameter name:\n\n```", "```jsx\n\n4.  We'll see that we don't get a compilation error. Let's change the method name now:\n\n```", "```jsx\n\n5.  This does cause an error because a `total` method doesn't exist on the `OrderDetail` interface:\n\n![](assets/d383f245-e341-45d1-b6bb-33d726f27e64.png)\n\n6.  We could try changing the return type:\n\n```", "```jsx\n\nThis actually doesn't produce a compilation error in the TypeScript playground, but it should do!\n\n7.  So, let's use Visual Studio Code for this example. After we've opened Visual Studio Code in a folder of our choice, let's create a file called `interfaces.ts` and paste in the interface definitions for the `Product` and `OrderDetail` interfaces, along with the `table` variable declaration.\n8.  We can then enter the preceding implementation of the `OrderDetail` interface. As expected, we get a compilation error:\n\n![](assets/0b00ed1a-ea34-4688-b4c7-30386fb6a7d5.png)\n\n9.  Changing the parameter type also results in a compilation error:\n\n![](assets/290762cb-1585-4daa-aca8-46972adbec6b.png)\n\nThe errors provided by TypeScript are fantastic\u2014they are very specific about where the problem is, allowing us to quickly correct our mistakes.\n\n10.  So, when implementing a method from an interface, the parameter names aren't important, but the other parts of the signature are. In fact, we don't even need to declare the parameter names in the interface:\n\n```", "```jsx\n\nHowever, omitting the parameter names arguably makes the interface harder to understand\u2014how do we know exactly what the parameter is for?\n\n# Optional properties and parameters\n\nWe might want to make a property optional because not every situation where the interface is implemented requires it. Let's take the following steps in our `OrderDetail` interface:\n\n1.  Let's create an optional property for the date it was added. We specify an optional value by putting a `?` at the end of the property name but before the type annotation:\n\n```", "```jsx\n\nWe'll see that our implementation of this interface, `tableOrder`, isn't broken. We can choose to add `dateAdded` to `tableOrder` but it isn't required.\n\n2.  We might also want to make a method parameter optional. We do this in a similar way by putting a `?` after the parameter name. In our example, let's make `discount` optional in the `OrderDetail` interface:\n\n```", "```jsx\n\n3.  We can change the method implementation signature as well:\n\n```", "```jsx\n\nWe've also dealt with the case when a discount isn't passed into the method by using `(discount || 0)` in the `discountAmount` variable assignment.\n\n`x || y` is shorthand for *if x is* truthy *then use x, otherwise, use y*. The following values are falsy values: `false`, `0`, `\"\"`, `null`, `undefined`, and `NaN`. All other values are truthy.\n\n4.  With our optional parameter in place, we can call `getTotal` without passing a value for the discount parameter:\n\n```", "```jsx\n\nThe preceding line doesn't upset the TypeScript compiler.\n\n# Readonly properties\n\nWe can stop a property from being changed after it has initially been set by using the `readonly` keyword before the property name.\n\n1.  Let's give this a try on our `Product` interface by making the `name` property `readonly`:\n\n```", "```jsx\n\n2.  Let's also make sure we have an instance of the `Product` interface in place:\n\n```", "```jsx\n\n3.  Let's change the `name` property `table` now on the next line:\n\n```", "```jsx\n\nAs expected, we get a compilation error:\n\n![](assets/ef683144-77d7-4cac-b646-244090f50f9e.png)\n\n`readonly` properties are a simple way of freezing their values after being initially set. A common use case is when you want to code in a functional way and prevent unexpected mutations to a property.\n\n# Extending interfaces\n\nInterfaces can *extend* other interfaces so that they inherit all the properties and methods from its parent. We do this using the `extends` keyword after the new interface name and before the interface name that is being extended.\n\nLet's look at the following example:\n\n1.  We create a new interface, taking `Product` as a base, and add information about discount codes:\n\n```", "```jsx\n\n2.  We can create an instance of the interface in the usual way, filling in properties from the base interface as well as the child interface:\n\n```", "```jsx\n\nInterfaces allow us to create complex but flexible structured types for our TypeScript program to use. They are a really important feature that we can use to create a robust, strongly-typed TypeScript program.\n\n# Type aliases\n\nIn simple terms, a type alias creates a new name for a type. To define a type alias, we use the `type` keyword, followed by the alias name, followed by the type that we want to alias.\n\nWe'll explore this with the following example:\n\n1.  Let's create a type alias for the `getTotal` method in the `OrderDetail` interface we have been working with. Let's try this in the TypeScript playground:\n\n```", "```jsx\n\nNothing changes with objects that implement this interface \u2013 it is purely a way we can structure our code. It arguably makes the code a little more readable.\n\n2.  Type aliases can also define the shape of an object. We could use a type alias for our `Product` and `OrderDetail` types that we previously defined with an interface:\n\n```", "```jsx\n\n3.  We use these types in exactly the same way as we used our interface-based types:\n\n```", "```jsx\n\nSo, type aliases seem very similar to interfaces. What is the difference between a type alias and an interface? The main difference is that type aliases can't be extended or implemented from like you can with interfaces. So, for a simple structure that doesn't require inheritance, should we use an interface or should we use a type alias? There isn't strong reasoning to prefer either approach. However, we should be consistent with whichever approach we choose to improve the readability of our code.\n\n# Classes\n\nClasses feature in many programming languages, including JavaScript. They let us shape objects with type annotations in a similar way to interfaces and type aliases. However, classes have many more features than interfaces and type aliases, which we'll explore in the following sections.\n\n# Basic classes\n\nClasses have lots of features. So, in this section we'll look at the basic features of a class. We use the `class` keyword followed by the class name, followed by the definition of the class.\n\nLet's look at this in more depth with the following example:\n\n1.  We could use a class to define the `Product` type we previously defined as an interface and as a type alias:\n\n```", "```jsx\n\n2.  We create an instance of our `Product` class by using the `new` keyword followed by the class name and parentheses. We then go on to interact with the class, setting property values or calling methods:\n\n```", "```jsx\n\nNotice that when we use this approach we don't need a type annotation for the table variable because the type can be inferred.\n\nClasses have many more features than type aliases and interfaces though. One of these features is the ability to define the implementation of methods in a class.\n\nLet's explore this with an example:\n\n1.  Let's change the `OrderDetail` type we have been working within previous sections to a class. We can define the implementation of the `getTotal` method in this class:\n\n```", "```jsx\n\n2.  We can create an instance of `OrderDetail`, specifying a `product` and `quantity`, and then calling the `getTotal` method with a `discount` to get the total price:\n\n```", "```jsx\n\nIf we run this and look at the console, we should see an output of `900`.\n\n# Implementing interfaces\n\nWe can use classes and interfaces together by defining the contract in an interface and then implementing the class as per the interface. We specify that a class is implementing a particular interface using the `implements` keyword.\n\nAs an example, we can define an interface for the order detail and then a class that implements this interface:\n\n```", "```jsx\n\nIn the preceding example, we've prefixed the interface with `I` so that readers of the code can quickly see when we are referencing interfaces.\n\nWhy would we use this approach? It seems like more code than we need to write. So, what's the benefit? This approach allows us to have multiple implementations of an interface, which can be useful in certain situations.\n\n# Constructors\n\nConstructors are functions that perform the initialization of new instances of a class. In order to implement a constructor, we implement a function called `constructor`. It's common to set property values in the constructor to simplify consumption of the class.\n\nLet's look at the following example:\n\n1.  Let's create a constructor in the `OrderDetail` class that allows us to set the `product` and `quantity`:\n\n```", "```jsx\n\n2.  If we create an instance of the class, we are forced to pass in the `product` and `quantity`:\n\n```", "```jsx\n\n3.  This is nice because we've reduced three lines of code to one line. However, we can make our class even nicer to work with by making the default `quantity` parameter `1` if nothing is passed in:\n\n```", "```jsx\n\n4.  We now don't have to pass in a `quantity` if it is `1`:\n\n```", "```jsx\n\n5.  We can save ourselves a few keystrokes and let the TypeScript compiler implement the `product` and `quantity` properties by using the `public` keyword before the parameters in the constructor:\n\n```", "```jsx\n\n# Extending classes\n\nClasses can extend other classes. This is the same concept as interfaces extending other interfaces, which we covered in the *Extending interfaces* section. This is a way for class properties and methods to be shared with child classes.\n\nAs with interfaces, we use the `extends` keyword followed by the class we are extending. Let's look at an example:\n\n1.  Let's create a `ProductWithDiscountCodes` from our `Product` class:\n\n```", "```jsx\n\n2.  We can then consume the `ProductWithDiscountCodes` class as follows, leveraging properties from the base class as well as the child class:\n\n```", "```jsx\n\n3.  If the parent class has a constructor, then the child class will need to pass the constructor parameters using a function called `super`:\n\n```", "```jsx\n\n# Abstract classes\n\nAbstract classes are a special type of class that can only be inherited from and not instantiated. They are declared with the `abstract` keyword, as in the following example:\n\n1.  We can define a base `Product` class as follows:\n\n```", "```jsx\n\n2.  If we try to create an instance of this, the compiler will complain, as we would expect:\n\n![](assets/d5892d27-9ae6-48f1-bced-7dfac45ab000.png)\n\n3.  We can create a more specific usable class for food products by extending `Product`:\n\n```", "```jsx\n\n4.  Here, we are adding a `bestBefore` date in our `Food` class. We can then create an instance of `Food`, passing in the `bestBefore` date:\n\n```", "```jsx\n\nAbstract classes can have `abstract` methods that child classes must implement. Abstract methods are declared with the `abstract` keyword in front of them, as in the following example:\n\n1.  Let's add an `abstract` method to our base `Product` class:\n\n```", "```jsx\n\n2.  After we add the `abstract` method, the compiler immediately complains about our `Food` class because it doesn't implement the `delete` method:\n\n![](assets/a9d5b1d7-7508-4386-8418-38d4725ebeb0.png)\n\n3.  So, let's fix this and implement the `delete` method:\n\n```", "```jsx\n\n# Access modifiers\n\nSo far, all our class properties and methods have automatically had the `public` access modifier. This means they are available to interact with class instances and child classes. We can explicitly set the `public` keyword on our class properties and methods immediately before the property or method name:\n\n```", "```jsx\n\nAs you might have guessed, there is another access modifier, called `private`**,** which allows the member to only be available to interact with inside the class and not on class instances or child classes.\n\nLet's look at an example:\n\n1.  Let's add a `delete` method in our `OrderDetail` class, which sets a private `deleted` property:\n\n```", "```jsx\n\n2.  Let's create an instance of `OrderDetail` and try to access the `deleted` property:\n\n```", "```jsx\n\nAs expected, the compiler complains:\n\n![](assets/1d66fcc2-2ce4-422a-8407-cc3ad618b557.png)\n\nThere is a third access modifier, `protected`, which allows the member to be available to interact with inside the class and on child classes, but not on class instances.\n\n# Property setters and getters\n\nOur classes so far have had simple property declarations. However, for more complex scenarios, we can implement a property with a `getter` and a `setter`. When implementing `getters` and `setters`, generally, you'll need a private property to hold the property value:\n\n*   `getter` is a function with the property name and the `get` keyword at the beginning and no parameters. Generally, this will return the value of the associated private property.\n*   `setter` is a function with the same name with the `set` keyword at the beginning and a single parameter for the value. This will set the value of the associated private property.\n*   The `private` property is commonly named the same as the `getter` and `setter` with an underscore in front.\n\nLet's take a look at an example:\n\n1.  Let's create `getters` and `setters` for the `unitPrice` property in our `Product` class. The `setter` ensures the value is not less than `0`. The `getter` ensures `null` or `undefined` is never returned:\n\n```", "```jsx\n\n2.  Let's consume the `Product` class and try this out:\n\n```", "```jsx\n\nIf we run this, we should see two 0's in the console.\n\n# Static\n\nStatic properties and methods are held in the class itself and not in class instances. They can be declared using the `static` keyword before the property or method name.\n\nLet's look at the following example:\n\n1.  Let's make the `getTotal` method static on the `OrderDetail` class we have been using:\n\n```", "```jsx\n\n2.  We get compilation errors where we try to reference the properties on the class. This is because the `static` method isn't in the class instance and therefore can't access these properties:\n\n![](assets/bdc9105e-9736-4573-8891-8d40a6c467e4.png)\n\n3.  To make the `static` method work, we can move its dependencies on the class instance to parameters in the function:\n\n```", "```jsx\n\n4.  We can now call the static method on the class type itself, passing in all the parameter values:\n\n```", "```jsx\n\nIf we run the preceding program, we should get an output of `900` in the console.\n\n# Structuring code into modules\n\nBy default, TypeScript generated JavaScript code that executes in what is called the global scope. This means code from one file is automatically available in another file. This in turn means that the functions we implement can overwrite functions in other files if the names are the same, which can cause our applications to break.\n\nLet's look at an example in Visual Studio Code:\n\n1.  Let's create a file called `product.ts` and enter the following interface for a product:\n\n```", "```jsx\n\n2.  Let's create another file, called `orderDetail.ts`, with the following content:\n\n```", "```jsx\n\nThe compiler doesn't give us any complaints. In particular, the reference to the `Product` interface in the `OrderDetail` class is able to be resolved, even though it's in a different file. This is because both `Product` and `OrderDetail` are in the global scope.\n\nOperating in the global scope is problematic because item names can conflict across different files, and as our code base grows, this is harder to avoid. Modules resolve this issue and help us write well organized and reusable code.\n\n# Module formats\n\nModules feature in JavaScript as part of ES6, which is great. However, lots of code exists in other popular module formats that came before this standardization. TypeScript allows us to write our code using ES6 modules, which can then transpile into another module format if specified.\n\nHere is a brief description of the different module formats that TypeScript can transpile to:\n\n*   **Asynchronous Module Definition** (**AMD**): This is commonly used in code targeted for the browser and uses a `define` function to define modules.\n*   **CommonJS**: This format is used in Node.js programs. It uses `module.exports` to define modules and `require` to define dependencies.\n*   **Universal Module Definition** (**UMD**): This can be used in both browser apps and Node.js programs.\n*   **ES6**: This is the native JavaScript module format and uses the `export` keyword to define modules and `import` to define dependencies.\n\nIn the following sections (and, in fact, this whole book), we'll write our code using ES6 modules.\n\n# Exporting\n\nExporting code from a module allows it to be used by other modules. In order to export from a module, we use the `export` keyword. We can specify that an item is exported using `export` directly before its definition. Exports can be applied to interfaces, type aliases, classes, functions, constants, and so on.\n\nLet's start to adjust our example code from the previous section to operate in modules rather than the global scope:\n\n1.  Firstly, let's export the `Product` interface:\n\n```", "```jsx\n\n2.  After we make this change, the compiler will complain about the reference to the `Product` interface in the `OrderDetail` class:\n\n![](assets/9f796565-f7ba-49c9-8306-7fdf77d57e23.png)\n\nThis is because `Product` is no longer in the global scope but `OrderDetail` still is. We'll resolve this in the next section, but let's look at alternative ways we can export the `Product` interface first.\n\n3.  We can use an `export` statement beneath the item declarations. We use the `export` keyword followed by a comma-delimited list of item names to export in curly braces:\n\n```", "```jsx\n\n4.  With this approach, we can also rename exported items using the `as` keyword:\n\n```", "```jsx\n\n# Importing\n\nImporting allows us to import items from an exported module. We do this using an `import` statement that includes the item names to import in curly braces and the file path to get the items from (excluding the `ts` extension). We can only import items that are exported in the other module file.\n\n1.  Let's resolve the issue with our `OrderDetail` class by importing the `Product` interface:\n\n```", "```jsx\n\n2.  We can rename imported items using the `as` keyword in an `import` statement. We then reference the item in our code using the new name:\n\n```", "```jsx\n\n# Default exports\n\nWe can specify a single item that can be exported by default using the `default` keyword:\n\n```", "```jsx\n\nNotice that we don't need to name the interface. We can then import a default exported item using an `import` statement without the curly braces with a name of our choice:\n\n```", "```jsx\n\n# Configuring compilation\n\nWe need to compile our TypeScript code before it can be executed in a browser. We do this by running the TypeScript compiler, `tsc`, on the files we want to compile. TypeScript is very popular and is used in many different situations:\n\n*   It is often introduced into large existing JavaScript code bases\n*   It comes by default in an Angular project\n*   It is often used to add strong types to a React project\n*   It can even be used in Node.js projects\n\nAll these situations involve slightly different requirements for the TypeScript compiler. So, the compiler gives us lots of different options to hopefully meet the requirements of our particular situation.\n\n1.  Let's give this a try by opening Visual Studio Code in a new folder and creating a new file, called `orderDetail.ts`, with the following content:\n\n```", "```jsx\n\n2.  We can open a Terminal in Visual Studio Code by going to the View menu and choosing Terminal. Let's enter the following command in the Terminal:\n\n```", "```jsx\n\n3.  Hopefully, no errors should be output from the compiler and it should generate a file called `orderDetail.js`, containing the following transpiled JavaScript:\n\n```", "```jsx\n\nWe'll continue to use `orderDetail.ts` in the following sections as we explore how the compiler can be configured.\n\n# Common options\n\nAs mentioned earlier, there are lots of configuration options for the TypeScript compiler. All the configuration options can be found at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html). The following sections detail some of the more common options that are used.\n\n# --target\n\nThis determines the ECMAScript version the transpiled code will be generated in.\n\nThe default is `ES3`, which will ensure the code works in a wide range of browsers and their different versions. However, this compilation target will generate the most amount of code because the compiler will generate polyfill code for features that aren't supported in `ES3`.\n\nThe `ESNext` option is the other extreme, which compiles to the latest supported proposed ES features. This will generate the least amount of code, but will only work on browsers that have implemented the features we have used.\n\nAs an example, let's compile `orderDetail.ts` targeting `ES6` browsers. Enter the following in the terminal:\n\n```", "```jsx\n\nOur transpiled JavaScript will be very different from the last compilation and much closer to our source TypeScript because classes are supported in `es6`:\n\n```", "```jsx\n\n# --outDir\n\nBy default, the transpiled JavaScript files are created in the same directory as the TypeScript files. `--outDir` can be used to place these files in a different directory.\n\nLet's give this a try and output the transpiled `orderDetail.js` to a folder called `dist`. Let's enter the following in the terminal:\n\n```", "```jsx\n\nA `dist` folder will be created containing the generated `orderDetail.js` file.\n\n# --module\n\nThis specifies the module format that the generated JavaScript should use. The default is the **CommonJS** module format if ES3 or ES5 are targeted. `ES6` and `ESNext` are common options today when creating a new project.\n\n# --allowJS\n\nThis option tells the TypeScript compiler to process JavaScript files as well as TypeScript files. This is useful if we've written some of our code in JavaScript and used features that haven't been implemented yet in all browsers. In this situation, we can use the TypeScript compiler to transpile our JavaScript into something that will work with a wider range of browsers.\n\n# --watch\n\nThis option makes the TypeScript compiler run indefinitely. Whenever a source file is changed, the compiling process is triggered automatically to generate the new version. This is a useful option to switch on during our developments:\n\n1.  Let's give this a try by entering the following in a terminal:\n\n```", "```jsx\n\n2.  The compiler should run and, when completed, give the message `Watching for file changes`. Let's change the `getTotal` method in the `OrderDetail` class to handle situations when `discount` is undefined:\n\n```", "```jsx\n\n3.  When we save `orderDetail.ts`, the compiler will say `File change detected. Starting incremental compilation...` and carry out the compilation.\n\nTo exit the watch mode, we can kill the terminal by clicking the bin icon in the Terminal.\n\n# --noImplicitAny\n\nThis forces us to explicitly specify the `any` type where we want to use it. This forces us to think about our use of `any` and whether we really need it.\n\nLet's explore this with an example:\n\n1.  Let's add a `doSomething` method to our `OrderDetail` class that has a parameter called `input` with no type annotation:\n\n```", "```jsx\n\n2.  Let's do a compilation with the `--noImplicitAny` flag in the Terminal:\n\n```", "```jsx\n\nThe compiler outputs the following error message because we haven't explicitly said what type the `input` parameter is:\n\n```", "```jsx\n\n3.  We can fix this by adding a type annotation with `any` or, better still, something more specific:\n\n```", "```jsx\n\nIf we do a compilation with `--noImplicitAny` again, the compiler is happy.\n\n# --noImplicitReturns\n\nThis ensures we return a value in all branches of a function if the return type isn't `void`.\n\nLet's see this in action with an example:\n\n1.  In our `OrderDetail` class, let's say we have the following implementation for our `getTotal` method:\n\n```", "```jsx\n\n2.  We've forgotten to implement the branch of code that deals with the case where there is no discount. If we compile the code without the `--noImplicitReturns` flag, it compiles fine:\n\n```", "```jsx\n\n3.  However, let's see what happens if we compile the code with the `--noImplicitReturns` flag:\n\n```", "```jsx\n\nWe get the following error, as expected:\n\n```", "```jsx\n\n# --sourceMap\n\nWhen this is set, `*.map` files are generated during the transpilation process. This will allow us to debug the TypeScript version of the program (rather than the transpiled JavaScript). So, this is generally switched on during development.\n\n# --moduleResolution\n\nThis tells the TypeScript compiler how to resolve modules. This can be set to `classic` or `node`. If we are using ES6 modules, this defaults to `classic`, which means the TypeScript compiler struggles to find third-party packages such as Axios. So, we can explicitly set this to `node` to tell the compiler to look for modules in `\"node_modules\"`.\n\n# tsconfig.json\n\nAs we have seen, there are lots of different switches that we can apply to the compilation process, and repeatedly specifying these on the command line is a little clunky. Luckily, we can specify these options in a file called `tsconfig.json`. The compiler options we have looked at in previous sections are defined in a `compilerOptions` field without the `\"--\"` prefix.\n\nLet's take a look at an example:\n\n1.  Let's create a `tsconfig.json` file with the following content:\n\n```", "```jsx\n\n2.  Let's run a compile without specifying the source file and any flags:\n\n```", "```jsx\n\nThe compilation will run fine, with the transpiled JavaScript being output to the `dist` folder along with a source map file.\n\n# Specifying files for compilation\n\nThere are several ways to tell the TypeScript compiler which files to process. The simplest method is to explicitly list the files in the `files` field:\n\n```", "```jsx\n\nHowever, that approach is difficult to maintain as our code base grows. A more maintainable approach is to define file patterns for what to include and exclude with the `include` and `exclude` fields.\n\nThe following example looks at the use of these fields:\n\n1.  Let's add the following `include` fields, which tell the compiler to compile TypeScript files found in the `src` folder and its subfolders:\n\n```", "```jsx\n\n2.  At the moment, our source files aren't in a folder called `src`, but let's run a compile anyway:\n\n```", "```jsx\n\n3.  As expected, we get `No inputs were found in the config file...` from the compiler.\n\nLet's create an `src` folder and move `orderDetail.ts` into this folder. If we do a compile again, it will successfully find the files and do a compilation.\n\nSo, we have lots of options for adapting the TypeScript compiler to our particular situation. Some options, such as `--noImplicitAny`, force us to write good TypeScript code. We can take the checks on our code to the next level by introducing linting into our project, which we'll look at in the next section.\n\n# TypeScript linting\n\nAs we have seen, the compiler does lots of useful checks against our TypeScript code to help us write error-free code. We can take this a step further and lint the code to help us make our code even more readable and maintainable. TSLint is a linter that is very popular in TypeScript projects, and we will explore it in this section.\n\nThe home page for TSLint is at [https://palantir.github.io/tslint/](https://palantir.github.io/tslint/).\n\nWe'll install TSLint in the next section.\n\n# Installing TSLint\n\nWe'll install TSLint in this section, along with a Visual Studio Code extension that will highlight linting problems right in the code:\n\n1.  Let's install TSLint globally via `npm`, as follows:\n\n```", "```jsx\n\n2.  Now, we can open Visual Studio Code and go to the extensions area (*Ctrl + Shift + X*) and type `tslint` in the search box at the top-left. The extension is called TSLint and was published by egamma:\n\n![](assets/6ff55d56-134d-4c7d-b580-ac11aea7f5a3.png)\n\n3.  We need to click the Install option to install the extension.\n4.  After it has been installed, we'll need to reload Visual Studio Code for the extension to become enabled.\n\nNow that this extension is installed, along with TSLint globally, linting errors will be highlighted right in our code, as we'll see in the following sections.\n\n# Configuring rules\n\nThe rules that `tslint` uses when checking our code are configurable in a file called `tslint.json`. In order to explore some of the rules, we first need a TypeScript file:\n\n1.  So, let's create a file called `orderDetail.ts` with the following content in Visual Studio Code:\n\n```", "```jsx\n\n2.  Let's now create a `tslint.json` file. We define the rules we want to implement in a `rules` field. Let's add the following rule:\n\n```", "```jsx\n\n3.  A full list of the rules can be found at: [https://palantir.github.io/tslint/rules/](https://palantir.github.io/tslint/rules/). The `member-access` rule forces us to explicitly declare the access modifier for classes. We haven't explicitly defined the property and method access modifiers in the `OrderDetail` class because they are `public` by default. So, with our linting rule in place, Visual Studio Code will highlight the lack of access modifiers to us:\n\n![](assets/630fab81-811a-428b-a180-b858f7caa663.png)\n\n4.  As we put a `public` access modifier in front of the properties and method, the warnings go away:\n\n```", "```jsx\n\nThe `member-access` rule forces us to write more code \u2013 how can this be a good thing? The rule is useful if you're reading the code and don't know TypeScript well enough to understand that class members without access modifiers are public. So, it's great if our team consists of developers who don't know TypeScript that well yet, but not necessarily for an experienced team of TypeScript developers.\n\nLots of the `tslint` rules are like `member-access` \u2013 in some teams, they will work well and in others, they don't really add value. This is why rules are configurable!\n\n# Built-in rules\n\n`tslint` has a handy collection of built-in rulesets that can be used. We can use these by specifying the ruleset name in the `extends` field. We can use multiple rulesets by putting all their names in the array:\n\n1.  Let's adopt the opinionated set of rules that `tslint` ships with, called `\"tslint:recommended\"`. So, in our `tslint.json` file, let's remove the `rules` field and add an `extends` field, as follows:\n\n```", "```jsx\n\nWe immediately get lint errors when `tslint.json` is saved. The error is complaining about the lack of an `I` prefix on our `Product` interface. The logic behind the rule is that, while reading code, if a type starts with an `I`, we immediately know that it is an interface.\n\n2.  Let's pretend that this rule isn't valuable to us. We can override this rule from `\"tslint:recommended\"` in the `\"rules\"` field. The rule is called `\"interface-name\"`. So, let's override this to `false`:\n\n```", "```jsx\n\nWhen `tslint.json` is saved, the linting errors immediately go away.\n\n# Excluding files\n\nWe can exclude files from the linting process. This is useful for excluding third-party code. We do this by specifying an array of files in an `exclude` field in the `linterOptions` field:\n\n```", "```jsx\n\nThe preceding configuration excludes third-party `node` packages from the linting process.\n\nNow that we've added TSLint to our tool belt, we are going to add another tool that will automatically format our code for us. This will help our code adhere to some of the code formattings TSLint rules.\n\n# Code formatting\n\nIn this section, we are going to install another extension in Visual Studio Code, called Prettier, which will automatically format our code. As well as putting a stop to all the ongoing debates over styles, it will help us adhere to some of the TSLint rules:\n\n1.  Let's open Visual Studio Code, go to the Extensions area, and type prettier in the search box. The extension is called Prettier - Code formatter and was published by Esben Petersen:\n\n![](assets/bcb3fc98-b4c0-4e54-ad03-d19831c3d52b.png)\n\n2.  We need to click the Install option to install the extension.\n3.  After it has been installed, we'll need to reload Visual Studio Code for the extension to become enabled.\n4.  The last step is to make sure the Format on Save option is ticked in User Settings. Press *Ctrl* +*,* (comma) to open the settings screen and type Format On Save in the search box to find the setting. If the setting isn't ticked, then tick it:\n\n![](assets/869f1ce0-1f9b-46d3-b2ed-cda84e18a00d.png)\n\nNow that this extension is installed, when we save our TypeScript code, it will automatically be formatted nicely for us.\n\n# Summary\n\nAt the start of this chapter, there was a section on why we would use TypeScript to build a frontend. We now have first-hand experience of TypeScript catching errors early and giving us productivity features such as IntelliSense. We learned that TypeScript is just an extension of JavaScript. So, we get to use all of the features in JavaScript plus additional stuff from TypeScript. One of these additional things is type annotations, which help the compiler spot errors and light up features such as code navigation in our code editor.\n\nWe haven't covered everything about types yet, but we have enough knowledge to build fairly complex TypeScript programs now. Classes, in particular, allow us to model complex real-world objects nicely. We learned about modules and how they keep us out of that dangerous global scope. Modules allow us to structure code nicely and make it reusable. We can even use these if we need to support IE, because of that magical TypeScript compiler.\n\nWe learned a fair bit about the TypeScript compiler and how it can work well in different use cases because it is very configurable. This is going to be important for when we start to use TypeScript with React later in the book.\n\n`TSLint` and `Prettier` were the icings on the cake. It's down to us and our team to debate and decide the TSLint rules we should go with. The benefit of both these tools is that they force consistency across our code base, which makes it more readable.\n\nNow that we understand the basics of TypeScript, we'll dive into the new features that have been added in TypeScript 3.\n\n# Questions\n\nHere are some questions to test what you have learned in this first chapter. The answers can be found in the appendix.\n\nGood luck!\n\n1.  What are the 5 primitive types?\n2.  What would the inferred type be for the `flag` variable be in the following code?\n\n```", "```jsx\n\n3.  What's the difference between an interface and a type alias?\n4.  What is wrong with the following code? How could this be resolved?\n\n```"]