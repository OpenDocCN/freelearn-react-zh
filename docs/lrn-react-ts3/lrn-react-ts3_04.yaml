- en: Routing with React Router
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router进行路由
- en: If our app has multiple pages, we need to manage the navigation between the
    different pages. React Router is a great library that helps us do just this!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序有多个页面，我们需要管理不同页面之间的导航。React Router是一个很棒的库，可以帮助我们做到这一点！
- en: 'In this chapter, we are going to build a web shop where we can purchase a few
    tools for React. Our simple shop will have multiple pages that we''ll manage using
    React Router. The shop will look like the following screenshot when we are finished:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个网上商店，我们可以在其中购买一些用于React的工具。我们的简单商店将有多个页面，我们将使用React Router来管理这些页面。当我们完成时，商店将如下截图所示：
- en: '![](assets/f7ddbc37-471d-4a5d-bec6-962275e687c3.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7ddbc37-471d-4a5d-bec6-962275e687c3.png)'
- en: 'In this chapter, we''ll learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Installing React Router with routing types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由类型安装React Router
- en: Declaring routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明路由
- en: Creating navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建导航
- en: Route parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由参数
- en: Handling not found routes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理未找到的路由
- en: Implementing page redirects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现页面重定向
- en: Query parameters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数
- en: Route prompts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由提示
- en: Nested routes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: Animated transitions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画过渡
- en: Lazy loading routes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟加载路由
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We''ll use the following technologies in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和** `npm`：TypeScript和React依赖于这些。我们可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装这些。如果已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写我们的React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要在Visual
    Studio Code中安装 TSLint（由egamma提供）和Prettier（由Estben Petersen提供）扩展。'
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter)上找到。
- en: Installing React Router with routing types
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由安装React Router
- en: '**React Router** and its Types are in `npm`, so we can install them from there.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Router**及其类型在`npm`中，因此我们可以从那里安装它们。'
- en: 'Before installing React Router, we need to create our React shop project. Let''s
    get ready to do that by choosing an empty folder of our choice and opening Visual
    Studio Code. To do this, follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装React Router之前，我们需要创建我们的React商店项目。让我们通过选择一个空文件夹并打开Visual Studio Code来做好准备。要做到这一点，请按照以下步骤进行：
- en: 'Let''s now open a Terminal and enter the following command to create a new
    React and TypeScript project:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开一个终端并输入以下命令来创建一个新的React和TypeScript项目：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json` is
    less that `16.7.0-alpha.0`, then we can install this version using the following
    command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的React版本至少需要是`16.7.0-alpha.0`。我们可以在`package.json`文件中检查这一点。如果`package.json`中的React版本小于`16.7.0-alpha.0`，那么我们可以使用以下命令安装此版本：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the project is created, let''s add TSLint as a development dependency
    to our project along with some rules that work well with React and Prettier:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，让我们将TSLint作为开发依赖项添加到我们的项目中，并添加一些与React和Prettier兼容的规则：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now add a `tslint.json` file containing some rules:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个包含一些规则的`tslint.json`文件：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s enter the following command to install React Router into our project:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们输入以下命令将React Router安装到我们的项目中：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s also install the TypeScript types for React Router and save them as
    a development dependency:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还安装React Router的TypeScript类型，并将它们保存为开发依赖项：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before going on to the next section, we''re going to remove some of the files `create-react-app`
    created that we don''t need:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，我们将删除一些我们不需要的`create-react-app`创建的文件：
- en: First, let's remove the `App` component. So, let's delete the `App.css`, `App.test.tsx`,
    and `App.tsx` files. Let's also remove the import reference `"./App"` in `index.tsx`**.**
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们删除`App`组件。因此，让我们删除`App.css`，`App.test.tsx`和`App.tsx`文件。让我们还在`index.tsx`中删除对`"./App"`的导入引用。
- en: Let's also remove the service worker by deleting the `serviceWorker.ts` file
    and removing the references to it in `index.tsx`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还通过删除`serviceWorker.ts`文件并在`index.tsx`中删除对它的引用来删除服务工作者。
- en: 'In `index.tsx`, let''s change the root component from `<App/>` to `<div/>`.
    Our `index.tsx` file should have the following content in it now:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.tsx`中，让我们将根组件从`<App/>`更改为`<div/>`。我们的`index.tsx`文件现在应该包含以下内容：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Declaring routes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明路由
- en: We declare the pages in our app using the `BrowserRouter` and `Route` components. `BrowserRouter` is
    the top-level component and this looks for `Route` components beneath it to determine
    all the different page paths.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BrowserRouter`和`Route`组件在应用程序中声明页面。`BrowserRouter`是顶层组件，它查找其下方的`Route`组件以确定所有不同的页面路径。
- en: 'We are going to declare some pages in our app using `BrowserRouter` and `Route`
    later in this section, but before that we need to create our first two pages. This
    first page is going to contain the list of our React tools that we are going to
    sell in our shop. We use the following steps to create our pages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节的后面使用`BrowserRouter`和`Route`声明一些页面，但在此之前，我们需要创建我们的前两个页面。这第一个页面将包含我们在商店中要出售的React工具列表。我们使用以下步骤来创建我们的页面：
- en: 'So, let''s start by creating the data for our list of tools by creating a `ProductsData.ts`filewith
    the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们首先通过创建一个`ProductsData.ts`文件并包含以下内容来为我们的工具列表创建数据：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create another file called `ProductsPage.tsx` containing the following
    to import React as well as our data:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`ProductsPage.tsx`的文件，其中包含以下内容来导入React以及我们的数据：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are going to reference the data in our component state, so let''s create
    an interface for this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在组件状态中引用数据，因此让我们为此创建一个接口：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s move on to create our class component called `ProductsPage`, initializing
    the state to an empty array:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建名为`ProductsPage`的类组件，将状态初始化为空数组：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now implement the `componentDidMount` life cycle method and set the
    data to the `products` array from `ProductData.ts`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现`componentDidMount`生命周期方法，并从`ProductData.ts`将数据设置为`products`数组：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Moving on to implementing the `render` method, let''s welcome our users and
    set out the products in a list:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续实现`render`方法，让我们欢迎我们的用户并在列表中列出产品：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have used the `map` function in the `products` array to iterate through the
    elements and produce a list item tag, `li`, for each product. We need to give
    each `li` a unique `key` attribute to help React manage any changes to the list
    items, which in our case is the `id` product.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`products`数组中使用了`map`函数来迭代元素并为每个产品生成一个列表项标签`li`。我们需要为每个`li`赋予一个唯一的`key`属性，以帮助React管理列表项的任何更改，而在我们的情况下是产品的`id`。
- en: 'We''ve referenced some CSS classes, so let''s add these to `index.css`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经引用了一些CSS类，因此让我们将它们添加到`index.css`中：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s implement our second page now, which is going to be an admin panel.
    So, let''s create a file called `AdminPage.tsx` with the following function component
    inside:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现我们的第二个页面，即管理面板。因此，让我们创建一个名为`AdminPage.tsx`的文件，并在其中添加以下功能组件：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have two pages in our shop, we can declare our two routes to them.
    Let''s create a file called `Routes.tsx` with the following content to import
    `React`, the `BrowserRouter` and `Route` components from React Router, and our
    two pages:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的商店中有两个页面，我们可以为它们声明两个路由。让我们创建一个名为`Routes.tsx`的文件，其中包含以下内容，以从React Router中导入`React`、`BrowserRouter`和`Route`组件，以及我们的两个页面：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have renamed `BrowserRouter` to `Router` in the import statement to save
    a few keystrokes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在导入语句中将`BrowserRouter`重命名为`Router`，以节省一些按键次数。
- en: 'Let''s go on to implement a function component containing our two routes:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个包含我们两个路由的功能组件：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: During rendering, if the `path` in a `Route` component matches the current path,
    the component will be rendered, and if not, `null` will be rendered. In our example,
    `ProductPage` will be rendered if the path is `"/products"` and `AdminPage` will
    be rendered if the path is `"/admin"`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染过程中，如果`Route`组件中的`path`与当前路径匹配，那么该组件将被渲染，如果不匹配，则将渲染`null`。在我们的例子中，如果路径是`"/products"`，则将渲染`ProductPage`，如果路径是`"/admin"`，则将渲染`AdminPage`。
- en: 'The following is the final step to render our `Routes` as the root component
    in `index.tsx`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是将我们的`Routes`作为根组件在`index.tsx`中渲染的最后一步：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We should now be able to run our app:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该能够运行我们的应用程序了：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The app will probably start on the root page, which will be blank because that
    path doesn't point to anything.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应用可能会从根页面开始，因为该路径没有指向任何内容，所以页面会是空白的。
- en: 'If we change the path to `"/products"`, our product list should render the
    following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将路径更改为`"/products"`，我们的产品列表应该呈现如下：
- en: '![](assets/925bbb49-69b4-4177-992b-c25699f815d0.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/925bbb49-69b4-4177-992b-c25699f815d0.png)'
- en: 'If we change the path to `"/admin"`, our admin panel should render the following:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将路径更改为`"/admin"`，我们的管理面板应该呈现如下：
- en: '![](assets/0b262240-7972-4581-8568-e6e1bcb6c572.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b262240-7972-4581-8568-e6e1bcb6c572.png)'
- en: Now that we have successfully created a couple of routes, we really need a navigation
    component to make our pages a little more discoverable. We will do just that in
    the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了一些路由，我们真的需要一个导航组件来使我们的页面更加可发现。我们将在下一节中做到这一点。
- en: Creating navigation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航
- en: React Router comes with some nice components for providing navigation. We are
    going to use these to implement navigation options in the app header.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React Router提供了一些很好的组件来提供导航。我们将使用这些组件来实现应用程序标题中的导航选项。
- en: Using the Link component
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Link组件
- en: 'We are going to use the `Link` component from React Router to create our navigation
    options by carrying out the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用React Router中的`Link`组件来创建我们的导航选项，具体步骤如下：
- en: 'Let''s start by creating a new file called `Header.tsx` with the following
    imports:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`Header.tsx`的新文件开始，其中包含以下导入：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s create two links using the `Link` component in a `Header` function component:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Header`功能组件中使用`Link`组件创建两个链接：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Link` component allows us to define the path where the link navigates to
    as well as the text to display.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Link`组件允许我们定义链接导航到的路径以及要显示的文本。'
- en: 'We''ve referenced some CSS classes, so, let''s add these to `index.css`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经引用了一些CSS类，所以让我们把它们添加到`index.css`中：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that our `Header` component is in place, let''s `import` into `Routes.tsx`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的`Header`组件就位了，让我们在`Routes.tsx`中`import`它：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then use it in the JSX as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在JSX中使用它如下：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we examine the running app, it should look like the following screenshot
    with a nice header and two navigation options to go to our Products and Admin
    pages rendered:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们检查正在运行的应用程序，它应该看起来像以下截图，有一个漂亮的标题和两个导航选项，可以转到我们的产品和管理页面：
- en: '![](assets/e0077307-1579-4601-9c40-0921d07bbd20.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e0077307-1579-4601-9c40-0921d07bbd20.png)'
- en: 'Try clicking the navigation options — they work! If we inspect the Products
    and Admin elements using the browser Developer tools, we see that React Router
    has rendered them as anchor tags:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击导航选项-它们有效！如果我们使用浏览器开发者工具检查产品和管理元素，我们会看到React Router已将它们呈现为锚标签：
- en: '![](assets/13e4d12e-4743-4191-b589-920510489478.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13e4d12e-4743-4191-b589-920510489478.png)'
- en: If we look at the Network tab in Developer tools while clicking the navigation
    options, we'll see no network request is being made to serve the pages. This shows
    that React Router is handling the navigation for us in our React app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在点击导航选项时查看开发者工具中的网络选项卡，我们会看到没有网络请求正在被发出来为我们的React应用程序提供页面。这表明React Router正在处理我们的导航。
- en: Using the NavLink component
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NavLink组件
- en: 'React Router providers another component for linking to pages, called `NavLink`.
    This is actually even more suitable for our requirements. The following steps
    explain how we can refactor our `Header` component to use `NavLink`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: React Router还提供了另一个用于链接页面的组件，称为`NavLink`。实际上，这更适合我们的需求。以下步骤解释了我们如何重构我们的`Header`组件以使用`NavLink`：
- en: 'So, let''s replace `Link` with `NavLink` in our `Header` component and make
    some improvements:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们在我们的`Header`组件中用`NavLink`替换`Link`并进行一些改进：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, our app looks and behaves exactly the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的应用程序看起来和行为都完全一样。
- en: '`NavLink` exposes an `activeClassName` attribute that we can use to style the
    active link. So, let''s use this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NavLink`公开了一个`activeClassName`属性，我们可以用它来设置活动链接的样式。所以，让我们使用它：'
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s add the CSS for `header-link-active` into our `index.css`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`header-link-active`的CSS添加到我们的`index.css`中：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we switch to the running app now, the active link will be underlined:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在切换到正在运行的应用程序，活动链接将被下划线划掉：
- en: '![](assets/3400106f-fffa-4040-9a59-fd6563524f78.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3400106f-fffa-4040-9a59-fd6563524f78.png)'
- en: So, `NavLink` is great for the main app navigation where we want to highlight
    the active link and `Link` is great for all the other links in our app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`NavLink`非常适合主应用程序导航，我们希望突出显示活动链接，而`Link`非常适合应用程序中的所有其他链接。
- en: Route parameters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由参数
- en: A Route parameter is a variable part of the path that can used in the destination
    component to conditionally render something.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 路由参数是路径的可变部分，在目标组件中可以使用它们来有条件地渲染某些内容。
- en: 'We need to add another page to our shop to show the description and price of
    each product, along with an option to add it to the basket. We want to be able
    to navigate to this page using the `"/products/{id}"` path, where `id` is the
    ID of the product. For example, the path to React Redux would be `"products/2"`.
    So, the `id` part of the path is a route parameter. We can do all this by following
    these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的商店添加另一个页面，以显示每个产品的描述和价格，以及将其添加到购物篮的选项。我们希望能够使用`"/products/{id}"`路径导航到此页面，其中`id`是产品的ID。例如，到达React
    Redux的路径将是`"products/2"`。因此，路径的`id`部分是一个路由参数。我们可以通过以下步骤来完成所有这些：
- en: 'Let''s add this route to `Routes.tsx` in between the two existing routes. The
    `id` part of the route is going to be a route parameter, which we define with
    a colon in front of it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在两个现有路由之间的`Routes.tsx`中添加此路由。路由的`id`部分将是一个路由参数，我们在其前面用冒号定义它：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Of course, the `ProductPage` component doesn''t exist yet, so, let''s create
    that by first creating a new file called `ProductPage.tsx` with the following
    imports:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，`ProductPage`组件还不存在，所以，让我们首先创建一个名为`ProductPage.tsx`的新文件，其中包含以下导入：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The key part here is that we are going to use the `RouteComponentProps` type
    to access the `id` parameter in the path. Let''s define the props type alias for
    our `ProductPage` component using the `RouteComponentProps` generic type and passing
    in a type with an `id` property:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键部分在于我们将使用`RouteComponentProps`类型来访问路径中的`id`参数。让我们使用`RouteComponentProps`通用类型来定义我们的`ProductPage`组件的props类型别名，并传入一个具有`id`属性的类型：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Don't worry if you don't understand the angle brackets in the `type` expression.
    This denotes a generic type, which we will explore in [Chapter 5](5359acd1-bd43-48ef-b141-aea4d5fa356c.xhtml),
    *Advanced Types*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解`type`表达式中的尖括号，不要担心。这表示一个通用类型，我们将在[第5章](5359acd1-bd43-48ef-b141-aea4d5fa356c.xhtml)中探讨*高级类型*。
- en: Ideally, we'd have specified the `id` property as a number to match the type
    in the product data. However, `RouteComponentProps`only allows us to have Route
    parameters of type string or undefined.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该将`id`属性指定为数字，以匹配产品数据中的类型。但是，`RouteComponentProps`只允许我们拥有类型为字符串或未定义的路由参数。
- en: 'The `ProductPage` component is going to have state to hold the product that
    is being rendered and whether it has been added to the basket, so let''s define
    an interface for our state:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductPage`组件将具有状态来保存正在呈现的产品以及它是否已添加到购物篮中，因此让我们为我们的状态定义一个接口：'
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The product is initially going to be `undefined`, which is why it is defined
    as optional. Let''s create our `ProductPage` class and initialize the state so
    that the product is not in the basket:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品最初将是`undefined`，这就是为什么它被定义为可选的。让我们创建我们的`ProductPage`类并初始化状态，以便产品不在购物篮中：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the component is loaded into the DOM, we need to find our product from
    the product data with the `id` property from the `Route` parameter. `RouteComponentProps`
    gives us a `match` object, containing a `params` object, containing our `id` route
    parameter. So, let''s implement this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件加载到DOM中时，我们需要使用`Route`参数中的`id`属性从产品数据中找到我们的产品。`RouteComponentProps`给我们一个包含`params`对象的`match`对象，其中包含我们的`id`路由参数。所以，让我们实现这个：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember that the `id` route parameter is a string, which is why we cast it
    to a number using `parseInt` before comparing it with the product data in the `filter` array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`id`路由参数是一个字符串，这就是为什么我们在将其与`filter`数组中的产品数据进行比较之前，将其转换为数字使用`parseInt`。
- en: 'Now that we have our product in our component state, let''s move on to the
    `render` function:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在组件状态中有了我们的产品，让我们继续进行`render`函数：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are a few interesting bits in this JSX:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个JSX中有一些有趣的地方：
- en: On the first line inside the function, we set a `product` variable to the product
    state to save a few keystrokes because we reference the product a lot in the JSX.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内的第一行，我们将`product`变量设置为产品状态，以节省一些按键，因为我们在JSX中引用产品很多。
- en: The ternary inside `div` renders the product if there is one. Otherwise, it
    informs the user that the product cannot be found.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`div`内的三元运算符在有产品时呈现产品。否则，它会通知用户找不到产品。'
- en: We use `React.Fragment` in the true part of the ternary because each part of
    a ternary can only have a single parent and `React.Fragment` is a mechanism for achieving
    this, without rendering something like a `div` tag that is not really needed.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在三元运算符的真部分中使用`React.Fragment`，因为三元运算符的每个部分只能有一个父级，`React.Fragment`是一种实现这一点的机制，而不需要渲染像`div`这样的不是真正需要的标记。
- en: We use `Intl.NumberFormat` to format the product price as currency with a currency
    symbol.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Intl.NumberFormat`将产品价格格式化为带有货币符号的货币。
- en: 'We are also calling the `handleAddClick` method when the Add to basket button
    is clicked. We haven''t implemented this yet, so, let''s do that now and set the
    `added` state to `true`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当单击“添加到购物篮”按钮时，我们还将调用`handleAddClick`方法。我们还没有实现这一点，所以现在让我们这样做，并将`added`状态设置为`true`：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we''ve implemented the `ProductPage` component, let''s go back to
    `Routes.tsx` and import it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`ProductPage`组件，让我们回到`Routes.tsx`并导入它：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s go to our running app and type in `"/products/2"` as the path:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开我们的运行中的应用，输入`"/products/2"`作为路径：
- en: '![](assets/0b6b05ab-b747-4c2a-82e9-3f753290bb97.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b6b05ab-b747-4c2a-82e9-3f753290bb97.png)'
- en: Not quite what we want! Both `ProductsPage` and `ProductPage` have rendered
    because `"/products/2"` matches both `"/products"` and `"/products/:id"`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不太符合我们的要求！`ProductsPage`和`ProductPage`都被渲染了，因为`"/products/2"`同时匹配`"/products"`和`"/products/:id"`。
- en: 'To resolve this, we can tell the `"/products"` route to only render when there
    is an exact match:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以告诉`"/products"`路由只在有精确匹配时才进行渲染：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After we make this change and save `Routes.tsx`, our product page looks much
    better:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行这些更改并保存`Routes.tsx`之后，我们的产品页面看起来好多了：
- en: '![](assets/59bbace4-1854-40b6-9504-65f9c7b1a1df.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59bbace4-1854-40b6-9504-65f9c7b1a1df.png)'
- en: 'We aren''t going to make our users type in the specific paths to visit the
    products! So, we are going to change `ProductsPage` to link to `ProductPage` for
    each product using the `Link` component. First, let''s import `Link` into `ProductsPage`
    from React Router:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不打算让用户输入特定的路径来访问产品！因此，我们将更改`ProductsPage`，使用`Link`组件为每个产品链接到`ProductPage`。首先，让我们从React
    Router中导入`Link`到`ProductsPage`中：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, instead of rendering the product name in each list item, we are going
    to render a `Link` component that goes to our product page:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不再在每个列表项中渲染产品名称，而是要渲染一个`Link`组件，用于跳转到我们的产品页面：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before we take a look a the running app, let''s add the following CSS class
    in our `index.css`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们查看运行中的应用之前，让我们在`index.css`中添加以下CSS类：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, if we go to the products list in our app and click on a list item, it takes
    us to the relevant product page.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在应用中的产品列表中点击一个列表项，它会带我们到相关的产品页面。
- en: Handling not found routes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理未找到的路由
- en: 'What if a user enters a path that doesn''t exist in our app? For example, if
    we try to navigate to `"/tools"` we get nothing appearing beneath our header.
    This makes sense, because React Router didn''t find any matching routes, so nothing
    is rendered. However, if the user does navigate to an invalid path, we want to
    inform them that the path doesn''t exist. The following steps make this happen:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了我们应用中不存在的路径会怎么样？例如，如果我们尝试导航到`"/tools"`，我们在标题下面什么都看不到。这是有道理的，因为React Router没有找到匹配的路由，所以什么都没有渲染。然而，如果用户导航到无效的路径，我们希望通知他们该路径不存在。以下步骤可以实现这一点：
- en: 'So, let''s create a new file called `NotFoundPage.tsx` with the following component:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个名为`NotFoundPage.tsx`的新文件，其中包含以下组件：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s import this into our routes in `Routes.tsx`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Routes.tsx`中导入这个：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s then add a `Route` component to this with the other routes:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们在其他路由中添加一个`Route`组件：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, this is going to render for every path:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将对每个路径进行渲染：
- en: '![](assets/3842b2b9-6751-45b7-9d7b-9f605e22cece.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3842b2b9-6751-45b7-9d7b-9f605e22cece.png)'
- en: How can we just render `NotFoundPage` when it hasn't found another route? The
    answer is to wrap the Routes in the `Switch` component in React Router.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有找到其他路由时，我们如何只渲染`NotFoundPage`？答案是在React Router中用`Switch`组件包裹路由。
- en: 'Let''s first import `Switch` into `Routes.tsx`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`Routes.tsx`中导入`Switch`：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s now wrap the `Route` components in a `Switch` component:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`Route`组件包裹在`Switch`组件中：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Switch` component renders only the first matching `Route` component. If
    we look at the running app we see that our problem is resolved. If we enter a
    path that doesn''t exist, we get our nice not found message:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`组件只渲染第一个匹配的`Route`组件。如果我们查看运行中的应用，我们会发现我们的问题已经解决了。如果输入一个不存在的路径，我们会得到一个友好的未找到消息：'
- en: '![](assets/21ea4cb5-68fb-41c3-abe3-ae2b50f7e5ad.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21ea4cb5-68fb-41c3-abe3-ae2b50f7e5ad.png)'
- en: Implementing page redirects
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现页面重定向
- en: React Router has a component called `Redirect` that we can use to redirect to
    pages. We use this component in a couple of cases to improve our shop in the following
    sections.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: React Router有一个名为`Redirect`的组件，我们可以用它来重定向到页面。我们在接下来的几节中使用这个组件来改进我们的商店。
- en: Simple redirect
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单重定向
- en: If we visit the `/` route path, we'll notice that we get the Sorry, this page
    cannot be found message. Let's change this to redirect to `"/products"` when the
    path is `/`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问`/`路由路径，我们会注意到我们得到了“抱歉，找不到此页面”的消息。让我们把它改成在路径为`/`时重定向到`"/products"`。
- en: 'First, we need to import the `Redirect` component from React Router into `Routes.tsx`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`Routes.tsx`中导入`Redirect`组件：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can now use the `Redirect` component to redirect to `"/products"` when the
    path is `/`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`Redirect`组件在路径为`/`时重定向到`"/products"`：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We've used the `exact` attribute on `Redirect` so that it only matches `/` and
    not `"/products/1"` and `"/admin"`. If we give this a try and enter `/` as the
    path in our running app, it will immediately redirect to `"/products"`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Redirect`上使用了`exact`属性，以便它只匹配`/`而不匹配`"/products/1"`和`"/admin"`。如果我们尝试在运行的应用程序中输入`/`作为路径，它将立即重定向到`"/products"`。
- en: Conditional redirect
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件重定向
- en: 'We can use the `Redirect` component to protect pages from unauthorized users.
    In our shop, we can use this to ensure only logged in users can access our Admin
    page. We do this through the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Redirect`组件来保护未经授权的用户访问页面。在我们的商店中，我们可以使用这个来确保只有已登录的用户可以访问我们的Admin页面。我们通过以下步骤来实现这一点：
- en: 'Let''s start by adding a route to a `LoginPage` in `Routes.tsx` after the route
    to the Admin page:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`Routes.tsx`中的Admin页面路由之后添加一个到`LoginPage`的路由：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Of course, `LoginPage` doesn''t exist at the moment, so, let''s create a file
    called `LoginPage.tsx` and enter the following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，`LoginPage`目前不存在，所以让我们创建一个名为`LoginPage.tsx`的文件并输入以下内容：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can then go back to `Routes.tsx` and import `LoginPage`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以回到`Routes.tsx`并导入`LoginPage`：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we go to the running app and navigate to `"/login"`, we will see our Login
    page:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们去运行的应用程序并导航到`"/login"`，我们会看到我们的登录页面：
- en: '![](assets/cc65b5cd-91ed-4172-acdd-646e9462f43d.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc65b5cd-91ed-4172-acdd-646e9462f43d.png)'
- en: We are not going to fully implement our Login page; the page that we have implemented
    is enough to demonstrate a conditional redirect.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算完全实现我们的登录页面；我们已经实现的页面足以演示条件重定向。
- en: 'Before we implement the conditional redirect on the `"admin"` path, we need
    to add a piece of state for whether a user is logged in or not in `Routes.tsx`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在`Routes.tsx`中实现`"admin"`路径的条件重定向之前，我们需要在`Routes.tsx`中添加一个关于用户是否已登录的状态：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So, we have used a `useState` hook to add a state variable called `loggedIn`
    and a function to set it called `setLoggedIn`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用了`useState`钩子来添加一个名为`loggedIn`的状态变量和一个名为`setLoggedIn`的函数。
- en: 'The final step is to add the following inside the `Route` component with the `"/admin"`
    path:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在`"/admin"`路径的`Route`组件内添加以下内容：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We conditionally render `AdminPage` if the user is logged in, otherwise, we
    redirect to the `"/login"` path. If we now click the `admin` link in our running
    app, we get redirected to the Login page.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，我们有条件地渲染`AdminPage`，否则，我们重定向到`"/login"`路径。如果我们现在在运行的应用程序中点击`admin`链接，我们将被重定向到登录页面。
- en: 'If we change the `loggedIn` state to be true when we initialize it, we are
    able to access our Admin page again:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将`loggedIn`状态更改为true，我们就能再次访问我们的Admin页面：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Query parameters
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询参数
- en: A query parameter is part of the URL that allows additional parameters to be
    passed into a path. For example, `"/products?search=redux"` has a query parameter
    called `search` with a `redux` value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是URL的一部分，允许将附加参数传递到路径中。例如，`"/products?search=redux"`有一个名为`search`的查询参数，值为`redux`。
- en: 'Let''s implement this example and allow the users of the shop to search for
    a product:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个例子，让商店的用户可以搜索产品：
- en: 'Let''s start by adding a variable in the state in `ProductsPage.tsx` called
    `search`, which is going to hold the search criteria:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`ProductsPage.tsx`中的状态中添加一个名为`search`的变量，它将保存搜索条件：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Given that we need to access the URL, we need to use `RouteComponentProps`
    as the props type in `ProductsPage`. Let''s first import this:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于我们需要访问URL，我们需要在`ProductsPage`中使用`RouteComponentProps`作为`props`类型。让我们首先导入这个：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can then use this as the `props` type:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以将其用作`props`类型：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can initialize the `search` state to an empty string in `constructor`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`constructor`中将`search`状态初始化为空字符串：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We then need to set the `search` state in `componentDidMount` to the search
    query parameter. React Router gives us access to all the query parameters in `location.search`
    within the `props` argument that it passes into the component. We then need to
    parse that string to get our search query string parameter. We can use the `URLSearchParams`JavaScript
    function to do this. We are going to use the static `getDerivedStateFromProps`
    life cycle method to do this, which is called when the component loads and when
    its `props` parameters change:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要在`componentDidMount`中将`search`状态设置为搜索查询参数。React Router通过`location.search`在`props`参数中给我们访问所有查询参数。然后我们需要解析该字符串以获取我们的搜索查询字符串参数。我们可以使用`URLSearchParams`JavaScript函数来做到这一点。我们将使用静态的`getDerivedStateFromProps`生命周期方法来做到这一点，当组件加载时以及其`props`参数发生变化时会调用该方法：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Unfortunately, `URLSearchParams`hasn''t been implemented yet in all browsers,
    so we can use a polyfill called `url-search-params-polyfill`. Let''s install this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，`URLSearchParams`在所有浏览器中尚未实现，因此我们可以使用一个名为`url-search-params-polyfill`的polyfill。让我们安装这个：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s import this into `ProductPages.tsx`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将其导入到`ProductPages.tsx`中：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We then can use the `search` state in the `render` method by wrapping an `if`
    statement around the returned list item to only return something when the value
    of `search` is contained within the product name:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在`render`方法中使用`search`状态，通过在返回的列表项周围包装一个`if`语句，只有在产品名称中包含`search`的值时才返回结果：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we enter `"/products?search=redux"` as the path in our running app, we will
    see our products list containing only React Redux:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在运行的应用程序中输入`"/products?search=redux"`作为路径，我们将看到我们的产品列表仅包含React Redux：
- en: '![](assets/96ffab51-0017-401b-b155-bb32ee090203.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96ffab51-0017-401b-b155-bb32ee090203.png)'
- en: 'We are going to finish implementing this feature by adding a search input in
    our app header that sets the search query parameter. Let''s start this by creating
    some state in the `Header` component for the search value in `Header.tsx`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过在应用程序标题中添加一个搜索输入来完成实现此功能，该输入将设置搜索查询参数。让我们首先在`Header.tsx`中的`Header`组件中创建一些状态来存储搜索值：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We are also going to need to access the query string via React Router and `URLSearchParams`,
    so let''s import `RouteComponentProps`, `withRouter`,andthe `URLSearchParams`
    polyfill:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要通过React Router和`URLSearchParams`访问查询字符串，所以让我们导入`RouteComponentProps`，`withRouter`和`URLSearchParams`
    polyfill：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s add a `props` parameter to our `Header` component:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向`Header`组件添加一个`props`参数：
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now get the search value from the path query string and set the `search`
    state to this when the component first renders:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从路径查询字符串中获取搜索值，并在组件首次渲染时将`search`状态设置为该值：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s now add a `search` input in the `render` method for the user to enter
    their search:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`render`方法中添加一个`search`输入，让用户输入他们的搜索条件：
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s add the `search-container` CSS class that we just referenced to `index.css`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将刚刚引用的`search-container` CSS类添加到`index.css`中：
- en: '[PRE67]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Back in `Header.tsx`, let''s add the `handleSearchChange` method, which is
    referenced in the `render` method and will keep our `search` state up to date
    with the value being entered:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`Header.tsx`，让我们添加`handleSearchChange`方法，该方法在`render`方法中被引用，并将保持我们的`search`状态与输入的值保持同步：
- en: '[PRE68]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can now implement the `handleSearchKeydown` method, which is referenced
    in the `render` method. This needs to add the `search` state value to the path
    query string when the `Enter` key is pressed. We can leverage the `push` method
    in the `history` prop that `RouteComponentProps` gives us:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实现`handleSearchKeydown`方法，该方法在`render`方法中被引用。当按下`Enter`键时，这需要将`search`状态值添加到路径查询字符串中。我们可以利用`RouteComponentProps`给我们的`history`属性中的`push`方法：
- en: '[PRE69]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We need to export the `Header` component wrapped with the `withRouter` higher
    order component in order for the reference to `this.props.history` to work. So,
    let''s do this and adjust our `export` expression:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导出使用`withRouter`高阶组件包装的`Header`组件，以便引用`this.props.history`能够工作。所以，让我们这样做并调整我们的`export`表达式：
- en: '[PRE70]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s give this a try in the running app. If we enter `redux` in the search
    input and press the *Enter* key, the app should navigate to the Products page
    and filter the products to React Redux:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在运行的应用程序中尝试一下。如果我们在搜索输入中输入`redux`并按下*Enter*键，应用程序应该导航到产品页面并将产品过滤为React Redux：
- en: '![](assets/57a03ba9-e655-4f2e-be06-f7ac98dbad03.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57a03ba9-e655-4f2e-be06-f7ac98dbad03.png)'
- en: Route prompts
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由提示
- en: 'Sometimes, we might want to ask the user to confirm that they want to navigate
    away from a page. This is useful if the user is in the middle of data entry on
    a page and presses a navigation link to go to a different page before they have
    saved the data. The `Prompt` component in React Router allows us to do this, as
    set out in the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望要求用户确认他们是否要离开页面。如果用户在页面上进行数据输入并在保存数据之前按导航链接转到另一页，这将很有用。React Router中的`Prompt`组件允许我们执行此操作，如下所述：
- en: 'In our app, we are going to prompt users to confirm that they want to navigate
    away from the Product page if they haven''t added the product to their basket.
    First, in `ProductPage.tsx`, let''s import the `Prompt` component from React Router:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，如果用户尚未将产品添加到其购物篮中，我们将提示用户确认是否要离开产品页面。首先，在`ProductPage.tsx`中，让我们从React
    Router中导入`Prompt`组件：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Prompt`component invokes a confirmation dialog during navigation when
    a certain condition is met. We can use the `Prompt` component in our JSX as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Prompt`组件在满足某些条件时在导航期间调用确认对话框。我们可以在我们的JSX中使用`Prompt`组件如下：'
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `when` attribute allows us to specify an expression for when the dialog
    should appear. In our case, this is when the product hasn't been added to the
    basket.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`属性允许我们指定对话框何时出现的表达式。在我们的情况下，这是当产品尚未添加到购物篮时。'
- en: The `message`attribute allows us to specify a function that returns the message
    to display in the dialog.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`属性允许我们指定一个返回要在对话框中显示的消息的函数。'
- en: 'In our case, we call a `navAwayMessage` method, which we''ll implement next:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们调用一个`navAwayMessage`方法，接下来我们将实现：
- en: '[PRE73]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s give this a try by navigating to the React Router product and then navigating
    away without clicking the Add to basket button:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下，通过导航到React Router产品，然后在不点击添加到购物篮按钮的情况下离开：
- en: '![](assets/cf59716c-37f2-4965-a041-d7c064953d5e.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf59716c-37f2-4965-a041-d7c064953d5e.png)'
- en: We are asked to confirm whether we want to navigate away.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求确认是否要离开。
- en: Nested routes
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: 'A nested route is when a URL is more than one level deep and it renders multiple
    components. We are going to implement some nested routes in this section in our
    Admin page. Our completed Admin page will look like the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由是指URL超过一个级别，并且呈现多个组件。在本节中，我们将实现一些嵌套路由在我们的管理页面中。我们完成的管理页面将如下截图所示：
- en: '![](assets/aea627e7-0812-4851-b2c2-3619c51533ef.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aea627e7-0812-4851-b2c2-3619c51533ef.png)'
- en: 'The URL in the preceding screenshot is 3 levels deep which renders the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中的URL有3个级别，会显示如下内容：
- en: The top-level menu containing links for Users and Products.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含用户和产品链接的顶级菜单。
- en: A menu containing all the users. This is just Fred, Bob, and Jane is our example.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有用户的菜单。在我们的示例中只有Fred、Bob和Jane。
- en: Information about the selected user.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所选用户的信息。
- en: 'Let''s start by opening `AdminPage.tsx` and add `import` statements for the
    following from `react-router-dom`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始打开`AdminPage.tsx`并从`react-router-dom`中为以下内容添加`import`语句：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We'll use the `NavLink` component to render the menus
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`NavLink`组件来呈现菜单。
- en: The `Route` component will be used to render the nested routes
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Route`组件将用于渲染嵌套路由'
- en: The `RouteComponentProps` type will be used to get the `id` of a user from the
    URL
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouteComponentProps`类型将用于从URL获取用户的`id`'
- en: 'We are going to replace the `p` tag with an unordered list containing menu
    options Users and Products:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用无序列表替换`p`标签，其中包含菜单选项Users和Products：
- en: '[PRE75]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We use the `NavLink` component to navigate to the nested route for the two options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`NavLink`组件导航到两个选项的嵌套路由。
- en: 'Let''s add the CSS classes we have just referenced in `index.css`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`index.css`中添加我们刚刚引用的CSS类：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Moving back to `AdminPage.tsx`, let''s add two `Route` components beneath the
    menu we have just added. These will handle the `/admin/users` and `/admin/products` paths
    we referenced in our menu:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`AdminPage.tsx`，让我们在我们刚刚添加的菜单下面添加两个`Route`组件。这些将处理我们在菜单中引用的`/admin/users`和`/admin/products`路径：
- en: '[PRE77]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We have just referenced `AdminUsers` and `AdminProducts` components that don''t
    exist yet. Let''s implement the `AdminProducts` component first by entering the
    following beneath the `AdminPage` component in `AdminPage.tsx`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚引用了尚不存在的`AdminUsers`和`AdminProducts`组件。让我们首先在`AdminPage.tsx`中的`AdminPage`组件下面输入以下内容来实现`AdminProducts`组件：
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So, this component just renders a bit of text on the screen.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此组件只在屏幕上呈现一些文本。
- en: 'Let''s move on to the `AdminUsers` component now which is more complex. We''ll
    start by defining an interface for a user along with some user data beneath the `AdminProducts` component
    in `AdminPage.tsx`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续处理`AdminUsers`组件，这更加复杂。我们将从在`AdminPage.tsx`中的`AdminProducts`组件下面定义用户接口以及一些用户数据开始：
- en: '[PRE79]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: So, we have 3 users in our example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我们的示例中有3个用户。
- en: 'Let''s start to implement the `AdminUsers` component then in `AdminPage.tsx`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始在`AdminPage.tsx`中实现`AdminUsers`组件：
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The component renders a link containing each user's name. The link is to a nested
    path which will eventually show details about the user.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件呈现一个包含每个用户名称的链接。该链接是到一个嵌套路径，最终将显示有关用户的详细信息。
- en: 'So, we need to define another route that will call a component to render details
    about a user. We can do this by using another `Route` component:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要定义另一个路由，调用一个组件来渲染有关用户的详细信息。我们可以通过使用另一个`Route`组件来实现这一点：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The path we have just defined routes to an `AdminUser` component we haven''t
    defined yet. So, let''s make a start on this beneath the `AdminUsers` component:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚定义的路径路由到一个我们还没有定义的`AdminUser`组件。所以，让我们从`AdminUsers`组件下面开始：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We use `RouteComponentProps` to get the `id` from the URL path and make this
    available in the props.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`RouteComponentProps`从URL路径中获取`id`并在props中使其可用。
- en: 'We can now use the `id` from the path to get the user from our `adminUsersData`
    array:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用路径中的`id`来从我们的`adminUsersData`数组中获取用户：
- en: '[PRE83]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we have the `user` object, we can render the information within it.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`user`对象，我们可以呈现其中的信息。
- en: '[PRE84]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If we go to the running app, go to the Admin page and click on the Products
    menu item, it will look like below:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们转到运行的应用程序，转到管理页面并单击产品菜单项，它将如下所示：
- en: '![](assets/41b9577d-4622-4b94-8fbc-8fff41c2939e.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41b9577d-4622-4b94-8fbc-8fff41c2939e.png)'
- en: If we click on the Users menu item, we'll see the 3 users that we can click
    on to get more information about a user. This will look like the first screenshot
    in this section.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们单击`用户`菜单项，我们将看到我们可以单击以获取有关用户的更多信息的3个用户。这将看起来像本节中的第一个截图。
- en: So, in order to implement nested routes, we create the necessary links using
    `NavLink` or `Link` components and route those links to the component to render
    the content using a `Route` component. We already knew about these components
    before this section, so, we just needed to learn how to use these in the context
    of nested routes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了实现嵌套路由，我们使用`NavLink`或`Link`组件创建必要的链接，并使用`Route`组件将这些链接路由到要使用`Route`组件呈现内容的组件。在本节之前，我们已经了解了这些组件，所以我们只需要学习如何在嵌套路由的上下文中使用它们。
- en: Animated transitions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画过渡
- en: 'In this section, we are going to add a bit of animation when users navigate
    to different pages. We do this using the `TransitionGroup` and `CSSTransition`
    components from the `react-transition-group npm` package, as shown in the following
    steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，当用户导航到不同页面时，我们将添加一些动画。我们使用`react-transition-group npm`包中的`TransitionGroup`和`CSSTransition`组件来实现这一点，如下所示：
- en: 'So, let''s first install this package with its TypeScript types:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们首先安装此包及其TypeScript类型：
- en: '[PRE85]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`TransitionGroup` keeps track of all its children inside its local state and
    calculates when children are entering or exiting.  `CSSTransition` takes whether
    children are leaving or exiting from `TransitionGroup` and applies CSS classes
    to the children based on that status. So, `TransitionGroup` and `CSSTransition` can
    wrap our routes and invoke CSS classes that we can create to animate pages in
    and out.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransitionGroup`跟踪其所有子元素并计算子元素何时进入或退出。`CSSTransition`从`TransitionGroup`获取子元素是离开还是退出，并根据该状态对子元素应用CSS类。因此，`TransitionGroup`和`CSSTransition`可以包装我们的路由并调用我们可以创建的CSS类，以实现页面的进出动画。'
- en: 'So, let''s import these components into `Routes.tsx`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们将这些组件导入`Routes.tsx`：
- en: '[PRE86]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We also need to import `RouteComponentProps` from React Router:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从React Router中导入`RouteComponentProps`：
- en: '[PRE87]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let''s use `RouteComponentProps` as the `Route` component props type:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`RouteComponentProps`用作`Route`组件的props类型：
- en: '[PRE88]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let''s add the `CSSTransition` and `TransitionGroup` components to the JSX
    around the `Switch` component:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`CSSTransition`和`TransitionGroup`组件添加到`Switch`组件周围的JSX中：
- en: '[PRE89]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`TransitionGroup` requires children to have a unique key for it to determine
    what is exiting and entering. So, we have specified a `key` attribute on `CSSTransition`
    to be the `location.key` property from `RouteComponentProps`. We have specified
    that the transition is going to run for up to half a second via the `timeout`
    attribute. We have also specified the CSS classes that are going to be invoked
    with an `animate` prefix via the `classNames`attribute.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransitionGroup`要求子元素具有唯一的`key`，以确定何时退出和进入。因此，我们已经指定了`CSSTransition`上的`key`属性为`RouteComponentProps`的`location.key`属性。我们已经指定了过渡将在半秒内运行的`timeout`属性。我们还指定了将使用`animate`前缀调用的CSS类，通过`classNames`属性。'
- en: 'So, let''s add these CSS classes in `index.css`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们在`index.css`中添加这些CSS类：
- en: '[PRE90]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`CSSTransition` is going to invoke these CSS classes when its key changes.
    The CSS classes initially hide the element being transitioned and gradually ease
    the element''s opacity so that it shows.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSSTransition`将在其键更改时调用这些CSS类。这些CSS类最初隐藏了正在过渡的元素，并逐渐缓解了元素的不透明度，以便显示出来。'
- en: 'If we go to `index.tsx`, we get a compilation error where we reference the
    `Routes` component because it is expecting us to pass props such as `history`
    from the router:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们转到`index.tsx`，我们会得到一个编译错误，因为它期望我们传递来自路由器的`history`等props给`Routes`组件：
- en: '![](assets/d2f019b7-3abf-401b-873b-968d0076d9f0.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2f019b7-3abf-401b-873b-968d0076d9f0.png)'
- en: Unfortunately, we can't use the `withRouter` higher order component because
    this would be outside the `Router` component. To resolve this, we can add a new
    component called `RoutesWrap`, which doesn't take in any props and wraps our existing
    `Routes` component. The `Router` will move up to `RoutesWrap` and will contain
    a `Route` component that always renders our `Routes` component.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法使用`withRouter`高阶组件，因为这将位于`Router`组件之外。为了解决这个问题，我们可以添加一个名为`RoutesWrap`的新组件，它不接受任何props，并包装我们现有的`Routes`组件。`Router`将移动到`RoutesWrap`，并包含一个始终渲染我们的`Routes`组件的`Route`组件。
- en: 'So, let''s add this `RoutesWrap` component to `Routes.tsx` and export `RoutesWrap`
    instead of `Routes`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们将`RoutesWrap`组件添加到`Routes.tsx`中，并导出`RoutesWrap`而不是`Routes`：
- en: '[PRE91]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The compilation error goes away, which is great.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误消失了，这太棒了。
- en: 'Let''s now remove `Router` from our `Routes` component, leaving the `div` tag
    as its root:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们从我们的`Routes`组件中删除`Router`，将`div`标签作为其根：
- en: '[PRE92]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If we go to the running app and navigate to the different pages, you'll see
    a nice fade animation as the page comes into view.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到运行的应用程序并导航到不同的页面，您将看到一个很好的淡入淡出动画，当页面进入视图时。
- en: Lazy loading routes
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载路由
- en: 'At the moment, all the JavaScript for our app is loaded when the app first
    loads. This includes the Admin page that users don''t use that often. It would
    be great if the `AdminPage` component wasn''t loaded when the app loads and instead
    loaded on demand. This is exactly what we are going to do in this section. This
    is called "lazy loading" components. The following steps allows us to load things
    on demand:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当应用程序首次加载时，将加载我们应用程序的所有JavaScript。这包括用户不经常使用的管理页面。如果`AdminPage`组件在应用程序加载时不加载，而是按需加载，那将是很好的。这正是我们将在本节中要做的。这称为“延迟加载”组件。以下步骤允许我们按需加载内容：
- en: 'First, we are going to import the `Suspense` component from React, which we
    are going to use a little later:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从React中导入`Suspense`组件，稍后我们将使用它：
- en: '[PRE93]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, we are going to import the `AdminPage` component differently:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将以不同的方式导入`AdminPage`组件：
- en: '[PRE94]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We use a React function called `lazy` which takes in a function that returns
    a dynamic import, which in turn is assigned to our `AdminPage` component variable.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`lazy`的React函数，它接受一个返回动态导入的函数，然后将其分配给我们的`AdminPage`组件变量。
- en: 'After we have done this, we may get a linting error: A dynamic import call
    in ES5/ES3 requires the ''Promise'' constructor. Make sure you have a declaration
    for the ''Promise'' constructor or include ''ES2015'' in your `--lib` option.
    So, in `tsconfig.json`, let''s add the `lib` compiler option:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们这样做之后，我们可能会遇到一个linting错误：在ES5/ES3中进行动态导入调用需要'Promise'构造函数。确保您有'Promise'构造函数的声明，或在`--lib`选项中包含'ES2015'。因此，在`tsconfig.json`中，让我们添加`lib`编译器选项：
- en: '[PRE95]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The next part is to wrap the `Suspense` component around the `AdminPage` component:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的部分是在`AdminPage`组件周围包装`Suspense`组件：
- en: '[PRE96]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `Suspense` component shows a `div` tag containing Loading... whilst `AdminPage`
    is being loaded.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suspense`组件显示一个包含Loading...的`div`标签，同时加载`AdminPage`。'
- en: 'Let''s try this in the running app. Let''s open the browser developer tools
    and go to the Network tab. In our app, let''s go to the Products page and refresh
    the browser. Let''s then clear the content in the Network tab in the developer
    tools. If we then go to the Admin page in our app and look at the content in the
    Network tab, we''ll see the *chunk* of JavaScript for the `AdminPage` component
    dynamically loaded:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在运行的应用程序中尝试这个。让我们打开浏览器开发者工具，转到网络选项卡。在我们的应用程序中，让我们转到产品页面并刷新浏览器。然后清除开发者工具中网络选项卡中的内容。如果我们然后转到应用程序中的管理页面并查看网络选项卡中的内容，我们将看到动态加载`AdminPage`组件的JavaScript
    *块*：
- en: '![](assets/3c17f194-4bda-4257-9bcb-b5469bc15d8b.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c17f194-4bda-4257-9bcb-b5469bc15d8b.png)'
- en: 'The `AdminPage` component loads really fast, so we never really see the Loading
    ... `div` tag. So, let''s slow the connection down in the browser developer tools:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AdminPage`组件加载非常快，所以我们从来没有真正看到Loading ... `div`标签。所以，让我们在浏览器开发者工具中减慢连接速度：'
- en: '![](assets/c83f1d4f-ebb1-4d97-9c9b-62be48138d46.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c83f1d4f-ebb1-4d97-9c9b-62be48138d46.png)'
- en: 'If we then refresh the browser, and go to the Admin page again, we''ll see
    Loading ...:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们然后刷新浏览器，再次转到管理页面，我们将看到Loading ...：
- en: '![](assets/0432f462-c81f-4d13-81f5-06e001a1f974.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0432f462-c81f-4d13-81f5-06e001a1f974.png)'
- en: In this example, the `AdminPage` component isn't that big so this approach doesn't
    really positively impact performance. However, loading larger components on demand
    can really help performance, particularly on slow connections.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`AdminPage`组件并不是很大，所以这种方法并没有真正对性能产生积极影响。然而，按需加载更大的组件确实可以帮助提高性能，特别是在慢速连接上。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: React Router gives us a comprehensive set of components for managing the navigation
    between pages in our app. We learned that the top-level component is `Router`,
    which looks for `Route` components beneath it where we define what components
    should be rendered for certain paths.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: React Router为我们提供了一套全面的组件，用于管理应用程序中页面之间的导航。我们了解到顶层组件是`Router`，它在其下寻找`Route`组件，我们在其中定义了应该为特定路径呈现哪些组件。
- en: The `Link` component allows us to link to different pages with an app. We learned
    that the `NavLink` component is like `Link`, but it includes the ability to style
    it depending on whether it is the active path or not. So, `NavLink` is perfect
    for the main navigation element in an app and `Link` is great for other links
    that appear on pages.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Link`组件允许我们链接到应用程序中的不同页面。我们了解到`NavLink`组件类似于`Link`，但它包括根据是否为活动路径来设置样式的能力。因此，`NavLink`非常适合应用程序中的主导航元素，而`Link`非常适合出现在页面上的其他链接。'
- en: '`RouteComponentProps` is a type that gives us access to route parameters and
    query parameters. We discovered that React Router doesn''t parse query parameters
    for us, but can use the native JavaScript `URLSearchParams` interface to do this
    for us.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteComponentProps`是一种类型，它使我们能够访问路由参数和查询参数。我们发现React Router不会为我们解析查询参数，但可以使用原生JavaScript
    `URLSearchParams`接口来为我们做这个。'
- en: The `Redirect` component redirects to a path under certain conditions. We found
    that this is perfect for protecting pages that only privileged users can access.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redirect`组件在特定条件下重定向到路径。我们发现这非常适合保护只有特权用户可以访问的页面。'
- en: The `Prompt` component allows us to ask the user to confirm they want to leave
    a page under a certain condition. We used this on the Product page to double-check
    whether users wanted to buy the product. Another common use case for this component
    is confirming navigation away from a data entry page when the inputted data hasn't
    been saved.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prompt`组件允许我们在特定条件下要求用户确认他们是否要离开页面。我们在产品页面上使用它来再次确认用户是否要购买产品。这个组件的另一个常见用例是在输入的数据没有保存时，确认离开数据输入页面的导航。 '
- en: We learnt about how nested routes can provide users with deep links into very
    specific parts of our app. We simply define the relevant links using `Link` or
    `NavLink` and `Route` components to handle those links.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到嵌套路由如何为用户提供进入应用程序特定部分的深链接。我们只需使用`Link`或`NavLink`和`Route`组件来定义相关链接以处理这些链接。
- en: We improved our app experience with page transitions using the `TransitionGroup`
    and `CSSTransition` components from the `react-transition-group npm` package.
    We wrapped these components around our `Route` components that define the app
    paths and added CSS classes to do the animation we want when pages exit and enter
    into view.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`react-transition-group npm`包中的`TransitionGroup`和`CSSTransition`组件改进了我们的应用体验。我们将这些组件包裹在定义应用路径的`Route`组件周围，并添加了CSS类来实现我们希望页面退出和进入视图时的动画效果。
- en: We learnt that the React `lazy` function along with its `Suspense` component
    can be used on large components that are rarely used by users to load them on
    demand. This helps performance for the startup time of our app.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，React的`lazy`函数以及其`Suspense`组件可以用于按需加载用户很少使用的大型组件。这有助于提高应用程序的启动时间性能。
- en: Questions
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let''s test our knowledge on React Router with the following questions:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下问题来测试我们对React Router的了解：
- en: 'We have the following `Route` component that shows a list of customers:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下显示客户列表的`Route`组件：
- en: '[PRE97]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Will the `CustomersPage` component render when the page is `"/customers"`?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面是`"/customers"`时，`CustomersPage`组件会渲染吗？
- en: Will the `CustomersPage` component render when the page is `"/customers/24322"`?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面是`"/customers/24322"`时，`CustomersPage`组件会渲染吗？
- en: We only want the `CustomersPage` component to render when the path is `"/customers"`.
    How can we change the attributes on `Route` to achieve this?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只希望在路径为`"/customers"`时，`CustomersPage`组件才会渲染。我们如何更改`Route`上的属性来实现这一点？
- en: What would be the `Route` component that could handle the `"/customers/24322"` path be? It
    should put `"24322"` in a route parameter called `customerId`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么样的`Route`组件可以处理`"/customers/24322"`路径？它应该将`"24322"`放在名为`customerId`的路由参数中。
- en: How can we catch paths that don't exist so that we can inform the user?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何捕获不存在的路径，以便通知用户？
- en: How would we implement a `search` query parameter in `CustomersPage`? So, `"/customers/?search=Cool
    Company"` would show customers with the name `"Cool Company"`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在`CustomersPage`中实现`search`查询参数？因此，`"/customers/?search=Cool Company"`将显示名称为`"Cool
    Company"`的客户。
- en: After a while, we decide to change the `"customer"` paths to `"clients"`. How
    can we implement this so that users can still use the existing `"customer"` paths
    but have the paths automatically redirect to the new `"client"` paths?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过了一会儿，我们决定将`"customer"`路径更改为`"clients"`。我们如何实现这一点，以便用户仍然可以使用现有的`"customer"`路径，但路径会自动重定向到新的`"client"`路径？
- en: Further reading
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The React Router documentation at the following link is worth going through:
    [https://reacttraining.com/react-router](https://reacttraining.com/react-router)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得一读的React Router文档链接如下：[https://reacttraining.com/react-router](https://reacttraining.com/react-router)
- en: The `react-transition-group` documentation is also worth looking at to gain
    further knowledge on transitioning components: [https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也值得查看`react-transition-group`文档，以进一步了解过渡组件：[https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)
