- en: Unit Testing with Jest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest进行单元测试
- en: Building a robust suite of unit tests that catches real bugs and doesn't flag
    false positives as we refactor our code is one of the hardest tasks we do as software
    developers. Jest is a great testing tool that helps us meet this challenge, as
    we'll find out in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个强大的单元测试套件，捕捉真正的错误并在重构代码时不会误报阳性，是我们作为软件开发人员所做的最艰巨的任务之一。Jest是一个很好的测试工具，可以帮助我们应对这一挑战，我们将在本章中了解到。
- en: Perhaps the easiest bits of an app to unit test are pure functions, because
    there are no side effects to deal with. We'll revisit the validator functions
    we built in [Chapter 7](712041e2-6abb-46fa-ad99-3aa78a357939.xhtml), *Working
    with Form*, and implement some unit tests against them in order to learn how to
    unit test pure functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 也许应用程序中最容易进行单元测试的部分是纯函数，因为没有副作用需要处理。我们将重新访问我们在[第7章](712041e2-6abb-46fa-ad99-3aa78a357939.xhtml)中构建的验证函数，*使用表单*，并对其进行一些单元测试，以便学习如何对纯函数进行单元测试。
- en: Unit testing components is the most common type of unit test we'll be carrying
    out while building our apps. We'll learn about it in detail, and leverage a library
    to help us implement tests that don't unnecessarily break when we refactor our
    code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，单元测试组件是我们将进行的最常见类型的单元测试。我们将详细了解它，并利用一个库来帮助我们实施测试，在重构代码时不会不必要地中断。
- en: We'll learn what snapshot testing is, and how we can leverage it to implement
    our tests quicker. Snapshots can be used for testing pure functions as well as
    components, so they are a very useful tool to have at our disposal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习什么是快照测试，以及如何利用它来更快地实现我们的测试。快照可以用于测试纯函数以及组件，因此它们是我们非常有用的工具。
- en: Mocking is a challenging topic because if we mock too much, we aren't really
    testing our app. However, there are certain dependencies that make sense to mock,
    such as a REST API. We'll revisit the app we built in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml), *Interacting
    with Restful APIs*, in order to implement some unit tests against it and learn
    about mocking.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一个具有挑战性的话题，因为如果我们模拟得太多，我们实际上并没有测试我们的应用程序。然而，有一些依赖关系是有意义的，比如REST API。我们将重新访问我们在[第9章](c4badffb-0c23-40cc-878c-8b598d427227.xhtml)中构建的应用程序，*与Restful
    API交互*，以便对其实施一些单元测试并学习有关模拟的知识。
- en: When implementing a suite of unit tests for our app, it is useful to know which
    bits we've tested and which bits we haven't. We'll learn how to use a code coverage
    tool to help us quickly identify areas of our app that need more unit tests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的应用程序实现一套单元测试时，了解我们已经测试过哪些部分以及哪些部分尚未测试是很有用的。我们将学习如何使用代码覆盖工具来帮助我们快速识别需要更多单元测试的应用程序区域。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Testing pure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: Testing components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Using Jest snapshot tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest快照测试
- en: Mocking dependencies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟依赖关系
- en: Getting code coverage
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取代码覆盖率
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We use the following technologies in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用以下技术：
- en: '**Node.js and `npm`**: TypeScript and React are dependent on these. Install
    them from the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和`npm`**：TypeScript和React依赖于这些。可以从以下链接安装它们：[https://nodejs.org/en/download/](https://nodejs.org/en/download)。如果您已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We''ll also need the TSLint extension (by egamma) and the Prettier extension (by
    Estben Petersen).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写我们的React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要TSLint扩展（由egamma提供）和Prettier扩展（由Estben
    Petersen提供）。'
- en: '**React shop**: We''ll be implementing unit tests on the React shop we created.
    This is available on GitHub at the following link: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React商店**：我们将在我们创建的React商店上实现单元测试。这可以在GitHub上的以下链接找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF)。'
- en: '**Chapter 9 code**: We''ll be implementing unit tests on the app we created
    in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml), *Interacting with
    RESTful APIs*. This is available on GitHub at the following link: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs/03-AxiosWithClass](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs/03-AxiosWithClass).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第9章代码**：我们将在[第9章](c4badffb-0c23-40cc-878c-8b598d427227.xhtml)中创建的应用上实现单元测试，*与RESTful
    API交互*。这可以在GitHub上的以下链接找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs/03-AxiosWithClass](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs/03-AxiosWithClass)。'
- en: In order to restore code from a previous chapter, the `LearnReact17WithTypeScript`
    repository at [https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript) can
    be downloaded. The relevant folder can then be opened in Visual Studio Code and `npm
    install` entered in the terminal to do the restore. All the code snippets in this
    chapter can be found online at the following link: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/11-UnitTesting](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/11-UnitTesting).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从之前的章节中恢复代码，可以下载`LearnReact17WithTypeScript`存储库，网址为[https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript)。然后可以在Visual
    Studio Code中打开相关文件夹，并在终端中输入`npm install`来进行恢复。本章中的所有代码片段都可以在以下链接找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/11-UnitTesting](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/11-UnitTesting)。
- en: Testing pure functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: We'll start our unit testing journey in this section by implementing a unit
    test on a pure function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中开始我们的单元测试之旅，通过对纯函数实现一个单元测试。
- en: A pure function has a consistent output value for a given set of parameter values.
    Pure functions only depend on the function arguments, and on nothing outside the
    function. These functions also don't change any of the argument values passed
    into them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数对于给定的参数值集合具有一致的输出值。纯函数仅依赖于函数参数，不依赖于函数外部的任何东西。这些函数也不会改变传递给它们的任何参数值。
- en: The fact that these functions only depend on their parameter values makes them
    straightforward to unit test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数仅依赖于它们的参数值，这使得它们很容易进行单元测试。
- en: We are going to implement a unit test on the `required` validator function we
    created in our `Form` component in the React shop we built. If you haven't already,
    open this project in Visual Studio Code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们构建的React商店中的`Form`组件中创建的`required`验证函数上实现一个单元测试。如果还没有，请在Visual Studio
    Code中打开这个项目。
- en: We are going to use Jest, which is very popular for unit testing React apps,
    as our unit testing framework. Luckily the `create-react-app` tool installs and
    configures this for us when creating a project. So, Jest is ready to be used in
    our React shop project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Jest作为我们的单元测试框架，这在测试React应用中非常流行。幸运的是，`create-react-app`工具在创建项目时已经为我们安装和配置了Jest。因此，Jest已经准备好在我们的React商店项目中使用。
- en: Creating a basic pure function test
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的纯函数测试
- en: 'Let''s create our first unit test in our project to test the `required` function
    in `Form.tsx`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中创建我们的第一个单元测试，来测试`Form.tsx`中的`required`函数：
- en: Start by creating a file called `Form.test.tsx` in the `src` folder. We'll use
    this file for our test code, to test the code in `Form.tsx`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`src`文件夹中创建一个名为`Form.test.tsx`的文件。我们将使用这个文件来编写我们的测试代码，以测试`Form.tsx`中的代码。
- en: The `test.tsx` extension is important because Jest automatically looks for files
    with this extension when finding tests to execute. Note that if our tests don't
    contain any JSX, we could use a `test.ts` extension.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.tsx`扩展名很重要，因为Jest在查找要执行的测试时会自动查找具有此扩展名的文件。请注意，如果我们的测试不包含任何JSX，我们可以使用`test.ts`扩展名。'
- en: 'Let''s import the function we want to test, along with a TypeScript type we
    need for a parameter value:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入我们想要测试的函数，以及我们需要用于参数值的TypeScript类型：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s start to create our test using the Jest `test` function:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始使用Jest的`test`函数创建我们的测试：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `test` function takes in two parameters:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数接受两个参数：'
- en: The first parameter is a message telling us whether the test passed or not,
    which will be shown in the test output
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是告诉我们测试是否通过的消息，将显示在测试输出中
- en: The second parameter is an arrow function that will contain our test
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是包含我们的测试的箭头函数
- en: 'We''ll move on to calling the `required` function with a `values` parameter
    that contains an empty `title` property:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续调用`required`函数，并使用包含空`title`属性的`values`参数：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our next task in this test is to check that the result from the `required`
    function is what we expect. We can use the Jest `expect` function to do this:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个测试中的下一个任务是检查`required`函数的结果是否符合我们的期望。我们可以使用Jest的`expect`函数来做到这一点：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We pass the variable we are checking into the `expect` function. We then chain
    a `toBe` matcher function onto this, which checks that the result from the `expect`
    function is the same as the parameter supplied to the `toBe` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的变量传递给`expect`函数。然后我们在其后链接一个`toBe`匹配函数，它检查`expect`函数的结果是否与`toBe`函数提供的参数相同。
- en: '`toBe` is one of many Jest matcher functions we can use to check a variable
    value. The full list of functions can be found at [https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBe`是我们可以用来检查变量值的许多Jest匹配函数之一。完整的函数列表可以在[https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect)找到。'
- en: 'Now that our test is complete, we can run the test by typing the following
    in the terminal:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的测试完成了，我们可以在终端中输入以下内容来运行测试：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This starts the Jest test runner in watch mode, which means that it will continuously
    run, executing tests when we change the source files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Jest测试运行程序的观察模式，这意味着它将持续运行，在更改源文件时执行测试。
- en: 'Jest will eventually find our test file, execute our test, and output the result
    to the terminal, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Jest最终会找到我们的测试文件，执行我们的测试，并将结果输出到终端，如下所示：
- en: '![](assets/5a80eb3d-465a-4d50-861d-6ea156f89e70.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a80eb3d-465a-4d50-861d-6ea156f89e70.png)'
- en: 'Let''s change the expected result in the test to make the test fail:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更改测试中的预期结果，使测试失败：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we save the test file, Jest automatically executes the test and outputs
    the failure to the terminal, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存测试文件时，Jest会自动执行测试，并将失败输出到终端，如下所示：
- en: '![](assets/a0719956-b0a4-44af-b67b-6a0b84b5f999.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a0719956-b0a4-44af-b67b-6a0b84b5f999.png)'
- en: 'Jest gives us valuable information about the failure. It tells us this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jest为我们提供了有关失败的宝贵信息。它告诉我们：
- en: Which test failed
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个测试失败了
- en: What the expected result was, in comparison to the actual result
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期结果与实际结果的比较
- en: The line in our test code where the failure occurred
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试代码中发生失败的那一行
- en: This information helps us quickly resolve test failures.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息帮助我们快速解决测试失败。
- en: 'Before we move on, let''s correct our test code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们纠正我们的测试代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we save the change, the test should now pass.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存更改时，测试现在应该通过。
- en: Understanding Jest watch options
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Jest观察选项
- en: 'After Jest executes our tests, it provides us with the following options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jest执行我们的测试后，它会提供以下选项：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These options let us specify what tests should be executed, which is really
    useful as the number of tests grows. Let''s explore some of these options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项让我们指定应该执行哪些测试，这对于测试数量增加时非常有用。让我们探索一些这些选项：
- en: 'If we press *F*, Jest will execute only the tests that have failed. In our
    code, we get confirmation that we have no failing tests:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们按下*F*，Jest将只执行失败的测试。在我们的代码中，我们得到确认我们没有失败的测试：
- en: '![](assets/92898667-2723-4795-8169-2cbe94f29d0b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92898667-2723-4795-8169-2cbe94f29d0b.png)'
- en: Let's press *F* to exit this option and take us back to all the options that
    are available.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按下*F*键退出此选项，并返回到所有可用的选项。
- en: 'Now, let''s press *P*. This allows us to test a specific file or a collection
    of files with names matching a regular expression pattern. Let''s enter `form`
    when prompted for the filename pattern:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们按下*P*。这允许我们测试特定文件或与正则表达式模式匹配的文件集合。当提示输入文件名模式时，让我们输入`form`：
- en: '![](assets/0e1a490c-e71c-469c-914e-a5571eb66a0a.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0e1a490c-e71c-469c-914e-a5571eb66a0a.png)'
- en: Our test in `Form.test.tsx` will then be executed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Form.test.tsx`中的测试将会被执行。
- en: 'We are going to leave the filename filter on and press *T*. This will allow
    us to add an additional filter by test name. Let''s enter `required`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保留文件名过滤器并按*T*。这将允许我们通过测试名称添加额外的过滤器。让我们输入`required`：
- en: '![](assets/2d2f150e-883d-487e-8e72-1d83ec81a32c.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d2f150e-883d-487e-8e72-1d83ec81a32c.png)'
- en: Our test on the `required` function will then be executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`required`函数的测试将会被执行。
- en: To clear the filters, we can press *C*.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清除过滤器，我们可以按*C*。
- en: If we receive an error—watch is not supported without git/hg, please use --watchAll,
    this will be because our project isn't in a Git repository. We can resolve the
    issue by entering the `git init` command in the Terminal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到错误信息——watch不支持没有git/hg，请使用--watchAll，这是因为我们的项目不在Git存储库中。我们可以通过在终端中输入`git
    init`命令来解决这个问题。
- en: We have a good handle on the options available to execute our tests now.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经很好地掌握了可用于执行测试的选项。
- en: Adding structure to unit test results
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单元测试结果添加结构
- en: As we implement more unit tests, it is useful to add some structure to the unit
    test results so that we can read them more easily. There is a Jest function called
    `describe` that we can use to group the results of certain tests together. It
    may make reading test results easier if all the tests for a function are grouped
    together.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们实施更多的单元测试，将单元测试结果添加一些结构是很有用的，这样我们就可以更容易地阅读它们。有一个名为`describe`的Jest函数，我们可以用它来将某些测试的结果分组在一起。如果一个函数的所有测试都被分组在一起，可能会更容易阅读测试结果。
- en: 'Let''s do this and refactor the unit test we created earlier, using the `describe`
    function in Jest:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做，并使用Jest中的`describe`函数重构我们之前创建的单元测试：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The describe function takes in two parameters:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: describe函数接受两个参数：
- en: The first parameter is the title for the group of tests. We have used the function
    name we are testing for this.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是测试组的标题。我们已经为此使用了我们正在测试的函数名称。
- en: The second parameter is an arrow function that contains the tests to execute.
    We have placed our original test here.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是包含要执行的测试的箭头函数。我们已经将我们的原始测试放在这里。
- en: 'When we save our test file, the tests will automatically run, and our improved
    output is shown in the terminal with our test result under a `required` heading:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存我们的测试文件时，测试将自动运行，并且我们改进的输出将显示在终端上，测试结果显示在`required`标题下：
- en: '![](assets/30db856d-4fbd-4bd0-8aa9-57bd32a074a8.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30db856d-4fbd-4bd0-8aa9-57bd32a074a8.png)'
- en: We're starting to get familiar with Jest, having implemented and executed a
    unit test. In the next section, we will move on to the more complex topic of unit
    testing components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始熟悉Jest，已经实现并执行了一个单元测试。在下一节中，我们将继续进行更复杂的单元测试组件的主题。
- en: Testing components
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: Unit testing a component is challenging because a component has dependencies
    such as the browser's DOM and the React library. How exactly can we render a component
    in our test code before we do the necessary checks? How can we trigger DOM events
    when coding a user interaction, such as clicking a button?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的单元测试是具有挑战性的，因为组件具有依赖项，如浏览器的DOM和React库。在我们进行必要的检查之前，我们如何在测试代码中渲染组件？在编写用户交互的代码时，如何触发DOM事件，比如点击按钮？
- en: We'll answer these questions in this section, by implementing some tests on
    the `ContactUs` component we created in our React shop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中回答这些问题，通过对我们在React商店中创建的`ContactUs`组件进行一些测试来实现。
- en: Creating a basic component test
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本组件测试
- en: 'We are going to start by creating a unit test to verify that submitting the
    Contact Us form without filling in the fields results in errors being displayed
    on the page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个单元测试，以验证在不填写字段的情况下提交“联系我们”表单会在页面上显示错误：
- en: We are going to implement a unit test on the `ContactUs` component. We'll start
    by creating a file called `ContactUs.test.tsx` in the `src` folder.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对`ContactUs`组件进行单元测试。我们将首先在`src`文件夹中创建一个名为`ContactUs.test.tsx`的文件。
- en: 'We are going to use `ReactDOM` to render a test instance of the `ContactUs`
    component. Let''s import `React` and `ReactDOM`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`ReactDOM`来渲染`ContactUs`组件的测试实例。让我们导入`React`和`ReactDOM`：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are going to simulate the form submit event, so let''s import the `Simulate`
    function from the React testing utilities:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将模拟表单提交事件，因此让我们从React测试工具中导入`Simulate`函数：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s now import the component we need to test:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们导入需要测试的组件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to import the submission result interface from `Form.tsx` as well:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从`Form.tsx`中导入提交结果接口：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s start to create our test using the Jest `test` function, with the results
    outputting to a `ContactUs` group:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始使用Jest的`test`函数创建我们的测试，并将结果输出到`ContactUs`组。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first task in our test implementation is to create our React component
    in the DOM:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试实现中的第一个任务是在DOM中创建我们的React组件：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we create a container `div` tag and then render our `ContactUs` component
    into this. We have also created a handler for the `onSubmit` prop, which returns
    success. The last line in the test cleans up by removing the DOM elements that
    were created in the test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个容器`div`标签，然后将我们的`ContactUs`组件渲染到其中。我们还为`onSubmit`属性创建了一个处理程序，它返回成功。测试中的最后一行通过移除测试中创建的DOM元素来进行清理。
- en: 'Next, we need to get a reference to the form, and then submit it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取对表单的引用，然后提交它：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the step-by-step description:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一步一步的描述：
- en: We use the `querySelector` function, passing in the `form` tag to get a reference
    to the `form` tag.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`querySelector`函数，传入`form`标签来获取对`form`标签的引用。
- en: We then check that the form is not `null` by using the Jest `expect` function
    with the `not` and `toBeNull` functions chained together.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们通过使用Jest的`expect`函数和`not`和`toBeNull`函数链式调用来检查表单是否不是`null`。
- en: The `submit` event is simulated using the `Simulate` function from the React
    testing utilities. We use an `!` after the `form` variable to inform the TypeScript
    compiler that it is not `null`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React测试工具中的`Simulate`函数来模拟`submit`事件。我们在`form`变量后面使用`!`来告诉TypeScript编译器它不是`null`。
- en: 'Our final task is to check that the validation errors are displayed:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最终任务是检查验证错误是否显示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see this step-by-step:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来看：
- en: We use the `querySelectorAll` function on the container DOM node, passing in
    a CSS selector to find the `span` tags that should contain the errors
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在容器DOM节点上使用`querySelectorAll`函数，传入一个CSS选择器来查找应该包含错误的`span`标签
- en: We then use the Jest `expect` function to verify that two errors are displayed
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们使用Jest的`expect`函数来验证页面上显示了两个错误
- en: 'When the test runs, it should pass successfully, giving us two passing tests:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试运行时，它应该成功通过，给我们两个通过的测试：
- en: '![](assets/7f8227b3-6643-4c54-bfa8-e879a79166c7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7f8227b3-6643-4c54-bfa8-e879a79166c7.png)'
- en: In this test, Jest is rendering the component in a fake DOM. The form `submit`
    event is also simulated, using the `simulate` function from standard React testing
    utilities. So, there's a lot of mocking going on in order to facilitate an interactive
    component test.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，Jest在一个虚拟DOM中渲染组件。表单`submit`事件也是通过标准的React测试工具中的`simulate`函数模拟的。因此，为了方便交互式组件测试，需要进行大量的模拟。
- en: Also note that we are referencing internal implementation details in our test
    code. We reference a `form` tag, along with a `form-error` CSS class. What if
    we later change this CSS class name to `contactus-form-error`? Our test would
    break, without there necessarily being a problem with our app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，我们在测试代码中引用了内部实现细节。我们引用了一个`form`标签，以及一个`form-error`CSS类。如果我们以后将此CSS类名称更改为`contactus-form-error`，我们的测试将会失败，而我们的应用可能并没有问题。
- en: This is called a **false positive**, and can make code bases with these kinds
    of tests very time-consuming to change.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**false positive**，并且可以使具有这些测试的代码库非常耗时。
- en: Improving our tests with react-testing-library
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-testing-library改进我们的测试
- en: react-testing-library is a set of utilities that helps us write maintainable
    tests for React components. It focuses heavily on helping us remove implementation
    details from our test code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: react-testing-library是一组工具，帮助我们为React组件编写可维护的测试。它主要帮助我们从测试代码中删除实现细节。
- en: We'll use this library to remove the CSS class references in our test code,
    and also the tight coupling to React's event system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用这个库来从我们的测试代码中删除CSS类引用，以及与React事件系统的紧耦合。 '
- en: Installing react-testing-library
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装react-testing-library
- en: 'Let''s install `react-testing-library` first as a development dependency via
    the terminal:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过终端安装`react-testing-library`作为开发依赖：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After a few seconds, this will be added to our project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，这将被添加到我们的项目中。
- en: Removing CSS class references from our tests
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的测试中删除CSS类引用
- en: 'We''ll make our first improvement to our test by removing the dependencies
    on the `form-error` CSS class. Instead, we will get a reference to the errors
    via the error text, which is what the user sees onscreen and not an implementation
    detail:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过删除对`form-error`CSS类的依赖来改进我们的测试。相反，我们将通过错误文本获取错误的引用，这是用户在屏幕上看到的，而不是实现细节：
- en: 'We''ll import a `render` function from `react-testing-library`, which we will
    now use to render our component. We''ll also import a `cleanup` function, which
    we''ll use at the end of our tests to remove the test component from the DOM:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`react-testing-library`导入一个`render`函数，现在我们将使用它来渲染我们的组件。我们还将导入一个`cleanup`函数，在测试结束时我们将使用它来从DOM中移除测试组件：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can render our component using the `render` function we have just imported,
    rather than using `ReactDOM.render`, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们刚刚导入的`render`函数来渲染我们的组件，而不是使用`ReactDOM.render`，如下所示：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We get the container DOM node back in a `container` variable, along with a `getallByText` function,
    which we'll use to get a reference to the displayed errors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将容器DOM节点存储在`container`变量中，还有一个`getallByText`函数，我们将使用它来获取显示的错误的引用。
- en: 'Let''s now use the `getAllByText` function to get the errors displayed on the
    page:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用`getAllByText`函数来获取页面上显示的错误：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last change we are going to make is to clean up our DOM at the end of the
    test using the `cleanup` function we just imported, rather than `ReactDOM.unmountComponentAtNode`.
    We are also going to do this outside our test, in Jest''s `afterEach` function.
    Our completed test should now look like the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的最后一项更改是在测试结束时使用我们刚刚导入的`cleanup`函数清理我们的DOM，而不是`ReactDOM.unmountComponentAtNode`。我们还将在Jest的`afterEach`函数中执行此操作。我们完成的测试现在应该如下所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the test runs, it should still execute okay and the tests should pass.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，它应该仍然正常执行，并且测试应该通过。
- en: Using fireEvent for user interaction
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`fireEvent`进行用户交互
- en: 'We are now going to switch to depending on the native event system, rather
    than React''s event system which sits on top of it. This gets us closer to testing
    what happens when users are using our app, and increases our confidence in our
    test:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转而依赖于本机事件系统，而不是React的事件系统，后者位于其之上。这使我们更接近测试用户在使用我们的应用时发生的情况，并增加了我们对测试的信心：
- en: 'Let''s start by adding the `fireEvent` function to the import statement from
    `react-testing-library`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先通过从`react-testing-library`导入语句中添加`fireEvent`函数：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are going to add the `getByText` function to the destructured variables
    from the call to the `render` function:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在对`render`函数的调用中解构变量时添加`getByText`函数：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can also remove the destructured `container` variable, as that won't be needed
    anymore.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以删除解构的`container`变量，因为它将不再需要。
- en: 'We can then use this function to get a reference to the Submit button. After
    that, we can use the `fireEvent` function we imported to click the button:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用此函数获取对提交按钮的引用。之后，我们可以使用我们导入的`fireEvent`函数来点击按钮：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous code that referenced the `form` tag has now been removed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前引用`form`标签的代码现在已经被移除。
- en: When the test runs, it still passes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，它仍然通过。
- en: So, our test references items that the user sees, rather than implementation
    details, and is far less likely to unexpectedly break.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的测试引用用户看到的项目，而不是实现细节，并且不太可能出现意外中断。
- en: Creating a second test for a valid form submission
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为有效的表单提交创建第二个测试
- en: 'Now that we have got the gist of how to write robust tests, let''s add a second
    test to check that no validation errors are shown when the form is filled incorrectly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了如何编写健壮测试的要领，让我们添加第二个测试，检查当表单填写不正确时是否不显示验证错误：
- en: 'We''ll start by creating a new test in our `ContactUs` group:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从我们的`ContactUs`组中创建一个新的测试：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll render the component in the same way as the first test, but destructuring
    slightly different variables:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以与第一个测试相同的方式渲染组件，但是解构稍有不同的变量：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在：
- en: We'll need the `container` object to check whether there are any errors displayed
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将需要`container`对象来检查是否显示了任何错误
- en: We'll use the `getByText` function to locate the Submit button
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`getByText`函数来定位提交按钮
- en: We'll use the `getByLabelText` function to get references to our inputs
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`getByLabelText`函数来获取对我们输入的引用
- en: 'We can now get a reference to the name input using the `getByLabelText` function.
    After that, we do a little check to verify that the name input does exist:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`getByLabelText`函数获取对名称输入的引用。之后，我们进行一些检查，以验证名称输入确实存在：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then need to simulate the user filling in this input. We do this by calling
    the native `change` event, passing in the required event argument, which includes
    our input value:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要模拟用户填写此输入。我们通过调用本机的`change`事件来实现这一点，传入所需的事件参数，其中包括我们的输入值：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have simulated the user setting the name field as `Carl`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经模拟了用户将名称字段设置为`Carl`。
- en: We use a type assertion after the call to `getByLabelText` to inform the TypeScript
    compiler that the returned element is of type `HTMLInputElement`, so that we don't
    get a compilation error.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`getByLabelText`后，我们使用类型断言来通知TypeScript编译器返回的元素是`HTMLInputElement`类型，这样我们就不会得到编译错误。
- en: 'We then can follow the same pattern for filling in the email field:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以按照相同的模式填写电子邮件字段：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we have simulated the user setting the email field as `carl.rippon@testmail.com`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们模拟用户将电子邮件字段设置为`carl.rippon@testmail.com`。
- en: 'We can then submit the form by clicking the Submit button, in the same way
    as in our first test:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过点击提交按钮来提交表单，就像我们第一次测试时一样：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our final task is to verify there are no errors displayed on the screen. Unfortunately,
    we can''t use the `getAllByText` function we used in the last test, as this expects
    to find at least one element, and in our case we expect there to be no elements.
    So, before we carry out this check, we are going to add a wrapping `div` tag around
    errors. Let''s go to `Form.tsx` and do this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后任务是验证屏幕上没有显示错误。不幸的是，我们不能像上次测试中使用`getAllByText`函数，因为这个函数期望至少找到一个元素，而在我们的情况下，我们期望没有元素。因此，在进行此检查之前，我们将在错误周围添加一个包装的`div`标签。让我们去`Form.tsx`并做这个：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've given the `div` tag a `data-testid` attribute, which we'll use in our
    test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给`div`标签添加了一个`data-testid`属性，我们将在我们的测试中使用它。
- en: 'Let''s go back to our test. We can now locate the `div` tag around the errors
    using the `data-testid` attribute. We can then verify that this `div` tag is `null`,
    because no errors are displayed:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的测试。我们现在可以使用`data-testid`属性定位围绕错误的`div`标签。然后我们可以验证这个`div`标签是`null`，因为没有显示错误：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the test runs in our suite of tests, we'll find we now have three passing
    tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试在我们的测试套件中运行时，我们会发现现在有三个通过的测试。
- en: Isn't referencing the `data-testid` attribute an implementation detail, though?
    The user doesn't see or care about the `data-testid` attribute—this seems to contradict
    what we said earlier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，引用`data-testid`属性是一个实现细节，对吗？用户看不到或关心`data-testid`属性，这似乎与我们之前说的相矛盾。
- en: It is kind of an implementation detail, but it is specifically for our test.
    So, an implementation refactor is unlikely to unexpectedly break our test.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点是一个实现细节，但它是专门为我们的测试而设计的。因此，实现重构不太可能意外地破坏我们的测试。
- en: In the next section, we are going to add another test, this time using Jest
    snapshot tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加另一个测试，这次使用Jest快照测试。
- en: Using Jest snapshot tests
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest快照测试
- en: A snapshot test is one where Jest compares all the elements and attributes in
    a rendered component to a previous snapshot of the rendered component. If there
    are no differences, then the test passes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试是Jest将渲染组件的所有元素和属性与先前渲染组件的快照进行比较的测试。如果没有差异，那么测试通过。
- en: 'We are going to add a test to verify the `ContactUs` component renders OK,
    by checking the DOM nodes using a Jest snapshot test:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个测试来验证`ContactUs`组件是否正常渲染，通过使用Jest快照测试来检查DOM节点：
- en: 'We''ll create a test with the title `Renders okay` in the `ContactUs` group
    of tests, rendering the component in the same way as previously:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`ContactUs`测试组中创建一个标题为“渲染正常”的测试，以与以前相同的方式渲染组件：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now add the line to carry out the snapshot test:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加一行来执行快照测试：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Doing a snapshot test is pretty simple. We pass the DOM node we want to compare
    into Jest's `expect` function, and then chain the `toMatchSnapshot` function after
    it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 进行快照测试非常简单。我们将要比较的DOM节点传递给Jest的`expect`函数，然后在其后链接`toMatchSnapshot`函数。
- en: 'When the test runs, we''ll get confirmation that the snapshot has been written
    in the terminal, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，我们将在终端中得到快照已被写入的确认，如下所示：
- en: '![](assets/40d1d8d8-f581-4f3d-abdd-f860f1e4fa42.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/40d1d8d8-f581-4f3d-abdd-f860f1e4fa42.png)'
- en: 'If we look at our `src` folder, we''ll see it now contains a `__snapshots__` folder.
    If we look in this folder, we''ll see a file called `ContactUs.test.tsx.snap`.
    Opening the file, we''ll see the following content:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看我们的`src`文件夹，我们会看到现在包含一个`__snapshots__`文件夹。如果我们查看这个文件夹，我们会看到一个名为`ContactUs.test.tsx.snap`的文件。打开文件，我们会看到以下内容：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Some of the content is stripped out in this snippet, but we get the gist: we
    have a copy of every DOM node including their attributes from the `container` element
    we passed into the `toMatchSnapshot` function.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段中有一些内容被剥离了，但我们明白：我们从传入`toMatchSnapshot`函数的`container`元素中得到了每个DOM节点的副本，包括它们的属性。
- en: This test is heavily coupled to our implementation, though. So, any change to
    our DOM structure or attributes will break our test.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这个测试与我们的实现紧密耦合。因此，对DOM结构或属性的任何更改都将破坏我们的测试。
- en: 'As an example, let''s add a `div` tag inside our `Form` component in `Form.tsx`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 举个例子，在`Form.tsx`中的`Form`组件中添加一个`div`标签：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the test runs, we''ll see confirmation that our test has broken. Jest
    does a great job of showing us the difference in the terminal:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，我们将看到确认我们的测试已经失败。Jest在终端中很好地显示了差异：
- en: '![](assets/eeb2f477-38cd-460d-bfd0-910b640cf3c6.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eeb2f477-38cd-460d-bfd0-910b640cf3c6.png)'
- en: 'We are happy that this is a valid change, so we can press *U* to let Jest update
    the snapshot:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们很高兴这是一个有效的改变，所以我们可以按*U*让Jest更新快照：
- en: '![](assets/ee14c380-8e94-4ba6-884f-33891162b018.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee14c380-8e94-4ba6-884f-33891162b018.png)'
- en: So, are snapshot tests a good thing or a bad thing? They are volatile because
    they are tightly coupled to the implementation of a component. However they are
    super-easy to create, and when they do break, Jest does a great job of highlighting
    the problem area and allowing us to efficiently correct the test snapshot. They
    are well worth a try to see if your team gains value from them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，快照测试是好事还是坏事呢？它们是不稳定的，因为它们与组件的实现紧密耦合。但是它们非常容易创建，当它们出现问题时，Jest会很好地突出显示问题区域，并允许我们有效地纠正测试快照。它们非常值得一试，看看你的团队是否从中获得价值。
- en: We have learned a lot already in this chapter about unit testing React and TypeScript
    apps. Next up, we'll learn how we can mock dependencies.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学到了很多关于单元测试React和TypeScript应用程序的知识。接下来，我们将学习如何模拟依赖关系。
- en: Mocking dependencies
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟依赖
- en: Mocking a component's dependencies can make the component easier to test. However,
    if we mock too many things, is the test really verifying that the component will
    work in our real app?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟组件的依赖关系可以使组件更容易测试。但是，如果我们模拟了太多东西，测试是否真的在验证组件在我们的真实应用程序中是否能正常工作呢？
- en: Establishing what to mock is one of the hardest tasks when writing unit tests.
    There are some things that make a lot of sense to mock, though, such as REST APIs.
    A REST API is a pretty fixed contract between the frontend and backend. Mocking
    a REST API also allows our tests to run nice and fast.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要模拟的内容是编写单元测试时最困难的任务之一。有一些东西是有意义模拟的，比如REST API。REST API是前端和后端之间的一个相当固定的契约。模拟REST
    API也可以让我们的测试运行得又快又顺利。
- en: In this section, we'll eventually learn how to mock REST API calls made with
    `axios`. First, though, we'll learn about Jest's function mocking feature.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们最终将学习如何模拟使用`axios`进行的REST API调用。不过首先，我们将学习Jest的函数模拟功能。
- en: Using a mock function in Jest
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jest中使用模拟函数
- en: 'We are going to make another improvement to the test that verified that submitting
    the Contact Us form without filling in the fields results in errors being displayed
    on the page. We are going to add an additional check, to make sure the submit
    handler is not executed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对验证提交“联系我们”表单而未填写字段会导致页面显示错误的测试进行另一个改进。我们将添加一个额外的检查，以确保提交处理程序不会被执行：
- en: 'Let''s go back to the first component test we wrote: `ContactUs.test.tsx`.
    We manually created a `handleSubmit` function that we referenced in our instance
    of the `ContactUs` component. Let''s change this to a Jest mock function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们编写的第一个组件测试：`ContactUs.test.tsx`。我们手动创建了一个`handleSubmit`函数，我们在`ContactUs`组件的实例中引用了它。让我们将其更改为Jest模拟函数：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our test will run correctly, as it did before, but this time Jest is mocking
    the function for us.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将像以前一样正确运行，但这次是Jest为我们模拟函数。
- en: 'Now that Jest is mocking the submit handler, we can check whether it was called
    as an additional check at the end of our test. We do this using the `not` and `toBeCalled`
    Jest matcher functions:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在Jest正在模拟提交处理程序，我们可以在测试结束时检查它是否被调用。我们使用`not`和`toBeCalled` Jest匹配函数来做到这一点：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is really nice, because we've not only simplified our submit handler function,
    but we've also really easily added a check to verify that it hasn't been called.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很好，因为我们不仅简化了我们的提交处理程序函数，而且还很容易地添加了一个检查来验证它是否被调用。
- en: 'Let''s move on to the second test we implemented, which verified that a valid Contact
    Us form was submitted okay:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实施的第二个测试，验证`Contact Us`表单是否被正确提交：
- en: 'We''ll again change the `handleSubmit` variable to reference a Jest mock function:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次更改`handleSubmit`变量以引用Jest模拟函数：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s verify that the submit handler is called. We do this using the `toBeCalledTimes` Jest
    function to pass in the number of times we expect the function to be called, which
    is `1` in our case:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证提交处理程序是否被调用。我们使用`toBeCalledTimes` Jest函数传入我们期望函数被调用的次数，这在我们的情况下是`1`：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the test executes, it should still pass.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试执行时，它仍应该通过。
- en: 'There is one other useful check we can do. We know that the submit handler
    is being called, but does it have the correct arguments? We can use the `toBeCalledWith`
    Jest function to check this:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个有用的检查我们可以做。我们知道提交处理程序正在被调用，但它是否有正确的参数？我们可以使用`toBeCalledWith` Jest函数来检查这一点：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Again, when the test executes, it should still pass.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当测试执行时，它仍应该通过。
- en: So, by letting Jest mock our submit handler, we've quickly added a few valuable
    additional checks to our tests.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过让Jest模拟我们的提交处理程序，我们很快为我们的测试添加了一些有价值的额外检查。
- en: Mocking Axios with axios-mock-adapter
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`axios-mock-adapter`模拟Axios
- en: 'We are going to move to the project we created in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml), *Interacting
    with Restful APIs.* We are going to add a test that verifies the posts are rendered
    on the page correctly. We''ll mock the JSONPlaceholder REST API so we are in control
    of the data that is returned, and so that our test will execute nicely and quickly:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转移到我们在[第9章](c4badffb-0c23-40cc-878c-8b598d427227.xhtml)中创建的项目，*与Restful API交互*。我们将添加一个测试，验证帖子是否正确呈现在页面上。我们将模拟JSONPlaceholder
    REST API，这样我们就可以控制返回的数据，使我们的测试可以顺利快速地执行：
- en: 'First, we need to install the `axios-mock-adapter` package as a development
    dependency:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`axios-mock-adapter`包作为开发依赖：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We are also going to install `react-testing-library`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将安装`react-testing-library`：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The project already has a test file, `App.test.tsx`, which includes a basic
    test on the `App` component. We'll remove the test, but leave the imports, as
    we'll need these.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目已经有一个测试文件`App.test.tsx`，其中包括对`App`组件的基本测试。我们将删除测试，但保留导入，因为我们需要这些。
- en: 'In addition, we are going to import some functions from react-testing-library, `axios`
    and a `MockAdapter` class that we''ll use to mock the REST API calls:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将从react-testing-library导入一些函数，`axios`和一个`MockAdapter`类，我们将使用它来模拟REST API调用：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s add the usual cleanup line that will execute after each test:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在每个测试后添加通常的清理行：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''ll create our test with an appropriate description, and place it under
    an `App` group:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用适当的描述创建我们的测试，并将其放在`App`组下：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that the `arrow` function is marked with the `async` keyword. This is because
    we'll eventually make an asynchronous call in our test.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`arrow`函数标有`async`关键字。这是因为我们最终会在测试中进行异步调用。
- en: 'Our first job in our test is to mock the REST API call using the `MockAdapter`
    class:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在测试中的第一项工作是使用`MockAdapter`类模拟REST API调用：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We use the `onGet` method to define the response HTTP status code and body we
    want when the URL to get the posts is called. So, the call to the REST API should
    return two posts containing our test data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`onGet`方法来定义调用获取帖子的URL时所需的响应HTTP状态码和主体。因此，对REST API的调用应该返回包含我们的测试数据的两个帖子。
- en: 'We need to check that the posts are rendered correctly. In order to do this,
    we are going to add a `data-testid` attribute to the unordered posts list in `App.tsx`.
    We are also only going to render this when we have data:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要检查帖子是否正确渲染。为了做到这一点，我们将在`App.tsx`中的无序帖子列表中添加`data-testid`属性。我们只在有数据时才会渲染这个。
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Moving back to our test, we can now render the component and destructure the
    `getByTestId` function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们现在可以渲染组件并解构`getByTestId`函数：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need to check that the rendered posts are correct, but this is tricky, because
    these are rendered asynchronously. We need to wait for the posts list to be added
    to the DOM before doing our checks. We can do this using the `waitForElement`
    function from react-testing-library:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要检查渲染的帖子是否正确，但这很棘手，因为这些是异步渲染的。我们需要在进行检查之前等待帖子列表被添加到DOM中。我们可以使用react-testing-library中的`waitForElement`函数来实现这一点：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `waitForElement` function takes in an arrow function as a parameter, which
    in turn returns the element we are waiting for. We use the `getByTestId` function
    to get the posts list, which finds it using its `data-testid` attribute.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForElement`函数接受一个箭头函数作为参数，然后返回我们正在等待的元素。我们使用`getByTestId`函数获取帖子列表，它使用`data-testid`属性找到它。'
- en: 'We can then use a snapshot test to check that the content in the posts list
    is correct:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用快照测试来检查帖子列表中的内容是否正确：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before our test can execute successfully, we need to make a change in `tsconfig.json`
    so that the TypeScript compiler knows that we are using `async` and `await`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的测试可以成功执行之前，我们需要在`tsconfig.json`中进行更改，以便TypeScript编译器知道我们正在使用`async`和`await`：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the test executes, the snapshot is created. If we inspect the snapshot,
    it will contain the two list items containing data that we told the REST API to
    return.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试执行时，将创建快照。如果我们检查快照，它将包含两个包含我们告诉REST API返回的数据的列表项。
- en: We've learned about some great features in Jest and react-testing-library that
    help us write maintainable tests on pure functions and React components.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Jest和react-testing-library中一些很棒的功能，这些功能帮助我们编写可维护的纯函数和React组件的测试。
- en: How can we tell what bits of our app are covered by unit tests, though—and,
    more importantly, what bits are uncovered? We'll find out in the next section.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何知道我们的应用程序的哪些部分由单元测试覆盖了，更重要的是，哪些部分没有覆盖？我们将在下一节中找出答案。
- en: Getting code coverage
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码覆盖率
- en: Code coverage is how we refer to how much of our app code is covered by unit
    tests. As we write our unit tests, we'll have a fair idea of what code is covered
    and what code is not covered, but as the app grows and time passes, we'll lose
    track of this.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是指我们的应用代码有多少被单元测试覆盖。当我们编写单元测试时，我们会对覆盖了哪些代码和哪些代码没有覆盖有一个大致的了解，但随着应用的增长和时间的推移，我们会失去对此的追踪。
- en: 'Jest comes with a great code coverage tool, so we don''t have to keep what
    is covered in our heads. In this section, we''ll use this to discover the code
    coverage in the project we worked on in the previous section, where we mocked
    `axios`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Jest带有一个很棒的代码覆盖工具，所以我们不必记住哪些代码被覆盖了。在本节中，我们将使用这个工具来发现我们在上一节中工作的项目中的代码覆盖情况，我们在那里模拟了`axios`：
- en: 'Our first task is to add an `npm` script that will run the tests with the coverage
    tracking tool switched on. Let''s add a new script called `test-coverage` that
    includes the `--coverage` option when `react-scripts` is executed:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是添加一个`npm`脚本，该脚本将在打开覆盖跟踪工具时运行测试。让我们添加一个名为`test-coverage`的新脚本，其中包括在执行`react-scripts`时使用`--coverage`选项：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then run this command in the terminal:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在终端中运行这个命令：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After a few seconds, Jest will render some nice high-level coverage statistics
    on each file in the terminal:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，Jest将在终端上呈现每个文件的高级覆盖统计信息：
- en: '![](assets/c426c06b-40a8-412f-9e86-ae592f821802.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c426c06b-40a8-412f-9e86-ae592f821802.png)'
- en: 'If we look in our project file structure, we''ll see that a `coverage` folder
    has been added with a `lcov-report` folder within it. There is an `index.html`
    file within the `lcov-report` folder that contains more detailed information on
    the coverage within each file. Let''s open this and have a look:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看项目文件结构，我们会看到一个`coverage`文件夹已经添加了一个`lcov-report`文件夹。`lcov-report`文件夹中有一个`index.html`文件，其中包含了每个文件的覆盖率的更详细信息。让我们打开它并看一看：
- en: '![](assets/3db8e56c-d029-4380-bcdd-cab3127e597a.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3db8e56c-d029-4380-bcdd-cab3127e597a.png)'
- en: We see the same information as presented in the terminal.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了与终端中呈现的相同信息。
- en: What do these four columns of statistics mean?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这四列统计数据的含义是什么？
- en: The `Statements` column shows how many statements in the code have been executed
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Statements`列显示了代码中执行了多少个语句'
- en: The `Branches` column shows how many branches in the conditional statements in
    the code have been executed
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Branches`列显示了代码中条件语句中执行了多少分支'
- en: The `Function` column shows how many functions in the code have been called
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function`列显示了代码中调用了多少个函数'
- en: 'The `Line` column shows how many lines in the code have been executed. Generally,
    this will be the same as the `Statements` figure. However, it can be different
    if multiple statements have been placed on a single line. For example, the following
    is counted as a single line, but two statements:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Line`列显示了代码中执行了多少行。通常，这将与`Statements`数字相同。但是，如果将多个语句放在一行上，它可能会有所不同。例如，以下内容被计为一行，但包含两个语句：'
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can drill into each file to find which specific bits of code aren''t covered.
    Let''s click on the `App.tsx` link:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以深入到每个文件中找出哪些具体的代码没有被覆盖。让我们点击`App.tsx`链接：
- en: '![](assets/12137a97-2add-4bdf-88a5-0312a8c06d0a.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12137a97-2add-4bdf-88a5-0312a8c06d0a.png)'
- en: The `1x` with a green background to the left of the lines of code indicates
    that those lines have been executed by our tests once. The code highlighted in
    red is code that isn't covered by our tests.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧带有绿色背景的`1x`表示这些代码行已被我们的测试执行了一次。红色高亮显示的代码是我们的测试未覆盖到的代码。
- en: So, getting coverage statistics and identifying additional tests that we may
    want to implement is pretty easy. It's something well worth using to give us confidence
    that our app is well-tested.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，获取覆盖率统计信息和确定我们可能想要实现的其他测试是相当容易的。这是非常值得使用的，可以让我们确信我们的应用程序经过了充分的测试。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to test pure functions written in TypeScript
    using Jest. We simply execute the function with the parameters we want to test,
    and use Jest's `expect` function chained with one of Jest's matcher functions, such
    as `toBe`, to validate the result.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了如何使用Jest测试用TypeScript编写的纯函数。我们只需使用我们想要测试的参数执行函数，并使用Jest的`expect`函数与Jest的匹配器函数之一，比如`toBe`，来验证结果。
- en: We looked at how to interact with Jest's test runner, and how to apply filters
    so that only the tests we are focusing on are executed. We learned that testing
    React and TypeScript components is more involved than testing pure functions,
    but Jest and react-testing-library give us a great deal of help.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了如何与Jest的测试运行器交互，以及如何应用过滤器，以便只执行我们关注的测试。我们了解到测试React和TypeScript组件比测试纯函数更复杂，但Jest和react-testing-library为我们提供了很大的帮助。
- en: We also learned how to render a component using the `render` function, and how
    to interact with and inspect elements using various functions such as `getByText` and
    `getLabelByText` from react-testing-library.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何使用`render`函数渲染组件，以及如何使用各种函数与检查元素进行交互，比如来自react-testing-library的`getByText`和`getLabelByText`。
- en: We learned that we can easily test asynchronous interactions using the `waitForElement` function
    in react-testing-library as well. We now understand the benefit of not referencing
    implementation details in our tests, which will help us build more robust tests.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用react-testing-library中的`waitForElement`函数轻松测试异步交互。我们现在明白了在测试中不引用实现细节的好处，这将帮助我们构建更健壮的测试。
- en: We also discussed Jest's clever snapshot testing tool. We looked at how these
    tests can regularly break, but also why they are incredibly easy to create and
    change.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Jest的巧妙快照测试工具。我们看到这些测试经常会出问题，但也知道它们非常容易创建和更改的原因。
- en: The ability to mock and spy into functions is another great Jest feature we
    now know about. Checking that functions for component event handlers have been
    called with the right parameters can really add value to our tests.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和监视函数的能力是另一个我们现在了解的很棒的Jest功能。检查组件事件处理程序的函数是否以正确的参数被调用，确实可以为我们的测试增加价值。
- en: We discussed the `axios-mock-adapter` library which we can use for mocking `axios`
    REST API requests. This allows us to easily test container components that interact
    with RESTful APIs.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了`axios-mock-adapter`库，我们可以用它来模拟`axios` REST API请求。这使我们能够轻松测试与RESTful API交互的容器组件。
- en: We now know how to quickly identify the additional tests that we need to implement
    to give us confidence that our app is well-tested. We created an `npm` script
    command to enable us to do this, using `react-scripts` and the `--coverage` option.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何快速确定我们需要实现的额外测试，以确保我们的应用程序经过了充分的测试。我们创建了一个`npm`脚本命令来实现这一点，使用`react-scripts`和`--coverage`选项。
- en: Overall, we now have the knowledge and the tools to robustly create unit tests
    for our apps with Jest.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们现在具有知识和工具，可以使用Jest为我们的应用程序稳健地创建单元测试。
- en: Jasmine and Mocha are two popular alternative testing frameworks to Jest. The
    big advantage of Jest is that it is configured by `create-react-app` to work out
    the box. We would have to configure Jasmine and Mocha manually if we wanted to
    use them. Jasmine and Mocha are worth considering, though, if your team is already
    experienced with either of these tools, rather than learning another testing framework.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine和Mocha是两个流行的替代测试框架，与Jest相比的一个巨大优势是它被`create-react-app`配置为开箱即用。如果我们想使用它们，我们将不得不手动配置Jasmine和Mocha。然而，如果您的团队已经熟悉其中任何一个工具，而不是学习另一个测试框架，那么Jasmine和Mocha也值得考虑。
- en: Enzyme is another popular library used with Jest to test React apps. It supports
    shallow rendering, which is a way of rendering only the top-level elements in
    a component and not child components. It is well worth exploring, but remember
    that the more we mock, the further from the truth we get, and the less confidence
    we have that our app is well-tested.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme是另一个与Jest一起用于测试React应用程序的流行库。它支持浅渲染，这是一种仅渲染组件中顶层元素而不是子组件的方法。这是值得探索的，但请记住，我们模拟得越多，我们离真相就越远，我们对应用程序是否经过充分测试的信心就越少。
- en: Questions
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Let's say we are implementing a Jest test and we have a variable called `result`,
    which we want to check isn't `null`. How can we do this with Jest matcher functions?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们正在实施一个Jest测试，并且我们有一个名为`result`的变量，我们想要检查它不是`null`。我们如何使用Jest匹配器函数来实现这一点？
- en: 'Let''s say we have a variable called `person` that is of type `IPerson`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`person`的变量，类型为`IPerson`：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We want to check that the `person` variable is `{ id: 1, name: "bob" }`. How
    can we do this with Jest matcher functions?'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '我们想要检查`person`变量是否为`{ id: 1, name: "bob" }`。我们如何使用Jest匹配器函数来实现这一点？'
- en: Is it possible to carry out our check in the last question with a Jest snapshot
    test? If so, how?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个问题中，我们是否可以使用Jest快照测试来进行我们的检查？如果可以，如何实现？
- en: 'We have implemented a component called `CheckList` which renders text from
    an array in a list. Each list item has a checkbox so that the user can select
    list items. The component has a function prop called `onItemSelect` that is called
    when a user selects an item by checking the checkbox. We are implementing a test
    to verify that the `onItemSelect` prop works. The following line of code renders
    the component in the test:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个名为`CheckList`的组件，它从数组中呈现文本列表。每个列表项都有复选框，以便用户可以选择列表项。该组件有一个名为`onItemSelect`的函数属性，当用户通过选中复选框选择项目时会调用该函数。我们正在实施一个测试来验证`onItemSelect`属性是否有效。以下代码行在测试中呈现组件：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How can we use a Jest mock function for `handleListItemSelect` and check that
    it is called?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用Jest模拟函数来处理`handleListItemSelect`并检查它是否被调用？
- en: In the implementation of `SimpleList` in the last question, the `onItemSelect`
    function takes in a parameter called `item`, which is the `string` value that
    the user has selected. In our test, let's pretend we have already simulated the
    user selecting `Banana`. How can we check the `onItemSelect` function was called,
    with the item parameter being `Banana`?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个问题中的`SimpleList`的实现中，`onItemSelect`函数接受一个名为`item`的参数，该参数是用户选择的`string`值。在我们的测试中，假设我们已经模拟了用户选择`Banana`。我们如何检查`onItemSelect`函数是否被调用，并且参数为`Banana`？
- en: In the implementation of `SimpleList` in the last two questions, the text is
    displayed using a label that is tied to the checkbox using the `for` attribute.
    How can we use functions in react-testing-library to firstly locate the `Banana`
    checkbox and then check it?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述两个问题中的`SimpleList`的实现中，文本使用一个标签显示，该标签使用`for`属性与复选框相关联。我们如何使用react-testing-library中的函数来首先定位`Banana`复选框，然后检查它？
- en: In this chapter, we found that the coverage was low in our code that rendered
    posts from the JSONPlaceholder REST API. One of the areas that wasn't covered
    was handling HTTP error codes in the `componentDidMount` function when we get
    the posts from the REST API. Create a test to cover this area of code.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，我们发现从JSONPlaceholder REST API渲染帖子的代码覆盖率很低。其中一个未覆盖的领域是在从REST API获取帖子时，在`componentDidMount`函数中处理HTTP错误代码。创建一个测试来覆盖代码的这一部分。
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources are useful for finding more information on unit testing
    React and TypeScript apps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源对于查找有关单元测试React和TypeScript应用程序的更多信息很有用：
- en: Official Jest documentation can be found at the following link: [https://jestjs.io/](https://jestjs.io/)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的Jest文档可以在以下链接找到：[https://jestjs.io/](https://jestjs.io/)
- en: 'The React Testing Library GitHub repository is at the following link: [https://github.com/kentcdodds/react-testing-library](https://github.com/kentcdodds/react-testing-library)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Testing Library GitHub存储库位于以下链接：[https://github.com/kentcdodds/react-testing-library](https://github.com/kentcdodds/react-testing-library)
- en: 'Read the documentation for Enzyme at the following link: [https://airbnb.io/enzyme/docs/api/](https://airbnb.io/enzyme/docs/api/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读Enzyme的文档，请访问以下链接：[https://airbnb.io/enzyme/docs/api/](https://airbnb.io/enzyme/docs/api/)
- en: 'The Jasmine GitHub page is as follows: [https://jasmine.github.io/index.html](https://jasmine.github.io/index.html)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine GitHub页面如下：[https://jasmine.github.io/index.html](https://jasmine.github.io/index.html)
- en: The Mocha homepage can be found at [https://mochajs.org/](https://mochajs.org/)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha主页可以在以下网址找到：[https://mochajs.org/](https://mochajs.org/)
