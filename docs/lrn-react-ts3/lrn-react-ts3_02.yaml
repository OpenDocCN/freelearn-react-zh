- en: What is New in TypeScript 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 3中的新功能
- en: In its six years of existence, TypeScript has continued to move forward and
    mature nicely. Is TypeScript 3 a significant release for React developers? What
    exactly are the new features that we have to add to our toolkit in TypeScript
    3? These questions will be answered in this chapter, starting with the `tuple`
    type and how it can now be successfully used with the **rest** and **spread**
    JavaScript syntax, which is very popular in the React community. We'll then move
    on to the new `unknown` type and how it can be used as an alternative to the `any`
    type. Further more, we'll break TypeScript projects up into smaller projects with
    the new project references in TypeScript. Finally, we'll go about defining default
    properties in a strongly-typed React component that has improved in TypeScript
    3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在其六年的存在中，TypeScript一直在不断前进并成熟。TypeScript 3对React开发人员来说是一个重要的发布吗？在TypeScript
    3中我们必须添加到我们的工具包中的新功能是什么？这些问题将在本章中得到解答，首先是`tuple`类型以及它如何可以成功地与React社区中非常流行的**rest**和**spread**
    JavaScript语法一起使用。然后，我们将介绍新的`unknown`类型以及它如何作为`any`类型的替代。此外，我们将使用TypeScript中的新项目引用将TypeScript项目分解为较小的项目。最后，我们将介绍在TypeScript
    3中改进的强类型React组件中定义默认属性的方法。
- en: 'By the end of the chapter, we''ll be ready to start learning how you can use
    TypeScript 3 to build frontends with React. In this chapter, we''ll cover the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将准备好开始学习如何使用TypeScript 3来构建具有React的前端。在本章中，我们将涵盖以下主题：
- en: Tuples
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: The unknown type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未知类型
- en: Project references
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目引用
- en: Default JSX properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认JSX属性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will use the same technologies as in [Chapter 1](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml),
    *TypeScript Basics*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用与[第1章](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml)中相同的技术，*TypeScript
    Basics*：
- en: '**TypeScript playground**: This is a website at [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/),
    which allows us to play around with and understand the features in TypeScript
    without installing it.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript playground：这是一个网站，位于[https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/)，允许我们在不安装它的情况下玩转和理解TypeScript中的功能。
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. You can
    install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和`npm`：TypeScript和React依赖于这些。您可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装它们。如果您已经安装了这些，请确保`npm`至少是5.2版本。
- en: '**TypeScript**: This can be installed via `npm`, entering the following command
    in a terminal:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript：这可以通过`npm`安装，输入以下命令在终端中：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is important that we are using TypeScript 3 in this chapter. You can check
    your TypeScript version by using the following command in a terminal:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中使用TypeScript 3非常重要。您可以使用以下命令在终端中检查您的TypeScript版本：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you need to upgrade to the latest version, you can run the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要升级到最新版本，可以运行以下命令：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code. This one can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed in Visual Studio Code.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code：我们需要一个编辑器来编写我们的React和TypeScript代码。这可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要在Visual
    Studio Code中安装TSLint（由egamma提供）和Prettier（由Estben Petersen提供）扩展程序。
- en: All the code snippets in this chapter can be found at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/02-WhatsNewInTS3](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/02-WhatsNewInTS3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/02-WhatsNewInTS3](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/02-WhatsNewInTS3)找到。
- en: Tuples
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples have had a few enhancements in TypeScript 3, so that they can be used
    with the popular `rest` and `spread` JavaScript syntax. Before we get into the
    specific enhancements, we'll go through what tuples are, along with what the `rest`
    and `spread` syntax is. A tuple is like an array but the number of elements are
    fixed. It's a simple way to structure data and use some type safety.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在TypeScript 3中有了一些增强，因此它们可以与流行的`rest`和`spread` JavaScript语法一起使用。在我们进入具体的增强之前，我们将介绍元组是什么，以及`rest`和`spread`语法是什么。元组类似于数组，但元素的数量是固定的。这是一种简单的方式来结构化数据并使用一些类型安全性。
- en: 'Let''s have a play with tuples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来玩玩元组：
- en: 'In the TypeScript playground, let''s enter the following example of a tuple
    variable:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TypeScript playground中，让我们输入以下元组变量的示例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've initialized a `product` variable to a tuple type with two elements. The
    first element is a string and the second a number.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`product`变量初始化为具有两个元素的元组类型。第一个元素是一个字符串，第二个是一个数字。
- en: 'We can store a product name and its unit price in the `product` variable on
    the next line, as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在下一行的`product`变量中存储产品名称和单位价格，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try to store the product name and unit price the other way around:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试以另一种方式存储产品名称和单位价格：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Not surprisingly, we get a compilation error. If we hover over `500`, the compiler
    quite rightly complains that it was expecting a string. If we hover over `"Table"`,
    the compiler complains that it expects a number:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们会得到一个编译错误。如果我们悬停在`500`上，编译器会正确地抱怨它期望一个字符串。如果我们悬停在`"Table"`上，编译器会抱怨它期望一个数字：
- en: '![](assets/c39e7280-3add-4c88-99aa-2b32c1f5ce50.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c39e7280-3add-4c88-99aa-2b32c1f5ce50.png)'
- en: So, we do get type safety, but tuples tell us nothing about what should be in
    the elements. So, they are nice for small structures or structures where the elements
    are obvious.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们确实获得了类型安全性，但元组并没有告诉我们元素中应该是什么。因此，它们适用于小型结构或元素明显的结构。
- en: 'The following examples are arguably fairly readable:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例可以说是相当可读的：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, the following example is not so readable:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，以下示例不太可读：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What exactly do those last two numbers represent?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后两个数字到底代表什么？
- en: 'We can access items in a tuple in the same way as an array, by using the element''s
    index. So, let''s access the product name and unit price in our `product` variable
    in the TypeScript playground:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像数组一样使用元组中的元素索引来访问元组中的项目。因此，在TypeScript playground中让我们访问`product`变量中的产品名称和单位价格：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we run the program, we'll get "Table" and 500 output to the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行程序，将会在控制台输出"Table"和500。
- en: 'We can iterate through elements in a tuple like we can an array, using a `for` loop
    or the array `forEach` function:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像使用`for`循环或数组`forEach`函数一样迭代元组中的元素：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running the program, will output `Table `and `500` to the console twice. Notice
    that we don't need to add a type annotation to the `element` variable because
    the TypeScript compiler cleverly infers this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，将会在控制台两次输出`Table`和`500`。请注意，我们不需要为`element`变量添加类型注释，因为TypeScript编译器聪明地推断出了这一点。
- en: So, that's the tuple type, but's what's new in TypeScript 3? The enhancements
    have been largely driven by the popularity of JavaScript's `rest` and `spread`
    syntax, so let's briefly cover this in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是元组类型，但是TypeScript 3中有什么新东西呢？这些增强主要是受JavaScript的`rest`和`spread`语法的流行驱动的，所以让我们在下一节简要介绍一下这个。
- en: JavaScript rest and spread syntax
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的rest和spread语法
- en: In JavaScript, a `rest` parameter collects multiple arguments and condenses
    them into a single argument. It is called `rest` because it collects the `rest`
    of the arguments into a single argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`rest`参数收集多个参数并将它们压缩成一个单一参数。它被称为`rest`，因为它将剩余的参数收集到一个参数中。
- en: A `rest` parameter has nothing to do with **Representational state transfer
    protocol** (**REST**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest`参数与**表述性状态转移协议**（**REST**）无关。'
- en: This syntax was introduced in ES6 and allows us to nicely implement functions
    that have an indefinite number of parameters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法是在ES6中引入的，允许我们很好地实现具有不确定数量参数的函数。
- en: We define a `rest` parameter with three dots preceding the parameter name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个点在参数名之前定义一个`rest`参数。
- en: 'Let''s go through a quick example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例：
- en: 'Let''s create a `logScores` function that takes in a `scores rest` parameter
    that just outputs the parameter to the console:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`logScores`函数，它接受一个`scores rest`参数，只是将参数输出到控制台：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is pure JavaScript - we'll introduce types to `rest` parameters when we
    look at the new features in TypeScript 3.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是纯JavaScript - 当我们查看TypeScript 3中的新功能时，我们将为`rest`参数引入类型。
- en: 'We can call `logScores` as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以这样调用`logScores`：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we run this, we'll get an array of the three elements we passed in as parameters
    output to the console. So, our `scores` parameter has collected all the arguments
    into an array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们将得到一个包含我们传入的三个元素的数组输出到控制台。因此，我们的`scores`参数已将所有参数收集到一个数组中。
- en: The `spread` syntax is the opposite of `rest` parameters. It allows an iterable,
    such as `array`, to be expanded into function arguments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`spread`语法与`rest`参数相反。它允许可迭代的对象，如`array`，扩展为函数参数。'
- en: 'Let''s look at an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: 'Let''s redefine our `logScore` function with specific parameters:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新定义我们的`logScore`函数，具有特定的参数：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that this is still pure JavaScript – no types just yet!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仍然是纯JavaScript - 还没有类型！
- en: 'Let''s define a `scores` array:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个`scores`数组：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, let''s use the `spread` syntax to pass our `scores` variable into
    our `logScore` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用`spread`语法将我们的`scores`变量传递给我们的`logScore`函数：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you are using the TypeScript playground, you'll get the compilation error, `expected
    3 arguments, but got 0 or more`. The program still runs though, because this is
    perfectly valid JavaScript. `75, 65, 80` will be output to the console if we do
    run it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用TypeScript playground，您将收到编译错误，`期望3个参数，但得到0个或更多`。尽管如此，程序仍然运行，因为这是完全有效的JavaScript。如果我们运行它，`75,
    65, 80`将被输出到控制台。
- en: In the following sections, we'll see how the new features in TypeScript 3 help
    us help the compiler to better understand what we are trying to do when using
    `rest` and `spread`. This will allow us to resolve the compilation errors seen
    in the preceding example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到TypeScript 3中的新功能如何帮助我们更好地帮助编译器理解我们在使用`rest`和`spread`时要做的事情。这将允许我们解决前面示例中看到的编译错误。
- en: Open-ended tuples
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放式元组
- en: Before TypeScript 3, tuples had to have a fixed amount of elements. TypeScript
    3 gives us a little more flexibility with `rest` elements. `rest` elements are
    similar to `rest` parameters, described in the last section, but they work with
    tuple element types. A `rest` element allows us to define an open-ended tuple.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 3之前，元组必须具有固定数量的元素。TypeScript 3为`rest`元素提供了更多的灵活性。`rest`元素类似于上一节中描述的`rest`参数，但它们与元组元素类型一起工作。`rest`元素允许我们定义一个开放式元组。
- en: 'Time to go through an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 时间来通过一个例子：
- en: 'In the TypeScript playground, let''s create a tuple with the first element
    being a string and subsequent elements being numbers:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TypeScript playground中，让我们创建一个元组，第一个元素是字符串，后续元素是数字：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We should be able to use this structure to store someone''s name with an infinite
    amount of scores. Let''s give this a go for `Billy` and three scores:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能够使用这种结构来存储某人的名字和无限数量的分数。让我们为`Billy`和三个分数试一试：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s move on to try `Sally` and four scores:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续尝试`Sally`和四个分数：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both these variables compile fine, as we would expect, because we have defined
    the numbers as open-ended.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变量都可以正常编译，因为我们已经将数字定义为开放式的。
- en: Tuple function parameters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组函数参数
- en: Tuple `function` parameters in TypeScript 3 allow us to create strongly-typed
    `rest` parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 3中的元组`function`参数允许我们创建强类型的`rest`参数。
- en: 'Time for an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：
- en: 'When we first looked at `rest` parameters, we created a pure JavaScript version
    of `logScores` that collected an unlimited amount of arguments in a `scores` variable:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们第一次看到`rest`参数时，我们创建了一个纯JavaScript版本的`logScores`，它在`scores`变量中收集了无限数量的参数：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In TypeScript 3, we can now make this example strongly-typed with a tuple `rest`
    parameter. Let''s give this a try in the TypeScript playground:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TypeScript 3中，我们现在可以使用元组`rest`参数来使这个例子具有强类型。让我们在TypeScript playground中试一试：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s call our function with some scores:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一些分数调用我们的函数：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We don't get a compiler error, and if we run the program, we get an array containing
    `50, 85, 75` output in the console.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会得到编译错误，如果我们运行程序，控制台会输出包含`50, 85, 75`的数组。
- en: We can create an enhanced version of our function that uses the `Scores` type
    from the *Open-ended tuples* section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个增强版本的函数，它使用*开放元组*部分的`Scores`类型。
- en: 'The `function` will take in the name, as well as an unlimited set of scores:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function`将接受名字以及无限数量的分数：'
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s try to call our function with some scores from `Sally`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试用`Sally`的一些分数调用我们的函数：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we run the program, `Sally `and her array of scores will be output to the
    console.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行程序，`Sally`和她的分数数组将被输出到控制台。
- en: Spread expressions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展表达式
- en: TypeScript 3 allows us to use tuples with spread expressions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 3允许我们使用带有扩展表达式的元组。
- en: 'Let''s look at an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: 'Let''s go back to the problematic pure JavaScript example we looked at for
    using the `spread` syntax:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们之前使用`spread`语法的有问题的纯JavaScript示例：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The TypeScript compiler raised the error `Expected 3 arguments, but got 0 or
    more`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器引发了错误`预期3个参数，但得到了0个或更多个`。
- en: 'Let''s resolve this now with enhanced tuples in TypeScript 3. We''ll start
    by adding types to the `function` parameters:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在TypeScript 3中使用增强元组来解决这个问题。我们将首先为`function`参数添加类型：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's nothing new yet, and we're still getting the compilation error.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还没有什么新东西，我们仍然得到编译错误。
- en: 'Let''s change the `scores` variable into a fixed tuple:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`scores`变量改为固定元组：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's it – the compilation error has gone! All we needed to do was tell the
    compiler how many items were in `scores` for it to successfully spread into the **`logScore` **function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 编译错误消失了！我们所需要做的就是告诉编译器`scores`中有多少项，它就可以成功地传递到**`logScore`**函数中。
- en: 'So, in TypeScript 3, we can spread into fixed tuples. What about open-ended
    tuples? Let''s give that a try:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在TypeScript 3中，我们可以扩展固定元组。那么开放元组呢？让我们试试看：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unfortunately, the compiler is not yet quite clever enough to let us do this.
    We get the compilation error Expected 3 arguments, but got 0 or more.:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，编译器还不够聪明，不允许我们这样做。我们得到了编译错误`预期3个参数，但得到了0个或更多个`。
- en: '![](assets/5c4e907c-3880-4b97-b6d6-32438cc19391.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c4e907c-3880-4b97-b6d6-32438cc19391.png)'
- en: Empty tuples
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空元组
- en: 'In TypeScript 3, we can now define an empty tuple type. Let''s have a little
    play with this in the TypeScript playground:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 3中，我们现在可以定义一个空元组类型。让我们在TypeScript playground中玩一下这个：
- en: 'Let''s create the following type alias for an empty tuple:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为一个空元组创建以下类型别名：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s declare a variable of this type and assign it to an empty array:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个这种类型的变量，并将其赋值为空数组：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s try to declare a variable of this type and assign it to a non-empty
    array:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试声明一个这种类型的变量，并将其赋值为一个非空数组：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As expected, we get a compilation error:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到了一个编译错误：
- en: '![](assets/f68dd6b5-dfa3-4b38-a87b-1623220e2e27.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f68dd6b5-dfa3-4b38-a87b-1623220e2e27.png)'
- en: 'Why is an empty tuple type useful, though? On its own, it perhaps is not that
    useful, but it can be used as part of a union type, which we''ll cover in detail
    later in the book. As a quick example for now, we can create a type for no more
    than three scores, where no scores is also acceptable:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，空元组类型有什么用呢？单独来看，它可能并不那么有用，但它可以作为联合类型的一部分使用，我们将在本书的后面详细介绍。现在，举个快速的例子，我们可以创建一个类型，表示最多三个分数，其中零个分数也是可以接受的：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All the scores are valid except Sarah's, because four scores aren't allowed
    in the `Scores` type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有分数都是有效的，除了Sarah的，因为`Scores`类型不允许四个分数。
- en: Optional tuple elements
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选元组元素
- en: The final tuple enhancement in TypeScript 3 is the ability to have optional
    elements. Optional elements are specified using a `?` at the end of the element
    type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 3中的最终元组增强功能是具有可选元素的能力。可选元素使用元素类型的末尾加上`?`来指定。
- en: 'Let''s look at another example using our scores theme:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个使用我们分数主题的例子：
- en: 'Let''s create a type for between one and three scores:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个类型，表示一到三个分数：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So, we should be able to create variables to hold between one and three scores:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们应该能够创建变量来保存一到三个分数：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As expected, this compiles just fine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这个编译得很好。
- en: 'What about four elements? Let''s give this a go:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个元素呢？让我们试试：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We get a compilation error, as we would expect:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的那样，我们得到了一个编译错误：
- en: '![](assets/587ab6a8-0ad2-4330-8dc5-8ece784f3482.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/587ab6a8-0ad2-4330-8dc5-8ece784f3482.png)'
- en: 'If we try no elements, we again get a compilation error:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试没有元素，我们再次得到了一个编译错误：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When defining optional elements in a tuple, they are restricted to the end
    of the tuple. Let''s try to define a required element after an optional element:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在元组中定义可选元素时，它们被限制在元组的末尾。让我们尝试在可选元素之后定义一个必需元素：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get a compilation error, as expected:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到了一个编译错误：
- en: '![](assets/744f0d4a-3779-441d-bc7f-debd800ec400.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/744f0d4a-3779-441d-bc7f-debd800ec400.png)'
- en: 'Optional elements also work in a function `rest` parameter. Let''s try this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可选元素在函数`rest`参数中也起作用。让我们试试这个：
- en: 'Let''s use our `scores` type in our `logScores` function we worked with in
    earlier sections:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们之前的部分中使用的`scores`类型在我们的`logScores`函数中使用：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we try to pass in two scores, the code will compile just fine, because the
    last parameter is optional:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试传递两个分数，代码将编译得很好，因为最后一个参数是可选的：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As expected, if we pass in four scores, we receive `Expected 1-3 arguments,
    but got 4`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如预期的那样，如果我们传递了四个分数，我们会收到`Expected 1-3 arguments, but got 4`：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we have optional parameters, it is likely our function''s implementation
    will need to know which arguments have been passed. We can use the tuple''s `length` property
    to do this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有可选参数时，很可能我们的函数实现需要知道哪些参数已经传递。我们可以使用元组的`length`属性来做到这一点：
- en: 'Let''s create an enhanced version of our scores logger, called `logScoresEnhanced`,
    which thanks us if we log all `3` scores:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个增强版本的分数记录器，称为`logScoresEnhanced`，如果我们记录了所有`3`个分数，它会感谢我们：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s call this function with various parameters:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用不同的参数调用这个函数：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we run the program, we only get thanked after the first call when we pass
    all three scores.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行程序，只有在第一次调用时传递了所有三个分数时才会得到感谢。
- en: All the enhancements to tuples in TypeScript 3 allow us to use the `rest` and
    `spread` syntax in a strongly-typed fashion. We'll make use of this feature later
    in the book, when we work with React components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 3中对元组的所有增强允许我们以强类型的方式使用`rest`和`spread`语法。在本书的后面，当我们使用React组件时，我们将利用这个特性。
- en: The unknown type
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未知类型
- en: '`unknown` is a new type that has been added in TypeScript 3\. Before TypeScript
    3, we may have used the `any` type when we weren''t sure of all the properties
    and methods in an object from a third-party library. However, when we declare
    a variable with the `any` type, the TypeScript compiler won''t do any type checking
    on it. The `unknown` type can be used in these situations to make our code more
    type-safe. This is because `unknown` types are type-checked. So, `unknown` can
    often be used as an alternative to `any`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown`是在TypeScript 3中添加的新类型。在TypeScript 3之前，当我们不确定第三方库中对象的所有属性和方法时，可能会使用`any`类型。然而，当我们用`any`类型声明变量时，TypeScript编译器不会对其进行任何类型检查。在这些情况下，可以使用`unknown`类型使我们的代码更加类型安全。这是因为`unknown`类型是经过类型检查的。因此，`unknown`通常可以作为`any`的替代。'
- en: 'In the TypeScript playground, let''s go through an example of a function using
    `any` and an improved version using `unknown`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript playground中，让我们通过一个使用`any`的函数和一个使用`unknown`的改进版本的例子来进行演示：
- en: 'First, let''s create a `logScores` function that takes in a parameter of type `any`.
    It logs out the `name` and `scores` properties from the argument to the console:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个以`any`类型参数的`logScores`函数。它会将参数的`name`和`scores`属性记录到控制台中：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s call this function with the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下函数调用：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we run the program, we get `undefined` followed by `[60, 70, 75]` in the
    console. We passed in a correct object parameter, but our function logs `firstName`
    instead of `name` to the console. The program compiled just fine and didn't produce
    an error at runtime, but didn't give the result we wanted. This is all because
    we told the compiler not to check any types with the `any` type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行程序，控制台中会先显示`undefined`，然后是`[60, 70, 75]`。我们传入了一个正确的对象参数，但是我们的函数将`firstName`而不是`name`记录到了控制台中。程序编译得很好，并且在运行时没有产生错误，但是没有得到我们想要的结果。这都是因为我们告诉编译器不要使用`any`类型进行任何类型检查。
- en: 'Let''s start to create a better version of this function with the `unknown`
    type:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建一个更好的版本，使用`unknown`类型：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We immediately get compiler warnings where we reference the properties in `scores`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即在引用`scores`中的属性时得到编译器警告：
- en: '![](assets/bd79710f-d16d-4c47-bece-5380676517ca.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bd79710f-d16d-4c47-bece-5380676517ca.png)'
- en: So, the compiler is checking our `scores` variable now, which is great, and
    is even warning us about the `firstName` property. However, the `scores` property
    is also giving a complication error but is valid. So, how do we tell the compiler this? We
    need to explicitly do some type checking ourselves in our code. We'll cover a
    couple of ways of doing this in the following sections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器现在正在检查我们的`scores`变量，这很好，甚至在`firstName`属性上警告我们。然而，`scores`属性也会产生一个复杂的错误，但是是有效的。那么，我们如何告诉编译器呢？我们需要在我们的代码中明确进行一些类型检查。我们将在接下来的几节中介绍几种方法。
- en: Type checking with a type predicate
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型断言进行类型检查
- en: 'One way we can perform type checking in a function is with another function
    that has a return type as a type predicate. Let''s explore this and eventually
    create a new version of our `logScores` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数中使用另一个具有类型断言返回类型的函数来执行类型检查。让我们探索一下，并最终创建一个新版本的`logScores`函数：
- en: 'First, we''ll define a new function called `scoresCheck` to do the necessary
    type checking:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个名为`scoresCheck`的新函数来进行必要的类型检查：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This takes in a `scores` parameter that has a type predicate,`scores is { name:
    string; scores: number[] }`, ensuring it contains the correctly typed `name` and
    `scores` properties. The function simply returns whether the `scores` parameter contains
    the `name` and `scores` properties.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '这个函数接受一个带有类型谓词的`scores`参数，`scores is { name: string; scores: number[] }`，确保它包含正确类型的`name`和`scores`属性。该函数只是返回`scores`参数是否包含`name`和`scores`属性。'
- en: 'Let''s use this function in our `logScores` function:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们的`logScores`函数中使用这个函数：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We immediately get the compilation error we want:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即得到了我们想要的编译错误：
- en: '![](assets/321c0859-294f-4e12-b3ef-a1475a9e95fb.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/321c0859-294f-4e12-b3ef-a1475a9e95fb.png)'
- en: 'The type predicate, `scores is { name: string, scores: number[] }`, allows
    the TypeScript compiler to narrow down the type in the `if` block that logs the
    properties to the console. This results in `scores.scores` compiling fine, but
    `scores.firstName` is giving an error, which is just what we want.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '类型断言，`scores is { name: string, scores: number[] }`，允许TypeScript编译器在`if`块中缩小类型，以便将属性记录到控制台。这导致`scores.scores`编译正常，但`scores.firstName`出现错误，这正是我们想要的。'
- en: The type predicate is the key bit. Without it, the TypeScript compiler will
    still throw errors on the valid `scores.scores` reference. Try removing the type
    predicate and see for yourself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类型谓词是关键部分。没有它，TypeScript编译器仍然会在有效的`scores.scores`引用上抛出错误。尝试删除类型谓词，自己看看。
- en: 'Note that we can make the predicate a little more readable with a type alias:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用类型别名使谓词更易读：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using a type predicate in this way is called a type guard. There are other ways
    of implementing type guards, which we'll cover later in the book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用类型谓词称为类型保护。我们将在本书后面介绍其他实现类型保护的方法。
- en: Type narrowing with a type assertion
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型断言进行类型缩小
- en: The other way of performing type checking we are going to look at when using `unknown` is
    to use type assertion. Type assertion lets us tell the compiler what the type
    is with the `as` keyword.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`unknown`时进行类型检查的另一种方法是使用类型断言。类型断言让我们使用`as`关键字告诉编译器类型是什么。
- en: 'Let''s create yet another version of our `logScores` function as an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个版本的`logScores`函数作为示例：
- en: 'First, let''s create a type alias for the structure we want the function parameter
    to be:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为我们想要函数参数的结构创建一个类型别名：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In our `logScores` function, we can now use the `as` keyword to tell the compiler
    what type to expect:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`logScores`函数中，我们现在可以使用`as`关键字告诉编译器期望的类型：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That''s enough information for the compiler to pinpoint the problem:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以让编译器准确定位问题：
- en: '![](assets/053bc758-8be0-4a1c-95be-b16a14e59b76.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/053bc758-8be0-4a1c-95be-b16a14e59b76.png)'
- en: The `unknown` type allows us to reduce our use of the `any` type and create
    more strongly-typed and robust TypeScript programs. We do have to write more code,
    though, when referencing `unknown` types. The additional code we need to write
    needs to check the type of the `unknown` variable so that the TypeScript compiler
    can be sure we are accessing valid members within it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown`类型允许我们减少对`any`类型的使用，并创建更强类型和健壮的TypeScript程序。但是，当引用`unknown`类型时，我们需要编写更多的代码。我们需要编写额外的代码来检查`unknown`变量的类型，以便TypeScript编译器可以确保我们正在访问其中的有效成员。'
- en: Project references
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目引用
- en: TypeScript 3 allows TypeScript projects to depend on other TypeScript projects
    by allowing `tsconfig.json` to reference other `tsconfig.json` files.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 3允许TypeScript项目依赖于其他TypeScript项目，通过允许`tsconfig.json`引用其他`tsconfig.json`文件。
- en: This makes it easier to split our code up into smaller projects. Our frontend
    code might be in TypeScript, in addition to having our backend in TypeScript.
    With TypeScript 3, we can have a frontend TypeScript project, a backend TypeScript
    project, and a shared TypeScript project that contains code that is used in both
    the frontend and backend. Splitting our code up into smaller projects can also
    can give us faster builds, because they can work incrementally.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以更容易地将我们的代码拆分成较小的项目。我们的前端代码可能是TypeScript，除了我们的后端也是TypeScript。有了TypeScript
    3，我们可以有一个前端TypeScript项目，一个后端TypeScript项目，以及一个共享的TypeScript项目，其中包含在前端和后端都使用的代码。将我们的代码拆分成较小的项目也可以让我们构建更快，因为它们可以逐步工作。
- en: Setting up an example
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例
- en: 'In order to explore this, we are going to work through an example of a TypeScript
    project referencing another project in Visual Studio Code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这一点，我们将通过一个在Visual Studio Code中引用另一个项目的TypeScript项目的示例来进行工作：
- en: Firstly, let's create a new folder called `Shared`. This is going to be the
    project for shared code that could potentially be used in many other projects.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为“Shared”的新文件夹。这将是一个用于共享代码的项目，可能会在许多其他项目中使用。
- en: 'In our `Shared` folder, let''s create the following `tsconfig.json` as a starting
    point:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的“Shared”文件夹中，让我们创建以下“tsconfig.json”作为起点：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s create an `src` folder containing a TypeScript file called `utils.ts`
    with the following function, `randomString`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含名为“utils.ts”的TypeScript文件的“src”文件夹，并包含以下函数“randomString”：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is a function that creates a random string of characters, as the name suggests.
    We are going to use this function in another project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建随机字符的函数，正如其名称所示。我们将在另一个项目中使用这个函数。
- en: Let's start to create our second project now, so go back up to the root of our
    solution, and create a folder called `ProjectA`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们开始创建我们的第二个项目，所以回到我们解决方案的根目录，创建一个名为“ProjectA”的文件夹。
- en: 'Inside `ProjectA`, let''s create the following `tsconfig.json` as a starting
    point:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“ProjectA”中，让我们创建以下“tsconfig.json”作为起点：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s also create a folder called `src` in `ProjectA`, containing a TypeScript
    file called `person.ts`, with the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还在“ProjectA”中创建一个名为“person.ts”的TypeScript文件的“src”文件夹，并包含以下代码：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The code defines a simple class of information about a person. The unique identifier
    of the person is set to a random string in the constructor using the `randomString`
    function from our `Shared` project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了一个关于人的简单信息类。人的唯一标识符在构造函数中使用来自我们“Shared”项目的“randomString”函数设置为随机字符串。
- en: 'Let''s open up the terminal, go to our `Shared` folder, and compile our `Shared`
    project:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开终端，转到我们的“Shared”文件夹，并编译我们的“Shared”项目：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `Shared` project compiles just fine.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: “Shared”项目编译得很好。
- en: 'Let''s try to compile `ProjectA` now:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试编译“ProjectA”：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We get a compilation error:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个编译错误：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, we created two dependent projects, but they don't properly understand each
    other yet, which is why we are getting the error. We'll resolve this in the following
    sections, using TypeScript 3's new features for multiple projects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了两个依赖项目，但它们还不彼此理解，这就是我们出错的原因。我们将在接下来的部分中解决这个问题，使用TypeScript 3的新功能来处理多个项目。
- en: Referencing projects
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用项目
- en: The first step in setting up TypeScript 3's multiple projects feature is to
    reference projects using a new field called `references` in `tsconfig.json`. This
    field is an array of objects that specify projects to reference.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 设置TypeScript 3的多项目功能的第一步是使用“tsconfig.json”中的新字段“references”引用项目。这个字段是一个指定要引用的项目的对象数组。
- en: 'In our working example, let''s make `ProjectA` start to understand the `Shared`
    project:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作示例中，让“ProjectA”开始理解“Shared”项目：
- en: 'Let''s change the `tsconfig.json` in `ProjectA` to reference the `Shared` project:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更改“ProjectA”中的“tsconfig.json”以引用“Shared”项目：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we want the dependent project's generated JavaScript code to be included
    in the same file as the current project, we can set `prepend` to `true` on the
    dependency.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望依赖项目生成的JavaScript代码包含在当前项目的同一文件中，我们可以在依赖项上将“prepend”设置为“true”。
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We're not going to use `prepend` in our example though.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们的示例中，我们不会使用“prepend”。
- en: 'If we compile `ProjectA` again, a different error is raised:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次编译“ProjectA”，会出现不同的错误：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The error gives a great clue as to what is wrong. We'll resolve this problem
    with the missing `composite` setting in the next section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 错误提示了问题出在哪里。我们将在下一节中通过缺少的“composite”设置来解决这个问题。
- en: Additions to compiler options
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器选项的添加
- en: Just referencing another project isn't enough for the TypeScript compiler to
    properly handle multiple projects. We need to add some additional compiler options
    in the dependent project.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅引用另一个项目对于TypeScript编译器来说并不足以正确处理多个项目。我们需要在依赖项目中添加一些额外的编译器选项。
- en: The `compilerOptions` field has a new field called `composite`, which must be
    set to `true` if we are using multiple projects. This ensures certain options
    are enabled so that this project can be referenced and built incrementally for
    any project that depends on it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: “compilerOptions”字段有一个新字段叫做“composite”，如果我们使用多个项目，必须将其设置为“true”。这样可以确保启用某些选项，以便可以对依赖于它的任何项目进行引用和增量构建。
- en: When `composite` is `true`, `declaration` must also be set to `true`, forcing
    the corresponding `.d.ts` file to be generated, containing the project's types.
    This allows TypeScript to only build dependent projects when types are changed
    and not rebuild all the dependent projects all the time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当“composite”为“true”时，“declaration”也必须设置为“true”，强制生成相应的“.d.ts”文件，其中包含项目的类型。这使得TypeScript只在类型更改时构建依赖项目，而不是一直重新构建所有依赖项目。
- en: 'Let''s make the following changes to our working example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的工作示例进行以下更改：
- en: 'Let''s open up `tsconfig.json` in the `Shared` project and make the following
    changes:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开“Shared”项目中的“tsconfig.json”并进行以下更改：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the terminal, let''s go to the `Shared` project directory and compile our
    `Shared` project:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，让我们进入“Shared”项目目录并编译我们的“Shared”项目：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The project compiles okay. Let''s now try to compile `ProjectA` again in the
    terminal:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 项目编译正常。现在让我们尝试在终端中再次编译“ProjectA”：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This time, `ProjectA` compiles just fine.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，“ProjectA”编译得很好。
- en: So, we have successfully tied together two projects using TypeScript 3's multiple
    projects feature. In the next section, we'll improve the setup of our projects
    even more.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们成功地使用了TypeScript 3的多项目功能将两个项目联系在一起。在下一节中，我们将进一步改进我们项目的设置。
- en: Cross-project Go to Definition
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨项目Go to Definition
- en: In order for the Go to Definition feature in Visual Studio Code to work across
    projects, we need to set the `declarationMap` setting in `tsconfig.json`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Visual Studio Code中的Go to Definition功能跨项目工作，我们需要在“tsconfig.json”中设置“declarationMap”设置。
- en: 'Let''s continue with our multiple project example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行我们的多项目示例：
- en: 'Let''s open `person.ts` in `ProjectA`, right-click on the `randomString` reference,
    and select Go to Definition:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在“ProjectA”中打开“person.ts”，右键单击“randomString”引用，然后选择Go to Definition：
- en: '![](assets/edb5b391-b705-4e09-818f-de7f14996be7.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edb5b391-b705-4e09-818f-de7f14996be7.png)'
- en: 'We are taken to the declaration file rather than the source file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被带到了声明文件而不是源文件：
- en: '![](assets/c0818d4d-a9b2-47ae-887b-100a74071afa.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c0818d4d-a9b2-47ae-887b-100a74071afa.png)'
- en: 'We can resolve that by setting `declarationMap` in `tsconfig.json` in the `Shared`
    project:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在“Shared”项目的“tsconfig.json”中设置“declarationMap”来解决这个问题：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we compile the `Shared` project and try the Go to Definition feature again,
    we are taken to the source file, as we would want.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译`Shared`项目并再次尝试“转到定义”功能，我们会被带到源文件，这正是我们想要的。
- en: So, by setting `declarationMap` to `true` in the dependent project, along with
    `composite` and `declaration`, we get great support for multiple TypeScript projects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在依赖项目中将`declarationMap`设置为`true`，以及`composite`和`declaration`，我们可以获得对多个
    TypeScript 项目的出色支持。
- en: Build mode
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模式
- en: 'The TypeScript 3 compiler includes the ability to perform smart incremental
    builds using the `--build` flag. Let''s give this a try in our example multiple
    project solution:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 3 编译器包括使用`--build`标志执行智能增量构建的能力。让我们在我们的示例多项目解决方案中试一试：
- en: 'First, let''s go to the root of the solution, open the terminal, and enter
    the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们进入解决方案的根目录，打开终端，然后输入以下内容：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `--verbose` flag tells the compiler to tell us the details of what it''s
    doing. The messages confirm to us that it has picked up the `Shared` project as
    well as `ProjectA`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`--verbose`标志告诉编译器告诉我们它正在做什么的细节。消息确认它已经选择了`Shared`项目以及`ProjectA`：'
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The compiler then checks each project to see if it''s up to date. If the project
    is up to date, we get something like the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器会检查每个项目是否是最新的。如果项目是最新的，我们会得到以下内容：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's make a change in the `utils.ts` file in the `Shared` project by adding
    a space somewhere, removing it, and then saving the file.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Shared`项目的`utils.ts`文件中进行更改，添加一个空格，然后删除它，然后保存文件。
- en: 'Let''s build `ProjectA` again:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次构建`ProjectA`：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As expected, we get a message to indicate that the `Shared` project is out
    of date and will be rebuilt:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们会收到一条消息，指示`Shared`项目已过时，并将被重新构建：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we want to force a rebuild, even if projects are up to date, we can use
    the `--force` flag. Let''s give this a try:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要强制重新构建，即使项目是最新的，我们可以使用`--force`标志。让我们试一试：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we do this, the compiler will still check whether projects are up to date
    (and tell us), but then it goes on to build each project.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，编译器仍然会检查项目是否是最新的（并告诉我们），然后继续构建每个项目。
- en: So, in addition to great multiple-project support, we can speed up solution
    builds using the `--build` flag. As the solution grows over time, this becomes
    increasingly valuable. If ever we want to force a rebuild of a project, we can
    use the `--force` flag along with `--build`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了出色的多项目支持外，我们还可以使用`--build`标志加快解决方案的构建速度。随着时间的推移，随着解决方案的增长，这变得越来越有价值。如果我们想要强制重新构建一个项目，我们可以使用`--force`标志以及`--build`。
- en: Default JSX properties
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认的 JSX 属性
- en: TypeScript 3 has also improved how we can set default properties on React components
    with `--strictNullChecks`. Before TypeScript 3, we had to set properties that
    had default values as optional and perform `null` checks when referencing them.
    We haven't introduced React yet in this book, so we'll only touch on this briefly
    at this point.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 3 还改进了我们如何使用`--strictNullChecks`在 React 组件上设置默认属性。在 TypeScript 3
    之前，我们必须将具有默认值的属性设置为可选的，并在引用它们时执行`null`检查。在本书中我们还没有介绍 React，所以在这一点上我们只会简要提及。
- en: 'Let''s look through an example to get a feel for the improvement:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来感受一下改进：
- en: 'The following is a React component with some default properties in TypeScript
    2.9\. The component is called `SplitText` and it takes in some text, splits it,
    and renders the bits that have been split in a list:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个在 TypeScript 2.9 中具有一些默认属性的 React 组件。该组件名为`SplitText`，它接受一些文本，将其拆分，并在列表中呈现已拆分的部分：
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The component has a `delimiter` property that defaults to `","`. In TypeScript
    2.9, we need to make `delimiter` an optional property, otherwise we get a compiler
    error if we don't specify it in the calling component (even though there is a
    `default`).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件有一个`delimiter`属性，默认值为`,`。在TypeScript 2.9中，我们需要将`delimiter`设为可选属性，否则如果在调用组件中没有指定它，就会得到编译器错误（即使有默认值）。
- en: Also notice that we need to put a `!` after we reference `delimiter` in the `bits` variable
    declaration. This is to tell the compiler that this will never be undefined.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在`bits`变量声明中引用`delimiter`后面需要加上`!`。这是告诉编译器这绝对不会是未定义的。
- en: 'Here''s the component that calls `SplitText`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是调用`SplitText`的组件：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here''s what it looks like when rendered:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染时的效果如下：
- en: '![](assets/b76dc251-9f55-401f-bbf1-cf92f46f939e.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b76dc251-9f55-401f-bbf1-cf92f46f939e.png)'
- en: 'Now, let''s look at the component in TypeScript 3:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下TypeScript 3中的组件：
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice that we didn't need to make the `delimiter` property optional. Also notice
    that we didn't need to tell the compiler that `this.props.delimiter` can't be
    undefined.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要将`delimiter`属性设为可选。还要注意，我们不需要告诉编译器`this.props.delimiter`不会是未定义的。
- en: So, in summary, we don't have to fiddle around to make default properties work
    nicely in TypeScript 3!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在TypeScript 3中，我们不必费力使默认属性在代码中正常工作！
- en: This is our first taste of React. Don't worry if the code examples don't make
    much sense at this point. We'll start to learn about React components in [Chapter
    3](6938e951-47cf-4751-9cfc-c5afcdd73c9e.xhtml), *Getting Started with React and
    TypeScript*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次接触React。如果此时代码示例并不太有意义，不要担心。我们将在[第3章](6938e951-47cf-4751-9cfc-c5afcdd73c9e.xhtml)中开始学习有关React组件的知识，*使用React和TypeScript入门*。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Using the `rest` and `spread` syntax is very common nowadays, particularly when
    building React apps. We've seen how TypeScript 3, with the enhancement of tuples,
    allows us to use `rest` and `spread` in a strongly-typed fashion.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建React应用程序时，使用`rest`和`spread`语法非常常见。我们已经看到，TypeScript 3通过元组的增强，允许我们以强类型的方式使用`rest`和`spread`。
- en: We've also seen how we can use the `unknown` type to reduce our use of the `any`
    type. The `unknown` type does require us to write more code, but it also allows
    us to create a more strongly-typed, more maintainable code base.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用`unknown`类型来减少对`any`类型的使用。`unknown`类型需要我们编写更多的代码，但也允许我们创建一个更强类型、更易维护的代码库。
- en: TypeScript has always made working with large code bases easier. With the introduction
    of project references, we can now split our solution into smaller projects more
    easily. This approach makes large solutions even more maintainable and flexible,
    and also yields faster build times with the new `--build` flag.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript一直让处理大型代码库变得更容易。引入项目引用后，我们现在可以更轻松地将解决方案分割成更小的项目。这种方法使得大型解决方案更易维护和灵活，并且使用新的`--build`标志可以获得更快的构建时间。
- en: We briefly went through how using `defaultprops`in a React component has improved.
    We'll be using this frequently as we start to learn how to build strongly-typed
    React components in subsequent chapters.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了在React组件中使用`defaultprops`的改进。在接下来的章节中，我们将经常使用这个功能来学习如何构建强类型的React组件。
- en: So, now that we are starting to get comfortable with TypeScript, in the next
    chapter, we'll get started with React. We'll start by learning how to create a
    React and TypeScript project, and then move on to how to create React and TypeScript
    components.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始逐渐熟悉TypeScript，下一章中我们将开始学习React。我们将首先学习如何创建React和TypeScript项目，然后再学习如何创建React和TypeScript组件。
- en: Questions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In order to cement what we have learned about TypeScript 3, have a go at the
    following questions:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们对TypeScript 3的学习，试着回答以下问题：
- en: 'We have the following function, which draws a point:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下绘制点的函数：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We also have the following `point` variable:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下`point`变量：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How can we call the `drawPoint` function in a terse manner?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以简洁的方式调用`drawPoint`函数？
- en: 'We need to create another version of the `drawPoint` function, where we can
    call it by passing the *x*, *y*, and *z* point values as parameters:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建`drawPoint`函数的另一个版本，可以通过传递*x*、*y*和*z*点值作为参数来调用它：
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Internally, in the implementation of `drawPoint`, we draw the point from a tuple
    type `[number, number, number]`. How can we define the method parameter(s) with
    the required tuple?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawPoint`的实现内部，我们从元组类型`[number, number, number]`中绘制点。我们如何定义具有所需元组的方法参数？
- en: In your implementation of `drawPoint`, how can you make `z` in the point optional?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`drawPoint`实现中，你如何使点中的`z`是可选的？
- en: 'We have a function called `getData`, which calls a web API to get some data. The
    number of different API resources is still growing, so we''ve chosen to use `any` as
    the return type:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个名为`getData`的函数，它调用web API来获取一些数据。不同的API资源数量仍在增长，所以我们选择使用`any`作为返回类型：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How can we make `getData` more type-safe by leveraging the `unknown` type?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过利用`unknown`类型使`getData`更加类型安全？
- en: What `build` flag can we use to determine which projects are out of date and
    need to be rebuilt without doing a rebuild?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个`build`标志来确定哪些项目已过时并需要重新构建而无需重新构建？
- en: Further reading
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links are good resources for further information on TypeScript
    3.0:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是关于TypeScript 3.0更多信息的好资源：
- en: 'The Microsoft blog post that announced the TypeScript 3.0 release is worth
    a read: [https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/](https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得一读的是微软博客发布的TypeScript 3.0版本的文章：[https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/](https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/)
- en: 'The TypeScript documentation has got good information on project references,
    which is worth looking at: [https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript文档中有关项目引用的信息很全面，值得一看：[https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html)
