- en: Component Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件模式
- en: In this chapter, we will continue with the React shop we were building previously.
    We'll build a reusable tab component as well as a reusable loading indicator component
    that will both be used on the product page in our shop. The chapter will start
    by splitting the product page into a container and a presentational component
    before working on the tab component, leveraging the compound component and render
    props patterns. We'll then move on to implement a loading indicator component
    using the higher-order component pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建之前的React商店。我们将构建一个可重用的选项卡组件，以及一个可重用的加载指示器组件，两者都将在商店的产品页面上使用。本章将首先将产品页面分割为容器和展示组件，然后再处理选项卡组件，利用复合组件和渲染属性模式。然后，我们将继续实现一个使用高阶组件模式的加载指示器组件。
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下主题：
- en: Container and presentational components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和展示组件
- en: Compound components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合组件
- en: Render props pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染属性模式
- en: Higher-order components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶组件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We''ll use the following technologies in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least version 5.2.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js和** `npm`：TypeScript和React依赖于这些。我们可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装这些。如果我们已经安装了这些，确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写React和TypeScript代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要在Visual
    Studio Code中安装 TSLint（由egamma提供）和Prettier（由Estben Petersen提供）扩展。'
- en: '**React shop**: We''ll start from the project we began in the chapter where
    we looked at React Router. This is available on GitHub at: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React商店**：我们将从我们在查看React Router的章节中开始的项目开始。这可以在GitHub上找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter)。'
- en: All the code snippets in this chapter can be found online at: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在以下网址找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns)。
- en: Container and presentational components
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和展示组件
- en: Splitting pages up into container and presentational components makes the presentational
    component easier to reuse. The container component is responsible for how things
    work, fetching any data from a web API and managing state. The presentational component
    is responsible for how things look. Presentational components receive data via
    their properties and also have property event handlers so that their container
    can manage the user interactions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将页面分割为容器和展示组件可以使展示组件更容易重用。容器组件负责事物的运作，从Web API获取数据并管理状态。展示组件负责外观。展示组件通过属性接收数据，同时具有属性事件处理程序，以便其容器可以管理用户交互。
- en: 'We are going use this pattern in our React shop to split the product page into
    container and presentational components. The `ProductPage` component will be the
    container and we''ll introduce a new component called `Product` that will be the presentational
    component:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的React商店中使用这种模式，将产品页面分成容器和展示组件。`ProductPage`组件将是容器，我们将引入一个名为`Product`的新组件，它将是展示组件：
- en: 'Let''s start by opening our shop project in Visual Studio Code and entering
    the following command in a terminal to start the app:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在Visual Studio Code中打开我们的商店项目，并在终端中输入以下命令来启动应用程序：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we navigate to a product, let''s remind ourselves what the product page
    looks like:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们导航到一个产品，让我们回顾一下产品页面是什么样子的：
- en: '![](assets/fe7f8f05-1de1-488a-a184-9faace7ade77.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fe7f8f05-1de1-488a-a184-9faace7ade77.png)'
- en: 'Let''s create a new file called `Product.tsx` that will contain our presentational
    component with the following content:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Product.tsx`的新文件，其中包含我们的展示组件，内容如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our presentational component is a function component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的展示组件是一个函数组件。
- en: 'Presentational components receive data via props and also delegate event handling
    via props. So, let''s create props for the product data item, whether it has been
    added to the basket, and the handler for adding it to the basket:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示组件通过props接收数据，也通过props委托事件处理。因此，让我们为产品数据项、是否已添加到购物篮以及添加到购物篮的处理程序创建props：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we look at `ProductsPage.tsx`, we are going to copy the JSX for when there
    is a product that is the `React.Fragment` section. We then paste this into the
    return statement for our `Product` component:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看`ProductsPage.tsx`，我们将复制`React.Fragment`部分中有产品时的JSX。然后我们将其粘贴到`Product`组件的return语句中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have a few reference issues now to resolve.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一些参考问题需要解决。
- en: 'Let''s define a product variable above the return statement to resolve the issue
    with the product reference in the JSX:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在return语句之前定义一个产品变量，以解决JSX中产品引用的问题：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Whether the product is in the basket is passed in via the `inBasket` prop now.
    So, let''s change the conditional around the Add to Basket button to use this
    prop:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过`inBasket` prop传递产品是否在购物篮中。因此，让我们改变添加到购物篮按钮周围的条件以使用这个prop：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final reference issue we need to resolve is with the handler for clicking
    the Add to Basket button. Let''s first create a handler that simply calls the
    `onAddToBasket` prop:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要解决的最后一个参考问题是点击“添加到购物篮”按钮的处理程序。让我们首先创建一个简单调用`onAddToBasket` prop的处理程序：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can remove the `this` reference where we reference this handler in the JSX:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在JSX中删除对此处理程序的引用`this`。
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's our `Product` presentational component complete for the time being. So,
    let's reference our `Product` component in our `ProductPage` component.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们目前的`Product`展示组件完成了。因此，让我们在`ProductPage`组件中引用我们的`Product`组件。
- en: 'First, let''s import our `Product` component into `ProductPage.tsx`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将我们的`Product`组件导入到`ProductPage.tsx`中：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s replace the section we copied in the JSX with our `Product` component:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用我们的`Product`组件替换在JSX中复制的部分：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We pass the product, whether the product has been added to basket, and the handler
    for adding to the basket together as props to the `Product` component.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将产品、产品是否已添加到购物篮以及添加到购物篮的处理程序一起作为props传递给`Product`组件。
- en: If we look at the shop again and go to the product page, it will look exactly
    the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看商店并转到产品页面，它看起来完全一样。
- en: So, we just implemented our first container and presentational components. Container
    components are great as the top-level component within a page, fetching data from
    a web API, and managing all the state within the page. Presentational components
    just focus on what needs to be rendered to the screen. A benefit of this pattern
    is that presentational components can be used elsewhere in the app more easily.
    For example, our `Product` component could fairly easily be used on other pages
    that we create in our shop. Another benefit of this pattern is that presentational
    components are generally easier to unit-test. In our example, our `Product` component is
    a pure function and so unit-testing this is simply a case of checking that the
    output is correct for different inputs because there are no side-effects. We'll
    cover unit testing in detail later in the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚实现了我们的第一个容器和展示组件。容器组件非常适合作为页面中的顶层组件，从Web API获取数据，并管理页面内的所有状态。展示组件只关注需要呈现在屏幕上的内容。这种模式的好处是展示组件可以更容易地在应用程序的其他地方使用。例如，我们的`Product`组件可以相当容易地在商店中创建的其他页面上使用。这种模式的另一个好处是，展示组件通常更容易进行单元测试。在我们的示例中，我们的`Product`组件是一个纯函数，因此对其进行单元测试只是检查不同输入的输出是否正确，因为没有副作用。我们将在本书的后面详细介绍单元测试。
- en: We'll continue to enhance our product page in the next section by adding reviews
    to it and adding tabs to separate the product description from the reviews.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续增强我们的产品页面，通过向其添加评论并添加选项卡来将产品描述与评论分开。
- en: Compound components
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合组件
- en: Compound components are a set of components that work together. We are going
    to use this pattern to create a reusable tab component for use on the product
    page to separate reviews the product descriptions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 复合组件是一组共同工作的组件。我们将使用这种模式在产品页面上创建一个可重用的选项卡组件，以分隔产品描述和评论。
- en: Adding reviews to a product
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品添加评论
- en: 'Before we create our `Tabs` compound component, let''s add reviews to the product
    page:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的`Tabs`复合组件之前，让我们在产品页面上添加评论：
- en: 'First, we need to add an interface for the review data structure in `ProductsData.ts`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`ProductsData.ts`中为评论数据结构添加一个接口：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now add reviews to our product interface :'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将评论添加到我们的产品接口中：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now add reviews to our product data array:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将评论添加到我们的产品数据数组中：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, we add a `reviews` property to each product that is an array of reviews.
    Each review is an object containing `comment` and `reviewer` properties as defined
    by the `IReview` interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为每个产品添加了一个`reviews`属性，它是一个评论数组。每个评论都是一个包含`comment`和`reviewer`属性的对象，由`IReview`接口定义。
- en: 'With our data in place, let''s add the reviews to our `Product` component after
    the description:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了我们的数据，让我们在描述之后将评论添加到我们的`Product`组件中：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, we are using the `map` function on the `reviews` array to display `comment`
    and `reviewer` in a list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在使用`map`函数在`reviews`数组上显示`comment`和`reviewer`。
- en: 'We have referenced some new CSS classes, so let''s add these into `index.css`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引用了一些新的CSS类，因此让我们将它们添加到`index.css`中：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we look at the running app and go to a product, we''ll now see the reviews:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序并转到产品，我们现在将看到评论：
- en: '![](assets/d72a2bb2-abca-46ce-a62a-c3b1c78c5741.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d72a2bb2-abca-46ce-a62a-c3b1c78c5741.png)'
- en: Now that we have added the reviews, we can work on our `Tabs` component in the
    next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了评论，我们可以在下一节中处理我们的`Tabs`组件。
- en: Creating a basic tab component
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的选项卡组件
- en: Our job now is to separate the description from the reviews using a tab component
    that we are going to build. We are going to create a simple tab component first
    and refactor this into the compound component pattern in the next section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作现在是使用我们将要构建的选项卡组件将描述与评论分开。我们将首先创建一个简单的选项卡组件，然后在下一节将其重构为复合组件模式。
- en: 'It''s time to start on our tab component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始我们的选项卡组件了：
- en: 'First, let''s create a file called `Tabs.tsx` for our tab component with the
    following content in it as a skeleton class component:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`Tabs.tsx`的文件，用以下内容作为骨架类组件：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have chosen to create a class-based component because our component will
    have to track state for whichever tab heading is active.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择创建基于类的组件，因为我们的组件将需要跟踪活动的选项卡标题的状态。
- en: 'So, let''s complete the interface for our state by adding a property that will
    give the active heading name:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们通过添加一个属性来完成我们状态的接口，该属性将给出活动的标题名称：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our component will take in the tab headings and display them as properties.
    So, let''s complete our interface for this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的组件将接受选项卡标题并将它们显示为属性。因此，让我们完成这个接口：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, our component can take in an array of heading names in a `headings` prop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的组件可以接受一个`headings`属性中的标题名称数组。
- en: 'Let''s create the initial value for the `activeHeading` state in the constructor
    now:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在在构造函数中为`activeHeading`状态创建初始值：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, the active heading will initially be set to the first element in the `headings`
    array. The ternary ensures our component doesn't produce an error if no tabs have
    been passed to it by the consumer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，活动标题最初将设置为`headings`数组中的第一个元素。三元运算符确保我们的组件在消费者未传递任何选项卡时不会产生错误。
- en: 'Moving on to the render method now, let''s render our tabs in a list by mapping
    over the `headings` prop:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到渲染方法，让我们通过映射`headings`属性在列表中渲染我们的选项卡：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have referenced some CSS classes including `active`, which is set using a
    ternary based on whether it is the active tab heading being rendered or not.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引用了一些CSS类，包括`active`，它是基于三元运算符设置的，取决于正在呈现的是否是活动选项卡标题。
- en: 'Let''s add these CSS classes to `index.css` now:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将这些CSS类添加到`index.css`中：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before we can see what our tab component looks like, we need to consume it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以看到我们的选项卡组件是什么样子之前，我们需要使用它。
- en: 'So, let''s add this on the `Product` component by first importing the `Tabs`
    component:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们首先导入`Tabs`组件，然后将其添加到`Product`组件中。
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now add the `Tabs` component in between the product name and description:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在产品名称和描述之间添加`Tabs`组件：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We pass the `Tabs` component the two tab headings we want to display, which
    are Description and Reviews.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`Tabs`组件传递我们要显示的两个选项卡标题，即描述和评论。
- en: 'Let''s see what this looks like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是什么样子：
- en: '![](assets/2224eb38-ef28-4945-9ee0-e297c2a8a6e1.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2224eb38-ef28-4945-9ee0-e297c2a8a6e1.png)'
- en: That's a good start. The first tab is underlined from the `active` CSS style
    just as we wanted. If we click on the Reviews tab nothing happens, though.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的开始。第一个选项卡下划线是`active` CSS样式，正如我们所希望的那样。但是，如果我们点击评论选项卡，什么也不会发生。
- en: 'So, let''s reference the click handler back in `Tabs.tsx` for each tab:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们在`Tabs.tsx`中引用点击处理程序来处理每个选项卡：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s implement the click handler as well now:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们也实现点击处理程序：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We first extract the heading from the `textContent` of `li`. We then set the
    `activeHeading` state to this. This will cause React to re-render the component
    with the clicked tab shown as being active.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`li`的`textContent`中提取标题。然后将`activeHeading`状态设置为此标题。这将导致React重新渲染组件，显示所点击的选项卡为活动状态。
- en: Notice that we help the TypeScript compiler declare the `li` variable as `HTMLLIElement`
    using the `as` keyword. Without doing this, the compiler wouldn't be happy with
    us accessing the `textContent` property within it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`as`关键字帮助TypeScript编译器将`li`变量声明为`HTMLLIElement`。如果不这样做，编译器将不允许我们访问其中的`textContent`属性。
- en: If we go to the running app again, we can now click on our tabs and see the
    active state changing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次转到运行的应用程序，现在我们可以单击选项卡并看到活动状态的变化。
- en: At the moment, our tabs component just renders some tabs that can be clicked
    on. It doesn't tie into any content yet. We'll actually not tie in our headings
    to content until the next section on the render props pattern. However, now it's
    time to explore the compound component pattern and enhance our tab headings a
    little more in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的选项卡组件只是渲染一些可以单击的选项卡。它还没有与任何内容相关联。直到下一节关于渲染属性模式的部分，我们才会将标题与内容关联起来。但是，现在是时候探索复合组件模式，并在下一节中稍微增强我们的选项卡标题。
- en: Leveraging the compound component pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用复合组件模式
- en: 'Our tab headings can only be strings at the moment. What if we want to allow
    the consumer of the component to define richer content in the headings? For example,
    a consumer might want to put an icon in front of a tab heading or make a heading
    bold. So, the consuming JSX could look something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的选项卡标题只能是字符串。如果我们希望允许组件的使用者在标题中定义更丰富的内容怎么办？例如，使用者可能希望在选项卡标题前放置图标或使标题加粗。因此，使用的JSX可能如下所示：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the previous example, `Tabs` and `Tabs.Tab` are compound components:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`Tabs`和`Tabs.Tab`是复合组件：
- en: '`Tabs` is the component that renders the `Tabs.Tab` components within it. It
    also manages the state for whichever tab is active.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs`是渲染其中的`Tabs.Tab`组件的组件。它还管理活动选项卡的状态。'
- en: '`Tabs.Tab` renders a single heading. It takes a unique tab name as a property,
    which allows the active tab to be managed. It also takes in a `boolean` property called
    `initialActive` that sets that tab to be active when first loaded. The heading
    that is rendered is the content within the `Tabs.Tab` tag. So, the first tab will
    render Description in bold.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs.Tab`渲染单个标题。它以唯一的选项卡名称作为属性，允许管理活动选项卡。它还接受一个名为`initialActive`的`boolean`属性，该属性在首次加载时设置该选项卡为活动状态。渲染的标题是`Tabs.Tab`标记内的内容。因此，第一个选项卡将以粗体呈现描述。'
- en: 'So, let''s refactor our basic tabs component into a compound component that
    can be used similarly to the previous example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的基本选项卡组件重构为一个复合组件，可以类似于上一个示例中使用：
- en: 'Our `Tabs` component no longer takes in any properties, so, let''s remove the
    `IProps` interface. We can remove the constructor because we no longer need to
    initialize the state from the props. Let''s also change the name of our state
    property from `activeHeading` to `activeName` as well:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Tabs`组件不再接受任何属性，因此，让我们删除`IProps`接口。我们可以删除构造函数，因为我们不再需要从属性初始化状态。我们还将状态属性的名称从`activeHeading`更改为`activeName`：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are going to work on the `Tab` component within `Tabs`, first. So, let''s
    create an interface for its properties:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在`Tabs`中工作`Tab`组件。因此，让我们为其属性创建一个接口：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `name` property is a unique name for the tab. This will be used later to
    help us manage the active tab.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`属性是选项卡的唯一名称。稍后将使用它来帮助我们管理活动选项卡。'
- en: The `initialActive` property specifies whether the tab is active when the component
    first loads.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialActive`属性指定组件首次加载时选项卡是否处于活动状态。'
- en: 'Let''s add the following `Tab` function component inside our `Tabs` class component
    now:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在我们的`Tabs`类组件中添加以下`Tab`函数组件：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the start of the component that will render each tab. The `Tab` component
    is defined as a static property on the `Tabs` component. This means `Tab` lives
    on the actual `Tabs` class and not in its instances. So, we must remember we don't
    have access to any `Tabs` instance members (for instance, `this`). However, we
    can reference `Tab` in JSX using `Tabs.Tab` now, which was one of our requirements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将渲染每个标签的组件的开始。`Tab`组件被定义为`Tabs`组件的静态属性。这意味着`Tab`存在于实际的`Tabs`类中，而不是它的实例中。因此，我们必须记住我们无法访问任何`Tabs`实例成员（例如`this`）。但是，现在我们可以在JSX中使用`Tabs.Tab`来引用`Tab`，这是我们的要求之一。
- en: 'At the moment, `Tab` is just rendering `li` with a note reminding us that we
    need to somehow render the child nodes of the component. Remember that we want
    the consuming markup for our `Tabs` component to be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Tab`只是渲染带有提醒的`li`，提醒我们需要以某种方式渲染组件的子节点。请记住，我们希望消费`Tabs`组件的标记如下：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, our render function needs to somehow render `<b> Description </b>` inside
    our `li` tag. How do we do this? The answer is via a special property called `children`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们的渲染函数需要以某种方式在我们的`li`标签内渲染`<b> Description </b>`。我们该如何做呢？答案是通过一个叫做`children`的特殊属性：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: React component properties can be of any type, including React nodes. The `children` property
    is a special property that React gives a component that contains the component's
    child nodes. We render a component's child nodes in JSX by referencing the `children` property
    in curly brackets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: React组件属性可以是任何类型，包括React节点。`children`属性是React给组件的一个特殊属性，其中包含组件的子节点。我们通过在JSX中引用`children`属性来渲染组件的子节点。
- en: Our `Tab` component is not finished, but we'll leave it like this for the time
    being. We now need to move on to the `Tabs` component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Tab`组件还没有完成，但我们暂时会保持这样。现在我们需要继续进行`Tabs`组件。
- en: 'The `render` method in the `Tabs` class is simply going to render its child
    nodes now. Let''s replace this method with the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Tabs`类中的`render`方法现在只是简单地渲染其子节点。让我们用以下内容替换这个方法：'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We again use the magical `children` property to render the child nodes within
    `Tabs`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用神奇的`children`属性来渲染`Tabs`中的子节点。
- en: We are progressing well with our compound `Tabs` and `Tab` components but our
    project no longer compiles because we have the tab click handler, `handleTabClick`,
    that is not referenced anymore. We need to somehow reference it from the `Tab` component
    when a tab heading is clicked, but remember `Tab` doesn't have access to members
    of `Tabs`. So, how can we do this? We'll find the answer to this problem in the
    next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在复合`Tabs`和`Tab`组件中取得了进展，但是我们的项目不再编译，因为我们有一个标签点击处理程序`handleTabClick`，它不再被引用。当点击标签标题时，我们需要以某种方式从`Tab`组件中引用它，但请记住`Tab`无法访问`Tabs`的成员。那么，我们该如何做呢？我们将在下一节中找到这个问题的答案。
- en: Sharing state with React context
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React上下文共享状态
- en: 'React context allows state to be shared between components. It works really
    well with compound components. We are going to use it in our `Tabs` and `Tab`
    components to share state between them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文允许在组件之间共享状态。它与复合组件非常配合。我们将在`Tabs`和`Tab`组件中使用它来共享状态：
- en: 'Our first task is to create an interface for the context we are going to use
    in `Tabs.tsx` at the top of the file just beneath the import statements:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是在文件顶部创建一个用于`Tabs.tsx`中使用的上下文接口，就在导入语句的下面：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, our context will contain the active tab name as well as a reference to a
    tab click handler. These are the two bits of state that need to be shared between
    the components.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的上下文将包含活动标签名称以及标签点击处理程序的引用。这些是需要在组件之间共享的两个状态。
- en: 'Next, let''s create the context underneath the `ITabsContext` interface:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`ITabsContext`接口下创建上下文：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We've used the `createContext` function in React to create our context, which
    is a generic function that creates a context of a generic type, which in our case
    in `ITabsContext`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在React中使用`createContext`函数创建了我们的上下文，这是一个通用函数，用于创建一个通用类型的上下文，在我们的情况下是`ITabsContext`。
- en: We are required to pass the default context value as the parameter value to
    `createContext` but that doesn't make sense in our case, so we just pass an empty `{}`
    object to keep the TypeScript compiler happy. This is why both the properties
    in `ITabsContext` are optional.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将默认上下文值作为参数值传递给`createContext`，但在我们的情况下这是没有意义的，所以我们只是传递一个空的`{}`对象，以使TypeScript编译器满意。这就是为什么`ITabsContext`中的两个属性都是可选的。
- en: 'It''s time to use this context now in our compound components. The first thing
    we need to do is to define the context provider in the `Tabs` `render` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在我们的复合组件中使用这个上下文了。我们需要做的第一件事是在`Tabs`的`render`方法中定义上下文提供程序：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are a few things going on here, so let''s break this down:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些事情要处理，所以让我们来分解一下：
- en: The constant for our context we declared earlier, `TabsContext`, is available
    in JSX as a `<TabsContext />` component.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前声明的上下文常量`TabsContext`在JSX中可以作为`<TabsContext />`组件使用。
- en: The context provider fills the context with values. Given that `Tabs` manages
    the state and event handling, it makes sense for the provider to be referenced
    there.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文提供程序用值填充上下文。鉴于`Tabs`管理状态和事件处理，将提供程序引用到那里是有意义的。
- en: We reference the provider using `<TabsContext.Provider />`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`<TabsContext.Provider />`引用提供程序。
- en: The provider takes in a property called `value` for the context value. We set
    this to an object containing the active tab name and the tab click event handler.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供程序接受一个名为`value`的属性作为上下文值。我们将其设置为一个包含活动选项卡名称和选项卡点击事件处理程序的对象。
- en: 'We need to adjust the tab click handler slightly because the click isn''t going
    to be handled directly in `Tabs` anymore. So, we simply need to take in the active
    tab name as a parameter and then set the active tab name state within the method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要稍微调整选项卡点击处理程序，因为点击不再直接在`Tabs`中处理。因此，我们只需要将活动选项卡名称作为参数传入，然后在方法中设置活动选项卡名称状态：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have fed the context some data, it''s time to consume this in the
    `Tab` component:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经向上下文提供了一些数据，是时候在`Tab`组件中使用它了：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This again looks a little daunting, so let''s break it down:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来又有点令人生畏，所以让我们来分解一下：
- en: We can consume a context via a `Consumer` component within the context component.
    So, this is `<TabsContext.Consumer />` in our case.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过上下文组件内的`Consumer`组件来消费上下文。所以，在我们的情况下是`<TabsContext.Consumer />`。
- en: The child for `Consumer` needs to be a function that has a parameter for the
    context value and returns some JSX. `Consumer` will then render the JSX we return.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer`的子代需要是一个具有上下文值参数并返回一些JSX的函数。`Consumer`然后将渲染我们返回的JSX。'
- en: Don't worry if this is still a little confusing. We'll cover this pattern in
    a lot more detail later when we cover children props and render props.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然有点令人困惑，不要担心。当我们讨论子代属性和渲染属性时，我们将在以后更详细地介绍这种模式。
- en: This context function gives us everything we need to render the tab. We have
    access to the state from the `context` argument as well as access to the `Tab`
    component `props` object.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个上下文函数为我们提供了渲染选项卡所需的一切。我们可以从`context`参数中访问状态，还可以访问`Tab`组件的`props`对象。
- en: The first line of the function determines the active tab name by using what
    is in the context. If the active tab in the context is an empty string, we use
    the current tab name if it has been defined as the initial active tab.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的第一行通过使用上下文中的内容来确定活动选项卡名称。如果上下文中的活动选项卡是空字符串，我们将使用当前选项卡名称，如果已经定义为初始活动选项卡。
- en: The second line of the function creates a tab click handler that calls the context
    tab click handler if it has been specified.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的第二行创建了一个标签点击处理程序，如果已经指定了上下文标签点击处理程序，则调用它。
- en: The return statement is as it was before, but we've been able to add a reference
    to the tab click handler and the class name now.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回语句与以前一样，但我们已经能够添加标签点击处理程序的引用和类名。
- en: So, that's it for our tabs compound component. The syntax for React context
    may seem a little strange at first, but when you get used to it, it is really
    simple and elegant.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们的标签复合组件。React上下文的语法一开始可能看起来有点奇怪，但当你习惯了它之后，它真的很简单和优雅。
- en: 'Before we can give this a try, we need to consume our compound component in
    our `Product` component. Let''s replace our previous consumption of the `Tabs`
    component with the following highlighted JSX:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试之前，我们需要在我们的`Product`组件中使用我们的复合组件。让我们用以下突出显示的JSX替换我们之前对`Tabs`组件的使用：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is exactly the JSX we wanted to achieve when we started to build the compound
    tabs component. If we go to the running app and browse to the product page, our
    tabs component works perfectly, with the description tab in bold:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在开始构建复合标签组件时想要实现的JSX。如果我们转到运行的应用程序并浏览到产品页面，我们的标签组件将完美地工作，描述标签会以粗体显示：
- en: '![](assets/2cb6cee1-2be4-4f5b-b4a2-d71dbe9bf45d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2cb6cee1-2be4-4f5b-b4a2-d71dbe9bf45d.png)'
- en: So, compound components are great for components that rely on each other. The `<Tabs.Tab
    />` syntax really *calls out the fact* that `Tab` needs to be used with `Tabs`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，复合组件非常适合相互依赖的组件。`<Tabs.Tab />`的语法真的*强调了*`Tab`需要与`Tabs`一起使用。
- en: React context works really well with compound components allowing the components,
    in the compound to easily share state. The state can even include functions such
    as event handlers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文与复合组件非常配合，允许复合中的组件轻松共享状态。状态甚至可以包括诸如事件处理程序之类的函数。
- en: Allowing the consumer to specify the content to be rendered in sections of a
    component gives the consumer a great deal of flexibility. Specifying this custom
    content as a child of a component is intuitive and feels natural. We'll continue
    with this approach in the following section where we'll complete our tabs component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 允许消费者指定要在组件的各个部分中呈现的内容，为消费者提供了极大的灵活性。将此自定义内容指定为组件的子级是直观且自然的。在接下来的部分中，我们将继续使用这种方法来完成我们的标签组件。
- en: Render props pattern
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染道具模式
- en: We used a form of the render props pattern in the previous section where we
    leveraged the `children` prop. We used this to allow a consumer of our `Tab` component
    to render custom content for the tab heading. This is great, but what if we want
    to allow the consumer to render custom content in different sections of the component?
    In our `Tabs` component, we haven't allowed the consumer to render the content
    of the tab yet. We definitely want the consumer to be able to specify custom content
    for this, but how do we do this now that we've already used the `children` prop
    for the heading?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了渲染道具模式的一种形式，其中我们利用了`children`道具。我们用它来允许`Tab`组件的消费者为标签标题呈现自定义内容。这很好，但是如果我们想允许消费者在组件的不同部分呈现自定义内容怎么办？在我们的`Tabs`组件中，我们还没有允许消费者呈现标签的内容。我们确实希望消费者能够为此指定自定义内容，但是既然我们已经使用了`children`道具来表示标题，那么现在该怎么做呢？
- en: The answer is simple but not obvious at first. The answer is that, because props
    can be anything, they can be a function that renders content – just like the special
    `children` prop. These types of prop are called render props. We can have as many
    render props as we like, giving us the flexibility to allow multiple sections
    of a component to be rendered by the consumer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单，但一开始并不明显。答案是，因为props可以是任何东西，它们可以是一个呈现内容的函数 - 就像特殊的`children`prop一样。这些类型的prop被称为渲染prop。我们可以拥有尽可能多的渲染prop，从而灵活地允许消费者呈现组件的多个部分。
- en: We actually used a render prop in the last section when we used React context.
    The way we consumed the context was via a render prop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当我们使用React上下文时，实际上使用了渲染prop。我们消费上下文的方式是通过渲染prop。
- en: Next, we'll complete our `Tabs` component by leveraging the render props pattern.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将利用渲染prop模式完成我们的`Tabs`组件。
- en: Completing Tabs with render props
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用渲染prop完成Tabs
- en: 'We are going to complete our Tabs component now by using the render props pattern. Before
    we implement our first render prop, let''s think about how we want the consumer
    to consume our `Tabs` component when it has been completed. The following JSX
    is how we would ideally consume the `Tabs` component from the `Product` component:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用渲染prop模式来完成我们的Tabs组件。在我们实现第一个渲染prop之前，让我们考虑一下当`Tabs`组件完成后，我们希望消费者如何消费它。以下的JSX是我们理想情况下从`Product`组件中消费`Tabs`组件的方式：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s go through the steps of the key parts in this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些关键部分的步骤：
- en: We are still using compound components. Render props work perfectly fine with
    these components.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然在使用复合组件。渲染prop与这些组件完全兼容。
- en: The heading for each tab is no longer defined in the child of the `Tab` component.
    Instead, we use a `heading` render prop where we can still render a simple string
    or richer content.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个选项卡的标题不再在`Tab`组件的子元素中定义。相反，我们使用一个`heading`渲染prop，在那里我们仍然可以呈现简单的字符串或更丰富的内容。
- en: The tab content is then specified as the child of the `Tab` component.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后指定选项卡内容为`Tab`组件的子元素。
- en: Using render prop for tab headings
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用渲染prop来设置选项卡标题
- en: 'So, let''s change the implementation of the tab headings to use a render prop:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们改变选项卡标题的实现，使用渲染prop：
- en: 'In `Tabs.tsx`, let''s start by adding a new property in the tab props interface
    for the heading:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tabs.tsx`中，让我们首先在选项卡props接口中添加一个新的属性用于标题：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This property is a function with no parameters that returns a `string` or some
    JSX. This is the definition of our render prop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是一个没有参数的函数，返回一个`string`或一些JSX。这就是我们的渲染prop的定义。
- en: 'Changing the implementation is very straightforward. We simply replace the
    call to the `children` prop function with our new render prop function in the
    return statement in the `Tab` component:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改实现非常简单。我们只需在`Tab`组件的返回语句中用新的渲染prop函数替换对`children`prop函数的调用：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s switch the consumption of `Tabs` in `Product.tsx` to the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`Product.tsx`中`Tabs`的使用切换为以下内容：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We may get a TSLint warning: Lambdas are forbidden in JSX attributes due to
    their rendering performance impact. It is useful to know that lambdas can be problematic
    so that we can keep this in mind for when we do experience a performance problem.
    However, we are going to switch this rule off in `tslint.json` by specifying `"jsx-no-lambda"`
    as `false`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会收到一个TSLint警告：由于其渲染性能影响，JSX属性中禁止使用lambda。知道lambda可能会有问题是有用的，这样我们在遇到性能问题时可以记住这一点。然而，我们将在`tslint.json`中关闭此规则，指定`"jsx-no-lambda"`为`false`：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we want to be super performance-conscious, instead of using a lambda function
    we can reference a method within the component.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要非常关注性能，我们可以引用组件内的方法，而不是使用lambda函数。
- en: After we have saved the new TSLint settings, the compiler complaint will hopefully
    go away. Note that we may need to kill the Terminal and `npm start` the app again
    for the compiler complaint to go away.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存了新的TSLint设置之后，编译器的投诉希望会消失。请注意，我们可能需要杀死终端并再次启动应用程序以消除编译器的投诉。
- en: If we try using the product page in our app, it will behave just as it did before.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在我们的应用程序中使用产品页面，它将表现得和以前一样。
- en: So, implementing the render prop pattern is very simple. The most time-consuming
    thing with this pattern is understanding what it can do and how it works. Once
    we've got to grips with it, it is an excellent pattern we can use to provide rendering
    flexibility to consumers of our components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实现渲染属性模式非常简单。使用此模式最耗时的事情是理解它可以做什么以及它是如何工作的。一旦我们掌握了它，它就是一个可以为我们组件的消费者提供渲染灵活性的优秀模式。
- en: We have just one more section to go now before our `Tab` component is complete.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“Tab”组件完成之前，我们还有最后一个部分要完成。
- en: Using children prop for tab content
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“children”属性来呈现选项卡内容。
- en: 'The finish line is in sight now for our `Tab` component. The final task is
    to allow consumers to render tab content. We''ll use the `children` prop to do
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的“Tab”组件已经接近完成了。最后的任务是允许消费者呈现选项卡内容。我们将使用“children”属性来实现这一点：
- en: 'Firstly, in `Tabs.tsx`, let''s change the `handleTabClick` property in our
    context interface to include the content to render:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在“Tabs.tsx”中，让我们将上下文接口中的“handleTabClick”属性更改为包括要呈现的内容：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We are also going to hold the active content in state along with the active
    tab name. So, let''s add this to the state interface for `Tabs`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在状态接口中保存活动内容以及活动选项卡名称。因此，让我们将其添加到“Tabs”的状态接口中：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s now change the tab click handler in `Tabs` to set the state for the
    active content along with the active tab name:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在“Tabs”中更改选项卡点击处理程序，以设置活动内容的状态以及活动选项卡名称：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `Tab` component, let''s call the tab click handler with the additional
    parameter for the tab content by passing the `children` prop:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Tab”组件中，让我们通过传递“children”属性来调用选项卡点击处理程序，以获取选项卡内容的附加参数：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let''s render the active content from our state in the `Tabs` `render`
    method under where we render the tab headings:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在“Tabs”“render”方法中呈现我们状态中的活动内容，就在我们呈现选项卡标题的下面：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s change how we consume the `Tabs` component in the `Product` component:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变在“Product”组件中使用“Tabs”组件的方式：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The tab content is now nested within each `Tab` component exactly how we wanted.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选项卡内容已经嵌套在每个“Tab”组件中，正如我们所希望的那样。
- en: 'Let''s give this a try. If we go to the product page we notice an issue:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。如果我们转到产品页面，我们会注意到一个问题：
- en: '![](assets/f8461702-bc71-4f68-9eb0-8e684520a27d.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8461702-bc71-4f68-9eb0-8e684520a27d.png)'
- en: The content isn't being rendered when the page first loads. If we click on the
    Reviews tab or the Description tab, the content then loads.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面首次加载时未呈现内容。如果我们单击“Reviews”选项卡或“Description”选项卡，然后内容就会加载。
- en: 'The problem is that we don''t have any code to render the content when the
    tabs initially load. So, let''s resolve this in the `Tab` component by adding
    the highlighted lines:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于当选项卡初始加载时，我们没有任何代码来呈现内容。因此，让我们通过在“Tab”组件中添加高亮显示的行来解决这个问题：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The highlighted lines invoke the tab click handler if there is no active tab
    in the context and the tab is flagged as initially active. In this case, we return
    null because invoking the tab click will set the state for the active tab, which
    will cause another rendering cycle.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的行在上下文中没有活动选项卡并且选项卡被标记为初始活动时，调用选项卡点击处理程序。在这种情况下，我们返回null，因为调用选项卡点击将设置活动选项卡的状态，这将导致另一个渲染周期。
- en: 'Our tabs component should now be complete. Let''s check by going to the product
    page:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的选项卡组件现在应该已经完成了。让我们通过转到产品页面来检查：
- en: '![](assets/cc55df59-386e-410e-a76f-6f37c42b5e7f.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc55df59-386e-410e-a76f-6f37c42b5e7f.png)'
- en: 'The content renders as we expect. If we click on the Reviews tab, this renders
    fine as well:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 内容呈现如我们所期望的那样。 如果我们点击评论选项卡，这也会很好地呈现：
- en: '![](assets/5bae7243-ea0b-4a76-bcb1-7cb5e88cac12.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5bae7243-ea0b-4a76-bcb1-7cb5e88cac12.png)'
- en: So, the render props and children props patterns are great for allowing consumers
    to render custom content. The syntax may look a little tricky at first, but when
    you understand it, it makes perfect sense and is really elegant.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，渲染道具和子道具模式非常适合允许消费者渲染自定义内容。 语法一开始可能看起来有点棘手，但当你理解它时，它就变得非常合理和优雅。
- en: In the next section, we'll look at the final pattern in this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下本章中的最终模式。
- en: Higher-order components
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶组件
- en: 'A **higher-order component** (**HOC**) is a functional component that takes
    in a component as a parameter and returns an enhanced version of that component.
    That may not make a lot of sense, so we''re going to go through an example in
    this section. Our example creates a HOC called `withLoader` that can be applied
    to any component in order to add a loading spinner when the component is busy.
    We are going to use this in our React shop (that we worked on in the last section)
    in the product page whilst data is being fetched. It will look like the following when
    we have finished:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶组件**（**HOC**）是一个将组件作为参数并返回增强版本的函数组件。 这可能不太明晰，因此我们将在本节中通过一个示例来说明。 我们的示例创建了一个名为`withLoader`的HOC，可以应用于任何组件，以在组件忙碌时添加加载旋转器。
    我们将在我们的React商店（我们在上一节中工作过的）中使用它在产品页面上获取数据时。 完成后将如下所示：'
- en: '![](assets/9454161c-6159-4d83-8f20-a1bd53e4137a.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9454161c-6159-4d83-8f20-a1bd53e4137a.png)'
- en: Adding asynchronous data fetching
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加异步数据获取
- en: 'At the moment, the data fetching in our shop is instantaneous because all the
    data is local. So, before working on the `withLoader` component, let''s refactor
    the data fetching functions to include a delay and be asynchronous as well. This
    will better simulate a real data fetching function that gets the data using a
    web API:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们商店中的数据获取是瞬时的，因为所有数据都是本地的。 因此，在着手处理`withLoader`组件之前，让我们重构数据获取函数，包括延迟和异步。
    这将更好地模拟使用Web API获取数据的真实数据获取函数：
- en: 'In `ProductData.ts`, let''s add the following arrow function that can be used
    to get a product:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductData.ts`中，让我们添加以下箭头函数，用于获取产品：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The function takes in the product ID and uses the `filter` function in the `products`
    array to find the product and then returns it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受产品ID并使用`products`数组中的`filter`函数找到产品，然后返回它。
- en: The function is prefixed with the `async` keyword because it is asynchronous.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数以`async`关键字为前缀，因为它是异步的。
- en: 'The function also calls a function called `wait` asynchronously with the `await`
    keyword in front of it. So, let''s create the `wait` function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数还使用`await`关键字异步调用名为`wait`的函数。 因此，让我们创建`wait`函数：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function uses the standard JavaScript `setTimeout` function to wait for
    the number of milliseconds we specify in the function parameter. The function
    returns a `Promise` that is resolved when `setTimeout` completes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用标准的JavaScript `setTimeout`函数等待我们在函数参数中指定的毫秒数。 该函数返回一个在`setTimeout`完成时解析的`Promise`。
- en: Don't worry if the `async` and `await` keywords along with promises don't make
    much sense at the moment. We'll look at these in detail later in the book.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此刻`async`和`await`关键字以及承诺不太明晰，不要担心。 我们将在本书的后面详细讨论这些。
- en: So, we have a function that now fetches a product asynchronously taking at least
    1 second. Let's plug this into our product page. The `ProductPage` component is
    a container component responsible for fetching data, so let's plug this in here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个异步获取产品的函数，至少需要1秒。让我们将其插入到我们的产品页面中。`ProductPage`组件是一个负责获取数据的容器组件，所以让我们在这里插入它。
- en: 'First, let''s import the `getProduct` function into `ProductPage`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将`getProduct`函数导入到`ProductPage`中：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s add a property called `loading` to the state of `ProductPage` to indicate
    whether the data is loading or not:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向`ProductPage`的状态添加一个名为`loading`的属性，以指示数据是否正在加载：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s also initialize this state to `true` in the constructor:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在构造函数中也将这个状态初始化为`true`：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we can use the `getProduct` function when the `ProductPage` component
    loads:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`ProductPage`组件加载时使用`getProduct`函数：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We call `getProduct` asynchronously using the `await` keyword. In order to do
    this, we need to mark the `componentDidMount` lifecycle method as asynchronous
    with the `async` keyword. After we've got the product, we set it in the state
    and reset the `loading` flag to `false`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`await`关键字异步调用`getProduct`。为了做到这一点，我们需要使用`async`关键字将`componentDidMount`生命周期方法标记为异步。在获取产品后，我们将其设置在状态中，并将`loading`标志重置为`false`。
- en: 'If our shop isn''t running, let''s run this:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的商店没有运行，让我们运行这个：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we go to the product page, we see that it takes roughly 1 second for the
    product to load now. You may notice Product not found! being displayed whilst
    the product loads. This is because the product is not set on the initial render.
    We'll ignore this for the time being because our `withLoader` HOC will resolve
    this issue.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到产品页面，我们会发现产品加载大约需要1秒。您可能会注意到在产品加载时显示“产品未找到！”。这是因为产品在初始渲染时未设置。我们暂时忽略这个问题，因为我们的`withLoader`HOC将解决这个问题。
- en: So, now that we are getting data asynchronously and roughly taking 1 second,
    we are ready to implement our `withLoader` HOC and use it on the product page.
    We'll do just this in the next section.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们正在异步获取数据，大约需要1秒，我们准备实现我们的`withLoader`HOC并在产品页面上使用它。我们将在下一节中完成这个操作。
- en: Implementing the withLoader HOC
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`withLoader` HOC
- en: 'We''re going to create a loader spinner component called `withLoader` that
    can be used with any component to indicate that the component is busy doing something:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`withLoader`的加载器组件，可以与任何组件一起使用，以指示组件正在忙于执行某些操作：
- en: 'Let''s start by creating a new file called `withLoader.tsx` with the following
    content:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`withLoader.tsx`的新文件，内容如下：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There are a few things going on here, so let''s break this down:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些事情正在发生，让我们来分解一下：
- en: '`withLoader` is a function that that takes in a component of type `P`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withLoader`是一个接受类型为`P`的组件的函数。'
- en: '`withLoader` calls a function component.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withLoader`调用一个函数组件。'
- en: The properties for the function component are defined as `P & IProps`, which
    is an intersection type.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件的属性被定义为`P & IProps`，这是一个交集类型。
- en: An intersection type combines multiple types into one. So `X`, and `Y`, and `Z`
    combine all the properties and methods of `X`, `Y`, and `Z` together into a new
    type.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 交集类型将多种类型合并为一个。因此，`X`，`Y`和`Z`将`X`，`Y`和`Z`的所有属性和方法合并到一个新类型中。
- en: So, the properties for the SFC include all the properties from the component
    passed in along with a `loading` `boolean` property that we defined.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，SFC的属性包括从传入的组件中获取的所有属性，以及我们定义的`loading`布尔属性。
- en: The props are destructured into a `loading` variable and a `props` variable
    containing all the other properties using a rest parameter.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用剩余参数，将props解构为一个`loading`变量和一个包含所有其他属性的`props`变量。
- en: 'So, the remaining work we have to do is return our loading spinner if `loading`
    is `true`, otherwise we just need to return the component passed in. We can do
    this using a ternary expression highlighted in the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们剩下要做的工作是，如果`loading`为`true`，则返回我们的加载旋转器，否则我们只需要返回传入的组件。我们可以使用下面代码中窗口中突出显示的三元表达式来实现这一点：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The component passed in is returned in the second ternary branch. We use the
    spread syntax to spread the properties in the `props` variable into the component.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的组件在第二个三元分支中返回。我们使用扩展语法将`props`变量中的属性扩展到组件中。
- en: The loading spinner is returned in the first ternary branch.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 加载旋转器在第一个三元分支中返回。
- en: 'The loading spinner references some CSS classes, so let''s add these into `index.css`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载旋转器引用了一些CSS类，所以让我们把它们添加到`index.css`中：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `loader-overlay` class creates a black see-through overlay over the whole
    page. The `loader-circle-wrap` class creates a `100px` by `100px` square in the
    center of the overlay. The `loader-circle` class creates the spinning circle.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader-overlay`类在整个页面上创建一个黑色的透明覆盖层。`loader-circle-wrap`类在覆盖层的中心创建一个`100px`乘`100px`的正方形。`loader-circle`类创建旋转的圆圈。'
- en: Our `withLoader` HOC is now complete.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`withLoader` HOC现在已经完成。
- en: 'For reference, a class-based version of `withLoader` is shown in the following
    code block:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，下面的代码块显示了基于类的`withLoader`版本：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We are going to stick with the SFC version, though, because it doesn't contain
    any state or need access to any lifecycle methods.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持使用SFC版本，因为它不包含任何状态，也不需要访问任何生命周期方法。
- en: In the next section, we'll consume our `withLoader` component in the product
    page in our shop app.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在商店应用程序中的产品页面中使用我们的`withLoader`组件。
- en: Consuming the withLoader HOC
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用withLoader HOC
- en: Consuming a HOC is very simple. We simply wrap the HOC around the component
    that we want to enhance. The easiest place to do this is in the export statement.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HOC非常简单。我们只需将HOC包装在我们想增强的组件周围。这样做的最简单的地方是在导出语句中。
- en: 'Let''s add the `withLoader` HOC we created in the previous section to our product
    page:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将在上一节中创建的`withLoader` HOC添加到我们的产品页面中：
- en: 'So, we are going to wrap the `Product` component with `withLoader`. First,
    let''s import `withLoader` into `Product.tsx`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将使用`withLoader`来包装`Product`组件。首先，让我们将`withLoader`导入到`Product.tsx`中：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we can wrap `withLoader` around `Product` in the export statement:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在导出语句中将`withLoader`包装在`Product`周围：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We now get a compilation error in the `ProductPage` component because it expects
    to pass `Product` a loading property.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ProductPage`组件中，我们得到了一个编译错误，因为它期望向`Product`传递一个loading属性。
- en: 'So, let''s pass the loading property from the loading state where we reference
    `Product` in `ProductPage`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们在引用`Product`时，从加载状态中传递loading属性：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Whilst still in `ProductPage.tsx`, we should revise the condition that renders
    the `Product` component. We now want to render `Product` if the product is still
    being loaded. This will then render the loading spinner:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductPage.tsx`中，我们应该修改渲染`Product`组件的条件。现在，如果产品仍在加载，我们希望渲染`Product`。然后将渲染加载旋转器：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This gives us another compilation error, though, because the `product` property
    within the `Product` component doesn't expect to be `undefined`. However, it will
    be `undefined` when the product is being loaded.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致另一个编译错误，因为`Product`组件内的`product`属性不希望是`undefined`。然而，在加载产品时它将是`undefined`。
- en: 'So, let''s make this property optional in `IProps` for the `Product` component:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们在`IProps`中将这个属性设为可选的，用于`Product`组件：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This then gives further compilation errors in the JSX in the `Product` component
    where we reference the `product` property because it now will be `undefined` during
    the loading of the data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在`Product`组件中引用`product`属性时，JSX中会出现进一步的编译错误，因为在加载数据时它现在将是`undefined`。
- en: 'A simple resolution to this is to render `null` if we don''t have a product.
    The `withLoader` HOC that wraps `Product` will render a loading spinner in this
    case, anyway. So, we are just keeping the TypeScript compiler happy here:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的解决方法是，如果我们没有产品，就渲染`null`。`withLoader`高阶组件在这种情况下会渲染一个加载旋转器。所以，我们只是让TypeScript编译器在这里很高兴：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now that the TypeScript compiler is happy, if we go to the product page in
    our shop it will display our loading spinner before rendering the product:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在TypeScript编译器很高兴，如果我们去商店的产品页面，它将在渲染产品之前显示我们的加载旋转器：
- en: '![](assets/13a53776-e0bb-4729-8884-3a88283ab8f7.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13a53776-e0bb-4729-8884-3a88283ab8f7.png)'
- en: So, HOCs are great for enhancing components where the enhancement is something
    that can be applied to many components. Our loader spinner is a common use case
    for a HOC. Another very common usage of the HOC pattern is when using React Router.
    We used the React Router `withRouter` HOC previously in this book to access parameters
    for a path.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，高阶组件非常适合增强组件，其中增强是可以应用于许多组件的东西。我们的加载旋转器是高阶组件的一个常见用例。另一个非常常见的HOC模式的用法是在使用React
    Router时。在本书的前面，我们使用了React Router的`withRouter`高阶组件来访问路径的参数。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about container components and how they can be used
    to manage state and what presentational components need to do. Presentational
    components can then focus on what they need to look like. This allows presentational
    components to be more easily reused in multiple places and unit-tested.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了容器组件以及它们如何用于管理状态以及展示组件需要做什么。然后展示组件可以专注于它们需要看起来的样子。这使得展示组件可以更容易地在多个地方重复使用并进行单元测试。
- en: We learned that compound components are components that rely on each other.
    Declaring compound children as static members on the parent class make it clear
    to a consumer that the components should be used together. React context is a
    convenient way for compound components to share their state.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了复合组件是相互依赖的组件。在父类上将复合子项声明为静态成员，可以清楚地告诉消费者这些组件应该一起使用。React上下文是复合组件共享状态的便捷方式。
- en: We learned about the special children prop that can be used to access and render
    a component's children. We then learned that we can create our own render props
    to give consumers great flexibility for custom-rendering sections of a component.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了特殊的children属性，可以用来访问和渲染组件的子项。然后我们学到，我们可以创建自己的渲染属性，为消费者提供对组件的自定义渲染部分的极大灵活性。
- en: In the last section, we learned about higher-order components and how they can
    be used to implement common enhancements to components. We already consumed the
    React Router higher-order component when gaining access to a paths parameters
    earlier in the book.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了高阶组件以及它们如何用于实现对组件的常见增强。在本书的前面，我们已经使用了React Router高阶组件来获取路径参数。
- en: In the next chapter, we'll learn how we create forms in React. Towards the end
    of the next chapter, we'll use some of these patterns that we have learned in
    this chapter in order to deal with forms in a generic way.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在React中创建表单。在下一章的末尾，我们将使用本章学到的一些模式来以通用的方式处理表单。
- en: Questions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let''s put what we have learned about component patterns to the test with some
    questions:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些问题来测试一下我们对组件模式的学习成果：
- en: What special property does React give us to access a component's, children?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React给我们提供了什么特殊属性来访问组件的子项？
- en: How many components can share state with React context?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少组件可以通过React上下文共享状态？
- en: When consuming the React context, what pattern does it use to allow us to render
    our content with the context?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用React上下文时，它使用什么模式来允许我们使用上下文渲染我们的内容？
- en: How many render props can we have in a component?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件中有多少个渲染props？
- en: How many children props do we have in a component?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件中有多少个children props？
- en: 'We only used `withLoader` on the product page. We use the following function
    in `ProductData.ts` to get all the products:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只在产品页面上使用了`withLoader`。我们在`ProductData.ts`中使用以下函数来获取所有产品：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Can you use this to implement a loader spinner on the products page by consuming
    the `withLoader` HOC?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你能用这个来通过使用`withLoader`高阶组件在产品页面上实现一个加载器吗？
- en: 'Is it possible to create a loader spinner using the children props pattern?
    The consuming JSX would be something like the following:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以使用children props模式来创建一个加载器？消费的JSX可能如下所示：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If so, have a go at implementing it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以的话，试着去实现它。
- en: Further reading
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: React context is explained in detail in the React documentation at the following
    link: [https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React上下文在React文档中有详细说明，链接如下：[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
- en: Higher-order components are detailed in the React documentation at the following
    link: [https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶组件在React文档中有详细说明，链接如下：[https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html)
- en: The render props pattern is explained in the React documentation at the following
    link: [https://reactjs.org/docs/render-props.html](https://reactjs.org/docs/render-props.html)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染props模式在React文档中有详细说明，链接如下：[https://reactjs.org/docs/render-props.html](https://reactjs.org/docs/render-props.html)
