- en: Working with Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单
- en: Forms are extremely common in the apps we build. In this chapter, we'll learn
    how to build forms using controlled components in React and TypeScript. We'll
    build a Contact Us form for the React shop we have been working on in other chapters
    as our learning exercise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 表单在我们构建的应用程序中非常常见。在本章中，我们将学习如何在React和TypeScript中使用受控组件构建表单。作为学习练习，我们将为我们在其他章节中一直在开发的React商店构建一个联系我们表单。
- en: We'll quickly discover that there is a fair amount of boilerplate code involved
    in creating forms, so we'll look at building a generic form component to reduce
    the boilerplate code. Client-side validation is critical to the user experience
    of the forms we build, so we'll also cover this topic in a fair amount of depth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会发现，在创建表单时涉及大量样板代码，因此我们将研究构建通用表单组件以减少样板代码。客户端验证对我们构建的表单的用户体验至关重要，因此我们还将深入讨论这个主题。
- en: Finally, form submission is a critical consideration. We'll cover how to handle
    submission errors, as well as success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，表单提交是一个关键考虑因素。我们将介绍如何处理提交错误，以及成功情况。
- en: 'In this chapter, we''ll discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a form with controlled components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用受控组件创建表单
- en: Reducing boilerplate code with generic components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用组件减少样板代码
- en: Validating forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证表单
- en: Form submission
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单提交
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We''ll use the following technologies in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用以下技术：
- en: '**Node.js** and `npm`: TypeScript and React are dependent on these. Install
    them from the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**和`npm`：TypeScript和React依赖于这些。可以从以下链接安装它们：[https://nodejs.org/en/download/](https://nodejs.org/en/download)。如果您已经安装了这些，请确保`npm`至少是5.2版本。'
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来编写React和TypeScript'
- en: code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We'll also need the TSLint extension (by egamma) and the Prettier extension (by
    Estben Petersen).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码，可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装。我们还需要TSLint扩展（由egamma提供）和Prettier扩展（由Estben
    Petersen提供）。
- en: '**React shop**: We''ll start with the React shop project we finished in [Chapter
    6](3680b0b4-3a8c-4fae-8ac2-da283139bbb6.xhtml), *Component Patterns*. This is
    available on GitHub at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React商店**：我们将从[第6章](3680b0b4-3a8c-4fae-8ac2-da283139bbb6.xhtml)完成的React商店项目开始，*组件模式*。这可以在GitHub上找到：[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns)。'
- en: In order to restore code from a previous chapter, the `LearnReact17WithTypeScript`
    repository at [https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript)
    can be downloaded. The relevant folder can then be opened in Visual Studio Code
    and then `npm install` can be entered in the terminal to do the restore. All the
    code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从上一章节恢复代码，可以在[https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript)上下载`LearnReact17WithTypeScript`存储库。然后可以在Visual
    Studio Code中打开相关文件夹，然后在终端中输入`npm install`来进行恢复。本章中的所有代码片段都可以在[https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms)上找到。
- en: Creating a form with controlled components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用受控组件创建表单
- en: Forms are a common part of most apps. In React, the standard way to create a
    form is with what is called *controlled components*. A controlled component has
    its value synchronized with state in React. This will make more sense when we've
    implemented our first controlled component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是大多数应用程序的常见部分。在React中，创建表单的标准方式是使用所谓的*受控组件*。受控组件的值与React中的状态同步。当我们实现了我们的第一个受控组件时，这将更有意义。
- en: We are going to extend the React shop we have been building to include a Contact
    Us form. This will be implemented using controlled components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们一直在构建的React商店，以包括一个联系我们表单。这将使用受控组件来实现。
- en: Adding a Contact Us page
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加联系我们页面
- en: Before we start work on our form, we need a page to host the form in. The page
    will be a container component, and our form will be a presentational component.
    We also need to create a navigation option that takes us to our new page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理表单之前，我们需要一个页面来承载表单。该页面将是一个容器组件，我们的表单将是一个展示组件。我们还需要创建一个导航选项，可以带我们到我们的新页面。
- en: 'We''ll write the following codes before starting to implement our form:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现我们的表单之前，我们将写下以下代码：
- en: 'If you haven''t already, open the React shop project in Visual Studio Code.
    Create a new file called `ContactUsPage.tsx` in the `src` folder, containing the
    following code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有，打开在Visual Studio Code中的React商店项目。在`src`文件夹中创建一个名为`ContactUsPage.tsx`的新文件，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This component will eventually contain state, so, we have created a class-based
    component. This simply renders a heading with some instructions at the moment.
    Eventually, it will reference our form.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件最终将包含状态，因此我们创建了一个基于类的组件。目前，它只是简单地呈现一个带有一些说明的标题。最终，它将引用我们的表单。
- en: 'Let''s now add this page to the available routes. Open `Routes.tsx`, and import
    our page:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将这个页面添加到可用的路由中。打开`Routes.tsx`，并导入我们的页面：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `render` method for the `Routes` component, we can now add a new route
    to our page just above the `admin` route:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Routes`组件的`render`方法中，我们现在可以在`admin`路由的上方添加一个新路由到我们的页面：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open `Header.tsx` now, which contains all the navigation options. Let''s add
    a `NavLink` to our new page just above the admin link:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`Header.tsx`，其中包含所有的导航选项。让我们在管理员链接的上方添加一个`NavLink`到我们的新页面：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the project in your development server, by entering the following in the
    terminal:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中输入以下内容，在开发服务器中运行项目：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see a new navigation option that takes us to our new page:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个新的导航选项，可以带我们到我们的新页面：
- en: '![](assets/a3962f6b-53ca-42b1-a6b3-d987b02f8944.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a3962f6b-53ca-42b1-a6b3-d987b02f8944.png)'
- en: Now that we have our new page, we are ready to implement our first controlled
    input in a form. We'll do this in the following section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新页面，我们准备在表单中实现我们的第一个受控输入。我们将在下一节中完成这个任务。
- en: Creating controlled inputs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建受控输入
- en: 'In this section, we''ll start to create our form containing our first controlled
    input:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将开始创建包含我们第一个受控输入的表单：
- en: 'Create a new file called `ContactUs.tsx` in the `src` folder containing the
    following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`ContactUs.tsx`的新文件，其中包含以下代码：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a function component that renders a form containing a label and an input
    for the user's name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数组件，用于呈现一个包含用户姓名标签和输入框的表单。
- en: 'We have referenced some CSS classes, so let''s add these to the bottom of `index.css`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引用了一些CSS类，所以让我们把它们添加到`index.css`的底部：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `form-group` class wraps each field in our form, displaying the label above
    the input with nice spacing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`form-group`类将包装表单中的每个字段，显示标签在输入框上方，并具有良好的间距。'
- en: 'Let''s reference our form from our page now. Go to `ContactUsPage.tsx` and
    import our component:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们从我们的页面引用我们的表单。转到`ContactUsPage.tsx`并导入我们的组件：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then reference our component in the `render` method at the bottom of
    the `div` container:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在`div`容器底部的`render`方法中引用我们的组件：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we look at the running app and go to the Contact Us page, we''ll see our
    name field rendered:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看正在运行的应用程序并转到联系我们页面，我们将看到我们的名字字段被呈现：
- en: '![](assets/dc455066-7714-4043-916e-3cd46c5e0eb0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc455066-7714-4043-916e-3cd46c5e0eb0.png)'
- en: We can enter our name into this field, but nothing will happen yet. We want
    the entered name to be stored in the `ContactUsPage` container component state.
    This is because `ContactUsPage` will eventually manage the form submission.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的名字输入到这个字段中，但目前什么也不会发生。我们希望输入的名字存储在`ContactUsPage`容器组件的状态中。这是因为`ContactUsPage`最终将管理表单提交。
- en: 'Let''s add a state type to `ContactUsPage`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`ContactUsPage`添加一个状态类型：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As well as the person's name, we are going to capture their email address, reason
    for contacting the shop, and any additional notes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了人的名字，我们还将捕获他们的电子邮件地址，联系商店的原因以及任何其他附加说明。
- en: 'Let''s also initialize the state in a constructor:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还在构造函数中初始化状态：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now need to get the name value from the state in `ContactUsPage` into the
    `ContactUs` component. This will allow us to display the value in the input. We
    can do this by first creating props in the `ContactUs` component:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`ContactUsPage`中的名字值传递到`ContactUs`组件中。这将允许我们在输入框中显示该值。我们可以通过首先在`ContactUs`组件中创建props来实现这一点：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have created props for all the data we are going to eventually capture in
    our form.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已为我们最终要捕获的所有数据创建了props。
- en: 'Now, we can bind the name input value to the `name` prop:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将名字输入值绑定到`name`属性：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now pass these from the state in `ContactUsPage`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从`ContactUsPage`的状态中传递这些：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's go to the running app and go to our Contact Us page. Try typing something
    into the name input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去运行的应用程序并转到我们的联系我们页面。尝试在名字输入框中输入一些内容。
- en: Nothing seems to happen... something is preventing us from entering the value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎什么都没有发生……有什么东西阻止我们输入值。
- en: We have just set the input value to some React state, so React is now controlling
    the value of the input. This is why we no longer appear to be able to type into
    it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将输入值设置为一些React状态，因此React现在控制着输入的值。这就是为什么我们似乎不再能够输入的原因。
- en: We are part-way through creating our first controlled input. However, controlled
    inputs aren't much use if users can't enter anything into them. So, how can we
    make our input editable again?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建我们的第一个受控输入。但是，如果用户无法输入任何内容，受控输入就没有多大用处。那么，我们如何使输入框再次可编辑呢？
- en: The answer is that we need to listen to changes to the input value, and update
    the state accordingly. React will then render the new input value from the state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们需要监听输入值的更改，并相应地更新状态。然后React将从状态中呈现新的输入值。
- en: 'Let''s listen to changes to the input via the `onChange` prop:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过`onChange`属性监听输入的更改：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create the handler we have just referenced as well:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也创建我们刚刚引用的处理程序：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we've used the generic `React.ChangeEvent` command with the type of
    the element we are handling (`HTMLInputElement`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经使用了通用的`React.ChangeEvent`命令，其类型为我们正在处理的元素（`HTMLInputElement`）。
- en: The `currentTarget` prop in the event argument gives us a reference to the element
    that the event handler is attached to. The `value` property within this gives
    us the latest value of the input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 事件参数中的`currentTarget`属性为我们提供了事件处理程序所附加到的元素的引用。其中的`value`属性为我们提供了输入的最新值。
- en: 'The handler references an `onNameChange` function prop that we haven''t defined
    yet. So, let''s add this to our interface, along with similar props for the other
    fields:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序引用了一个我们尚未定义的`onNameChange`函数属性。因此，让我们将其添加到我们的接口中，以及其他字段的类似属性：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now pass these props from `ContactUsPage` into `ContactUs`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将这些props从`ContactUsPage`传递到`ContactUs`：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s create the change handlers we''ve just referenced in `ContactUsPage`
    that set the relevant state:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ContactUsPage`中创建我们刚刚引用的更改处理程序，设置相关状态：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we now go to the Contact Us page in the running app and enter something into
    the name, this time the input behaves as expected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在去运行应用程序中的联系我们页面，并输入一些内容到姓名中，这次输入会按预期的方式行为。
- en: 'Let''s add fields for email, reason, and notes in our `render` method for `ContactUs`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ContactUs`的`render`方法中添加电子邮件、原因和备注字段：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For each field, we render a `label` and the appropriate editor inside a `div`
    container, with a `form-group` class to space our fields out nicely.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字段，我们在`div`容器中呈现一个`label`和适当的编辑器，使用`form-group`类来很好地间隔我们的字段。
- en: All the editors reference handlers for handling changes to their value. All
    the editors also have their value set from the appropriate `ContactUs` prop. So,
    all the field editors have controlled components.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编辑器都引用处理更改值的处理程序。所有编辑器还从适当的`ContactUs`属性中设置其值。因此，所有字段编辑器都是受控组件。
- en: 'Let''s have a closer look at the `select` editor. We set the value in the `select`
    tag using a `value` attribute. However, this doesn''t exist in the native `select`
    tag. Usually, we have to include a `selected` attribute in the relevant `option`
    tag within the `select` tag:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下`select`编辑器。我们使用`value`属性在`select`标签中设置值。然而，这在原生的`select`标签中并不存在。通常情况下，我们必须在`select`标签中的相关`option`标签中包含一个`selected`属性：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: React adds the `value` prop to the `select` tag, and manages the `selected`
    attribute on the `option` tag for us, behind the scenes. This allows us to consistently
    manage `input`, `textarea`, and `selected` in our code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: React在`select`标签中添加了`value`属性，并在幕后管理`option`标签上的`selected`属性。这使我们能够一致地在我们的代码中管理`input`、`textarea`和`selected`。
- en: 'Let''s now create the change handlers for these fields that call the function
    props we created earlier:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为这些字段创建更改处理程序，调用我们之前创建的函数props：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This completes our basic Contact Us form, using various controlled form elements.
    We haven't implemented any validation or submitted the form yet. We'll get to
    these later in the chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们基本的联系我们表单，使用各种受控表单元素。我们还没有实现任何验证或提交表单。我们将在本章后面处理这些问题。
- en: We're already noticing lots of similar code for each field for getting changes
    to fields into state. In the next section, we are going to start work on a generic
    form component and switch to using this for our Contact Us form.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注意到为每个字段获取字段更改到状态的类似代码。在下一节中，我们将开始开发一个通用表单组件，并切换到使用它来处理我们的联系我们表单。
- en: Reducing boilerplate code with generic components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用组件减少样板代码
- en: Generic form components will help reduce the amount of code required to implement
    a form. We are going to do just this in this section, refactoring what we did
    in the last section for our `ContactUs` component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通用表单组件将有助于减少实现表单所需的代码量。在本节中，我们将对我们在上一节中为`ContactUs`组件所做的事情进行重构。
- en: 'Let''s think about how we would ideally consume the generic components to produce
    the new version of the `ContactUs` component. It could be something like the following
    JSX:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何理想地使用通用组件来生成`ContactUs`组件的新版本。它可能是以下JSX的样子：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, there are two generic compound components: `Form` and `Field`.
    Here are some key points:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有两个通用的复合组件：`Form`和`Field`。以下是一些关键点：
- en: The `Form` component is the container for the compound, managing the state and
    the interactions.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Form`组件是复合组件的容器，管理状态和交互。'
- en: We pass default values in for the fields in a `defaultValues` prop on the `Form`
    component.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`Form`组件的`defaultValues`属性中传递字段的默认值。
- en: The `Field` component renders the label and an editor for each field.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field`组件为每个字段渲染标签和编辑器。'
- en: Each field has a `name` prop that will determine the property name in the state
    that the field value is stored under.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段都有一个`name`属性，它将确定状态中存储字段值的属性名称。
- en: Each field has a `label` prop that specifies the text to display in each field
    label.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段都有一个`label`属性，用于指定每个字段标签中显示的文本。
- en: The specific field editor is specified using a `type` prop. The default editor
    is a text-based `input`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type`属性指定特定的字段编辑器。默认编辑器是基于文本的`input`。
- en: If the editor type is `Select`, then we can specify the options that appear
    in this using an `options` prop.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编辑器类型是`Select`，那么我们可以使用`options`属性指定出现在其中的选项。
- en: The JSX to render the new `ContactUs` component is much shorter than the original
    version, and arguably easier to read. The state management and event handlers
    are hidden away and encapsulated within the `Form` component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染新的`ContactUs`组件的JSX比原始版本要短得多，而且可能更容易阅读。状态管理和事件处理程序被隐藏在`Form`组件中并封装起来。
- en: Creating a basic form component
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的表单组件
- en: 'It''s time to start work on our generic `Form` component:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始处理我们的通用`Form`组件了：
- en: 'Let''s start by creating a new file in the `src` folder called `Form.tsx`,
    containing the following content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`src`文件夹中创建一个名为`Form.tsx`的新文件，其中包含以下内容：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Form` is a class-based component because it needs to manage state. We have
    named the props interface `IFormProps` because later on we''ll need an interface
    for field props.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`是一个基于类的组件，因为它需要管理状态。我们将props接口命名为`IFormProps`，因为以后我们将需要一个字段props的接口。'
- en: 'Let''s add a `defaultValues` prop to the `IFormProps` interface. This will
    hold the default value for every field in the form:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`IFormProps`接口中添加一个`defaultValues`属性。这将保存表单中每个字段的默认值：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use an additional interface called `IValues` for the default value type.
    This is an indexable key/value type that has a `string` type key and an `any`
    type value. The key will be the field name, and the value will be the field value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个名为`IValues`的额外接口来表示默认值类型。这是一个可索引的键/值类型，具有`string`类型的键和`any`类型的值。键将是字段名称，值将是字段值。
- en: 'So, the value for the `defaultValues` prop could be this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`defaultValues`属性的值可以是这样的：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s move on to the state in `Form` now. We are going to store the field
    values in a state property called `values`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续处理`Form`中的状态。我们将在状态属性`values`中存储字段值：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that this is the same type as the `defaultValues` prop, which is `IValues`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与`defaultValues`属性的类型相同，即`IValues`。
- en: 'We are going to initialize the state with the default values in the constructor
    now:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在构造函数中使用默认值初始化状态：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The final bit we are going to do in this section is to start implementing the
    `render` method in the `Form` component:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们要做的最后一件事是开始实现`Form`组件中的`render`方法：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We render the child components in a `form` tag, using the magical `children`
    prop we used in the last chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`form`标签中渲染子组件，使用了我们在上一章中使用的神奇的`children`属性。
- en: This leads us nicely to the `Field` component, which we'll implement in the
    next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地引出了`Field`组件，我们将在下一节中实现它。
- en: Adding a basic Field component
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个基本的Field组件
- en: 'The `Field` component needs to render a label and an editor. It will live in
    a static property called `Field` inside the `Form` component. Consumers can then
    reference this component using `Form.Field`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Field`组件需要渲染标签和编辑器。它将位于`Form`组件内部的静态属性`Field`中。消费者可以使用`Form.Field`来引用此组件：'
- en: 'Let''s start by creating an interface for the field props in `Form.tsx` just
    above `IFormProps`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`Form.tsx`中为字段props创建一个接口，就在`IFormProps`上面：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `name` prop is the name of the field.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`属性是字段的名称。'
- en: The `label` prop is the text to display in the field label.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`属性是要在字段标签中显示的文本。'
- en: The `type` prop is the type of editor to display. We have used a union type
    for this prop, containing the available types we are going to support. Note that
    we have defined this as an optional prop, so we'll need to define a default value
    for this a little later.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`属性是要显示的编辑器类型。我们已经为此属性使用了联合类型，包含了我们将要支持的可用类型。请注意，我们已将其定义为可选属性，因此稍后需要为此定义一个默认值。'
- en: The `options` prop, which is only applicable to the `Select` editor type, is
    also optional. This defines the list of options to display in the drop-down in
    a `string` array.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`属性仅适用于`Select`编辑器类型，也是可选的。这定义了要在下拉列表中显示的选项列表，是一个`string`数组。'
- en: 'Now, let''s add a skeleton static `Field` property in `Form` for the `Field`
    component:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`Form`中为`Field`组件添加一个骨架静态`Field`属性：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before we forget, let''s add that default for the field `type` prop. We define
    this as follows, outside and underneath the `Form` class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们忘记之前，让我们为字段`type`属性添加默认值。我们将其定义如下，在`Form`类的外部和下方：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, the default `type` will be a text-based input.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，默认的`type`将是基于文本的输入。
- en: 'Now, let''s have a go at rendering the field:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试渲染字段：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We start by destructuring `name`, `label`, `type`, and `options` from the props
    object.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从props对象中解构`name`、`label`、`type`和`options`。
- en: The field is wrapped in a `div` container, which spaces the fields out vertically,
    using the `form-group` class we already implemented in `index.css`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该字段被包裹在一个`div`容器中，使用`form-group`类在`index.css`中已经实现的方式在垂直方向上间隔字段。
- en: The `label` is then rendered just before the `input` inside the `div` container,
    with the `htmlFor` attribute of the label referencing the `id` of the `input`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在`div`容器内部渲染`label`，`label`的`htmlFor`属性引用`input`的`id`。
- en: This is a good start, but not all the different field editors are inputs. In
    fact, this will only work for types `Text` and `Email`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始，但并非所有不同的字段编辑器都是输入。实际上，这只适用于`Text`和`Email`类型。
- en: 'So, let''s adjust this slightly and wrap a conditional expression around the
    input:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们稍微调整一下，并在输入周围包裹一个条件表达式：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, let''s deal with the `TextArea` type by adding the highlighted JSX:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加高亮的JSX来处理`TextArea`类型：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now render the final editor we are going to support, as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以渲染我们将要支持的最终编辑器，如下所示：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We render a `select` tag, containing the options specified by using the `map`
    function in the `options` array prop. Note that we give each option a unique `key`
    attribute to keep React happy when detecting any changes to the options.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们渲染一个`select`标签，其中包含使用`options`数组属性中的`map`函数指定的选项。请注意，我们为每个选项分配一个唯一的`key`属性，以便在检测到选项的任何更改时保持React的正常运行。
- en: We now have basic `Form` and `Field` components in play, which is great. However,
    the implementation is still pretty useless because we are not managing the field
    values yet in state. Let's cover that in the next section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了基本的`Form`和`Field`组件，这很棒。但是，实现仍然相当无用，因为我们尚未在状态中管理字段值。让我们在下一节中解决这个问题。
- en: Sharing state with React context
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与React上下文共享状态
- en: The state for field values lives in the `Form` component. However, the values
    are rendered and changed with the `Field` component. The `Field` component doesn't
    have access to the state within `Form`, because the state lives in the `Form`
    instance and `Field` doesn't.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 字段值的状态存储在`Form`组件中。但是，这些值是通过`Field`组件渲染和更改的。`Field`组件无法访问`Form`中的状态，因为状态存在于`Form`实例中，而`Field`没有。
- en: This is very similar to the compound `Tabs` component we implemented in the
    last chapter. We shared state between the components in the `Tabs` compound using
    React context.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一章中实现的复合`Tabs`组件非常相似。我们使用React上下文在`Tabs`复合组件之间共享状态。
- en: 'We are going to use the same approach for our `Forms` component in this section:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用相同的方法来处理`Forms`组件。
- en: 'Let''s start by creating an interface for the form context in `Form.tsx`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`Form.tsx`中为表单上下文创建一个接口：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The context just contains values that have the same type, `IValues`, as in our
    state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文只包含与我们状态中的`IValues`相同类型的值。
- en: 'Let''s create the context component now just under `IFormContext` using `React.createContext`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`IFormContext`下方使用`React.createContext`创建上下文组件：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We keep the TypeScript compiler happy by setting the initial context value to
    an empty literal value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将初始上下文值设置为空文字值，我们使TypeScript编译器满意。
- en: 'In the `render` method in `Form`, create the context value containing the values
    from the state:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Form`的`render`方法中，创建包含状态中的值的上下文值：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Wrap the context provider around the `form` tag in the `render` method''s JSX:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法的JSX中的`form`标签周围包装上下文提供程序：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now consume the context in the `Field` SFC:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在`Field` SFC中使用上下文：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have access to the context, let''s render the values from it in
    all three editors:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们可以访问上下文了，让我们在所有三个编辑器中从中呈现值：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The TypeScript compiler is now happy with our `Form` and `Field` components.
    So, we could start work on the new `ContactUs` implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器现在对我们的`Form`和`Field`组件满意了。因此，我们可以开始对新的`ContactUs`实现进行工作。
- en: However, users will not be able to enter anything into our form yet, because
    we are not handling changes and passing new values to state. We now need to implement
    change handlers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户现在还不能输入任何内容到我们的表单中，因为我们还没有处理更改并将新值传递给状态。现在我们需要实现更改处理程序。
- en: 'Let''s start by creating a `setValue` method in the `Form` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`Form`类中创建一个`setValue`方法：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here are the key points in this method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的关键点如下：
- en: This method takes in the field name and new value as parameters.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法接受字段名称和新值作为参数。
- en: The new state for the `values` object is created using a new object called `newValues`,
    which spreads the old values from the state and then adds the new field name and
    value.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个名为`newValues`的新对象创建`values`对象的新状态，该对象展开了状态中的旧值，然后添加了新的字段名称和值。
- en: The new values are then set in the state.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后在状态中设置新值。
- en: 'We then create a reference to this method in the form context so that the `Field`
    component can access it. Let''s add this to the form context interface first:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在表单上下文中创建对该方法的引用，以便`Field`组件可以访问它。让我们首先将其添加到表单上下文接口中：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We set the property as optional to keep the TypeScript compiler happy when the
    form context component is created.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性设置为可选，以便在创建表单上下文组件时使TypeScript编译器满意。
- en: 'We can then create a reference to the `setValue` method in `Form` when the
    context value is created:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在创建上下文值时在`Form`中创建对`setValue`方法的引用：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We now have access to invoke this method from the `Field` component. In `Field`,
    just after we destructure the `props` object, let''s create a change handler that
    will invoke the `setValue` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从`Field`组件中访问并调用这个方法。在`Field`中，在我们解构`props`对象之后，让我们创建一个更改处理程序来调用`setValue`方法：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s look at the key points in this method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个方法的关键点：
- en: The TypeScript change event type is `ChangeEvent<T>`, where `T` is the type
    of the element that is being handled.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript更改事件类型为`ChangeEvent<T>`，其中`T`是正在处理的元素的类型。
- en: The handler's first parameter, `e`, is the React change event handler parameter.
    We union all the different change handler types for our different editors, so
    that we can handle all changes in a single function.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序的第一个参数`e`是React的change事件处理程序参数。我们将所有不同的编辑器的change处理程序类型联合起来，这样我们就可以在一个函数中处理所有的变化。
- en: The handler's second parameter is the form context.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序的第二个参数是表单上下文。
- en: We need a conditional statement to check that the `setValue` method is not `undefined`,
    to keep the TypeScript compiler happy.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个条件语句来检查`setValue`方法是否不是`undefined`，以使TypeScript编译器满意。
- en: We can then call the `setValue` method with the field name and new value.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们可以使用字段名称和新值调用`setValue`方法。
- en: 'We can then reference this change handler in the `input` tag, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在`input`标签中引用这个change handler，如下所示：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that we use a lamda function so that we can pass in the context value to
    `handleChange`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了一个lambda函数，这样我们就可以将上下文值传递给`handleChange`。
- en: 'We can do the same in the `textarea` tag:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以在`textarea`标签中这样做：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also do this in the `select` tag:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以在`select`标签中这样做：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, our `Form` and `Field` components are now nicely working together, rendering
    fields and managing their values. In the next section, we'll give our generic
    components a try by implementing a new `ContactUs` component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Form`和`Field`组件现在很好地协同工作，渲染字段并管理它们的值。在下一节中，我们将通过实现一个新的`ContactUs`组件来尝试我们的通用组件。
- en: Implementing our new ContactUs component
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的新ContactUs组件
- en: 'In this section, we are going to implement a new `ContactUs` component using
    our `Form` and `Field` components:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们的`Form`和`Field`组件实现一个新的`ContactUs`组件：
- en: Let's start by removing the props interface from `ContactUs.tsx`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先从`ContactUs.tsx`中删除props接口。
- en: 'The content within the `ContactUs` SFC will be very different to the original
    version. Let''s start by removing the content so that it looks as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ContactUs` SFC中的内容将与原始版本非常不同。让我们首先删除内容，使其看起来如下：'
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s import our `Form` component into `ContactUs.tsx`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们的`Form`组件导入到`ContactUs.tsx`中：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can now reference the `Form` component, passing some default values:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以引用`Form`组件，传递一些默认值：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s add the `name` field:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`name`字段：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note we haven't passed the `type` prop because this will default to a text-based
    input, which is just what we require.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有传递`type`属性，因为这将默认为基于文本的输入，这正是我们需要的。
- en: 'Let''s add the `email`, `reason`, and `notes` fields now:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加`email`，`reason`和`notes`字段：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `ContactUsPage` is going to be much simpler now. It won''t contain any
    state because that is managed within the `Form` component now. We also don''t
    need to pass any props to the `ContactUs` component:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ContactUsPage`现在会简单得多。它不会包含任何状态，因为现在状态是在`Form`组件中管理的。我们也不需要向`ContactUs`组件传递任何props：'
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If we go to the running app and go to the Contact Us page, it renders as required
    and accepts the values we enter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到运行中的应用程序并转到联系我们页面，它会按照要求呈现并接受我们输入的值。
- en: Our generic form component is progressing nicely, and we have consumed it to
    implement the `ContactUs` component as we had hoped. In the next section, we are
    going to improve our generic component even further by adding validation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通用表单组件正在良好地进展，并且我们已经使用它来实现了`ContactUs`组件，正如我们所希望的那样。在下一节中，我们将通过添加验证进一步改进我们的通用组件。
- en: Validating forms
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证表单
- en: Including validation on a form improves the user experience, by giving them
    immediate feedback on whether the information entered is valid. In this section,
    we are going to add validation to our `Form` component and then consume it in
    our `ContactUs` component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中包含验证可以提高用户体验，让他们立即得到关于输入信息是否有效的反馈。在本节中，我们将为我们的`Form`组件添加验证，然后在我们的`ContactUs`组件中使用它。
- en: 'The validation rules we are going to implement in the `ContactUs` component
    are these:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`ContactUs`组件中实现的验证规则是这些：
- en: The name and email fields should be populated
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称和电子邮件字段应填写
- en: The name field should be at least two characters
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称字段应至少为两个字符
- en: We are going to execute validation rules when the field editor loses focus.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段编辑器失去焦点时，我们将执行验证规则。
- en: In the next section, we'll add a prop to the `Form` component that allows consumers
    to specify validation rules.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向`Form`组件添加一个属性，允许消费者指定验证规则。
- en: Adding a validation rules prop to form
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向表单添加验证规则属性
- en: 'Let''s think about how we would want to specify validation rules to a form.
    We need to be able to specify one or more rules for a field. Some rules could
    have a parameter, such as a minimum length. It would be nice if we could specify
    the rules, as in the example that follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何指定验证规则给表单。我们需要能够为一个字段指定一个或多个规则。一些规则可能有参数，比如最小长度。如果我们能够像下面的示例那样指定规则就好了：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s have a go at implementing the `validationRules` prop on the `Form` component:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在`Form`组件上实现`validationRules`属性：
- en: 'Start by defining a type for the `Validator` function in `Form.tsx`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`Form.tsx`中为`Validator`函数定义一个类型：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A `Validator` function will take in the field name, the values for the whole
    form, and an optional argument specific to the function. A string containing the
    validation error message will be returned. If the field is valid, a blank string
    will be returned.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator`函数将接受字段名称、整个表单的值和特定于函数的可选参数。将返回包含验证错误消息的字符串。如果字段有效，则返回空字符串。'
- en: 'Let''s use this type to create a `Validator` function to check that a field
    called `required` under the `Validator` type is populated:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用此类型创建一个`Validator`函数，以检查`Validator`类型下名为`required`的字段是否已填写：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We export the function so that it can be used in our `ContactUs` implementation
    later. The function checks whether the field value is `undefined`, `null`, or
    an empty string and if so, it returns a This must be populated validation error
    message.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出该函数，以便稍后在我们的`ContactUs`实现中使用。该函数检查字段值是否为`undefined`、`null`或空字符串，如果是，则返回必须填写此字段的验证错误消息。
- en: If the field value isn't `undefined`, `null`, or an empty string, then an empty
    string is returned to indicate the value is valid.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段值不是`undefined`、`null`或空字符串，则返回空字符串以指示该值有效。
- en: 'Similarly, let''s create a `Validator` function for checking that a field input
    is over a minimum length:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，让我们为检查字段输入是否超过最小长度创建一个`Validator`函数：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The function checks whether the length of the field value is less than the length
    argument, and if so it returns a validation error message. Otherwise, an empty
    string is returned to indicate the value is valid.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数检查字段值的长度是否小于长度参数，如果是，则返回验证错误消息。否则，返回空字符串以指示该值有效。
- en: 'Now, let''s add the ability to pass validation rules via a prop to the `Form`
    component:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个属性向`Form`组件传递验证规则的能力：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `validationRules` prop is an indexable key/value type, where the key is
    the field name and the value is one or more validation rules of type `IValidation`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validationRules`属性是一个可索引的键/值类型，其中键是字段名称，值是一个或多个`IValidation`类型的验证规则。'
- en: A validation rule contains the validation function of type `Validator`, and
    an argument to pass into the validation function.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证规则包含`Validator`类型的验证函数和传递到验证函数的参数。
- en: 'With the new `validationRules` prop in place, let''s add this to the `ContactUs`
    component. Import the validator functions first:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了新的`validationRules`属性，让我们将其添加到`ContactUs`组件中。首先导入验证函数：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let''s add the validation rules to the `ContactUs` component JSX:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将验证规则添加到`ContactUs`组件的JSX中：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, our form is valid if the name and email are populated, and the name is
    at least two characters long.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果名称和电子邮件已填写，并且名称至少为两个字符长，我们的表单就是有效的。
- en: That's the `validationRules` prop complete. In the next section, we'll track
    the validation error messages in preparation for rendering them on the page.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是“validationRules”prop的完成。在下一节中，我们将跟踪验证错误消息，以准备在页面上呈现它们。
- en: Tracking validation error messages
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪验证错误消息
- en: We need to track the validation error messages in state as the user completes
    the form and fields become valid or invalid. Later on, we'll be able to render
    the error messages to the screen.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成表单并字段变为有效或无效时，我们需要在状态中跟踪验证错误消息。稍后，我们将能够将错误消息呈现到屏幕上。
- en: 'The `Form` component is responsible for managing all the form states, so we''ll
    add the error message state to there, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: “Form”组件负责管理所有表单状态，因此我们将错误消息状态添加到其中，如下所示：
- en: 'Let''s add the validation error message state to the form state interface:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将验证错误消息状态添加到表单状态接口中：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `errors` state is an indexable key/value type where the key is the field
    name and the value is an array of validation error messages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: “errors”状态是可索引的键/值类型，其中键是字段名称，值是验证错误消息的数组。
- en: 'Let''s initialize the `errors` state in the constructor:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在构造函数中初始化“errors”状态：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `defaultValues` prop contains all the field names in its keys. We iterate
    through the `defaultValues` keys, setting the appropriate `errors` key to an empty
    array. As a result, when the `Form` component initializes, none of the fields
    contain any validation error messages, which is exactly what we want.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: “defaultValues”prop包含其键中的所有字段名称。我们遍历“defaultValues”键，将适当的“errors”键设置为空数组。因此，当“Form”组件初始化时，没有任何字段包含任何验证错误消息，这正是我们想要的。
- en: 'The `Field` component is eventually going to render the validation error messages,
    so we need to add these to the form context. Let''s start by adding these to the
    form context interface:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Field”组件最终将呈现验证错误消息，因此我们需要将这些添加到表单上下文中。让我们从将这些添加到表单上下文接口开始：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s add an `errors` empty literal as the default value when the context
    is created. This is to keep the TypeScript compiler happy:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在创建上下文时将“errors”空文字作为默认值添加。这是为了让TypeScript编译器满意：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now include the errors in the context value:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在上下文值中包含错误：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, the validation errors are in the form state, and also in the form context
    for the `Field` component to access. In the next section, we'll create a method
    that is going to invoke the validation rules.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证错误在表单状态中，也在表单上下文中，以便“Field”组件可以访问。在下一节中，我们将创建一个方法来调用验证规则。
- en: Invoking validation rules
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用验证规则
- en: 'So far, we can define validation rules, and have state to track validation
    error messages, but nothing is invoking the rules yet. This is what we are going
    to implement in this section:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以定义验证规则，并且有状态来跟踪验证错误消息，但是还没有调用规则。这就是我们将在本节中实现的内容：
- en: 'We need to create a method within the `Form` component that is going to validate
    a field, calling the specified validator function. Let''s create a method called
    `validate` that takes in the field name and its value. The method will return
    an array of validation error messages:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在“Form”组件中创建一个方法，该方法将验证字段，调用指定的验证器函数。让我们创建一个名为“validate”的方法，该方法接受字段名称和其值。该方法将返回一个验证错误消息数组：
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s get the validation rules for the field and initialize an `errors` array.
    We''ll collect all the errors in the `errors` array as the validators are executed.
    We''ll also return the array of `errors` after all the validators have been executed:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取字段的验证规则并初始化一个`errors`数组。当验证器被执行时，我们将在`errors`数组中收集所有的错误。在所有验证器被执行后，我们还将返回`errors`数组：
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The rules can be an `IValidation` array or just a single `IValidation`. Let''s
    check for this and call the `validator` function if we just have a single validation
    rule:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规则可以是一个`IValidation`数组，也可以是一个单独的`IValidation`。让我们检查一下，如果只有一个验证规则，就调用`validator`函数：
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s now deal with the branch of code for when there are multiple validation
    rules. We can use the `forEach` function on the rules array to iterate through
    the rules and execute the `validator` function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们处理有多个验证规则时的代码分支。我们可以在规则数组上使用`forEach`函数来遍历规则并执行`validator`函数：
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The final bit of code we need to implement in the `validate` method is to set
    the new `errors` form state:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`validate`方法中实现的最后一部分代码是设置新的`errors`表单状态：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We spread the old errors state into a new object, and then add the new errors
    for the field.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旧的错误状态扩展到一个新对象中，然后为字段添加新的错误。
- en: 'The `Field` component needs to call into this `validate` method. We are going
    to add a reference to this method to the form context. Let''s add it to the `IFormContext`
    interface first:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Field`组件需要调用这个`validate`方法。我们将在表单上下文中添加对这个方法的引用。让我们先将它添加到`IFormContext`接口中：'
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can now add it to the context value in the `render` method in `Form`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在`Form`的`render`方法中将其添加到上下文值中：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Our form validation is coming along nicely, and we now have a method we can
    call to invoke all the rules for a field. However, this method isn't being called
    from anywhere yet as the user fills out the form. We'll do that in the next section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单验证进展顺利，现在我们有一个可以调用的方法来调用字段的所有规则。然而，这个方法还没有被从任何地方调用，因为用户填写表单。我们将在下一节中做这件事。
- en: Triggering validation rule execution from field
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字段触发验证规则执行
- en: 'When the user fills in the form, we want the validation rules to trigger when
    a field loses focus. We''ll implement this in this section:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户填写表单时，我们希望在字段失去焦点时触发验证规则。我们将在本节中实现这一点：
- en: 'Let''s create a function that is going to handle the `blur` event for all three
    of the different editors:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，来处理三种不同编辑器的`blur`事件：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The TypeScript blur event type is `FocusEvent<T>`, where `T` is the type of
    the element that is being handled.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的模糊事件类型是`FocusEvent<T>`，其中`T`是正在处理的元素的类型。
- en: The handler's first parameter, `e`, is the React blur event handler parameter.
    We union all the different handler types for our different editors, so that we
    can handle all the blur events in a single function.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序的第一个参数`e`是React模糊事件处理程序参数。我们将所有不同的处理程序类型联合起来，这样我们就可以在一个函数中处理所有的模糊事件。
- en: The handler's second parameter is the form context.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序的第二个参数是表单上下文。
- en: We need a conditional statement to check that the `validate` method is not `undefined`,
    to keep the TypeScript compiler happy.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个条件语句来检查`validate`方法是否不是`undefined`，以使TypeScript编译器满意。
- en: We can then call the `validate` method with the field name and new value we
    need to validate.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们可以使用字段名称和需要验证的新值调用`validate`方法。
- en: 'We can now reference this handler in the `Field` JSX for the text and email
    editor:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在文本和电子邮件编辑器的`Field` JSX中引用这个处理程序：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We set the `onBlur` prop to a lamda expression that calls our `handleBlur` function,
    passing in the blur argument as well as the context value.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`onBlur`属性设置为调用我们的`handleBlur`函数的lambda表达式，同时传入模糊参数和上下文值。
- en: 'Let''s reference the handler in the other two editors now:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在另外两个编辑器中引用这个处理程序：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Our field is now executing validation rules when it loses focus. There's one
    more task to do before we can give our Contact Us page a try, which we'll do in
    the next section.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的字段现在在失去焦点时执行验证规则。在我们尝试给我们的联系我们页面一个尝试之前，还有一项任务要做，我们将在下一节中完成。
- en: Rendering validation error messages
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染验证错误消息
- en: 'In this section, we are going to render the validation error messages in the
    `Field` component:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将在`Field`组件中渲染验证错误消息：
- en: 'Let''s display all errors in a `span` with the `form-error` CSS class we have
    already implemented. We display these at the bottom of the `div` container of
    the `form-group`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`form-group`的`div`容器底部显示所有错误，使用我们已经实现的`form-error` CSS类的`span`：
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: So, we first check that we have errors for the field name, and then use the
    `map` function in the `errors` array to render a `span` for each error.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先检查字段名称是否有错误，然后在`errors`数组中使用`map`函数为每个错误渲染一个`span`。
- en: 'We have referenced a CSS `form-error` class, so let''s add this to `index.css`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经引用了一个CSS `form-error`类，所以让我们把它添加到`index.css`中：
- en: '[PRE78]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It''s time to give the Contact Us page a try. If our app isn''t started, start
    it using `npm start` and go to the Contact Us page. If we tab through the name
    and email fields, the required validation rule triggers and error messages are
    displayed:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试联系我们页面了。如果我们的应用程序没有启动，请使用`npm start`启动它，然后转到联系我们页面。如果我们通过名称和电子邮件字段进行切换，将触发必填验证规则，并显示错误消息：
- en: '![](assets/5c1c0bd5-41d7-4dfe-a583-681a209e50fd.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c1c0bd5-41d7-4dfe-a583-681a209e50fd.png)'
- en: 'This is just what we want. If we go back to the name field and try to enter
    just a single character before tabbing away, the minimum length validation error
    triggers, as we would expect:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。如果我们回到名称字段，尝试在切换之前只输入一个字符，那么最小长度验证错误会触发，正如我们所期望的那样：
- en: '![](assets/985e637e-04be-4016-ba1f-990898bada01.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/985e637e-04be-4016-ba1f-990898bada01.png)'
- en: Our generic form component is nearly complete now. Our final task is to submit
    the form, which we'll do in the next section.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通用表单组件现在几乎完成了。我们的最后任务是提交表单，我们将在下一节中完成。
- en: Form submission
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单提交
- en: Submitting the form is the final part of the form implementation. The consumer
    of the `Form` component will handle the actual submission, which will probably
    result in a call to a web API. Our `Form` component will simply call a function
    in the consumer code when the form is submitted.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 提交表单是表单实现的最后一部分。`Form`组件的消费者将处理实际的提交，这可能会导致调用Web API。我们的`Form`组件在表单提交时将简单地调用消费者代码中的一个函数。
- en: Adding a submit button to the form
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表单中添加一个提交按钮
- en: 'In this section, we are going to add a submit button to our `Form` component:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将向我们的`Form`组件添加一个提交按钮：
- en: 'Let''s add a submit button to the `Form` JSX, wrapped in a `div` container
    within `form-group`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Form` JSX中添加一个提交按钮，放在`form-group`中的`div`容器中：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Style the button with the following CSS in `index.css`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下CSS样式为按钮添加样式在`index.css`中：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We now have a black submit button on our form that is gray when disabled.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在表单上有一个黑色的提交按钮，当禁用时是灰色的。
- en: Adding a onSubmit form prop
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个onSubmit表单prop
- en: 'In our `Form` component, we need a new prop that allows a consumer to specify
    the `submit` function to be called. We''ll do this in this section:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Form`组件中，我们需要一个新的prop，允许消费者指定要调用的`submit`函数。我们将在这一节中完成这个任务：
- en: 'Let''s start by creating a new prop function called `onSubmit` in the `Form`
    props interface:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`Form` props接口中创建一个名为`onSubmit`的新prop函数：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The function will take in the field values and asynchronously return whether
    the submission was successful, with any validation errors that occurred on the
    server.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将接受字段值，并异步返回提交是否成功，以及在服务器上发生的任何验证错误。
- en: 'We are going to track whether the form is being submitted or not in the `Form`
    state. We are also going to track whether the form has successfully been submitted
    in the `Form` state:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将跟踪表单是否正在提交或者在 `Form` 状态中成功提交的情况。
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s initialize those state values in the constructor:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在构造函数中初始化这些状态值：
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can now disable the submit button if the form is being submitted, or has
    successfully been submitted:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单正在提交或已成功提交，我们现在可以禁用提交按钮：
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s reference a submit handler in the `form` tag:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `form` 标签中引用一个提交处理程序：
- en: '[PRE85]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can now start to implement the submit handler we just referenced:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现我们刚刚引用的提交处理程序：
- en: '[PRE86]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We call `preventDefault` in the submit event argument to stop the browser automatically
    posting the form.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在提交事件参数中调用 `preventDefault` 来阻止浏览器自动发布表单。
- en: 'We need to make sure all the fields are valid before starting the form submission
    process. Let''s reference and create a `validateForm` function that does this:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始表单提交过程之前，我们需要确保所有字段都是有效的。让我们引用并创建一个执行此操作的 `validateForm` 函数：
- en: '[PRE87]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `validateForm` function iterates through the fields, calling the `validate`
    function that has already been implemented. The state is updated with the latest
    validation errors, and we return whether there are any errors or not in any of
    the fields.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateForm` 函数遍历字段，调用已经实现的 `validate` 函数。状态会更新为最新的验证错误，并返回字段中是否有任何错误。'
- en: 'Let''s implement the rest of the submit handler now:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在实现剩下的提交处理程序：
- en: '[PRE88]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If the form is valid, we start by setting the `submitting` state to `true`.
    We then call the `onSubmit` prop function asynchronously. When the `onSubmit`
    prop function has finished, we set any validation errors from the function in
    the state along with whether the submission was successful. We also set in the
    state the fact that the submission process has finished.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单有效，我们首先将 `submitting` 状态设置为 `true`。然后我们异步调用 `onSubmit` prop 函数。当 `onSubmit`
    prop 函数完成时，我们将函数中的任何验证错误与提交是否成功一起设置在状态中。我们还在状态中设置提交过程已经完成的事实。
- en: Now, our `Form` component has an `onSubmit` function prop. In the next section,
    we'll consume this in our Contact Us page.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `Form` 组件有一个 `onSubmit` 函数 prop。在下一节中，我们将在我们的联系我们页面中使用它。
- en: Consuming the onSubmit form prop
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 onSubmit 表单 prop
- en: 'In this section, we''ll consume the `onSubmit` form prop in the `ContactUs`
    component. The `ContactUs` component won''t manage the submission—it will simply
    delegate to the `ContactUsPage` component to handle the submission:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将在 `ContactUs` 组件中使用 `onSubmit` 表单 prop。`ContactUs` 组件不会管理提交，它只会委托给
    `ContactUsPage` 组件来处理提交：
- en: 'Let''s start by importing `ISubmitResult` and `IValues`, and creating a props
    interface in the `ContactUs` component for the `onSubmit` function:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先导入 `ISubmitResult` 和 `IValues`，并在 `ContactUs` 组件中为 `onSubmit` 函数创建一个 props
    接口：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a `handleSubmit` function that will invoke the `onSubmit` prop:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `handleSubmit` 函数来调用 `onSubmit` prop：
- en: '[PRE90]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `onSubmit` prop is asynchronous, so we need to prefix our function with
    `async` and prefix the `onSubmit` call with `await`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmit` prop 是异步的，所以我们需要在我们的函数前加上 `async`，并在 `onSubmit` 调用前加上 `await`。'
- en: 'Bind this submit handler in the form `onSubmit` prop in the JSX:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JSX 中将此提交处理程序绑定到表单的 `onSubmit` prop 中：
- en: '[PRE91]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s move on to the `ContactUsPage` component now. Let''s start by creating
    the submit handler:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们转到 `ContactUsPage` 组件。让我们首先创建提交处理程序：
- en: '[PRE92]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In practice, this will probably call a web API. In our example, we wait asynchronously
    for one second and return a validation error with the `email` field.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这可能会调用一个 web API。在我们的例子中，我们异步等待一秒钟，并返回一个带有 `email` 字段的验证错误。
- en: 'Let''s create the `wait` function we just referenced:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建刚刚引用的 `wait` 函数：
- en: '[PRE93]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Let''s wire up the `handleSubmit` method to the `ContactUs` `onSubmit` prop
    now:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`handleSubmit`方法与`ContactUs`的`onSubmit`属性连接起来：
- en: '[PRE94]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We have referenced `IValues` and `ISubmitResult`, so let''s import these:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经引用了`IValues`和`ISubmitResult`，所以让我们导入它们：
- en: '[PRE95]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If we go to the Contact Us page in the running app, fill out the form, and
    click the Submit button, we are informed that there is a problem with the email
    field, as we would expect:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到正在运行的应用程序中的联系我们页面，填写表单并单击提交按钮，我们会收到有关电子邮件字段存在问题的通知，这是我们所期望的：
- en: '![](assets/5f19c687-47c8-4ade-b729-bb59fccf669d.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f19c687-47c8-4ade-b729-bb59fccf669d.png)'
- en: 'Let''s change the submit handler in `ContactUsPage` to return a successful
    result:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`ContactUsPage`中的提交处理程序更改为返回成功的结果：
- en: '[PRE96]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, if we go to the Contact Us page in the running app again, fill out the
    form, and click the Submit button, the submission goes through fine and the Submit
    button is disabled:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次转到正在运行的应用程序中的联系我们页面，填写表单并单击提交按钮，提交将顺利进行，并且提交按钮将被禁用：
- en: '![](assets/dc82f431-136d-484c-b5e2-c3b86a943fa8.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc82f431-136d-484c-b5e2-c3b86a943fa8.png)'
- en: So, that's our Contact Us page complete, together with our generic `Form` and
    `Field` components.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的联系我们页面已经完成，还有我们的通用`Form`和`Field`组件。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed controlled components, which are React's recommended
    method for handling form data entry. With controlled components, we let React
    control input values via component state.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了受控组件，这是React处理表单数据输入的推荐方法。通过受控组件，我们让React通过组件状态控制输入值。
- en: We looked at building generic `Form` and `Field` components containing state
    and change handlers, so that we don't need to implement individual state and change
    handlers for every field in every form in our apps.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了构建通用的`Form`和`Field`组件，这些组件包含状态和更改处理程序，因此我们不需要为应用程序中每个表单中的每个字段实现单独的状态和更改处理程序。
- en: We then created some standard validation functions, and added the ability to
    add validation rules within the generic `Form` component and render validation
    errors automatically in the `Field` component.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一些标准验证函数，并在通用`Form`组件中添加了添加验证规则的能力，并在`Field`组件中自动呈现验证错误。
- en: Finally, we added the ability to handle form submission when consuming the generic
    `Form` component. Our Contact Us page was changed to use the generic `Form` and
    `Field` components.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了在使用通用`Form`组件时处理表单提交的能力。我们的联系我们页面已更改为使用通用的`Form`和`Field`组件。
- en: Our generic components only deal with very simple forms. Not surprisingly, there
    are a fair number of well-established form libraries already out in the wild.
    A popular choice is Formik, which is similar in some ways to what we have just
    built but much more powerful.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通用组件只处理非常简单的表单。毫不奇怪，已经有相当多的成熟表单库在外面。一个受欢迎的选择是Formik，它在某些方面类似于我们刚刚构建的内容，但功能更加强大。
- en: If you are building an app that contains lots of forms, it is well worth either
    building a generic form as we have just done or using an established library such
    as Formik to speed up the development process.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建包含大量表单的应用程序，构建一个通用表单或使用Formik等已建立的库来加快开发过程是非常值得的。
- en: Questions
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Check whether all that information about forms in React and TypeScript has
    stuck by trying the following implementations:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试以下实现来检查关于React和TypeScript中表单的所有信息是否已经掌握：
- en: Extend our generic `Field` component to include a number editor, using the native
    number input.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展我们的通用`Field`组件，使用原生数字输入包括一个数字编辑器。
- en: Implement an urgency field on the Contact Us form to indicate how urgent a response
    is. The field should be numeric.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在联系我们表单上实现一个紧急性字段，以指示回复的紧急程度。该字段应为数字。
- en: Implement a new validator function in the generic `Form` component, which validates
    whether a number falls between two other numbers.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通用的`Form`组件中实现一个新的验证器函数，用于验证一个数字是否落在另外两个数字之间。
- en: Implement a validation rule on the urgency field to ensure the input is a number
    between 1 and 10.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在紧急字段上实施验证规则，以确保输入是1到10之间的数字。
- en: Our validation triggers when a user clicks in and out of a field without typing
    anything. How can we trigger validation when a field loses focus, but only when
    it has been changed?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的验证在用户点击字段而不输入任何内容时触发。当字段失去焦点时如何触发验证，但只有在字段已经被更改时？
- en: Further reading
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links are good sources of further information on forms in React:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是关于React中表单的进一步信息的良好来源：
- en: There is a section in the React documentation on forms at [https://reactjs.org/docs/forms.html](https://reactjs.org/docs/forms.html).
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React文档中有一个关于表单的部分，网址是[https://reactjs.org/docs/forms.html](https://reactjs.org/docs/forms.html)。
- en: The Formik library is well worth looking into. This can be found at [https://github.com/jaredpalmer/formik](https://github.com/jaredpalmer/formik).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Formik库是值得深入研究的。可以在[https://github.com/jaredpalmer/formik](https://github.com/jaredpalmer/formik)找到。
