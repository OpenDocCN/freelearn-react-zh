- en: Chapter 2. Project 2 – Image Sharing App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。项目2 - 图像分享应用程序
- en: At this point, we know how to create a fully-featured app with a custom interface.
    You even learned how to add a state management library to control shared data
    in our app so that the code base remains maintainable and scalable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何创建一个具有自定义界面的功能齐全的应用程序。您甚至学会了如何添加一个状态管理库来控制我们应用程序中的共享数据，以便代码库保持可维护和可扩展。
- en: In this lesson, we will focus on building the app with a different state management
    library (Redux), using the camera capabilities, writing platform-specific code,
    and diving deeper into building a custom user interface, which is both appealing
    and usable. An image sharing app will serve as a good example for these features
    and also will set up the basis for understanding how big apps should be built
    on React Native.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们将专注于使用不同的状态管理库（Redux）构建应用程序，利用相机功能，编写特定于平台的代码，并深入构建自定义用户界面，既吸引人又可用。图像分享应用程序将作为这些功能的一个很好的示例，并且还将为理解如何在React
    Native上构建大型应用程序奠定基础。
- en: 'We will reuse most of our code for the two platforms where this app will be
    available: iOS and Android. Although most of our user interface will be custom,
    we will use `native-base` to simplify UI elements as icons. For navigation, we
    will use `react-navigation` again as it provides the most commonly used navigation
    for each platform: tabbed navigation for iOS and drawer menu navigation for Android.
    Finally, we will use `react-native-camera` to handle the interaction with the
    device''s camera. This will not only reduce implementation complexity but also
    will provide us with a large set of features for free that we could use to extend
    our app in the future.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们的大部分代码，这个应用程序将可用于两个平台：iOS和Android。尽管我们的大部分用户界面将是自定义的，但我们将使用`native-base`来简化UI元素，如图标。对于导航，我们将再次使用`react-navigation`，因为它为每个平台提供了最常用的导航：iOS的选项卡导航和Android的抽屉菜单导航。最后，我们将使用`react-native-camera`来处理与设备相机的交互。这不仅会减少实现复杂性，还会为我们提供一大堆免费的功能，我们可以在将来扩展我们的应用程序时使用。
- en: For this app, we will mock up a number of API calls so that we don't need to
    build a backend. These calls should be easily replaced by real API when the time
    to build a connected app comes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将模拟一些API调用，这样我们就不需要构建后端。当构建连接的应用程序时，这些调用应该很容易被真实的API替换。
- en: Overview
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概览
- en: One of the main requirements when building an image sharing app is an appealing
    design. We will follow the design patterns for some of the most popular image
    sharing apps, adapting those patterns for each platform while trying to reuse
    as much code as possible taking advantage of React Native's cross-platform capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 构建图像分享应用程序的主要要求之一是具有吸引人的设计。我们将遵循一些最流行的图像分享应用程序的设计模式，为每个平台调整这些模式，同时尽量重用尽可能多的代码，利用React
    Native的跨平台能力。
- en: 'Let''s first take a look at the user interface in iOS:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下iOS中的用户界面：
- en: '![Overview](Images/02_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_01.jpg)'
- en: 'The main screen shows a simple header and a list of images, including the user
    picture, name, and a **More** icon to share the image. At the bottom, the tabbed
    navigation displays three icons representing the three main screens: **All Images**,
    **My Images**, and **Camera**.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕显示一个简单的标题和图像列表，包括用户图片、姓名和一个**更多**图标以分享图像。在底部，选项卡导航显示三个图标，代表三个主要屏幕：**所有图像**、**我的图像**和**相机**。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All images used for this sample app are free to be used in any form.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应用程序中使用的所有图像都可以以任何形式使用。
- en: 'When a user presses the **More** icon for a specific image, the **Share** menu
    will be displayed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下特定图像的**更多**图标时，将显示**分享**菜单：
- en: '![Overview](Images/02_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_02.jpg)'
- en: This is a standard iOS component. It doesn't make much sense to use it on a
    simulator, it can be better tested on an actual device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的iOS组件。在模拟器上使用它并没有太多意义，最好在实际设备上进行测试。
- en: 'Let''s take a look at the second screen, **My Images**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看第二个屏幕，**我的图片**：
- en: '![Overview](Images/02_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_03.jpg)'
- en: 'This is a grid representation of all the images uploaded by the current user,
    which can be updated by the next screen, **Camera**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前用户上传的所有图片的网格表示，可以通过下一个屏幕**相机**进行更新：
- en: '![Overview](Images/02_04.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_04.jpg)'
- en: The iOS simulator doesn't include support for any camera, so this feature is
    again better tested on an actual device, although `react-native-camera` is fully
    usable and will return fake data when accessed. We will use a static image for
    testing purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: iOS模拟器不包括对任何相机的支持，因此这个功能最好在实际设备上进行测试，尽管`react-native-camera`是完全可用的，并且在访问时将返回虚假数据。我们将使用静态图像进行测试。
- en: 'That''s all for iOS; let''s move now to the Android version:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是iOS的全部内容；现在让我们转向Android版本：
- en: '![Overview](Images/02_05.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_05.jpg)'
- en: As Android encourages drawer-based navigation instead of tabs, we will include
    a drawer menu icon in the header and will also make the camera available through
    a different icon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android鼓励使用抽屉式导航而不是选项卡，我们将在页眉中包括一个抽屉菜单图标，并且还将通过不同的图标使相机可用。
- en: '![Overview](Images/02_06.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_06.jpg)'
- en: 'As with the iOS **Share** menu, Android has its own controller, so we will
    take advantage of this feature and include it whenever a user taps on the **More**
    icon on a specific image:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS的**分享**菜单一样，Android有自己的控制器，因此我们将利用这一功能，并在用户点击特定图像上的**更多**图标时包含它：
- en: '![Overview](Images/02_07.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_07.jpg)'
- en: 'When a user taps on the drawer menu icon, the menu will be displayed, revealing
    the three available screens. From here, the user can navigate to the **My Images**
    screen:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击抽屉菜单图标时，菜单将显示出来，显示三个可用屏幕。从这里，用户可以导航到**我的图片**屏幕：
- en: '![Overview](Images/02_08.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_08.jpg)'
- en: 'Finally, the camera screen will also be accessible through the drawer menu:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，相机屏幕也可以通过抽屉菜单访问：
- en: '![Overview](Images/02_09.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![概览](Images/02_09.jpg)'
- en: The Android Simulator includes a camera simulation consisting of a colored moving
    square, which can be used for testing. Instead, we will stick with the fixed image
    we used in the iOS version for consistency reasons.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Android模拟器包括一个由彩色移动方块组成的相机模拟，可以用于测试。但出于一致性原因，我们将继续使用iOS版本中使用的固定图像。
- en: 'We will be covering the following topics in this lesson:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程将涵盖以下主题：
- en: Redux in React Native
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native中的Redux
- en: Using the camera
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相机
- en: Platform-specific code
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定平台的代码
- en: Drawer and tabbed navigation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽屉和选项卡导航
- en: Sharing data with other apps
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他应用程序共享数据
- en: Setting up the Folder Structure
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `imageShare` and will be available for iOS and Android devices:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用React Native的CLI初始化一个React Native项目。该项目将命名为`imageShare`，并将适用于iOS和Android设备：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to use some packages in this app, we will be using a specific version
    of React Native (`0.44.0`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在此应用程序中使用一些包，我们将使用特定版本的React Native（`0.44.0`）。
- en: 'We will be using Redux for our app, so we will create a folder structure in
    which we can accommodate our `reducers`, `actions`, `components`, `screens`, and
    `api` calls:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的应用程序使用Redux，因此我们将创建一个文件夹结构，其中可以容纳我们的`reducers`、`actions`、`components`、`screens`和`api`调用：
- en: 'Moreover, we have added `logo.png` in the `img` folder. For the rest, we have
    a very standard React Native project. The entry point will be `index.ios.js` for
    iOS and `index.android.js` for Android:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经在`img`文件夹中添加了`logo.png`。至于其余部分，我们有一个非常标准的React Native项目。入口点将是`index.ios.js`用于iOS和`index.android.js`用于Android：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have the same implementation for both files as we want to use `src/main.js`
    as the common entry point for both platforms.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对两个文件的实现是相同的，因为我们希望使用`src/main.js`作为两个平台的通用入口点。
- en: 'Let''s jump into our `package.json` file to understand which dependencies we
    will have in our app:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到我们的`package.json`文件，了解我们的应用程序将有哪些依赖项：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some of the dependencies, such as `react-navigation` or `native-base`, are
    old acquaintances from previous lessons. Others, such as `react-native-camera`,
    will be introduced in this lesson for the first time. Some of them are closely
    related to the state management library we will be using for this app, Redux:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些依赖项，如`react-navigation`或`native-base`，是以前课程中的老朋友。其他一些，如`react-native-camera`，将在本课程中首次介绍。其中一些与我们将在此应用程序中使用的状态管理库Redux密切相关：
- en: '`redux`: This is the state management library itself'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux`：这就是状态管理库本身'
- en: '`react-redux`: These are the React handlers for Redux'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-redux`：这些是Redux的React处理程序'
- en: '`redux-thunk`: This is Redux middleware that handles asynchronous action execution'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux-thunk`：这是处理异步操作执行的Redux中间件'
- en: 'To complete the installation, we will need to link `react-native-camera` as
    it requires some changes in the native part of our app:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成安装，我们需要链接`react-native-camera`，因为它需要对我们应用程序的本地部分进行一些更改：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On iOS 10 and higher, we also need to modify our `ios/imageShare/Info.plist`
    to add a **Camera Usage Description**, which should be displayed to request permission
    to enable the camera within the app. We need to add these lines right before the
    last `</dict></plist>`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 10及更高版本中，我们还需要修改我们的`ios/imageShare/Info.plist`以添加一个**相机使用说明**，这应该显示以请求权限在应用程序内启用相机。我们需要在最后的`</dict></plist>`之前添加这些行：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Redux
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: 'Redux is a predictable state container for JavaScript apps based on simple
    principles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个基于简单原则的JavaScript应用程序的可预测状态容器：
- en: The whole state of your app is stored in an object tree inside a single **store**
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应用程序的整个状态存储在一个**store**内的对象树中
- en: The only way to change the state tree is to emit an **action**, an object describing
    what happened
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变状态树的唯一方法是发出一个**action**，一个描述发生了什么的对象
- en: To specify how the actions transform the state tree, you write pure **reducers**
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指定操作如何转换状态树，您需要编写纯**reducers**
- en: 'Its popularity comes from the degree of consistency, testability, and developer
    experience that can be derived from its use in any kind of code base (frontend
    or backend). It''s also simple to reason and master due to its strict unidirectional
    data flow:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它的流行程度来自于在任何类型的代码库（前端或后端）中使用它所能产生的一致性、可测试性和开发人员体验。由于其严格的单向数据流，它也很容易理解和掌握：
- en: '![Redux](Images/02_11.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Redux](Images/02_11.jpg)'
- en: User triggers and **Actions** that are processed by **Reducers**, which are
    just pure functions applying changes to the state based on that **Action**. The
    resulting state is saved in a single **Store**, which is used by the **View**
    in our app to display the current state of the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用户触发和由**Reducers**处理的**Actions**，这些**Reducers**只是应用基于该**Action**的状态变化的纯函数。生成的状态保存在一个**Store**中，该**Store**由我们应用程序中的**View**使用，以显示应用程序的当前状态。
- en: Redux is a complex topic that falls out of the scope of this book, but it will
    be extensively used throughout some of the lessons in this book, so it could be
    beneficial to take a look at their official documentation ([http://redux.js.org/](http://redux.js.org/))
    to get acquainted with the basic concepts of this state management library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个复杂的主题，超出了本书的范围，但它将在本书的一些课程中广泛使用，因此可能有益于查看它们的官方文档([http://redux.js.org/](http://redux.js.org/))，以熟悉这个状态管理库的基本概念。
- en: 'Some of the basic concepts of Redux will be used in our `src/main.js` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的一些基本概念将在我们的`src/main.js`文件中使用：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's focus first on the Redux ceremony. `let store = createStore(combineReducers({
    imagesReducer }), applyMiddleware(thunk));` sets up the store by combining the
    imported reducers (we only have one reducer for this app, so this is merely informative)
    and applying the **Thunk** middleware, which will enable our app to use asynchronous
    actions. We will simulate several API calls that will return asynchronous promises,
    so this middleware is needed to properly handle the resolutions of those promises.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注Redux的仪式。`let store = createStore(combineReducers({ imagesReducer }),
    applyMiddleware(thunk));`通过组合导入的reducer（我们这个应用程序只有一个reducer，所以这只是信息性的）并应用**Thunk**中间件来设置存储，这将使我们的应用程序能够使用异步操作。我们将模拟几个API调用，这些调用将返回异步承诺，因此需要这个中间件来正确处理这些承诺的解析。
- en: 'Then, we have our `render` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有我们的`render`方法：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is standard in most Redux apps using React. We wrap the root component
    `(<Navigator />` in our case) with a `<Provider />` component to ensure that we
    will have the `store` available from the root of our app. The Redux `connect`
    method will be available for us to use in our containers or screens as we proceed
    in this lesson.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这在大多数使用React的Redux应用程序中都是标准的。我们用一个`<Provider />`组件包装根组件`(<Navigator />`在我们的例子中)来确保我们将从我们应用程序的根部分获得`store`。Redux的`connect`方法将在我们继续本课程时在我们的容器或屏幕中可用。
- en: 'We will use a `<Navigator />` component as the root of our app, but it will
    have a different nature based on which platform is running:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个`<Navigator />`组件作为我们应用程序的根，但它将根据运行的平台的不同而具有不同的性质：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Platform` is a React Native API used mainly to identify which platform our
    app is running on. We can write iOS-specific code by enclosing that code with
    `if(Platform.OS === ''ios''){ ... }` and the same goes for Android: `if(Platform.OS
    === ''android''){ ... }`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platform`是一个React Native API，主要用于识别我们的应用程序正在运行的平台。我们可以通过用`if(Platform.OS ===
    ''ios''){ ... }`括起来的代码来编写特定于iOS的代码，对于Android也是一样：`if(Platform.OS === ''android''){
    ... }`。'
- en: In this case, we are using it to build a tabbed navigator on iOS and a drawer
    navigator on Android, which are the **de facto** navigation patterns for those
    platforms. On both navigators, we will set `ImagesList`, `MyImages`, and `Camera`
    as the three main screens in our app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将在iOS上使用它来构建一个选项卡导航器，在Android上使用它来构建一个抽屉导航器，这些都是这些平台上的**事实**导航模式。在这两个导航器上，我们将把`ImagesList`、`MyImages`和`Camera`设置为我们应用程序中的三个主要屏幕。
- en: ImagesList
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ImagesList
- en: 'The main screen in our app is a list of images retrieved from the backend.
    We will display this images together with their corresponding uploader profile
    pictures and names. For each image, we will show `More`, which can be used to
    share the image with other apps on the user''s device, such as messaging apps
    or social networks. Most of the UI for this screen will be derived from the `<Gallery
    />` component, so we will focus on connecting the screen with Redux store, adding
    a custom header, and a scroll view to make the gallery scrollable, and adding
    an activity indicator to warn the user about network activity:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的主屏幕是从后端检索的图像列表。我们将显示这些图像以及它们对应的上传者个人资料图片和名称。对于每个图像，我们将显示`更多`，可以用于与用户设备上的其他应用程序共享图像，例如消息应用程序或社交网络。这个屏幕的大部分UI将从`<Gallery
    />`组件派生，因此我们将专注于将屏幕与Redux存储连接起来，添加自定义标题，并添加一个滚动视图使画廊可滚动，并添加一个活动指示器来警告用户有网络活动：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As most of the React apps use Redux, we need to connect our component with
    the state and the actions. We will create two functions (`mapStateToProps` and
    `mapStateActionsToProps`) to decorate our `<ImageList />` component with the mapped
    actions and parts of the state the component is interested in:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数React应用程序使用Redux，我们需要将我们的组件与状态和操作连接起来。我们将创建两个函数（`mapStateToProps`和`mapStateActionsToProps`）来装饰我们的`<ImageList
    />`组件，以映射组件感兴趣的操作和状态的部分：
- en: '`images`: This is the list of images we will use to render in our `<Gallery
    />`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`：这是我们将在`<Gallery />`中用于呈现的图像列表'
- en: '`addingImage`: This is a flag we will set to `true` when uploading an image'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addingImage`：这是一个标志，当上传图像时我们将设置为`true`'
- en: '`fetchingImages`: This is a flag that will be set to `true` when the app requests
    the list of images to the backend in order to update the store'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchingImages`：当应用程序请求从后端获取图像列表以更新存储时，此标志将设置为`true`'
- en: 'The only action we will need on this screen is `fetchImages`, which is accessible
    through the `propscomponent` because we connected the list of actions in `Actions`
    to our `<ImagesList />` component. On a similar note, we have the three state
    variables (`images`, `addingImage`, and `fetchingImages`) available through `props`,
    thanks to the same `connect` invocation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们唯一需要的操作是`fetchImages`，它可以通过`propscomponent`访问，因为我们将`Actions`中的操作列表连接到我们的`<ImagesList
    />`组件。同样，我们通过`props`还可以访问三个状态变量（`images`，`addingImage`和`fetchingImages`）,这要归功于相同的`connect`调用：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's all we need from Redux. We will see this pattern in other screens as
    well, as it's a common solution for connecting React components with parts of
    the store and the list of actions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们从Redux需要的全部。我们将在其他屏幕中看到这种模式，因为它是连接React组件与存储部分和操作列表的常见解决方案。
- en: 'The `fetchImages` action is called on `componentWillMount` as the initial retrieval
    of the list of images to be rendered:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchImages`动作在`componentWillMount`上调用，作为要呈现的图像列表的初始检索：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also added a way to detect the moment the `addingImage` flag is set to `true`
    to display the activity indicator:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一种方法来检测`addingImage`标志何时设置为`true`以显示活动指示器：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method will call `scrollTo` in the `<Scrollview />` to make sure it displays
    the top part, so the `<ActivityIndicator />` is visible to the user. We are using
    a custom `<ActivityIndicator />` this time (imported from `src/components/ActivityIndicator`),
    as we want to display not only a spinner but also a message.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将在`<Scrollview />`中调用`scrollTo`，以确保它显示顶部部分，因此`<ActivityIndicator />`对用户可见。这次我们使用了自定义的`<ActivityIndicator
    />`（从`src/components/ActivityIndicator`导入），因为我们不仅想显示旋转器，还想显示消息。
- en: 'Last, we will add two components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加两个组件：
- en: '`<Header />`: This displays the logo and (in the Android version) two icons
    to navigate to the drawer menu and the camera screen'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Header />`：显示标志和（在Android版本中）两个图标，用于导航到抽屉菜单和相机屏幕'
- en: '`<Gallery />`: This shows the formatted list of images and uploaders'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Gallery />`：这显示了格式化的图片列表和上传者'
- en: 'Before moving to another screen, let''s take a look at the three custom components
    we included in this one: `<ActivityIndicator />`, `<Header />`, and `<Gallery
    />`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在转移到另一个屏幕之前，让我们看一下我们在这个屏幕中包含的三个自定义组件：`<ActivityIndicator />`、`<Header />` 和
    `<Gallery />`。
- en: Gallery
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gallery
- en: 'Gallery holds all the rendering logic for the list of images. It relies on
    `native-base` and, more specifically, on two of its components, `<List />` and
    `<ListItem />`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gallery 包含了所有图片列表的渲染逻辑。它依赖于 `native-base`，更具体地说，依赖于它的两个组件，`<List />` 和 `<ListItem
    />`：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This component takes two props from its parent: `loading` and `imageList`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件从它的父组件中获取两个props：`loading` 和 `imageList`。
- en: '`loading` is used to display a standard `<ActivityIndicator />` showing the
    user network activity. This time we are using the standard one instead of a custom
    indicator as it should be clear enough what the network activity is indicating.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`loading` 用于显示标准的 `<ActivityIndicator />`，显示用户的网络活动。这次我们使用标准的指示器，而不是自定义指示器，因为应该很清楚网络活动表示的是什么。'
- en: '`imageList` is the array storing the list of images, which will be rendered
    in our `<Gallery />` one `<ListenItem />` at a time. Each `<ListItem />` holds
    a `<Button />` with `onPress={this._share.bind(this, image)` to share the image
    with other apps. Let''s take a look at the `_share` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`imageList` 是存储图片列表的数组，它将在我们的 `<Gallery />` 中一次渲染一个 `<ListItem />`。每个 `<ListItem
    />` 都包含一个带有 `onPress={this._share.bind(this, image)` 的 `<Button />`，用于与其他应用程序共享图片。让我们看一下
    `_share` 函数：'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Share` is a React Native API for sharing text content. In our case, we will
    share the URL (`img.src`) of the image together with a simple title. Sharing text
    is the easiest way of sharing content between apps, as many apps would accept
    text as a shared format.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Share` 是一个用于分享文本内容的 React Native API。在我们的情况下，我们将分享图片的URL（`img.src`）以及一个简单的标题。分享文本是在应用程序之间共享内容的最简单方式，因为许多应用程序都会接受文本作为共享格式。'
- en: 'It''s also worth noting the style we apply to the image to take over the whole
    width and a fixed height (`300`), so we have a stable layout for all images even
    when the display images have different sizes. For this setup, we use `resizeMode:
    ''cover''` so the images are not stretched in any dimension. This means we may
    end up cutting the image, but it compensates on uniformity. Another option would
    be to use `resizeMode: contain` if we don''t want to cut anything, but rather
    want to fit the image inside these bounds while possibly shrinking them.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '值得注意的是我们对图片应用的样式，使其占据整个宽度并具有固定高度（`300`），这样即使显示的图片大小不同，我们也能获得稳定的布局。为了实现这一设置，我们使用了
    `resizeMode: ''cover''`，这样图片在任何维度上都不会被拉伸。这意味着我们可能会裁剪图片，但这样可以保持统一性。另一个选项是使用 `resizeMode:
    contain`，如果我们不想裁剪任何内容，而是想要将图片适应这些边界并可能缩小它们。'
- en: Header
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Header
- en: 'We want to reuse a custom header between several screens. That''s why it''s
    best to create a separate component for it and import it in those screens:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在多个屏幕之间重用一个自定义的标题。这就是为什么最好为它创建一个单独的组件，并在这些屏幕中导入它的原因：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are using the `Platform` API again to detect Android devices and show a
    drawer menu button and a camera button only on that platform. We decided to do
    this to make those features, which are the core of the app, more prominent to
    Android users by reducing the number of buttons needed to be pressed to reach
    them. The actions to be performed when pressing the buttons are passed by the
    parent component through two props:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `Platform` API 来检测安卓设备，并且只在该平台上显示抽屉菜单按钮和相机按钮。我们决定这样做是为了使这些功能更加突出，从而减少需要按下的按钮数量，以便安卓用户更容易地使用这些功能。按下按钮时要执行的操作是通过父组件通过两个props传递的：
- en: '`onMenuButtonPress`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMenuButtonPress`'
- en: '`onCameraButtonPress`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCameraButtonPress`'
- en: 'Those two props call two separate functions invoking the `navigate` method
    of the navigator:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性调用两个单独的函数，调用导航器的`navigate`方法：
- en: '`this.props.navigation.navigate(''DrawerOpen'')`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.props.navigation.navigate(''DrawerOpen'')`'
- en: '`this.props.navigation.navigate(''Camera'')`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.props.navigation.navigate(''Camera'')`'
- en: 'The last thing to note is how we set up the layout for the container in this
    component. We use `justifyContent: ''space-around''`, which is the way we tell
    Flexbox to evenly distribute items in the line with equal space around them. Note
    that, visually, the spaces aren''t equal since all the items have equal space
    on both sides. The first item will have one unit of space against the container
    edge, but two units of space between the next item because that next item has
    its own spacing that applies:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '最后要注意的是我们如何设置这个组件中容器的布局。我们使用`justifyContent: ''space-around''`，这是告诉Flexbox均匀分布项目在行中，并在它们周围有相等的空间。请注意，从视觉上看，这些空间并不相等，因为所有项目在两侧都有相等的空间。第一个项目将在容器边缘有一个单位的空间，但下一个项目之间将有两个单位的空间，因为下一个项目有自己的间距。'
- en: '![Header](Images/02_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Header](Images/02_12.jpg)'
- en: ActivityIndicator
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActivityIndicator
- en: 'Our custom `ActivityIndicator` is a very simple component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义`ActivityIndicator`是一个非常简单的组件：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It receives a message as a prop and displays it next to a standard spinner.
    We also added a custom background color (`#f0f0f0`) to make it more visible over
    the white backgrounds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个消息作为属性，并将其显示在标准旋转器旁边。我们还添加了自定义背景颜色（`#f0f0f0`）以使其在白色背景上更加可见。
- en: Let's move now to the camera screen to add our images to the list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转移到相机屏幕，将我们的图像添加到列表中。
- en: Camera
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机
- en: 'Most of the logic when taking photos can be abstracted when using `react-native-camera`,
    so we will focus on using this module in our component and making sure we connect
    it to our app''s state through Redux actions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`react-native-camera`时，大部分拍照逻辑可以被抽象出来，因此我们将专注于在我们的组件中使用这个模块，并确保通过Redux操作将其连接到我们应用程序的状态：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The way `react-native-camera` works is by providing a component we can include
    in our screen and, through a reference, we can call its `capture` method, which
    returns a promise we can use to call `addImage` to upload our image to the app's
    backend.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native-camera`的工作方式是通过提供一个我们可以包含在屏幕中的组件，并通过引用，我们可以调用它的`capture`方法，该方法返回一个我们可以使用的承诺，以调用`addImage`将我们的图像上传到应用程序的后端。'
- en: 'Let''s take a closer look at the `<Camera />` component:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下`<Camera />`组件：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `<Camera />` component takes three props:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Camera />`组件有三个属性：'
- en: '`ref`: This sets a reference to the `<Camera />` component in the parent component
    for it to call the capture method.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`：这在父组件中为`<Camera />`组件设置一个引用，以便调用捕获方法。'
- en: '`style`: This allows the developer to specify the look of the component in
    the app.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`样式`：这允许开发人员指定应用程序中组件的外观。'
- en: '`aspect`: This allows you to define how the view renderer will behave when
    displaying camera''s view. There are three options: `fill`, `fit`, and `stretch`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspect`：这允许您定义视图渲染器在显示相机视图时的行为。有三个选项：`fill`，`fit`和`stretch`。'
- en: 'The `takePicture` function will be invoked when the user presses the camera
    button:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下相机按钮时，`takePicture`函数将被调用：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will use the saved reference to the camera to call its `capture` method to
    which we can pass some metadata (for example, the location in which the photo
    was taken). This method returns a promise, which will be resolved with the image
    data so we will use this data to call the `addImage` action to send this data
    to the backend, so the picture can be added to the `imagesList`. Right after sending
    the image to the backend, we will make the app navigate back to the `ImagesList`
    screen. The `addImage` method will set the `addingImages` flag, so the `ImageList`
    screen can display the activity indicator with the corresponding message.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用保存的相机引用来调用其`capture`方法，我们可以传递一些元数据（例如，拍摄照片的位置）。这个方法返回一个promise，将使用这个数据调用`addImage`动作将这个数据发送到后端，这样图片就可以添加到`imagesList`中。在将图像发送到后端后，我们将使应用程序导航回`ImagesList`屏幕。`addImage`方法将设置`addingImages`标志，因此`ImageList`屏幕可以显示相应消息的活动指示器。
- en: 'Let''s move on to the last screen in our app: `MyImages`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看我们应用程序中的最后一个屏幕：`MyImages`。
- en: MyImages
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyImages
- en: This screen shows all the images the logged user has uploaded. We are using
    fake images for this screen to pre-fill this screen, but more images can be added
    through the camera screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕显示了已登录用户上传的所有图像。我们在这个屏幕上使用虚假图像来预先填充这个屏幕，但更多的图像可以通过相机屏幕添加。
- en: 'Most of the rendering logic will be moved to a separate component named `<ImagesGrid
    />`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分渲染逻辑将被移动到一个名为`<ImagesGrid />`的单独组件中：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first thing this component does is make a call to the `fetchImages` action
    but, unlike the `<ImagesList />` component, it passes the username to only retrieve
    the pictures for the logged in user. When we create this action, we need to take
    this into account and receive an optional `userName` parameter to filter out the
    list of images we will retrieve.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的第一件事是调用`fetchImages`动作，但与`<ImagesList />`组件不同的是，它只传递用户名来仅检索已登录用户的图片。当我们创建这个动作时，我们需要考虑到这一点，并接收一个可选的`userName`参数来过滤我们将检索的图像列表。
- en: Other than that, this component delegates most of its behavior to `<ImageGrid
    />` so that we can reuse the render capabilities for other users. Let's move on
    to `<ImageGrid />`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，这个组件将大部分行为委托给`<ImageGrid />`，这样我们可以重用渲染能力给其他用户。让我们继续看看`<ImageGrid />`。
- en: ImageGrid
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ImageGrid
- en: 'A simple scroll view and a list of images. This component is as simple as that,
    but it''s configured in a way that allows the images to flow like a grid in an
    easy way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的滚动视图和图像列表。这个组件就是这么简单，但它配置成可以让图像以网格的方式轻松流动：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When styling the container, we use `flexWrap`: ''wrap'' to ensure the images
    flow not only in the `row` direction but also spread to new lines when the device
    width is covered for a line of images. By setting `width` and `height` for each
    image to `width/3 - 2`, we ensure the container can fit three images per row,
    including two pixels for a small margin between them.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置容器样式时，我们使用`flexWrap`：'wrap'来确保图像不仅在`row`方向上流动，而且当设备宽度覆盖一行图像时也会扩展到新行。通过为每个图像设置`width`和`height`为`width/3
    - 2`，我们确保容器可以每行容纳三个图像，包括两个像素的小间距。
- en: There are also several grid modules available through `npm`, but we have decided
    to build our own component for this matter, as we don't need extra functionality
    in the grid and we gain the flexibility to do it this way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些通过`npm`可用的网格模块，但我们决定为此构建我们自己的组件，因为我们不需要网格中的额外功能，并且以这种方式可以获得灵活性。
- en: Those were all the screens and visual components we need in our image share
    app. Let's take a look now at the glue that makes them work together, the actions
    and the reducers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们在图像分享应用中需要的所有屏幕和视觉组件。现在让我们来看看让它们一起工作的粘合剂，即动作和减速器。
- en: Actions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作
- en: 'As we see on our screens, there are only two actions needed for this app, `fetchImages`
    (for all users or for a specific user) and `addImage`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在屏幕上看到的，这个应用只需要两个操作，`fetchImages`（对所有用户或特定用户）和`addImage`：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Redux actions are just simple objects describing an event, including its payload.
    Since we are using `redux-thunk`, our **action creators** will return a function
    in which the Redux `dispatch` function will be called, passing the action. Let''s
    take a closer look at our `addImage` action:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Redux操作只是描述事件的简单对象，包括其有效负载。由于我们使用了`redux-thunk`，我们的**action creators**将返回一个函数，在这个函数中将调用Redux的`dispatch`函数，传递操作。让我们更仔细地看看我们的`addImage`操作：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function we return starts by dispatching an action named `ADD_IMAGE` with
    no payload, as we just want to let Redux know that we are ready to make a network
    request to upload the image to our backend. Then, we make that request using our
    `api` (we will mock this call later). This request will return a promise, so we
    can attach `.then` and `.catch` callbacks to handle the response. If the response
    is positive (the image was properly uploaded), we will dispatch an `ADD_IMAGE_SUCCESS`
    action passing the URL for the uploaded image. If there is an error, we will dispatch
    an `ADD_IMAGE_ERROR` action covering all the possible states.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的函数首先通过不带有效负载的操作`ADD_IMAGE`来调度一个操作，因为我们只是想让Redux知道我们准备好发起网络请求将图像上传到我们的后端。然后，我们使用我们的`api`进行该请求（稍后我们将模拟这个调用）。这个请求将返回一个promise，所以我们可以附加`.then`和`.catch`回调来处理响应。如果响应是积极的（图像被正确上传），我们将调度一个`ADD_IMAGE_SUCCESS`操作，传递上传图像的URL。如果出现错误，我们将调度一个`ADD_IMAGE_ERROR`操作，涵盖所有可能的状态。
- en: 'Most of the action creators work in a similar way when making network requests
    in **Redux** and **Thunk**. In fact, our action `fetchImages` is very similar
    to `addImage`, with one exception: it needs to check if `userId` was passed and
    issued a different set of actions instead, so the reducers can modify the state
    accordingly. Let''s then take a look at the reducers, which will be handling all
    these actions.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数action creators在**Redux**和**Thunk**中进行网络请求时都是以类似的方式工作。事实上，我们的action `fetchImages`与`addImage`非常相似，只有一个例外：它需要检查是否传递了`userId`，并发出一组不同的操作，以便reducers可以相应地修改状态。让我们来看一下将处理所有这些操作的reducers。
- en: Reducers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: 'In Redux, reducers are functions in charge of updating the state as new actions
    happen. They receive the current `state` and the action (including any payload)
    and return a new state object. We won''t go deep into how reducers work, we just
    need to understand their basic structure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux中，reducers是负责在发生新操作时更新状态的函数。它们接收当前的`state`和操作（包括任何有效负载），并返回一个新的状态对象。我们不会深入研究reducers的工作原理，我们只需要了解它们的基本结构：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s break this down:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We start with an initial state where all properties will be set to `null` except
    for `user`, which will contain mocked user data. This initial state is injected
    by default in the reducer on startup:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个初始状态开始，其中所有属性都将设置为`null`，除了`user`，它将包含模拟用户数据。这个初始状态默认在启动时由reducer注入：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the subsequent calls, Redux will inject the actual state after applying
    any actions. Inside this function, we have `switch` evaluating the type of each
    triggered action to modify the state according to that action and its payload.
    Let''s take, for example, the `FETCH_IMAGES_SUCCESS` action:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的调用中，Redux将在应用任何操作后注入实际状态。在这个函数内部，我们有一个`switch`来评估每个触发的操作的类型，以根据该操作及其有效负载修改状态。例如，让我们来看一下`FETCH_IMAGES_SUCCESS`操作：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One of the rules in Redux is that reducers shouldn't mutate state, but return
    a new object after an action is triggered. Using `Object.assign`, we return a
    new object containing the current state plus the desired changes based on the
    action which just happened. In this case, we are setting the `fetchingImages`
    flag to `false` to let our components know that they can hide any activity indicator
    related to the action of fetching images. We also set the received list of images
    (from `actions.images`) in the key `images` of our state, so they can be injected
    into the components requiring them. Finally, we set the `error` flag to `null`
    to hide any errors we may have displayed because of a previous state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的一个规则是，减速器不应该改变状态，而是在触发动作后返回一个新对象。使用`Object.assign`，我们返回一个包含当前状态加上基于刚刚发生的动作的所需更改的新对象。在这种情况下，我们将`fetchingImages`标志设置为`false`，以便让我们的组件知道它们可以隐藏与获取图像动作相关的任何活动指示器。我们还将收到的图像列表（来自`actions.images`）设置在我们状态的`images`键中，以便它们可以被注入到需要它们的组件中。最后，我们将`error`标志设置为`null`，以隐藏由于先前状态而显示的任何错误。
- en: 'As we mentioned before, every asynchronous action should be split into three
    separate actions to represent the three different states: asynchronous request
    pending, succeeded, and errored. This way, we will have three groups of actions
    for our app:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，每个异步操作都应该分成三个单独的动作来表示三种不同的状态：异步请求挂起，成功和出错。这样，我们将为我们的应用程序有三组动作：
- en: '`FETCH_IMAGES`, `FETCH_IMAGES_SUCCESS`, and `FETCH_IMAGES_ERROR`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FETCH_IMAGES`，`FETCH_IMAGES_SUCCESS`和`FETCH_IMAGES_ERROR`'
- en: '`FETCH_USER_IMAGES`, `FETCH_USER_IMAGES_SUCCESS`, and `FETCH_USER_IMAGES_ERROR`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FETCH_USER_IMAGES`，`FETCH_USER_IMAGES_SUCCESS`和`FETCH_USER_IMAGES_ERROR`'
- en: '`ADD_IMAGE`, `ADD_IMAGE_SUCCESS`, and `ADD_IMAGE_ERROR`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD_IMAGE`，`ADD_IMAGE_SUCCESS`和`ADD_IMAGE_ERROR`'
- en: 'It''s important to note that we have separate cases for `FETCH_IMAGES` and
    `FETCH_USER_IMAGES`, as we want to keep two separate lists of images at the same
    time:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们为`FETCH_IMAGES`和`FETCH_USER_IMAGES`有单独的情况，因为我们希望同时保留两个不同的图像列表：
- en: A general one containing the images of all the people the user is following
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含用户正在关注的所有人的图像的通用列表
- en: The list of the pictures the user has uploaded
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户上传的图片列表
- en: The last missing piece is the API calls invoked from the action creators.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺失的部分是从动作创建者调用的API调用。
- en: API
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: 'In a real-world app, we would place all the calls to our backend in a separate
    `api` folder. For educational purposes, we just mocked the two API calls that
    are core to our app, `addImage` and `fetchImages`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，我们会将所有对后端的调用放在一个单独的`api`文件夹中。出于教育目的，我们只是模拟了对我们应用程序核心的两个API调用，`addImage`和`fetchImages`：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To simulate the network delay, we added some `setTimeouts` that will help in
    testing the activity indicators we set up to show the user network activity. We
    also used promises instead of plain callbacks to make our code easier to read.
    We also skipped the image URLs in these examples to make it more succinct.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟网络延迟，我们添加了一些`setTimeouts`，这将有助于测试我们设置的用于显示用户网络活动的活动指示器。我们还使用了promise而不是普通的回调来使我们的代码更易于阅读。我们还在这些示例中跳过了图像URL，以使其更简洁。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We used Redux in this app, and that shaped the folder structure we use. Although
    using Redux requires some boilerplate code, it helps break up our codebase in
    a reasonable way and removes direct dependencies between containers or screens.
    Redux is definitely a great addition when we need to maintain a shared state between
    screens, so we will be using it further throughout the rest of this book. In more
    complex apps, we would need to build more reducers and possibly separate them
    by domain and use Redux `combineReducers`. Moreover, we would need to add more
    actions and create separate files for each group of actions. For example, we would
    need actions for login, logout, and register, which we could put together in a
    folder named `src/actions/user.js`. Then, we should move our image-related actions
    (currently in `index.js`) to `src/actions/images.js`, so we can modify `src/actions/index.js`
    to use it as a combinator for the user and images actions in case we want to have
    the ability to import all the actions in one go.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个应用程序中使用了Redux，并且这塑造了我们使用的文件夹结构。虽然使用Redux需要一些样板代码，但它有助于以合理的方式拆分我们的代码库，并消除容器或屏幕之间的直接依赖关系。当我们需要在屏幕之间保持共享状态时，Redux绝对是一个很好的补充，因此我们将在本书的其余部分继续使用它。在更复杂的应用程序中，我们需要构建更多的减速器，并可能按领域将它们分开并使用Redux
    `combineReducers`。此外，我们需要添加更多的操作，并为每组操作创建单独的文件。例如，我们需要登录、注销和注册的操作，我们可以将它们放在名为`src/actions/user.js`的文件夹中。然后，我们应该将我们与图像相关的操作（目前在`index.js`中）移动到`src/actions/images.js`，这样我们就可以修改`src/actions/index.js`以将其用作用户和图像操作的组合器，以便在需要一次性导入所有操作时使用。
- en: Redux also helps with testing as it isolates the app's business logic into the
    reducers, so we can focus on testing them thoroughly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Redux还有助于测试，因为它将应用程序的业务逻辑隔离到减速器中，因此我们可以专注于对其进行彻底测试。
- en: Mocking the API calls enables us to build a quick prototype for our app. When
    a backend is available, we can reuse those mockups for test purposes and replace
    `src/api/index.js` with real HTTP calls. In any case, it's a good idea to have
    a separate folder for all our API calls, so we can replace them easily if there
    are any backend changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟API调用使我们能够为我们的应用程序构建一个快速原型。当后端可用时，我们可以重用这些模型进行测试，并用真正的HTTP调用替换`src/api/index.js`。无论如何，最好为我们所有的API调用建立一个单独的文件夹，这样如果后端发生任何更改，我们就可以轻松地替换它们。
- en: You also learned how to build platform-specific code (Android-specific in our
    case), which is a very useful feature for most apps. Some companies prefer to
    write separate apps for each platform and only reuse their business logic code,
    which should be very easy in any Redux-based app as it resides in the reducers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何构建特定平台的代码（在我们的案例中是特定于Android），这对大多数应用程序来说是非常有用的功能。一些公司更喜欢为每个平台编写单独的应用程序，并且只重用它们的业务逻辑代码，在任何基于Redux的应用程序中都应该非常容易，因为它驻留在减速器中。
- en: There is no specific API in React Native to control the device's camera, but
    we can use the `react-native-camera` module for it. This is an example of a library
    accessing iOS- and Android-native APIs to expose them in the React Native JavaScript
    world.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中没有特定的API来控制设备的相机，但我们可以使用`react-native-camera`模块来实现。这是一个访问iOS和Android本地API并在React
    Native JavaScript世界中公开它们的库的示例。
- en: In our next lesson, we will explore and cross that bridge between the native
    and the JavaScript world in React Native apps by building a messaging application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一课中，我们将通过构建一个消息应用程序来探索和跨越React Native应用程序中本地和JavaScript世界之间的桥梁。
- en: Assessments
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Actions that are processed by ______ are just pure functions that apply changes
    to the state based on that action.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由______处理的操作只是纯函数，根据该操作对状态进行更改。
- en: Viewer
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看器
- en: Reducers
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减速器
- en: Navigator
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航器
- en: Middleware
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件
- en: Gallery holds all the rendering logic for the list of images. It relies on _____and,
    more specifically, on two of its components, `<List />` and `<ListItem />`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gallery 包含了所有图像列表的渲染逻辑。它依赖于_____，更具体地说，依赖于它的两个组件，<List /> 和 <ListItem />。
- en: '`native-base`'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`native-base`'
- en: '`base-native`'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`base-native`'
- en: '`resizeMode`'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`resizeMode`'
- en: '`header`'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`header`'
- en: 'State whether the following statement is True or False: Every time a new message
    is stored in Firebase, `this.selectedChatMessages` will be synced to reflect it.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断以下陈述是真还是假：每当在Firebase中存储新消息时，`this.selectedChatMessages` 将被同步以反映它。
- en: Which among the following is a `<TextInput/>` property that will be invoked
    when a user presses the **Return** or **Next** button on the keyboard?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是 `<TextInput/>` 的属性，当用户按下键盘上的 **Return** 或 **Next** 按钮时将被调用？
- en: '`this.refs.loginPassword.focus()`'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`this.refs.loginPassword.focus()`'
- en: '`React.Component`'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`React.Component`'
- en: '`onSubmitEditing`'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onSubmitEditing`'
- en: '`onChangeText`'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onChangeText`'
- en: 'While splitting the login screen in two forms: `<LoginForm />` and `<RegistrationForm
    />` which three property components need to be passed?'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将登录屏幕分成两个表单：<LoginForm /> 和 <RegistrationForm /> 时，需要传递哪三个属性组件？
