- en: Creating a Real-Time Messaging Application with React Native and Expo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和Expo创建实时消息应用程序
- en: Having a real-time connection with a server is crucial when you're developing
    a real-time messaging application as you want your users to receive their messages
    as soon as they are sent. What you might have experienced in the previous two
    chapters is that mobile applications are more intuitive to use than web applications.
    When you want users to send messages back-and-forth, this is best done by building
    a mobile application, which you'll do in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器建立实时连接在开发实时消息应用程序时至关重要，因为您希望用户在发送消息后尽快收到消息。您可能在前两章中经历过的是，移动应用程序比Web应用程序更直观。当您希望用户来回发送消息时，最好的方法是构建一个移动应用程序，这就是本章将要做的事情。
- en: In this chapter, you'll create a real-time mobile messaging application using
    React Native and Expo that connects with a GraphQL server. By using WebSockets,
    you can create real-time connections with a server for web and mobile applications
    and have a two-way data flow between your application and a GraphQL server. This
    connection can also be used for authentication by using OAuth and JWT tokens,
    which is what you did in the [Chapter 7](ab243538-4b30-452f-8d9f-f80c648a6758.xhtml),
    *Build a Full Stack E-Commerce Application with React Native and GraphQL*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将使用React Native和Expo创建一个实时移动消息应用程序，该应用程序与GraphQL服务器连接。通过使用WebSockets，您可以为Web和移动应用程序与服务器创建实时连接，并在应用程序和GraphQL服务器之间实现双向数据流。这种连接也可以用于身份验证，使用OAuth和JWT令牌，这就是您在第7章中所做的事情，*使用React
    Native和GraphQL构建全栈电子商务应用程序*。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: GraphQL with React Native using Apollo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apollo的React Native中的GraphQL
- en: Authentication flows in React Native
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native中的身份验证流程
- en: GraphQL subscriptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL订阅
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a mobile messaging application build with React
    Native and Expo that uses a GraphQL server for authentication and to send and
    receive messages. Messages can be received in real-time as GraphQL subscriptions
    are used through a WebSocket that was created with Apollo. Users need to be logged
    in to send messages through the application, for which an authentication flow
    was built using React Navigation and AsyncStorage to store authentication details
    in persistent storage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用React Native和Expo创建一个移动消息应用程序，该应用程序使用GraphQL服务器进行身份验证并发送和接收消息。通过使用Apollo创建的WebSocket，可以实时接收消息，因为使用了GraphQL订阅。用户需要登录才能通过应用程序发送消息，为此使用了React
    Navigation和AsyncStorage构建了身份验证流程，以将身份验证详细信息存储在持久存储中。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch10-initial](https://github.com/PacktPublishing/React-Projects/tree/ch10-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch10](https://github.com/PacktPublishing/React-Projects/tree/ch10)[.](https://github.com/PacktPublishing/React-Projects/tree/ch9)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中创建的项目是在初始版本的基础上构建的，您可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch10-initial](https://github.com/PacktPublishing/React-Projects/tree/ch10-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch10](https://github.com/PacktPublishing/React-Projects/tree/ch10)。
- en: 'You need to have the application Expo Client installed on a mobile iOS or Android
    device to run the project on a physical device. Alternatively, you can install
    either Xcode or Android Studio on your computer to run the application on a virtual
    device:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在移动iOS或Android设备上安装应用程序Expo Client，以在物理设备上运行该项目。或者，您可以在计算机上安装Xcode或Android
    Studio，以在虚拟设备上运行应用程序：
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于iOS**：有关如何设置本地机器以运行iOS模拟器的信息，请参见此处：[https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/)。'
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/).
    There''s a known issue when running the emulator, which can be prevented by ensuring
    that the following lines are present in your `~/.bash_profile` or `~/.bash_rc`  file:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Android**：有关如何设置本地机器以从Android Studio运行模拟器的信息，请参见此处：[https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/)。在运行模拟器时存在已知问题，可以通过确保以下行存在于您的`~/.bash_profile`或`~/.bash_rc`文件中来防止该问题：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value for `ANDROID_SDK_LOCATION` is the path to the Android SDK on your
    local machine and can be found by opening Android Studio and going to **Preferences** | **Appearance
    & Behavior** *|* **System Settings** | **Android SDK**. The path is listed in
    the box that states the Android SDK locationand looks like this: `/Users/myuser/Library/Android/sdk`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANDROID_SDK_LOCATION`的值是您本地计算机上Android SDK的路径，可以通过打开Android Studio并转到**首选项**|**外观和行为**|**系统设置**|**Android
    SDK**来找到。路径在声明Android SDK位置的框中列出，看起来像这样：`/Users/myuser/Library/Android/sdk`。'
- en: This application was created using **Expo SDK version 33.0.0,** and so, you
    need to ensure that the version of Expo you're using on your local machine is
    similar. As React Native and Expo are frequently updated, make sure that you're
    working with this version so that the patterns described in this chapter behave
    as expected. In case your application doesn’t start or if you encounter errors,
    refer to the Expo documentation to learn more about updating the Expo SDK.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序是使用Expo SDK版本33.0.0创建的，因此，您需要确保您在本地机器上使用的Expo版本是相似的。由于React Native和Expo经常更新，请确保您使用此版本，以便本章描述的模式表现如预期。如果您的应用程序无法启动或遇到错误，请参考Expo文档以了解有关更新Expo
    SDK的更多信息。
- en: Checking out the initial project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查初始项目
- en: 'This project consists of two parts: a boilerplate React Native application
    and a GraphQL server. The React Native application can be found in the `client` directory,
    while the GraphQL server can be found in the `server` directory. For this chapter,
    you''ll need to have both the application and the server running at all times,
    where you''ll only make code changes to the application in the `client` directory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目由两部分组成：一个样板React Native应用程序和一个GraphQL服务器。React Native应用程序可以在`client`目录中找到，而GraphQL服务器可以在`server`目录中找到。对于本章，您需要始终同时运行应用程序和服务器，您只会对`client`目录中的应用程序进行代码更改。
- en: 'To get started with this chapter, you''ll need to run the following command
    in the `client` and `server` directories in order to install all of the dependencies
    and start both the server and the application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章，您需要在`client`和`server`目录中运行以下命令，以安装所有依赖项并启动服务器和应用程序：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the mobile application, this command will start Expo after installing the
    dependencies and gives you the ability to start your project from the Terminal
    or from your browser. In the Terminal, you can either use the QR code to open
    the application on your mobile device or open the application on a virtual device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动应用程序，此命令将在安装依赖项后启动Expo，并使您能够从终端或浏览器启动项目。在终端中，您可以使用QR码在移动设备上打开应用程序，也可以在虚拟设备上打开应用程序。
- en: 'Regardless of whether you''ve opened the application using the from a physical
    or virtual iOS or Android device, the application should look something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用物理设备还是虚拟iOS或Android设备打开应用程序，应用程序应该看起来像这样：
- en: '![](assets/8dab731f-78bf-46e1-8bdf-21b18befa226.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8dab731f-78bf-46e1-8bdf-21b18befa226.png)'
- en: 'The initial application consists of five screens: `AuthLoading`, `Conversations`, `Conversation`,
    `Login`, and `Settings`. The `Conversations` screen will be the initial screen
    and shows a loading message, while the `Settings` screen contains a non-functioning
    logout button. For now, the `AuthLoading`, `Conversation`, and `Login` screens
    aren''t visible yet as you''ll add the routing to these screens later on in this
    chapter.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 初始应用程序包括五个屏幕：`AuthLoading`、`Conversations`、`Conversation`、`Login`和`Settings`。`Conversations`屏幕将是初始屏幕，并显示加载消息，而`Settings`屏幕包含一个不起作用的注销按钮。目前，`AuthLoading`、`Conversation`和`Login`屏幕尚不可见，因为您将在本章后面为这些屏幕添加路由。
- en: 'The project structure from this React Native application in the `client` directory
    is as follows, where the structure is similar to the projects you''ve created
    before in this book:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client`目录中，此React Native应用程序的项目结构如下，结构类似于您在本书中之前创建的项目：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `assets` directory, you can find the images that are used for the application
    icon on the Home screen. Once you've installed this application on your mobile
    device, the image that will serve as the splash screen will be displayed when
    you start the application. Details about your application such as its name, description,
    and version are placed in `app.json`, while `babel.config.js` holds specific Babel
    configurations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`assets`目录中，您可以找到用于主屏幕应用程序图标的图像。一旦您在移动设备上安装了此应用程序，启动应用程序时将显示用作启动画面的图像。有关应用程序的详细信息，如名称、描述和版本，都放在`app.json`中，而`babel.config.js`包含特定的Babel配置。
- en: The `App.js` file is the actual entry point of your application, where the `AppContainer.js` file is
    being imported and returned. In `AppContainer`, all of the routes for this application
    are defined and `AppContext` will contain information that should be available
    in the entire application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`文件是您的应用程序的实际入口点，其中导入并返回`AppContainer.js`文件。在`AppContainer`中，定义了此应用程序的所有路由，并且`AppContext`将包含应该在整个应用程序中可用的信息。'
- en: 'All of the components for this application are located in the `Screens` and `Components` directories,
    where the first one holds the components that are rendered by the screens. The
    child components for these screens can be found in the `Components` directory, which
    has the following structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的所有组件都位于`Screens`和`Components`目录中，其中第一个包含由屏幕呈现的组件。这些屏幕的子组件可以在`Components`目录中找到，其结构如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The GraphQL server can be found at: `http://localhost:4000/graphql` and is where
    the GraphQL Playground will be visible. From this playground, you can view the
    schema for the GraphQL server and introspect all of the available queries, mutations,
    and subscriptions. Although you won't be making any code changes to the server,
    it's important to know about the schema and how it works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL服务器位于：`http://localhost:4000/graphql`，GraphQL Playground将在此处可见。通过这个Playground，您可以查看GraphQL服务器的模式，并审查所有可用的查询、变异和订阅。虽然您不会对服务器进行任何代码更改，但了解模式及其工作原理是很重要的。
- en: The server has two queries to retrieve a list of conversations or a single conversation
    by using the `userName` parameter as the identifier. These queries will return
    the `Conversation` type, which has an `id`, `userName`, and a list of messages
    of the `Message` type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有两个查询，一个是通过使用`userName`参数作为标识符来检索对话列表，另一个是检索单个对话。这些查询将返回`Conversation`类型，其中包括`id`、`userName`和`Message`类型的消息列表。
- en: 'On this GraphQL server, two mutations can be found, which are to either log
    the user in or to send a message. The user can be logged in by using the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个GraphQL服务器上，可以找到两个变异，一个是登录用户，另一个是发送消息。用户可以通过以下方式登录：
- en: '**Username**: `test`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：`test`'
- en: '**Password**: `test`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：`test`'
- en: Finally, there's one subscription that will retrieve messages that are added
    to the conversation. This subscription will enhance the query and can be sent
    in a document to retrieve a single conversation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个订阅将检索添加到对话中的消息。这个订阅将增强查询，并可以发送到一个文档中以检索单个对话。
- en: Creating a real-time messaging application with React Native and Expo
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和Expo创建实时消息应用程序
- en: One of the reasons why mobile applications are popular is because they usually
    provide real-time data, such as updates and notifications. With React Native and
    Expo, you can create mobile applications that can handle real-time data using
    WebSockets that synchronize with, for example, a GraphQL server. In this chapter,
    you'll add GraphQL to a React Native application and add extra features to this
    application to make it work with real-time data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序受欢迎的原因之一是它们通常提供实时数据，例如更新和通知。使用React Native和Expo，您可以创建能够使用WebSockets处理实时数据的移动应用程序，例如与GraphQL服务器同步。在本章中，您将向React
    Native应用程序添加GraphQL，并为该应用程序添加额外功能，使其能够处理实时数据。
- en: Using GraphQL in React Native with Apollo
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo在React Native中使用GraphQL
- en: In [Chapter 7](https://cdp.packtpub.com/react_projects_/wp-admin/post.php?post=33&action=edit#post_30), 
    *Build a Full Stack E-Commerce Application with React Native and GraphQL*, you've
    already set up a connection with the GraphQL server for a web application; similarly,
    in this chapter, you'll use a GraphQL server for the data in your mobile application.
    To use GraphQL in a React Native application, you can use Apollo to make the experience
    of developers smoother.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](https://cdp.packtpub.com/react_projects_/wp-admin/post.php?post=33&action=edit#post_30)中，*使用React
    Native和GraphQL构建全栈电子商务应用程序*，您已经为Web应用程序建立了与GraphQL服务器的连接；同样，在本章中，您将为移动应用程序中的数据使用GraphQL服务器。要在React
    Native应用程序中使用GraphQL，您可以使用Apollo来使开发人员的体验更加顺畅。
- en: Setting up Apollo in React Native
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React Native中设置Apollo
- en: The `react-apollo` package, which you've already used for Apollo in a React
    web application, can also be used for Apollo in a React Native mobile application.
    This fits perfectly with the tagline of React and React Native: *learn once, write
    everywhere*. But before we add Apollo to the application, it's important to know
    that when you run your application using the Expo application on your mobile,
    localhost requests aren't supported. The local GraphQL server for this project
    is running on `http://localhost:4000/graphql`, but to be able to use this endpoint
    in the React Native application, you need to find the local IP address of your
    machine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-apollo`包，你已经在React web应用程序中使用过Apollo，也可以在React Native移动应用程序中使用。这与React和React
    Native的标语“学一次，随处编写”完美契合。但在将Apollo添加到应用程序之前，重要的是要知道，当你在移动设备上使用Expo应用程序运行应用程序时，不支持本地主机请求。该项目的本地GraphQL服务器正在运行在`http://localhost:4000/graphql`，但为了能够在React
    Native应用程序中使用这个端点，你需要找到你的机器的本地IP地址。'
- en: 'To find your local IP address, you''ll need to do the following depending on
    your operating system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到你的本地IP地址，你需要根据你的操作系统做以下操作：
- en: '**For Windows**: Open the Terminal (or command prompt) and run this command:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Windows**：打开终端（或命令提示符）并运行这个命令：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will return a list, as follows, with data from your local machine. In
    this list, you need to look for the field **IPv4 Address**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个列表，如下所示，其中包含来自本地机器的数据。在这个列表中，你需要查找**IPv4 Address**字段：
- en: '![](assets/b0033c76-9caf-4443-9f99-328624f755e8.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0033c76-9caf-4443-9f99-328624f755e8.png)'
- en: '**For macOS**: Open the Terminal and run this command:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于macOS**：打开终端并运行这个命令：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After running this command, the local `Ipv4 Address` of your machine gets returned,
    which looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令后，你的机器的本地`Ipv4 Address`将被返回，看起来像这样：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After getting the local IP address, you can use this address to set up the
    Apollo client for the React Native application. To be able to use Apollo and GraphQL,
    you need to install several packages from `npm` using `npm` with the following
    command. You need to do this from the `client` directory in a separate Terminal
    tab:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 获取本地IP地址后，你可以使用这个地址来为React Native应用程序设置Apollo客户端。为了能够使用Apollo和GraphQL，你需要使用以下命令从`npm`安装`npm`中的几个包。你需要在一个单独的终端标签中从`client`目录中执行这个命令：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `App.js`, file, you can now use `apollo-client` to create your GraphQL
    client using `apollo-link-http` to set up the connection with the local GraphQL
    server and `apollo-cache-inmemory` to cache your GraphQL requests. Also, the `ApolloProvider` component
    will use the client you've created to make the GraphQL server available to all
    of the components that are nested within this Provider. The local IP address must
    be used to create the value for `API_URL` with the prefix `http://` and suffix
    `:4000/graphql` that points towards the correct port and endpoint, making it look
    like `http://192.168.1.107:4000/graphql`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，你现在可以使用`apollo-client`来创建你的GraphQL客户端，使用`apollo-link-http`来设置与本地GraphQL服务器的连接，并使用`apollo-cache-inmemory`来缓存你的GraphQL请求。此外，`ApolloProvider`组件将使用你创建的客户端，使GraphQL服务器对所有嵌套在此提供程序中的组件可用。必须使用本地IP地址来创建`API_URL`的值，前缀为`http://`，后缀为`:4000/graphql`，指向正确的端口和端点，使其看起来像`http://192.168.1.107:4000/graphql`。
- en: 'To do this, add the following lines to `App.js`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，将以下行添加到`App.js`中：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you're able to send documents with queries and mutations from any of the
    components nested within `ApolloProvider`, but you aren't able to send subscriptions
    in your documents yet. Support for subscriptions doesn't come out of the box and requires
    setting up a WebSocket for a real-time two-way connection between the client React
    Native application and the GraphQL server. This will be done later on in this
    chapter, after you've added authentication to the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从`ApolloProvider`中的任何嵌套组件发送带有查询和变异的文档，但是您还不能在文档中发送订阅。订阅的支持并不是开箱即用的，需要为客户端React
    Native应用程序和GraphQL服务器之间的实时双向连接设置WebSocket。这将在本章后面完成，之后您将为应用程序添加认证。
- en: In the next part of this section, you'll use Apollo to get the data from the
    GraphQL server that you just linked to the Apollo Client in this section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的下一部分中，您将使用Apollo从GraphQL服务器获取数据，您刚刚在本节中将其链接到Apollo Client。
- en: Using Apollo in React Native
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React Native中使用Apollo
- en: If you look at the application, you will see there are two tabs; one is showing
    the `Conversations` screen and the other is showing the `Settings` screen. The
    `Conversations` screen is now displaying the text `Loading...`, where the conversations
    that were returned from the GraphQL server should be shown. The components to
    display the conversations have already been created and can be found in the `client/Components/Conversation` directory,
    while the logic to request the conversations still needs to be created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看应用程序，您会看到有两个选项卡；一个显示`Conversations`屏幕，另一个显示`Settings`屏幕。`Conversations`屏幕现在显示文本`Loading...`，应该显示从GraphQL服务器返回的对话。用于显示对话的组件已经创建，可以在`client/Components/Conversation`目录中找到，而请求对话的逻辑仍需要创建。
- en: 'To add Apollo, follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加Apollo，请按照以下步骤：
- en: 'The first step is to import the `Query` component from `react-apollo` into
    the `client/Screens/Conversations.js` file, which you''ll use to send a document
    to the GraphQL server. This `Query` component will use the `GET_CONVERSATIONS` query and
    the `ConversationItem` component must be imported as well:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从`react-apollo`中导入`Query`组件到`client/Screens/Conversations.js`文件中，您将使用它向GraphQL服务器发送文档。这个`Query`组件将使用`GET_CONVERSATIONS`查询，`ConversationItem`组件也必须被导入：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Conversations` screen should now request the `GET_CONVERSATIONS` query using
    the `Query` component. When the request hasn''t been resolved, a loading message
    will be displayed. When the request to the GraphQL server is resolved, a styled
    `Flatlist` will return a list of the imported `ConversationItem` components. The
    styled `Flatlist` has already been created and can be found as the `ConversationsList` component at
    the bottom of this file:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Conversations`屏幕现在应该使用`Query`组件请求`GET_CONVERSATIONS`查询。当请求未解决时，将显示加载消息。当向GraphQL服务器的请求解决时，样式化的`Flatlist`将返回导入的`ConversationItem`组件列表。样式化的`Flatlist`已经创建，可以在该文件底部的`ConversationsList`组件中找到：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Conversations` screen initially shows the loading message when the document
    with the query is sent; after the query has returned data, the `ConversationsList`
    component will be displayed. This component renders `ConversationItem` components
    that display the data from the query.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Conversations`屏幕最初显示加载消息，当发送带有查询的文档时；在查询返回数据后，将显示`ConversationsList`组件。该组件呈现显示查询数据的`ConversationItem`组件。'
- en: 'When you try to click on any of the conversations, nothing will happen, except
    that you''ll see a small animation that changes the opacity. This is because the
    `ConversationItem` component is a styled `TouchableOpacity`, which can be passed
    as a function that is called when you tap it. The function to navigate to the
    conversation can be created from the `navigation` prop, which is available in
    the `Conversations` screen. This prop should be passed as a prop to `ConversationItem`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您尝试点击任何对话时，除了看到一个改变不透明度的小动画之外，什么也不会发生。这是因为“ConversationItem”组件是一个样式化的“TouchableOpacity”，当您点击它时可以作为一个被调用的函数传递。用于导航到对话的函数可以从“Conversations”屏幕中可用的“navigation”属性中创建。这个属性应该作为一个属性传递给“ConversationItem”。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ConversationItem` component can now navigate to the `Conversation` screen
    when `TouchableOpacity` is being tapped; this component can be found in the `client/Components/Conversation/ConversationItem.js` file,
    where the `navigation` prop should be destructured and used to call the `navigate` function
    on the `onPress` handler. This item is passed with the `navigate` function so
    that this data can be used in the `Conversation` screen:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “ConversationItem”组件现在可以在点击“TouchableOpacity”时导航到“Conversation”屏幕；这个组件可以在“client/Components/Conversation/ConversationItem.js”文件中找到，其中应该解构并使用“navigation”属性来调用“onPress”处理程序上的“navigate”函数。这个项目被传递给“navigate”函数，以便这些数据可以在“Conversation”屏幕中使用：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This navigates to the `Conversation` screen from the `client/Screens/Conversation.js` file,
    where the full conversation should be displayed. To display the conversation,
    you can either use the item data that was just passed to this screen or send another
    document to the GraphQL server that contains the query to retrieve the conversation.
    To make sure the most recent data is displayed, the `Query` component can be used
    to send a query to retrieve the conversation using the `userName` field from the
    `navigation` prop. To do this, you need to import the `Query` component, the `GET_CONVERSATION` query that
    is used by `Query`, and the `Message` component to display the messages from the
    conversation:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将从“client/Screens/Conversation.js”文件中导航到“Conversation”屏幕，其中应该显示完整的对话。要显示对话，您可以使用刚刚传递到此屏幕的项目数据，或者发送另一个包含检索对话的查询的文档到GraphQL服务器。为了确保显示最新的数据，“Query”组件可以用来发送一个查询，使用从“navigation”属性中的“userName”字段来检索对话。为了做到这一点，您需要导入“Query”组件、“Query”使用的“GET_CONVERSATION”查询，以及用于显示对话中消息的“Message”组件：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After this, you can add the `Query` component to the `Conversation` screen
    and have it use the `GET_CONVERSATION` query with `userName`, which was retrieved
    from the `navigation` prop. Once the query resolves the `Query` component returns
    a `data` object with a field called `messages`. This value can be passed to a
    `FlatList` component. In this component, you can iterate over this value and return `Message`
    components that display all of the messages from the conversation. `FlatList`
    is already styled and can be found at the bottom of the file as `MessagesList`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，您可以将“Query”组件添加到“Conversation”屏幕，并让它使用从“navigation”属性中检索到的“userName”与“GET_CONVERSATION”查询。一旦查询解析，“Query”组件将返回一个带有名为“messages”的字段的“data”对象。这个值可以传递给“FlatList”组件。在这个组件中，您可以遍历这个值并返回显示对话中所有消息的“Message”组件。“FlatList”已经被样式化，并且可以在文件底部找到，命名为“MessagesList”：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All of the received messages from this conversation are now being displayed
    and, using the form at the bottom of this screen, a new message can be added to
    the conversation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正在显示来自这次对话的所有接收到的消息，并且可以使用屏幕底部的表单向对话中添加新消息。
- en: 'Depending on the device that you''re running the application on, the `Conversation`
    and `Conversation` screens should look something like this on a device running
    on iOS:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您运行应用程序的设备，运行iOS设备的`Conversation`和`Conversation`屏幕应该看起来像这样：
- en: '![](assets/d97e780f-273a-4650-8f51-317bc80ce117.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d97e780f-273a-4650-8f51-317bc80ce117.png)'
- en: However, to send a message, a document with a mutation should be sent to the
    GraphQL server and, to do so the user must be authenticated. How to handle authentication
    for this mutation will be addressed in the next section, where the authentication
    flow will be added.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要发送消息，必须向GraphQL服务器发送带有突变的文档，并且用户必须经过身份验证。如何处理此突变的身份验证将在下一节中讨论，身份验证流程将被添加。
- en: Authentication in React Native
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native中的身份验证
- en: 'Typically, authentication for mobile applications is similar to how you would
    handle authentication in web applications, although there are some minor differences.
    The flow for authenticating a user on a mobile application would be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，移动应用程序的身份验证类似于在Web应用程序中处理身份验证，尽管存在一些细微差异。在移动应用程序上对用户进行身份验证的流程如下：
- en: The user opens your application
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户打开您的应用程序
- en: A loading screen is shown that checks for any authentication information in
    the persistent storage
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示检查持久存储中的任何身份验证信息的加载屏幕
- en: If authenticated, the user will be forwarded to the main screen for the application;
    otherwise, they will be forwarded to the login screen, where the user can log
    in
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果经过身份验证，用户将被转发到应用程序的主屏幕；否则，他们将被转发到登录屏幕，用户可以在那里登录
- en: Whenever the user signs out, the authentication details will be removed from
    the persistent storage
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户退出登录时，身份验证详细信息将从持久存储中删除
- en: One of the biggest caveats of this flow is that the mobile device doesn't support
    local storage or session storage as these persistent storage solutions are tied
    to the browser. Instead, you'd need to use the `AsyncStorage` library from React
    Native to have persistent storage on both iOS and Android. On iOS, it will use
    native code blocks to give you the global persistent storage that `AsyncStorage` offers,
    while on devices running Android, either RockDB- or SQLite-based storage will
    be used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流程的最大缺点之一是移动设备不支持本地存储或会话存储，因为这些持久存储解决方案与浏览器绑定。相反，您需要使用React Native中的`AsyncStorage`库在iOS和Android上实现持久存储。在iOS上，它将使用本机代码块为您提供`AsyncStorage`提供的全局持久存储，而在运行Android的设备上，将使用基于RockDB或SQLite的存储。
- en: For more complex usages, it's recommended to use an abstraction layer on top
    of `AsyncStorage` as encryption isn't supported out of the box by `AsyncStorage`.
    Also, the use of a key-value system can give you performance issues if you want
    to store a lot of information for your application using `AsyncStorage`. Both
    iOS and Android will have set limitations on the amount of storage each application
    can use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的用法，建议在`AsyncStorage`的顶层使用抽象层，因为`AsyncStorage`不支持加密。此外，如果要使用`AsyncStorage`为应用程序存储大量信息，键值系统的使用可能会导致性能问题。iOS和Android都会对每个应用程序可以使用的存储量设置限制。
- en: Authentication with React Navigation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Navigation进行身份验证
- en: To set up the authentication flow we described earlier, you'll use the React
    Navigation package again. Previously, you used the different types of navigators
    from React Navigation, but not `SwitchNavigator`. With this navigator type, you
    can only display one screen at once, and you can navigate to other screens using
    the `navigation` prop. `SwitchNavigator` should be the main navigator of your
    application and other navigators such as `StackNavigator` can be nested inside
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们之前描述的身份验证流程，你将再次使用React Navigation包。之前，你使用了React Navigation中的不同类型的导航器，但没有使用`SwitchNavigator`。使用这种导航器类型，你只能一次显示一个屏幕，并且可以使用`navigation`属性导航到其他屏幕。`SwitchNavigator`应该是你的应用程序的主要导航器，其他导航器如`StackNavigator`可以嵌套在其中。
- en: 'Adding authentication to the React Native application involves performing the
    following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 向React Native应用程序添加身份验证涉及执行以下步骤：
- en: 'The first step to using this navigator type is importing `createSwitchNavigator` from `react-navigation`,
    just like you imported the other navigators into the `client/AppContainer.js` file.
    Also, import the screen component for the login screen, which can be found at `client/Screens/Login.js`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种导航器类型的第一步是从`react-navigation`导入`createSwitchNavigator`，就像你将其他导航器导入到`client/AppContainer.js`文件中一样。还要导入登录屏幕的屏幕组件，可以在`client/Screens/Login.js`中找到：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead of wrapping `TabNavigator` at the bottom of this file with `createAppContainer`,
    you need to return `SwitchNavigator` instead. To create this, you need to use `createSwitchNavigator`, which
    you imported in the previous step. This navigator contains the `Login` screen
    and `TabNavigator`, which is the main screen for this application. For the user
    to only see the main screen when authenticated, the `Login` screen needs to be
    the initial screen:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要在此文件底部用`createAppContainer`包装`TabNavigator`，而是需要返回`SwitchNavigator`。要创建这个，你需要使用在上一步中导入的`createSwitchNavigator`。这个导航器包含`Login`屏幕和`TabNavigator`，后者是这个应用程序的主屏幕。为了让用户只在经过身份验证时看到主屏幕，`Login`屏幕需要成为初始屏幕：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Login` screen that is now displayed in the application will only switch
    to `TabNavigator` when the correct authentication details are filled in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在应用程序中显示的`Login`屏幕只有在填写正确的身份验证详细信息时才会切换到`TabNavigator`。
- en: 'However, this form needs to be connected to the GraphQL server first to receive
    the JWT token that is needed for authentication. The component for the `Login` screen
    already has a form, but submitting this form doesn''t call any function to authenticate
    the user yet. Therefore, you need to use a `Mutation` component from `react-apollo` and
    have this component send a document with the correct mutation to the GraphQL server. The
    mutation that needs to be added to this component can be found in the `constants.js` file and
    is called `LOGIN_USER`. To submit the form, the `loginUser` function that is returned
    by the `Mutation` component should be called when the user presses `Button`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，此表单首先需要连接到GraphQL服务器，以接收身份验证所需的JWT令牌。`Login`屏幕的组件已经有一个表单，但是提交此表单尚未调用任何函数来对用户进行身份验证。因此，你需要使用`react-apollo`中的`Mutation`组件，并让该组件向GraphQL服务器发送包含正确变异的文档。需要添加到此组件的变异可以在`constants.js`文件中找到，称为`LOGIN_USER`。要提交表单，应该在用户按下`Button`时调用`Mutation`组件返回的`loginUser`函数：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Both `TextInput` components are controlled component, and use `useState` Hooks
    to control their values. Both the `userName` and `password` constants that are
    used by this mutation take two variables for authentication, which are also `userName` and `password`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`TextInput`组件都是受控组件，并使用`useState`钩子来控制它们的值。用于此变异的`userName`和`password`常量都使用两个变量进行身份验证，这两个变量也是`userName`和`password`：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Apart from the `loginUser` function, which sends the mutation in a document,
    the `Mutation` component will also return the `loading`, `error`, and `data` variables
    that are returned by the GraphQL server. The `loading` variable can be used to
    communicate to the user that the document was sent to the server, while the `data`
    and `error` variables are returned when the GraphQL server responds to this document:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`loginUser`函数之外，该函数发送了一个文档中的变化，`Mutation`组件还会返回由GraphQL服务器返回的`loading`、`error`和`data`变量。`loading`变量可用于向用户传达文档已发送到服务器，而当GraphQL服务器对此文档做出响应时，将返回`data`和`error`变量：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will change the text of the button at the bottom of the form to `Loading...` when
    the document is sent to the GraphQL server and no response has been returned yet.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档发送到GraphQL服务器并且尚未返回响应时，这将会改变表单底部按钮的文本为`Loading...`。
- en: 'To use the `error` variable to show an error message when the wrong credentials
    have been filled in, you won''t be destructuring the variable from the output
    of the `Mutation` component. Instead, the error variable will be retrieved from `Promise`
    that is returned by the `loginUser` function. For displaying the error, you''ll
    use the `graphQLErrors` method that is available from the `error` variable, which
    returns an array (since there could be multiple errors) and renders the error
    within an `Alert` component from React Native:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`error`变量在填写错误凭据时显示错误消息，您不会从`Mutation`组件的输出中解构该变量。相反，错误变量将从`loginUser`函数返回的`Promise`中检索。为了显示错误，您将使用`error`变量中可用的`graphQLErrors`方法，该方法返回一个数组（因为可能存在多个错误），并在React
    Native的`Alert`组件中呈现错误：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the right username and password combination are used, the data variable
    should be used to store the JWT token that will be returned by the GraphQL server.
    Just like the `error` variable that was retrieved from the `loginUser` function,
    the `data` variable can be retrieved from this `Promise` as well. This token is
    available on the `data` variable and should be stored somewhere safe, which can
    be done using the `AsyncStorage` library:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用正确的用户名和密码组合时，应使用`data`变量来存储由GraphQL服务器返回的JWT令牌。就像从`loginUser`函数中检索的`error`变量一样，`data`变量也可以从这个`Promise`中检索。这个令牌可用于`data`变量，并且应该被安全地存储，可以使用`AsyncStorage`库来实现：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After storing the token, the user should be redirected to the main application,
    which can be found at the `Main` route and represents the screens linked to `TabNavigator`.
    To redirect the user, you can use the `navigation` prop that is passed to the
    `Login` component by `SwitchNavigator`. Since storing something with `AsyncStorage` should
    be done asynchronously, the navigation function should be called from within the
    callback of `Promise` that is returned by `AsyncStorage`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储令牌后，用户应被重定向到主应用程序，该应用程序可以在`Main`路由中找到，并表示与`TabNavigator`相关联的屏幕。要重定向用户，您可以使用`SwitchNavigator`通过传递给`Login`组件的`navigation`属性。由于使用`AsyncStorage`存储东西应该是异步的，因此应该从`AsyncStorage`返回的`Promise`的回调中调用导航函数：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This, however, only completes a part of the authentication flow since the `Login`
    screen will always be displayed when the application first renders. That way,
    users always have to log in with their authentication details, even when their
    JWT token is stored in the persistent storage.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只完成了认证流程的一部分，因为当应用程序首次渲染时，`Login`屏幕将始终显示。这样，用户始终必须使用他们的认证详细信息登录，即使他们的JWT令牌存储在持久存储中。
- en: 'To check whether or not the user has logged in before, a third screen has to
    be added to `SwitchNavigator`. This screen will determine whether the user has
    a token stored in the persistent storage and if they do, the user will be redirected
    to the `Main` route immediately. If the user hasn''t logged in before, the user
    will be redirected to the `Login` screen you''ve just created:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查用户以前是否已登录，必须向`SwitchNavigator`中添加第三个屏幕。这个屏幕将确定用户是否在持久存储中存储了令牌，如果有，用户将立即重定向到`Main`路由。如果用户以前没有登录，则会重定向到你刚刚创建的`Login`屏幕：
- en: 'This intermediate screen that determines whether there is an authentication
    token stored in the persistent storage, that is the `AuthLoading` screen, should
    be added to `SwitchNavigator` in `App.js`. This screen should also become the
    initial route that is served by the navigator:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定是否在持久存储中存储了身份验证令牌的中间屏幕，即`AuthLoading`屏幕，应该在`App.js`中添加到`SwitchNavigator`中。这个屏幕也应该成为导航器提供的初始路由：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this `AuthLoading` screen, the authentication token should be retrieved
    from the persistent storage, and afterward, the navigation to either the `Login`
    or `Main` screen should be handled. This screen can be found in the `client/Screens/AuthLoading.js` file, where
    nothing but a simple interface has been added. The token can be retrieved using
    the `getItem` method from the `AsyncStorage` library and should be called from
    a `useEffect` Hook so that it''s retrieved when the `AuthLoading` screen is first
    loaded. From `callback`, and from `Promise` returned by `getItem`, the `navigate`
    function from the `navigation` prop is used for the actual navigation to either
    of these screens:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`AuthLoading`屏幕中，应该从持久存储中检索身份验证令牌，然后处理导航到`Login`或`Main`屏幕。这个屏幕可以在`client/Screens/AuthLoading.js`文件中找到，那里只添加了一个简单的界面。可以使用`AsyncStorage`库中的`getItem`方法来检索令牌，并且应该从`useEffect`
    Hook中调用，以便在首次加载`AuthLoading`屏幕时检索它。从`callback`和`Promise`返回的`getItem`中，使用`navigation`属性的`navigate`函数来实际导航到这些屏幕中的任何一个：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The final step in completing the authentication flow is adding the possibility
    for a user to log out of the application by deleting the token from the persistent
    storage. This is done in the `client/Screens/Settings.js` file. This renders the
    `Settings` screen that can be found in `TabNavigator`. The `Settings` screen has
    a green button, which you can set an `onPress` event on.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成身份验证流程的最后一步是通过从持久存储中删除令牌来为用户添加注销应用的可能性。这是在`client/Screens/Settings.js`文件中完成的。这会呈现`TabNavigator`中的`Settings`屏幕。`Settings`屏幕上有一个绿色按钮，你可以在上面设置`onPress`事件。
- en: 'The `removeItem` method from `AsyncStorage` can be used for deleting the token
    from the persistent storage and returns `Promise`. In the callback of this `Promise`,
    you can again handle the navigation to return to the `Login` screen as you don''t
    want an unauthenticated user in your application:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage`的`removeItem`方法可用于从持久存储中删除令牌，并返回`Promise`。在这个`Promise`的回调中，你可以再次处理导航，以返回到`Login`屏幕，因为你不希望未经身份验证的用户在你的应用中。'
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By adding the logout functionality, you''ve completed the authentication flow
    that uses JWT tokens returned by the GraphQL server. This can be requested by
    filling in a form on the `Login` screen. If the authentication is successful,
    the user will be redirected to the `Main` screen and, by using the Log out button
    on the `Settings` screen, the user can log out and will be directed back to the
    `Login` screen. The final authentication flow will now look something like this,
    depending on which operating system you''re running this application on. The following
    screenshots have taken taken from a device that''s running on iOS:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加注销功能，您已经完成了使用GraphQL服务器返回的JWT令牌的身份验证流程。这可以通过在“登录”屏幕上填写表单来请求。如果身份验证成功，用户将被重定向到“主”屏幕，并且通过“设置”屏幕上的“注销”按钮，用户可以注销并将被重定向回“登录”屏幕。最终的身份验证流程现在看起来可能是这样的，具体取决于您在哪个操作系统上运行此应用程序。以下屏幕截图是从运行iOS的设备上获取的：
- en: '![](assets/22c6656d-d2d5-4501-b80f-804de21ebd29.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/22c6656d-d2d5-4501-b80f-804de21ebd29.png)
- en: However, for the GraphQL server to know whether this user is authenticated,
    you need to send a validation token to it. In the next part of this section, you'll
    learn how to do this by using a **JSON Web Token** (**JWT**).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了GraphQL服务器知道这个用户是否经过身份验证，您需要向其发送一个验证令牌。在本节的下一部分，您将学习如何通过使用JSON Web Token（JWT）来实现这一点。
- en: Sending authentication details to the GraphQL server
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向GraphQL服务器发送身份验证详细信息
- en: 'The authentication details that are now stored in the persistent storage should
    also be added to the Apollo Client so that they''re sent to the GraphQL server
    with every document. This can be done by extending the setup of Apollo Client
    with the token information. since the token is a JWT, it should be prefixed with
    `Bearer`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存储在持久存储中的身份验证详细信息也应该添加到Apollo Client中，以便在每个文档中与GraphQL服务器一起发送。这可以通过扩展Apollo
    Client的设置与令牌信息来完成。由于令牌是JWT，因此应该以`Bearer`为前缀：
- en: 'You need to install an Apollo package to deal with adding values to `context`.
    The `setContext` method is available from the `apollo-link-context` package, which
    you can install from `npm`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要安装一个Apollo包来处理向“上下文”添加值。`setContext`方法来自`apollo-link-context`包，您可以从`npm`安装该包：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `apollo-link-context` package should be imported into the `client/App.js` file,
    where the Apollo client is created. You need to separate the construction of the `HttpLink` object
    for the client as this one needs to be combined with the created Context:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该将`apollo-link-context`包导入到`client/App.js`文件中，其中创建了Apollo客户端。您需要分开为客户端创建`HttpLink`对象的构造，因为这个对象需要与创建的上下文结合使用：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After this, you can use the `setContext()` method to extend the headers that
    are being sent to the GraphQL server so that you can also include the token that
    can be retrieved from the persistent storage. This method should be used asynchronously
    as getting an item from `AsyncStorage` is also asynchronous. The token that will
    be returned must be prefixed with `Bearer` as the GraphQL server expects the JWT
    token in that format:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以使用`setContext()`方法来扩展发送到GraphQL服务器的标头，以便还可以包括可以从持久存储中检索的令牌。由于从`AsyncStorage`获取项目也是异步的，因此应该异步使用此方法。将返回的令牌必须以`Bearer`为前缀，因为GraphQL服务器期望以该格式接收JWT令牌：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `httpLink` that is used for the `link` field when creating the Apollo Client
    should now be combined with `authLink` so that the token that is retrieved from
    `AsyncStorage` will be added to the headers when the request is sent to the GraphQL
    server:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Apollo Client时用于`link`字段的`httpLink`现在应该与`authLink`结合，以便从`AsyncStorage`检索到的令牌在发送请求到GraphQL服务器时被添加到标头中：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, any document is passed to the GraphQL server will be able to use the token
    that was retrieved by using the login form of your application—something that
    you'll need when a mutation is used to send a message in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何传递给GraphQL服务器的文档都可以使用通过应用程序登录表单检索到的令牌，这是在下一节中使用变异发送消息时所需的内容。
- en: Handling subscriptions in React Native with Apollo
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo在React Native中处理订阅
- en: Before you can proceed and send documents containing mutations to the GraphQL
    server, we need to set up Apollo so that we can handle subscriptions. For handling
    subscriptions, a WebSocket needs to be set up for your application, which enables
    a real-time two-way connection between the GraphQL server and your application.
    That way, you'll receive instant feedback when you, for example, send or receive
    a message using this mobile application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以继续并发送包含变异的文档到GraphQL服务器之前，我们需要设置Apollo以便处理订阅。为了处理订阅，需要为您的应用程序设置一个WebSocket，这样可以在GraphQL服务器和您的应用程序之间建立实时的双向连接。这样，当您使用这个移动应用程序发送或接收消息时，您将收到即时反馈。
- en: Setting up Apollo Client for GraphQL subscriptions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为GraphQL订阅设置Apollo客户端
- en: 'To use subscriptions in your React Native application, there are more packages
    you need to add to the project that, for example, make it possible to add the
    WebSocket. These packages are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的React Native应用程序中使用订阅，您需要添加更多的软件包到项目中，例如，使其可能添加WebSocket。这些软件包如下：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `apollo-link-ws` package helps you create a link to the GraphQL server running
    the subscription, like `apollo-link-http` does for queries and mutations. `subscriptions-transport-ws` is
    a package that is needed to run `apollo-link-ws`, while `apollo-utilities` is
    added to use a method that is available on those packages so that you can separate
    requests regarding subscriptions from requests for queries or mutations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`apollo-link-ws`软件包帮助您创建到运行订阅的GraphQL服务器的链接，就像`apollo-link-http`为查询和变异所做的那样。`subscriptions-transport-ws`是运行`apollo-link-ws`所需的软件包，而`apollo-utilities`被添加以使用这些软件包上可用的方法，以便您可以将有关订阅的请求与查询或变异的请求分开。'
- en: 'After installing these packages, you need to follow these steps to use subscriptions
    in your application:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些软件包后，您需要按照以下步骤在应用程序中使用订阅：
- en: 'You can add the creation of the link to the GraphQL server using `apollo-link-ws`.
    The URL to the GraphQL server should be prefixed with `ws://` instead of `http://` as
    it concerns a connection with a WebSocket. The URL to the GraphQL server running
    on your machine would look like `ws://192.168.1.107/graphql` instead of `http://192.168.1.107/graphql` and
    must be added to the `SOCKET_URL` constant:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`apollo-link-ws`来添加链接到GraphQL服务器的创建。GraphQL服务器的URL应该以`ws://`开头，而不是`http://`，因为它涉及与WebSocket的连接。在您的机器上运行的GraphQL服务器的URL看起来像`ws://192.168.1.107/graphql`，而不是`http://192.168.1.107/graphql`，必须添加到`SOCKET_URL`常量中：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the `split` and `getMainDefinition` methods, the distinction between
    different requests to the GraphQL server can be made by separating queries and
    mutations from subscriptions. That way, only documents containing subscriptions
    will be sent using the WebSocket, and queries and mutations will use the default
    flow:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`split`和`getMainDefinition`方法，可以通过将查询和变异与订阅分开来区分对GraphQL服务器的不同请求。这样，只有包含订阅的文档才会使用WebSocket发送，而查询和变异将使用默认流程：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The setup for Apollo now also supports subscriptions, which you'll add in the
    next part of this section where the `Conversations` screen will be filled with
    real-time data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Apollo的设置也支持订阅，您将在本节的下一部分中添加，其中`Conversations`屏幕将填充实时数据。
- en: Adding subscriptions to React Native
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将订阅添加到React Native
- en: The local GraphQL server that is running on your machine supports both a query
    and a subscription so that you can return a conversation from a specific user.
    Where the query will return the full conversation, the subscription will return
    any new message that may have been sent or received in that conversation. At the
    moment, the `Conversation` screen is only sending a document with the query that
    will return the conversation with a user if you tap on any of the conversations
    displayed on the `Conversations` screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地GraphQL服务器上运行的服务器支持查询和订阅，以便您可以从特定用户返回对话。查询将返回完整的对话，而订阅将返回可能已发送或接收到的对话中的任何新消息。目前，“Conversation”屏幕只会发送一个带有查询的文档，如果您点击“Conversations”屏幕上显示的任何对话，它将返回与用户的对话。
- en: 'Subscriptions can be added to your application in multiple ways; using the
    `Subscription` component from `react-apollo` is the most simple one. But since
    you''re already retrieving the conversation using the `Query` component in `client/Screens/Conversation.js`,
    the `Query` component can be extended to also support subscriptions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅可以以多种方式添加到您的应用程序中；使用`react-apollo`中的`Subscription`组件是最简单的方法。但由于您已经使用`client/Screens/Conversation.js`中的`Query`组件检索对话，因此可以扩展`Query`组件以支持订阅：
- en: 'The first step in adding the subscriptions to the `Conversation` screen is
    by splitting the screen into multiple components. You can do this by creating
    a new component called `ConversationBody` in the `client/Components/Conversation` directory.
    This file should be called `ConversationBody.js` and contain the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向“Conversation”屏幕添加订阅的第一步是将屏幕拆分为多个组件。您可以通过在`client/Components/Conversation`目录中创建一个名为`ConversationBody`的新组件来实现这一点。该文件应该被命名为`ConversationBody.js`，并包含以下代码：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After creating this new component, it should be imported into the `Conversation`
    screen in the `client/Screens/Conversation.js` file, where it can replace the
    `ContainerBody` component that is already present in that file. This also means
    that some imports become obsolete and that the `ContainerBody` styled component
    can be deleted as well:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了这个新组件之后，应该将其导入到`client/Screens/Conversation.js`文件中的`Conversation`屏幕中，以取代该文件中已经存在的`ContainerBody`组件。这也意味着一些导入变得过时，`ContainerBody`样式组件也可以被删除：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, the logic for retrieving the subscription can be added to the `Query`
    component, by getting the `subscribeToMore` method from it. This method should
    be passed to the `ConversationBody` component, where it will be called and thereby
    retrieve any new messages that are sent or received in the conversation:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，可以将检索订阅的逻辑添加到“Query”组件中，通过从中获取“subscribeToMore”方法。这个方法应该传递给“ConversationBody”组件，在那里它将被调用，从而检索发送或接收到的任何新消息：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `ConversationBody` component, the `subscribeToMore` method can now be
    used to retrieve any new messages that are added to the conversation, by using
    a subscription. The subscription to use is called `MESSAGES_ADDED` and can be
    found in the `client/constants.js` file. It takes `userName` as a variable:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“ConversationBody”组件中，现在可以使用“subscribeToMore”方法通过订阅来检索添加到对话中的任何新消息。要使用的订阅称为“MESSAGES_ADDED”，可以在`client/constants.js`文件中找到。它以`userName`作为变量：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After importing the subscription and destructuring the `subscribeToMore` method
    from the props, the logic for retrieving the subscription can be added. Calling `subscribeToMore`
    should be done from a `useEffect` Hook and only when the `ConversationBody` component
    first mounts. Any newly added messages will cause the `Query` component to rerender,
    which makes the `ConversationBody` component rerender as well, so it isn''t necessary to
    check for any updates in the `useEffect` Hook:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入订阅并从props中解构`subscribeToMore`方法之后，可以添加检索订阅的逻辑。应该从`useEffect` Hook中调用`subscribeToMore`，并且仅当`ConversationBody`组件首次挂载时。任何新添加的消息都将导致`Query`组件重新渲染，这将使`ConversationBody`组件重新渲染，因此在`useEffect`
    Hook中不需要检查任何更新：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `subscribeToMore` method will now check for any new messages by using the `MESSAGES_ADDED` subscription,
    and the results from that subscription will be added to the `Query` component
    on an object called `previous`. The local GraphQL server will return a new message
    every few seconds, so you can see that the subscription is working by opening
    a conversation and waiting for new messages to appear in that conversation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeToMore`方法现在将使用`MESSAGES_ADDED`订阅来检查任何新消息，并将该订阅的结果添加到名为`previous`的对象上的`Query`组件中。本地GraphQL服务器将每隔几秒钟返回一条新消息，因此您可以通过打开对话并等待新消息出现在该对话中来查看订阅是否起作用。'
- en: Besides queries, you also want to be able to send real-time subscriptions as
    well. This will be addressed in the final part of this section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询，您还希望能够发送实时订阅。这将在本节的最后部分进行讨论。
- en: Using mutations with subscriptions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用订阅与突变
- en: Apart from using a subscription to receive messages in a conversation, they
    can also be used to display the messages you send yourself. Previously, you used
    the `refetchQueries` prop on a `Mutation` component to resend documents with any
    queries that would have been affected by the mutation you've executed. By using
    subscriptions, you no longer have to refetch, for example, the conversation query,
    as the subscription will get the new message you've just sent and add it to the
    query.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用订阅来接收对话中的消息，它们还可以用于显示您自己发送的消息。以前，您可以在`Mutation`组件上使用`refetchQueries`属性来重新发送受到您执行的突变影响的任何查询的文档。通过使用订阅，您不再需要重新获取，例如，对话查询，因为订阅将获取您刚刚发送的新消息并将其添加到查询中。
- en: In the previous section, you used a `Query` component from `react-apollo` to
    send a document to the GraphQL server, while in this section, the new React Apollo
    Hooks will be used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您使用了来自`react-apollo`的`Query`组件向GraphQL服务器发送文档，而在本节中，将使用新的React Apollo
    Hooks。
- en: The React Apollo Hooks can be used from the `react-apollo` package, but if you
    only want to use the Hooks, you can install `@apollo/react-hooks` instead by executing `npm
    install @apollo/react-hooks`. The GraphQL components such as `Query` or `Mutation`
    are available in both the `react-apollo` and `@apollo/react-components` packages.
    Using these packages will decrease the size of your bundle as you're only importing
    the features you need.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: React Apollo Hooks可以从`react-apollo`包中使用，但如果您只想使用Hooks，可以通过执行`npm install @apollo/react-hooks`来安装`@apollo/react-hooks`。GraphQL组件，如`Query`或`Mutation`，在`react-apollo`和`@apollo/react-components`包中都可用。使用这些包将减少捆绑包的大小，因为您只导入所需的功能。
- en: 'The Hooks from this package must be used in the `ConversationActions` component.
    This is used in the `Conversation` screen component, which will consist of the
    input field to type a message and a button to send the message. When you press
    this button, nothing will happen as the button isn''t connected to a mutation.
    Let''s connect this button and see how the subscription will also display the
    message you''ve sent:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包中的Hooks必须在`ConversationActions`组件中使用。这在`Conversation`屏幕组件中使用，该组件将包括输入消息的输入字段和发送消息的按钮。当您按下此按钮时，什么也不会发生，因为按钮未连接到变异。让我们连接这个按钮，看看订阅如何显示您发送的消息：
- en: 'The `useMutation` Hook should be imported into the `client/Components/Conversation/ConversationActions.js` file,
    which will be used to send the message from the input field to the GraphQL server.
    The mutation that will be included in the document that you sent must also be
    imported and is called `SEND_MESSAGE`; this can be found in the `client/constants.js` file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useMutation` Hook应该被导入到`client/Components/Conversation/ConversationActions.js`文件中，该文件将用于将输入字段中的消息发送到GraphQL服务器。还必须导入将包含在您发送的文档中的变异，名为`SEND_MESSAGE`；这可以在`client/constants.js`文件中找到：'
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This `useMutation` Hook can now be used to wrap the `TextInput` and `Button`
    components, and the `sendMessage` prop from the Hook can be used to send a document
    with the message to the GraphQL server. The value for `TextInput` is controlled
    by the `setMessage` function that was created by the `useState` Hook, and this
    function can be used to clear `TextInput` after the mutation is sent:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`useMutation` Hook现在可以用来包裹`TextInput`和`Button`组件，来自Hook的`sendMessage`属性可以用来向GraphQL服务器发送带有消息的文档。`TextInput`的值由`useState`
    Hook创建的`setMessage`函数控制，这个函数可以在发送变异后用来清除`TextInput`：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sending a message by typing a value into the text field and pressing the send
    button afterward will now update the conversation with the message you've just
    sent. But you might notice that this component is getting lost behind the keyboard,
    depending on the size of the screen of your mobile device. This behavior can easily
    be avoided by using the `KeyboardAvoidingView` component from `react-native`.
    This component will make sure that the input field is being displayed outside
    the area of the keyboard.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在文本字段中输入值并在之后按下发送按钮来发送消息，现在会更新对话，显示您刚刚发送的消息。但是，您可能会注意到，这个组件会在移动设备屏幕的大小上被键盘遮挡。通过使用`react-native`中的`KeyboardAvoidingView`组件，可以轻松避免这种行为。这个组件将确保输入字段显示在键盘区域之外。
- en: 'The `KeyboardAvoidingView` component can be imported from `react-native` and
    used to replace the `View` component that is currently being styled into the `ConversationsActionsWrapper`
    component:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`KeyboardAvoidingView`组件可以从`react-native`中导入，并用于替换当前正在样式化为`ConversationsActionsWrapper`组件的`View`组件：'
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Depending on which platform your mobile device is running on, the `KeyboardAvoidingView`
    component still might not display the input field outside the keyboard area. However,
    the `KeyboardAvoidingView` component can be customized using the `keyboardVerticalOffset`
    and `behavior` props. For iOS and Android, the values for these props should be
    different; in general, Android needs a smaller offset than iOS. In this situation,
    `keyboardVerticalOffset` must be set to `190` for iOS and to `140` for Android,
    and the `behavior` of the component for both platforms must be set to `padding`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的移动设备运行的平台，`KeyboardAvoidingView`组件可能仍然无法在键盘区域之外显示输入字段。但是，`KeyboardAvoidingView`组件可以使用`keyboardVerticalOffset`和`behavior`属性进行自定义。对于iOS和Android，这些属性的值应该不同；一般来说，Android需要比iOS更小的偏移量。在这种情况下，`keyboardVerticalOffset`必须设置为`190`，`behavior`必须设置为`padding`：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`KeyboardAvoidingView` might not work as expected on the Android Studio emulator
    or on devices running Android, as there are a lot of different possible screen
    sizes for devices that can run the Android operating system.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardAvoidingView`在Android Studio模拟器或运行Android的设备上可能无法按预期工作，因为可以运行Android操作系统的设备有许多不同的可能屏幕尺寸。'
- en: When you press the input field, the keyboard will no longer be hidden behind
    the keyboard and you should be able to type and send a message that will send
    a document with a mutation to the GraphQL server. Your message will also appear
    in the conversation that was being displayed previously.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按下输入字段时，键盘将不再隐藏在键盘后面，您应该能够输入并发送一条消息，该消息将发送一个包含对GraphQL服务器的突变的文档。您的消息还将出现在先前显示的对话中。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you built a mobile messaging application that can be used to
    send and receive messages from a GraphQL server. The messages are received in
    real time as GraphQL subscriptions were used to receive the messages through a
    WebSocket. Also, a mobile authentication flow was added, meaning users should
    be logged in to send and receive messages. For this, `AsyncStorage` was used to
    store the JWT token returned by the GraphQL server in persistent storage.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您构建了一个移动消息应用程序，可以用于与GraphQL服务器发送和接收消息。通过使用GraphQL订阅，消息可以实时接收，通过WebSocket接收消息。此外，还添加了移动身份验证流程，这意味着用户必须登录才能发送和接收消息。为此，使用`AsyncStorage`将GraphQL服务器返回的JWT令牌存储在持久存储中。
- en: The project you've built in this chapter was pretty challenging, but the project
    you'll create in the next chapter will be even more advanced. So far, you've handled
    most of the core features for a React Native mobile application, but there's more
    to come. The next chapter will explore how to build a full stack application with
    React Native and GraphQL as you'll be adding notifications and more to a social
    media application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中构建的项目非常具有挑战性，但您将在下一章中创建的项目将更加先进。到目前为止，您已经处理了大多数React Native移动应用程序的核心功能，但还有更多内容。下一章将探讨如何使用React
    Native和GraphQL构建全栈应用程序，您将向社交媒体应用程序添加通知等功能。
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about what was covered in this chapter, check out the
    following resources:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涵盖的更多信息，请查看以下资源：
- en: WebSockets: [https://developer.mozilla.org/en-US/docs/Web/API/WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'WebSockets: [https://developer.mozilla.org/en-US/docs/Web/API/WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)'
- en: Apollo React Hooks: [https://www.apollographql.com/docs/react/api/react-hooks/](https://www.apollographql.com/docs/react/api/react-hooks/)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Apollo React Hooks: [https://www.apollographql.com/docs/react/api/react-hooks/](https://www.apollographql.com/docs/react/api/react-hooks/)'
