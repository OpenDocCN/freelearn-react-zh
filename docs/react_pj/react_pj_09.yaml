- en: Build an Animated Game Using React Native and Expo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和Expo构建动画游戏
- en: Most of the projects that you've created in this book focused on displaying
    data and making it possible to navigate between pages. In the previous chapter,
    you explored some of the differences between creating a web and a mobile application.
    One other difference when building a mobile application is that your users expect
    animations and gestures since they make using the application easy and familiar.
    This is something that you'll focus on in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中创建的大多数项目都侧重于显示数据并使其可以在页面之间进行导航。在上一章中，您探索了创建Web和移动应用程序之间的一些差异。构建移动应用程序时的另一个区别是，用户期望动画和手势，因为它们使应用程序的使用变得简单和熟悉。这是本章的重点。
- en: In this chapter, you'll add animations and gestures to a React Native application
    using the Animated API from React Native, a package called Lottie, and Expo's
    `GestureHandler`. Together, they make it possible for us to create applications
    that make the best use of a mobile's interaction methods, which is perfect for
    a game such as *Tic-Tac-Toe*. Also, the application will show a leaderboard with
    the high scores for this game next to the game interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用React Native的Animated API、一个名为Lottie的包以及Expo的`GestureHandler`为React
    Native应用程序添加动画和手势。它们共同使我们能够创建最充分利用移动交互方法的应用程序，这对于像*Tic-Tac-Toe*这样的游戏非常理想。此外，该应用程序将在游戏界面旁边显示此游戏的最高分排行榜。
- en: 'To create this game, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个游戏时，将涵盖以下主题：
- en: Using the React Native Animated API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Native Animated API
- en: Advanced animations with Lottie
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lottie进行高级动画
- en: Handling native gestures with Expo
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Expo处理原生手势
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will be creating an animated *Tic-Tac-Toe* game build with
    React Native and Expo, which uses the Animated API to add basic animations, Lottie
    for advanced animations, and Gesture Handler from Expo to handle native gestures.
    The starting point will be creating an application with the Expo CLI that has
    basic routing implemented in it, so that our users can switch between the game
    interface and an overview of the high scores for this game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用React Native和Expo创建一个带有基本动画的*Tic-Tac-Toe*游戏，使用Animated API添加基本动画，使用Lottie添加高级动画，并使用Expo的Gesture
    Handler处理原生手势。起点将是创建一个具有基本路由实现的Expo CLI应用程序，以便我们的用户可以在游戏界面和此游戏的最高分概述之间切换。
- en: The build time is 1.5 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为1.5小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch9-initial](https://github.com/PacktPublishing/React-Projects/tree/ch9-initial)[. The
    complete source code can also be found on GitHub: ](https://github.com/PacktPublishing/React-Projects/tree/ch10-initial)[https://github.com/PacktPublishing/React-Projects/tree/ch9.](https://github.com/PacktPublishing/React-Projects/tree/ch9)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中创建的项目是基于GitHub上的初始版本构建的：[https://github.com/PacktPublishing/React-Projects/tree/ch9-initial](https://github.com/PacktPublishing/React-Projects/tree/ch9-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch10-initial](https://github.com/PacktPublishing/React-Projects/tree/ch9)。
- en: 'You need to have the application Expo Client installed on a mobile iOS or Android
    device to run the project on a physical device. Alternatively, you can install
    either Xcode or Android Studio on your computer to run the application on a virtual
    device:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在移动iOS或Android设备上安装Expo Client应用程序，以在物理设备上运行该项目。或者，您可以在计算机上安装Xcode或Android
    Studio，以在虚拟设备上运行该应用程序：
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于iOS**：有关如何设置本地机器以运行iOS模拟器的信息，请在此处找到：[https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/)。'
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/).
    There''s a known issue when running the emulator, which can be prevented by ensuring
    that the following lines are present in your `~/.bash_profile` or `~/.bash_rc`  file:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Android**：有关如何设置本地机器以从Android Studio运行模拟器的信息，请在此处找到：[https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/)。运行模拟器时存在已知问题，可以通过确保以下行存在于您的`~/.bash_profile`或`~/.bash_rc`文件中来预防：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value for `ANDROID_SDK_LOCATION` is the path to the Android SDK on your
    local machine and can be found by opening Android Studio and going to **Preferences** | **Appearance
    & Behavior** *|* **System Settings** | **Android SDK**. The path is listed in
    the box that states the Android SDK locationand looks like this: `/Users/myuser/Library/Android/sdk`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANDROID_SDK_LOCATION`的值是本地机器上Android SDK的路径，可以通过打开Android Studio并转到**首选项**|**外观和行为**|**系统设置**|**Android
    SDK**来找到。路径在声明Android SDK位置的框中列出，看起来像这样：`/Users/myuser/Library/Android/sdk`。'
- en: This application was created using **Expo SDK version 33.0.0,** and so, you
    need to ensure that the version of Expo you're using on your local machine is
    similar. As React Native and Expo are frequently updated, make sure that you're
    working with this version so that the patterns described in this chapter behave
    as expected. In case your application doesn’t start or if you encounter errors,
    refer to the Expo documentation to learn more about updating the Expo SDK.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序是使用**Expo SDK版本33.0.0**创建的，因此，您需要确保您在本地机器上使用的Expo版本是相似的。由于React Native和Expo经常更新，请确保您使用此版本，以便本章描述的模式表现如预期般。如果您的应用程序无法启动或遇到错误，请参考Expo文档，了解有关更新Expo
    SDK的更多信息。
- en: Checking out the initial project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查初始项目
- en: 'The application that you''ll be working on in this chapter has already been
    built for you, but we will need to complete it by adding features such as animations
    and transitions. After downloading or cloning the project, you''ll need to move
    into the root directory of the project, where you can run the following command
    to install the dependencies and start the application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将要处理的应用程序已经为您构建，但我们需要通过添加诸如动画和过渡之类的功能来完成它。下载或克隆项目后，您需要进入项目的根目录，在那里您可以运行以下命令来安装依赖项并启动应用程序：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will start Expo and give you the ability to start your project from the
    Terminal or from your browser. In the Terminal, you can either use the QR Code
    to open the application on your mobile device or select to open the application
    in a simulator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Expo并使您能够从终端或浏览器启动项目。在终端中，您可以使用QR码在移动设备上打开应用程序，或选择在模拟器中打开应用程序。
- en: 'No matter whether you''ve opened the application on a virtual or physical device,
    at this point, the application should look something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在虚拟设备还是物理设备上打开应用程序，在这一点上，应用程序应该看起来像这样：
- en: '![](assets/84ec8568-59b9-490c-85a6-8fded3613a7a.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/84ec8568-59b9-490c-85a6-8fded3613a7a.jpg)'
- en: 'The application consists of three screens: `Start`, `Game`, and `LeaderBoard`.
    The first screen is `Start`, where the game can be started by clicking the green
    button. This will lead to the `Game` screen, which is set up as a modal. The `Start`
    screen uses tab navigation, from which you can also visit the `LeaderBoard` screen,
    which is where the scores of the players will be displayed.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序由三个屏幕组成：`Start`，`Game`和`LeaderBoard`。第一个屏幕是`Start`，在那里可以通过点击绿色按钮开始游戏。这将导致`Game`屏幕，该屏幕设置为模态。`Start`屏幕使用选项卡导航，您还可以访问`LeaderBoard`屏幕，该屏幕将显示玩家的分数。
- en: 'The project structure for this React Native application is as follows. This
    structure is similar to the projects we''ve created already in this book:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此React Native应用程序的项目结构如下。此结构类似于本书中已创建的项目：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `assets` directory, you''ll find the two images: one that will be used
    as the application''s icon on the Home screen once you''ve installed this application
    on your mobile device, and one that will serve as the splash screen that is displayed
    when you start the application. A Lottie animation file has also been placed here,
    which you''ll use later on in this chapter. The configurations for your application,
    for example, the App Store, are placed in `app.json`, while `babel.config.js` holds
    specific Babel configurations.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`assets`目录中，您将找到两个图像：一个将用作应用程序的图标，一旦您在移动设备上安装了该应用程序，它将显示在主屏幕上，另一个将用作启动应用程序时显示的启动画面。还在这里放置了一个Lottie动画文件，您将在本章后面使用。应用程序的配置，例如App
    Store，放在`app.json`中，而`babel.config.js`保存特定的Babel配置。
- en: The `App.js` file is the actual entry point of your application, where the `AppContainer.js` file
    is being imported and returned within a Context Provider that was created in the
    `context/AppContext.js` file. In `AppContainer`, all the routes for this application
    are defined and `AppContext` will contain information that should be available
    in the entire application. In the `utils` directory, you can find the logic for
    the game, that is, the functions that will fill the slots of the *Tic-Tac-Toe*
    board and determine which player won the game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`文件是您的应用程序的实际入口点，其中导入并返回`AppContainer.js`文件，该文件在`context/AppContext.js`文件中创建的上下文提供程序中。在`AppContainer`中，定义了此应用程序的所有路由，而`AppContext`将包含应该在整个应用程序中可用的信息。在`utils`目录中，您可以找到游戏的逻辑，即填充*Tic-Tac-Toe*棋盘的函数以及确定哪个玩家赢得了比赛。'
- en: 'All the components for this game are located in the `Screens` and `Components` directories,
    where the former holds the components that are rendered by the `Start`, `Game`,
    and `LeaderBoard` routes. The child components for these screens can be found
    in the `Components` directory, which has the following structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此游戏的所有组件都位于`Screens`和`Components`目录中，前者包含由`Start`，`Game`和`LeaderBoard`路由呈现的组件。这些屏幕的子组件可以在`Components`目录中找到，该目录具有以下结构：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The most important components in the preceding structure are `Board`, `Slot`,
    and `Filled`, since they construct most of the game. `Board` is rendered by the
    `Game` screen and holds some logic for the game, while `Slot` and `Filled` are
    components that are rendered on this board. The `Actions` component returns two `Button`
    components so that we can either navigate away from the `Game` screen or restart
    the game. `Player` displays the name of the player whose turn it is, or the player
    that has won the game.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面结构中最重要的组件是`Board`，`Slot`和`Filled`，因为它们构成了大部分游戏。`Board`由`Game`屏幕呈现，并包含一些游戏逻辑，而`Slot`和`Filled`是在此棋盘上呈现的组件。`Actions`组件返回两个`Button`组件，以便我们可以从`Game`屏幕导航离开或重新开始游戏。`Player`显示了轮到哪个玩家或赢得比赛的玩家的名称。
- en: Creating an animated Tic-Tac-Toe game application with React Native and Expo
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Native 和 Expo 创建动画的井字棋游戏应用程序
- en: Mobile games often have flashy animations that make the user want to keep playing
    and make the game more interactive. The *Tic-Tac-Toe* game that is already functioning
    uses no animations so far and just has some transitions that have been built in
    with React Navigation. In this section, you'll be adding animations and gestures
    to the application, which will improve the game interface and make the user feel
    more comfortable while playing the game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 手机游戏通常具有引人注目的动画，使用户想要继续玩游戏并使游戏更具互动性。已经运行的 *Tic-Tac-Toe* 游戏到目前为止没有使用任何动画，只是使用了内置的一些过渡效果，这些过渡效果是使用
    React Navigation 构建的。在本节中，您将向应用程序添加动画和手势，这将改善游戏界面，并使用户在玩游戏时感到更舒适。
- en: Using the React Native Animated API
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Native Animated API
- en: There are multiple ways to use animations in React Native and one of those is
    to use the Animated API, which can be found in the core of React Native. With
    the Animated API, you can create animations for `View`, `Text`, `Image`, and `ScrollView`
    components from `react-native` by default. Alternatively, you can use the `createAnimatedComponent` method
    to create your own.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中使用动画的多种方法之一是使用 Animated API，该 API 可在 React Native 的核心中找到。使用
    Animated API，您可以默认为 `react-native` 中的 `View`、`Text`、`Image` 和 `ScrollView` 组件创建动画。或者，您可以使用
    `createAnimatedComponent` 方法创建自己的组件。
- en: Creating a basic animation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本动画
- en: 'One of the simplest animations you can add is fading an element in or out by
    changing the value for the opacity of that element. In the *Tic-Tac-Toe* game
    you created previously, the slots were filled with either a green or blue color,
    depending on which player filled that slot. These colors already show a small
    transition since you''re using the `TouchableOpacity` element to create the slot.
    However, it''s possible to add a custom transition to this by using the Animated
    API. To add an animation, the following code blocks must be changed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加的最简单的动画之一是通过更改元素的不透明度来使元素淡入或淡出。在您之前创建的 *Tic-Tac-Toe* 游戏中，插槽填充了绿色或蓝色，具体取决于哪个玩家填充了该插槽。由于您使用
    `TouchableOpacity` 元素创建插槽，这些颜色已经显示了一个小的过渡效果。但是，可以通过使用 Animated API 为其添加自定义过渡效果。要添加动画，必须更改以下代码块：
- en: 'Start by creating a new file in the `src/Components/Slot` directory and calling
    it `Filled.js`. This file will contain the following code, which will be used
    to construct the `Filled` component. Inside this file, add the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `src/Components/Slot` 目录中创建一个新文件，并将其命名为 `Filled.js`。该文件将包含以下代码，用于构建 `Filled`
    组件。在此文件中，添加以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This component displays a `View` element and is styled using a styling object
    that's using the JSS syntax, which is the default for React Native. This element
    can be used to fill in another element since its position is absolute with 100%
    width and 100% height. It also takes the `filled` prop so that we can set the
    `backgroundColor` and determine whether the component is displayed or not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件显示一个 `View` 元素，并使用使用 JSS 语法的样式对象进行样式设置，这是 React Native 的默认语法。由于其位置是绝对的，宽度和高度均为
    100%，因此该元素可以用于填充另一个元素。它还接受 `filled` 属性，以便我们可以设置 `backgroundColor` 并确定组件是否显示。
- en: 'You can import this component into the `Slot` component and display it once
    the slot has been filled by any of the players. Instead of setting the background
    color for the `SlotWrapper` component, you can pass the color that belongs to
    player one or two to the `Filled` component:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将此组件导入到 `Slot` 组件中，并在任何玩家填充插槽后显示它。而不是为 `SlotWrapper` 组件设置背景颜色，您可以将属于玩家一或玩家二的颜色传递给
    `Filled` 组件：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, whenever you click on a slot, nothing visible will change since you''ll
    need to change the clickable element from a `TouchableOpacity` element to a `TouchableWithoutFeedback` element
    first. That way, the default transition with the opacity will be gone, so you
    can replace this with your own. The `TouchableWithoutFeedback` element can be
    imported from `react-native` and should be placed around a `View` element, which
    will hold the default styling for the slot:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每当您单击插槽时，由于您需要先将可点击元素从“TouchableOpacity”元素更改为“TouchableWithoutFeedback”元素，因此不会发生任何可见变化。这样，默认的带不透明度的过渡就会消失，因此您可以用自己的过渡替换它。可以从“react-native”导入“TouchableWithoutFeedback”元素，并将其放置在一个“View”元素周围，该元素将保存插槽的默认样式：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, the slot that you've just pressed on will be immediately filled in with
    the color you've specified in the `backgroundColor` field for the `Filled` component,
    without any transition whatsoever.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您刚刚按下的插槽将立即填充为您在“Filled”组件的“backgroundColor”字段中指定的颜色，而无需任何过渡。
- en: 'To recreate this transition, you can use the Animated API, which you''ll use
    to change the opacity of the `Filled` component from the moment it''s rendered
    by a slot. Therefore, you need to import `Animated` from `react-native` in `src/Components/Slot/Filled.js`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新创建此过渡，可以使用Animated API，您将使用它来从插槽渲染时更改“Filled”组件的不透明度。因此，您需要在“src/Components/Slot/Filled.js”中从“react-native”导入“Animated”：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A new instance of the Animated API starts by specifying a value that should
    be changed during the animation that we created with the Animated API. This value
    should be changeable by the Animated API in your entire component, so you can
    add this value to the top of the component. This value should be created with
    a `useState` Hook since you want this value to be changeable later on:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Animated API的新实例是通过指定应在使用Animated API创建的动画期间更改的值来开始的。此值应该可以由整个组件的Animated
    API更改，因此您可以将此值添加到组件的顶部。由于您希望稍后可以更改此值，因此应使用“useState” Hook创建此值：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This value can now be changed by the Animated API using any of the three animations
    types that are built-in. These are `decay`, `spring`, and `timing`, where you''ll
    be using the `timing` method from the Animated API to change the animated value
    within a specified time frame. The Animated API can be triggered from any function
    that is, for example, linked to an `onPress` event or from a life cycle method.
    Since the `Filled` component should only be displayed when the slot is filled,
    you can use a life cycle method that is triggered when the `filled` prop component
    is changed, that is, a `useEffect` Hook with the `filled` prop as a dependency.
    The styling rule for the display can be removed since the component will have
    an `opacity` of `0` when the `filled` prop is `false`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，可以使用内置的三种动画类型之一（即“decay”、“spring”和“timing”）通过Animated API更改此值，其中您将使用Animated
    API的“timing”方法在指定的时间范围内更改动画值。可以从任何函数触发Animated API，例如与“onPress”事件链接或从生命周期方法触发。由于“Filled”组件应仅在插槽填充时显示，因此可以使用在“filled”属性组件更改时触发的生命周期方法，即具有“filled”属性作为依赖项的“useEffect”
    Hook。可以删除显示的样式规则，因为当“filled”属性为“false”时，组件的“opacity”将为“0”：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `timing` method takes the `opacityValue` that you've specified at the top
    of your component and an object with the configuration for the Animated API. One
    of the fields is `toValue`, which will become the value for `opacityValue` when
    the animation has ended. The other field is for the field's duration, which specifies
    how long the animation should last.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “timing”方法使用您在组件顶部指定的“opacityValue”和包含Animated API配置的对象。其中一个字段是“toValue”，当动画结束时，它将成为“opacityValue”的值。另一个字段是字段的持续时间，它指定动画应持续多长时间。
- en: The other built-in animation types next to `timing` are `decay` and `spring`.
    Where the `timing` method changes gradually over time, the `decay` type has animations
    that change fast in the beginning and gradually slow down until the end of the
    animation. With `spring`, you can create animations that move a little outside
    of its edges at the end of the animations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`timing`旁边的其他内置动画类型是`decay`和`spring`。`timing`方法随着时间逐渐改变，`decay`类型的动画在开始时变化很快，然后逐渐减慢直到动画结束。使用`spring`，您可以创建动画，使其在动画结束时稍微超出其边缘。'
- en: 'Finally, you only need to change the `View` element into an `Animated.View`
    element and add the `opacity` field and the `opacityValue` value to the `style`
    object:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您只需要将`View`元素更改为`Animated.View`元素，并将`opacity`字段和`opacityValue`值添加到`style`对象中：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when you press any of the slots, the `Filled` component will fade in,
    since the opacity value transitions for 500 ms. This will make a filled slot look
    as follows for both players when you run the application in either the iOS simulator
    or a device that runs on iOS. On Android, the application should look similar,
    since no platform-specific styling has been added:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您按下任何一个插槽时，`Filled`组件将淡入，因为不透明度值在500毫秒内过渡。当您在iOS模拟器或运行iOS的设备上运行应用程序时，这将使填充的插槽看起来如下。在Android上，应用程序应该看起来类似，因为没有添加特定于平台的样式：
- en: '![](assets/2db00402-f380-40e3-acbc-389e11cac37f.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2db00402-f380-40e3-acbc-389e11cac37f.png)'
- en: 'Something else you can do to make the animation appear smoother is add an `easing`
    field to the `Animated` object. The value for this field comes from the `Easing`
    module, which can be imported from `react-native`. The `Easing` module has three
    standard functions: `linear`, `quad`, and `cubic` Here, the `linear` function
    can be used for smoother timing animations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使动画看起来更加流畅，您还可以向`Animated`对象添加一个`easing`字段。这个字段的值来自`Easing`模块，可以从`react-native`中导入。`Easing`模块有三个标准函数：`linear`，`quad`和`cubic`。在这里，`linear`函数可以用于更平滑的时间动画：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this last change, the animation is complete and the game interface already
    feels smoother since the slots are being filled using your own custom animation.
    In the next part of this section, we will combine some of these animations to
    make the user experience for this game even more advanced.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最后这个改变，动画已经完成，游戏界面已经感觉更加流畅，因为插槽正在使用您自己的自定义动画进行填充。在本节的下一部分中，我们将结合其中一些动画，使这个游戏的用户体验更加先进。
- en: Combining animations with the Animated API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Animated API结合动画
- en: Having the transition by changing the opacity of the `Filled` component is already
    an improvement to the game interface. But there are more animations we can create
    to make the game's interaction even more appealing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变`Filled`组件的不透明度来进行过渡已经改善了游戏界面。但是我们可以创建更多的动画来使游戏的交互更具吸引力。
- en: 'One of the things we can do is add a fade-in animation to the size of the `Filled` component.
    To make this animation work well with the fading in animation we''ve just created,
    we can use the `parallel` method from the Animated API. This method will start
    the animations that are specified within the same moment. To create this effect,
    we need to make the following changes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的一件事是为`Filled`组件的大小添加淡入动画。为了使这个动画与我们刚刚创建的淡入动画配合得很好，我们可以使用Animated API中的`parallel`方法。这个方法将在同一时刻开始指定的动画。为了创建这种效果，我们需要做出以下改变：
- en: 'For this second animation, you want the `Filled` component to not only have
    a color that fades in, but also a size that is fading in. To set an initial value
    for the opacity, you have to set an initial value for the size of this component:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这第二个动画，您希望`Filled`组件不仅具有淡入的颜色，还具有淡入的大小。为了为不透明度设置初始值，您必须为该组件的大小设置初始值：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Animated.timing` method that you created in the `useEffect` Hook needs
    to be wrapped inside an `Animated.parallel` function. That way, you can add another
    animation that changes the size of the `Filled` component later on. The `Animated.parallel` function
    takes an array of the `Animated` method as a parameter and must be added like
    this:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在`useEffect` Hook中创建的`Animated.timing`方法需要包装在`Animated.parallel`函数中。这样，您可以在以后添加另一个改变`Filled`组件大小的动画。`Animated.parallel`函数将`Animated`方法的数组作为参数添加，必须像这样添加：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next to the `parallel` function, three other functions help you with animation
    composition. These functions are `delay`, `sequence`, and `stagger`, and can also
    be used in combination with each other. The `delay` function starts any animation
    after a predefined delay, the `sequence` function starts animations in the order
    you've specified and waits until an animation is resolved before starting another
    one, and the `stagger` function can start animations both in order and parallel
    with specified delays in-between.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`parallel`函数之外，还有三个函数可以帮助您进行动画组合。这些函数是`delay`、`sequence`和`stagger`，它们也可以结合使用。`delay`函数在预定义的延迟之后开始任何动画，`sequence`函数按照您指定的顺序开始动画，并在动画解决之前等待，然后开始另一个动画，`stagger`函数可以按顺序和指定的延迟同时开始动画。
- en: 'Within the `parallel` function, you need to add the Animated API''s `spring` method,
    which animates the size of the `Filled` component. This time, you won''t be using
    a `timing` method, but a `spring` method, which adds a little bounce effect to
    the end of the animation. An `Easing` function is also added to make the animation
    look a little smoother:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`parallel`函数中，您需要添加Animated API的`spring`方法，该方法可以动画化`Filled`组件的大小。这次，您不会使用`timing`方法，而是使用`spring`方法，它会在动画结束时添加一点弹跳效果。还添加了一个`Easing`函数，使动画看起来更加流畅。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `spring` animation will change the value of `scaleValue` from `0` to `1` and
    create a little bounce effect at the end of the animation. `scaleValue` must also
    be added to the `style` object for the `Animated.View` component for the animation
    to become effective. `scaleValue` will be added to the `scale` field within the
    `transform` field, which will change the size of the `Filled` component:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`spring`动画将会把`scaleValue`的值从`0`改变到`1`，并在动画结束时创建一个小的弹跳效果。`scaleValue`也必须添加到`style`对象中的`Animated.View`组件中，以使动画生效。`scaleValue`将被添加到`transform`字段中的`scale`字段中，这将改变`Filled`组件的大小：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you click on any of the slots, the `Filled` component won't only fade in
    by changing the opacity but also by changing its size. The bounce effect at the
    end of the animation adds a nice touch to the fading effect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击任何一个插槽时，`Filled`组件不仅通过改变不透明度而淡入，还会通过改变大小来淡入。动画结束时的弹跳效果为淡入效果增添了一丝美感。
- en: 'However, when you click on the slot that depicts the winner of the game, the
    animation doesn''t have enough time to end while the winning state is rendered
    by the component. Therefore, you will also need to add a timeout to the function
    that sets the winner of the game. This function can be found in `src/Screens/Game.js`,
    where you can add a constant that sets the number of ms the animation should last
    for:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，当您点击描绘游戏获胜者的插槽时，动画没有足够的时间结束，而获胜状态由组件渲染。因此，您还需要在设置游戏获胜者的函数中添加一个超时。这个函数可以在`src/Screens/Game.js`中找到，您可以添加一个常量来设置动画持续的毫秒数：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will also wrap the functions that set the winner in a `setTimeout` function,
    which delays the execution of these functions by the same amount of time the animation
    lasts for:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将包装设置获胜者的函数在一个`setTimeout`函数中，这会延迟这些函数的执行时间，延迟时间与动画持续时间相同：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the `ANIMATION_DURATION` constant is exported, you can import this constant
    in the `src/Components/Slot/Filled.js` file and use this same constant for the
    actual animation. That way, if you change the duration of the animation at some
    point, you won''t have to make any changes to other components for these changes
    to be visible:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`ANIMATION_DURATION`常量被导出，您可以在`src/Components/Slot/Filled.js`文件中导入这个常量，并在实际动画中使用相同的常量。这样，如果您在某个时候更改了动画的持续时间，您不必对其他组件进行任何更改，这些更改就会可见：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Apart from the slots now being filled in with an animated `Filled` component
    that executes two parallel animations, when you click on any of them, the functions
    that set the winner of the game will wait until the slot is filled before firing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了插槽现在填充了一个执行两个并行动画的动画`Filled`组件之外，当您点击其中任何一个时，设置游戏获胜者的函数将等到插槽填充后再触发。
- en: The next section will show how to handle even more advanced animations, such
    as displaying animated graphics when any of the two players win. For this, we'll
    use the Lottie package since it supports more functionalities than the built-in
    Animated API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将展示如何处理更高级的动画，比如在任何两个玩家中有一个获胜时显示动画图形。为此，我们将使用Lottie包，因为它支持的功能比内置的Animated
    API更多。
- en: Advanced animations with Lottie
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lottie进行高级动画
- en: The React Native Animated API is great for building simple animations, but building
    more advanced animations can be harder. Luckily, Lottie offers a solution for
    creating advanced animations in React Native by making it possible for us to render After
    Effects animations in real time for iOS, Android, and React Native. Lottie can
    be installed as a separate package using `npm`, but it is also available from
    Expo. Since Lottie is still part of Expo's experimental features, you can use
    it by retrieving it from the `DangerZone` namespace. Therefore, it is currently
    best to install Lottie from `npm` and import it in the files where you want to
    use it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: React Native动画API非常适合构建简单的动画，但构建更高级的动画可能更难。幸运的是，Lottie通过在iOS、Android和React Native中实时渲染After
    Effects动画，为我们提供了在React Native中创建高级动画的解决方案。Lottie可以作为一个独立的包使用`npm`安装，但也可以从Expo获取。由于Lottie仍然是Expo的实验性功能的一部分，您可以通过从`DangerZone`命名空间中检索它来使用它。因此，目前最好是从`npm`安装Lottie，并在要使用它的文件中导入它。
- en: When using Lottie, you don't have to create these After Effects animations yourself;
    there's a whole library full of resources that you can customize and use in your
    project. This library is called `LottieFiles` and is available at `https://lottiefiles.com/`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Lottie时，您不必自己创建这些After Effects动画；有一个完整的资源库，您可以在项目中自定义和使用。这个库叫做`LottieFiles`，可以在`https://lottiefiles.com/`上找到。
- en: 'Since you''ve already added animations to the slots of the board game, a nice
    place to add more advanced animations would be the screen that is displayed when
    either of the players wins the game. On this screen, a trophy can be displayed
    instead of the board since the game has ended. Let''s do this now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经将动画添加到了棋盘游戏的插槽中，一个很好的地方来添加更高级的动画将是在任何一名玩家赢得比赛时显示的屏幕上。在这个屏幕上，可以显示一个奖杯，而不是棋盘，因为游戏已经结束了。现在让我们来做这个：
- en: 'To get started with Lottie, run the following command, which will install Lottie
    and its dependencies and add it to your `package.json` file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用Lottie，请运行以下命令，这将安装Lottie及其依赖项，并将其添加到您的`package.json`文件中：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After the installation process has completed, you can proceed by creating a
    component that will be used to render the After Effects animations that have been
    downloaded as Lottie files. This component can be created in the new `src/Components/Winner/Winner.js` file.
    In this file, you will need to import React and, of course, Lottie from `lottie-react-native`,
    which you''ve just installed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装过程完成后，你可以继续创建一个组件，用来渲染已下载为Lottie文件的After Effects动画。这个组件可以在新的`src/Components/Winner/Winner.js`文件中创建。在这个文件中，你需要导入React和当然是从`lottie-react-native`中导入的Lottie，这是你刚刚安装的：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The imported `Lottie` component can render any Lottie file that you either
    create yourself or that is download from the `LottieFiles` library. In the `assets` directory,
    you will find a Lottie file that can be used in this project called `winner.json`.
    This file can be rendered by the `Lottie` component when you add it to the source,
    and the width and height of the animation can be set by passing a style object.
    Also, you should add the `autoPlay` prop to start the animation once the component
    renders:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入的`Lottie`组件可以渲染你自己创建的或者从`LottieFiles`库下载的任何Lottie文件。在`assets`目录中，你会找到一个可以在这个项目中使用的Lottie文件，名为`winner.json`。当你将它添加到源中时，`Lottie`组件可以渲染这个文件，并且可以通过传递一个样式对象来设置动画的宽度和高度。此外，你应该添加`autoPlay`属性来在组件渲染时启动动画：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This component will now start rendering the trophy animation in any of the
    screens where you''ll include this component. Since this animation should be displayed
    instead of the board when either of the players wins the game, the `Board` component
    would be a good place to add this component as you can then use the wrapper styling
    for the board. The `Board` component can be found in the `src/Components/Board/Board.js` file,
    and is where you can import the `Winner` component:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该组件现在将开始在包含此组件的任何屏幕中渲染奖杯动画。由于这个动画应该在任一玩家赢得比赛时显示出来，所以`Board`组件是一个很好的地方来添加这个组件，因为你可以使用包装样式来包裹棋盘。`Board`组件可以在`src/Components/Board/Board.js`文件中找到，你可以在这里导入`Winner`组件：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `return` function of this component, you can check whether the `winner`
    prop is `true` or `false` and, depending on the outcome, display either the `Winner` component
    or iterate over `slots`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件的`return`函数中，你可以检查`winner`属性是`true`还是`false`，并根据结果显示`Winner`组件或者遍历`slots`：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the `Board` component receives the `winner` prop with the `true` value,
    instead of the board, the user will see the trophy animation being rendered. An
    example of how this will look when you''re running the application with the iOS
    simulator or on an iOS device can be seen here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Board`组件接收到值为`true`的`winner`属性时，用户将看到渲染的奖杯动画，而不是棋盘。当你在iOS模拟器上或者iOS设备上运行应用程序时，可以看到这将是什么样子的例子：
- en: '![](assets/6f18f00c-3355-4980-ad61-29b0ccf1944c.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6f18f00c-3355-4980-ad61-29b0ccf1944c.jpg)'
- en: 'In case you find the speed of this animation too fast, it''s possible to change
    this by combining the Animated API with Lottie. The `Lottie` component can take
    a `progress` prop that determines the speed of the animation. When passing a value
    that is created by the Animated API, you can tweak the speed of the animation
    to your own needs. Adding this to the Lottie animation can be done as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这个动画的速度太快，可以通过将Animated API与Lottie结合来进行调整。`Lottie`组件可以接受一个`progress`属性，用来确定动画的速度。通过传递由Animated
    API创建的值，你可以调整动画的速度以满足自己的需求。将这个添加到Lottie动画中可以这样做：
- en: 'First, you''ll need to import `Animated` and `Easing` (which you''ll use later
    on) and create a new value using `Animated` and the `useState` Hook at the top
    of your component:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要导入`Animated`和`Easing`（稍后会用到），并在组件顶部使用`Animated`和`useState` Hook创建一个新值：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Within a `useEffect` Hook, you can create the `Animated.timing` method, which
    will set the `progressValue` over a time frame that you indicate using the `duration`
    field. The animation should start as soon as the component renders, so the dependency
    array for the Hook should be empty. You can also add the `Easing.linear` function
    to the `easing` field to make the animation run smoother:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`useEffect` Hook中，您可以创建`Animated.timing`方法，它将在您使用`duration`字段指定的时间范围内设置`progressValue`。动画应该在组件渲染时立即开始，因此Hook的依赖数组应为空。您还可以将`Easing.linear`函数添加到`easing`字段中，以使动画运行更顺畅：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, the `progressValue` value can be passed to the `Lottie` component, which
    will result in a different behavior for the animation:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`progressValue`值可以传递给`Lottie`组件，这将导致动画的不同行为：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the animation is being slowed down. Instead of the default 3,000 ms, the
    animation will take 4,000 ms to play from beginning to end. In the next section,
    you'll add even more complexity to the user experience of this application by
    handling gestures that are available on mobile devices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，动画正在减速。动画将花费4,000毫秒而不是默认的3,000毫秒来从头到尾播放。在下一节中，您将通过处理移动设备上可用的手势，为该应用程序的用户体验增加更多复杂性。
- en: Handling gestures with Expo
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Expo处理手势
- en: Gestures are an important feature of mobile applications as they will make the
    difference between a mediocre and a good mobile application. In the *Tic-Tac-Toe*
    game you've created, several gestures could be added to make the game more appealing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 手势是移动应用程序的重要特性，因为它们将决定平庸和优秀移动应用程序之间的差异。在您创建的*Tic-Tac-Toe*游戏中，可以添加几种手势以使游戏更具吸引力。
- en: Previously, you used the `TouchableOpacity` element, which gives the user feedback
    after they press this element by changing the element. Another element that you
    could have used for this was the `TouchableHighlight` element. Just like`TouchableOpacity`,
    it can be pressed by the user, but, instead of changing the opacity, it highlights
    the element. These feedback or highlight gestures give the user an impression
    of what happens when they make decisions within your application, leading to improved
    user experience. These gestures can be customized and added to other elements
    as well, making it possible to have custom Touchable elements as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，您使用了`TouchableOpacity`元素，用户按下该元素后会通过更改元素来获得反馈。您还可以使用`TouchableHighlight`元素来实现这一点。与`TouchableOpacity`一样，它可以被用户按下，但是它会突出显示元素，而不是改变不透明度。这些反馈或突出显示手势让用户对在应用程序中做出决定时会发生什么有所印象，从而提高用户体验。这些手势也可以自定义并添加到其他元素中，使得可以创建自定义的可触摸元素。
- en: For this, you can use a package called `react-native-gesture-handler`, which
    helps you access native gestures on every platform. All of these gestures will
    be run in the native thread, which means you can add complex gesture logic without
    having to deal with the performance limitations of React Native's gesture responder
    system. Some of the gestures it supports include tap, rotate, drag, and pan gestures.
    Any project that's created with the Expo CLI can already use `GestureHandler`
    from `react-native-gesture-handler` without you having to manually install the
    package.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您可以使用一个名为`react-native-gesture-handler`的软件包，它可以帮助您在每个平台上访问原生手势。所有这些手势都将在原生线程中运行，这意味着您可以添加复杂的手势逻辑，而无需处理React
    Native手势响应系统的性能限制。它支持的一些手势包括轻触、旋转、拖动和平移手势。使用Expo CLI创建的任何项目都可以在不必手动安装软件包的情况下使用`react-native-gesture-handler`中的`GestureHandler`。
- en: You can also use gestures directly from React Native, without having to use
    an additional package. However, the gesture responder system that React Native
    currently uses doesn't run in the native thread. Not only does this limit the
    possibilities of creating and customizing gestures, but you can also run into
    cross-platform or performance problems. Therefore, it's advised that you use the
    `react-native-gesture-handler` package, but this isn't necessary for using gestures
    in React Native.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接从React Native中使用手势，而无需使用额外的包。然而，React Native目前使用的手势响应系统并不在原生线程中运行。这不仅限制了创建和自定义手势的可能性，还可能遇到跨平台或性能问题。因此，建议您使用`react-native-gesture-handler`包，但在React
    Native中使用手势并不需要这个包。
- en: Handling tap gestures
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理轻击手势
- en: 'The first gesture we will implement is a tap gesture, which will be added to
    the `Slot` component, to give the user more feedback on their actions. Instead
    of filling the slot when the user taps it, the user will already receive some
    feedback when the tap event is started and receive feedback when the event is
    completed. Here, we''ll use the `TouchableWithoutFeedback` element from `react-native-gesture-handler`,
    which runs in the native thread, instead of the `TouchableWithoutFeedback` element
    from `react-native`, which uses the gesture responder system. Replacing the `react-native`
    component with the one from `react-native-gesture-handler` can be done by following
    these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的第一个手势是轻击手势，它将被添加到`Slot`组件中，以便为用户的操作提供更多反馈。用户轻击时不会填充插槽，而是在轻击事件开始时就会收到一些反馈，并在事件完成时收到反馈。在这里，我们将使用`react-native-gesture-handler`中的`TouchableWithoutFeedback`元素，它在原生线程中运行，而不是使用手势响应系统的`react-native`中的`TouchableWithoutFeedback`元素。可以通过以下步骤将`react-native`组件替换为`react-native-gesture-handler`中的组件：
- en: '`TouchableWithoutFeedback` can be imported from `react-native-gesture-handler` at
    the top of the `src/components/Slot.js` file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TouchableWithoutFeedback`可以从`react-native-gesture-handler`中导入到`src/components/Slot.js`文件的顶部：'
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You don't have to change anything in the return function since `TouchableWithoutFeedback`
    uses the same props as the one from `react-native`. When you tap the slot, nothing
    will change. This is because the slot will be filled by the `Filled` component,
    which shows an animation once it appears.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必在返回函数中做任何更改，因为`TouchableWithoutFeedback`使用与`react-native`相同的props。当您轻击插槽时，什么都不会改变。这是因为插槽将由`Filled`组件填充，一旦出现就会显示动画。
- en: 'When you tap any of the slots and hold your finger on it, the `handleOnPress` function
    won''t be called yet. Only when you complete the tap gesture by removing your
    finger will the gesture end and the `handleOnPress` function will be called. To
    start the animation when you start the tap gesture by touching the slot, you can
    use the `onPressIn` callback from `TouchableWithoutFeedback`. Once the tap event
    starts, a value needs to be passed to the `Filled` component that indicates it
    should start the animation. This value can be created with the `useState` Hook,
    so you already have a function that can be called to change this value. The `handleOnPress` function
    should be called when the tap event ends by removing your finger from the element.
    You can do this using the `onPressOut` callback:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您轻击任何插槽并将手指放在上面时，`handleOnPress`函数还不会被调用。只有当您通过移开手指完成轻击手势时，手势才会结束，并且`handleOnPress`函数将被调用。当您触摸插槽开始轻击手势时，可以使用`TouchableWithoutFeedback`中的`onPressIn`回调来启动动画。一旦轻击事件开始，就需要向`Filled`组件传递一个值，该值指示它应该开始动画。这个值可以使用`useState`
    Hook创建，因此您已经有一个可以调用以更改此值的函数。当通过从元素上移开手指结束轻击事件时，应调用`handleOnPress`函数。您可以使用`onPressOut`回调来实现这一点：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `Filled` component in the `src/Components/Slot/Filled.js` file, you
    need to check for the `start` prop and start the animation once this prop has
    a value of `true`. Since you don''t want to start the entire animation when the
    value for `start` is `true`, only the animation that changes `opacityValue` will
    start:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Components/Slot/Filled.js`文件中的`Filled`组件中，您需要检查`start`属性，并在此属性的值为`true`时开始动画。由于您不希望在`start`的值为`true`时启动整个动画，只有改变`opacityValue`的动画会开始：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, the animation that changes the opacity can be removed from the `useEffect` Hook
    that''s checking for the `filled` prop. This `useEffect` Hook only handles the
    animation that changes the scale. The initial `scaleValue` should be changed because,
    otherwise, the size of the component will be equal to `0`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，可以从检查`filled`属性的`useEffect` Hook中删除改变不透明度的动画。此`useEffect` Hook仅处理改变比例的动画。应该更改初始的`scaleValue`，否则组件的大小将等于`0`：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you tap any of the slots after making these changes, the `timing` animation
    will be started and a square will appear in the slot, which indicates that the
    slot is being tapped. Once you release your finger from this slot, the square
    will change in size and fill in the rest of the slot as the `spring` animation
    starts, which happens when the `onPress` function changes the value for `filled`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在进行这些更改后轻击任何插槽时，将启动`timing`动画，并且一个正方形将出现在插槽中，这表示正在轻击插槽。一旦您从该插槽释放手指，正方形将改变大小，并且在`spring`动画开始时填充插槽的其余部分，这发生在`onPress`函数改变`filled`的值时。
- en: Customizing tap gestures
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义轻击手势
- en: Now, the slot has different animations, depending on the state of the tap event,
    which can be useful if the user has second thoughts about which slot to select.
    The user may remove their finger from the selected slot, in which case the tap
    event will follow a different flow of states. You can even determine whether the
    user should click on the slot for a longer time to make the selection definitive
    or maybe double-tap the slot just like liking a picture on some social media applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，插槽具有不同的动画，取决于轻击事件的状态，这可能对用户在选择哪个插槽时犹豫不决很有用。用户可能会从所选插槽上移开手指，此时轻击事件将遵循不同的状态流。您甚至可以确定用户是否应该长时间点击插槽以使选择变得明确，或者像在某些社交媒体应用程序上喜欢图片一样双击插槽。
- en: To create more complex tap gestures such as these, you need to know that the
    tap event goes through different states. `TouchableWithoutFeedback` uses `TapGestureHandler` under
    the hood and can go through the following states: `UNDETERMINED`, `FAILED`, `BEGAN`, `CANCELLED`, `ACTIVE`,
    and `END`. The naming of these states is pretty straightforward and, usually,
    the handler will have the following flow: `UNDETERMINED > BEGAN > ACTIVE > END
    > UNDETERMINED`. When you add a function to the `onPressIn` callback on the `TouchableWithoutFeedback` element,
    this function is called when the tap event is in the `BEGAN` state. The `onPressOut` callback
    is invoked when the state is `END`, while the default `onPress` callback responds
    to the `ACTIVE` state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建更复杂的轻击手势，您需要知道轻击事件经历不同的状态。`TouchableWithoutFeedback`在底层使用`TapGestureHandler`，并且可以经历以下状态：`UNDETERMINED`，`FAILED`，`BEGAN`，`CANCELLED`，`ACTIVE`和`END`。这些状态的命名非常直观，通常情况下，处理程序将具有以下流程：`UNDETERMINED
    > BEGAN > ACTIVE > END > UNDETERMINED`。当您在`TouchableWithoutFeedback`元素的`onPressIn`回调中添加函数时，此函数在轻击事件处于`BEGAN`状态时被调用。当状态为`END`时，将调用`onPressOut`回调，而默认的`onPress`回调则响应于`ACTIVE`状态。
- en: 'To create these complex gestures, you can use the `react-native-gesture-handler` package
    by handling the event state yourself, rather than the declarative way of using
    a touchable element:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些复杂的手势，您可以使用`react-native-gesture-handler`包，通过自己处理事件状态，而不是使用可触摸元素的声明方式：
- en: '`TapGestureHandler` can be imported from `react-native-gesture-handler` and lets
    you create customized touchable elements that have gestures that you can define
    yourself. You''ll need to import the `State` object from `react-native-gesture-handler`,
    which holds the constants you''ll need to use to handle checking for the state
    of the tap event:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TapGestureHandler`可以从`react-native-gesture-handler`中导入，并允许您创建自定义的可触摸元素，您可以自己定义手势。您需要从`react-native-gesture-handler`中导入`State`对象，其中包含您需要用来检查轻触事件状态的常量：'
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Instead of event handlers such as `onPress`, the `TouchableWithoutFeedback` element
    has a callback called `onHandlerStateChange`. This function will be called every
    time the state of `TapGestureHandler` changes, which is, for example, when the
    element is tapped. By using `TapGestureHandler` to create the touchable element,
    you no longer need the `TouchableWithoutFeedback` element. The functionality of
    this element can be moved to the new element that you''ll create:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要像`onPress`那样使用事件处理程序，`TouchableWithoutFeedback`元素有一个名为`onHandlerStateChange`的回调。每当`TapGestureHandler`的状态发生变化时，例如当元素被点击时，都会调用这个函数。通过使用`TapGestureHandler`来创建可触摸元素，您就不再需要`TouchableWithoutFeedback`元素。这个元素的功能可以移动到您将要创建的新元素中：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`onHandlerStateChange` takes the `onTap` function, which you still need to
    create, and checks for the current state of the tap event. When the tap event
    is in the `BEGAN` state, which is similar to the `onPressIn` handler, the animation
    from `Filled` should start. The completion of the tap event has the `END` state and
    is like the `onPressOut` handler, where you''ll call the `handleOnPress` function,
    which changes the value for the prop regarding the player that tapped the slot.
    The `setStart` function will be called to reset the state that starts the animation:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onHandlerStateChange`接受`onTap`函数，您仍然需要创建，并检查轻触事件的当前状态。当轻触事件处于`BEGAN`状态时，类似于`onPressIn`处理程序，应该开始`Filled`的动画。轻触事件的完成状态为`END`，类似于`onPressOut`处理程序，在这里您将调用`handleOnPress`函数，该函数会更改有关点击插槽的玩家的属性值。将调用`setStart`函数来重置启动动画的状态。'
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you tap any of the slots and hold your finger on it, the `handleOnPress` function
    won't be called. Only when you complete the tap gesture by removing your finger
    will the gesture end and the `handleOnPress` function be called.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击任何一个插槽并将手指放在上面时，`handleOnPress`函数不会被调用。只有当您完成轻触手势并移开手指时，手势才会结束，并调用`handleOnPress`函数。
- en: 'These gestures can be customized even more since you can use composition to
    have multiple tap events that respond to each other. By creating so-called **cross-handler
    interactions**, you can create a touchable element that supports a double-tap
    gesture and a long-press gesture. By setting and passing down a ref that''s been
    created with the React `useRef` Hook, you can let the gesture handlers from `react-native-gesture-handler`
    listen to the state life cycle of other handlers. That way, you can sequence events
    and respond to gestures like a double-tap event:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些手势甚至可以进行更多的自定义，因为您可以使用组合来拥有多个相互响应的轻触事件。通过创建所谓的**跨处理程序交互**，您可以创建一个支持双击手势和长按手势的可触摸元素。通过设置并传递使用React
    `useRef` Hook创建的引用，您可以让来自`react-native-gesture-handler`的手势处理程序监听其他处理程序的状态生命周期。这样，您可以按顺序响应事件和手势，比如双击事件：
- en: 'To create the ref, you need to place the `useRef` Hook at the top of your component
    and pass this ref to `TapGestureHandler`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建引用，您需要将`useRef` Hook放在组件顶部，并将此引用传递给`TapGestureHandler`：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you need to set the number of taps that are needed to start and complete
    the tap gesture. You don''t have to make any changes to the `onTap` function since
    the first time you tap the element, the state of the tap event will be `BEGAN`.
    Only after you''ve tapped the element twice will the tap event state change to
    `END`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要设置开始和完成轻击手势所需的轻击次数。由于第一次轻击元素时，不必对`onTap`函数进行任何更改，轻击事件的状态将为`BEGAN`。只有在您连续两次轻击元素后，轻击事件状态才会变为`END`：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To fill a slot, a user has to tap `TapGestureHandler` two times for the tap
    event to complete. However, you can also call a function when `TapGestureHandler`
    is tapped once by adding another `TapGestureHandler` that takes the existing one
    as its child. This new `TapGestureHandler` should wait for the other handler to
    have the double-tap gesture, which it can check using `doubleTapRef`. The `onTap` function
    should be renamed to `onDoubleTap` so that you have a new `onTap` function that
    will handle the single tap:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要填充一个插槽，用户必须轻击`TapGestureHandler`两次才能完成轻击事件。但是，您还可以在轻击一次`TapGestureHandler`时调用一个函数，方法是添加另一个以现有的一个为其子元素的`TapGestureHandler`。这个新的`TapGestureHandler`应该等待另一个处理程序进行双击手势，它可以使用`doubleTapRef`来检查。`onTap`函数应该重命名为`onDoubleTap`，这样您就有了一个新的`onTap`函数来处理单击：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When you click on a slot just once, the animation will start, since `TapGestureHandler`
    will be in the `BEGAN` state. The animation on the double-tap gesture should only
    start when the state is `ACTIVE` instead of `BEGAN`, so the animation won''t start
    on just a single tap. Also, by adding a `setTimeout` to the functions that are
    called when the tap gesture has ended, the animation will look smoother since
    both animations will otherwise occur too soon after each other:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您仅单击插槽时，动画将开始，因为`TapGestureHandler`将处于`BEGAN`状态。双击手势上的动画应该只在状态为`ACTIVE`而不是`BEGAN`时开始，这样动画就不会在单击时开始。此外，通过向轻击手势结束时调用的函数添加`setTimeout`，动画看起来会更加流畅，因为否则两个动画会在彼此之后太快地发生：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next to having a double-tap gesture to fill a slot, having a long-press gesture
    could also improve the user''s interaction. You can add a long-press gesture by
    following these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有双击手势来填充插槽之外，具有长按手势也可以改善用户的交互。您可以通过以下步骤添加长按手势：
- en: Import `LongPressGestureHandler` from `react-native-gesture-handler`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`react-native-gesture-handler`导入`LongPressGestureHandler`。
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On this handler, you can set the minimal duration of the long-press gesture
    and set the function that should be called after this time frame has passed. The
    `LongPressGestureHandler` handler has a state life cycle, that you can use together
    with the `onDoubleTap` function:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此处理程序上，您可以设置长按手势的最短持续时间，并设置在此时间段过去后应调用的函数。`LongPressGestureHandler`处理程序具有状态生命周期，您可以与`onDoubleTap`函数一起使用：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you only want to create a long-press gesture, you can use the `onLongPress` event
    handler, which is available on the touchable elements from `react-native` and `react-native-gesture-handler`.
    It's advised that you use the touchable elements from `react-native-gesture-handler` as
    they will run in the native thread, instead of using the React Native gesture
    responder system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想创建一个长按手势，可以使用`react-native`和`react-native-gesture-handler`中可用的可触摸元素上的`onLongPress`事件处理程序。建议您使用`react-native-gesture-handler`中的可触摸元素，因为它们将在本机线程中运行，而不是使用React
    Native手势响应系统。
- en: 'Maybe not all of your users will understand that they need to use a long-press
    gesture to fill a slot. Therefore, you can use the `onTap` function, which is
    called on a single tap, to alert the user about this functionality. For this,
    you can use the `Alert` API, which works for both iOS and Android and uses the
    native alert message from either of these platforms. In this alert, you can add
    a small message for the user:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也许并非所有用户都会理解他们需要使用长按手势来填充一个插槽。因此，您可以使用`onTap`函数，在单击时调用，向用户提醒此功能。为此，您可以使用适用于iOS和Android的`Alert`
    API，并使用这些平台中的任何一个的本机警报消息。在此警报中，您可以为用户添加一条小消息：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will show an alert when the user doesn't use the long-press to make a move
    on the board, thus making it more understandable for them. With these final additions,
    the game interface has been improved even more. Not only will users see animations
    based on their actions, but they'll also be notified about which gestures they
    can use.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在棋盘上没有使用长按来移动时，将显示警报，从而使用户更容易理解。通过这些最终的添加，游戏界面得到了进一步改进。用户不仅会看到基于其操作的动画，还将被通知他们可以使用哪些手势。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we added animations and gestures to a simple *Tic-Tac-Toe*
    game that was built with React Native and Expo. The animations were created using
    the React Native Animated API and Lottie, which is available from the Expo CLI
    and as a separate package. We also added basic and more complex gestures to the
    game, which runs in the native thread thanks to the `react-native-gesture-handler` package.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为使用React Native和Expo构建的简单*井字棋*游戏添加了动画和手势。动画是使用React Native Animated API和Expo
    CLI以及作为单独包的Lottie创建的。我们还为游戏添加了基本和更复杂的手势，这得益于`react-native-gesture-handler`包在本地线程中运行。
- en: Animations and gestures provide a clear improvement to the user interface of
    your mobile application, and there's even more we can do. Still, our application
    will also need to request and display data to your users.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 动画和手势为您的移动应用程序的用户界面提供了明显的改进，我们还可以做更多。但是，我们的应用程序还需要向用户请求和显示数据。
- en: Previously, we used GraphQL alongside React. We will build upon this in the
    next chapter. The project that you'll create in the next chapter will explore
    handling real-time data in a React Native application using WebSockets and GraphQL
    using Apollo.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在React中使用了GraphQL。我们将在下一章中继续构建。在下一章中，您将创建的项目将使用WebSockets和Apollo在React
    Native应用程序中处理实时数据。
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Various Lottie files: [https://lottiefiles.com/](https://lottiefiles.com/)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种Lottie文件：[https://lottiefiles.com/](https://lottiefiles.com/)
- en: More on the Animated API: [https://facebook.github.io/react-native/docs/animated](https://facebook.github.io/react-native/docs/animated)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Animated API的更多信息：[https://facebook.github.io/react-native/docs/animated](https://facebook.github.io/react-native/docs/animated)
