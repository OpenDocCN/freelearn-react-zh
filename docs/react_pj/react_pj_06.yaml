- en: Build an Application Exploring TDD Using Jest and Enzyme
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest和Enzyme构建探索TDD的应用程序
- en: To keep your application maintainable, it is good practice to have testing set
    up for your project. Where some developers hate writing tests and therefore try
    to avoid writing them, other developers like to make testing the core of their
    development process by implementing a **test-driven development** (**TDD**) strategy.
    There are many opinions about testing your applications and how to do this. Luckily,
    when building an application with React, many great libraries can help you with
    testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用的可维护性，最好为项目设置测试。一些开发人员讨厌编写测试，因此试图避免编写测试，而其他开发人员则喜欢将测试作为其开发过程的核心，实施**测试驱动开发**（**TDD**）策略。关于测试应用程序以及如何进行测试有很多不同的观点。幸运的是，在使用React构建应用程序时，许多出色的库可以帮助您进行测试。
- en: In this chapter, you'll use two libraries to unit test React applications. The
    first one is Jest, which is maintained by Facebook itself and ships with Create
    React App. The other tool is called Enzyme, which has more functionality than
    Jest and can be used to test entire life cycles within your components. Together,
    they are a great fit for testing most React applications if you want to test whether
    functions or components behave as expected when they're given a certain input.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用两个库来对React应用程序进行单元测试。第一个是Jest，由Facebook自己维护，并随Create React App一起发布。另一个工具叫做Enzyme，它比Jest具有更多的功能，并且可以用来测试组件内的整个生命周期。它们一起非常适合测试大多数React应用程序，如果您想要测试函数或组件在给定特定输入时是否表现如预期。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Unit testing with Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest进行单元测试
- en: Rendering React components for testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试渲染React组件
- en: Testing with Enzyme
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Enzyme进行测试
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a hotel review application that has unit and
    integration testing in place with Jest and Enzyme. The application has been prebuilt
    and uses the same patterns that we've looked at in the previous chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个酒店评论应用程序，并使用Jest和Enzyme进行单元和集成测试。该应用程序已经预先构建，并使用了我们在前几章中看到的相同模式。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The application for this chapter builds upon an initial version, which can be
    found at [https://github.com/PacktPublishing/React-Projects/tree/ch6-initial](https://github.com/PacktPublishing/React-Projects/tree/ch6-initial). The
    complete code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch6](https://github.com/PacktPublishing/React-Projects/tree/ch6).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的应用程序是基于初始版本构建的，可以在[https://github.com/PacktPublishing/React-Projects/tree/ch6-initial](https://github.com/PacktPublishing/React-Projects/tree/ch6-initial)找到。本章的完整代码可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects/tree/ch6](https://github.com/PacktPublishing/React-Projects/tree/ch6)。
- en: Start by downloading the initial project from GitHub and move into the root
    directory for this project, where you must run the `npm install` command. Since
    this project builds upon Create React App, running this command will install `react`, `react-dom`, and `react-scripts`.
    Also, `styled-components` and `react-router-dom` will be installed so that they
    can handle styling and routing for the application. After finishing the installation
    process, you can execute the `npm start` command to run the application so that
    you can visit the project in the browser at `http://localhost:3000`. Just like
    with the applications you've built in the previous chapters, this application
    functions as a PWA.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载初始项目，并进入该项目的根目录，然后运行`npm install`命令。由于该项目是基于Create React App构建的，运行此命令将安装`react`、`react-dom`和`react-scripts`。此外，还将安装`styled-components`和`react-router-dom`，以便它们可以处理应用程序的样式和路由。安装过程完成后，可以执行`npm
    start`命令来运行应用程序，然后在浏览器中访问`http://localhost:3000`来查看项目。就像你在之前章节中构建的应用程序一样，这个应用程序也是一个PWA。
- en: 'The initial application consists of a simple header and a list of hotels. These
    hotels have a title and meta information, like a thumbnail. This page will look
    as follows. If you click on any of the hotels in the list, a new page will open
    with a list of reviews for this hotel. By clicking the button at the top left
    of this page, you can move back to the previous page, and with the button at the
    top right, a page with a form where you can add a review will open. If you add
    a new review, this data will be stored in a global Context and sent to a mock
    API server:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 初始应用程序包括一个简单的标题和酒店列表。这些酒店有标题和缩略图等元信息。该页面将如下所示。如果你点击列表中的任何酒店，将会打开一个新页面，显示该酒店的评论列表。通过点击页面左上角的按钮，你可以返回到上一个页面；通过点击右上角的按钮，将打开一个包含表单的页面，你可以在其中添加评论。如果你添加了新的评论，这些数据将被存储在全局上下文中，并发送到一个模拟API服务器。
- en: '![](assets/c25bf83e-16c2-42a4-a572-8dffff5127ea.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c25bf83e-16c2-42a4-a572-8dffff5127ea.png)'
- en: 'If you look at the project''s structure, you''ll see that it''s using the same
    structure as the projects we created previously. The entry point of this application
    is a file called `src/index.js`, which renders a component called `App`. In this `App` component,
    all the routes are declared and wrapped within a router component. Also, the component
    that holds the global Context and the Providers is declared here. Compared to
    the applications you created previously, the container component pattern isn''t
    used in this application. Instead, all the data fetching is done by the Context
    components. Life cycles are accessed using Hooks:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目的结构，你会发现它使用了与我们之前创建的项目相同的结构。这个应用程序的入口点是一个名为`src/index.js`的文件，它渲染了一个名为`App`的组件。在这个`App`组件中，所有的路由都被声明并包装在一个路由组件中。此外，这里还声明了持有全局上下文和提供者的组件。与之前创建的应用程序相比，这个应用程序中没有使用容器组件模式。相反，所有的数据获取都是通过上下文组件完成的。生命周期是使用Hooks来访问的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding project structure, you can see there are also two files in
    the `public/assets` directory, which are the thumbnails for the hotels. To make
    them available in the rendered application, you can place them in the `public` directory.
    Also, there is a file called `api.js` in `src` that exports the functions so that `GET` and `POST` requests
    can be sent to an API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述项目结构中，你可以看到`public/assets`目录中还有两个文件，这些文件是酒店的缩略图。为了在渲染的应用程序中使用它们，你可以将它们放在`public`目录中。此外，在`src`中还有一个名为`api.js`的文件，它导出了函数，以便可以向API发送`GET`和`POST`请求。
- en: Hotel review application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 酒店评论应用程序
- en: In this section, we will add unit and integration testing to the hotel review
    application that was created in Create React App. This application lets you add
    reviews to a list of hotels and controls this data from a global Context. Jest
    and Enzyme will be used to render React components without a DOM and test assertions
    on these components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为在Create React App中创建的酒店评论应用程序添加单元测试和集成测试。这个应用程序允许你向酒店列表中添加评论，并从全局上下文中控制这些数据。Jest和Enzyme将用于在没有DOM的情况下渲染React组件，并对这些组件进行测试断言。
- en: Unit testing with Jest
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest进行单元测试
- en: Unit testing is an important part of your application since you want to know
    that your functions and components behave as expected, even when you make code
    changes. For this, you're going to use Jest, an open source testing package for
    JavaScript applications that was created by Facebook. With Jest, you can test
    assertions, for example, if the output of a function matches the value you expected.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是应用程序的重要部分，因为你希望知道你的函数和组件在进行代码更改时是否按预期行为。为此，你将使用Jest，这是一个由Facebook创建的用于JavaScript应用程序的开源测试包。使用Jest，你可以测试断言，例如，如果函数的输出与你预期的值匹配。
- en: To get started with Jest, you don't have to install anything; it's part of Create
    React App. If you look at the `package.json` file, you will see that a script
    is already there for running tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Jest，你无需安装任何东西；它是Create React App的一部分。如果你查看`package.json`文件，你会看到已经有一个用于运行测试的脚本。
- en: 'Let''s see what happens if you execute the following command from your Terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果你从终端执行以下命令会发生什么：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will return a message saying `No tests found related to files changed
    since last commit.`, which means Jest is running within watch mode and only running
    tests for files that have been changed. By pressing the `a` key, you can run all
    the tests, even if you haven''t modified any files. If you press this key, the
    following message will be displayed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一条消息，说`No tests found related to files changed since last commit.`，这意味着Jest正在观察模式下运行，并且只对已更改的文件运行测试。通过按下`a`键，你可以运行所有测试，即使你没有修改任何文件。如果按下这个键，将显示以下消息：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This message states that `26` files have been investigated, but no tests have
    been found. It also states that it's looking for JavaScript or JSX files in directories
    called `__tests__` in your project and files that have the `spec` or `test` suffix.
    The `node_modules` directory, which is where all the `npm` packages are installed,
    is ignored. From this message, you may have noticed that Jest automatically detects
    files with tests for you.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息说明已经调查了`26`个文件，但没有找到测试。它还说明正在寻找项目中名为`__tests__`的目录中的JavaScript或JSX文件，以及具有`spec`或`test`后缀的文件。`node_modules`目录，即所有`npm`包安装的地方，将被忽略。从这条消息中，你可能已经注意到Jest会自动检测包含测试的文件。
- en: Creating these tests can be done with Jest, which will be demonstrated in the
    first part of this section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Jest来创建这些测试，这将在本节的第一部分进行演示。
- en: Creating a unit test
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个单元测试
- en: 'Since there are multiple ways Jest can detect which file contains a test, let''s
    choose the structure where every component has a separate test file. This test
    file will have the same name as the file that holds the component, with the `.test` suffix.
    If we choose the `SubHeader` component, we can create a new file called `SubHeader.test.js` in
    the `src/components/Header` directory. Add the following code to this file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jest可以以多种方式检测哪个文件包含测试，让我们选择每个组件都有一个单独的测试文件的结构。这个测试文件将与包含组件的文件同名，后缀为`.test`。如果我们选择`SubHeader`组件，我们可以在`src/components/Header`目录中创建一个名为`SubHeader.test.js`的新文件。将以下代码添加到这个文件中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Two global functions from Jest are used here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了Jest的两个全局函数：
- en: '`describe`: This is used to define a block of related tests'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`：用于定义一组相关的测试'
- en: '`it`: This is used to define a test'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it`：用于定义测试'
- en: 'Within the definition of a test, you can add assumptions such as `toEqual` or
    `toBe`, which check whether the value is exactly equal to something or whether
    just the types match, respectively. The assumptions can be added within the callback
    of the `it` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的定义中，您可以添加假设，比如`toEqual`或`toBe`，分别检查值是否完全等于某些内容，或者只是类型匹配。假设可以在`it`函数的回调中添加：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you still have the test script running in your Terminal, you will see that
    Jest has detected your test. The test succeeds since `1+2` is indeed `3`. Let''s
    go ahead and change the assumption to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端仍在运行测试脚本，您将看到Jest已检测到您的测试。测试成功，因为`1+2`确实是`3`。让我们继续并将假设更改为以下内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, the test will fail as the second assumption doesn't match. Although `1+2` still
    equals `3`, it's assumed that a string type with a value pf `3` is returned, while
    in fact a number type is returned. This helps you when you're writing your code
    as you can make sure that your application doesn't change the types of its values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试将失败，因为第二个假设不匹配。虽然`1+2`仍然等于`3`，但假设返回了一个值为`3`的字符串类型，而实际上返回的是一个数字类型。这在编写代码时可以帮助您，因为您可以确保应用程序不会更改其值的类型。
- en: However, this assumption has no actual usage as it doesn't test your component.
    To test your component, you need to render it. Rendering components so that you
    can test them will be handled in the next part of this section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个假设实际上没有用，因为它并没有测试您的组件。要测试您的组件，您需要渲染它。在本节的下一部分将处理渲染组件以便测试它们。
- en: Rendering a React component for testing
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染React组件进行测试
- en: 'Jest is based upon Node.js, meaning that it can''t use the DOM to render your
    component and test its functionality. Therefore, you need to add a React core
    package to your project, which can help you render the component without a DOM.
    Let''s take a look at this here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Jest基于Node.js，这意味着它无法使用DOM来渲染您的组件并测试其功能。因此，您需要向项目添加一个React核心软件包，它可以帮助您在没有DOM的情况下渲染组件。让我们在这里看一下：
- en: 'From your Terminal, execute the following command, which will install `react-test-renderer`
    in your project. It can be installed as a devDependency as you don''t need to
    run tests on the build version of your application:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端执行以下命令，它将在您的项目中安装`react-test-renderer`。它可以作为devDependency安装，因为您不需要在应用程序的构建版本上运行测试：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With `react-test-renderer` installed, you can now import this package into
    the `src/components/Header/SubHeader.test.js` file. This package returns a method
    called `ShallowRenderer` that lets you render the component. With Shallow rendering,
    you only render a component at its first level, thereby leaving out any possible
    children components. You also need to import React and the actual component you
    want to test since these are used by `react-test-renderer`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了`react-test-renderer`后，您现在可以将此软件包导入到`src/components/Header/SubHeader.test.js`文件中。此软件包返回一个名为`ShallowRenderer`的方法，让您可以渲染组件。使用浅渲染，您只在其第一级渲染组件，从而排除任何可能的子组件。您还需要导入React和您想要测试的实际组件，因为这些是`react-test-renderer`使用的：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In your test, you can now render the component with `ShallowRenderer` and get
    the output of this component. With the Jest `toMatchSnapshot` assumption, you
    can test the structure of the component. `ShallowRenderer` will render the component
    and `toMatchSnapshot` will create a snapshot from this render and compare it to
    the actual component every time this test is run:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的测试中，您现在可以使用`ShallowRenderer`来渲染组件，并获得此组件的输出。使用Jest的`toMatchSnapshot`假设，您可以测试组件的结构。`ShallowRenderer`将渲染组件，`toMatchSnapshot`将从此渲染创建快照，并在每次运行此测试时将其与实际组件进行比较：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `src/components/Header` directory, a new directory called `__snapshots__`
    has now been created by Jest. Inside this directory is a file called `SubHeader.test.js.snap`,
    which includes the snapshot. If you open this file, you will see that a rendered
    version of the `SubHeader` component is stored here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components/Header`目录中，Jest现在创建了一个名为`__snapshots__`的新目录。在这个目录中有一个名为`SubHeader.test.js.snap`的文件，其中包含了快照。如果您打开这个文件，您会看到`SubHeader`组件的渲染版本存储在这里：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The components that have been created with `styled-components` cannot be rendered
    by `react-test-renderer` because of how they're exported by `styled-components`.
    If you look at the code for the `SubHeader` component, you will see that the `ForwardRef` components
    represent `SubHeaderWrapper` and `Title`. Later in this chapter, we will use Enzyme
    for testing, which handles this test scenario better.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`styled-components`创建的组件无法被`react-test-renderer`渲染，因为它们是由`styled-components`导出的方式。如果您查看`SubHeader`组件的代码，您会看到`ForwardRef`组件代表`SubHeaderWrapper`和`Title`。在本章的后面，我们将使用Enzyme进行测试，它可以更好地处理这种测试场景。
- en: 'No actual values are being rendered by `react-test-renderer` since no props
    have been passed to the `SubHeader` component. You can inspect how the snapshot
    works by passing, for instance, a `title` prop to the `SubHeader` component. To
    do this, create a new test scenario, which should render `SubHeader` with a title.
    Also, move the creation of the `renderer` constant to the `describe` function,
    so that it can be used by all the test scenarios:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于未向`SubHeader`组件传递任何props，因此`react-test-renderer`不会呈现任何实际值。您可以通过向`SubHeader`组件传递`title`
    prop来检查快照的工作方式。为此，创建一个新的测试场景，应该呈现带有标题的`SubHeader`。此外，将`renderer`常量的创建移动到`describe`函数中，以便它可以被所有的测试场景使用：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next time the tests are run, a new snapshot will be added to the `src/components/Header/__snapshots__/SubHeader.test.js.snap` file.
    This snapshot has a value rendered for the `title` prop. If you change the `title` prop
    that is displayed by the `SubHeader` component in your test file, the rendered
    component will no longer match the snapshot. You can try this by changing the
    value for the `title` prop in the test scenario:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下次运行测试时，将会在`src/components/Header/__snapshots__/SubHeader.test.js.snap`文件中添加一个新的快照。这个快照为`title`
    prop呈现了一个值。如果您在测试文件中更改了`SubHeader`组件显示的`title` prop的值，渲染的组件将不再与快照匹配。您可以通过更改测试场景中`title`
    prop的值来尝试这一点：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Jest will return the following message in the Terminal, where it specifies
    which lines have changed in comparison to the snapshot. In this case, the title
    that''s being displayed is no longer `Test Application` but `Test Application
    Test`, which doesn''t match the title in the snapshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Jest将在终端中返回以下消息，其中指定了与快照相比发生了哪些变化的行。在这种情况下，显示的标题不再是`Test Application`，而是`Test
    Application Test`，这与快照中的标题不匹配：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By pressing the `u` key, you can update the snapshot to handle this new test
    scenario. This is an easy way to test the structure of your component and see
    if the title has been rendered. With the preceding test, the initially created
    snapshot still matches the rendered component for the first test. Also, another
    snapshot was created for the second test, where a `title` prop was added to the
    `SubHeader` component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下`u`键，您可以更新快照以处理这个新的测试场景。这是测试组件结构的一种简单方法，可以看到标题是否已经被渲染。通过前面的测试，最初创建的快照仍然与第一个测试的渲染组件匹配。此外，还为第二个测试创建了另一个快照，其中向`SubHeader`组件添加了`title`
    prop。
- en: You can do the same for the other props that are passed to the `SubHeader` component,
    which renders differently if you do or don't pass certain props to it. Next to
    `title`, this component takes `goBack` and `openForm` as props, where the `openForm` prop
    has a default value of false.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以对传递给`SubHeader`组件的其他属性做同样的操作，如果你传递或不传递某些属性，它会以不同的方式呈现。除了`title`之外，这个组件还接受`goBack`和`openForm`作为属性，其中`openForm`属性的默认值为false。
- en: 'Just like we did for the `title` prop, we can also create test scenarios for
    the two other props. When there''s a value for `goBack`, a button is created that
    takes us back to the previous page, while when there''s a value for `openForm`,
    a button is created that allows us to proceed to the next page so that we can
    add a new review. You need to add these two new test scenarios to the `src/components/Header/SubHeader.test.js` file
    as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为`title`属性所做的那样，我们也可以为另外两个属性创建测试场景。当`goBack`有值时，会创建一个按钮，让我们返回到上一页，而当`openForm`有值时，会创建一个按钮，让我们可以继续到下一页，这样我们就可以添加新的评论。你需要将这两个新的测试场景添加到`src/components/Header/SubHeader.test.js`文件中：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You''ve now created two more snapshots for the `SubHeader` component, which
    leads to a total of four snapshots. Something else that Jest does is show you
    how many lines of code have been covered by your tests. The higher your testing
    coverage, the more reason to assume your code is stable. You can check the test
    coverage of your code by executing the `test` script command with the `--coverage`
    flag, or use the following command in your Terminal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在为`SubHeader`组件创建了另外两个快照，总共有四个快照。Jest还会显示你的测试覆盖了多少行代码。你的测试覆盖率越高，就越有理由认为你的代码是稳定的。你可以通过执行带有`--coverage`标志的`test`脚本命令来检查你的代码的测试覆盖率，或者在终端中使用以下命令：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command will run your tests and generate a report with all the test coverage
    information about your code per file. After adding the tests for `SubHeader`,
    this report will look as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将运行你的测试并生成一个报告，其中包含有关每个文件的代码测试覆盖信息。在为`SubHeader`添加测试之后，这个报告将如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Testing coverage only tells us something about the lines and the functions of
    your code that have been tested and not their actual implementation. Having a
    test coverage of 100% doesn't mean there aren't any bugs in your code as there
    will always be edge cases. Also, getting to a testing coverage of 100% means you
    may end up spending more time on writing tests than on actual code. Usually, a
    testing coverage above 80% is considered good practice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖只告诉我们关于已经测试过的代码行和函数的信息，而不是它们的实际实现。拥有100%的测试覆盖并不意味着你的代码中没有任何错误，因为总会有边缘情况。此外，达到100%的测试覆盖意味着你可能会花更多的时间编写测试而不是实际的代码。通常，80%以上的测试覆盖被认为是良好的实践。
- en: As you can see, the test coverage for the component is 100%, meaning that all
    the lines are covered in your test. However, this method of testing with snapshots
    will create a lot of new files and lines of code. We'll look at other ways we
    can test our components in the next part of this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，组件的测试覆盖率为100%，这意味着你的测试覆盖了所有的代码行。然而，使用快照测试的这种方法会创建大量新文件和代码行。我们将在本节的下一部分中看看我们可以用其他方法来测试我们的组件。
- en: Testing components with assertions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断言测试组件
- en: In theory, snapshot testing is not necessarily bad practice; however, your files
    can get quite big over time. Also, since you're not explicitly telling Jest what
    part of the component you want to test, you might need to update your code regularly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，快照测试并不一定是坏的实践；然而，随着时间的推移，你的文件可能会变得非常庞大。此外，由于你没有明确告诉Jest你想测试组件的哪一部分，你可能需要定期更新你的代码。
- en: Luckily, using snapshots isn't the only method we can use to test whether our
    components are rendering the correct props. Instead, you can also directly compare
    which props are being rendered by checking the value of the component and making
    assertions. The big advantage of testing with assertions is that you can test
    a lot without having to dig deeper into the logic of the component you're testing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用快照并不是我们测试组件是否渲染正确属性的唯一方法。相反，您还可以直接比较组件渲染的属性的值并进行断言。使用断言进行测试的重要优势是，您可以进行大量测试，而无需深入了解正在测试的组件的逻辑。
- en: 'For instance, you can see what the children that are being rendered look like.
    Let''s take a look at how to do this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以查看正在渲染的子元素的样子。让我们看看如何做到这一点：
- en: 'First, let''s create a snapshot test for the `Button` component to compare
    the impact of test coverage. Create a new file called `src/components/Button/Button.test.js`.
    In this file, you need to insert a test that creates a snapshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为 `Button` 组件创建一个快照测试，以比较测试覆盖率的影响。创建一个名为 `src/components/Button/Button.test.js`
    的新文件。在这个文件中，您需要插入一个创建快照的测试：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you run the tests with the `--coverage` flag, a new test coverage report
    will be created:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用 `--coverage` 标志运行测试，将创建一个新的测试覆盖报告：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This report generates the following report, which shows the coverage for the
    `Button` component, which is 100%:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此报告生成以下报告，显示了 `Button` 组件的覆盖率，为100％：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you open the snapshot for the `Button` component, which is in the `src/components/Button/__snapshots__/Button.test.js.snap` file,
    you will see that the only thing that''s been rendered within the button (represented
    by `ForwardRef`) is the `children` prop:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开 `src/components/Button/__snapshots__/Button.test.js.snap` 文件中 `Button`
    组件的快照，您将看到按钮内部渲染的唯一内容（由 `ForwardRef` 表示）是 `children` 属性：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Although the testing coverage is at 100%, there are other ways to test whether
    the correct children have been rendered. For this, we can create a new test that
    also uses `ShallowRenderer` and tries to render the `Button` component with a
    child. This test has the assertion that the rendered `children` prop is equal
    to the actual `children` prop that was rendered by `Button`. You can remove the
    snapshot test since you only want to test the children with assertions:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管测试覆盖率达到了100％，但还有其他方法可以测试正确的子元素是否已被渲染。为此，我们可以创建一个新的测试，也使用 `ShallowRenderer`
    并尝试使用子元素渲染 `Button` 组件。这个测试断言渲染的 `children` 属性是否等于 `Button` 渲染的实际 `children` 属性。您可以删除快照测试，因为您只想通过断言测试子元素：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From your Terminal, run `npm run test --coverage` again to check the impact
    this testing method has on the test coverage:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端运行 `npm run test --coverage` 再次检查这种测试方法对测试覆盖率的影响：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding report, you can see that the testing coverage is still 100%,
    meaning that this testing method has the same outcome. But this time, you're specifically
    testing whether the children are equal to that value. The upside is that you don't
    have to update snapshots every time you make code changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述报告中，您可以看到测试覆盖率仍然为100％，这意味着这种测试方法具有相同的结果。但这次，您特别测试子元素是否等于该值。好处是，您无需在每次进行代码更改时更新快照。
- en: 'Also, a message noting `1 snapshot obsolete` is shown. By running `npm run
    test` with the `-u` flag, the snapshot for the `Button` component is removed by
    Jest:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还显示了一个消息，指出 `1 个快照已过时`。通过使用 `-u` 标志运行 `npm run test`，`Button` 组件的快照将被 Jest 删除：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This provides us with the following output, which shows us that the snapshot
    has been removed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下输出，显示快照已被移除：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, the `Button` component doesn't just take the `children` prop – it also
    takes the `onClick` prop. If you want to test whether this `onClick` prop is triggered
    when you click on the button, you need to render the component differently. This
    can be done by using `react-test-renderer`, but the React documentation also notes
    that you can use Enzyme for this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Button`组件不仅接受`children`属性，还接受`onClick`属性。如果您想测试当单击按钮时是否触发了此`onClick`属性，您需要以不同的方式渲染组件。这可以通过使用`react-test-renderer`来完成，但React文档还指出您也可以使用Enzyme来实现这一点。
- en: In the next section, we'll use the shallow render function from Enzyme, which
    has more options than `ShallowRenderer`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Enzyme的浅渲染函数，该函数比`ShallowRenderer`有更多选项。
- en: Using Enzyme for testing React
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Enzyme进行React测试
- en: The `ShallowRenderer` from `react-test-renderer` allows us to render the structure
    of a component but doesn't show us how a component interacts in certain scenarios,
    such as when an `onClick` event is being triggered. To simulate this, we'll use
    a more complex tool called Enzyme.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-test-renderer`的`ShallowRenderer`允许我们渲染组件的结构，但不会显示组件在某些场景下的交互方式，例如当触发`onClick`事件时。为了模拟这一点，我们将使用一个更复杂的工具，称为Enzyme。'
- en: Shallow rendering with Enzyme
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Enzyme进行浅渲染
- en: 'Enzyme is an open source JavaScript testing library that was created by Airbnb
    and works with almost every JavaScript library or framework. With Enzyme, you
    can also shallow render components to test the first level of the component, as
    well as render nested components, and simulate life cycles for integration tests.
    The Enzyme library can be installed with `npm`, and also needs an adapter to simulate
    React features. Let''s get started:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme是由Airbnb创建的开源JavaScript测试库，可以与几乎所有JavaScript库或框架一起使用。使用Enzyme，您还可以浅渲染组件以测试组件的第一级，以及渲染嵌套组件，并模拟集成测试的生命周期。Enzyme库可以使用`npm`安装，并且还需要一个适配器来模拟React功能。让我们开始吧：
- en: 'To install Enzyme, you need to run the following command from your Terminal,
    which installs Enzyme and the specific adapter for the version of React you''re
    using:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Enzyme，您需要从终端运行以下命令，该命令安装Enzyme和您正在使用的React版本的特定适配器：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After installing Enzyme, you need to create a setup file that tells Enzyme
    what adapter should be used to run the tests. Normally, you''d need to specify
    which file holds this configuration in your `package.json` file, but, when you''re
    using Create React App, this is already done for you. The filename that''s automatically
    being used as the configuration file for testing libraries is called `setupTests.js`
    and should be created in the `src` directory. Once you''ve created the file, paste
    the following code into it:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Enzyme后，您需要创建一个设置文件，告诉Enzyme应该使用哪个适配器来运行测试。通常，您需要在`package.json`文件中指定保存此配置的文件，但是，当您使用Create
    React App时，这已经为您完成。自动用作测试库配置文件的文件名为`setupTests.js`，应该创建在`src`目录中。创建文件后，将以下代码粘贴到其中：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the installation of Enzyme, you can no longer use the test scenarios that
    use `react-test-renderer`. Therefore, you need to change the tests for the `SubHeader` and
    `Button` components. As we mentioned previously, Enzyme has a method that allows
    us to shallow render components. Let''s try this for the `SubHeader` component
    first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Enzyme后，您将无法再使用使用`react-test-renderer`的测试场景。因此，您需要更改`SubHeader`和`Button`组件的测试。正如我们之前提到的，Enzyme有一个方法允许我们浅渲染组件。让我们先尝试对`SubHeader`组件进行这样的操作：
- en: 'Instead of importing `react-test-renderer`, you need to import `shallow` from
    Enzyme. The `ShallowRender` method should no longer be added to the `renderer`
    constant, so you can delete this line:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要从Enzyme导入`shallow`，而不是导入`react-test-renderer`。`ShallowRender`方法不应再添加到`renderer`常量中，因此您可以删除此行：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each test scenario should be changed so that it uses the shallow render function
    from Enzyme. We can do this by replacing `renderer.render` with `shallow`. The
    function that we use to get the output of this render can be deleted as well.
    The `shallow` render from Enzyme will instantly create a result that can be tested
    by Jest:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个测试方案都应更改为使用Enzyme的浅渲染函数。我们可以通过用`shallow`替换`renderer.render`来实现这一点。我们用于获取此渲染输出的函数也可以删除。Enzyme的`shallow`渲染将立即创建一个可以由Jest测试的结果：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Just like we did in the first test scenario, we must replace the other test
    scenarios; otherwise, the tests won''t run. This happens because we''ve already
    deleted the setup for `react-test-renderer`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在第一个测试方案中所做的那样，我们必须替换其他测试方案；否则，测试将无法运行。这是因为我们已经删除了`react-test-renderer`的设置：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the Terminal, you can now run the test again by running `npm run test`. Since
    the tests are running in watch mode, the tests for the `Button` component will
    probably start running as well. You can specify which tests should be run by pressing
    the `p` key and then type `SubHeader` in the Terminal. Now, Jest will only run
    the tests for the `SubHeader` component.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，您现在可以通过运行`npm run test`再次运行测试。由于测试正在观察模式下运行，`Button`组件的测试可能也会开始运行。您可以通过按下`p`键然后在终端中输入`SubHeader`来指定应该运行哪些测试。现在，Jest将仅运行`SubHeader`组件的测试。
- en: 'The tests will fail as your snapshots are no longer the snapshots that were
    created by `react-test-renderer`. Enzyme''s shallow render has a better understanding
    of the exports from `styled-components` and no longer renders those components
    as a `ForwardRef` component. Instead, it returns, for instance, a component called
    `styled.div` or `styled.h2`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的快照不再是由`react-test-renderer`创建的快照，测试将失败。Enzyme的浅渲染对来自`styled-components`的导出有更好的理解，不再将这些组件呈现为`ForwardRef`组件。相反，它返回，例如，名为`styled.div`或`styled.h2`的组件：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By pressing the `u` key, all the snapshots that were created by `react-test-renderer`
    will be replaced by the new snapshots from Enzyme.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下`u`键，所有由`react-test-renderer`创建的快照将被Enzyme的新快照替换。
- en: 'The same can be done for the `Button` component, where no snapshot is used
    for testing. Instead, an assertion is used. In your test scenario, in the `src/components/Button/Button.test.js`
    file, replace `ShallowRenderer` with the shallow render from Enzyme. Also, the
    value for `component.props.children` is no longer present due to how Enzyme renders
    the component. Instead, you need to use the `props` method, which is available
    on the shallow rendered component, to get the `children` prop:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Button`组件，也可以进行相同的操作，不使用快照进行测试。而是使用断言。在您的测试方案中，在`src/components/Button/Button.test.js`文件中，用Enzyme的浅渲染替换`ShallowRenderer`。此外，由于Enzyme呈现组件的方式，`component.props.children`的值不再存在。相反，您需要使用`props`方法，该方法可用于浅渲染的组件上，以获取`children`属性：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All the tests should now succeed when you run the tests, and the testing coverage
    should be unaffected as you're still testing whether the props are rendered on
    your components. However, with the snapshots from Enzyme, you've got more information
    about the structure of the component that's being rendered. Now, you can test
    even more and find out how, for example, `onClick` events are being handled.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您运行测试时，所有测试都应该成功，并且测试覆盖率不应受影响，因为您仍在测试组件上的属性是否被渲染。然而，使用Enzyme的快照，您可以获得有关正在呈现的组件结构的更多信息。现在，您甚至可以测试更多内容，并找出例如`onClick`事件是如何处理的。
- en: However, snapshots aren't the only way of testing your React components, as
    we'll see in the next part of this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，快照并不是测试React组件的唯一方式，正如我们将在本节的下一部分中看到的那样。
- en: Testing assertions with shallow rendering
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浅渲染进行断言测试
- en: Other than `react-test-renderer`, Enzyme can handle `onClick` events on the
    shallow rendered component. To test this, you have to create a mocked version
    of the function, which should be fired once the component is clicked. After this,
    Jest can check whether or not the function was executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`react-test-renderer`之外，Enzyme可以处理浅渲染组件上的`onClick`事件。为了测试这一点，您必须创建一个模拟版本的函数，该函数应在组件被点击时触发。之后，Jest可以检查该函数是否被执行。
- en: 'The `Button` component that you tested previously doesn''t just take `children`
    as a prop – it also takes the `onClick` function. Let''s try and see if this can
    be tested using Jest and Enzyme by creating a new test scenario in the file for
    the `Button` component:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前测试过的`Button`组件不仅接受`children`作为属性 - 它还接受`onClick`函数。让我们尝试看看是否可以使用Jest和Enzyme来测试这一点，通过在`Button`组件的文件中创建一个新的测试场景：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding test scenario, a mocked `onClick` function was created with
    Jest, which is passed as a prop to the shallow rendered `Button` component. Then,
    a `simulate` method with a click event handler is invoked on that component. Simulating
    a click on the `Button` component should execute the mocked `onClick` function,
    which you can confirm by checking the test results for this test scenario.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试场景中，使用Jest创建了一个模拟的`onClick`函数，该函数作为属性传递给了浅渲染的`Button`组件。然后，在该组件上调用了一个带有点击事件处理程序的`simulate`方法。模拟点击`Button`组件应该执行模拟的`onClick`函数，您可以通过检查该测试场景的测试结果来确认这一点。
- en: 'The tests for the `SubHeader` component can also be updated since two buttons
    with an `onClick` event are rendered by it. Let''s get started:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubHeader`组件的测试也可以更新，因为它渲染了两个带有`onClick`事件的按钮。让我们开始吧：'
- en: 'First, you need to make some changes to the file for the `SubHeader` component
    in `src/components/Header/SubHeader.js` since you need to export the components
    that have been created with `styled-components`. By doing this, they can be used
    for testing in your test scenario for `SubHeader`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要对`src/components/Header/SubHeader.js`中的`SubHeader`组件的文件进行一些更改，因为您需要导出使用`styled-components`创建的组件。通过这样做，它们可以在`SubHeader`的测试场景中用于测试：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once they''ve been exported, we can import these components into our test file
    for `SubHeader`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它们被导出，我们就可以将这些组件导入到我们的`SubHeader`测试文件中：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This makes it possible to find these components from any of our tests. In this
    scenario, the rendering of the `title` prop is tested with a snapshot, but you
    can also directly test whether the `title` prop is being rendered by the `Title` component
    in `SubHeader`. To test this, change the following lines of code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样可以在任何测试中找到这些组件。在这种情况下，使用快照测试了`title`属性的渲染，但您也可以直接测试`SubHeader`中的`Title`组件是否正在渲染`title`属性。要测试这一点，请更改以下代码行：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A new constant for the `title` prop is created here and passed to the `SubHeader` component.
    Instead of using a snapshot as an assertion, a new one is created that tries to
    find the `Title` component and checks whether the text inside this component is
    equal to the `title` prop.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建了一个新的常量用于`title`属性，并将其传递给`SubHeader`组件。不再使用快照作为断言，而是创建一个新的快照，尝试找到`Title`组件，并检查该组件内的文本是否等于`title`属性。
- en: 'Next to the `title` prop, you can also test for the `goBack` (or `openForm`)
    prop. If this prop is present, a button will be rendered that has the `goBack`
    prop as an `onClick` event. This button is rendered as a `SubHeaderButton` component.
    Here, we need to change the second test scenario so that it has a mocked function
    for the `goBack` prop and then create an assertion to check for the existence
    of `SubHeaderButton` in the rendered component:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了“title” prop之外，您还可以测试“goBack”（或“openForm”）prop。如果存在这个prop，将渲染一个具有“goBack”
    prop作为“onClick”事件的按钮。这个按钮被渲染为“SubHeaderButton”组件。在这里，我们需要改变第二个测试场景，使其具有“goBack”
    prop的模拟函数，然后创建一个断言来检查渲染组件中“SubHeaderButton”的存在：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Not only do we want to test whether the button with the `goBack` prop is being
    rendered, but we also want to test whether this function is being called once
    we click on the button. Just like we did for the `Button` component test, we can
    simulate a click event and check whether the mocked `goBack` function was called:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不仅要测试带有“goBack” prop的按钮是否被渲染，还要测试一旦我们点击按钮，这个函数是否被调用。就像我们为“Button”组件测试所做的那样，我们可以模拟点击事件并检查模拟的“goBack”函数是否被调用：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The same can be done for the `openForm` prop if we replace the assertion that''s
    testing the snapshot with two assertions that test for the existence of the button
    and if it fired the mocked `openForm` function. Instead of adding this to the
    existing test scenario, we can extend the test scenario for the `goBack` button:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们用两个断言替换测试快照的断言，测试按钮的存在以及它是否触发了模拟的“openForm”函数，那么对于“openForm” prop也可以做同样的事情。我们可以将这个添加到现有的测试场景中，也可以扩展“goBack”按钮的测试场景：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The component that is now being rendered for the `SubHeader` should have both
    a button to go back to the previous page and a button to open the form. However,
    they''re both using the `SubHeaderButton` component to render. The button to go
    back is rendered in the component tree first since it''s placed on the left-hand
    side of `SubHeader`. Therefore, we need to specify which rendered `SubHeaderButton` is
    which button:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为“SubHeader”渲染的组件应该同时具有一个按钮返回到上一页和一个按钮打开表单。然而，它们都使用“SubHeaderButton”组件进行渲染。返回按钮首先在组件树中进行渲染，因为它位于“SubHeader”的左侧。因此，我们需要指定哪个渲染的“SubHeaderButton”是哪个按钮：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After these changes, all the test scenarios that use snapshots are removed and
    replaced with more concrete tests that are less vulnerable once we change any
    of the code. Apart from snapshots, these tests will keep working if we change
    any props that make refactoring easier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，所有使用快照的测试场景都被移除，并替换为更具体的测试，一旦我们改变了任何代码，它们就会变得不太脆弱。除了快照，这些测试将在我们改变任何使重构更容易的props时继续工作。
- en: In this section, we've created unit tests that will test a specific part of
    our code. However, it can be interesting to test how different parts of our code
    work together. For this, we'll add integration tests to our project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经创建了单元测试，用于测试我们代码的特定部分。然而，测试不同部分的代码如何一起工作可能会很有趣。为此，我们将向我们的项目添加集成测试。
- en: Integration testing with Enzyme
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Enzyme进行集成测试
- en: 'The tests that we''ve created all use shallow rendering to render components,
    but, with Enzyme, we also have the option to mount components. When using this,
    we can enable lifecycles and test larger components deeper than just the first
    level. When we want to test multiple components at once, this is called integration
    testing. In our application, the components that are rendered directly by the
    routes are rendering other components as well. A good example of this is the `Hotels` component,
    which renders the list of hotels that were returned by the Context. Let''s get
    started:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的所有测试都使用浅渲染来渲染组件，但是在Enzyme中，我们也有选项来挂载组件。使用这个选项时，我们可以启用生命周期并测试比第一级更深的更大的组件。当我们想一次测试多个组件时，这被称为集成测试。在我们的应用程序中，由路由直接渲染的组件也会渲染其他组件。`Hotels`组件就是一个很好的例子，它渲染了上下文返回的酒店列表。让我们开始吧：
- en: 'As always, the starting point is to create a new file with the `.test` suffix
    in the same directory that the component we want to test is located. Here, we
    need to create the `Hotels.test.js` file in the `src/components/Hotels` directory.
    In this file, we need to import `mount` from Enzyme, import the component that
    we want to test, and create a new test scenario:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，起点是在与要测试的组件位于同一目录中创建一个带有`.test`后缀的新文件。在这里，我们需要在`src/components/Hotels`目录中创建`Hotels.test.js`文件。在这个文件中，我们需要从Enzyme中导入`mount`，导入我们要测试的组件，并创建一个新的测试场景：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '2\. The `Hotels` component is using the `useContext` Hook to get the data it
    needs to display the hotels. However, since this is a test for this specific component,
    that data needs to be mocked. Before we can mock this data, we need to create
    a mock function for the `useContext` Hook. If we have multiple test scenarios
    that use this mock, we also need to use the `beforeEach` and `afterEach` methods
    to create and reset this mock function for every scenario:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 2. `Hotels`组件使用`useContext` Hook来获取显示酒店所需的数据。然而，由于这是针对特定组件的测试，该数据需要被模拟。在我们可以模拟这些数据之前，我们需要为`useContext`
    Hook创建一个模拟函数。如果我们有多个使用此模拟的测试场景，我们还需要使用`beforeEach`和`afterEach`方法为每个场景创建和重置这个模拟函数。
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now use the mocked `useContextMock` function to generate the data that
    will be used as a mock for the Context by the `Hotels` component. The data that
    will be returned should also be mocked, which can be done by invoking the `mockReturnValue` function,
    which is available on the mocked function. If we take a look at the actual code
    for the `Hotels` component, we will see that it takes four values from the Context: `loading`,
    `error`, `hotels`, and `getHotelsRequest`. These values should be mocked and returned
    by `mockReturnValue` in the first test scenario that we will create to check the
    behavior when the Context is loading the hotels'' data:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用模拟的`useContextMock`函数来生成将用作上下文的模拟数据，该数据将由`Hotels`组件使用。将返回的数据也应该是模拟的，可以通过调用可用于模拟函数的`mockReturnValue`函数来实现。如果我们看一下`Hotels`组件的实际代码，我们会发现它从上下文中获取了四个值：`loading`，`error`，`hotels`和`getHotelsRequest`。这些值应该在我们将创建的第一个测试场景中被模拟和返回，以检查上下文在加载酒店数据时的行为：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This first test scenario checks whether the `Hotels` component will call the
    `getHotelsRequest` function from the Context when it first mounts. This means
    that the `useEffect` Hook that's used in `Hotels` has been tested.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个测试场景检查了`Hotels`组件在首次挂载时是否会调用上下文中的`getHotelsRequest`函数。这意味着在`Hotels`中使用的`useEffect`
    Hook已经经过了测试。
- en: 'Since the data is still loading here, we can also test whether the `Alert` component
    is rendering the `loading` value from the Context and displaying a loading message.
    Here, we need to export this component from `Hotels` in `src/components/Hotels/Hotels.js`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据仍在加载中，我们还可以测试`Alert`组件是否从上下文中渲染了`loading`值并显示了加载消息。在这里，我们需要从`src/components/Hotels/Hotels.js`中导出这个组件：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we can import this component in the test file and write the assertion
    to check whether it''s displaying the value from the Context:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在测试文件中导入这个组件，并编写断言来检查它是否显示了来自上下文的值：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After the `Hotels` component has mounted and the data has been fetched, the
    values for `loading`, `error`, and `hotels` in the Context will be updated. When
    the values for `loading` and `error` are `false`, the `HotelItemsWrapper` component
    will be rendered by `Hotels`. To test this, we need to export `HotelItemsWrapper` from
    `Hotels`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Hotels`组件挂载并且数据被获取后，上下文中的`loading`、`error`和`hotels`的值将被更新。当`loading`和`error`的值为`false`时，`HotelItemsWrapper`组件将被`Hotels`渲染。为了测试这一点，我们需要从`Hotels`中导出`HotelItemsWrapper`：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the testing file, this component can now be imported, which means we can
    add the new test scenario that checks whether this component is being rendered:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件中，现在可以导入这个组件，这意味着我们可以添加新的测试场景，检查这个组件是否被渲染：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, when we run the test, we''ll get an error saying `Invariant failed: You
    should not use <Link> outside a <Router>` since Enzyme can''t render the `Link` component,
    which is used to navigate when we click on a hotel. Due to this, we need to wrap
    the `Hotels` component within a router component from `react-router`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行测试时，会出现错误，显示“不变式失败：您不应该在<Router>之外使用<Link>”，因为Enzyme无法渲染`Link`组件，这是我们点击酒店时用来导航的。因此，我们需要将`Hotels`组件包装在`react-router`的路由器组件中：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This test will now pass, as Enzyme can render the component, including the `Link` to
    navigate to a hotel.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试现在会通过，因为Enzyme可以渲染组件，包括`Link`来导航到酒店。
- en: 'Inside the `HotelItemsWrapper` component is a `map` function that iterates
    over the hotel data from the Context. For every iteration, a `HotelItem` component
    will be rendered. In these `HotelItem` components, the data will be displayed
    in, for instance, a `Title` component. We can test whether the data that will
    be displayed in these components is equal to the mocked Context data. The component
    that displays the title of the hotel should be exported from `src/components/Hotels/HotelItem.js`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HotelItemsWrapper`组件内部是一个`map`函数，它遍历来自上下文的酒店数据。对于每次迭代，都会渲染一个`HotelItem`组件。在这些`HotelItem`组件中，数据将以某种方式显示，例如一个`Title`组件。我们可以测试这些组件中将显示的数据是否等于模拟的上下文数据。显示酒店标题的组件应该从`src/components/Hotels/HotelItem.js`中导出。
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Along with the `HotelItem` component, this should be imported into the test
    for `Hotels`. In the test scenario, we can now check for the existence of the
    `<HotelItem` component and check whether this component has a `Title` component.
    The value that''s displayed by this component should be equal to the mocked Context
    value for the title of the first row in the array of `hotels`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`HotelItem`组件，这应该被导入到`Hotels`的测试中。在测试场景中，我们现在可以检查`<HotelItem`组件是否存在，并检查这个组件是否有`Title`组件。这个组件显示的值应该等于数组`hotels`中第一行的标题的模拟上下文值：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After running the tests again with the `--coverage` flag, we will be able to
    see what impact writing this integration test has on our coverage. Since an integration
    test not only tests one specific component but multiple at once, the testing coverage
    for `Hotels` will be updated. This test also covers the `HotelItem` component,
    which we will be able to see in the coverage report after running `npm run test
    --coverage`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`--coverage`标志再次运行测试之后，我们将能够看到编写此集成测试对我们的覆盖率产生了什么影响。由于集成测试不仅测试一个特定的组件，而是一次测试多个组件，因此`Hotels`的测试覆盖率将得到更新。此测试还涵盖了`HotelItem`组件，我们将能够在运行`npm
    run test --coverage`后的覆盖率报告中看到这一点：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The coverage for `Hotels` is close to 100%. The test coverage for `HotelItems` has
    also got to 100%. This means that we can skip writing unit tests for `HotelItem`,
    assuming that we only use this component within the `Hotels` component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hotels`的覆盖率接近100%。`HotelItems`的测试覆盖率也达到了100%。这意味着我们可以跳过为`HotelItem`编写单元测试，假设我们只在`Hotels`组件中使用此组件。'
- en: The only downside of having integration tests over unit tests is that they're
    harder to write as they usually contain more complex logic. Also, these integration
    tests will run slower than unit tests because of them having more logic and bringing
    together multiple components.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于单元测试，集成测试的唯一缺点是它们更难编写，因为它们通常包含更复杂的逻辑。此外，由于集成测试具有更多的逻辑并将多个组件组合在一起，因此这些集成测试将运行得更慢。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered testing for React applications using Jest in combination
    with either `react-test-renderer` or Enzyme. Both packages are a great resource
    to every developer that wants to add test scripts to their application, and they
    also work well with React. The advantages of having tests for your application
    were discussed in this chapter, and hopefully, you now know how to add test scripts
    to any project. Also, the differences between unit tests and integration tests
    were shown.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Jest结合`react-test-renderer`或Enzyme进行React应用程序测试。这两个软件包对于希望为其应用程序添加测试脚本的每个开发人员都是很好的资源，它们也与React很好地配合。本章讨论了为应用程序编写测试的优势，希望现在您知道如何为任何项目添加测试脚本。还展示了单元测试和集成测试之间的区别。
- en: Since the application that was tested in this chapter has the same structure
    as the applications from the previous chapters, the same testing principles can
    be applied to any of the applications we've built in this book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章中测试的应用程序与前几章的应用程序具有相同的结构，因此可以将相同的测试原则应用于本书中构建的任何应用程序。
- en: The next chapter will combine a lot of the patterns and libraries we've already
    used in this book as we'll be creating a full-stack e-commerce store with React,
    GraphQL, and Apollo.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将结合本书中已经使用过的许多模式和库，因为我们将使用React、GraphQL和Apollo创建一个全栈电子商务商店。
- en: Further reading
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Enzyme shallow rendering: [https://airbnb.io/enzyme/docs/api/shallow.html](https://airbnb.io/enzyme/docs/api/shallow.html)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enzyme浅渲染：[https://airbnb.io/enzyme/docs/api/shallow.html](https://airbnb.io/enzyme/docs/api/shallow.html)
- en: Enzyme mount: [https://airbnb.io/enzyme/docs/api/mount.html](https://airbnb.io/enzyme/docs/api/mount.html)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enzyme挂载：[https://airbnb.io/enzyme/docs/api/mount.html](https://airbnb.io/enzyme/docs/api/mount.html)
