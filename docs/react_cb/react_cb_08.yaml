- en: Creating an API with Node.js Using MongoDB and MySQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js和MongoDB、MySQL创建API
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下配方：
- en: Creating a basic API with Express
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express创建一个基本的API
- en: Building a database with MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用MongoDB构建数据库
- en: Building a database with MySQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用MySQL构建数据库
- en: Adding access tokens to secure our API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加访问令牌以保护我们的API
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'From the Node.js official website ([https://nodejs.org](https://nodejs.org)):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从Node.js官方网站([https://nodejs.org](https://nodejs.org))：
- en: '*Node.js is a JavaScript runtime built on Chrome''s V8 JavaScript engine. Node.js
    uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
    Node.js'' package ecosystem, npm, is the largest ecosystem of open source libraries
    in the world.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node.js是建立在Chrome的V8 JavaScript引擎上的JavaScript运行时。Node.js使用事件驱动的、非阻塞的I/O模型，使其轻量高效。Node.js的包生态系统npm是世界上最大的开源库生态系统。*'
- en: Node.js is widely used as a backend for web applications because it is easy
    to create an API and its performance is better than technologies such as Java,
    PHP, or Ruby. Usually, the most popular way to use Node.js is by using a framework
    called Express.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js广泛用作Web应用程序的后端，因为它很容易创建API，并且其性能优于Java、PHP或Ruby等技术。通常，使用Node.js最流行的方式是使用一个叫做Express的框架。
- en: 'From Express official website ([https://expressjs.com](https://expressjs.com)):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Express官方网站([https://expressjs.com](https://expressjs.com))：
- en: '*Express is a minimal and flexible Node.js web application framework that provides
    a robust set of features for web and mobile applications.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Express是一个最小化和灵活的Node.js Web应用程序框架，为Web和移动应用程序提供了强大的功能集。*'
- en: Creating a basic API with Express
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express创建一个基本的API
- en: Express is the most popular Node.js framework and is easy to install and to
    use. In this recipe we are going to create, configure, and install a basic API
    using Express.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Express是最流行的Node.js框架，安装和使用都很容易。在这个配方中，我们将使用Express创建、配置和安装一个基本的API。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to install Node. You need to go to the official website, [www.nodejs.org](http://www.nodejs.org),
    and then download Node.js. There are two versions: the **LTS** (**Long Term Support**)
    version and the current version, which has the latest features. In my opinion,
    it is always better to choose the LTS version, but it''s up to you.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装Node。你需要去官方网站[www.nodejs.org](http://www.nodejs.org)，然后下载Node.js。有两个版本：**LTS**（长期支持）版本和当前版本，具有最新功能。在我看来，选择LTS版本总是更好，但这取决于你。
- en: 'Once you have installed Node, you can check which version you have by running
    this command in your Terminal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了Node，你可以在终端中运行这个命令来检查你的版本：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, Node includes Node Package Manager (npm) by default. You can check which
    version you have with this command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Node默认包含Node Package Manager (npm)。你可以用这个命令检查你的版本：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we need to install Express. To do this, there is a package called `express-generator`,
    which will allow us to create an Express application with a simple command. We
    need to install it globally:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装Express。为了做到这一点，有一个叫做`express-generator`的包，它将允许我们用一个简单的命令创建一个Express应用程序。我们需要全局安装它：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we installed `express-generator`, we can create an Express application.
    I usually prefer to create a directory called `projects` inside my home folder
    on my Mac, or if you use Windows, you can make it at `C:\projects`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装了`express-generator`之后，我们可以创建一个Express应用程序。我通常喜欢在我的Mac的主文件夹内创建一个名为`projects`的目录，或者如果你使用Windows，你可以在`C:\projects`下创建它：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you run the command, you will see something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了这个命令，你会看到类似这样的东西：
- en: '![](assets/0bccf184-aa0c-4f1f-b259-cd47fab12921.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0bccf184-aa0c-4f1f-b259-cd47fab12921.png)'
- en: 'If you follow the instructions to run the application, you will see the Express
    application running at `http://localhost:3000`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照运行应用程序的说明，你会看到Express应用程序在`http://localhost:3000`上运行：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see this view:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个视图：
- en: '![](assets/3d25ab16-c785-45b9-a461-48372d15b22e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d25ab16-c785-45b9-a461-48372d15b22e.png)'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The code generated by default with `express-generator` is ES5 code, using `var`,
    `require`, `module.exports`, and so on:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下由`express-generator`生成的代码是ES5代码，使用`var`，`require`，`module.exports`等：
- en: 'The first thing we need to do is convert this code to be ES6\. To do this,
    let''s first modify our `app.js` file. This is the original code of this file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将这段代码转换为ES6。为了做到这一点，让我们首先修改我们的`app.js`文件。这是该文件的原始代码：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'File: app.js'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：app.js
- en: 'Migrating to ES6, we should have this code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移到ES6，我们应该有这段代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'File: app.js'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：app.js
- en: 'Now let''s remove our `bin/www`directory because we had added `app.listen(3000);`
    at the end of our file, and then you need to modify the `start` script in `package.json`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们删除我们的`bin/www`目录，因为我们在文件末尾添加了`app.listen(3000);`，然后你需要修改`package.json`中的`start`脚本：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'File: package.json'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：package.json
- en: 'If you try to run your application with `npm start` you will get this error:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试用`npm start`运行你的应用程序，你会得到这个错误：
- en: '![](assets/5a034ddd-3709-48a5-9351-cb80a902b114.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a034ddd-3709-48a5-9351-cb80a902b114.png)'
- en: 'This error is because our ES6 code does not work directly with Node. We need
    to use Babel to compile our file and be able to write ES6 code. For this, we need
    to install `babel-cli` globally and also the `babel-preset-es2015` package:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个错误是因为我们的ES6代码不能直接与Node一起工作。我们需要使用Babel来编译我们的文件，以便能够编写ES6代码。为此，我们需要全局安装`babel-cli`，还需要安装`babel-preset-es2015`包：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To make it work, we need to create a new file called `.babelrc` and add our
    `es2015` preset:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它工作，我们需要创建一个名为`.babelrc`的新文件，并添加我们的`es2015`预设：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'File: .babelrc'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：.babelrc
- en: 'Now you need to change your `start` script again and switch `node` to `babel-node`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你需要再次修改你的`start`脚本，并将`node`切换为`babel-node`：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'File: package.json'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：package.json
- en: If you run `npm start` in your terminal, you should be able to run the application
    now.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在终端中运行`npm start`，你现在应该能够运行应用程序了。
- en: 'After we have changed our code to ES6, we have another issue. If you modify
    a file and you save it in the application, it will not refresh. Also, if for some
    reason our application crashes, then our server will stop working. The way to
    fix this is by using a Node watcher. The most popular one is `nodemon`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将代码更改为ES6后，我们遇到了另一个问题。如果你修改一个文件并在应用程序中保存它，它不会刷新。而且，如果由于某种原因我们的应用程序崩溃，那么我们的服务器将停止工作。解决这个问题的方法是使用一个Node监视器。最流行的是`nodemon`：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You need to modify your `start` script for this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要修改你的`start`脚本：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'File: package.json'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：package.json
- en: 'Now if you make any changes to your application (for example, in the `routes/index.js`
    file, you can change the text `Express` on line 6  for any other content), you
    will see how the server restarts itself and refreshes the site:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你对应用程序进行任何更改（例如，在`routes/index.js`文件中，你可以更改第6行的`Express`文本为任何其他内容），你会看到服务器如何重新启动并刷新网站：
- en: '![](assets/2bd39c52-2994-49e6-8e43-e8de87d81b20.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2bd39c52-2994-49e6-8e43-e8de87d81b20.png)'
- en: 'As you can see, the first message in green says `starting babel-node app.js`, and
    then when it detects a change, it says restarting due to changes... Now we can
    see the changes reflected in our site:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，绿色的第一条消息说`starting babel-node app.js`，然后当它检测到变化时，它会说`restarting due
    to changes...`现在我们可以看到我们网站上的变化：
- en: '![](assets/fc5a2047-a2e5-48b4-a685-05bf7d847395.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc5a2047-a2e5-48b4-a685-05bf7d847395.png)'
- en: 'Because our Express application was created to be an API instead of a regular
    website, we need to remove many things that are superfluous, such as the `views`
    folder and the template engine, and we need to make some structural changes to
    make it easier to handle. Let''s see what our `app.js` file looks like now:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们的Express应用程序是为了成为API而不是常规网站而创建的，所以我们需要删除许多多余的东西，比如`views`文件夹和模板引擎，我们需要进行一些结构上的改变，以便更容易处理。让我们看看我们的`app.js`文件现在是什么样子的：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'File: app.js'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：app.js
- en: 'As you can see, I renamed the `routes` directory to `controllers`, and also
    I deleted the `users.js` file that was in that folder, and I renamed the `index.js`
    as `api.js`. Let''s create an API to handle a blog:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我将`routes`目录重命名为`controllers`，并且我还删除了该目录中的`users.js`文件，并将`index.js`重命名为`api.js`。让我们创建一个处理博客的API：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'File: controllers/api.js'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：controllers/api.js
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now let''s test our new API:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的新API：
- en: 'If we go to `http://localhost:3000/api`, we are going to display a list of
    the endpoints. This is optional, but it is useful as a reference for developers:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们转到`http://localhost:3000/api`，我们将显示一个端点列表。这是可选的，但对开发人员来说是一个有用的参考：
- en: '![](assets/d0a3ea05-5b03-4b31-a25b-650b1df4baaf.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0a3ea05-5b03-4b31-a25b-650b1df4baaf.png)'
- en: 'If you go to `http://localhost:3000/api/posts`, you will see all the posts:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您转到`http://localhost:3000/api/posts`，您将看到所有的帖子：
- en: '![](assets/f53337e7-16a7-4f0c-b051-fc8d9d39d892.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f53337e7-16a7-4f0c-b051-fc8d9d39d892.png)'
- en: 'Also, if you hit `http://localhost:3000/api/post/1`, you will get the first
    post of the list:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，如果您访问`http://localhost:3000/api/post/1`，您将得到列表中的第一篇帖子：
- en: '![](assets/e350206c-a69c-4404-8668-e4e171a583d1.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e350206c-a69c-4404-8668-e4e171a583d1.png)'
- en: 'Finally, if you try to get a post that does not exist in our data (`http://localhost:3000/api/post/99`),
    then we will return an error:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果您尝试获取我们数据中不存在的帖子（`http://localhost:3000/api/post/99`），那么我们将返回一个错误：
- en: '![](assets/f18f6765-805f-40c1-9916-223f2f709645.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f18f6765-805f-40c1-9916-223f2f709645.png)'
- en: Building a database with MongoDB
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB构建数据库
- en: MongoDB is the most popular NoSQL database. It is free (open source) and document-oriented.
    In this recipe, we are going to install MongoDB, create a database, create a document,
    and insert some data to display information with Node.js using the Mongoose library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是最流行的NoSQL数据库。它是免费的（开源）和面向文档的。在这个教程中，我们将安装MongoDB，创建一个数据库，创建一个文档，并插入一些数据，以便使用Node.js和Mongoose库显示信息。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: First, we need to install MongoDB. In this recipe, I'm going to show you the
    easiest way to install it using Mac, and I'll give you some links to install it
    if you have Linux or Windows.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装MongoDB。在这个教程中，我将向您展示使用Mac安装它的最简单的方法，并且我会给您一些链接，以便在Linux或Windows上安装它。
- en: '**From the MongoDB official documentation** ([https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x))**:** "Starting
    in version 3.0, MongoDB only supports MacOS version 10.7 (Lion) and later on Intel
    x86-64."'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自MongoDB官方文档**（[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x)）**：**“从3.0版本开始，MongoDB只支持MacOS版本10.7（狮子）及更高版本的Intel
    x86-64。”'
- en: Installing MongoDB Community Edition manually (the hard way)
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动安装MongoDB社区版（困难的方法）
- en: 'This installation works for Mac and Linux:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个安装适用于Mac和Linux：
- en: Download the binary files for the version you want of MongoDB from [https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community)下载您想要的MongoDB版本的二进制文件。
- en: 'Extract the files from the downloaded file; you can use the terminal and use
    this command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载的文件中提取文件；您可以使用终端并使用以下命令：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Copy the extracted folder to the location from which MongoDB will run:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提取的文件夹复制到MongoDB将运行的位置：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Ensure the location of the binaries is in the `PATH` variable. You can add
    the following line in your shell''s `rc` file, such as `~/.bashrc` or `~/.bash_profile`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保二进制文件的位置在`PATH`变量中。您可以在您的shell的`rc`文件中添加以下行，比如`~/.bashrc`或`~/.bash_profile`：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Installing MongoDB Community Edition with Homebrew (the easy way)
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Homebrew安装MongoDB社区版（简单方法）
- en: 'Homebrew is a package manager for Mac (*also known as the missing package manager
    for macOS*) and is easy to install. Go to the official website (https://brew.sh),
    and there you will find a command that you should run to install it, which is
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew是Mac的软件包管理器（*也被称为macOS的缺失软件包管理器*），并且很容易安装。前往官方网站（https://brew.sh），在那里您会找到一个您应该运行以安装它的命令，如下所示：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you have Homebrew already installed, or if you just installed it, then the
    first thing you need to do is to update the package database with this command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经安装了Homebrew，或者刚刚安装了它，那么您需要做的第一件事就是使用以下命令更新软件包数据库：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we need to install MongoDB using this command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要使用以下命令安装MongoDB：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to install the latest development version of MongoDB, then you
    should run this command (I don''t recommend it because it may have some bugs that
    are not fixed yet, but it is up to you):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要安装MongoDB的最新开发版本，那么您应该运行此命令（我不建议这样做，因为它可能有一些尚未修复的错误，但这取决于您）：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running MongoDB
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行MongoDB
- en: 'Before we start MongoDB for the first time, we need to create a directory in
    which the *mongod* process will write the data:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次启动MongoDB之前，我们需要创建一个目录，*mongod*进程将在其中写入数据：
- en: 'By default, the mongod process uses the `/data/db` directory. To create this
    folder, you can use the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，mongod进程使用`/data/db`目录。要创建此文件夹，您可以使用以下命令：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to set permissions for the data directory:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为数据目录设置权限：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In a new terminal (or tab) you need to run the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的终端（或选项卡）中，您需要运行以下命令：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you didn''t get an error, you could start the Mongo shell on the same host
    machine as *mongod* (in a new terminal or tab):'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有遇到错误，您可以在与*mongod*相同的主机机器上启动Mongo shell（在新的终端或选项卡中）：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you get an error like this: *Error: Port number 127017 out of range parsing
    HostAndPort from "127.0.0.1:127017"*, then just run `mongo` without `--host` flag.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您遇到这样的错误：*Error: Port number 127017 out of range parsing HostAndPort from
    "127.0.0.1:127017"*，那么只需运行`mongo`而不带`--host`标志。'
- en: Finally, if you want to stop MongoDB, press *Ctrl* + *C* in the terminal that `mongod`
    is running.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果您想要停止MongoDB，在运行`mongod`的终端中按下*Ctrl* + *C*。
- en: 'If everything works, you should see this in your Terminal:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果一切正常，您应该在终端中看到这个： '
- en: '![](assets/1c552831-d61e-4124-85f2-a51f3c571b30.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1c552831-d61e-4124-85f2-a51f3c571b30.png)'
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we need to create a new database:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的数据库：
- en: 'To create a new database or switch to an existing database, you need to run: `use
    <name of the database>`. Let''s create a blog database:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的数据库或切换到现有的数据库，您需要运行：`use <name of the database>`。让我们创建一个博客数据库：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we need to create a collection called *posts*, and you need to save the
    data directly in JSON format using the `db.<your-collection-name>.save({})` command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个名为*posts*的集合，并且您需要直接以JSON格式保存数据，使用`db.<your-collection-name>.save({})`命令：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, I''m not adding any `id` value, and that is because MongoDB
    automatically creates a unique ID for each row called `_id`, which is a random
    hash. If you want to see the data that you just saved, you need to use the `find()`
    method without any parameters:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我没有添加任何`id`值，这是因为MongoDB会自动为每一行创建一个名为`_id`的唯一ID，这是一个随机哈希。如果您想要查看刚刚保存的数据，您需要使用不带任何参数的`find()`方法：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see your data like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到您的数据如下所示：
- en: '![](assets/84051594-8bc2-498f-a098-fbb7821c8225.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/84051594-8bc2-498f-a098-fbb7821c8225.png)'
- en: 'Now let''s suppose you add a new row for Post 2 and you want to find that specific
    row by specifying the slug (post-2). You can do it like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设您添加了一个新的帖子2行，并且您想通过指定slug（post-2）找到该特定行。您可以这样做：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到这个：
- en: '![](assets/251b9d46-2fa3-44b0-8747-1efa66091936.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/251b9d46-2fa3-44b0-8747-1efa66091936.png)'
- en: 'Now let''s change the Post 2 title to My Updated Post 2\. To do this, we need
    to update our row as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将帖子2的标题更改为My Updated Post 2。为此，我们需要按照以下方式更新我们的行：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first parameter is the query to find the row we want to update, and the
    second one modifies the fields using `$set`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是查询要更新的行，第二个参数使用`$set`修改字段。
- en: 'Finally, if we want to remove a specific row, we can do it as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果我们想要删除特定的行，可以按照以下步骤进行：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The recommended way to remove a row is by specifying the `_id` directly to
    avoid deleting other rows by mistake but is also possible to delete a row by any
    other field. For example, let''s say you want to remove Post 1 using the slug.
    You can do it like this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除行的推荐方法是直接指定`_id`以避免错误删除其他行，但也可以通过任何其他字段删除行。例如，假设您想使用slug删除帖子1。您可以这样做：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that you have learned how to do basic operations with MongoDB let''s implement
    MongoDB into Node.js using the Mongoose library, which is an **Object Document
    Mapper** (**ODM**) for Node. We need to install some extra packages for this recipe:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用MongoDB进行基本操作，让我们使用Mongoose库将MongoDB实现到Node.js中，这是一个**对象文档映射器**（**ODM**）。我们需要为此示例安装一些额外的包：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the same code as the previous recipe (`Repository: Chapter08/Recipe1/my-first-express-app`),
    we are going to connect Mongoose to Node.js. The first thing we need to do is
    to modify `app.js`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用与上一个示例相同的代码（`Repository: Chapter08/Recipe1/my-first-express-app`），我们将连接Mongoose到Node.js。我们需要做的第一件事是修改`app.js`：'
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'File: app.js'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：app.js
- en: 'Now that we have Mongoose connected to our database we need to create a model
    to handle our blog posts. To do this, you will need to create a `src/models/blog.js` file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将Mongoose连接到我们的数据库，我们需要创建一个模型来处理我们的博客帖子。为此，您需要创建一个`src/models/blog.js`文件：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'File: src/models/blog.js'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/models/blog.js
- en: 'Now to handle our model we need to create a new controller (`src/controllers/blog.js`)
    where we are going to add methods to save, update, remove, find all posts, or
    find a single post:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了处理我们的模型，我们需要创建一个新的控制器（`src/controllers/blog.js`），在那里我们将添加保存、更新、删除、查找所有帖子或查找单个帖子的方法：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: File: src/controllers/blog.js
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/controllers/blog.js
- en: 'Finally, we are going to modify our API controller (`src/controllers/api.js`)
    to remove the fake data we created in the last recipe and get the data from the
    actual MongoDB database:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将修改我们的API控制器（`src/controllers/api.js`）以删除我们在上一个示例中创建的虚假数据，并从实际的MongoDB数据库获取数据：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: File: src/controllers/api.js
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/controllers/api.js
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You need to install Postman ([https://www.getpostman.com](https://www.getpostman.com))
    or any other REST client to test the API. Mainly for a `POST`, `PUT` and `DELETE`
    methods, the GET method can be easily verified on any browser.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装Postman（[https://www.getpostman.com](https://www.getpostman.com)）或任何其他REST客户端来测试API。主要用于`POST`、`PUT`和`DELETE`方法，`GET`方法可以在任何浏览器上轻松验证。
- en: GET method endpoints
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET方法端点
- en: '**GET /posts**. This endpoint can be tested with your browser. Go to `http://localhost:3000/api/posts`.
    I have manually inserted three rows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET /posts**。此端点可以在浏览器中测试。转到`http://localhost:3000/api/posts`。我手动插入了三行：'
- en: '![](assets/2c0ae937-b138-4923-8dcb-7a06f19a511d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2c0ae937-b138-4923-8dcb-7a06f19a511d.png)'
- en: 'If you want to test it on Postman, then write the same URL (`http://localhost:3000/api/posts`),
    select the `GET` method, and click on the Send button:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Postman上进行测试，那么请写入相同的URL（`http://localhost:3000/api/posts`），选择`GET`方法，并点击发送按钮：
- en: '![](assets/2d201617-225a-45bc-833b-e0a05c1f13fe.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d201617-225a-45bc-833b-e0a05c1f13fe.png)'
- en: '**GET /post/:slug**. This endpoint is also a `GET`, and you need to pass the
    slug (friendly URL) on the URL. For example, the slug of the first row, My blog
    post 1, is my-blog-post-1\. A slug is a friendly URL that has the same value of
    a title but in lowercase, without special characters, and with the spaces replaced
    with dashes (-). In our model, we defined our slug as a unique field. That means
    there cannot be more than one post with the same slug.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET /post/:slug**。此端点也是`GET`，您需要在URL上传递slug（友好的URL）。例如，第一行的slug，My blog post
    1，是my-blog-post-1。slug是一个友好的URL，其值与标题相同，但是小写，没有特殊字符，并且空格用破折号（-）替换。在我们的模型中，我们将slug定义为唯一字段。这意味着不能有多个具有相同slug的帖子。'
- en: 'Let''s go to `http://localhost:3000/api/post/my-blog-post-1` in the browser.
    If the slug exists in the database you will see the information:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中转到`http://localhost:3000/api/post/my-blog-post-1`。如果数据库中存在slug，您将看到信息：
- en: '![](assets/5a1720d4-76a4-4571-a0eb-d649da2976c7.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a1720d4-76a4-4571-a0eb-d649da2976c7.png)'
- en: 'But if you try to find a slug that does not exist in the database you will
    get this error:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您尝试查找数据库中不存在的slug，您将收到此错误：
- en: '![](assets/85d62104-76d1-4dc7-b4c2-cb81ba1a44ac.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85d62104-76d1-4dc7-b4c2-cb81ba1a44ac.png)'
- en: POST method endpoints
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST方法端点
- en: The `POST` method is typically used when we want to insert new data into our
    database.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`方法通常用于在数据库中插入新数据。'
- en: '**POST /post**. For this endpoint, we need to use Postman to be able to send
    the data through the body. To do this, you need to select the POST method in Postman.
    Use the URL `http://localhost:3000/api/post`, then click on Headers, and you need
    to add the header `Content-Type` with the value `application/x-www-form-urlencoded`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST /post**。对于此端点，我们需要使用Postman能够通过body发送数据。为此，您需要在Postman中选择POST方法。使用URL
    `http://localhost:3000/api/post`，然后点击Headers，并且您需要添加带有值`application/x-www-form-urlencoded`的标头`Content-Type`：'
- en: '![](assets/48486a95-e81b-4834-b0a1-cef74fab6fde.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48486a95-e81b-4834-b0a1-cef74fab6fde.png)'
- en: 'After you set the header, then go to the Body tab and select the raw option,
    and you can send the information like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 设置标头后，转到Body选项卡并选择原始选项，然后可以发送以下信息：
- en: '![](assets/14e38988-f382-4259-84fe-26007f6573ac.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14e38988-f382-4259-84fe-26007f6573ac.png)'
- en: 'Now you can hit the Send button and see the response that the service returns:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以点击发送按钮并查看服务返回的响应：
- en: '![](assets/49ffd8e7-e8ae-4146-bb19-c1640fbf7b85.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/49ffd8e7-e8ae-4146-bb19-c1640fbf7b85.png)'
- en: 'If you did everything correctly, you should get a response with the saved node set
    to true and the *post* node containing information about the saved post. Now if
    you try to hit the *Send* button again with the same data (the same title), it
    will cause an error because, as you remember, our slug must be unique:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您做的一切正确，您应该收到一个响应，其中保存的节点设置为true，*post*节点包含有关保存的帖子的信息。现在，如果您尝试再次使用相同的数据（相同的标题）点击*发送*按钮，它将导致错误，因为您记得，我们的slug必须是唯一的：
- en: '![](assets/a4f6552a-dc34-4125-b3e0-f88986e9be99.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a4f6552a-dc34-4125-b3e0-f88986e9be99.png)'
- en: You are probably wondering what the `__v` is if we haven't added that node directly.
    That is the `versionKey`, which is a property set on each document when it's first
    created by Mongoose. This key's value contains the internal revision of the document.
    You can change or remove the name of this document property. The default is `__v`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道`__v`是什么，如果我们没有直接添加该节点。那就是`versionKey`，它是Mongoose在每个文档第一次创建时设置的属性。该键的值包含文档的内部修订版本。您可以更改或删除此文档属性的名称。默认值为`__v`。
- en: 'If you want to change it, you can do something like this when you are defining
    a new schema:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更改它，可以在定义新模式时执行以下操作：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or if you want to remove it, you can pass `false` to the `versionKey`, but
    I don''t recommend doing that because you won''t have control on the version changes
    every time you update a document:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想要删除它，可以将`versionKey`传递为`false`，但我不建议这样做，因为每次更新文档时，您都无法控制版本更改：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: DELETE method endpoints
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE方法端点
- en: The `DELETE` method, as the name implies, is for deleting rows in a database.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`方法，顾名思义，是用于删除数据库中的行。'
- en: '**DELETE /post/:slug**. In Postman, we need to select the `DELETE` method,
    and in the URL you need to pass the slug of the post you want to remove. For example,
    let''s remove the post my-blog-post-2\. If you remove it correctly you should
    get a response with the removed node set to true:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**DELETE /post/:slug**。在Postman中，我们需要选择`DELETE`方法，并在URL中传递要删除的帖子的slug。例如，让我们删除帖子my-blog-post-2。如果您正确删除它，您应该会收到一个将删除的节点设置为true的响应：'
- en: '![](assets/d0b0a0a4-fdcb-43ad-9b0b-a3676a314193.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0b0a0a4-fdcb-43ad-9b0b-a3676a314193.png)'
- en: 'If you want to verify the post was deleted, you can go to the `/posts` endpoint
    again, and you will see that is not in the JSON anymore:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要验证帖子是否已删除，可以再次转到`/posts`端点，您将看到它不再在JSON中：
- en: '![](assets/85e32f89-e584-4979-96ae-14456006c218.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85e32f89-e584-4979-96ae-14456006c218.png)'
- en: PUT method endpoints
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT方法端点
- en: The last method is `PUT`, and it is typically used to update a row in a database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是`PUT`，通常用于更新数据库中的行。
- en: '**PUT /post/:slug**. In Postman you need to select the PUT method, then the
    URL of the post you want to edit. Let''s edit my-blog-post-3; the URL will be
    `http://localhost:3000/api/post/my-blog-post-3`. On the Headers tab, like in the
    `POST` method, you need to add a `Content-Type` header with the value application/x-www-form-urlencoded.
    In the Body tab, you send the new data you want to replace, in this case, a new
    title and new content:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUT /post/:slug**。在Postman中，您需要选择PUT方法，然后选择要编辑的帖子的URL。让我们编辑my-blog-post-3；URL将是`http://localhost:3000/api/post/my-blog-post-3`。在标题选项卡中，就像在`POST`方法中一样，您需要添加一个值为application/x-www-form-urlencoded的`Content-Type`标题。在Body选项卡中，您发送要替换的新数据，例如新标题和新内容：'
- en: '![](assets/a904f58d-2a3f-4f91-b336-55fc61f986b1.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a904f58d-2a3f-4f91-b336-55fc61f986b1.png)'
- en: 'If everything works fine, you should get this response:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该会收到这个响应：
- en: '![](assets/738bb7f1-eb5d-436d-992e-5644307bf71b.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/738bb7f1-eb5d-436d-992e-5644307bf71b.png)'
- en: 'Again, if you want to verify the post was updated correctly then go to the
    `/posts` endpoint in your browser:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您想要验证帖子是否已正确更新，请转到浏览器中的`/posts`端点：
- en: '![](assets/525231bf-fb84-4def-a8f1-2311d0512ded.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/525231bf-fb84-4def-a8f1-2311d0512ded.png)'
- en: As you can see, the post title, content, and slug were updated correctly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，帖子标题、内容和slug已正确更新。
- en: Building a database with MySQL
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MySQL构建数据库
- en: 'MySQL is the most popular database. It''s an open source Relational Database
    Management System (RDBMS). MySQL normally is a central component of the LAMP (Linux,
    Apache, MySQL, PHP/ Python/ Perl) stack; many bundles include MySQL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL是最受欢迎的数据库。它是一个开源的关系数据库管理系统（RDBMS）。MySQL通常是LAMP（Linux，Apache，MySQL，PHP/Python/Perl）堆栈的核心组件；许多捆绑包都包括MySQL：
- en: AMPPS (Max, Linux, and Windows) – [https://www.ampps.com](https://www.ampps.com)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMPPS（Max，Linux和Windows） - [https://www.ampps.com](https://www.ampps.com)
- en: XAMPP (Mac, Linux, and Windows) – [https://www.apachefriends.org](https://www.apachefriends.org)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAMPP（Mac，Linux和Windows） - [https://www.apachefriends.org](https://www.apachefriends.org)
- en: WAMP Server (Windows) – [http://www.wampserver.com](http://www.wampserver.com)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAMP Server（Windows） - [http://www.wampserver.com](http://www.wampserver.com)
- en: MAMP (Mac) – [https://www.mamp.info](https://www.mamp.info)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAMP（Mac） - [https://www.mamp.info](https://www.mamp.info)
- en: Other developers prefer to install it individually. If you want to do this,
    you can download MySQL directly from the official website: [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 其他开发人员更喜欢单独安装。如果你想这样做，你可以直接从官方网站下载MySQL：[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)。
- en: In this recipe, I'm going to use MySQL Workbench to execute the SQL queries.
    You can download it from [https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/).
    Feel free to use any other MySQL administrator, or if you prefer the terminal,
    you can use MySQL commands directly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我将使用MySQL Workbench来执行SQL查询。你可以从[https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)下载它。随意使用任何其他MySQL管理员，或者如果你喜欢终端，你可以直接使用MySQL命令。
- en: 'Here are more MySQL GUI tools:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的MySQL GUI工具：
- en: phpMyAdmin – [https://www.phpmyadmin.net](https://www.phpmyadmin.net)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: phpMyAdmin - [https://www.phpmyadmin.net](https://www.phpmyadmin.net)
- en: Sequel Pro – [https://www.sequelpro.com](https://www.sequelpro.com)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sequel Pro - [https://www.sequelpro.com](https://www.sequelpro.com)
- en: Navicat – [https://www.navicat.com](https://www.navicat.com)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Navicat - [https://www.navicat.com](https://www.navicat.com)
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work with MySQL on Node, we need to install the sequelize and mysql2 packages:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node上使用MySQL，我们需要安装sequelize和mysql2包：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The first thing we need to do is to create a database, which we will name as
    blog, and use it:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个名为blog的数据库，并使用它：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that we have our database ready let's work on the MySQL implementation with
    Node.js. There are many ways to use MySQL with Node, but for this recipe, we will
    use a package called *Sequelize*, which is a robust ORM for MySQL and other databases
    such as SQLite, Postgres, and MsSQL.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们的数据库准备好了，让我们来使用Node.js进行MySQL实现。有许多使用MySQL与Node的方法，但在这个教程中，我们将使用一个名为*Sequelize*的包，它是一个强大的MySQL和其他数据库（如SQLite，Postgres和MsSQL）的ORM。
- en: 'The first thing we need to do is to create a config file to add our database
    configuration (host, database, user, password, etc). To do this, you need to create
    a file called `config/index.js`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个配置文件来添加我们的数据库配置（主机，数据库，用户，密码等）。为此，你需要创建一个名为`config/index.js`的文件：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'File: config/index.js'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：config/index.js
- en: 'We can re-use the same API controller we used in the MongoDB recipe:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以重复使用在MongoDB教程中使用的相同API控制器：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'File: controllers/api.js'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：controllers/api.js
- en: 'Now we need to create our blog model (`models/blog.js`). Let''s build it in
    sections; the first thing is the connection to our database:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的blog模型（`models/blog.js`）。让我们分部分构建它；首先是连接到我们的数据库：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'File: models/blog.js'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: 'After we created our database connection, let''s create our Post model. We
    will create a table called posts with the following fields: `id`, `title`, `slug`,
    `content`, `author`, and `createdAt`, but Sequelize by default will automatically create
    an extra field called `updatedAt` when you add a `DATE` field, which will change
    every time we update a row:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建了数据库连接之后，让我们创建我们的Post模型。我们将创建一个名为posts的表，其中包含以下字段：`id`，`title`，`slug`，`content`，`author`和`createdAt`，但是Sequelize默认情况下会在添加`DATE`字段时自动创建一个名为`updatedAt`的额外字段，每次更新行时都会更改：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'File: models/blog.js'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: 'One of the coolest things of sequelize is that we can add a validation with
    a custom message when a field is empty (`notEmpty`). Now we are going to add a
    method to create a new post:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sequelize最酷的事情之一是，我们可以在字段为空时添加一个自定义消息的验证（`notEmpty`）。现在我们将添加一个方法来创建一个新的post：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'File: models/blog.js'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: 'Now we need a method to update a post:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个方法来更新一个post：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'File: models/blog.js'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: 'Also, we need a method to delete a post by its slug:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要一种方法来通过其slug删除一个post：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'File: models/blog.js'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: 'Sequelize also supports SQL queries directly. Let''s create two methods, one
    to find all the posts and the other to find a post by slug using SQL queries:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sequelize还支持直接的SQL查询。让我们创建两种方法，一种是通过SQL查询找到所有帖子，另一种是通过slug找到帖子：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'File: models/blog.js'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: 'The `queryType` variable that we defined at the beginning of the file is to
    avoid getting a second response from Sequelize. By default, if you don''t pass
    this `queryType` Sequelize will return the result in a multidimensional array
    (the first object is the result and the second one is the metadata object). Let''s
    put all the pieces together:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在文件开头定义的`queryType`变量是为了避免从Sequelize获得第二个响应。默认情况下，如果您不传递此`queryType`，Sequelize将以多维数组的形式返回结果（第一个对象是结果，第二个对象是元数据对象）。让我们把所有的部分放在一起：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'File: models/blog.js'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/blog.js
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: It will work in the same way as the MongoDB recipe, just with minor differences
    in the results. To test the API, you will need to install Postman ([https://www.getpostman.com](https://www.getpostman.com)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以与MongoDB配方相同的方式工作，只是结果中存在细微差异。要测试API，您需要安装Postman（[https://www.getpostman.com](https://www.getpostman.com)）。
- en: POST method endpoints
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST方法端点
- en: The POST method is typically used when we want to insert new data into our database.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: POST方法通常用于在数据库中插入新数据。
- en: '**POST /post.** For this endpoint, we need to use Postman to send the data through
    the request body. To do this, you need to select the POST method in Postman. Enter
    the URL `http://localhost:3000/api/post`, then click on Headers, and you need
    to add a `Content-Type` header with a value of `application/x-www-form-urlencoded`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST /post.** 对于此端点，我们需要使用Postman通过请求正文发送数据。为此，您需要在Postman中选择POST方法。输入URL
    `http://localhost:3000/api/post`，然后点击Headers，您需要添加一个值为`application/x-www-form-urlencoded`的`Content-Type`头：'
- en: '![](assets/1cf5089d-dc33-45ce-80a7-bd4b7e86e1cc.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1cf5089d-dc33-45ce-80a7-bd4b7e86e1cc.png)'
- en: 'After you set the header, go to the `Body` tab and select the `raw` option,
    and you can send the information like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 设置头之后，转到`Body`选项卡并选择`raw`选项，您可以像这样发送信息：
- en: '![](assets/d24a9c4c-d82e-473f-82e5-f1e8c52a2033.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d24a9c4c-d82e-473f-82e5-f1e8c52a2033.png)'
- en: 'Now you can hit the Send button and see the response that the service returns:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以点击发送按钮并查看服务返回的响应：
- en: '![](assets/caaf5419-5406-4dee-a373-e0d85cd4b786.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/caaf5419-5406-4dee-a373-e0d85cd4b786.png)'
- en: 'If you did everything correctly, you should get a response with the saved node set
    to true and the post node with information about the saved post. If you try to
    hit the *Send* button again with the same data (the same title), it will cause
    an error because, as you remember, our slug must be unique:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您做的一切正确，您应该会收到一个响应，其中保存的`node`设置为`true`，并且帖子的`node`中包含有关保存的帖子的信息。如果您尝试再次点击*发送*按钮并使用相同的数据（相同的标题），它将会导致错误，因为您记得，我们的slug必须是唯一的：
- en: '![](assets/7b0d1911-3327-4929-be63-f1e1f8c33543.png)The text in this image
    is not relevant. The purpose of the image is to give you a glimpse of how the
    error looks like. Try in your Postman, and you will see the same error as the
    image.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7b0d1911-3327-4929-be63-f1e1f8c33543.png)此图像中的文本与本文无关。图像的目的是让您一睹错误的样子。在您的Postman中尝试，您将看到与图像相同的错误。'
- en: GET method endpoints
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET方法端点
- en: '**GET /posts**. This endpoint can be tested with your browser. Go to `http://localhost:3000/api/posts`.
    I have manually inserted three rows with the `createPost` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET /posts**。此端点可以在浏览器中进行测试。转到`http://localhost:3000/api/posts`。我已经手动使用`createPost`方法插入了三行：'
- en: '![](assets/2706cc8b-dd9d-4f31-b4b7-d89d7e36e4bb.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2706cc8b-dd9d-4f31-b4b7-d89d7e36e4bb.png)'
- en: 'If you want to test it on Postman, then write the same URL (`http://localhost:3000/api/posts`),
    select the `GET` method, and click on the Send button:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Postman上进行测试，请写入相同的URL（`http://localhost:3000/api/posts`），选择`GET`方法，然后点击发送按钮：
- en: '![](assets/d429bc41-8f87-4c5a-928f-d14fc2cb3398.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d429bc41-8f87-4c5a-928f-d14fc2cb3398.png)'
- en: '**GET /post/:slug**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET /post/:slug**'
- en: This endpoint is also a GET, and you need to pass the slug (the friendly URL)
    in the URL. For example, the slug of the first row, My blog post 1, is my-blog-post-1. A
    slug is a friendly URL that has the same value as the title but in lowercase,
    without special characters and the spaces are replaces with dashes (`-`). In our
    model, we defined our slug as a unique field, which means that there cannot be
    more than one post with the same slug.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点也是一个GET，您需要在URL中传递slug（友好的URL）。例如，第一行的slug，我的博客文章1，是my-blog-post-1。slug是一个友好的URL，其值与标题相同，但是小写，没有特殊字符，并且空格用破折号（`-`）替换。在我们的模型中，我们将slug定义为唯一字段，这意味着不能有多个具有相同slug的帖子。
- en: 'Let''s go to `http://localhost:3000/api/post/my-blog-post-1` in the browser.
    If the slug exists in the database you will see the information:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中转到`http://localhost:3000/api/post/my-blog-post-1`。如果数据库中存在slug，您将看到以下信息：
- en: '![](assets/5fb67d09-368a-4194-a40f-b94eb9afdf21.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5fb67d09-368a-4194-a40f-b94eb9afdf21.png)'
- en: 'But if you try to view a slug that does not exist in the database you will
    get this error:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果尝试查看数据库中不存在的slug，您将收到此错误：
- en: '![](assets/283dd8c5-5c71-4d39-9fe4-b0b952223d57.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/283dd8c5-5c71-4d39-9fe4-b0b952223d57.png)'
- en: DELETE method endpoints
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE方法端点
- en: The `DELETE` method, as the name implies, is for deleting rows in a database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`方法，顾名思义，用于删除数据库中的行。'
- en: '**DELETE /post/:slug**. In Postman, we need to select the `DELETE` method,
    and in the URL you need to pass the slug of the post you want to remove. For example,
    let''s remove my-blog-post-2. If you remove it correctly you should get a response
    with the removed node with a value of true:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**DELETE /post/:slug**。在Postman中，我们需要选择`DELETE`方法，并在URL中传递要删除的帖子的slug。例如，让我们删除my-blog-post-2。如果删除成功删除，您应该收到一个带有已删除节点值为true的响应：'
- en: '![](assets/c06a5148-9780-45c5-aca3-ed132c2c59b8.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c06a5148-9780-45c5-aca3-ed132c2c59b8.png)'
- en: 'If you want to verify the post was deleted, you can go to the `/posts` endpoint
    again, and you will see that is not in the JSON anymore:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要验证帖子是否已删除，可以再次转到`/posts`端点，您将看到它不再在JSON中：
- en: '![](assets/86099ab6-2d08-415a-9726-3dc08eaa8036.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86099ab6-2d08-415a-9726-3dc08eaa8036.png)'
- en: PUT method endpoints
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT方法端点
- en: The last method is `PUT`, and it is usually used to update a row in a database.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是`PUT`，通常用于更新数据库中的一行。
- en: '`PUT /post/:slug`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT /post/:slug`'
- en: 'In Postman, you need to select the PUT method first, then the URL of the post
    you want to edit. Let''s edit my-blog-post-3; so the URL will be `http://localhost:3000/api/post/my-blog-post-3`.
    In the Headers tab, you need to add, as in the POST method, the `Content-Type`
    header with the value `application/x-www-form-urlencoded`. The last part is the
    Body tab, where you can send the new data you want to replace, in this case, a
    new title and new content:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，您首先需要选择PUT方法，然后选择要编辑的帖子的URL。让我们编辑my-blog-post-3；因此URL将是`http://localhost:3000/api/post/my-blog-post-3`。在标题选项卡中，您需要添加与POST方法相同的`Content-Type`标题，值为`application/x-www-form-urlencoded`。最后一部分是Body选项卡，您可以在其中发送要替换的新数据，例如新标题和新内容：
- en: '![](assets/774cd76e-7c09-46f0-aab3-ea77ad15db36.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/774cd76e-7c09-46f0-aab3-ea77ad15db36.png)'
- en: 'If everything works fine, you should get this response:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该收到此响应：
- en: '![](assets/1fd0ea4f-8fdd-4f15-80d7-c3bcf90199a3.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1fd0ea4f-8fdd-4f15-80d7-c3bcf90199a3.png)'
- en: 'Again, if you want to verify the post was updated correctly, then go to the `/posts` endpoint
    in your browser:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要验证帖子是否已正确更新，请在浏览器中转到`/posts`端点：
- en: '![](assets/746c4fcf-f8bb-47cc-ae48-90e31a71b571.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/746c4fcf-f8bb-47cc-ae48-90e31a71b571.png)'
- en: As you can see, the post title, content, and slug were updated correctly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，帖子标题、内容和slug已正确更新。
- en: Adding access tokens to secure our API
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加访问令牌以保护我们的API
- en: The APIs that we created in the last two recipes is public. That means everyone
    can access and get the information from our server, but what happens if you want
    to add a security layer on the API and get the information for registered users
    on your platform? We need to add access token validation to protect our API, and
    to do this; we have to use **JSON Web Tokens** (**JWT**).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后两个示例中创建的API是公开的。这意味着每个人都可以访问并从我们的服务器获取信息，但如果您想在API上添加安全层并获取平台上注册用户的信息，该怎么办？我们需要添加访问令牌验证来保护我们的API，为此，我们必须使用**JSON
    Web Tokens**（**JWT**）。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you need to install JWT for Node.js:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要为Node.js安装JWT：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We will mostly use the same code that we created for the MySQL recipe and add
    a security layer to validate our access tokens:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要使用我们为MySQL示例创建的相同代码，并添加一个安全层来验证我们的访问令牌：
- en: 'The first thing we need to do is to modify our config file (`config/index.js`),
    add a security node with the `secretKey` we are going to use to create our tokens,
    and add the expiration time of the token:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是修改我们的配置文件（`config/index.js`），添加一个安全节点，其中包含我们将用来创建令牌的`secretKey`，并添加令牌的过期时间：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: File: config/index.js
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：config/index.js
- en: 'The next step is to create a `db.js` file in our model''s folder to separate
    our database connection and share it between our models. Before, we just had the
    blog model, but now we are going to create a user model file as well:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在我们模型文件夹中创建一个`db.js`文件，以分离我们的数据库连接并在我们的模型之间共享它。以前，我们只有博客模型，但现在我们也要创建一个用户模型文件：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'File: models/db.js'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/db.js
- en: 'Now we need to create a table for users and save a record for our user:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为用户创建一个表，并保存用户的记录：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can insert a user with this command, change the username and password. In
    this recipe, we are going to use the SHA1 algorithm to encrypt our passwords:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这个命令插入一个用户，更改用户名和密码。在这个示例中，我们将使用SHA1算法来加密我们的密码：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After we have created our user table and we have a registered user, let''s
    create our user model with a `login` method:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建了用户表并有了注册用户之后，让我们创建我们的用户模型，其中包含一个`login`方法：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'File: models/user.js'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：models/user.js
- en: 'The next step is to modify our API controller, add a `login` endpoint to generate
    our token, and add a function to validate the token. Then we are going to protect
    one of our endpoints (`/api/posts`):'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是修改我们的API控制器，添加一个`login`端点来生成我们的令牌，并添加一个验证令牌的函数。然后我们将保护我们的一个端点（`/api/posts`）：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'File: controllers/api.js'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：controllers/api.js
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: If you want to test the security of your API, the first thing you need to do
    is to execute the *POST* `/api/login` method to get a new token. As before, we
    can do this with Postman.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试API的安全性，首先需要执行*POST* `/api/login`方法来获取一个新的令牌。和以前一样，我们可以使用Postman来做这个。
- en: 'You need to select the POST method and then write the URL `http://localhost:3000/api/login`
    and add a `Content-Type` header with the value `application/x-www-form-urlencoded`
    to be able to send data through the request body:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要选择POST方法，然后编写URL `http://localhost:3000/api/login`，并添加一个`Content-Type`头，值为`application/x-www-form-urlencoded`，以便通过请求体发送数据：
- en: '![](assets/860c9a7a-ea73-4a50-b402-065418b2c8b6.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/860c9a7a-ea73-4a50-b402-065418b2c8b6.png)'
- en: 'Then, on the *Body* tab, we need to send our data (username and password) with
    the information of the user that we have in the database. Here we are doing this
    process manually, but eventually, this information should come from a login form
    on your website:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*Body*选项卡上，我们需要发送我们的数据（用户名和密码），以及我们在数据库中拥有的用户信息。在这里，我们手动进行这个过程，但最终，这些信息应该来自您网站上的登录表单：
- en: '![](assets/118e7fca-a9f9-48e7-bf45-d544150fc4da.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/118e7fca-a9f9-48e7-bf45-d544150fc4da.png)'
- en: 'If you passed the correct information for your user you should get the `accessToken`,
    but if for some reason the login fails or the user or password is incorrect, you
    will get an error like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为用户传递了正确的信息，您应该会得到`accessToken`，但如果由于某种原因登录失败或用户或密码不正确，您将收到类似于此的错误：
- en: '![](assets/fc76aea9-c029-4a12-8e2d-197a2f33985f.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc76aea9-c029-4a12-8e2d-197a2f33985f.png)'
- en: 'Once you get the new `accessToken` (remember that this token will be valid
    just for 1 hour; after the expiration time you will need to create a new one)
    you need to copy the token and then send it as header (as an access tokenwith
    the format `Bearer <access-token>`) in the protected endpoint we have (`/api/posts`):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得新的`accessToken`（请记住，此令牌仅在1小时内有效；在过期时间后，您将需要创建一个新的），您需要复制该令牌，然后将其作为标头（作为访问令牌的格式`Bearer
    <access-token>`）发送到我们的受保护端点(`/api/posts`)。
- en: '![](assets/953b247e-b35f-4eb6-ae9d-dfa28f091ed9.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/953b247e-b35f-4eb6-ae9d-dfa28f091ed9.png)'
- en: It is crucial that you send the correct format, Bearer[SPACE]<access-token>.
    Remember, we are using a space to get the token. If you did everything correctly,
    you should get the response from the service with the posts from the blog and
    the user information (this can maybe be in a different endpoint, but for this
    example, I just added the user data here).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，您发送正确的格式，Bearer[空格]<access-token>。请记住，我们使用空格来获取令牌。如果您一切都做对了，您应该会收到来自服务的响应，其中包含博客的帖子和用户信息（这可能在不同的端点，但在此示例中，我只是在此处添加了用户数据）。
- en: '![](assets/e99f71c4-8ebd-4637-acaf-e8f9a7675bb5.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e99f71c4-8ebd-4637-acaf-e8f9a7675bb5.png)'
- en: 'As you can see in the user data, we are getting the information from the database
    plus two new fields: `iat` (issued at) and `exp` (token expiration). But what
    happens if our token expires or the user sends an incorrect access-token? In these
    scenarios, we will return an error:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在用户数据中，我们从数据库获取信息，还有两个新字段：`iat`（发行时间）和`exp`（令牌过期）。但如果我们的令牌过期或用户发送了不正确的访问令牌会发生什么呢？在这些情况下，我们将返回一个错误：
- en: '![](assets/e6424039-d5fd-49d4-901e-18454c280a18.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e6424039-d5fd-49d4-901e-18454c280a18.png)'
- en: There's more...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, token validation is easy to implement and adds a security layer
    for our API when we are working with private data. You will probably ask where
    the best place is to save the generated access token. Some people save the access
    token in cookies or sessions, but I don't recommend this because there are some
    associated security issues. My recommendation is to use local storage to save
    it only while the user is connected to the site, and then remove it after the
    user closes the browser, but again this will depend on the type of security you
    want to add to your platform.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，令牌验证易于实现，并在处理私人数据时为我们的API增加了安全层。您可能会问最佳保存生成的访问令牌的位置在哪里。有些人将访问令牌保存在cookie或会话中，但我不建议这样做，因为存在一些相关的安全问题。我的建议是只在用户连接到网站时使用本地存储来保存它，然后在用户关闭浏览器后将其删除，但这将取决于您想要为平台添加的安全类型。
