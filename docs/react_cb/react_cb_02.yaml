- en: Conquering Components and JSX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 征服组件和JSX
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下内容：
- en: Creating our first React component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个React组件
- en: Organizing our React application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织我们的React应用程序
- en: Styling a component with CSS classes and inline styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS类和内联样式为组件设置样式
- en: Passing props to a component and validating them with PropTypes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将props传递给组件并使用PropTypes进行验证
- en: Using local state in a component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中使用本地状态
- en: Making a functional or stateless component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数式或无状态组件
- en: Understanding React lifecycle methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React生命周期方法
- en: Understanding React Pure Components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React纯组件
- en: Preventing XSS vulnerabilities in React
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中防止XSS漏洞
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter contains recipes related to how to create components in React.
    We are going to learn how to create React components (class components, pure components,
    and functional components) and organize our project structure. We'll also learn
    how to use React local state, implement all the React lifecycle methods, and finally,
    we'll see how to prevent XSS vulnerabilities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含与在React中创建组件相关的内容。我们将学习如何创建React组件（类组件、纯组件和函数组件）并组织我们的项目结构。我们还将学习如何使用React本地状态，实现所有React生命周期方法，最后，我们将看到如何防止XSS漏洞。
- en: Creating our first React component
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个React组件
- en: The component is the essential part of React. With React you can build interactive
    and reusable components. In this recipe, you will create your first React component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是React的重要部分。使用React，您可以构建交互式和可重用的组件。在这个配方中，您将创建您的第一个React组件。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we need to create our React application using `create-react-app`. Once
    that is done, you can proceed to create your first React component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`create-react-app`创建我们的React应用程序。完成后，您可以继续创建您的第一个React组件。
- en: Before you install `create-react-app`, remember that you need to download and
    install Node from [www.nodejs.org](http://www.nodejs.org). You can install it
    for Mac, Linux, and Windows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装`create-react-app`之前，请记住您需要从[www.nodejs.org](http://www.nodejs.org)下载并安装Node。您可以为Mac、Linux和Windows安装它。
- en: 'Install `create-react-app` globally by typing this command in your Terminal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中输入以下命令全局安装`create-react-app`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or you can use a shortcut:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用快捷方式：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s build our first React application by following these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤构建我们的第一个React应用程序：
- en: 'Create our React application with the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建我们的React应用程序：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Go to the new application with `cd my-first-react-app` and start it with `npm
    start`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到新应用程序，使用`cd my-first-react-app`进入，并使用`npm start`启动它。
- en: The application should now be running at `http://localhost:3000`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序现在应该在`http://localhost:3000`上运行。
- en: 'Create a new file called `Home.js` inside your `src` folder:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`src`文件夹中创建一个名为`Home.js`的新文件：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'File: src/Home.js'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/Home.js
- en: 'You may have noticed that we are exporting our class component at the end of
    the file, but it''s fine to export it directly on the class declaration, like
    this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在文件末尾导出了我们的类组件，但直接在类声明上导出也是可以的，就像这样：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'File: src/Home.js'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/Home.js
- en: I prefer to export it at the end of the file, but some people like to do it
    in this way, so it depends on your preferences.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢在文件末尾导出它，但有些人喜欢以这种方式做，所以这取决于您的偏好。
- en: 'Now that we have created the first component, we need to render it. So we need
    to open the `App.js` file, import the `Home` component, and then add it to the
    render method of the `App` component. If we are opening this file for the first
    time, we will probably see a code like this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个组件，我们需要渲染它。因此，我们需要打开`App.js`文件，导入`Home`组件，然后将其添加到`App`组件的渲染方法中。如果我们是第一次打开这个文件，我们可能会看到类似这样的代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'File: src/App.js'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/App.js
- en: 'Let''s change this code a little bit. As I said before, we need to import our
    `Home` component and then add it to the JSX. We also need to replace the `<p>`
    element with our component, like this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下这段代码。正如我之前所说，我们需要导入我们的`Home`组件，然后将其添加到JSX中。我们还需要用我们的组件替换`<p>`元素，就像这样：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'File: src/App.js'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/App.js
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, we imported `React` and `Component` from the React library.
    You probably noticed that we are not using the `React` object directly. To write
    code in JSX, you need to import `React`. JSX is similar to HTML, but with a few
    differences. In the following recipes, you will learn more about JSX.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们从React库中导入了`React`和`Component`。你可能注意到我们并没有直接使用`React`对象。要在JSX中编写代码，你需要导入`React`。JSX类似于HTML，但有一些不同之处。在接下来的示例中，你将学习更多关于JSX的知识。
- en: 'This component is called a `class` component (`React.Component`), and there
    are different types: pure components (`React.PureComponent`) and functional components,
    also known as stateless components, which we will cover in the following recipes.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件被称为`class`组件（`React.Component`），有不同的类型：纯组件（`React.PureComponent`）和功能组件，也被称为无状态组件，我们将在接下来的示例中介绍。
- en: 'If you run the application, you should see something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你应该会看到类似这样的东西：
- en: '![](assets/37d1b4cf-d6b1-4f07-abbf-904a802e686a.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37d1b4cf-d6b1-4f07-abbf-904a802e686a.png)'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In our example, we created the `Home.js` file, and our component's name is `Home`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了`Home.js`文件，我们组件的名称是`Home`。
- en: All React component names should start with the first letter capitalized in
    both the file and the class name. To begin with, it might feel uncomfortable for
    you to see this, but this is the best practice in React.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有React组件的名称都应该以文件和类名的首字母大写开头。一开始，你可能会感到不舒服，但这是React中的最佳实践。
- en: Some of the main differences between JSX and HTML are the attributes names.
    You may have noticed that we are using `className` instead of `class`. This is
    the only special attribute name. Others that are two words separated by a dash
    need to be converted to camelCase, for example, `onClick`, **`srcSet`**, and `tabIndex`.
    The `aria-*` and `data-*` attributes still uses the same nomenclature (`data-something` and `aria-label`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JSX和HTML之间的一些主要区别是属性名称。你可能已经注意到，我们使用`className`而不是`class`。这是唯一的特殊属性名称。其他由破折号分隔的两个单词需要转换为驼峰命名法，例如，`onClick`，**`srcSet`**和`tabIndex`。`aria-*`和`data-*`属性仍然使用相同的命名法（`data-something`和`aria-label`）。
- en: Organizing our React application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织我们的React应用程序
- en: In this recipe, we will learn how to structure our project in a better way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何更好地组织我们的项目。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We can create React components with the default structure that `create-react-app`
    provides, but in this recipe, I'll show you a better way to organize the project
    so that we are ready when for when the application grows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`create-react-app`提供的默认结构创建React组件，但在这个示例中，我将向你展示更好的组织项目的方法，以便在应用程序增长时做好准备。
- en: We need to create a new React app (check the last recipe if you haven't created
    a React app yet)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的React应用程序（如果你还没有创建React应用程序，请查看上一个示例）
- en: 'Currently, our React application directory tree looks like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的React应用程序目录树看起来像这样：
- en: '![](assets/92e8684d-42cf-416f-a60a-5afcff61c84b.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92e8684d-42cf-416f-a60a-5afcff61c84b.png)'
- en: We need to create `src/components` and `src/shared` directories
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建`src/components`和`src/shared`目录
- en: After this, we need to create the `src/components/Home` directory for our component and
    move **`Home.js`** into this folder
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要为我们的组件创建`src/components/Home`目录，并将**`Home.js`**移动到这个文件夹中
- en: The `App.js` file stays at the `src/components` level
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.js`文件保持在`src/components`级别'
- en: Also, `App.css` and `App.test.js` will stay at `src/components` level
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`App.css`和`App.test.js`将保持在`src/components`级别
- en: Move the `logo.svg` file to `src/shared/images`
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`logo.svg`文件移动到`src/shared/images`
- en: Our `index.js` will stay at the `src/` level
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`index.js`将保持在`src/`级别
- en: 'Now your directory tree should look like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你的目录树应该是这样的：
- en: '![](assets/3ba9e4f5-31dd-4ec2-b313-a65fc5056d59.png)I highly recommend that
    you create another directory for shared components, `src/shared/components.`I''ll
    explain more about this in the next recipes.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3ba9e4f5-31dd-4ec2-b313-a65fc5056d59.png)我强烈建议你为共享组件创建另一个目录，`src/shared/components`。我将在下一个教程中详细解释这一点。'
- en: 'In the `App.js` file, change the `logo` and `Home` imports:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，更改`logo`和`Home`的引入：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'File: src/components/App.js'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: 'After you changed that, we need to open the `index.js` and fix the import path
    for the `App` component:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你改变了那个之后，我们需要打开`index.js`并修复`App`组件的导入路径：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'File: src/index.js'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/index.js
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This new structure will give us more flexibility to group our React components
    smartly. With this new structure, we are going to be able to create sub-components,
    if we need them, and that is very important when developing complex applications
    with React.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的结构将使我们更灵活地智能地分组我们的React组件。有了这种新的结构，我们将能够创建子组件，如果我们需要的话，这在使用React开发复杂应用程序时非常重要。
- en: In the next recipes, we will see how to share components in our application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个教程中，我们将看到如何在我们的应用程序中共享组件。
- en: Styling a component with CSS classes and inline styles
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS类和内联样式来为组件添加样式
- en: In the last recipe, we learned how to create a class component. Now let's add
    some CSS to our `Home` component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们学会了如何创建一个类组件。现在让我们为`Home`组件添加一些CSS。
- en: 'In React, one of the best practices is to have the style file in the same directory
    as the component. If you have worked with PHP, Node, or any other server language,
    you probably write your styles in a `style.css` file, and you include it using
    a `link` tag in your template. React uses Webpack, which is the most popular module
    bundler at the moment. With Webpack, we can configure the way that we want to
    handle our styles (using CSS directly or by using a CSS preprocessor such as Sass,
    Stylus, or Less CSS), and with Webpack we can implement CSS modules. This is a
    powerful way to avoid the three main issues of CSS:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，最佳实践之一是将样式文件放在与组件相同的目录中。如果你曾经使用过PHP、Node或任何其他服务器语言，你可能会将样式写在一个`style.css`文件中，并在模板中使用`link`标签进行引入。React使用的是目前最流行的模块打包工具Webpack。通过Webpack，我们可以配置处理样式的方式（直接使用CSS或使用CSS预处理器如Sass、Stylus或Less
    CSS），并且我们可以实现CSS模块化。这是一个强大的方式来避免CSS的三个主要问题：
- en: No more conflicts (unintentional CSS overwrites)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再有冲突（意外的CSS覆盖）
- en: Explicit dependencies (styles per component)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式依赖（每个组件的样式）
- en: No global scope
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有全局作用域
- en: In [Chapter 10](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*, Mastering Webpack
    4.x*, we will cover Webpack, and we'll be able to implement CSS modules using Sass or Stylus in
    our project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*，《掌握Webpack 4.x*》，我们将介绍Webpack，并且我们将能够在项目中使用Sass或Stylus来实现CSS模块。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We will now go about adding CSS to our `Home` component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`Home`组件添加CSS：
- en: Create a new application, or use the previous one (`my-first-react-app`).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序，或者使用之前的一个（`my-first-react-app`）。
- en: 'Then create a new CSS file for our `Home` component. Let''s reuse the `Home`
    component we created in the last recipe. Now you need to create a `Home.css` file
    at the same level as your `Home.js` file (inside the `components` folder). Before
    you create this file, let''s modify our `Home` component a little bit:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为我们的`Home`组件创建一个新的CSS文件。让我们重用上一个示例中创建的`Home`组件。现在，您需要在与您的`Home.js`文件相同级别的位置（在`components`文件夹内）创建一个`Home.css`文件。在创建此文件之前，让我们稍微修改我们的`Home`组件：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'We''ll now add styles to our `Home.css`**.** Basically, we wrapped our component
    into a `div` with a `className` of Home, and inside we have an `<h1>` tag with
    the text `Welcome to Codejobs`, and then a `<p>` tag with a message. We need to
    import our `Home.css` file directly, and then our CSS file will look like this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们给我们的`Home.css`**添加样式**。基本上，我们将我们的组件包装在一个`className`为Home的`div`中，里面有一个文本为`Welcome
    to Codejobs`的`<h1>`标签，然后是一个消息的`<p>`标签。我们需要直接导入我们的`Home.css`文件，然后我们的CSS文件将如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'File: src/components/Home/Home.css'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.css
- en: 'Now let''s suppose you need to add an inline style. We do this with the style
    property, and the CSS properties need to be written in camelCase and between `{{
    }}`, like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设您需要添加内联样式。我们可以使用style属性来实现这一点，CSS属性需要以驼峰命名法写在`{{ }}`之间，就像这样：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'You also can pass an object to the `style` property like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以像这样将对象传递给`style`属性：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you can see, it is straightforward to connect a CSS file to our component,
    and if you followed all the steps correctly, your site should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将CSS文件连接到我们的组件非常简单，如果您正确地按照所有步骤进行操作，您的网站应该看起来像这样：
- en: '![](assets/a94c164c-7ab3-4d97-a5f2-7a46f396c26f.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a94c164c-7ab3-4d97-a5f2-7a46f396c26f.png)'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You''re probably curious about how the CSS code is added to the browser since
    we haven''t imported a CSS file to our project directly (by using a `<link>` tag,
    for example). Well, you will be surprised to see that the CSS code is being injected
    into our `<head>` tag using the `<style>` tag for each imported stylesheet. If
    you inspect your project with Chrome DevTools you will see something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能好奇CSS代码是如何添加到浏览器中的，因为我们没有直接向项目导入CSS文件（例如使用`<link>`标签）。好吧，您会惊讶地发现，CSS代码是通过使用`<style>`标签将其注入到我们的`<head>`标签中的每个导入样式表中的。如果您使用Chrome
    DevTools检查您的项目，您会看到类似于这样的内容：
- en: '![](assets/737dff60-3cf8-44ac-8d83-b3734177d630.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/737dff60-3cf8-44ac-8d83-b3734177d630.png)'
- en: 'This behavior is because the `style-loader` is a Webpack loader that is being
    used by default in our application when we create it with `create-react-app`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在我们使用`create-react-app`创建应用程序时，默认使用了名为`style-loader`的Webpack加载器：
- en: '![](assets/26c0d48b-1281-498b-a93c-ef8424d21f29.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/26c0d48b-1281-498b-a93c-ef8424d21f29.png)'
- en: There is no way to modify the Webpack configuration directly when we use `create-react-app`
    because it is using a package called `react-scripts`, but in [Chapter 10](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*,
    Mastering Webpack*, we will see how to configure our Webpack without using a starting
    kit such as `create-react-app`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`create-react-app`时，没有直接修改Webpack配置的方法，因为它使用一个名为`react-scripts`的包，但是在[第10章](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*，掌握Webpack*中，我们将看到如何配置我们的Webpack，而不使用`create-react-app`这样的起始工具包。
- en: There are more Webpack loaders that do different things, such as `css-loader` for
    CSS modules, `sass-loader` to implement Sass, `stylus-loader` to implement Stylus,
    and `extract-text-plugin` to move the CSS code to a `.css` file instead of injecting
    it to the DOM (usually, this is only used in production).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的Webpack加载程序可以执行不同的操作，例如`css-loader`用于CSS模块，`sass-loader`用于实现Sass，`stylus-loader`用于实现Stylus，以及`extract-text-plugin`用于将CSS代码移动到`.css`文件中，而不是将其注入到DOM中（通常，这仅在生产中使用）。
- en: Passing props to a component and validating them with PropTypes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将props传递给组件并使用PropTypes进行验证
- en: So far, you are getting familiar with React components, but there is more to
    it than rendering static HTML. Like any application, we need to be able to send
    information (via props) to different elements. In this recipe, we are going to
    create new components: `Header`, `Content`, and `Footer` (we will group these
    components into a folder called `layout`), and we will send some props (as attributes
    and as children) and validate them with `PropTypes`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经熟悉了React组件，但它不仅仅是渲染静态HTML。像任何应用程序一样，我们需要能够将信息（通过props）发送到不同的元素。在这个示例中，我们将创建新的组件：`Header`，`Content`和`Footer`（我们将把这些组件分组到一个名为`layout`的文件夹中），并且我们将发送一些props（作为属性和子元素）并使用`PropTypes`进行验证。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Taking the same of the React application we created before, let's create first
    our `Header` component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以前创建的React应用程序的名称相同，让我们首先创建我们的`Header`组件。
- en: 'At this point, our current header is placed on `App.js`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们当前的`header`放置在`App.js`中。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'File: src/components/App.js'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: Let's move that header to our new `Header` component and then import it into
    the `App` component. Because the layout components are global or shared, we need
    to create a layout directory in our shared components directory (`src/shared/components/layout`).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将该标题移动到我们的新`Header`组件中，然后将其导入到`App`组件中。因为`layout components`是全局或共享的，所以我们需要在我们的`shared
    components`目录（`src/shared/components/layout`）中创建一个`layout directory`。
- en: 'Before you continue, you must install a package called `prop-types` to use
    the `PropTypes` validation:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，您必须安装一个名为`prop-types`的软件包，以使用`PropTypes`验证：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`PropTypes` was initially released as part of the React core module and is
    commonly used with React components. `PropTypes` is used to document the intended
    types of properties passed to components. React will check the props passed to
    your components against those definitions, and it will send a warning in development
    if they don''t match:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PropTypes`最初作为React核心模块的一部分发布，并且通常与React组件一起使用。`PropTypes`用于记录传递给组件的属性的预期类型。React将检查传递给组件的props与这些定义是否匹配，并且如果不匹配，它将在开发中发送警告：'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'File: src/shared/components/layout/Header.js'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Header.js
- en: The `static` PropTypes property is basically an object where you need to define
    the types of prop you will pass. `array`, `bool`, `func`, `number`, `object`,
    `string`, and `symbol` are primitive types, but there are also particular types,
    such as `node`, `element`, `instanceOf`, `oneOf`, `oneOfType`, `arrayOf`, `objectOf`,
    `shape and any`. There is an optional property called `isRequired` that can be
    added to any type if the prop must be required and will produce a React warning
    if is not defined.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static`的`PropTypes`属性基本上是一个对象，在其中您需要定义将传递的prop的类型。`array`，`bool`，`func`，`number`，`object`，`string`和`symbol`是原始类型，但也有特定的类型，例如`node`，`element`，`instanceOf`，`oneOf`，`oneOfType`，`arrayOf`，`objectOf`，`shape`和`any`。还有一个可选属性叫做`isRequired`，如果prop是必需的，将其添加到任何类型中，如果未定义，将产生React警告。'
- en: 'Import and render our `Header` component:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并渲染我们的`Header`组件：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'File: src/components/App.jsDon''t get confused with the `<Header/>` component, it
    is not the same as the `<header>` tag from HTML5, that''s why in React is recommended
    to use capital letters in the class names.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js不要与`<Header/>`组件混淆，它与HTML5中的`<header>`标签不同，这就是为什么在React中建议在类名中使用大写字母。
- en: 'All the properties passed to our components are contained in this props. You
    may have noticed that we are only sending the `title` prop because it is the only
    one that is required. The `url` prop is optional and also has a default value
    in the destructuring (`http://localhost:3000`). If we don''t pass the title prop,
    even if we have a default value Welcome to React in the destructuring we are going
    to get a warning like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给我们组件的所有属性都包含在这个props中。您可能已经注意到，我们只发送了`title`属性，因为它是唯一必需的属性。`url`属性是可选的，并且在解构中也有一个默认值（`http://localhost:3000`）。如果我们不传递title属性，即使在解构中有一个默认值Welcome
    to React，我们也会收到警告，如下所示：
- en: '![](assets/8eca84f1-f852-4e7e-8dc5-e9714dbcb28d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8eca84f1-f852-4e7e-8dc5-e9714dbcb28d.png)'
- en: 'Create our `Footer` component:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`Footer`组件：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'File: src/shared/components/layout/Footer.js'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Footer.js
- en: 'So far, we only have passed props as attributes (with self-closed components
    `<Component />`), but there is another way to pass props as children (`<Component>Children
    Content</Component>`). Let''s create a `Content` component and send our `Home`
    component as a child of content:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只将props作为属性传递（使用自关闭组件`<Component />`），但还有另一种将props作为子元素传递的方式（`<Component>Children
    Content</Component>`）。让我们创建一个`Content`组件，并将我们的`Home`组件作为内容的子组件发送：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'File: src/shared/components/layout/Content.js'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Content.js
- en: 'With those changes, our `App.js` file should now look like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，我们的`App.js`文件现在应该是这样的：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'File: src/components/App.js'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: PropTypes validations are very important for developers because they force us
    to define which type of prop we are going to receive in our components and validate
    whether some of them are required or not.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: PropTypes验证对开发人员非常重要，因为它们强制我们定义我们将在组件中接收哪种类型的属性，并验证其中一些是否是必需的。
- en: 'If you followed all the steps correctly, you should see something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地按照所有步骤进行了操作，您应该会看到类似于这样的东西：
- en: '![](assets/bce4d668-5bad-4606-ab16-94f1e06ea367.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bce4d668-5bad-4606-ab16-94f1e06ea367.png)'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, there are many ways to send props to components. There are more
    ways to receive props, such as using Redux (through a container) or React Router,
    but those are topics that we are going to cover in the next chapters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多将props发送到组件的方法。还有更多接收props的方法，例如使用Redux（通过容器）或React Router，但这些是我们将在下一章中涵盖的主题。
- en: Using local state in a component
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件中使用本地状态
- en: The local state is a fundamental feature of React for creating dynamic components. Local
    state is only available on class components, and each component manages its state.
    You can define the initial value of the state on the component's constructor,
    and when you update the value of the state, the component will be re-render itself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态是React创建动态组件的基本功能。本地状态仅在类组件上可用，并且每个组件都管理其状态。您可以在组件的构造函数中定义状态的初始值，并且当您更新状态的值时，组件将重新渲染自身。
- en: Local state is helpful with toggles, for handling forms, and is used to manage
    information within the same component. It is not recommended to use local state
    if we need to share data between different components. In that scenario, we need
    to implement Redux state, which we will cover in [Ch](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml)[apter](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml)
    [5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml), *Mastering Redux*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态对于切换、处理表单非常有帮助，并且用于在同一组件内管理信息。如果我们需要在不同组件之间共享数据，不建议使用本地状态。在这种情况下，我们需要实现Redux状态，我们将在第5章*精通Redux*中介绍。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s define our initial state.Let''s see how it works the component''s `render` method when
    the local state is updated:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的初始状态。让我们看看当本地状态更新时组件的`render`方法是如何工作的：
- en: 'Using our `Home` component, we are going to add a constructor and define our initial
    state:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的`Home`组件，我们将添加一个构造函数并定义我们的初始状态：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'In this example, we are defining our local state in the constructor as an object,
    and in the render, we are printing the value directly. We are using `super()` at
    the beginning of the constructor. This is used to call the parent constructor, `(React.Component)`. If
    we don''t include it, we will get an error like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在构造函数中将本地状态定义为一个对象，并在渲染时直接打印值。我们在构造函数的开头使用`super()`。这是用来调用父构造函数`(React.Component)`的。如果我们不包括它，我们会得到这样的错误：
- en: '![](assets/e13d8fc3-393a-4ead-89d0-a24cf1c86db7.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e13d8fc3-393a-4ead-89d0-a24cf1c86db7.png)'
- en: 'After we added `super()`, we need to define our initial state as a regular
    object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们添加了`super()`之后，我们需要将我们的初始状态定义为一个普通对象：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Updating our local state with** `this.setState()`:Right now, this is just
    a state that is not being updated. That means that the component will never re-render
    again. To update the state, we need to use the `this.setState()` method and pass
    the new value of the state. We can add a `setTimeout` to update the name state
    after 1 second (1,000 milliseconds), so we need to modify our `render` method
    like this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用`this.setState()`更新我们的本地状态**：现在，这只是一个没有被更新的状态。这意味着组件将永远不会再次重新渲染。要更新状态，我们需要使用`this.setState()`方法并传递状态的新值。我们可以添加一个`setTimeout`来在1秒后（1,000毫秒）更新名称状态，所以我们需要修改我们的`render`方法如下：'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you run this in your browser, you will see the first value of the state
    is Carlos, and 1 second after this it will change to Cristina. I have added a `console.log` to
    log the value of the state name. If you open your browser console, you will see
    this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在浏览器中运行这个，你会看到状态的第一个值是Carlos，1秒后它会变成Cristina。我已经添加了一个`console.log`来记录状态名称的值。如果你打开浏览器控制台，你会看到这个：
- en: '![](assets/c13cfaec-5e84-41ba-833c-6489ab557835.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c13cfaec-5e84-41ba-833c-6489ab557835.png)'
- en: '**Updating our local state in the** `componentDidMount` **lifecycle method**:
    You''re probably wondering why is repeated so many times. It is simple; this is
    the way React works. Every time we update a state the method render is fired,
    and in this code, we added a `setTimeout` which updates the state after a second.
    That means that the `render` method is being called every second, causing an infinitive
    loop. This will affect the performance of our application, and that''s why you
    need to be careful when you update a state. As you can see updating it in the
    render method is not a good idea. So, where should I update the state? Well, it
    depends on your application, but for now, I''ll show you a method that is part
    of the React lifecycle called `componentDidMount()`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在**`componentDidMount`**生命周期方法中更新我们的本地状态**：您可能想知道为什么重复这么多次。很简单；这是React的工作方式。每次更新状态时，都会触发render方法，在这段代码中，我们添加了一个`setTimeout`，它在一秒后更新状态。这意味着`render`方法每秒都会被调用，导致无限循环。这将影响我们应用的性能，这就是为什么在更新状态时需要小心。正如您所看到的，在render方法中更新它不是一个好主意。那么，我应该在哪里更新状态呢？嗯，这取决于您的应用，但现在，我将向您展示一种属于React生命周期的方法，称为`componentDidMount()`：'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'If you run this code and you see the console, now you will see this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行此代码并查看控制台，现在您将看到这个：
- en: '![](assets/f08c1634-0c26-487d-808e-aebd5beba711.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f08c1634-0c26-487d-808e-aebd5beba711.png)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With `componentDidMount`, we avoided the infinite loop. The reason why this
    is a better approach is that `componentDidMount` is being executed just once when
    the component is already mounted, and in that method, we are executing our `setTimeout` and
    updating the name state only once. In the following recipes, we are going to learn
    more about React lifecycle methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`componentDidMount`，我们避免了无限循环。这种方法更好的原因是，`componentDidMount`在组件已经挂载时只执行一次，并且在该方法中，我们只执行一次`setTimeout`并更新名称状态。在接下来的示例中，我们将学习更多关于React生命周期方法的知识。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Local state is also used to handle forms, but we will cover forms in [Chapter
    6](69fdac67-4387-49ad-89bb-b3407133caaf.xhtml)*, Creating Forms with Redux Form.*
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态也用于处理表单，但我们将在[第6章](69fdac67-4387-49ad-89bb-b3407133caaf.xhtml)*使用Redux Form创建表单*中进行介绍。
- en: Making a functional or stateless component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数式或无状态组件
- en: So far, we have only learned how to create *class components* in React. These
    components are useful when you need to handle local state, but in some cases,
    we will need to render static markup. For static components, we need to use functional
    components*,* also known as stateless components*.* This will improve the performance
    of our application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只学习了如何在React中创建*类组件*。当您需要处理本地状态时，这些组件非常有用，但在某些情况下，我们需要渲染静态标记。对于静态组件，我们需要使用*函数组件*，也称为*无状态组件*。这将提高我们应用的性能。
- en: In the *Passing props to a component and validating them with PropTypes *recipe, we
    created some layout components (`Header`, `Content`, and `Footer`). These components,
    as you may imagine, are frequently not dynamic (unless you want to have a toggle
    menu or some user information in the header), so in this case, we can convert
    them into functional components.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在*将props传递给组件并使用PropTypes进行验证*示例中，我们创建了一些布局组件（`Header`，`Content`和`Footer`）。这些组件通常不是动态的（除非您想在标题中添加切换菜单或一些用户信息），所以在这种情况下，我们可以将它们转换为函数组件。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'It''s now time to convert our `Header` component to a functional component:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的`Header`组件转换为函数组件了：
- en: 'First, let''s see what the current `Header` component looks like:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看当前的`Header`组件是什么样子的：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'File: src/shared/components/layout/Header.js'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Header.js
- en: 'The first thing to do is to convert our class component into an arrow function,
    and with this change, we don''t need to import  `React.Component` anymore. The
    second part of the migration is to pass the props as parameter in the function
    instead of getting them from `this.props`, and the last step is to move our static `propTypes` as
    a node of the function. After those changes, our code should look like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一件事是将我们的类组件转换为箭头函数，通过这个改变，我们不再需要导入`React.Component`。迁移的第二部分是将props作为函数的参数传递，而不是从`this.props`获取它们，最后一步是将我们的静态`propTypes`移动为函数的一个节点。在这些改变之后，我们的代码应该是这样的：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'File: src/shared/components/layout/Header.jsA functional component is an equivalent
    to just having the render method. That''s why we only need to return the JSX directly.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Header.js功能组件相当于只有渲染方法。这就是为什么我们只需要直接返回JSX。
- en: 'After we migrated our `Header` component, we will migrate the `Footer` component;
    this is easier because it does not have props. First, let''s see what our `Footer` component
    looks like:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们迁移了`Header`组件之后，我们将迁移`Footer`组件；这更容易，因为它没有props。首先，让我们看看我们的`Footer`组件是什么样的：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'File: src/shared/components/layout/Footer.js'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Footer.js
- en: 'Now, as a functional component, it should look like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，作为一个功能组件，它应该是这样的：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'File: src/shared/components/layout/Footer.jsIn this case, as you can see, we
    need to create an arrow function without parameters (because we don''t have any
    props) and directly return the JSX we need to render.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Footer.js在这种情况下，正如您所看到的，我们需要创建一个没有参数的箭头函数（因为我们没有任何props），并直接返回我们需要渲染的JSX。
- en: 'Converting the `Content` component to a functional component:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Content`组件转换为功能组件：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'File: src/shared/components/layout/Content.js'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Content.js
- en: 'This component is similar to our `Header` component. We need to pass the props
    as parameters and keep our `propTypes`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件类似于我们的`Header`组件。我们需要将props作为参数传递并保留我们的`propTypes`：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: File***:*** src/shared/components/layout/Content.js
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 文件***:*** src/shared/components/layout/Content.js
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even with functional components, we can validate our `PropTypes`. Remember,
    if you don't need any dynamic data or local state then you should consider using
    a stateless component. This will improve the performance of your application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用功能组件，我们也可以验证我们的`PropTypes`。请记住，如果您不需要任何动态数据或本地状态，那么您应该考虑使用无状态组件。这将提高您的应用程序的性能。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A functional component not only does not have a state but also does not have the
    React lifecycle methods either.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能组件不仅没有状态，而且也没有React生命周期方法。
- en: Understanding React lifecycle methods
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React生命周期方法
- en: React provides methods to handle the data during the lifecycle of a component.
    This is very useful when we need to update our application at particular times.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了处理组件生命周期期间数据的方法。当我们需要在特定时间更新我们的应用程序时，这是非常有用的。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we are going to explain each example independently.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将独立解释每个示例。
- en: Todo list – implementing ComponentWillMount
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表 - 实现ComponentWillMount
- en: 'In this recipe, you will learn about the lifecycle methods in React. We will
    see how the information flows through the methods since the component is pre-mounted,
    mounted, and unmounted. The Todo list that we will develop in this recipe will
    look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习有关React生命周期方法的信息流。我们将看到信息如何在组件预装载、已装载和已卸载时流动。在这个示例中，我们将开发的待办事项列表将如下所示：
- en: '![](assets/7b3d85d6-75af-4b01-bfb2-b80d34257fa2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7b3d85d6-75af-4b01-bfb2-b80d34257fa2.png)'
- en: 'For this Todo list, we need to create a new folder called `Todo` into our `components`
    directory, and you also need to create files called `Todo.js `and `Todo.css`.
    This is the skeleton of the `Todo` component:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个待办事项列表，我们需要在我们的`components`目录中创建一个名为`Todo`的新文件夹，并且你还需要创建名为`Todo.js`和`Todo.css`的文件。这是`Todo`组件的骨架：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'File: src/components/Todo/Todo.js'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Todo/Todo.js
- en: '**Constructo****r: **A constructor is a unique method that is executed before
    the object is initialized. A constructor can use the `super` keyword to call the
    constructor of the super class (parent class). This method is used to initialize
    our local state or to bind our methods. For the Todo list, we need to initialize
    the local state in the constructor with some values in the task and `items` array:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构造函数：**构造函数是一个在对象初始化之前执行的独特方法。构造函数可以使用`super`关键字调用父类（超类）的构造函数。这个方法用于初始化我们的本地状态或绑定我们的方法。对于待办事项列表，我们需要在构造函数中用一些值初始化本地状态或`items`数组：'
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `componentWillMount` method is executed once before the component is mounted.
    In this case, before our component is mounted we need to update our `items` state
    with the default tasks:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentWillMount`方法在组件挂载之前执行一次。在这种情况下，在我们的组件挂载之前，我们需要使用默认任务更新我们的`items`状态：'
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are using `uuidv4` to generate random IDs. To install this package, you
    need to run the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`uuidv4`来生成随机ID。要安装这个包，你需要运行以下命令：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And then you need to import it like this:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你需要像这样导入它：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After we defined our default tasks, let''s see how we need to render the Todo list:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义了默认任务之后，让我们看看如何渲染待办事项列表：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our JSX is divided into two parts. The first one is a form with an input that
    is connected to our local state (`this.state.task`), and we will save the task when
    the user submits the form (`onSubmit`). The second part is the component list where
    we are going to display our Todo list (or tasks list), passing the items array
    and the `markAsCompleted` (to mark a task as a completed) and `removeTask` (to
    remove the task from the list) functions.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的JSX分为两部分。第一部分是一个表单，其中包含一个与我们的本地状态（`this.state.task`）连接的输入，并且当用户提交表单时我们将保存任务（`onSubmit`）。第二部分是组件列表，我们将在其中显示我们的待办事项列表（或任务列表），传递`items`数组和`markAsCompleted`（标记任务为已完成）和`removeTask`（从列表中移除任务）函数。
- en: 'The `handleOnChange` method is for connecting our input value with our state
    task:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handleOnChange`方法用于将我们的输入值与我们的状态任务连接起来：'
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `handleOnSubmit` method is for updating the `items` state and pushing the
    new task to the array:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handleOnSubmit`方法用于更新`items`状态并将新任务推送到数组中：'
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `markAsCompleted` function is going to be called from our `List` component
    and needs to receive the `id` of the task we want to mark as completed. With this,
    we can find the specific task in our items array, modify the node as completed,
    and then update the local state:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`markAsCompleted`函数将从我们的`List`组件中调用，并且需要接收我们想要标记为已完成的任务的`id`。有了这个，我们可以在我们的items数组中找到特定的任务，将节点修改为已完成，然后更新本地状态：'
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `removeTask` function is also being called from the `List` component, and
    like `markAsCompleted`, we need to receive the `id` to remove the specific task:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`removeTask`函数也是从`List`组件中调用的，和`markAsCompleted`一样，我们需要接收`id`来移除特定的任务：'
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s put all the pieces together. Our `Todo` component should look like this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把所有的部分放在一起。我们的`Todo`组件应该是这样的：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'File: src/components/Todo/Todo.js'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Todo/Todo.js
- en: 'Now that we have completed our `Todo` component, let''s see what our `List` component
    looks like:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Todo`组件，让我们看看我们的`List`组件是什么样子的：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'File: src/components/Todo/List.js'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Todo/List.js
- en: 'Every time we use a `.map` function to render multiple React elements from
    an array, we must add the key prop to each item we created. Otherwise, we will
    get a React warning like this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们使用`.map`函数从数组中渲染多个React元素时，我们必须为我们创建的每个项目添加key属性。否则，我们将收到类似于此的React警告：
- en: '![](assets/31fa593a-8e11-43ac-901e-f9038e1be126.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/31fa593a-8e11-43ac-901e-f9038e1be126.png)'
- en: 'You have probably noticed that we also included some Font Awesome icons, and
    to make it work we need to add the Font Awesome CDN into the main `index.html`
    file:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们还包含了一些Font Awesome图标，并且为了使其工作，我们需要将Font Awesome CDN添加到主`index.html`文件中：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'File: public/index.html'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：public/index.html
- en: 'The last part is the CSS for the Todo list (you''re free to change the styles
    if you prefer):'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一部分是Todo列表的CSS（如果您愿意，可以自由更改样式）：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'File: src/components/Todo/Todo.css'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Todo/Todo.css
- en: 'Don''t forget to import the `Todo` component into your `App` component. Otherwise,
    the component won''t render:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将`Todo`组件导入到您的`App`组件中。否则，组件将无法渲染：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'File: src/components/App.js'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: 'If you followed all the instructions correctly you should see the Todo List like
    this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正确地遵循了所有说明，您应该看到Todo列表如下所示：
- en: 'The initial state with default tasks:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有默认任务的初始状态：
- en: '![](assets/b11119df-92bf-45bf-b33d-534c8d80c369.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b11119df-92bf-45bf-b33d-534c8d80c369.png)'
- en: 'Adding a new task:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新任务：
- en: '![](assets/c219e590-ec67-4d43-803a-9edab71965e3.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c219e590-ec67-4d43-803a-9edab71965e3.png)'
- en: 'Write the task title and then press *Enter*:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写下任务标题，然后按*Enter*：
- en: '![](assets/a1c1f936-b61e-4798-8d92-16a1a794248c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1c1f936-b61e-4798-8d92-16a1a794248c.png)'
- en: 'Mark a task as complete:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任务为完成：
- en: '![](assets/f0129857-e44e-42ec-b668-eeb1d7d14a59.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0129857-e44e-42ec-b668-eeb1d7d14a59.png)'
- en: 'Removing a task:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除任务：
- en: '![](assets/ccb14d7c-04a6-4f45-8cf2-1b18023052bf.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ccb14d7c-04a6-4f45-8cf2-1b18023052bf.png)'
- en: I challenge you to save the tasks using `localStorage` instead of defining the
    default tasks with `componentWillMount`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我挑战您使用`localStorage`保存任务，而不是使用`componentWillMount`定义默认任务。
- en: Pomodoro timer – implementing the constructor and componentDidMount
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 番茄工作法计时器 - 实现构造函数和componentDidMount
- en: To understand `componentDidMount`, we are going to create a Pomodoro Timer (if
    you don't know what it is you can read this: [https://en.wikipedia.org/wiki/Pomodoro_Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique))[.](https://en.wikipedia.org/wiki/Pomodoro_Technique)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`componentDidMount`，我们将创建一个番茄工作法计时器（如果您不知道它是什么，可以阅读这篇文章：[https://en.wikipedia.org/wiki/Pomodoro_Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique)）。
- en: 'Our Pomodoro timerwill look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的番茄工作法计时器将如下所示：
- en: '![](assets/b3474db4-b21d-4fb6-81ea-7f2d9b3c16ec.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b3474db4-b21d-4fb6-81ea-7f2d9b3c16ec.png)'
- en: 'Creating our Pomodoro Timer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的番茄工作法计时器：
- en: 'The first thing we need to do is to create a new folder called `Pomodoro` in
    our `components` directory, as well as a file called `Timer.js` and the CSS file, `Timer.css`. This
    is the skeleton of the class component we will use for this component:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在我们的`components`目录中创建一个名为`Pomodoro`的新文件夹，以及一个名为`Timer.js`和CSS文件`Timer.css`。这是我们将用于此组件的类组件的骨架：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'File: src/components/Pomodoro/Timer.js'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Pomodoro/Timer.js
- en: 'For our Pomodoro timer, we need to initialize our local state in the constructor with
    some values for the time and for the alert (when the time is over):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的番茄工作法计时器，我们需要在构造函数中使用一些值初始化我们的本地状态，用于时间和警报（当时间结束时）：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `componentDidMount` method is called once the component is mounted and
    is executed just once. In this case, once our component is mounted we need to
    update our time state with the default time (25 min), and to do this, we need
    to create a new method called `setDefaultTime` and then execute it in our `componentDidMount` method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentDidMount`方法在组件挂载后调用，并且仅执行一次。在这种情况下，一旦我们的组件挂载，我们需要使用默认时间（25分钟）更新我们的时间状态，为此，我们需要创建一个名为`setDefaultTime`的新方法，然后在我们的`componentDidMount`方法中执行它：'
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After we defined our default time to our time state, let''s see how we need
    to render the Pomodoro Timer. Our `render` method should look like this:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将默认时间定义为我们的时间状态之后，让我们看看我们需要如何渲染番茄钟计时器。我们的`render`方法应该是这样的：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, our JSX is very simple. We are getting the values from the local
    state (`message`, `type`, and `time`) and displaying a div to show our alert when
    the user receives an alert message. We have another div to show our timer, and
    here we are passing our current time (expressed in seconds) to the `displayTimer` method,
    which will convert those seconds into `mm:ss`format. The last piece of the layout
    are the buttons to select the type of timer (start working for 25 min, short break
    for 5 min, or long break for 15 min), and you may have noticed that we are executing
    different methods on the `onClick` event for each type of timer.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的JSX非常简单。我们从本地状态（`message`，`type`和`time`）中获取值，并显示一个div来显示用户接收到的警报消息。我们有另一个div来显示我们的计时器，这里我们将我们当前的时间（以秒为单位）传递给`displayTimer`方法，该方法将这些秒转换为`mm:ss`格式。布局的最后一部分是用于选择计时器类型的按钮（开始工作25分钟，短暂休息5分钟或长时间休息15分钟），您可能已经注意到我们在每种计时器的`onClick`事件上执行不同的方法。
- en: '`setTimeForWork`, `setTimeForShortBreak`, and `setTimeForLongBreak`:The purpose
    of these three functions is to update the alert message depending on the type
    of the timer and then call a common function called `setTime`, passing as a parameter
    the specific time for each option. Let''s first see what these three functions
    should look like:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setTimeForWork`，`setTimeForShortBreak`和`setTimeForLongBreak`：这三个函数的目的是根据计时器的类型更新警报消息，然后调用一个名为`setTime`的公共函数，将特定时间作为参数传递给它。让我们首先看看这三个函数应该是什么样子的：'
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we learned in the previous recipes when we specify our methods with arrow
    functions in our class they are automatically bound (they have access to the "`this`" object).
    That means we don''t need to bind them on the constructor.Now let''s create our `setTime` method:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中学到的，当我们在类中使用箭头函数指定我们的方法时，它们会自动绑定（它们可以访问“this”对象）。这意味着我们不需要在构造函数中绑定它们。现在让我们创建我们的`setTime`方法：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, we executed a new method called `restartInterval()`, and we
    updated our local state with the `newTime` variable, which we passed as a parameter
    (it can be 1,500 seconds = 25 min, 300 seconds = 5 min or 900 seconds = 15 min).
    You probably noticed, from the name of the function, that we are going to use
    a `setInterval` function, which is used to call a function every X milliseconds.
    Our `restartInterval` function should be like this:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们执行了一个名为`restartInterval()`的新方法，并使用`newTime`变量更新了我们的本地状态，我们将其作为参数传递（可以是1,500秒=25分钟，300秒=5分钟或900秒=15分钟）。您可能已经注意到，从函数的名称中，我们将使用`setInterval`函数，该函数用于每X毫秒调用一次函数。我们的`restartInterval`函数应该像这样：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this case, we first cleared our interval with `clearInterval(this.interval)`.
    This is because the user can switch between the different types of the timer,
    so we need to clear the interval each time we set a new timer*. *After we cleared
    the interval, then we call the `countDown` function every second using `setInterval`.
    The `countDown` function is as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先用`clearInterval(this.interval)`清除了我们的间隔。这是因为用户可以在不同类型的计时器之间切换，所以我们需要在设置新的计时器时清除间隔。清除间隔后，我们使用`setInterval`每秒调用`countDown`函数。`countDown`函数如下：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The last piece of this puzzle is the `displayTimer` function, which will convert
    the time into an `mm:ss`format and display it in our component:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个谜题的最后一块是`displayTimer`函数，它将把时间转换成`mm:ss`格式，并在我们的组件中显示出来：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s put it all together:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把它全部整合起来：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'File: src/components/Pomodoro/Timer.js'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Pomodoro/Timer.js
- en: 'After we have completed our component, the last step is to add our styles.
    This is the CSS used for the Pomodoro timer. Of course, you can change it if you
    prefer:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成了组件之后，最后一步是添加我们的样式。这是用于番茄钟计时器的CSS。当然，如果你愿意，你可以进行更改：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'File: src/components/Pomodoro/Timer.css'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Pomodoro/Timer.css
- en: 'Don''t forget to import the `<Timer />` component into `App.js`. If you follow
    everything correctly, you should see the Pomodoro timerworking like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`<Timer />`组件导入到`App.js`中。如果你按照一切正确的步骤进行，你应该会看到番茄钟计时器的工作方式如下：
- en: 'Working:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作中：
- en: '![](assets/81c80738-f47f-401e-bc31-4b466d615a82.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81c80738-f47f-401e-bc31-4b466d615a82.png)'
- en: 'Taking a short break:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短时间休息：
- en: '![](assets/c83b17af-37eb-471d-b357-ec59075cf219.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c83b17af-37eb-471d-b357-ec59075cf219.png)'
- en: 'Taking a long break:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间休息：
- en: '![](assets/1199ed97-04e1-4fa4-bb9f-35d879943f67.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1199ed97-04e1-4fa4-bb9f-35d879943f67.png)'
- en: 'Buzzzz - time over!:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嗡嗡声 - 时间到了！：
- en: '![](assets/065a22f1-9ada-4ee5-92ae-55e7af538040.png)I challenge you to add
    a Play, Pause, and Reset buttons to control the timer.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/065a22f1-9ada-4ee5-92ae-55e7af538040.png)我向你挑战，添加一个播放、暂停和重置按钮来控制计时器。'
- en: Crypto coins exchanger – implementing shouldComponentUpdate
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币兑换器 - 实现shouldComponentUpdate
- en: Today, everyone is talking about Bitcoin, Ethereum, Ripple, and other cryptocurrencies.
    Let's create our own Crypto Coins Exchanger to learn how `shouldComponentUpdate` works.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，每个人都在谈论比特币、以太坊、瑞波和其他加密货币。让我们创建我们自己的加密货币兑换器，来学习`shouldComponentUpdate`是如何工作的。
- en: 'Our exchanger will look like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计时器将会是这样的：
- en: '![](assets/ea808246-e7f9-4527-8ae4-85f573f40fe3.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea808246-e7f9-4527-8ae4-85f573f40fe3.png)'
- en: 'We''ll sell entire coins. That means we won''t trade with decimals; everything
    should be an integer, and each currency costs $10 dollars**. **Our code is simple,
    so let''s take a look:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将出售整个硬币。这意味着我们不会用小数进行交易；一切都应该是整数，每种货币的成本是10美元**。**我们的代码很简单，所以让我们来看一下：
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'File: src/components/Coins/Coins.js'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Coins/Coins.js
- en: We are updating our dollars state every time the user writes something in the
    input and converting the value to a number, but if you run this code, you will
    probably notice that when you put in a number under 10, the message **You can
    buy 0 coins** doesn't change until you write 10, 20, 30, 40, and so on.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户在输入框中输入内容并将值转换为数字时，我们都会更新我们的dollars状态，但是如果你运行这段代码，你可能会注意到，当你输入小于10的数字时，消息**你可以购买0个硬币**直到你写下10、20、30、40等数字时才会改变。
- en: '`shouldComponentUpdate`:This method is one of the most important methods that
    improve the performance of our application. It receives two parameters (props,
    state) every time we update a local state, and when a prop is updated this method
    is executed. The returned value must be boolean, which means that if you intentionally
    write the following, your component will never update because this method will
    block it from updating:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`：这个方法是改善我们应用程序性能的最重要的方法之一。每当我们更新本地状态时，它都会接收两个参数（props，state），当一个prop被更新时，这个方法就会被执行。返回的值必须是布尔值，这意味着如果你有意写下面的内容，你的组件将永远不会更新，因为这个方法会阻止它更新：'
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But, on the other hand, if you return true or even if you don't define this
    method at all, the default behavior of React is always to update the component, which
    in some cases can cause a performance issue when we are rendering vast views and
    handling a lot of data that changes regularly.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，另一方面，如果你返回true，甚至如果你根本没有定义这个方法，React的默认行为总是更新组件，在某些情况下，当我们渲染大量视图并处理经常变化的大量数据时，这可能会导致性能问题。
- en: 'In our example, we are returning true only when the number of dollars that
    the user enters is a multiple of 10\. That''s why you only see the component updating
    in this case:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，只有当用户输入的美元数量是10的倍数时，我们才返回true。这就是为什么你只会在这种情况下看到组件更新：
- en: '![](assets/8c2d7386-d2d6-4ec5-be6b-e781097a21b6.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c2d7386-d2d6-4ec5-be6b-e781097a21b6.png)'
- en: 'But it is not going to work for numbers that are not multiples of 10:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是对于不是10的倍数的数字，它是不会起作用的：
- en: '![](assets/49507625-ed20-4e88-95cd-0d662fd310f5.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/49507625-ed20-4e88-95cd-0d662fd310f5.png)'
- en: 'Now, if we remove the `shouldComponentUpdate` method from our component or
    we directly return a `true` value, the component will update every time we write
    a number, and this will be the result:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们从组件中删除`shouldComponentUpdate`方法，或者直接返回一个`true`值，每次我们写一个数字，组件都会更新，这将是结果：
- en: '![](assets/75f61086-21c6-4837-bd44-6c5a57ff487b.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75f61086-21c6-4837-bd44-6c5a57ff487b.png)'
- en: 'As you can see, with `shouldComponentUpdate`, we can control the updates of
    our component, and this improves the performance of the application significantly.The
    last piece of our example is the CSS:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过`shouldComponentUpdate`，我们可以控制组件的更新，这显著提高了应用程序的性能。我们例子的最后一部分是CSS：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'File: src/components/Coins/Coins.css'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Coins/Coins.css
- en: Notes – implementing componentWillReceiveProps and componentWillUnmount
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 笔记 - 实现componentWillReceiveProps和componentWillUnmount
- en: 'In this example, we are going to create a simple list of notes where, every
    10 seconds, we will simulate that we receive an update from the service with new
    data, and with `componentWillReceiveProps`, we will register the last time we
    got an update from the server:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个简单的笔记列表，在这个列表中，每10秒，我们将模拟从服务接收到新数据的更新，并且通过`componentWillReceiveProps`，我们将记录我们上次从服务器接收到更新的时间：
- en: 'The `componentWillReceiveProps` method is called right before rendering. Like `shouldComponentUpdate`, it is
    called whenever new props are passed to the component, or the state has changed.
    In this example, we need to create fake data, but data normally needs to come
    from an actual service:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`方法在渲染之前被调用。像`shouldComponentUpdate`一样，每当新的props被传递给组件，或者状态发生改变时，它都会被调用。在这个例子中，我们需要创建假数据，但数据通常需要来自实际的服务：'
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'File: src/components/Notes/data.js'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Notes/data.js
- en: 'After we''ve created our fake data, let''s create our component:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建了假数据之后，让我们创建我们的组件：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'File: src/components/Notes/Notes.js'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Notes/Notes.js
- en: 'In this example, we are using the `moment.js`library. To install it, you need
    to run the following command:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`moment.js`库。要安装它，你需要运行以下命令：
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, in our `App.js` file, we are going to simulate that after 10 seconds of
    the first render, we will receive a new update from the service and render the
    new notes:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`App.js`文件中，我们将模拟在第一次渲染后10秒收到来自服务的新更新并渲染新的笔记：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'File: src/components/App.js'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: 'The last part is the CSS file:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一部分是CSS文件：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'File: src/components/Notes/Notes.css'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Notes/Notes.css
- en: 'If you run the application, you will see something like this:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到类似于这样的东西：
- en: '![](assets/d7508b74-c308-4345-aee1-68778a10ed3f.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/d7508b74-c308-4345-aee1-68778a10ed3f.png)
- en: 'After 10 seconds you will see this:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10秒后，您将看到这个：
- en: '![](assets/be3a42cb-a6ae-4dee-9e16-8dd99516de82.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/be3a42cb-a6ae-4dee-9e16-8dd99516de82.png)
- en: As you can see, the Last Update date has changed from 2018-02-20 00:07:28 to
    2018-02-20 00:07:**38** (10 seconds later).
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，最后更新日期已从2018-02-20 00:07:28更改为2018-02-20 00:07:**38**（10秒后）。
- en: '`componentWillUnmount`:This is the last method to be called immediately before
    the component is removed from the DOM. Generally, is used to perform a clean-up for
    any DOM elements or timers created by the `componentWillMount` method. Let''s
    modify our code a little bit to be able to call this method. In our `Notes` component,
    you can add this code after the `render` method:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`：这是在组件从DOM中被移除之前立即调用的最后一个方法。通常，用于对`componentWillMount`方法创建的任何DOM元素或定时器进行清理。让我们稍微修改我们的代码以便调用这个方法。在我们的`Notes`组件中，您可以在`render`方法之后添加这段代码：'
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We need to modify our `index.html` file to manually include a button that won''t
    be part of React:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改我们的`index.html`文件手动包含一个不会成为React的一部分的按钮：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'File: public/index.html'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：public/index.html
- en: 'And then, in our `index.js` file, where we are rendering our `<App />` component,
    let''s add some extra code (we need actually to remove the element from the DOM):'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的`index.js`文件中，我们正在渲染我们的`<App />`组件，让我们添加一些额外的代码（实际上我们需要从DOM中删除元素）：
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'File: src/index.js'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/index.js
- en: 'With this, we will have a hideous red button at the bottom of our page, and
    when we click it, we are going to unmount our component. The background will go
    black, and we will display the text "There is no mounted component!", and the
    console will display Hasta la vista baby!:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们将在页面底部有一个丑陋的红色按钮，当我们点击它时，我们将卸载我们的组件。背景将变黑，我们将显示文本“没有安装的组件！”，控制台将显示Hasta
    la vista baby！：
- en: '![](assets/ae76a546-97bb-4c7f-9e59-11b66531863a.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/ae76a546-97bb-4c7f-9e59-11b66531863a.png)
- en: 'After you click the button, you will see this:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮后，您将看到这个：
- en: '![](assets/e1a1ace9-acbc-49ed-a93c-bcc20d31817f.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/e1a1ace9-acbc-49ed-a93c-bcc20d31817f.png)
- en: C3.js chart – implementing componentDidUpdate
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C3.js图表 - 实现componentDidUpdate
- en: 'C3.js is a third-party library that makes it easy to generate D3-based charts
    by wrapping the code required to construct the entire chart. That means you don''t
    need to write any D3 code anymore:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: C3.js是一个第三方库，通过包装构建整个图表所需的代码，使得生成基于D3的图表变得容易。这意味着您不再需要编写任何D3代码：
- en: '`componentDidUpdate`:This React method is normally used to manage third-party
    UI elements and interact with the native UI. When we use a third-party library
    such as C3.js, we need to update the UI library with the new data. Install C3.js
    with npm:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate`：这个React方法通常用于管理第三方UI元素并与原生UI交互。当我们使用第三方库如C3.js时，我们需要使用新数据更新UI库。使用npm安装C3.js：'
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After we install C3.js, we need to add the C3 CSS file to our `index.html`.
    For now, we can use the CDN they provide:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装C3.js后，我们需要将C3 CSS文件添加到我们的`index.html`中。现在，我们可以使用他们提供的CDN：
- en: '[PRE68]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'File: public/index.html'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：public/index.html
- en: 'Now we can create our `Chart` component:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`Chart`组件：
- en: '[PRE69]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'File: src/components/Chart/Chart.js'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Chart/Chart.js
- en: 'As you can see, we are executing the `updateChart` method on `componentDidUpdate`,
    which is executed every time the user receives a new prop from `App.js`.Let''s
    add some logic that we need in our `App.js` file:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在`componentDidUpdate`上执行`updateChart`方法，每当用户从`App.js`接收新的props时都会执行。让我们在我们的`App.js`文件中添加一些我们需要的逻辑：
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'File: src/components/App.js'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: 'Now let''s add some basic styles to our `Chart` component:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们给我们的`Chart`组件添加一些基本样式：
- en: '[PRE71]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'File: src/components/Chart.css'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Chart.css
- en: 'In this case, we are creating some charts to display information about the
    most important cryptocurrencies today (BTC - Bitcoin, ETH - Ethereum and XRP -
    Ripple). This is how it should look:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一些图表来显示有关当今最重要的加密货币（BTC - 比特币，ETH - 以太坊和XRP - 瑞波）的信息。它应该是这样的：
- en: '![](assets/1174221c-8d3f-44bf-92b7-6b22e5155778.png)This image gives you an
    idea of how the line charts look like'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1174221c-8d3f-44bf-92b7-6b22e5155778.png)这张图片让你了解折线图是什么样子的'
- en: 'We have two buttons to switch between chart types (bar or line). If we click
    on BAR, we should see this chart:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个按钮可以在图表类型之间切换（柱状图或折线图）。如果我们点击BAR，我们应该看到这个图表：
- en: '![](assets/881f0098-b76d-4104-a56a-90d2e4f69b10.png)This image gives you an
    idea of how the bar charts look like.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/881f0098-b76d-4104-a56a-90d2e4f69b10.png)这张图片让你了解柱状图是什么样子的。'
- en: If you remove the `componentDidUpdate` method from the `Chart` component, then
    when you press the buttons the chart is not going to update. This is because every
    time we need to refresh the data, we need to call the `c3.generate` method, and
    in this case, React's `componentDidUpdate` method is very useful.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您从`Chart`组件中删除`componentDidUpdate`方法，那么当您按下按钮时，图表将不会更新。这是因为每当我们需要刷新数据时，我们需要调用`c3.generate`方法，在这种情况下，React的`componentDidUpdate`方法非常有用。
- en: Basic animation – implementing componentWillUpdate
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本动画 - 实现componentWillUpdate
- en: 'In this example, we are going to learn how to use `componentWillUpdate`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何使用`componentWillUpdate`：
- en: '`componentWillUpdate` allows you to manipulate a component just before it receives
    new props or a new state. It is typically used for animations. Let''s create a
    basic animation (fade in/fade out) to see how to use it:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`允许您在组件接收新的props或新的状态之前对组件进行操作。它通常用于动画。让我们创建一个基本的动画（淡入/淡出）来看如何使用它：'
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'File: src/components/Animation/Animation.js'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Animation/Animation.js
- en: 'As you can see, we are validating the show state with `newState` and observe
    that it is true. Then we add `opacity 0`, and if it is false, we add `opacity
    1`. An important thing I want to mention about `componentWillUpdate` is that you
    can''t update the state (which means you are not able to use `this.setState`)
    in this method because it will cause another call to the same method, creating
    an infinite loop. Let''s add some styles:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在用`newState`验证`show state`，并观察它是true。然后我们添加`opacity 0`，如果它是false，我们添加`opacity
    1`。关于`componentWillUpdate`我想提到的一件重要的事情是，您不能在这个方法中更新状态（这意味着您不能使用`this.setState`），因为这将导致对相同方法的另一个调用，从而创建一个无限循环。让我们添加一些样式：
- en: '[PRE73]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'File: src/components/Animation/Animation.css'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Animation/Animation.css
- en: 'If you run the application, you will see this view:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到这个视图：
- en: '![](assets/167ba80f-84d3-4d4e-b5ec-62a8a1fca076.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/167ba80f-84d3-4d4e-b5ec-62a8a1fca076.png)'
- en: 'After you click on the button, you will see an animation with the text fading
    out, and the red div will be expanded, giving you this result:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您点击按钮之后，您将看到一个文本淡出的动画，红色的div将被扩展，给您这个结果：
- en: '![](assets/c1e8a457-1fe6-4bb7-92d1-7bfd9669db4e.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1e8a457-1fe6-4bb7-92d1-7bfd9669db4e.png)'
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see with all those examples, React lifecycle methods are used to
    handle different scenarios in our application. In *[Chapter 5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml),
    Mastering Redux*, we are going to see how to implement Redux and how the lifecycle
    methods can work with Redux states.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以看到所有这些例子，React 生命周期方法被用来处理我们应用程序中的不同场景。在*[第5章](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml)，精通
    Redux*中，我们将看到如何实现 Redux 以及生命周期方法如何与 Redux 状态一起工作。
- en: Understanding React Pure Components
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React Pure Components
- en: 'Many people get confused by the difference between a Functional Component and
    a Pure Component. Most of them think they are the same, but this is not true.
    When we use a Pure Component, we need to import `PureComponent` from React:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人对函数组件和纯组件之间的区别感到困惑。他们中的大多数人认为它们是相同的，但这是不正确的。当我们使用纯组件时，我们需要从 React 中导入 `PureComponent`：
- en: '[PRE74]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If your React component's render method is "pure" (that means it renders the
    same result, given the same props and state), you can use this function to improve
    the performance of your application. A Pure Component performs a shallow comparison
    for the props and nextProps objects as well as the state and nextState objects.
    Pure components do not include the `shouldComponentUpdate(nextProps, nextState)`
    method, and if we try to add it, we will get a warning from React.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 React 组件的 render 方法是“纯”的（这意味着它根据相同的 props 和 state 渲染相同的结果），你可以使用这个函数来提高你的应用程序的性能。纯组件对
    props 和 nextProps 对象以及 state 和 nextState 对象进行浅比较。纯组件不包括 `shouldComponentUpdate(nextProps,
    nextState)` 方法，如果我们尝试添加它，我们将收到来自 React 的警告。
- en: '![](assets/ac0abe9f-9602-4501-85c5-cabaff680fa4.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ac0abe9f-9602-4501-85c5-cabaff680fa4.png)'
- en: In this recipe, we will create a basic example to understand how Pure Components
    works.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个基本的例子来理解 Pure Components 是如何工作的。
- en: Getting ready
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to install the Chrome extension React Developer Tools
    to do a simple debug in our application. In [Chapter 12](1daa68c4-442d-479f-b1b6-3efa80592901.xhtml),
    Testing and Debugging, we will delve into this topic.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要安装 Chrome 扩展 React Developer Tools 来在我们的应用程序中进行简单的调试。在[第12章](1daa68c4-442d-479f-b1b6-3efa80592901.xhtml)，测试和调试中，我们将深入探讨这个主题。
- en: You can download React Developer Tools from [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)下载
    React Developer Tools。
- en: How to do it…
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create a component where we will sum all the numbers entered in an
    input. We can take some of the last recipes to start from there:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个组件，其中我们将对输入的所有数字进行求和。我们可以从最后的一些示例中开始：
- en: 'The first thing we will do is to modify our `App.js` and include the Numbers
    component:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们要做的是修改我们的 `App.js` 并包括 Numbers 组件：
- en: '[PRE75]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'File: src/components/App.js'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: 'Now we will create the Numbers component:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建 Numbers 组件：
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'File: src/components/Numbers/Numbers.js'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Numbers/Numbers.js
- en: 'Then, let''s create the Result component (as a Class Component):'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建 Result 组件（作为一个类组件）：
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'File: src/components/Numbers/Result.js'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Numbers/Result.js
- en: 'Finally, the styles:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，样式：
- en: '[PRE78]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'File: src/components/Numbers/Numbers.css'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Numbers/Numbers.css
- en: How it works…
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'If you run the application, you will see this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你会看到这个：
- en: '![](assets/da16b38c-61c7-4f56-bb6e-6e4e5b79dbc4.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da16b38c-61c7-4f56-bb6e-6e4e5b79dbc4.png)'
- en: As you can see, we are using an input with type number, which means we will
    only accept numbers if you start writing numbers (1, then 2, then 3, and such),
    you will see the results of the sum on each row (0 + 1 = **1**, 1 + 2 = **3**,
    3 + 3 = **6**).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用的是类型为数字的输入，这意味着如果你开始输入数字（1，然后2，然后3，等等），你将看到每一行的求和结果（0 + 1 = **1**，1
    + 2 = **3**，3 + 3 = **6**）。
- en: '![](assets/97ddc724-b477-4d01-a79e-52f3782eff44.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/97ddc724-b477-4d01-a79e-52f3782eff44.png)
- en: Probably this looks very simple to you, but if let's inspect the application
    using React Developer Tools, we need to enable the Highlight Updates option.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对你来说，这可能看起来很简单，但是如果我们使用React开发者工具来检查应用程序，我们需要启用“高亮更新”选项。
- en: '![](assets/49a2ab49-32a0-40ba-9de3-bb72d58e19ee.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/49a2ab49-32a0-40ba-9de3-bb72d58e19ee.png)
- en: After this, start writing multiple numbers in the input (quickly), and you will
    see all the renders that React is performing.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，快速在输入框中输入多个数字，你将看到React正在执行的所有渲染。
- en: '![](assets/de4fb8e3-93b4-409a-98cd-31234874ff9c.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/de4fb8e3-93b4-409a-98cd-31234874ff9c.png)
- en: 'As you can see, React is doing a lot of renderings. When the highlights are
    red, it means the performance of that component is not good. Here''s when Pure
    Components will help us; let''s migrate our Result component to be a Pure Component:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，React正在进行大量的渲染。当高亮显示为红色时，意味着该组件的性能不佳。这就是Pure Components将帮助我们的地方；让我们将我们的Result组件迁移到成为Pure
    Component：
- en: '[PRE79]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'File: src/components/Numbers/Result.js'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Numbers/Result.js
- en: Now if we try to do the same with the numbers, let's see the difference.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试对数字做同样的事情，让我们看看有什么不同。
- en: '![](assets/79143d3f-f02c-4263-849d-5c76f3f97b30.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/79143d3f-f02c-4263-849d-5c76f3f97b30.png)
- en: 'As you can see, with the Pure Component React, do less renders in comparison
    to a Class Component. Probably now you think that if we use a Stateless component
    instead of a Pure Component, the result will be the same. Unfortunately, this
    won''t happen; if you want to verify this, let''s change the Result component
    again and convert it into a Functional Component.:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用Pure Component React与Class Component相比，渲染次数较少。也许现在你认为，如果我们使用无状态组件而不是Pure
    Component，结果将是相同的。不幸的是，这不会发生；如果你想验证这一点，让我们再次更改Result组件，并将其转换为Functional Component。：
- en: '[PRE80]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'File: src/components/Numbers/Result.js'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Numbers/Result.js
- en: Even the code is less, but let's see what happen with the renders.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码更少，但让我们看看渲染发生了什么。
- en: '![](assets/087b2535-7c5f-4639-8494-e7c20374a4b7.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/087b2535-7c5f-4639-8494-e7c20374a4b7.png)
- en: As you can see, the result is the same as the Class Component, which means not
    all the time using a Stateless component necessary will help us improve the performance
    of our application. If you have components that you consider are pure, consider
    converting them into Pure components.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，结果与Class Component相同，这意味着并非始终使用无状态组件必然会帮助我们改善应用程序的性能。如果你认为某些组件是纯粹的，请考虑将它们转换为Pure
    components。
- en: Preventing XSS vulnerabilities in React
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中防止XSS漏洞
- en: In this recipe, we are going to learn about cross-site scripting (XSS) vulnerabilities
    in React. XSS attacks are widespread in web applications, and some developers
    are still not aware of this. XSS attacks are malicious scripts that are injected
    into the DOM of unprotected web applications. The risks can vary with each application.
    It could just be an innocent alert script injection or, worse, someone can get
    access to your cookies and steal your private credentials (passwords), for example.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习有关React中跨站脚本（XSS）漏洞的知识。XSS攻击在Web应用程序中很常见，一些开发人员仍然不知道这一点。XSS攻击是恶意脚本，被注入到未受保护的Web应用程序的DOM中。每个应用程序的风险都可能不同。它可能只是一个无害的警报脚本注入，或者更糟糕的是，有人可以访问你的Cookie并窃取你的私人凭据（密码）。
- en: Let's create an XSS component to start playing around a little bit with some
    XSS attacks. We are going to have a response variable that is simulating a response
    from a real server, and we will simulate that we are using Redux's initial state (we
    are going to see Redux in *[Chapter 5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml),
    Mastering Redux*).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个XSS组件，开始玩一下XSS攻击。我们将有一个模拟来自真实服务器的响应的变量，并且我们将模拟使用Redux的初始状态（我们将在第5章中看到Redux，精通Redux）。
- en: How to do it...
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'We will now see how to create our XSS component:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何创建我们的XSS组件：
- en: 'Create an XSS component:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个XSS组件：
- en: '[PRE81]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Xss/Xss.js
- en: 'If you render this component, you will see something like this:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您呈现此组件，您将看到类似以下的内容：
- en: '![](assets/5237a4d6-1d66-4b9e-bcf8-005a133c9ada.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5237a4d6-1d66-4b9e-bcf8-005a133c9ada.png)'
- en: As you can see, by default, React prevents us from injecting HTML code directly
    into our components. It is rendering the HTML as a string. This is good, but sometimes
    we need to insert HTML code in our components.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，默认情况下，React会阻止我们直接向组件中注入HTML代码。它会将HTML呈现为字符串。这很好，但有时我们需要在组件中插入HTML代码。
- en: 'Implementing `dangerouslySetInnerHTML`*:*This prop probably scares you a little
    bit (maybe because it explicitly says the word danger!). I''m going to show you
    that this prop is not too bad if we know how to use it securely.Let''s modify
    our previous code, and we are going to add this prop to see how the HTML is rendering
    it now:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`dangerouslySetInnerHTML`：这个属性可能会让你有点害怕（也许是因为它明确地说出了“危险”这个词！）。我将向您展示，如果我们知道如何安全地使用它，这个属性并不太糟糕。让我们修改我们之前的代码，然后我们将添加这个属性来看看HTML是如何渲染的：
- en: '[PRE82]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Xss/Xss.js
- en: 'Our site should now look like this:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的网站现在应该是这样的：
- en: '![](assets/8b877eca-d229-4b4e-801b-5a191683871b.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b877eca-d229-4b4e-801b-5a191683871b.png)'
- en: It is interesting, probably you thought that the content of "My blog post 2"
    will fire an alert in the browser but does not. If we inspect the code the alert
    script is there.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很有趣，也许您认为“我的博客文章2”的内容会在浏览器中触发警报，但实际上并没有。如果我们检查代码，警报脚本是存在的。
- en: '![](assets/2a74381f-e333-4620-913b-70446e824d4e.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2a74381f-e333-4620-913b-70446e824d4e.png)'
- en: 'Even if we use `dangerouslySetInnerHTML`,React protects us from malicious scripts
    injections, but it is not secure enough for us to relax on the security aspect
    of our site. Now let''s see the issue with My blog post 3 content. The code **`<img onmouseover="alert(''This
    site is not secure'');" src="attack.jpg" />`** is not directly using a `<script>`
    tag to inject a malicious code, but is using an `img` tag with an event (`onmouseover`).
    So, if you were happy about React''s protection, we can see that this XSS attack
    will be executed if we move the mouse over the image:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使我们使用`dangerouslySetInnerHTML`，React也会保护我们免受恶意脚本注入的影响，但这对我们来说还不够安全，我们不能放松对网站安全性的警惕。现在让我们看看“我的博客文章3”的内容存在的问题。代码`<img
    onmouseover="alert('This site is not secure');" src="attack.jpg" />`并不直接使用`<script>`标签来注入恶意代码，而是使用了一个带有事件（`onmouseover`）的`img`标签。因此，如果您对React的保护感到满意，我们可以看到，如果我们将鼠标移到图像上，这个XSS攻击将被执行：
- en: '![](assets/ff3f07da-b726-4e70-be35-06d32a7a9192.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff3f07da-b726-4e70-be35-06d32a7a9192.png)'
- en: '**Removing XSS attacks**:This is kind of scary, right? But as I said at the
    beginning of this recipe, there is a secure way to use dangerouslySetInnerHTMLand,
    yes, as you may be thinking right now, we need to clean our code of malicious
    scripts before we render it with dangerouslySetInnerHTML. The next script will
    take care of removing `<script>` tags and events from tags, but of course, you
    can modify this depending on the security level you want to have:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除XSS攻击：这有点可怕，对吧？但正如我在本教程开头所说的，有一种安全的方法来使用`dangerouslySetInnerHTML`，是的，正如你现在可能在想的那样，我们需要在使用`dangerouslySetInnerHTML`渲染之前清理我们的恶意脚本。下一个脚本将负责删除`<script>`标签和标签中的事件，当然，你可以根据你想要的安全级别进行修改：
- en: '[PRE83]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Xss/Xss.js
- en: 'If we look at the code now, we will see that now our render is more secure:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看代码，我们会发现现在我们的渲染更加安全：
- en: '![](assets/4cf149d2-6a90-40ea-9cc1-0a1364ae1612.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4cf149d2-6a90-40ea-9cc1-0a1364ae1612.png)'
- en: '**The problem with JSON.stringify**:So far, we have learned how to inject HTML
    code into a React component with `dangerouslySetInnerHTML`, but there is another
    potential security issue using JSON.stringify. If we have an XSS attack (`<script>`
    tag inside the content) in our response and then we use JSON.stringify to convert
    the object to a string, the HTML tags are not encoded. That means that if we inject
    the string into our HTML (like Redux does with the initial state), we will have
    a potential security issue*.*The output of `JSON.stringify(response)` is this:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON.stringify的问题：到目前为止，我们已经学会了如何使用`dangerouslySetInnerHTML`将HTML代码注入到React组件中，但是使用JSON.stringify也存在潜在的安全问题。如果我们的响应中存在XSS攻击（内容中包含`<script>`标签），然后我们使用JSON.stringify将对象转换为字符串，那么HTML标签将不会被编码。这意味着，如果我们将该字符串注入到我们的HTML中（就像Redux在初始状态中所做的那样），我们将会有潜在的安全问题。`JSON.stringify(response)`的输出如下：
- en: '[PRE84]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'As you can see, all the HTML is exposed without any encoding characters, and
    that is a problem. But how we can fix this? We need to install a package called `serialize-javascript`:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，所有的HTML都是裸露的，没有任何编码字符，这是一个问题。但是我们如何解决这个问题呢？我们需要安装一个叫做`serialize-javascript`的包：
- en: '[PRE85]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Instead of using `JSON.stringify`, we need to serialize the code like this:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用`serialize`而不是`JSON.stringify`来序列化代码，像这样：
- en: '[PRE86]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output of the console is as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台的输出如下：
- en: '[PRE87]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now that we have our code with HTML entities (encoded) instead of directly
    having HTML tags, and the good news is that we can use `JSON.parse` to convert
    this string again into our original object. Our component should look like this:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的代码中有HTML实体（已编码）而不是直接包含HTML标签，好消息是我们可以使用`JSON.parse`将这个字符串再次转换为我们原始的对象。我们的组件应该是这样的：
- en: '[PRE88]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Xss/Xss.js
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, XSS attacks are widespread, and many websites suffer from this
    problem without knowing it. There are other injections attacks, such as SQL injections,
    that could happen in an API if we don't take minimal security precautions.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，XSS攻击是很普遍的，许多网站都在不知情的情况下遭受这种问题。还有其他的注入攻击，比如SQL注入，在API中如果我们不采取最低限度的安全预防措施，可能会发生。
- en: There's more...
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are some security recommendations:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些安全建议：
- en: Always sanitize users' content that comes from forms.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终对来自表单的用户内容进行清理。
- en: Always use `serialize` instead of `JSON.stringify`.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用`serialize`而不是`JSON.stringify`。
- en: Use `dangerouslySetInnerHTML` only when absolutely necessary.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在绝对必要时使用`dangerouslySetInnerHTML`。
- en: Do unit tests for your components, and try to cover all the possible XSS attacks
    (we are going to see unit tests in [Chapter 12](1daa68c4-442d-479f-b1b6-3efa80592901.xhtml)*,
    Testing and Debugging*).
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的组件编写单元测试，并尝试覆盖所有可能的XSS攻击（我们将在[第12章](1daa68c4-442d-479f-b1b6-3efa80592901.xhtml)中看到单元测试，测试和调试）。
- en: Always encrypt passwords with `sha1` and `md5`, and do not forget to add a salt
    value (for example, if the password is `abc123`, then your salt can be encrypted
    like this: `sha1(md5('$4ltT3xt_abc123'))`.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用`sha1`和`md5`加密密码，并不要忘记添加盐值（例如，如果密码是`abc123`，那么你的盐可以像这样加密：`sha1(md5('$4ltT3xt_abc123'))`。
- en: If you use cookies to store sensitive information (personal information and
    passwords mainly), you can save the cookie with Base64 to obfuscate the data.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用cookie来存储敏感信息（主要是个人信息和密码），你可以使用Base64保存cookie以混淆数据。
- en: Add some protection to your API (security tokens) unless you need to be public.
    There is a recipe about security tokens in [Chapter 8](41637135-a49d-409a-bbbe-2928609e749b.xhtml)*,
    Creating an API with Node.js Using MongoDB and MySQL*.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API添加一些保护（安全令牌），除非你需要公开。在[第8章](41637135-a49d-409a-bbbe-2928609e749b.xhtml)*《使用Node.js和MongoDB以及MySQL创建API》*中有关安全令牌的方法。
