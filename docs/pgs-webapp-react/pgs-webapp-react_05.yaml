- en: Routing with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React进行路由
- en: '"We''ve expanded the feature list."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我们已经扩展了功能列表。”
- en: You suppress a groan and wait.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你忍住一声叹息，等待。
- en: '"We want to give our users everything. Everything they need, everything they
    want, everything they could possibly ever desire."'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “我们想给我们的用户一切。他们需要的一切，他们想要的一切，他们可能永远想要的一切。”
- en: '"Okay," you say. "But this is a prototype…"'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，”你说。“但这只是一个原型…”
- en: '"A page for analytics, a page for their profile, a page for their friend''s
    analytics, a page for taking notes, a page for the weather."'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “一个用于分析的页面，一个用于他们的个人资料，一个用于他们朋友的分析，一个用于做笔记，一个用于天气。”
- en: You quietly show yourself out, repeating under your breath, "It's a prototype."
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你悄悄地走出去，低声重复着，“这只是一个原型。”
- en: The plan
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划
- en: We've now arrived at the point where our application is technically working
    (in that we allow users to log in) but is lacking in real, useful content. It's
    time to change that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了技术上工作的应用程序的点（允许用户登录），但缺乏真正有用的内容。是时候改变了。
- en: To do so, however, we need to add additional pages to our application. Some
    of you may have heard the term **Single-Page Application** (**SPA**), which is
    used to refer to React apps and therefore may be confused by this talk of more
    pages. We'll cover that distinction as we move further on, and then move into
    our actual routing setup using React Router.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了这样做，我们需要向我们的应用程序添加额外的页面。你们中的一些人可能听说过**单页应用程序**（**SPA**）这个术语，它用来指代React应用程序，因此可能会对更多页面的讨论感到困惑。随着我们进一步深入，我们将涵盖这个区别，然后进入使用React
    Router进行实际路由设置。
- en: 'Here''s what we''ll learn:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学到什么：
- en: How to install and use React Router v4
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和使用React Router v4
- en: How to add additional routes to additional components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为其他组件添加额外的路由
- en: How to move between routes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在路由之间移动
- en: Pages on pages
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面上的页面
- en: 'Luckily, saner heads prevail and the head product designer (the highest ranked
    of the five designers now employed by the company) says that they need only three
    views for the prototype: the login view (done!), the main chat view, and the user
    profile view.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，理智的头脑占上风，产品主设计师（公司目前雇佣的五名设计师中排名最高的）表示他们只需要原型的三个视图：登录视图（已完成！）、主要聊天视图和用户个人资料视图。
- en: Still, we clearly need a robust and extensible way to move between different
    screens in our app. We need a good solid routing solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显然我们需要一种强大且可扩展的方法来在我们的应用程序中在不同的屏幕之间切换。我们需要一个良好而坚实的路由解决方案。
- en: Traditionally, routing has been a question of which HTML/CSS/JavaScript files
    are served up. You hit the URL at [static-site.com](http://static-site.com) and
    get the main `index.html`, then go to [static-site.com/resources](http://static-site.com/resources)
    and get the `resources.html`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，路由一直是关于提供哪些HTML/CSS/JavaScript文件的问题。你在[static-site.com](http://static-site.com)上输入URL，得到主`index.html`，然后转到[static-site.com/resources](http://static-site.com/resources)并得到`resources.html`。
- en: In this model, the server gets a request for a certain URL and returns the appropriate
    files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，服务器收到对特定URL的请求并返回相应的文件。
- en: Increasingly, however, routing is moving to the client side. In a React world,
    we only ever serve up our `index.html` and `bundle.js`. Our JavaScript takes in
    the URL from the browser and then decides what JSX to render.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，越来越多的情况下，路由正在转移到客户端。在React世界中，我们只提供我们的`index.html`和`bundle.js`。我们的JavaScript从浏览器中获取URL，然后决定渲染什么JSX。
- en: Hence the term Single-Page App--our user technically only ever sits on one page
    (if we look at it from the traditional model). However, they're able to navigate
    between other views, and do so in a much more streamlined way, without having
    to request more files from the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此有了单页应用程序这个术语--从传统模型来看，我们的用户技术上只坐在一个页面上。然而，他们能够在其他视图之间导航，并且以更加流畅的方式进行，而无需从服务器请求更多文件。
- en: Our top-level container component (`App.js`) will always be rendered, but what
    changes is what is rendered inside it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶层容器组件（`App.js`）将始终被渲染，但变化的是其内部渲染的内容。
- en: The React Router difference
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React路由的不同之处
- en: For some React routing solutions, the model will look something like the following.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些React路由解决方案，模型看起来可能是这样的。
- en: 'We will render our initial screen, as shown:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染我们的初始屏幕，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will fit with the URL of `chatastrophe.com/login`. When the user completes
    the login, we will send them to `chatastrophe.com/chat`. At that point, we will
    call `ReactDOM.render` with the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适用于`chatastrophe.com/login`的URL。当用户完成登录后，我们将把他们发送到`chatastrophe.com/chat`。在那时，我们将使用以下方式调用`ReactDOM.render`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: React's reconciliation engine will then compare the old app with the new app
    and swap out the components that have changes; in this case, it will swap `LoginContainer`
    for `ChatContainer`, without rerendering `App`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，React的协调引擎将比较旧应用程序和新应用程序，并交换具有更改的组件；在这种情况下，它将`LoginContainer`替换为`ChatContainer`，而不重新渲染`App`。
- en: 'Here''s a very simple example of what that may look like, using a basic routing
    solution called `page.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个非常简单的示例，使用了一个名为`page.js`的基本路由解决方案：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This solution works fine. We're able to navigate between multiple views, and
    React's reconciliation ensures that there's no wasteful rerendering of unchanged
    components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案运行良好。我们能够在多个视图之间导航，而React的协调确保没有不必要的重新渲染未更改的组件。
- en: However, this solution is not very React-y. We're passing our entire application
    to `ReactDOM.render` each time we change the page, which leads to lots of repeated
    code in our `router.js` file. We're defining multiple versions of our application,
    rather than choosing precisely which components should render at which time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案并不是非常符合React的特点。每次我们改变页面时，我们都将整个应用程序传递给`ReactDOM.render`，这导致我们的`router.js`文件中有大量重复的代码。我们定义了多个版本的应用程序，而不是精确选择应该在何时渲染哪些组件。
- en: In other words, this solution imposes a holistic approach to routing, rather
    than one split up by components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个解决方案强调了路由的整体方法，而不是通过组件分割的方法。
- en: Enter `React Router v4`, a complete rewrite of the library, which used to be
    a more traditional routing solution. The difference is that routes are now components
    that render based on the URL.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`React Router v4`，这是该库的完全重写，它曾经是一个更传统的路由解决方案。不同之处在于现在路由是基于URL渲染的组件。
- en: 'Let''s talk about what that means exactly by rewriting our earlier example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重新编写我们之前的示例来详细讨论这意味着什么：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we only call `ReactDOM.render` once. We render our application, and within
    it, render two `Route` components wrapping our two containers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只调用一次`ReactDOM.render`。我们渲染我们的应用程序，并在其中渲染两个包裹我们两个容器的`Route`组件。
- en: Each `Route` takes a `path` prop. If the URL in the browser matches that `path`,
    the `Route` will render its child component (the container); otherwise, it will
    render nothing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Route`都有一个`path`属性。如果浏览器中的URL与该`path`匹配，`Route`将渲染其子组件（容器）；否则，它将不渲染任何内容。
- en: We never try to rerender our `App`. As it should be, it stays static. Furthermore,
    our routing solution is no longer kept separate from our components in a `router.js`
    file. Now, it lives within our components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从不尝试重新渲染我们的`App`。它应该保持静态。此外，我们的路由解决方案不再与我们的组件分开存放在一个`router.js`文件中。现在，它存在于我们的组件内部。
- en: We can also nest our routes further within our components. Inside `LoginContainer`,
    we can add two routes--one for `/login`, and one for `/login/new`--if we wanted
    to have separate login and signup views.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在组件内进一步嵌套我们的路由。在`LoginContainer`内部，我们可以添加两个路由--一个用于`/login`，一个用于`/login/new`--如果我们想要有单独的登录和注册视图。
- en: In this model, every component can make a decision about what to render, based
    on the current URL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，每个组件都可以根据当前的URL做出渲染的决定。
- en: I'll be honest, this approach is a bit weird to get used to, and I did not like
    it one bit when I started using it. For experienced developers, it requires thinking
    about your routing in a different way, rather than as a top-down, whole-page decision
    about what to render, you're now encouraged to make decisions at a component level,
    which can be difficult.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我会诚实，这种方法有点奇怪，需要时间适应，当我开始使用它时，我一点也不喜欢。对于有经验的开发人员来说，它需要以一种不同的方式思考你的路由，而不是作为一个自上而下的、整个页面决定要渲染什么的决定，现在鼓励你在组件级别做决定，这可能会很困难。
- en: After some time working with it, however, I think this paradigm is exactly what's
    needed for a React approach to routing, and will give developers far more flexibility
    down the line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，经过一段时间的使用，我认为这种范式正是React路由所需要的，将为开发人员提供更多的灵活性。
- en: Okay, enough talk. Let's create our second view--the chat screen--where users
    can view and send messages to everyone in the world at once ("global interconnectivity",
    you know). First, we'll create a basic component, and then we can get started
    with our routing solution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，说了这么多。让我们创建我们的第二个视图--聊天界面--用户可以在这里查看并向全世界的人发送消息（你知道，“全球互联”）。首先，我们将创建一个基本组件，然后我们可以开始使用我们的路由解决方案。
- en: Our ChatContainer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的ChatContainer
- en: Creating a component should be old news by now. Our `ChatContainer` will be
    a class-based component, since we’ll need to tap into some lifecycle methods down
    the line (more on that later).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组件现在应该是老生常谈了。我们的`ChatContainer`将是一个基于类的组件，因为我们将需要在后面利用一些生命周期方法（稍后会详细介绍）。
- en: 'Inside our `components` folder, create a file called `ChatContainer.js`. Then,
    set up our skeleton:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`components`文件夹中，创建一个名为`ChatContainer.js`的文件。然后，设置我们的骨架：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s continue our pattern of wrapping our component in a `div` with an `id`
    of the component name:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续包装我们的组件，使用组件名称作为`div`的`id`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just as at the top of our `LoginContainer`, we will want to render our beautiful
    logo and title for our user to see. If only we had some sort of reuseable component
    so that we didn''t have to rewrite that code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的`LoginContainer`顶部一样，我们希望渲染我们美丽的标志和标题供用户查看。如果我们有某种可重用的组件，这样我们就不必重写那段代码了：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is beautiful. Okay, let's just add `<h1>Hello from ChatContainer</h1>`
    after the `Header` and move on to routing so that we can actually see what we're
    doing as we work. Right now, our `ChatContainer` isn't visible. To change that,
    we need to set up React Router.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这太美妙了。好吧，让我们在`Header`后面添加`<h1>Hello from ChatContainer</h1>`，然后继续进行路由，这样我们在工作时就可以实际看到我们在做什么。现在，我们的`ChatContainer`是不可见的。要改变这种情况，我们需要设置React
    Router。
- en: Installing React Router
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装React Router
- en: Let's start with the basics. Run the following in the Terminal from the project
    root.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。从项目根目录在终端中运行以下命令。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `react-router-dom` contains all the React components we could want for routing
    our user through our application. You can view the full documentation for it at
    [https://reacttraining.com/react-router](https://reacttraining.com/react-router).
    The only components we’ll be interested in, however, are `Route` and `BrowserRouter`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom`包含了我们在应用程序中为用户进行路由所需的所有React组件。您可以在[https://reacttraining.com/react-router](https://reacttraining.com/react-router)上查看完整的文档。然而，我们感兴趣的唯一组件是`Route`和`BrowserRouter`。'
- en: It's important to ensure that you install `react-router-dom` and not `react-router`.
    Since version 4 was released, the package has been split into various branches.
    `React-router-dom` is specifically geared towards providing routing components,
    which is what we’re interested in. Note that it installed `react-router` as a
    peer dependency, though.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要确保您安装的是`react-router-dom`而不是`react-router`。自从发布了第4版以后，该软件包已被拆分为各种分支。`React-router-dom`专门用于提供路由组件，这正是我们感兴趣的。请注意，它安装了`react-router`作为对等依赖。
- en: The `Route` component is rather simple; it takes a prop called `path`, which
    is a string such as `/` or `/login`. When the URL in the browser matches that
    string ([http://chatastrophe.com/login](http://chatastrophe.com/login)), the `Route`
    component renders the component, which is passed in via the `component` prop;
    otherwise, it renders nothing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`组件相当简单；它接受一个名为`path`的属性，这是一个字符串，比如`/`或`/login`。当浏览器中的URL与该字符串匹配（[http://chatastrophe.com/login](http://chatastrophe.com/login)），`Route`组件渲染通过`component`属性传递的组件；否则，它不渲染任何内容。'
- en: As with anything in web development, there's a lot of additional complexity
    to how you can use the `Route` component. We'll dive into it a bit more later
    on. For now, however, we only want to conditionally render either `ChatContainer`
    or `LoginContainer`, based on whether our path is `/` or `/login`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web开发中的任何内容一样，您可以使用`Route`组件的方式有很多额外复杂性。我们稍后会更深入地探讨这个问题。但是，现在，我们只想根据我们的路径是`/`还是`/login`有条件地渲染`ChatContainer`或`LoginContainer`。
- en: '`BrowserRouter` is more complicated, but for our purposes, it will be simple
    to use. Essentially, it ensures that our `Route` components are kept in sync (either
    rendering or not rendering) with the URL. It uses the HTML5 history API to do
    so.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserRouter`更复杂，但对于我们的目的，使用起来会很简单。基本上，它确保我们的`Route`组件与URL保持同步（渲染或不渲染）。它使用HTML5历史API来实现这一点。'
- en: Our BrowserRouter
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的BrowserRouter
- en: The first thing we need to do is wrap our entire application in the `BrowserRouter`
    component, then we can add our `Route` components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将整个应用程序包装在`BrowserRouter`组件中，然后我们可以添加我们的`Route`组件。
- en: 'Since we want to have our router around our entire application, the easiest
    place to add it is in our `src/index.js`. At the top, we require the following
    component:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在整个应用程序周围使用路由器，最容易添加它的地方是在我们的`src/index.js`中。在顶部，我们要求以下组件：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we render our `App` as a child of `BrowserRouter`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的`App`作为`BrowserRouter`的子级进行渲染：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should also do the same inside our hot re-loader configuration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该在我们的热重新加载器配置中执行相同的操作：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Done! Now we can actually start adding routes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在我们实际上可以开始添加路由了。
- en: Our first two Routes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的前两个路由
- en: 'Inside our `App` component, we currently render `LoginContainer`, no matter
    what:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`App`组件中，我们目前无论如何都会渲染`LoginContainer`：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We want to change this logic so that we render either `LoginContainer` only
    or we render `ChatContainer`. To do that, let's require it in our `ChatContainer`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望改变这个逻辑，以便只渲染`LoginContainer`或者渲染`ChatContainer`。为了做到这一点，让我们在`ChatContainer`中要求它。
- en: 'We''ll also require our `Route` component from `react-router-dom`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从`react-router-dom`中要求我们的`Route`组件：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I put the `Route` import above the two `Container` imports. Best practices say
    you should put absolute imports (imports from `node_modules`) before relative
    imports (files imported from within `src`). This keeps things clean.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`Route`导入放在了两个`Container`导入的上面。最佳实践是，你应该在相对导入（从`src`内导入的文件）之前放置绝对导入（从`node_modules`导入）。这样可以保持代码整洁。
- en: 'Now, we can replace our containers with `Route` components that take a `component`
    prop:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用接受`component`属性的`Route`组件替换我们的容器：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We pass in our component prop as `LoginContainer`, and not as `<LoginContainer
    />`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的组件属性传递为`LoginContainer`，而不是`<LoginContainer />`。
- en: 'Our app reloads and we see… a mess:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序重新加载，我们看到...一团糟：
- en: '![](../images/00033.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: We're currently rendering both containers at once! Oops. The problem is that
    we failed to give our `Route` a `path` prop that tells them when to render (and
    when not to). Let's do that now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前同时渲染两个容器！糟糕。问题在于我们没有给我们的`Route`一个`path`属性，告诉它们何时渲染（以及何时不渲染）。让我们现在来做。
- en: 'Our first `Route`, the `LoginContainer`, is to be rendered when we''re at the
    `/login` route, so we add a path as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`Route`，`LoginContainer`，应该在`/login`路由时渲染，因此我们添加了如下路径：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our other container, `ChatContainer`, will be shown when the user is at the
    root, "`/`" (at `localhost:8080/` currently, or [https://chatastrophe-77bac.firebaseapp.com/](https://chatastrophe-77bac.firebaseapp.com/)
    for our deployed app), so we add a path as shown:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在根路径“/”（当前在`localhost:8080/`，或者在我们部署的应用[https://chatastrophe-77bac.firebaseapp.com/](https://chatastrophe-77bac.firebaseapp.com/)）时，我们的另一个容器`ChatContainer`将被显示，因此我们添加了如下路径：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save, check the app, and you get the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 保存，检查应用程序，你会得到以下结果：
- en: '![](../images/00034.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: 'Nice! Our `LoginContainer` no longer renders. Let''s head over to `/login`
    and ensure that we only see our `LoginContainer` there:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们的`LoginContainer`不再渲染。让我们前往`/login`，确保我们只在那里看到我们的`LoginContainer`：
- en: '![](../images/00033.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: Augh!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！
- en: We're rendering both containers at `/login`. What happened?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`/login`处同时渲染两个容器。发生了什么？
- en: Well, long story short, React Router uses a **RegEx** pattern to match routes
    and determine what to render. Our current path (`/login`) matches the prop passed
    to our login `Route`, but it also technically matches `/`. In fact, everything
    matches `/`, which is great if you have a component you want to render on every
    page, but we want our `ChatContainer` to only render when the path is `/` (with
    nothing else).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，React Router使用**RegEx**模式来匹配路由并确定要渲染的内容。我们当前的路径（`/login`）匹配了传递给我们登录`Route`的属性，但它也在技术上匹配了`/`。实际上，一切都匹配`/`，这对于你想要在每个页面上渲染一个组件是很好的，但我们希望我们的`ChatContainer`只在路径为`/`（没有其他内容）时才渲染。
- en: In other words, we want to render the `ChatContainer` route when the path is
    an exact match for `/`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望在路径精确匹配`/`时渲染`ChatContainer`路由。
- en: 'The good news is that React Router is prepared for this problem; simply add
    a prop `exact` to our `Route`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，React Router已经为这个问题做好了准备；只需在我们的`Route`中添加一个`exact`属性：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding is the same as writing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容与写作如下相同：
- en: '`<Route exact={true} path="/" component={ChatContainer} />`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Route exact={true} path="/" component={ChatContainer} />`'
- en: When we check `/login`, we should only see our `LoginContainer`. Great! We have
    our first two routes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`/login`时，我们应该只看到我们的`LoginContainer`。太棒了！我们有了我们的前两个路由。
- en: The next thing we want to do is add a bit of forced routing; when the user logs
    in, we want to redirect them to the main chat screen. Let's do it!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要做的是强制路由一点；当用户登录时，我们希望将他们重定向到主要的聊天界面。让我们来做吧！
- en: Redirecting on login
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录后重定向
- en: Here, things will get a bit more tricky. First, we'll do some preparation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，事情会变得有点棘手。首先，我们要做一些准备工作。
- en: 'Inside our `LoginContainer`, when it comes to our `signup` and `login` methods,
    we currently just `console.log` out the result in our `then` statement. In other
    words, we don''t actually do anything once our user logs in:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`LoginContainer`中，当涉及到我们的`signup`和`login`方法时，我们目前只是在`then`语句中`console.log`出结果。换句话说，一旦用户登录，我们实际上什么也没做：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s change this bit (in both `signup` and `login`) to call another method,
    `onLogin`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变这一点（在`signup`和`login`中），调用另一个方法`onLogin`：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can define our `onLogin` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义我们的`onLogin`方法：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, how do we redirect to the root path?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何重定向到根路径？
- en: We know that our `Route` components will render based on the URL in the browser.
    We can be confident that if we modify the URL correctly, our app will rerender
    to display the appropriate component. The trick is to modify that URL from within
    `LoginContainer`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的`Route`组件将根据浏览器中的URL进行渲染。我们可以确信，如果我们正确修改URL，我们的应用程序将重新渲染以显示适当的组件。诀窍是从`LoginContainer`内部修改URL。
- en: As we mentioned earlier, React Router uses the HTML5 history API to move between
    URLs. In this model, there's an object called `history` with certain methods that
    allow you to push a new URL into the current state of the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，React Router使用HTML5历史API在URL之间移动。在这个模型中，有一个叫做`history`的对象，其中有一些方法，允许你将一个新的URL推入应用程序的当前状态。
- en: 'So, if we''re at `/login`, and want to go to `/`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们在`/login`，想要去`/`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'React Router lets us interact with the HTML5 history object in a more streamlined
    way (avoiding the null arguments, for example). The way it does so is simple:
    every component passed to a `Route` (via the `component` prop) receives another
    prop called `history`, which has a method called `push`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: React Router让我们以更简洁的方式与HTML5历史对象交互（例如避免空参数）。它的工作方式很简单：通过`Route`（通过`component`属性）传递给的每个组件都会接收到一个叫做`history`的prop，其中包含一个叫做`push`的方法。
- en: 'If that sounds confusing, don''t worry, it''ll all be clear in a moment. All
    we have to do is this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来让人困惑，不用担心，一会儿就会清楚了。我们只需要这样做：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try it out by going to `/login` and logging in. You'll be redirected to the
    `ChatContainer`. Magic!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 试着去`/login`并登录。你将被重定向到`ChatContainer`。神奇！
- en: 'What''s happening is the `history` prop, when `push` is called, is updating
    the browser''s URL, which then causes our `Route` components to render their component
    (or render nothing):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`push`时，`history` prop正在更新浏览器的URL，然后导致我们的`Route`组件渲染它们的组件（或者不渲染）：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that this is a rather revolutionary way of navigating around a website.
    Previously, it was much different:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个相当革命性的在网站中导航的方式。以前，它是完全不同的：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Welcome to the world of routing single-page applications. Feels good, doesn't
    it?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到单页面应用的路由世界。感觉不错，是吧？
- en: Logging out
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出
- en: Okay, we've handled our user logging in, but what about when they want to log
    out?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经处理了用户登录，但是当他们想要注销时怎么办？
- en: Let's build them a button at the top of `ChatContainer` to allow them to log
    out. It'll fit best in the `Header` component, so why don't we build it in there?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ChatContainer`的顶部建立一个按钮，让他们可以注销。它最适合在`Header`组件中，所以为什么不在那里建立呢？
- en: Well, hold up. We currently use the `Header` on our `/login` path, in the `LoginContainer`.
    If we add a `Logout` button, it'll appear on the sign-in screen as well, which
    is just confusing. We need a way to only render the `Logout` button on the `ChatContainer`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。我们目前在`LoginContainer`的`/login`路径上使用`Header`。如果我们添加一个`Logout`按钮，它也会出现在登录界面上，这会让人感到困惑。我们需要一种方法，只在`ChatContainer`上渲染`Logout`按钮。
- en: We can take advantage of the `Route history` prop and use that to do a conditional
    rendering of the Logout button based on the URL (if the path is "`/`", render
    the button, otherwise don't!). However, that can be messy and hard to understand
    for future developers as we add more routes. Let's make it super explicit when
    we want the Logout button to appear.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`Route history` prop，并使用它来根据URL进行Logout按钮的条件渲染（如果路径是“/”，则渲染按钮，否则不渲染！）。然而，这可能会变得混乱，对于未来的开发人员来说很难理解，因为我们添加了更多的路由。让我们在想要Logout按钮出现时变得非常明确。
- en: In other words, we want to render the Logout button inside `Header`, but only
    when `Header` is inside `ChatContainer`. Does this make sense?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们想在`Header`内部渲染Logout按钮，但只有当`Header`在`ChatContainer`内部时才这样做。这有意义吗？
- en: 'The way to do so is with React children. Children are actually super easy to
    understand, if you look at it from an HTML standpoint:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的方法是使用React children。从HTML的角度来看，Children实际上非常容易理解：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`h1` is the child of `div`. In the case of a React component the `Parent` component
    will receive a prop called `children`, which equals the `h1` tag:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`h1`是`div`的子元素。在React组件的情况下，`Parent`组件将接收一个名为`children`的属性，它等于`h1`标签：'
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To render that within `Parent`, we just do this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`Parent`中渲染它，我们只需要这样做：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's see this in action and, hopefully, it'll make much more sense (and give
    you an idea of its power).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实际中是如何运作的，希望这样会更有意义（并给你一个它的强大的想法）。
- en: 'Inside `ChatContainer`, let''s replace our `<Header />` tag with an opening
    and closing tag:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ChatContainer`中，让我们用一个开放和关闭的标签替换我们的`<Header />`标签：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside that, we''ll define our button:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们将定义我们的按钮：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Check our page and we see that nothing has changed. This is because we haven't
    told `Header` to actually render its `children`. Let's hop over to `Header.js`
    and change that.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的页面，我们会发现没有任何变化。这是因为我们还没有告诉`Header`实际渲染它的`children`。让我们跳到`Header.js`并改变这一点。
- en: 'Underneath our `h1`, add the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`h1`下面，添加以下内容：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What are we doing here? First, we''re defining `props` as our argument to our
    functional component:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？首先，我们将`props`定义为我们函数组件的参数：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All functional React components receive the `props` object as their first argument.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有功能性的React组件都将`props`对象作为它们的第一个参数。
- en: 'Then, within that object, we''re accessing the `children` property, which is
    equal to our button. Now, our `Logout` button should appear:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在该对象内，我们正在访问`children`属性，它等于我们的按钮。现在，我们的`Logout`按钮应该出现：
- en: '![](../images/00035.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00035.jpeg)'
- en: Awesome! If you check the `/login` path, you'll notice that our button does
    not appear. That's because in `LoginContainer`, `Header` has no `children`, so
    nothing is rendered.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果你检查`/login`路径，你会注意到我们的按钮没有出现。那是因为在`LoginContainer`中，`Header`没有`children`，所以没有东西被渲染。
- en: Children make React components super composable and extra reuseable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Children使React组件非常可组合和可重用。
- en: 'Okay, let''s make our button actually work. We want to call a method called
    `firebase.auth().signOut`. Let''s make a click handler for our button that calls
    this function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们让我们的按钮真正起作用。我们想要调用一个名为`firebase.auth().signOut`的方法。让我们为我们的按钮创建一个调用这个函数的点击处理程序：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, when we press the button, nothing happens, but we are being logged out.
    We're missing one last piece of the login puzzle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们按下按钮时，什么也不会发生，但我们已经被登出了。我们缺少登录谜题的最后一块。
- en: 'When our user logs out, we want to redirect them to the login screen. If only
    we had some way of telling the status of Firebase''s authorization:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的用户注销时，我们希望将他们重定向到登录界面。如果我们有某种方式来告诉Firebase授权的状态就好了：
- en: '![](../images/00036.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: This is perfect. After we click on the logout button, when our user logs out,
    Firebase will call `firebase.auth().onAuthStateChanged` with a null argument for
    the user.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这很完美。当我们点击注销按钮后，当我们的用户注销时，Firebase将使用空参数调用`firebase.auth().onAuthStateChanged`。
- en: In other words, we already have everything we need; we just need to add an `else`
    to our `if` statement to cover situations where there is no user found.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们已经拥有了我们需要的一切；我们只需要在我们的`if`语句中添加一个`else`来处理没有找到用户的情况。
- en: 'The flow will go like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 流程将是这样的：
- en: When the user clicks on the logout button, Firebase will log them out.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击注销按钮时，Firebase将登出他们。
- en: It will then call the `onAuthStateChanged` method with a null argument.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它将使用空参数调用`onAuthStateChanged`方法。
- en: If `onAuthStateChanged` is called with a null user, we will redirect the user
    to the login page using the `history` prop.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`onAuthStateChanged`被调用时用户为空，我们将使用`history`属性将用户重定向到登录页面。
- en: Let's put this in place by jumping over to `App.js`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过跳转到 `App.js` 来实现这一点。
- en: Our `App` isn't the child of a `Route`, so it doesn't get access to the `history`
    prop that we used in `LoginContainer`, but there's a little workaround we can
    use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `App` 不是 `Route` 的子组件，所以它无法访问我们在 `LoginContainer` 中使用的 `history` 属性，但是我们可以使用一个小技巧。
- en: 'At the top of `App.js`, add the following to our `react-router-dom` import:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.js` 的顶部，添加以下内容到我们的 `react-router-dom` 导入：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, at the bottom, replace our `export default` statement with this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在底部，用这个替换我们的 `export default` 语句：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What's happening here? Essentially, `withRouter` is a function that takes a
    component as an argument and returns that component exactly as it was, except
    that now it has access to the `history` prop. We'll cover more on that as we move
    on, but let's finish this logout flow first.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？基本上，`withRouter` 是一个接受组件作为参数并返回该组件的函数，除了现在它可以访问 `history` 属性。随着我们的学习，我们会更多地涉及到这一点，但让我们先完成这个注销流程。
- en: 'Lastly, we can fill out `componentDidMount`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以填写 `componentDidMount`：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Try logging in again and hitting the logout button. You should be taken directly
    to the login screen. Magic!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次登录并点击注销按钮。你应该直接进入登录界面。神奇！
- en: Detour - higher order components
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕道 - 高阶组件
- en: In the preceding code, we used the `withRouter` function (imported from `react-router-dom`)
    to give our `App` component access to the `history` prop. Let's take a moment
    to talk about how that worked, since it's one of the most powerful React patterns
    you can learn.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `withRouter` 函数（从 `react-router-dom` 导入）来让我们的 `App` 组件访问 `history`
    属性。让我们花点时间来谈谈它是如何工作的，因为这是你可以学到的最强大的 React 模式之一。
- en: '`withRouter` is an example of a **Higher Order Component** (**HOC**). This
    slightly grandiose name is better than my favorite explanation: *Functions That
    Build Functions* (thanks to *Tom Coleman* for that one). Let''s see an example.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`withRouter` 是一个**高阶组件**（**HOC**）的例子。这个略显夸张的名字比我最喜欢的解释更好：*构建函数的函数*（感谢 *Tom
    Coleman*）。让我们看一个例子。'
- en: 'Let''s say that you had a `Button` component, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `Button` 组件，如下所示：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, let''s say that we had a situation where we wanted it to have white text
    and a red background:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还有，假设我们有这样一种情况，我们希望它有白色文本和红色背景：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As your app evolves, you're finding that you're using this particular styling
    a lot with this button. You need a lot of red buttons, with different text, and
    it's getting tiresome to type out `backgroundColor` every time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序的发展，你发现你经常使用这种特定的样式来制作按钮。你需要很多红色按钮，带有不同的文本，每次都输入 `backgroundColor` 很烦人。
- en: 'Not only that; you also have another component, an alert box, with the same
    styles:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此；你还有另一个组件，一个带有相同样式的警报框：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, you have two options. You want two new components (`RedAlertBox` and
    `RedButton`), which you can use everywhere. You can define them as illustrated:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有两个选择。你想要两个新的组件（`RedAlertBox` 和 `RedButton`），你可以在任何地方使用。你可以按照下面的示例定义它们：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还有：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: However, there's a simpler, more composable way, and that's to make a Higher
    Order Component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种更简单、更可组合的方法，那就是创建一个高阶组件。
- en: What we want to achieve is a way to take a component and give it the red-on-white
    styling. That's it. We want to inject those props into any given component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现的是一种方法，可以给一个组件添加红色背景和白色文本的样式。就是这样。我们想要将这些属性注入到任何给定的组件中。
- en: 'Let''s look at the end result, and then what our HOC will look like. If we
    successfully make a HOC called `makeRed`, we can use it, as follows, to create
    our `RedButton` and `RedAlertBox`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看最终结果，然后看看我们的 HOC 会是什么样子。如果我们成功地创建了一个名为 `makeRed` 的 HOC，我们可以像下面这样使用它来创建我们的
    `RedButton` 和 `RedAlertBox`：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is much easier, and much more reuseable. We can now reuse `makeRed` to
    convert any component into a nice red background and white text. That's power.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做要容易得多，而且更容易重复使用。我们现在可以重复使用`makeRed`来将任何组件转换为漂亮的红色背景和白色文本。这就是力量。
- en: 'Okay, so how do we create a `makeRed` function? We want to take a component
    as an argument, and return that component with all its assigned props and the
    correct style prop:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，那么我们如何创建一个`makeRed`函数呢？我们希望将一个组件作为参数，并返回具有其所有分配的props和正确样式prop的组件：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s the same code, with comments:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同的代码，带有注释：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The most confusing thing will likely be the spread operator of `{...props}`.
    The spread operator is a useful yet confusing ES6 tool. It allows you to take
    an object (here, the `props` object) and apply all its keys and values to a new
    object (the component):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人困惑的可能是`{...props}`的扩展运算符。扩展运算符是一个有用但令人困惑的ES6工具。它允许您获取一个对象（这里是`props`对象）并将其所有键和值应用于一个新对象（组件）：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Higher order components are a next-level tool to make your React components
    easier to reuse. We've only scratched their surface here. For more information,
    check out *Understanding Higher Order Components* by *Tom Coleman*, at [https://medium.freecodecamp.org/understanding-higher-order-components-6ce359d761b](https://medium.freecodecamp.org/understanding-higher-order-components-6ce359d761b).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件是使您的React组件更容易重用的下一级工具。我们在这里只是浅尝辄止。有关更多信息，请查看*Tom Coleman*的*Understanding
    Higher Order Components*，网址为[https://medium.freecodecamp.org/understanding-higher-order-components-6ce359d761b](https://medium.freecodecamp.org/understanding-higher-order-components-6ce359d761b)。
- en: Our third Route
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第三个路由
- en: As discussed at the beginning of this chapter, the Chatastrophe team is set
    on having a user profile view. Let's do the skeleton and basic routing for that.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所讨论的，Chatastrophe团队决定要有一个用户个人资料视图。让我们为此做骨架和基本路由。
- en: 'In `src/components`, make a new file called `UserContainer.js`. Inside, do
    the basic component skeleton:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components`中，创建一个名为`UserContainer.js`的新文件。在里面，做基本的组件框架：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Back in `App.js`, let’s import our new container and add the `Route` component:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`App.js`，让我们导入我们的新容器并添加`Route`组件：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hold on! The preceding code creates a route at `/users` for our `UserContainer`,
    but we don't have just one user view. We have a user view for every user of our
    application. We need to have a route for User 1 at `chatastrophe.com/users/1`,
    and for User 2 at `chatastrophe.com/users/2`, and so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！前面的代码为我们的`UserContainer`创建了一个在`/users`的路由，但我们不只有一个用户视图。我们为我们应用程序的每个用户都有一个用户视图。我们需要在`chatastrophe.com/users/1`为用户1创建一个路由，在`chatastrophe.com/users/2`为用户2创建一个路由，依此类推。
- en: 'We need some way to pass a variable value to our `path` prop, equal to the
    user `id`. Fortunately, it''s easy to do so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来将变量值传递给我们的`path`属性，等于用户的`id`。幸运的是，这样做很容易：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The best part? Now, in our `UserContainer`, we''ll receive a `props.params.match`
    object, equal to `{ id: 1 }` or whatever the `id` is, which we can then use to
    fetch that user''s messages.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '最棒的部分？现在，在我们的`UserContainer`中，我们将收到一个`props.params.match`对象，等于`{ id: 1 }`或者`id`是什么，然后我们可以使用它来获取该用户的消息。'
- en: 'Let''s test that by changing our `h1` in `UserContainer.js`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更改`UserContainer.js`中的`h1`来测试一下：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, head to `localhost:8080/users/1`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，前往`localhost:8080/users/1`：
- en: '![](../images/00037.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: 'If you run into problems with finding `bundle.js` when in a nested route, ensure
    that your output inside your `webpack.config.js` looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在嵌套路由中遇到找不到`bundle.js`的问题，请确保您在`webpack.config.js`中的输出如下所示：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Beautiful. Now, there's one last step. Let's add a way for the user to return
    to the main chat screen from the `UserContainer`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在，还有最后一步。让我们为用户从`UserContainer`返回到主聊天屏幕添加一种方式。
- en: We can do so in a really easy way by taking advantage of the `Header` children
    again; only, in this case, we can add in another React Router component to make
    our lives super easy. It's called `Link`, and it's just like a tag in HTML, but
    is optimized for React Router.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过充分利用`Header`的子组件来以一种非常简单的方式做到这一点；只是，在这种情况下，我们可以添加另一个React Router组件，使我们的生活变得非常简单。它被称为`Link`，就像HTML中的标签一样，但经过了React
    Router的优化。
- en: 'In `UserContainer.js`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserContainer.js`中：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](../images/00038.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: When you click on the button, you should be taken to the root route of `/`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击按钮时，应该转到根路由`/`。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That's it! We covered a lot in this chapter in order to get our application's
    routing solution up and running. If anything is confusing, I invite you to take
    a look at the React Router docs at [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/).
    Next, we'll go much, much deeper into React, as we finish up our basic application,
    and then start converting it into a Progressive Web App.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！在本章中，我们涵盖了很多内容，以便让我们的应用程序的路由解决方案能够正常运行。如果有任何困惑，我建议您查看React Router文档[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)。接下来，我们将深入学习React，完成我们的基本应用程序，然后开始将其转换为渐进式Web应用程序。
