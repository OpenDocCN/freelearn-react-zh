["```jsx\nrender() {\n  return (\n    <div id=\"ChatContainer\">\n      <Header>\n        <button className=\"red\" onClick={this.handleLogout}>\n          Logout\n        </button>\n      </Header>\n      <div id=\"message-container\">\n\n </div>\n <div id=\"chat-input\">\n\n </div>\n     </div>\n   );\n}\n```", "```jsx\n<textarea placeholder=\"Add your message...\" />\n```", "```jsx\n<div id=\"chat-input\">\n  <textarea placeholder=\"Add your message...\" />\n  <button>\n <svg viewBox=\"0 0 24 24\">\n <path fill=\"#424242\" d=\"M2,21L23,12L2,3V10L17,12L2,14V21Z\" />\n </svg>\n </button>\n</div>\n```", "```jsx\n<div id=\"ChatContainer\" className=\"inner-container\">\n```", "```jsx\nstate = { newMessage: '' };\n```", "```jsx\nhandleInputChange = e => {\n  this.setState({ newMessage: e.target.value });\n};\n```", "```jsx\n<textarea\n    placeholder=\"Add your message...\"\n    onChange={this.handleInputChange}\n    value={this.state.newMessage} \n/>\n```", "```jsx\nhandleSubmit = () => {\n   this.props.onSubmit(this.state.newMessage);\n   this.setState({ newMessage: \u2018\u2019 });\n};\n```", "```jsx\n<button onClick={this.handleSubmit}>\n  <svg viewBox=\"0 0 24 24\">\n    <path fill=\"#424242\" d=\"M2,21L23,12L2,3V10L17,12L2,14V21Z\" />\n  </svg>\n</button>\n```", "```jsx\n<textarea\n    placeholder=\"Add your message...\"\n    onChange={this.handleInputChange}\n    onKeyDown={this.handleKeyDown}\n    value={this.state.newMessage} />\n```", "```jsx\nhandleKeyDown = e => {\n  if (e.key === 'Enter') {\n    e.preventDefault();\n    this.handleSubmit();\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\nimport Header from './Header';\n\nexport default class ChatContainer extends Component {\n  state = { newMessage: '' };\n\n  handleLogout = () => {\n    firebase.auth().signOut();\n  };\n\n  handleInputChange = e => {\n    this.setState({ newMessage: e.target.value });\n  };\n\n  handleSubmit = () => {\n    this.props.onSubmit(this.state.newMessage);\n    this.setState({ newMessage: '' });\n  };\n\n  handleKeyDown = e => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      this.handleSubmit();\n    }\n  };\n\n  render() {\n    return (\n      <div id=\"ChatContainer\" className=\"inner-container\">\n        <Header>\n          <button className=\"red\" onClick={this.handleLogout}>\n            Logout\n          </button>\n        </Header>\n        <div id=\"message-container\" />\n        <div id=\"chat-input\">\n          <textarea\n            placeholder=\"Add your message...\"\n            onChange={this.handleInputChange}\n            onKeyDown={this.handleKeyDown}\n            value={this.state.newMessage}\n          />\n          <button onClick={this.handleSubmit}>\n            <svg viewBox=\"0 0 24 24\">\n              <path fill=\"#424242\" d=\"M2,21L23,12L2,3V10L17,12L2,14V21Z\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n```", "```jsx\n// in App.js\nhandleSubmitMessage = msg => {\n  // Send to database\n  console.log(msg);\n};\n```", "```jsx\n<Route exact path=\"/\" component={ChatContainer} />\n```", "```jsx\n<Route\n  exact\n  path=\"/\"\n  render={() => <ChatContainer onSubmit={this.handleSubmitMessage} />}\n/>\n```", "```jsx\n// App.js\nhandleSubmitMessage = msg => {\n  const data = {\n    msg,\n    author: this.state.user.email,\n    user_id: this.state.user.uid,\n    timestamp: Date.now()\n  };\n  // Send to database\n}\n```", "```jsx\nhandleSubmitMessage = (msg) => {\n  const data = {\n    msg,\n    author: this.state.user.email,\n    user_id: this.state.user.uid,\n    timestamp: Date.now()\n  };\n  firebase\n      .database()\n      .ref('messages/')\n      .push(data);\n}\n```", "```jsx\nclass App extends Component {\n  state = { user: null, messages: [] }\n\n  componentDidMount() {\n    firebase.auth().onAuthStateChanged((user) => {\n      if (user) {\n        this.setState({ user });\n      } else {\n       this.props.history.push('/login')\n      }\n    });\n    firebase\n .database()\n .ref('/messages')\n .on('value', snapshot => {\n console.log(snapshot);\n });\n  }\n```", "```jsx\nfirebase.database().ref('/messages').on('value', snapshot => {\n  console.log(snapshot.val());\n});\n```", "```jsx\nclass App extends Component {\n  state = { user: null, messages: [] }\n\n  componentDidMount() {\n    firebase.auth().onAuthStateChanged((user) => {\n      if (user) {\n        this.setState({ user });\n      } else {\n       this.props.history.push('/login')\n      }\n    });\n    firebase\n      .database()\n      .ref('/messages')\n      .on('value', snapshot => {\n        this.onMessage(snapshot);\n      });\n  }\n```", "```jsx\n  onMessage = snapshot => {\n    const messages = Object.keys(snapshot.val()).map(key => {\n      const msg = snapshot.val()[key];\n      msg.id = key;\n      return msg;\n    });\n    console.log(messages);\n  };\n```", "```jsx\nonMessage = (snapshot) => {\n  const messages = Object.keys(snapshot.val()).map(key => {\n    const msg = snapshot.val()[key]\n    msg.id = key\n    return msg\n  });\n  this.setState({ messages });\n}\n```", "```jsx\n<Route\n  exact\n  path=\"/\"\n  render={() => (\n    <ChatContainer\n      onSubmit={this.handleSubmitMessage}\n      messages={this.state.messages}\n    />\n  )}\n/>\n```", "```jsx\nimport React, { Component } from 'react';\nimport { Route, withRouter } from 'react-router-dom';\nimport LoginContainer from './LoginContainer';\nimport ChatContainer from './ChatContainer';\nimport UserContainer from './UserContainer';\nimport './app.css';\n\nclass App extends Component {\n  state = { user: null, messages: [] };\n\n  componentDidMount() {\n    firebase.auth().onAuthStateChanged(user => {\n      if (user) {\n        this.setState({ user });\n      } else {\n        this.props.history.push('/login');\n      }\n    });\n    firebase\n      .database()\n      .ref('/messages')\n      .on('value', snapshot => {\n        this.onMessage(snapshot);\n      });\n  }\n\n  onMessage = snapshot => {\n    const messages = Object.keys(snapshot.val()).map(key => {\n      const msg = snapshot.val()[key];\n      msg.id = key;\n      return msg;\n    });\n    this.setState({ messages });\n  };\n\n  handleSubmitMessage = msg => {\n    const data = {\n      msg,\n      author: this.state.user.email,\n      user_id: this.state.user.uid,\n      timestamp: Date.now()\n    };\n    firebase\n      .database()\n      .ref('messages/')\n      .push(data);\n  };\n\n  render() {\n    return (\n      <div id=\"container\">\n        <Route path=\"/login\" component={LoginContainer} />\n        <Route\n          exact\n          path=\"/\"\n          render={() => (\n            <ChatContainer\n              onSubmit={this.handleSubmitMessage}\n              messages={this.state.messages}\n            />\n          )}\n        />\n        <Route path=\"/users/:id\" component={UserContainer} />\n      </div>\n    );\n  }\n}\n\nexport default withRouter(App);\n```", "```jsx\n<div id=\"message-container\">\n  {\n\n  }\n</div>\n```", "```jsx\n<div id=\"message-container\">\n  {this.props.messages.map(msg => (\n    <div key={msg.id} className=\"message\">\n      <p>{msg.msg}</p>\n    </div>\n  ))}\n</div>\n```", "```jsx\nimport { Link } from 'react-router-dom';\n```", "```jsx\n<div id=\"message-container\">\n  {this.props.messages.map(msg => (\n    <div key={msg.id} className=\"message\">\n      <p>{msg.msg}</p>\n      <p className=\"author\">\n <Link to={`/users/${msg.user_id}`}>{msg.author}</Link>\n </p>\n    </div>\n  ))}\n</div>\n```", "```jsx) instead of quotation marks, you can use `${VARIABLE}` to embed variables right into it.\n\nNow, we will make our messages look even better!\n\n# Message display improvements\n\nLet's take some time to do some quick UI improvements to our message display, before we move on to the user profile page.\n\n# Multiple users\n\nIf you try logging out and signing in with a new user, all the messages from all users are displayed, as shown:\n\n![](../images/00047.jpeg)\n\nThere's no differentiation between my messages, and the messages of other users. The classic chat application pattern is to put one user's messages on one side, and one on the other. Our CSS is all ready to handle that\u2014we just have to assign the class \"mine\" to messages that match the current user.\n\nSince we have access to the email of the message author in `msg.author`, we can compare that to the user we have stored in the state of `App`. Let\u2019s pass that down as a prop to `ChatContainer`:\n\n```", "```jsx\n\nThen, we can add a conditional in our `className` property:\n\n```", "```jsx\n\nThis uses ES6 string interpolation along with short-circuit evaluation to create the effect we want. Those are the fancy terms for what boils down to this: if the message author matches the user email in `state`, set the `className` to `message mine`; otherwise, set it to `message`.\n\nIt should end up looking like this:\n\n![](../images/00048.jpeg)\n\n# Batching user messages\n\nIn the preceding screenshot, you'll notice that we display the author email under each message, even if two messages in the row have the same author. Let's get tricky, and make it so that we group messages from the same author together.\n\nIn other words, we only want to display the author email if the next message is not by the same author:\n\n```", "```jsx\n\nHow can we do this? We need a way to check the next message in the array, from the current message.\n\nLuckily, the `Array.map()` function passes the index to our callback as the second element. We can use it, as illustrated:\n\n```", "```jsx\n\nNow, we're saying: \"If there is a next message, and the next message's author is not the same as the current message's author, show the author for this message.\"\n\nHowever, this is a lot of complex logic in our `render` method. Let's extract it to a method:\n\n```", "```jsx\n\nAlso, the method itself:\n\n```", "```jsx\n\nOur messages are now grouped like this:\n\n![](../images/00049.jpeg)\n\n# Scrolling down\n\nTry making your browser smaller so that your list of messages is almost cut off; then, submit another message. Note that you have to scroll down to see it, if it's past the cut off of the message container. This is bad UX. Let's make it so that we automatically scroll down when a new message arrives.\n\nIn this section, we will dive into two powerful React concepts: the `componentDidUpdate` method, and refs.\n\nLet's start by discussing what we want to achieve. We want our message container to be scrolled down to the bottom so that the most recent messages are always in view (unless the user decides to scroll up to see older messages). This means we need the message container to scroll down in two situations:\n\n*   When the first component is rendered\n*   When new messages arrive\n\nLet\u2019s start with the first use case. We will need a React life cycle method--one we\u2019ve already used. We will add a `componentDidMount` method to our `ChatContainer`, just like we did with `App`.\n\nLet's define it, and a `scrollToBottom` method as well:\n\n```", "```jsx\n\nWe also want to trigger the `scrollToBottom` method whenever new messages arrive, have appeared on the screen. React gives us another method to deal with this situation--`componentDidUpdate`. This method is called whenever your React component updates due to new `props` or state. The best part is that the method gets the previous `props` passed as the first argument, so we can compare them and find the difference, as follows:\n\n```", "```jsx\n\nWe look at the length of the messages array in the previous `props`, and compare it to the length of the messages array in the current `props`. If it has changed, we scroll to the bottom.\n\nOkay, all that looks good. Let's go ahead and get our `scrollToBottom` method working.\n\n# React refs\n\nRefs in React are a way to grab a particular DOM element. For those familiar with jQuery, refs bridge the gap between the React approach of creating elements with props and the jQuery approach of grabbing things from the DOM and manipulating them.\n\nWe can add a `ref` to any JSX element we want to use later (that we want to refer to later). Let's add one to our message container. The `ref` prop is always a function, which is called with the element in question, and then used to assign that element to a property of the component, as shown:\n\n```", "```jsx\n\nInside our `scrollToBottom` method, we use `ReactDOM.findDOMNode` to grab the element in question (don't forget to import react-dom!):\n\n```", "```jsx\n\n```", "```jsx\n\nIn the next section, we will make it such that we only show our message container when the messages are loaded. For that reason, we need an `if` statement to check whether our `messageContainer` DOM node currently exists. Once that is done, we can set the `messageContainer.scrollTop` (how far it is currently scrolled down) to its height so that it\u2019s at the bottom:\n\n```", "```jsx\n\nNow if you try reducing the size of your browser and sending a message, you should always be taken to the bottom of the message container so that it's automatically in view. Nice!\n\n# Loading indicator\n\nFirebase is pretty quick to load, but if our users are on slow connections, they will see a blank screen until their messages load, and be wondering, \"Where are all my awesome chats?\" Let's give them a loading indicator.\n\nInside our `ChatContainer`, we only want to show the messages if a prop called `messagesLoaded` is true (which we'll define in a moment). We will make the rendering of our message container conditional on that prop. We can do so using a **ternerary** statement.\n\nTernerary statements in JavaScript are a short way of doing if else. Instead of if (true) `{ // this code }`, else `{ // that code }`, we can write `true ? // this code : // that code`, which is short and sweet.\n\nThe code looks like this:\n\n```", "```jsx\n\nTake a moment to read this closely, and ensure that you understand exactly what's going on. Ternerary statements are common in React, simply because they make it easy to conditionally render JSX. If everything is right, you should see the following, with a pulsing animation to the logo:\n\n![](../images/00050.jpeg)\n\nThe next step is to update the `messagesLoaded` prop when the messages load. Let's hop over to `App.js`.\n\nThe logic here is simple--when we receive a message value from the Firebase database, if we haven't received a value before (in other words, this is the first message we've received), we know that our messages have loaded for the first time:\n\n```", "```jsx\n\n```", "```jsx\n\n```", "```jsx\n\nNow, if you reload the app page, you should briefly see the loading indicator (depending on your internet connection), and then see the messages displayed.\n\nHere's the code for `ChatContainer` so far:\n\n```", "```jsx\n\nOur app is so close to complete. The last step is the user profile page.\n\n# The Profile page\n\nThe code for `UserContainer` will be the same as `ChatContainer`, with two major differences:\n\n*   We only want to show the messages from our messages array that match the ID from the URL parameters\n*   We want to show the author email at the top of page, before any other messages\n\nFirstly, in `App.js`, convert the `UserContainer` route to use the `render` prop, the same as `ChatContainer`, and pass in the following props:\n\n```", "```jsx\n\nNote that React Router automatically gives us the history and match `props` in our `render` method, which we use here to grab the user ID from the URL parameters.\n\nThen, in `UserContainer`, let\u2019s set up our loading indicator. Also, ensure that you give `UserContainer` a `className` of `inner-container` for CSS purposes:\n\n```", "```jsx\n\nFor displaying our messages, we only want to show the ones where `msg.user_id` equals our `props.userID`. Instead of our callback for `Array.map()`, we can just add an `if` statement:\n\n```", "```jsx\n\nThis should only show messages from the author whose profile we are on. However, we now need to display the author email at the top.\n\nThe challenge is that we won't know the user email until we've loaded the messages, and are iterating over the first message that matches the ID, so we can't use the index of `map()`, like we did before, and we can't use a prop.\n\nInstead, we'll add a `class` property to track whether we've shown the user email already.\n\nDeclare it at the top of `UserContainer`:\n\n```", "```jsx\n\nThen, we'll call a `getAuthor` method in the code:\n\n```", "```jsx\n\nThis checks to see if we've rendered the author already, and if not, returns it:\n\n```", "```jsx\n\nA little bit of a roundabout route--for our production application, we\u2019d probably want to add more sophisticated logic to only load the messages from that author. However, this will do just fine for our prototype.\n\nHere's the full code for `UserContainer`:\n\n```"]