- en: Getting Started with Webpack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack入门
- en: 'This chapter is all about Webpack: what it is, how to use it, and why we care.
    However, before we dive into Webpack, I have a confession to make.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论Webpack：它是什么，如何使用它，以及为什么我们关心。然而，在我们深入研究Webpack之前，我有一个坦白要做。
- en: We cheated a bit in the last chapter on application setup. There’s one last
    piece of our folder structure we need to add--the place where our React files
    will live.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在应用程序设置上有点作弊。我们需要添加一个文件夹结构的最后一部分--我们的React文件将存放的地方。
- en: As we discussed in the *Dependencies* section of the last chapter, one of React’s
    killer features is the *componentization of user interfaces*--splitting them up
    into small chunks of related HTML and JavaScript. For instance, a "Save" button
    may be one component, sitting inside a form component, next to a Profile Information
    component, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章的*依赖*部分讨论的那样，React的一个杀手功能是*用户界面的组件化*--将它们拆分成相关HTML和JavaScript的小块。例如，“保存”按钮可能是一个组件，位于表单组件内部，旁边是个人资料信息组件，依此类推。
- en: The beauty of the component structure is that everything related to a particular
    piece of the UI sits together (separation of concerns), also, these sections are
    in brief, readable files. As a developer, you can easily find what you’re looking
    for by navigating the folder structure, rather than scrolling through a monolithic
    JavaScript file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组件结构的美妙之处在于与特定UI部分相关的所有内容都在一起（关注点分离），而且这些部分都在简洁易读的文件中。作为开发人员，你可以通过浏览文件夹结构轻松找到你要找的内容，而不是在一个庞大的JavaScript文件中滚动。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to structure our React project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织我们的React项目
- en: Setting up Webpack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Webpack
- en: Adding a Dev server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个开发服务器
- en: Getting started with JavaScript transpilation with Babel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babel进行JavaScript转译入门
- en: Activating hot reloading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活热重载
- en: Building for production
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生产环境构建
- en: Our project structure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的项目结构
- en: Let’s see what this looks like in practice. In our `chatastrophe` project folder,
    create an `src` folder (which should be next to the `public` and `node_modules`
    folder in the root of the project folder).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作中是什么样子。在我们的`chatastrophe`项目文件夹中，创建一个`src`文件夹（应该位于项目文件夹根目录中`public`和`node_modules`文件夹旁边）。
- en: The `src` folder is where all our React files will live. To illustrate what
    this will look like, let’s create some mock files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`文件夹是我们所有React文件的存放地。为了说明这将是什么样子，让我们创建一些模拟文件。'
- en: Inside `src`, make another folder, called `components`. Inside that folder,
    let's make three JavaScript files. You can name them whatever you like, but for
    example purposes, I’ll call them `Component1.js`, `Component2.js`, and `Component3.js`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹内，创建另一个名为`components`的文件夹。在该文件夹内，让我们创建三个JavaScript文件。你可以随意命名它们，但为了举例，我将称它们为`Component1.js`，`Component2.js`和`Component3.js`。
- en: Imagine that each of these component files holds a bit of our user interface.
    We need all three files to construct a complete UI. How do we import them all?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，每个组件文件都包含了我们用户界面的一部分。我们需要这三个文件来构建完整的用户界面。我们如何导入它们呢？
- en: Well, we can do what we’ve done so far when we needed to use JavaScript files.
    We can create a `script` tag for each component in our `index.html`. That’s the
    brute force way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当我们需要使用JavaScript文件时，我们可以像迄今为止所做的那样。我们可以为我们`index.html`中的每个组件创建一个`script`标签。这是一种蛮力的方法。
- en: However, as our application grows, this approach will quickly become unwieldy.
    An application such as Facebook, for example, will have tens of thousands of components.
    We can’t write tens of thousands of `script` tags!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着我们应用程序的增长，这种方法很快就会变得难以管理。例如，像Facebook这样的应用程序将拥有成千上万个组件。我们无法为成千上万个组件编写`script`标签！
- en: Ideally, we’d have only one `script` tag, with all our JavaScript combined.
    We need a tool that takes our varied files and squishes them together, giving
    us the best of both worlds--organized, separated code for the developer, and compressed,
    optimized code for the user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们只有一个`script`标签，所有的JavaScript都合并在一起。我们需要一个工具，将我们的各种文件压缩在一起，给我们最好的两个世界--为开发者组织、分离的代码，以及为用户压缩、优化的代码。
- en: '"But wait, Scott," you might say, "if we put all our code in one file, won’t
    that take longer for the browser to download? Isn’t it a good thing to have small,
    separate files?"'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “但是，斯科特，”你可能会说，“如果我们把所有的代码放在一个文件中，那不是会让浏览器下载时间更长吗？有小的、分离的文件不是一件好事吗？”
- en: You're exactly right. We don’t want to go back to a monolithic single file in
    the end, but neither do we want thousands of separate files. We need a happy medium
    of a handful of code files, and we’ll get to that medium. However, to start, let’s
    see how we can bundle multiple JavaScript files into just one using our new friend--**Webpack**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你说得对。最终我们不想回到单一的单文件，但也不想有成千上万个单独的文件。我们需要一个合适的中间地带，有一些代码文件，我们会达到这个中间地带。然而，首先，让我们看看如何使用我们的新朋友--**Webpack**将多个JavaScript文件捆绑成一个文件。
- en: Welcome to Webpack
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到Webpack
- en: Our goal for this section is to take the JavaScript sitting in our script tag
    in our `index.html` (the line responsible for rendering our "Hello from React!")
    and move that to a JavaScript file in the `src` folder, which is then bundled
    and injected into the HTML by Webpack.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这一节的目标是将我们在`index.html`中的脚本标签中的JavaScript（负责渲染我们的“Hello from React!”）移到`src`文件夹中的JavaScript文件中，然后由Webpack捆绑并注入到HTML中。
- en: 'It sounds complicated, but it’s simpler than it sounds, thanks to the magic
    of Webpack. Let’s get started:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很复杂，但由于Webpack的魔力，它比听起来简单。让我们开始吧：
- en: 'First, we need to install Webpack:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装Webpack：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you check the `package.json`, you should see Webpack listed under our dependencies.
    For this book, I’ll be using **version 3.5.4**; if you run into any inexplicable
    problems, try specifying this version with `yarn add webpack@3.5.4`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`package.json`，你应该会看到Webpack列在我们的依赖项下。在本书中，我将使用**版本3.5.4**；如果你遇到任何莫名其妙的问题，尝试使用`yarn
    add webpack@3.5.4`指定这个版本：
- en: Now, we need to tell Webpack what to do. Let’s start by moving our React code
    into the `src` folder. Inside `chatastrophe/src`, create a file called `index.js`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉Webpack该做什么。让我们先把我们的React代码移到`src`文件夹中。在`chatastrophe/src`中创建一个名为`index.js`的文件。
- en: 'Then, type in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入以下代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our goal is to get this greeting to display in our browser console.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是让这个问候显示在我们的浏览器控制台中。
- en: 'Okay, let’s try out Webpack. In your Terminal, type the following:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们试试Webpack。在你的终端中，输入以下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your Terminal should now look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的终端现在应该是这样的：
- en: '![](../images/00014.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: What does this do? Well, it tells Webpack to take the first file and copy it
    (and everything it needs, that is, every file it requires) into the second file
    (which Webpack created for us, since it didn’t exist).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有什么作用？嗯，它告诉Webpack将第一个文件复制（以及它需要的一切，也就是说，它需要的每个文件）到第二个文件中（这是Webpack为我们创建的，因为它不存在）。
- en: If you open up the newly created `public/bundle.js`, you’ll see a lot of Webpack
    boilerplate… and at the bottom, our `console.log`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新创建的`public/bundle.js`，你会看到很多Webpack样板代码...在底部是我们的`console.log`。
- en: Okay, so it works; we can require this file in our `index.html` to see our `console.log`,
    but that's not using Webpack to its full potential. Let’s try something else.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它可以工作；我们可以在我们的`index.html`中引入这个文件来看到我们的`console.log`，但这并没有充分利用Webpack的潜力。让我们试试其他的东西。
- en: Bundling files
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捆绑文件
- en: 'Let''s take a look at how Webpack combines our JavaScript files together. Go
    through the following steps to add a second JavaScript file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Webpack如何将我们的JavaScript文件合并在一起。按照以下步骤添加第二个JavaScript文件：
- en: In our `src` folder, create another file. Let’s call it `index2.js`, for lack
    of creativity.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`src`文件夹中，创建另一个文件。让我们称之为`index2.js`，因为缺乏创造力。
- en: 'Inside, add a second `console.log`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在里面，添加第二个`console.log`：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, back in `index.js` (the first one), we’ll require the other file, as
    follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`index.js`（第一个）中，我们将按如下方式需要另一个文件：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This basically means that `index.js` now tells Webpack, "Hey, I need this other
    index!"
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着`index.js`现在告诉Webpack，“嘿，我需要另一个index！”
- en: 'Okay, let’s rerun the same Webpack command as earlier:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们重新运行与之前相同的Webpack命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, we’ll only specify `src/index.js`, but if you look at the console output,
    you’ll see that Webpack now grabs the other file too:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只会指定`src/index.js`，但是如果你查看控制台输出，你会看到Webpack现在也获取了另一个文件：
- en: '![](../images/00015.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: Open up `public/bundle.js`, scroll to the bottom, and you’ll see both console
    logs.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`public/bundle.js`，滚动到底部，你会看到两个控制台日志。
- en: There’s the beauty of Webpack. We can now expand our app to contain any number
    of JavaScript files, and use Webpack to merge them all into one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Webpack的美妙之处。我们现在可以扩展我们的应用程序以包含任意数量的JavaScript文件，并使用Webpack将它们合并为一个文件。
- en: 'Okay, let’s ensure that those console logs are working. In our `public/index.html`,
    add another script tag below the other three:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们确保那些控制台日志能够正常工作。在我们的`public/index.html`中，在其他三个标签下面添加另一个脚本标签：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Reload the page, open up your console, and you''ll have this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载页面，打开控制台，你会看到这个：
- en: '![](../images/00016.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: Moving our React
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动我们的React
- en: 'Enough of console logs; now, let’s use Webpack to take care of some useful
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，现在让我们使用Webpack来处理一些有用的代码：
- en: Delete our `index2.js`, and delete all code from `index.js`. Then, copy and
    paste our React code into `index.js`, and delete the first three script tags in
    the `index.html`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除我们的`index2.js`，并删除`index.js`中的所有代码。然后，将我们的React代码复制粘贴到`index.js`中，并删除`index.html`中的前三个脚本标签。
- en: 'After doing so, you should have only one script tag in your `index.html` (the
    one for `bundle.js`), and your `index.js` should consist of this line:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做后，你的`index.html`中应该只有一个脚本标签（用于`bundle.js`），而你的`index.js`应该包含这一行：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we run Webpack, though, we have a problem. We deleted the script tags
    that required React and ReactDOM, but we still need a way to access them in our
    `index.js`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行Webpack之前，我们有一个问题。我们删除了需要React和ReactDOM的脚本标签，但我们仍然需要一种方法在我们的`index.js`中访问它们。
- en: We can do it in the same way we required `index2.js`, that is, type out `require(‘../node_modules/react/dist/react.js’)`,
    but that’s a lot of typing. Also, we will be using many dependencies from `node_modules`
    in our code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以以与需要`index2.js`相同的方式来做，也就是，输入`require(‘../node_modules/react/dist/react.js’)`，但那需要大量输入。此外，我们将在我们的代码中使用许多来自`node_modules`的依赖项。
- en: 'Fortunately, requiring modules in this way is common, so the `require` function
    is smart enough to grab a dependency based on the name alone, which means we can
    add this to the beginning of our `index.js`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，以这种方式需要模块是很常见的，所以`require`函数足够智能，可以根据名称单独获取依赖项，这意味着我们可以将其添加到我们的`index.js`的开头：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can then use these packages in our code, just as before!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像以前一样在我们的代码中使用这些包！
- en: 'Alright, let’s try it out. Run Webpack again:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们试一下。再次运行Webpack：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It will show the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示以下输出：
- en: '![](../images/00017.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: 'Now, you can see all the files that Webpack bundles together in our `index.js`:
    React, all its dependencies, and ReactDOM.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在我们的`index.js`中看到Webpack捆绑在一起的所有文件：React，它的所有依赖项和ReactDOM。
- en: Reload the page and you should see that nothing has changed. However, our application
    is now much more scalable, and we can organize our files a lot better. When we
    add a dependency, we no longer need to add another `<script>` tag; we just require
    it in our code where we're using it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面，您应该看到没有任何变化。但是，我们的应用程序现在更具可扩展性，我们可以更好地组织我们的文件。当我们添加一个依赖项时，我们不再需要添加另一个`<script>`标签；我们只需在我们使用它的代码中要求它。
- en: Shortcuts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快捷方式
- en: Typing out that long Webpack command is boring and opens us up to errors potentially
    being made (what if we mistype `bundle.js` and end up generating the wrong file?).
    Let’s simplify that process for our own sanity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 打出那么长的Webpack命令很无聊，也可能导致错误（如果我们误输入了`bundle.js`，最终生成了错误的文件怎么办？）。让我们简化这个过程以保持我们的理智。
- en: First, let’s decide that our `index.js` will be the entry point to our application,
    which means that it will require all the other files in the application (or rather,
    it will require a few files that require a few other files, which require a few
    other files, and so on).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们决定我们的`index.js`将是我们应用程序的入口点，这意味着它将需要应用程序中的所有其他文件（或者说，它将需要一些需要其他文件的文件，这些文件需要一些其他文件，依此类推）。
- en: Conversely, our `bundle.js` will be our output file, where all our bundled code
    goes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们的`bundle.js`将是我们的输出文件，其中包含我们所有捆绑的代码。
- en: Those two files, therefore, will always be the arguments we give to the Webpack
    command in our Terminal. Since they won’t change, let’s configure Webpack to always
    use them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这两个文件将始终是我们在终端中给Webpack命令的参数。由于它们不会改变，让我们配置Webpack始终使用它们。
- en: 'In our project folder (not in `src`, but the top-level folder), create a file
    called `webpack.config.js`. In it, put the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目文件夹中（不是在`src`中，而是顶层文件夹），创建一个名为`webpack.config.js`的文件。在其中，放入以下内容：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We define our entry point as the path to the `index.js` (`__dirname` is a global
    variable which grabs the current directory, that is, wherever we run the command
    `webpack`). We then define our output file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的入口点定义为`index.js`的路径（`__dirname`是一个全局变量，它抓取当前目录，也就是说，无论我们在哪里运行`webpack`命令）。然后我们定义我们的输出文件。
- en: 'Now, we can simply run `node_modules/.bin/webpack` in our Terminal, with no
    arguments, and get the same results:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在终端中简单地运行`node_modules/.bin/webpack`，不带任何参数，得到相同的结果：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../images/00018.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.jpeg)'
- en: A good improvement, but we’re developers, so we’re lazy and want to take even
    more shortcuts. Let’s shorten that `node_modules/.bin/webpack` command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的改进，但我们是开发人员，所以我们懒惰，想要更多的快捷方式。让我们缩短`node_modules/.bin/webpack`命令。
- en: 'One of the cool features of `npm` is the ability to write scripts to perform
    commonly used tasks. Let’s try it out. In our `package.json`, create a scripts
    section; within that, make a script named `build`, with a value of the `node_modules/.bin/webpack`
    command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`的一个很酷的功能是能够编写脚本来执行常用任务。让我们试试。在我们的`package.json`中，创建一个脚本部分；在其中，创建一个名为`build`的脚本，值为`node_modules/.bin/webpack`命令：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in the Terminal, you can run either `npm run build` or `yarn build`.
    They do the same thing: run the Webpack command and bundle our files!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在终端中，您可以运行`npm run build`或`yarn build`。它们做的事情是一样的：运行Webpack命令并捆绑我们的文件！
- en: Wow, our life is getting easier and easier. Could we be any lazier?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们的生活变得越来越容易。我们还能更懒吗？
- en: In short, yes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，是的。
- en: Our Dev server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的开发服务器
- en: If we want to update our code (say, to change our `h1` to `h2`), we’ll have
    to make the change, rerun `yarn build`, and then reload the page for every single
    change we want to see. That’ll slow us down a lot in our development process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更新我们的代码（比如，将我们的`h1`更改为`h2`），我们将不得不进行更改，重新运行`yarn build`，然后重新加载页面以查看我们想要看到的每一个更改。这将大大减慢我们的开发过程。
- en: Ideally, every time we change our JavaScript, the Webpack command will automatically
    rerun, and will reload the page. What a world of luxury that would be!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每当我们更改JavaScript时，Webpack命令将自动重新运行，并重新加载页面。这将是多么奢侈的世界啊！
- en: Fortunately, there’s a package called `webpack-dev-server` for exactly this
    purpose. To install it, just run `yarn add webpack-dev-server`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个叫做`webpack-dev-server`的包专门用于这个目的。要安装它，只需运行`yarn add webpack-dev-server`。
- en: Before we jump in, let’s briefly cover how the Dev Server works. It runs a small
    Node application in the background of our machine, serving up the files in our
    public folder so that we can see them by visiting `localhost:3000` in our browser.
    At the same time, it watches the source files of the `bundle.js`, rebundles them
    when they change, and then reloads the page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们简要介绍一下Dev Server是如何工作的。它在我们的机器后台运行一个小型的Node应用程序，提供我们公共文件夹中的文件，以便我们可以通过在浏览器中访问`localhost:3000`来查看它们。同时，它会监视`bundle.js`的源文件，当它们发生变化时重新打包，然后重新加载页面。
- en: To get it to work, we need to specify which folder we want to serve up (public),
    and then do some basic configuration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们需要指定要提供的文件夹（public），然后进行一些基本配置。
- en: 'In our `webpack.config.js`, add the following before the closing squiggly bracket
    (we have the full code here):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`webpack.config.js`中，在闭合的花括号之前添加以下内容（我们在这里有完整的代码）：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`contentBase` does this, setting `public` as the folder to serve, `historyApiFallback`
    lets our single-page app seem like a multipage app, and `inline` is the bit that
    automatically refreshes the page on file changes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`contentBase`会设置`public`作为要提供的文件夹，`historyApiFallback`让我们的单页应用看起来像多页应用，`inline`是自动刷新文件更改的部分：'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Okay, let’s try it. First, we’ll add a new script to our `package.json`, called
    `start`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们试试。首先，我们将在我们的`package.json`中添加一个名为`start`的新脚本：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will run our Dev Server (ensure that you ran `yarn add webpack-dev-server`
    first). In your Terminal, type in **`yarn start`**. You’ll see our Webpack compile,
    and a notice that our app is running on port `8080`. Let’s hop over to `http://localhost:8080`
    in our browser and we should see our application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行我们的Dev Server（确保你首先运行了`yarn add webpack-dev-server`）。在你的终端中，输入**`yarn start`**。你会看到我们的Webpack编译，并且会收到一个通知，我们的应用正在端口`8080`上运行。让我们跳转到浏览器中的`http://localhost:8080`，我们应该能看到我们的应用程序。
- en: The last test is to change the text in our `index.js` from `Hello from React`
    to `Hello from Webpack!`. Your browser tab should automatically reload and reflect
    the changes, without you having to rerun the Webpack command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试是将我们的`index.js`中的文本从`Hello from React`改为`Hello from Webpack!`。你的浏览器标签应该会自动重新加载并反映出更改，而无需重新运行Webpack命令。
- en: Webpack loaders
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack加载器
- en: We’re about to step into the future.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将迈入未来。
- en: So far in this book, we’ve been using JavaScript in its old form. The language
    recently (in 2015) got a facelift, with a smattering of conveniences and new functionalities
    added. This new release is called **ECMAScript 2015**, or **ES6** for short. It’s
    much more enjoyable to use than older JavaScript (ES5), but there’s a problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直在使用旧形式的JavaScript。这种语言最近（2015年）进行了一次整容，增加了一些便利和新功能。这个新版本被称为**ECMAScript
    2015**，简称**ES6**。它比旧版JavaScript（ES5）更加令人愉快，但也存在问题。
- en: All internet browsers are perfectly capable of running JavaScript, but many
    users are using older browsers that are not yet capable of running ES6\. So, as
    developers, we want to use ES6, but how can we do so and still have our website
    work on older browsers?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的互联网浏览器都能够完美运行JavaScript，但许多用户使用的是旧版本浏览器，还不能运行ES6。因此，作为开发者，我们想要使用ES6，但如何才能在旧版本浏览器上使我们的网站正常工作呢？
- en: The key is that ES6 doesn’t do much that ES5 couldn’t do, it just makes it easier
    to write.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于ES6并没有做太多ES5做不到的事情，它只是让编写变得更容易。
- en: 'For instance, looping through an array was done like this previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以前循环遍历数组是这样做的：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, it''s done like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它是这样做的：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An older browser understands the first one, but not the second, but the code
    does the same thing. So, all we need to do is convert the second code snippet
    into the first. This is where Babel comes in. **Babel** is a transpiler tool for
    JavaScript; think of it as a translator. We give it our beautiful ES6 code, and
    it converts it into uglier but more browser-friendly ES5 code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个较旧的浏览器可以理解第一个，但不能理解第二个，但代码的功能是一样的。所以，我们只需要将第二个代码片段转换成第一个。这就是Babel的作用。**Babel**是JavaScript的转译工具；把它想象成一个翻译器。我们把我们美丽的ES6代码给它，它把它转换成更丑陋但更适合浏览器的ES5代码。
- en: We will stick Babel into our Webpack build process so that when we bundle all
    our JavaScript files, we also transpile them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把Babel插入到我们的Webpack构建过程中，这样当我们捆绑所有的JavaScript文件时，我们也会对它们进行转译。
- en: 'To get started, we will install Babel, along with a bunch of plugins and add-ons
    for it to make it play nice with React. Stop your Dev server, and then run the
    following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将安装Babel，以及一堆插件和附加组件，使其能够与React很好地配合。停止你的开发服务器，然后运行以下命令：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yikes, that’s a lot of packages all at once! The important one for the next
    step is `babel-loader`. This is a Webpack loader, and we use it to grab (and then
    transpile) our JavaScript files before passing them to Webpack for bundling. Let’s
    plug it into Webpack.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊，一次性安装了这么多的包！下一步中重要的是`babel-loader`。这是一个Webpack加载器，我们用它来获取（然后转译）我们的JavaScript文件，然后将它们传递给Webpack进行捆绑。让我们把它插入到Webpack中。
- en: 'In our `webpack.config.js`, make a module object with a loaders array within
    it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`webpack.config.js`中，创建一个带有加载器数组的模块对象：
- en: '![](../images/00019.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: Then, we can define our loader inside the array.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在数组内定义我们的加载器。
- en: 'We will make an object with four keys: test, exclude, loader, and query:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有四个键的对象：test、exclude、loader和query：
- en: '**Test** is what the loader will use to determine which files it should transpile.
    For Babel, we want to run on all JavaScript files, so our test will be for the
    files ending with `.js`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Test**是加载器用来确定它应该转译哪些文件的内容。对于Babel，我们希望运行所有的JavaScript文件，所以我们的测试将是以`.js`结尾的文件：'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Exclude** is what not to run on. We can skip our entire `node_modules` folder,
    since the packages are already in ES5:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exclude**是不需要运行的内容。我们可以跳过整个`node_modules`文件夹，因为这些包已经是ES5了：'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Loader** is what our loader is called:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Loader**就是我们的加载器的名字：'
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we’ll use **query** to define our presets (what Babel will use to
    transpile the JavaScript):'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将使用**query**来定义我们的预设（Babel将用它来转译JavaScript）：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s what the full file should look like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件应该是这样的：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run **`yarn start`** and look for errors. If there aren’t any, we can take it
    for a test drive and write some ES6 code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`yarn start`**并查找错误。如果没有错误，我们可以进行测试并编写一些ES6代码。
- en: Our first ES6
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个ES6
- en: Let’s open up our `src/index.js` and see how we can spice it up.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的`src/index.js`并看看我们如何让它更有趣。
- en: 'First, we can replace our `require` calls with the new `import` syntax. It
    looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以用新的`import`语法替换我们的`require`调用。它看起来像这样：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's a little cleaner, and it lets us do some cool stuff, which we’ll see later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会更清晰一些，并且让我们可以做一些很酷的东西，我们稍后会看到。
- en: Do that for both React and ReactDOM, and then we can finally replace our `React.createElement`
    call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于React和ReactDOM都要这样做，然后我们可以最终替换我们的`React.createElement`调用。
- en: As you may guess, it would be very unwieldy to build a complex UI by calling
    `React.createElement` for every HTML element we need. We want the power and functionality
    of JavaScript, but with the readability of HTML.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜到，通过调用`React.createElement`来构建复杂的UI会非常笨拙。我们希望拥有JavaScript的功能和功能，但又具有HTML的可读性。
- en: Enter JSX; **JSX** is a type of syntax that looks like HTML, but is actually
    JavaScript underneath. In other words, it compiles down to `React.createElement`,
    just as our ES6 JavaScript will compile into ES5.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输入JSX；**JSX**是一种类似HTML的语法，但实际上是JavaScript。换句话说，它编译成`React.createElement`，就像我们的ES6
    JavaScript会编译成ES5一样。
- en: It has some gotchas as well, since it’s not true HTML, but we’ll get there.
    The last thing to note is that JSX makes some developers very uncomfortable; they
    say it looks odd to have HTML inside JavaScript. I don’t agree, personally, but
    it's an opinion thing. Whatever your aesthetic stance, JSX offers a lot of convenience,
    so let’s try it out.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它也有一些陷阱，因为它不是真正的HTML，但我们会解决的。最后要注意的是，JSX让一些开发人员感到非常不舒服；他们说在JavaScript内部放置HTML看起来很奇怪。我个人不同意，但这是一个观点问题。无论你的审美立场如何，JSX提供了很多便利，所以让我们试一试。
- en: 'We can simply convert our line of code to this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地将我们的代码行转换为这样：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run `yarn start` (or, if it’s already running, it should automatically refresh).
    If Babel is working correctly, nothing should change. Our first JSX is done!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`yarn start`（或者，如果已经运行，它应该会自动刷新）。如果Babel工作正常，什么都不应该改变。我们的第一个JSX完成了！
- en: We will, of course, work much more with JSX, looking at how it differs from
    HTML, and what advantages it offers to us as developers. However, for now, let’s
    make our lives even easier.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将更多地使用JSX，看看它与HTML的区别，以及作为开发人员它为我们提供了什么优势。但是，现在让我们让我们的生活更加轻松。
- en: Splitting up our app
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分我们的应用程序
- en: To organize our app a bit better (and to do some magic in the next section),
    let’s move our JSX into a separate file from our `ReactDOM.render`. This will
    ensure good separation of concerns throughout our file structure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地组织我们的应用程序（并在下一节中进行一些魔术），让我们将我们的JSX从`ReactDOM.render`中移到一个单独的文件中。这将确保我们的文件结构具有良好的关注点分离。
- en: 'Next to `index.js`, in our `src` folder, create a file called `App.js`. Inside,
    we’ll just make a function called `App`, which returns our JSX:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹的`index.js`旁边，创建一个名为`App.js`的文件。在里面，我们只需创建一个名为`App`的函数，它返回我们的JSX：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the `export` statement at the bottom; this means when we import our file,
    we’ll automatically get this function as the default import. We'll see an example
    of non-default imports down the line, which will make this clearer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意底部的`export`语句；这意味着当我们导入我们的文件时，我们将自动获得此函数作为默认导入。我们将在后面看到非默认导入的示例，这将使这一点更清晰。
- en: 'If we jump back to `index.js`, we can now import `App` from `''./App’`. Then,
    we render it, as shown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到`index.js`，现在可以从`'./App'`导入`App`。然后，我们渲染它，如下所示：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we are using it just like an HTML (or rather, JSX) tag. We’ll talk
    more about why in the coming chapters; for now, the important thing is that our
    app is a bit more organized, with our view logic (the JSX) separate from the render
    logic (`ReactDOM.render`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用它就像HTML（或者说JSX）标签一样。我们将在接下来的章节中更多地讨论原因；现在，重要的是我们的应用程序更有组织性，我们的视图逻辑（JSX）与渲染逻辑（`ReactDOM.render`）分开。
- en: Hot reloading
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热重载
- en: We have achieved some pretty big wins for our development process. There’s one
    more convenience I want to add before we move deeper into Webpack configuration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的开发过程取得了一些重大的胜利。在我们深入了解Webpack配置之前，我想再添加一个便利。
- en: Imagine an application that consists of a form that pops up in a modal when
    a user clicks on an Edit button. When you reload the page, that modal is closed.
    Now, imagine that you’re the developer trying to fine-tune that form. Your Dev
    server is reloading the page after every tweak, forcing you to reopen the modal.
    This is mildly annoying in this case, but think about something like a browser
    game, where getting back to where you were requires several clicks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个应用程序，它包括一个表单，当用户点击编辑按钮时，会弹出一个模态框。当你重新加载页面时，那个模态框会关闭。现在，想象一下你是开发人员，试图微调那个表单。你的开发服务器在每次微调后重新加载页面，迫使你重新打开模态框。在这种情况下，这可能有点烦人，但想象一下像浏览器游戏这样的东西，要回到之前的状态需要点击好几次。
- en: In short, we need a way to reload our JavaScript while still preserving the
    current state of the application, without reloading the page itself; this is called
    **hot reloading**. We use Webpack to swap out the bits of our UI that have changed,
    without reloading everything.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们需要一种方法在保留应用程序当前状态的同时重新加载我们的JavaScript，而不重新加载页面本身；这被称为**热重载**。我们使用Webpack来替换已更改的UI部分，而不重新加载所有内容。
- en: In order to do so, we will use *Dan Abramov’s* `react-hot-loader` package. Let’s
    install it and see how we will configure Webpack to play nicely with it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这样做，我们将使用*Dan Abramov*的`react-hot-loader`包。让我们安装它并看看我们将如何配置Webpack以使其与之良好地配合。
- en: 'To install, type `yarn add react-hot-loader@3.0.0`. At the time of writing,
    version 3 is still in beta; if yarn prompts you to select a beta version of 3.0,
    pick the latest (for me, I chose beta.7):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装，输入`yarn add react-hot-loader@3.0.0`。在撰写本文时，版本3仍处于测试阶段；如果yarn提示您选择3.0的测试版本，请选择最新版本（对我来说，我选择了beta.7）：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To get it working, we need to do four things:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它工作，我们需要做四件事：
- en: Turn on Webpack’s own hot module replacement plugin.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Webpack自己的热模块替换插件。
- en: Use React Hot Loader as an entry point to our app so that Webpack looks to it
    for source files.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将React Hot Loader用作我们应用程序的入口点，以便Webpack查找源文件。
- en: Connect React Hot Loader to Babel.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将React Hot Loader连接到Babel。
- en: Turn on hot reloading with our Dev Server.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的开发服务器上启用热重载。
- en: 'Installing Webpack’s `HMR` plugin is actually quite easy. In our `webpack.config.js`,
    first require Webpack at the top of the file so that we can access the package:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Webpack的`HMR`插件实际上非常容易。在我们的`webpack.config.js`中，首先在文件顶部要求Webpack，以便我们可以访问该包：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our Webpack file is not processed by Babel, so we will still use `require` instead
    of `import`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Webpack文件不会被Babel处理，所以我们仍然会使用`require`而不是`import`。
- en: 'Then, above our `devServer` key, add a new key called `plugins`, with an array
    as the value, which includes `new webpack.HotModuleReplacementPlugin()` as the
    only item:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`devServer`键上面，添加一个名为`plugins`的新键，其值为一个数组，其中包括`new webpack.HotModuleReplacementPlugin()`作为唯一的项：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Restart your server to check for errors, and then move on to step 2.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器以检查错误，然后继续进行第二步。
- en: 'Right now, our `index.js` is our entry point for Webpack; it executes the code
    in that file and derives from the bundle of the files used in that execution.
    We want to execute the `react-hot-loader` package first. Let’s modify our entry
    key to be like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`index.js`是Webpack的入口点；它执行该文件中的代码，并从该执行中使用的文件的捆绑文件中派生。我们想要首先执行`react-hot-loader`包。让我们修改我们的入口键如下：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To make it work with our Dev server, we need to add a bit more code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它与我们的开发服务器配合使用，我们需要添加一些代码：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This configuration means that Webpack will execute the code in these paths before
    moving on to our code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置意味着Webpack会在移动到我们的代码之前执行这些路径中的代码。
- en: Again, try restarting your server. If there is an error, check for typos; otherwise,
    onward!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试重新启动服务器。如果有错误，请检查拼写错误；否则，继续！
- en: 'Next, we want to add a Babel plugin so that our hot reloaded files are compiled
    with `babel-loader`. Just update our Babel configuration, as shown, using the
    Babel plugin included in `react-hot-loader`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要添加一个Babel插件，以便我们的热重新加载文件使用`babel-loader`进行编译。只需更新我们的Babel配置，如下所示，使用`react-hot-loader`中包含的Babel插件：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We also need to turn on hot reloading with our Dev Server; do so by adding
    a `hot: true` to our `devServer` config:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要在我们的开发服务器中打开热重新加载；通过在我们的`devServer`配置中添加`hot: true`来实现：'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As the last step, we need to add a bit of code to our `index.js`. Add the following
    to the bottom of the file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要在我们的`index.js`中添加一些代码。在文件底部添加以下内容：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code basically sends a new version of our app to `ReactDOM.render`
    when the files change.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基本上在文件更改时向`ReactDOM.render`发送我们应用程序的新版本。
- en: Okay, let’s give it a shot. Restart your server, and then open up `localhost:8080`.
    Try editing the text `Hello from React!`, and watch as the HTML updates without
    the page ever reloading; neat.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们试一试。重新启动服务器，然后打开`localhost:8080`。尝试编辑文本`Hello from React!`，看看HTML在不重新加载页面的情况下更新；很棒。
- en: '**Hot Module Replacement** will make our lives much easier, especially once
    we start building our app with different states--states that reloading the page
    will reset.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**热模块替换**将使我们的生活变得更加轻松，特别是当我们开始用不同的状态构建我们的应用程序时--重新加载页面将重置状态。'
- en: Building for production
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产构建
- en: So far, we’ve been entirely focused on using Webpack in a development context,
    but we also need to think about deploying our app to production, and what that
    may involve.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们完全专注于在开发环境中使用Webpack，但我们还需要考虑将我们的应用程序部署到生产环境中，以及可能涉及的内容。
- en: When we send our app out to the World Wide Web, we don’t want to send anything
    unnecessary (remember that our goal is performance); we want to deploy the bare
    minimum.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将我们的应用程序发送到全球网络时，我们不想发送任何不必要的东西（记住我们的目标是性能）；我们想要部署最少的内容。
- en: 'Here’s what we need:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的：
- en: An `index.html` page (minified)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`index.html`页面（经过压缩）
- en: A CSS file (minified)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CSS文件（经过压缩）
- en: A JavaScript file (minified)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JavaScript文件（经过压缩）
- en: All image assets
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有图像资产
- en: An asset manifest (a list of the preceding static files)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个资产清单（上述静态文件的列表）
- en: We have some of these, but not all. Let’s work on using Webpack to automatically
    generate a `build` folder with all of these, which we can deploy later.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些这样的文件，但不是全部。让我们使用Webpack自动生成一个带有所有这些文件的`build`文件夹，以便稍后部署。
- en: First, a minified `index.html`. We want Webpack to take our `public/index.html`
    file, minify it, add the appropriate script and CSS links automatically, and then
    add that to a `build` folder.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个经过压缩的`index.html`。我们希望Webpack获取我们的`public/index.html`文件，对其进行压缩，自动添加适当的脚本和CSS链接，然后将其添加到`build`文件夹中。
- en: Since our Webpack process for production will be different from development,
    let’s make a duplicate of our `webpack.config.js` and name it `webpack.config.prod.js`.
    For most of the rest of the chapter, we’ll work with `webpack.config.prod.js`,
    not `webpack.config.js`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的生产环境中的Webpack流程将与开发环境不同，让我们制作一个`webpack.config.js`的副本，并将其命名为`webpack.config.prod.js`。在本章的大部分时间里，我们将使用`webpack.config.prod.js`，而不是`webpack.config.js`。
- en: 'First things first, delete the `devServer` key from `webpack.config.prod.js`.
    We won''t use a Dev server in production, nor will we use hot reloading. We need
    to delete the two `devServer` specific lines under `entry`, and the hot reloading
    line, so that it now looks like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`webpack.config.prod.js`中删除`devServer`键。我们不会在生产中使用开发服务器，也不会使用热重新加载。我们需要删除`entry`下的两行`devServer`特定行，以及热重新加载行，使其看起来像这样：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also, inside our `webpack.config.prod.js`, let’s specify that our output folder
    is now `chatastrophe/build` by changing this line under output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的`webpack.config.prod.js`中，让我们指定我们的输出文件夹现在是`chatastrophe/build`，通过更改输出下面的这行：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It needs to be changed to this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改为这样：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ll also want to add a `publicPath`, so our `index.html` in `build` will
    know to look for the bundled JavaScript in the same folder:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个`publicPath`，这样我们`build`文件夹中的`index.html`就知道在同一个文件夹中查找捆绑的JavaScript：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s set our environment to production so that React doesn''t display its
    (helpful, in development) warnings. We can also remove `HotModuleReplacementPlugin`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将环境设置为生产环境，这样React就不会显示它的（在开发中很有帮助的）警告。我们还可以移除`HotModuleReplacementPlugin`：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we will use a new Webpack plugin, called `HtmlWebpackPlugin`. It does
    what it sounds like--packs down HTML for us! Let’s install it with `yarn add html-webpack-plugin`,
    and then add it with the following options:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个新的Webpack插件，称为`HtmlWebpackPlugin`。它做起来就像它的名字一样--为我们打包HTML！让我们使用`yarn
    add html-webpack-plugin`来安装它，然后使用以下选项添加它：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Don’t forget to require it at the top of `webpack.config.prod.js`, just like
    we required Webpack:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`webpack.config.prod.js`的顶部要求它，就像我们要求Webpack一样：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Time to give it a test! In your `package.json`, update our build script to
    use our new config, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候来测试一下了！在你的`package.json`中，更新我们的构建脚本以使用我们的新配置，如下所示：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then, run `yarn build`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行`yarn build`。
- en: You should see a `build` folder appear in your project directory. If you open
    `build/index.html`, you’ll see that it’s nice and mushed together. However, there’s
    a problem; in that squashed code, you should see two script tags, both requiring
    `bundle.js`*.*
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在项目目录中看到一个`build`文件夹出现。如果您打开`build/index.html`，您会看到它被整合在一起。但是，有一个问题；在那个压缩的代码中，您应该看到两个脚本标签，都需要`bundle.js`。
- en: That is the result of the `inject` option we specified earlier with `HtmlWebpackPlugin`.
    The plugin adds the script tag for us! How convenient, except that we already
    added it in `public/index.html` ourselves.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前指定的`HtmlWebpackPlugin`选项的结果。插件为我们添加了脚本标签！多么方便，除了我们已经在`public/index.html`中自己添加了它。
- en: 'Here''s a simple solution--let’s copy our `HtmlWebpackPlugin` configuration
    (and require statement) over to `webpack.config.js` (our original configuration
    file). However, we can remove the `minify` key and all its options, since that’s
    not necessary in development:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的解决方案--让我们将我们的`HtmlWebpackPlugin`配置（和require语句）复制到`webpack.config.js`（我们的原始配置文件）中。但是，我们可以删除`minify`键及其所有选项，因为在开发中这是不必要的：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then, delete the script tag from `public/index.html` and try `yarn start` again
    to test whether our development environment is working, and `yarn build` to test
    our production build.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从`public/index.html`中删除脚本标签，然后再次尝试`yarn start`来测试我们的开发环境是否工作正常，以及`yarn build`来测试我们的生产构建。
- en: Okay, we have a minified HTML file in our build, and we have improved our development
    start process a bit as well. The next task is to ensure that our CSS is minified
    and copied into our build folder as well.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在我们的构建中有一个被压缩的HTML文件，并且我们也稍微改进了我们的开发启动过程。下一个任务是确保我们的CSS也被压缩并复制到我们的构建文件夹中。
- en: In our webpack configuration (both production and development), we used `babel-loader`
    to load our JavaScript files in; we will do something similar with CSS.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的webpack配置中（生产和开发环境都是），我们使用`babel-loader`来加载我们的JavaScript文件；我们将类似的方法用于CSS。
- en: 'To do so, we will combine two loaders: `css-loader` and `style-loader`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将结合两个加载器：`css-loader`和`style-loader`。
- en: You can read more about why it’s recommended to use both on the style-loader
    GitHub page at [https://github.com/webpack-contrib/style-loader](https://github.com/webpack-contrib/style-loader).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/webpack-contrib/style-loader](https://github.com/webpack-contrib/style-loader)的style-loader
    GitHub页面上阅读更多关于为什么建议同时使用两者的信息。
- en: 'Install both with the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装两者：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s add them to both our `webpack.config.prod.js` and `webpack.config.js`,
    by adding the following code under our `babel-loader` configuration:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它们添加到我们的`webpack.config.prod.js`和`webpack.config.js`中，通过在我们的`babel-loader`配置下添加以下代码：
- en: '![](../images/00020.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: 'What these plugins do is take a CSS file required by our React code and turn
    it into a `<style>` tag injected into our HTML. Right now, that won’t do much
    for us, since our CSS is sitting in our `public`/`assets` folder. Let’s move it
    to `src`, then require it in `App.js`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件的作用是将我们的React代码所需的CSS文件转换为注入到我们的HTML中的`<style>`标签。现在，这对我们来说没有太大作用，因为我们的CSS目前位于我们的`public`/`assets`文件夹中。让我们将它移到`src`中，然后在`App.js`中引入它：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then, we can delete our link tag from our `public/index.html` and restart our
    server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从我们的`public/index.html`中删除我们的链接标签，并重新启动我们的服务器。
- en: 'If we inspect the head of our HTML in our browser, we should see a `<style>`
    tag with all our CSS inside. Neat!:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中检查我们的HTML的头部，我们应该会看到一个包含所有CSS的`<style>`标签。很整洁！：
- en: '![](../images/00021.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: Now, you may notice when we refresh the page, that there’s a flash of unstyled
    content; this is a consequence of our app now requiring React to boot up before
    adding styling. We’ll address that issue in the coming chapters, rest assured.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们刷新页面时，你可能会注意到有一些未经样式化的内容闪烁；这是因为我们的应用现在需要React在添加样式之前启动。我们将在接下来的章节中解决这个问题，放心。
- en: Run `yarn build` and take a look at `bundle.js`. If you search for "Start initial
    styles" you’ll see where our CSS is bundled in our JavaScript. Also, note how
    relatively readable our JavaScript is compared to our HTML. The next step is to
    take care of minifying it!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`yarn build`，看一下`bundle.js`。如果你搜索"Start initial styles"，你会看到我们的CSS是如何捆绑在我们的JavaScript中的。另外，请注意我们的JavaScript相对于我们的HTML来说是相对可读的。下一步是对其进行缩小处理！
- en: 'Fortunately, doing so is quite easy. We just add another Webpack plugin to
    our `production` file. After `HtmlWebpackPlugin`, add the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这样做非常容易。我们只需要在我们的`production`文件中添加另一个Webpack插件。在`HtmlWebpackPlugin`之后，添加以下内容：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Run `yarn build` again, and you should see that our `bundle.js` has become a
    single line. This is not great for humans, but much faster for the browser.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`yarn build`，你会看到我们的`bundle.js`已经变成了一行。这对人类来说不太好，但对浏览器来说更快。
- en: Okay, we're getting closer to the end. Next, we want to ensure that all our
    asset files get copied over to our `build` folder.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们离结束越来越近了。接下来，我们要确保所有的资产文件都被复制到我们的`build`文件夹中。
- en: 'We can do so by adding another loader to our Webpack config, called `file-loader`.
    We’ll install it with `yarn add file-loader@0.11.2`. Let’s see what the code looks
    like (note that this is only for our `webpack.config.prod.js` file):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向我们的Webpack配置添加另一个加载器来实现，称为`file-loader`。我们将使用`yarn add file-loader@0.11.2`来安装它。让我们看看代码是什么样子的（请注意，这仅适用于我们的`webpack.config.prod.js`文件）：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that we’re excluding HTML, CSS, JSON, and JS files. These are covered by
    our other loaders, so we don’t want to duplicate files.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们排除了HTML、CSS、JSON和JS文件。这些都已经被我们的其他加载器覆盖了，所以我们不想重复文件。
- en: We’re also putting these assets in a `static` folder, just like our `assets`
    folder in our `public` folder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将这些资产放在一个`static`文件夹中，就像我们的`public`文件夹中的`assets`文件夹一样。
- en: However, `file-loader` will only apply to those files required by our JavaScript
    code. We have our favicon and icon, which are currently only used in our `index.html`,
    so Webpack won't find them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`file-loader`只会应用于我们的JavaScript代码所需的文件。我们有我们的favicon和图标，目前只在我们的`index.html`中使用，所以Webpack找不到它们。
- en: To do so, we will use JavaScript instead of Webpack (since Webpack focuses only
    on our `src` folder).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用JavaScript而不是Webpack（因为Webpack只关注我们的`src`文件夹）。
- en: Creating a custom script
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义脚本
- en: Make a new folder in the root of your directory and name it `scripts`. Inside,
    make a file called `copy_assets.js`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的目录根目录下新建一个名为`scripts`的文件夹。在里面，创建一个名为`copy_assets.js`的文件。
- en: In here, we will copy everything in `public` to `build`, excluding our `index.html`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把`public`中的所有内容复制到`build`中，但不包括我们的`index.html`。
- en: To do this (you guessed it), we need one more package; run `yarn add fs-extra`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点（你猜对了），我们需要另一个包；运行 `yarn add fs-extra`。
- en: 'Then, require it inside `copy_assets.js`, as illustrated:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `copy_assets.js` 中引入它，如下所示：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`fs-extra` is a package used for manipulating files in a Node environment.
    It has a method called `copySync`, which we''ll use here.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs-extra` 是一个用于在 Node 环境中操作文件的包。它有一个叫做 `copySync` 的方法，我们将在这里使用它。'
- en: 'The code is rather straightforward:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单明了：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This says copy everything in the `public` folder to the `build` folder, except
    the `index.html` file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着复制 `public` 文件夹中的所有内容到 `build` 文件夹，除了 `index.html` 文件。
- en: If you have a `bundle.js` in your `public` folder from our previous Webpack
    config, you can delete it now.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在之前的 Webpack 配置中的 `public` 文件夹中有一个 `bundle.js`，现在可以删除它了。
- en: 'Now, to run this command whenever we build, add it to the build script in `package.json`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在构建时运行此命令，请将其添加到 `package.json` 中的构建脚本中：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It's a good idea to put the `copy_assets` command before our Webpack command,
    just to ensure that we don't accidentally copy any JavaScript assets in `public`
    without transpiling them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 把 `copy_assets` 命令放在我们的 Webpack 命令之前是个好主意，这样可以确保我们不会在 `public` 中意外复制任何未经转译的
    JavaScript 资源。
- en: Making an asset manifest
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个资产清单
- en: As the last step, we want a list of all the static assets that we’re generating.
    This will be useful down the line, once we start caching them to save load times.
    Fortunately, it’s an easy step, another plugin!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们想要一个我们正在生成的所有静态资产的清单。一旦我们开始缓存它们以节省加载时间，这将会很有用。幸运的是，这是一个简单的步骤，另一个插件！
- en: '`yarn add webpack-manifest-plugin` and add it to `webpack.config.prod.js`,
    under plugins, with the following configuration:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn add webpack-manifest-plugin` 并将其添加到 `webpack.config.prod.js` 中的插件下，使用以下配置：'
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Okay, let’s try it all together. Run **`yarn build`** and then open `index.html`
    in the browser. It should look exactly the same as running **`yarn start`**. You
    should also see an `index.html`, a `bundle.js`, an `asset-manifest.json`, and
    an `assets` folder in our `build` folder.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们一起试试。运行 **`yarn build`**，然后在浏览器中打开 `index.html`。它应该看起来和运行 **`yarn start`**
    一样。你还应该在我们的 `build` 文件夹中看到一个 `index.html`，一个 `bundle.js`，一个 `asset-manifest.json`，和一个
    `assets` 文件夹。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Whew! That was a lot of configuration. The good news is that now we are completely
    ready to start writing React, and build our application. That's what we'll move
    on to next!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！那是很多的配置。好消息是现在我们已经完全准备好开始编写 React 并构建我们的应用程序了。这就是我们接下来要做的！
- en: In this chapter, we covered everything to do with Webpack, adding in a bunch
    of convenient features to speed up our development. In the next chapter, we'll
    start the development process, and begin constructing our React application. This
    is where the fun begins!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了与 Webpack 相关的一切，添加了一堆方便的功能来加快我们的开发速度。在下一章中，我们将开始开发过程，并开始构建我们的 React
    应用程序。这就是乐趣开始的地方！
