- en: '*Chapter 9*: Debugging and Reaching out for Help'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：调试和寻求帮助'
- en: We've been through so much already. We've learned how to create different types
    of components; we've learned about props and state and how each has an important
    role in our component creation. We've also learned about life cycle functions.
    We have gained a lot of knowledge so far, but we still haven't got a way of testing
    our components to see whether they have the behavior we expect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经经历了很多。我们已经学会了如何创建不同类型的组件；我们已经了解了props和state以及它们在组件创建中的重要作用。我们还了解了生命周期函数。到目前为止，我们已经获得了很多知识，但我们仍然没有办法测试我们的组件，以查看它们是否具有我们期望的行为。
- en: In this chapter, we're going to learn about debugging and we'll go through the
    most popular debugging options, such as React DevTools and React Native Debugger.
    We're also going to learn about some other debugging alternatives so that we can
    be on the safe side and make sure we use the right tool for the job when needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习调试，并了解最流行的调试选项，如React DevTools和React Native调试器。我们还将学习一些其他调试替代方案，以便在需要时确保我们使用正确的工具。
- en: We'll go through interesting concepts such as type checking and linting. We'll
    also learn about the **Developer** menu and some of the features React Native
    has for us to quickly find out if our app is having any type of problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习有趣的概念，如类型检查和linting。我们还将了解**开发者**菜单以及React Native为我们提供的一些功能，以快速发现我们的应用是否存在任何类型的问题。
- en: By the end of this chapter, we should have some knowledge about debugging so
    we are ready whenever something's not working the way we expect it to work. This
    will be the last step before creating more complex applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们应该对调试有一些了解，以便在某些东西不按我们的预期工作时做好准备。这将是在创建更复杂的应用程序之前的最后一步。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Different ways of debugging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试的不同方式
- en: React Native Debugger
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native调试器
- en: Where you can reach out for help when you need it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要时寻求帮助的地方
- en: Different ways of debugging
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的调试方式
- en: As we all know, developers are human beings and human beings make mistakes.
    To be completely honest, I feel like software developers make a lot more mistakes
    than just your average normal human being, so of course, there have to be some
    ways of solving the bugs that came into existence because of our mistakes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，开发人员是人类，人类会犯错误。坦率地说，我觉得软件开发人员犯的错误比普通人类要多得多，所以当然，必须有一些方法来解决由于我们的错误而产生的错误。
- en: The process of finding and resolving bugs in computer programming is called
    *debugging*. There are lots of debugging tactics you can use while solving bugs,
    so we'll try and get through some of them in this section. Understanding them
    will surely unlock a new achievement on our React Native journey.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，查找和解决错误的过程称为*调试*。在解决错误时，您可以使用许多调试策略，因此我们将尝试并在本节中介绍其中一些。了解它们肯定会在我们的React
    Native之旅中解锁新的成就。
- en: We'll begin this interesting quest of finding out how to make sure there are
    fewer and fewer errors while we're in the development phase with different formatting
    tools.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始这个有趣的探索，找出如何在开发阶段使用不同的格式化工具来确保错误越来越少。
- en: Linting, type checking, and formatting
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linting，类型检查和格式化
- en: As developers, we'll mostly want to focus our attention on stuff such as business
    logic, code patterns, and best practices. You don't usually want to spend time
    making sure each line is correctly indented or checking what type of argument
    a certain function needs to receive. To simplify our life and our code writing
    process, we can make sure all the automation stuff is delegated to our code editor.
    I'm personally a big **Visual Studio Code** fan, but we've discussed in previous
    chapters that you may use whatever code editor you want to.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们大多数时候都想把注意力集中在业务逻辑、代码模式和最佳实践等方面。通常情况下，我们不想花时间确保每一行都正确缩进，或者检查某个函数需要接收什么类型的参数。为了简化我们的生活和代码编写过程，我们可以确保所有自动化工作都委托给我们的代码编辑器。我个人非常喜欢**Visual
    Studio Code**，但在之前的章节中我们已经讨论过，你可以使用任何你喜欢的代码编辑器。
- en: Type checking
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型检查
- en: The process of verifying and enforcing the constraints of a type is called type
    checking. This is all to make sure that the possibility of type errors is kept
    as low as possible. With JavaScript, we don't have to specify what type of information
    will be stored in a variable and that's all because JavaScript is a loosely typed
    language. But putting constraints or limitations on our code will make us write
    more thoughtful code, making us more careful about how we think about the code
    we're writing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和强制类型约束的过程称为类型检查。这一切都是为了确保类型错误的可能性尽可能地降低。在JavaScript中，我们不必指定变量中将存储什么类型的信息，这都是因为JavaScript是一种弱类型语言。但对我们的代码加上约束或限制将使我们编写更加深思熟虑的代码，让我们更加小心地思考我们正在编写的代码。
- en: 'There are two cool tools when it comes to type checking: **TypeScript** and
    **Flow**. The main difference between these two is that Flow is just a type checker
    while TypeScript is a superset of JavaScript, which basically means it will include
    more next-gen features of JavaScript.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查方面有两个很棒的工具：**TypeScript**和**Flow**。这两者之间的主要区别在于Flow只是一个类型检查器，而TypeScript是JavaScript的超集，基本上意味着它将包含更多JavaScript的下一代特性。
- en: Linting
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linting
- en: Linting is the process of executing a program to analyze the potential program
    syntax errors. The most famous linting plugins for JavaScript are **ESLint**,
    **JSHint**, and **JSLint**. I personally use ESLint, which now even has an official
    plugin for TypeScript linting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Linting是执行程序以分析潜在程序语法错误的过程。JavaScript最著名的linting插件有**ESLint**、**JSHint**和**JSLint**。我个人使用ESLint，现在甚至有一个官方的TypeScript
    linting插件。
- en: You'll see that most people go for ESLint, but that doesn't mean it's the best;
    you need to figure out what exactly works for you, so try and take a few minutes
    to google them all. I usually go for the tools with the biggest community just
    because it's easier to find out how to fix certain errors if they pop up.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现大多数人选择ESLint，但这并不意味着它就是最好的；你需要弄清楚哪种工具对你来说最有效，所以尝试花几分钟去搜索它们。我通常选择拥有最大社区的工具，因为这样更容易找到如何修复某些错误的方法。
- en: Formatting the code
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化代码
- en: Most of your time as a programmer will be spent reading code, so you'll have
    to make sure the code you're reading is legible. Let's pretend we want to quickly
    write a class component; we already know how to do that so maybe we're not even
    looking at the screen anymore.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你大部分时间都将花在阅读代码上，所以你必须确保你正在阅读的代码是可读的。假设我们想快速编写一个类组件；我们已经知道如何做了，所以也许我们甚至不再看屏幕。
- en: 'Because of that, we''re not really paying attention to the way the code looks,
    but it''s irrelevant since we''re already good programmers and we know it works.
    This is how unformatted code looks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们并不真的关注代码的外观，但这并不重要，因为我们已经是优秀的程序员，我们知道它能工作。这就是未格式化的代码的样子：
- en: '![Figure 9.1 – Unformatted class component'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 未格式化的类组件'
- en: '](Images/Figure_9.01_B17074.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.01_B17074.jpg)'
- en: Figure 9.1 – Unformatted class component
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 未格式化的类组件
- en: 'I mean… yeah. This doesn''t look that good. It works but… where do we even
    begin understanding what''s going on in this big sausage? Now let''s see what
    will happen to our code once we save the file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是…是的。这看起来不太好。它能工作，但是…我们甚至从何处开始理解这个大香肠中发生了什么？现在让我们看看一旦我们保存文件后我们的代码会发生什么：
- en: '![Figure 9.2 – Formatted class component'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 格式化的类组件'
- en: '](Images/Figure_9.02_B17074.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.02_B17074.jpg)'
- en: Figure 9.2 – Formatted class component
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 格式化的类组件
- en: Phew! It looks 10 times better, right? We can easily follow the code written
    here. It's a lot easier to read code and understand it when it looks well formatted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！看起来好了十倍，对吧？我们可以很容易地跟踪这里写的代码。当代码格式良好时，阅读和理解代码就变得更容易了。
- en: There are multiple different code formatters, but one of the most used ones
    and also the one that I enjoy using the most is **Prettier**. This is really easy
    to integrate and configure with your favorite code editor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种不同的代码格式化工具，但其中最常用的一个，也是我最喜欢使用的一个是**Prettier**。这很容易与您喜欢的代码编辑器集成和配置。
- en: By the way, you can even configure your linter to use it for formatting the
    code so maybe, if you don't really like Prettier, you might actually configure
    ESLint to do that for you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，您甚至可以配置您的linter来使用它来格式化代码，所以也许，如果您真的不喜欢Prettier，您实际上可以配置ESLint来为您执行这项任务。
- en: In-app Developer menu
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用内开发者菜单
- en: There are a bunch of different tools we have access to from inside of our simulator
    that React Native makes available for us. These are really cool so let's see how
    to access the in-app Developer menu whenever we're testing our app in the simulator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从模拟器内部访问一堆不同的工具，React Native为我们提供了这些工具。这些工具非常酷，所以让我们看看如何在模拟器中测试应用时访问应用内开发者菜单。
- en: The first method of accessing the Developer menu is by shaking the device or
    selecting **Shake Gesture** inside the **Hardware** menu in the iOS Simulator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 访问开发者菜单的第一种方法是摇动设备或在iOS模拟器的**硬件**菜单中选择**摇动手势**。
- en: 'The second method is a keyboard shortcut. For Mac on iOS, the shortcut is *Cmd
    + D* and for Android it''s *Cmd + M*. For Windows, the shortcut is *Ctrl + M*
    for the Android Simulator. Alternatively, for Android, we can run the following
    command to open the dev menu:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用键盘快捷键。对于iOS上的Mac，快捷键是*Cmd + D*，对于Android则是*Cmd + M*。对于Windows，Android模拟器的快捷键是*Ctrl
    + M*。另外，对于Android，我们可以运行以下命令来打开开发菜单：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve used one of the preceding methods, the following menu will open
    up:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用了上述方法之一，将打开以下菜单：
- en: '![Figure 9.3 – Developer menu'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 开发者菜单'
- en: '](Images/Figure_9.03_B17074.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.03_B17074.jpg)'
- en: Figure 9.3 – Developer menu
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 开发者菜单
- en: As we can see, there are a bunch of options right here, so let's talk about
    each one of them. First of all, the ones that are actually interesting to us for
    debugging purposes are **Debug Remote JS**, **Show Performance Monitor**, and
    **Show Element Inspector**. Let's begin with the first one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里有一堆选项，所以让我们谈谈每一个。首先，对于调试目的，我们真正感兴趣的是**调试远程JS**，**显示性能监视器**和**显示元素检查器**。让我们从第一个开始。
- en: Debug Remote JS
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试远程JS
- en: 'Clicking this button will open up a new tab in our Chrome browser with the
    following URL: [http://localhost:8081/debugger-ui](http://localhost:8081/debugger-ui).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮将在我们的Chrome浏览器中打开一个新的标签，其中包含以下URL：[http://localhost:8081/debugger-ui](http://localhost:8081/debugger-ui)。
- en: Select **Tools** | **Developer Tools** from the Chrome menu to open the Developer
    Tools. React Native also recommends enabling **Pause on Caught Exceptions** for
    a better debugging experience. You can do that by going to the **Sources** tab
    and you'll find this checkbox somewhere on the right, next to the usual buttons
    used for breakpoints.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从Chrome菜单中选择**工具** | **开发人员工具**，以打开开发人员工具。React Native还建议启用**捕获异常时暂停**以获得更好的调试体验。您可以通过转到**源**选项卡来执行此操作，并且您会在右侧的某个位置找到此复选框，紧邻用于断点的常规按钮。
- en: Show Performance Monitor
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示性能监视器
- en: 'This one is actually pretty cool. Once you click on this button, it''ll enable
    a performance overlay to help you debug performance problems:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实际上相当酷。一旦您点击此按钮，它将启用性能叠加，以帮助您调试性能问题：
- en: '![Figure 9.4 – Performance overlay'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 - 性能叠加'
- en: '](Images/Figure_9.04_B17074.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.04_B17074.jpg)'
- en: Figure 9.4 – Performance overlay
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 性能叠加
- en: 'Let''s see what we''re seeing in the preceding screenshot. We''ll begin from
    left to right, explaining each and every column:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在前面的截图中我们看到了什么。我们将从左到右开始，解释每一列：
- en: '**RAM** – The amount of RAM your app is using.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM** - 应用程序正在使用的RAM量。'
- en: '**JSC** – The size of the JavaScript code managed heap. It will only get updated
    as garbage collection occurs.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSC** - JavaScript代码管理堆的大小。它只会在垃圾收集发生时更新。'
- en: '**Views** – The top number is the number of views on the screen and the bottom
    number is the total number of views in the component. The bottom number is typically
    larger but usually indicates that you have something that could be improved/refactored.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图** - 顶部数字是屏幕上视图的数量，底部数字是组件中视图的总数。底部数字通常较大，但通常表示您有一些可以改进/重构的内容。'
- en: '**UI** – Main frames per second.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI** - 每秒主要帧数。'
- en: '**JS** – JavaScript frames per second. This is the JavaScript thread where
    all the business logic lives. If the JavaScript thread is unresponsive for a frame,
    it will be considered a dropped frame.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JS** - JavaScript每秒帧数。这是业务逻辑所在的JavaScript线程。如果JavaScript线程在一帧内无响应，它将被视为丢帧。'
- en: Show Element Inspector
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示元素检查器
- en: 'Here it is! The last option in our Developer menu. Let''s click it and see
    what happens. Our screen has kind of changed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这里！我们开发菜单中的最后一个选项。让我们点击它，看看会发生什么。我们的屏幕有点改变了：
- en: '![Figure 9.5 – Element Inspector once we enable it'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 - 一旦我们启用元素检查器'
- en: '](Images/Figure_9.05_B17074.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.05_B17074.jpg)'
- en: Figure 9.5 – Element Inspector once we enable it
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 一旦我们启用元素检查器
- en: Now that we've clicked it, we can see that it asks us to tap on something so
    it can inspect it. At the same time, we also can see there are four different
    tabs down there called **Inspect**, **Perf**, **Network**, and **Touchables**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经点击了它，我们可以看到它要求我们点击某些内容以便检查它。与此同时，我们还可以看到下面有四个不同的选项卡，分别称为**检查**，**性能**，**网络**和**可触摸**。
- en: 'These can all be used just like you''d use the Chrome Developer Tools, but
    with more limitations, so you''d probably prefer using the Developer Tools. Let''s
    at least tap on an element and see how it appears once we click it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以像使用Chrome开发人员工具一样使用，但有更多限制，因此您可能更喜欢使用开发人员工具。让我们至少点击一个元素，看看我们点击后它是什么样子：
- en: '![Figure 9.6 – Our Element Inspector once we have clicked the commerce card'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 - 一旦我们点击了商务卡，我们的元素检查器'
- en: '](Images/Figure_9.06_B17074.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.06_B17074.jpg)'
- en: Figure 9.6 – Our Element Inspector once we have clicked the commerce card
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - 一旦我们点击了商务卡，我们的元素检查器
- en: Once we click the commerce card, we can see it has a blueish overlay on top
    of it with a green border. That green border represents the padding. But let's
    focus our attention on the upper part of the screen where our inspector has now
    moved.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击了商务卡，我们就可以看到它顶部有一个蓝色的覆盖层，周围有一个绿色的边框。那个绿色的边框代表了填充。但让我们把注意力集中在屏幕上部，我们的检查器现在已经移动到那里。
- en: In the upper part of the inspector, we can see the component tree, which basically
    tells us what component exactly we have clicked. So, we've clicked a `View` component
    inside a `Block` component, which lies in a `Context.Consumer` component. I guess
    we can read even further than that and see that this is all part of the `CommerceCard`
    we created in the previous chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器的上部，我们可以看到组件树，它基本上告诉我们我们点击了哪个组件。所以，我们点击了`Block`组件内的`View`组件，它位于`Context.Consumer`组件中。我想我们甚至可以进一步阅读，看到这都是我们在上一章中创建的`CommerceCard`的一部分。
- en: Underneath the component tree, we have the styling applied on the View we've
    clicked. Toward its right, we have information about the *size*, *padding*, and
    *margin*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件树下面，我们有应用在我们点击的View上的样式。在它的右边，我们有关于*大小*、*填充*和*边距*的信息。
- en: The best way of actually learning how to use all these internal tools that are
    provided to us by the React and Expo team is to actually play around with them.
    You probably won't use these as much as the following tool, but I'm pretty sure
    you'll want to experiment with them. The following tool is one of the most commonly
    used for debugging.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上学习如何使用React和Expo团队为我们提供的所有这些内部工具的最佳方法是实际操作它们。您可能不会像使用以下工具那样经常使用它们，但我非常确定您会想要尝试它们。以下工具是最常用于调试的工具之一。
- en: React Native Debugger
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native Debugger
- en: React Native Debugger includes almost all the tools necessary for debugging
    a React Native application. That's why I totally recommend using this one as it
    has everything you need inside it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Debugger包含了几乎所有调试React Native应用程序所需的工具。这就是为什么我完全推荐使用这个，因为它里面包含了您需要的一切。
- en: This is basically a standalone app based on the official **Remote Debugger**
    but with more features implemented. It also includes **React Inspector**, **Redux
    DevTools**, and **Apollo Client DevTools**. We're not really interested in Redux
    and Apollo right now, but you'll most probably stumble upon *Redux* as it's one
    of the most used libraries for state management.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个基于官方**远程调试器**的独立应用，但实现了更多功能。它还包括**React检查器**、**Redux开发工具**和**Apollo客户端开发工具**。我们现在并不真正关心Redux和Apollo，但您很可能会偶然遇到*Redux*，因为它是最常用的状态管理库之一。
- en: 'You can install React Native Debugger on macOS via the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下命令在macOS上安装React Native Debugger：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this command doesn't work, you should make sure you have **Homebrew** installed.
    Homebrew is a module manager and you'll for sure keep on using it with different
    programming tools. To install Homebrew, visit [https://brew.sh](https://brew.sh).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个命令不起作用，您应该确保您已经安装了**Homebrew**。Homebrew是一个模块管理器，您肯定会在不同的编程工具中继续使用它。要安装Homebrew，请访问[https://brew.sh](https://brew.sh)。
- en: 'To install React Native Debugger on Windows, we have to go to the following
    URL: [https://github.com/jhen0409/react-native-debugger/releases](https://github.com/jhen0409/react-native-debugger/releases).
    Download the `.exe` file and open it up.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上安装React Native Debugger，我们必须转到以下网址：[https://github.com/jhen0409/react-native-debugger/releases](https://github.com/jhen0409/react-native-debugger/releases)。下载`.exe`文件并打开它。
- en: 'Now that the software is opened up, press *Ctrl + T* on Windows or *Cmd + T*
    if you''re on a Mac. This will open up a new window where you''ll be prompted
    to specify the port. Write `19000` there and click **Confirm**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在软件已经打开，按下Windows上的*Ctrl + T*或者Mac上的*Cmd + T*。这将打开一个新窗口，您将被提示指定端口。在那里写入`19000`，然后点击**确认**：
- en: '![Figure 9.7 – Window opened for changing the port'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 - 打开用于更改端口的窗口'
- en: '](Images/Figure_9.07_B17074.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.07_B17074.jpg)'
- en: Figure 9.7 – Window opened for changing the port
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 打开用于更改端口的窗口
- en: Now we can run our project with `expo start` or `expo r -c`. After that, open
    up the **Developer** menu and select **Debug Remote JS**. The debugger should
    automatically connect now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`expo start`或`expo r -c`来运行我们的项目。之后，打开**开发者**菜单，选择**调试远程JS**。调试器现在应该会自动连接。
- en: 'Now you should be able to see the element tree as well as the props state and
    children of whatever element you''ve selected. On the right, you''ll see the Chrome
    console:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够看到元素树，以及您选择的任何元素的props状态和子元素。在右侧，您将看到Chrome控制台：
- en: '![Figure 9.8 – React Native Debugger connected to our simulator'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - React Native Debugger连接到我们的模拟器'
- en: '](Images/Figure_9.08_B17074.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.08_B17074.jpg)'
- en: Figure 9.8 – React Native Debugger connected to our simulator
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - React Native Debugger连接到我们的模拟器
- en: If you right-click anywhere in the React Native Debugger, you'll see we have
    some cool little shortcuts that we can use to reload our app, enable the element
    inspector or network inspector, while also clearing our **AsyncStorage** content.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在React Native Debugger中的任何地方右键单击，您将看到我们有一些很酷的小快捷方式，可以用来重新加载我们的应用程序，启用元素检查器或网络检查器，同时还可以清除我们的**AsyncStorage**内容。
- en: 'We can even use this one to inspect our network traffic so right-click anywhere
    and select **Enable Network Inspect**. This will enable the **Network** tab and
    allow us to inspect `fetch` or `XMLHttpRequest` requests. Because there are some
    limitations to inspecting networks using React Native Debugger, you might want
    to look for some alternatives. All of them require a proxy but here are some alternatives
    you might want to look into: *Charles Proxy*, *mitmproxy*, and *Fiddler*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用这个工具来检查我们的网络流量，所以在任何地方右键单击，然后选择**启用网络检查**。这将启用**网络**选项卡，并允许我们检查`fetch`或`XMLHttpRequest`请求。由于使用React
    Native Debugger检查网络存在一些限制，您可能想寻找一些替代方案。它们都需要代理，但是这里有一些您可能想了解的替代方案：*Charles Proxy*，*mitmproxy*和*Fiddler*。
- en: As we know, React Native Debugger has React DevTools implemented inside of it,
    so maybe you don't want to mess with all the tools at once and you'd really love
    seeing the component tree with some properties.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，React Native Debugger内部实现了React DevTools，所以也许您不想一次使用所有工具，而是真的很希望看到带有一些属性的组件树。
- en: Even though we've installed React Native Debugger, I'd really recommend at least
    keeping in mind that we can also use each tool included in it but separately.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经安装了React Native Debugger，但我真的建议至少要记住，我们也可以单独使用其中包含的每个工具。
- en: React DevTools
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React DevTools
- en: 'This tool is really great for checking out the component tree and each component''s
    props and state. First, if we want to install it, we need to do it via `npm` with
    the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具非常适合查看组件树和每个组件的props和状态。首先，如果我们想安装它，我们需要使用以下命令通过`npm`进行安装：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will install React DevTools globally on your computer but you might want
    to just install it as a project dependency. If that''s the case, you can do that
    via the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的计算机上全局安装React DevTools，但您可能只想将其安装为项目依赖项。如果是这种情况，您可以通过以下命令进行安装：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have React DevTools installed on our computer or project, let''s
    start up our project with the usual `expo start` command. After we''ve opened
    up our project, let''s open a new terminal window and run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在计算机或项目上安装了React DevTools，让我们使用通常的`expo start`命令启动我们的项目。在打开项目后，让我们打开一个新的终端窗口，并运行以下命令：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will open up a new window. Now we need to open the Developer menu inside
    our simulator and click **Debug Remote JS**. It''s the same process as before
    but we don''t need to set up the port with React DevTools because it will automatically
    connect to our project. We can see how the app looks by looking at the following
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新窗口。现在我们需要在模拟器内打开开发者菜单，然后点击**调试远程JS**。这与之前的过程相同，但我们不需要使用React DevTools设置端口，因为它会自动连接到我们的项目。我们可以通过查看以下截图来看应用程序的外观：
- en: '![Figure 9.9 – DevTools standalone app for Debug Remote JS'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 – 用于调试远程JS的DevTools独立应用程序'
- en: '](Images/Figure_9.09_B17074.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_9.09_B17074.jpg)'
- en: Figure 9.9 – DevTools standalone app for Debug Remote JS
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 用于调试远程JS的DevTools独立应用程序
- en: As far as we can see, this is identical to our bottom-left window in React Native
    Debugger. I'll mostly use this because it makes it easier for me to check out
    my component but as the app gets bigger, you'll probably catch me switching to
    React Native Debugger.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 据我们所见，这与React Native Debugger中的左下窗口完全相同。我主要会使用这个，因为这样更容易查看我的组件，但随着应用程序变得更大，你可能会看到我切换到React
    Native Debugger。
- en: All in all, this is a great tool to have under your belt and I highly recommend
    playing around with it if you don't really have too much experience with Chrome's
    Developer Tools as these tools are really similar to what a web developer is used
    to.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一个非常好的工具，我强烈建议如果您对Chrome的开发者工具没有太多经验的话，可以尝试一下，因为这些工具与网页开发者所熟悉的非常相似。
- en: Now that we have found out about some tools used for debugging React Native
    applications, let's see what else can we do if an issue can't really be debugged
    with these tools. Or, maybe some of you might even see these tools as too much
    work so let's check out other solutions to some of the problems we might encounter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些用于调试React Native应用程序的工具，让我们看看如果问题无法通过这些工具进行调试，我们还能做些什么。或者，也许有些人甚至认为这些工具太麻烦，所以让我们看看我们可能会遇到的一些问题的其他解决方案。
- en: Where you can reach out for help when you need it
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当您需要帮助时可以寻求帮助的地方
- en: I know for a fact that almost all programmers get stuck at some point while
    developing a product or a feature for an already existing product. So, we should
    know what to do when an error pops up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道事实上几乎所有程序员在开发产品或已有产品的功能时都会遇到困难。因此，当错误出现时，我们应该知道该怎么办。
- en: Sometimes, you can tell exactly what's wrong just by the **stacktrace**, but
    other errors might be a bit more difficult to understand at first glance. The
    stacktrace is the big red error message that pops up on your simulator whenever
    there's a problem with your code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可以通过**堆栈跟踪**准确地知道出了什么问题，但其他错误可能一开始会更难理解。堆栈跟踪是指每当代码出现问题时，在模拟器上弹出的大红色错误消息。
- en: First of all, I think you should know that because we're on React Native and
    the community is so big, almost all error messages can be searched on Google.
    There's always going to be someone out there with a solution for your error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我认为您应该知道，因为我们使用的是React Native，而且社区如此之大，几乎所有的错误消息都可以在Google上搜索到。总会有人有解决您错误的办法。
- en: Another good solution would be to isolate the code that's throwing the error.
    You can do that by discovering which line exactly threw the error and then commenting
    out that section. By isolating the code, we can start experimenting with that
    part alone and by trial and error, we can get to a working solution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的解决方案是隔离引发错误的代码。您可以通过发现确切引发错误的行，然后注释掉该部分来做到这一点。通过隔离代码，我们可以开始单独尝试该部分，并通过反复试验，找到可行的解决方案。
- en: A really good habit that you should start developing is the use of `console.log`.
    You can use this to discover how your code works. For example, by using it before
    and after we do something with a state variable, we can see how exactly the variable
    changes by constantly following it inside our code. The only issue with using
    `console.log` instead of breakpoints with a debugger is the fact that when we
    have any type of `async` code, we might not realize that some code is changing
    at different points that might be out of our control.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该开始养成的一个非常好的习惯是使用`console.log`。您可以使用它来发现您的代码是如何工作的。例如，通过在我们对状态变量进行操作之前和之后使用它，我们可以通过不断跟踪代码内部的变量来看到变量的确切变化。使用`console.log`而不是调试器中的断点的唯一问题是，当我们有任何类型的`async`代码时，我们可能意识不到一些代码在不同的点上发生了变化，这可能超出了我们的控制。
- en: If you can simplify your code as much as possible, you might be able to track
    down errors much more easily than you normally would be able to. Because of that,
    you'll see that some repositories on GitHub ask for a *minimal reproducible demo*
    in their bug reports. This allows them to see that you correctly identified the
    issue and isolated it. So, if the app you're working on is a bit too large and
    complex, extract the functionality and try to identify the specific error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能尽可能简化您的代码，您可能会比通常更容易地追踪错误。因此，您会发现GitHub上的一些存储库要求在其错误报告中提供*最小可重现演示*。这使他们能够看到您正确地识别了问题并将其隔离。因此，如果您正在开发的应用程序有点过大和复杂，请提取功能并尝试识别特定错误。
- en: 'Of course, you might also get into some production errors. Some errors and
    bugs might show up only in production mode. So, it''s a good thing to test your
    app once in a while in production mode by running the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能也会遇到一些生产错误。一些错误和漏洞可能只会在生产模式下出现。因此，不妨偶尔以生产模式运行您的应用程序，通过运行以下命令来测试一下：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The best first step in understanding a production error is to reproduce it locally.
    After that, just isolate the issue and find a good solution for it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 了解生产错误的最佳第一步是在本地重现它。之后，只需隔离问题并找到一个好的解决方案。
- en: The Expo team recommends an automated error logging system such as Sentry. This
    tool will help you in tracking, identifying, and resolving JavaScript errors in
    your production app. It even provides you with *sourcemaps* so you will have stacktraces
    of your errors. This tool is free for up to 5,000 events a month.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Expo团队推荐使用Sentry等自动化错误记录系统。这个工具将帮助您跟踪、识别和解决生产应用程序中的JavaScript错误。它甚至为您提供了*源映射*，这样您就可以获得错误的堆栈跟踪。这个工具每月免费提供5000个事件。
- en: Let's think of what we would do if our production app was crashing. What could
    be the cause of that? This is one of those really frustrating scenarios at first
    glance. The truth is this is pretty easy to understand and solve.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想，如果我们的生产应用程序崩溃了，我们会怎么做。可能的原因是什么？乍一看，这是一个非常令人沮丧的情景之一。事实是这很容易理解和解决。
- en: The first thing you should do is to access the *native device logs*. You can
    do that by following the instructions for whatever platform you're using. We will
    see how to check logs on each of these platforms in the next sections.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该做的第一件事是访问*本机设备日志*。您可以按照您使用的平台的说明来做到这一点。我们将在接下来的部分中看到如何在每个平台上检查日志。
- en: Logs for iPhone/iPad
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iPhone/iPad的日志
- en: 'Follow these steps to check your iPhone logs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤检查您的iPhone日志：
- en: 'Open up your terminal and use the following command:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并使用以下命令：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that this package has been installed, plug in your iOS device and run the
    following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，安装了这个软件包，插入您的iOS设备并运行以下命令：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Click the **Accept** button on your device.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上点击**接受**按钮。
- en: 'Go back to the computer and run the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回计算机并运行以下命令：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Congratulations! Now you can check out your iPhone logs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以查看你的iPhone日志了。
- en: Logs for Android
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android日志
- en: Make sure your Android SDK is installed. Make sure that USB debugging is enabled
    for your device. If it isn't enabled, you should be able to find out how to do
    that at [https://developer.android.com](https://developer.android.com). The information
    you're looking for should be under **User Guide** | **Build and run your app**
    | **Run apps on a hardware device**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的Android SDK已安装。确保USB调试已启用。如果没有启用，你应该能在[https://developer.android.com](https://developer.android.com)找到如何做的信息。你要找的信息应该在**用户指南**
    | **构建和运行应用程序** | **在硬件设备上运行应用程序**下。
- en: Now plug in your device and run `adb logcat` inside the terminal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插入你的设备并在终端内运行`adb logcat`。
- en: Congratulations! Now you're able to check out your Android logs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以查看你的Android日志了。
- en: This is great! We've found out how to check our logs and this should point you
    in the right direction in your bug-solving adventure. Search the logs with the
    words "fatal exception," and this should quickly point you to errors. Now reproduce
    the errors! By reproducing them, we're making sure that our assumption of how
    exactly they behave will be proven.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经找到了如何检查我们的日志，这应该能指引你在解决错误的冒险中朝着正确的方向前进。用“fatal exception”这几个词搜索日志，这应该能迅速指出错误。现在重现这些错误！通过重现它们，我们确保我们对它们的行为方式的假设将得到验证。
- en: Okay, but what if my app only crashes on a specific or older device? This has
    a 90% likelihood of being an indication of performance issues. The best thing
    you could do in this situation is to run your app through a profiler to see what
    exactly is killing your app. Hmm, do we know a good profiler? Yes, React DevTools
    or React Native Debugger both have a profiler included. I'd honestly recommend
    you read [https://reactnative.dev/docs/profiling](https://reactnative.dev/docs/profiling)
    because there's a ton of information about how exactly to identify which processes
    take high amounts of memory and could potentially kill your app.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但如果我的应用程序只在特定或较旧的设备上崩溃怎么办？这有90%的可能性表明存在性能问题。在这种情况下，你最好的做法是通过性能分析器运行你的应用程序，看看到底是什么导致了你的应用程序崩溃。嗯，我们知道一个好的性能分析器吗？是的，React
    DevTools或React Native Debugger都包含了性能分析器。我真诚地建议你阅读[https://reactnative.dev/docs/profiling](https://reactnative.dev/docs/profiling)，因为里面有大量关于如何准确识别哪些进程占用大量内存并可能导致应用程序崩溃的信息。
- en: Still can't figure out what's wrong with your app?
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仍然无法弄清楚应用程序出了什么问题？
- en: This is the perfect moment to seriously consider taking a break. I know it might
    sound weird but a 10-minute break is a lifesaver in certain situations. I sometimes
    even sleep on the issue until the next day and once I open up Visual Studio Code,
    the solution kind of comes to me.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是认真考虑休息的绝佳时机。我知道这听起来有点奇怪，但在某些情况下，10分钟的休息是救命的。有时我甚至会把问题搁置到第二天，一旦我打开Visual Studio
    Code，解决方案就会迎刃而解。
- en: You could also just try a Google search again. The best places to find solutions
    are the **Issues** section on GitHub, Stack Overflow, Reddit, and Expo forums.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以再次尝试谷歌搜索。在GitHub的**Issues**部分、Stack Overflow、Reddit和Expo论坛是找到解决方案的最佳地方。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter wasn't as expansive as the others but I hope you were able to find
    all the information necessary for a jumpstart into how exactly to solve all the
    issues you might encounter while developing with React Native and Galio.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章不像其他章节那样详尽，但我希望你能找到所有必要的信息，以便开始解决在使用React Native和Galio开发过程中可能遇到的所有问题。
- en: We've been through certain tools to prevent mistakes in our code writing. I
    highly recommend going over all of them and doing more research because, as we
    all know, knowledge is power. The more tools you learn about, the better you'll
    feel once you find the perfect match for you.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了一些工具来防止我们编写代码时出现错误。我强烈建议你去了解所有这些工具，并进行更多的研究，因为众所周知，知识就是力量。你了解的工具越多，当你找到适合你的完美匹配时，你会感到越好。
- en: After going through those tools, we learned about React Native's built-in tools
    for debugging and profiling. We learned how to use the features found in the Developer
    menu and I hope you understand the fact that even though the information presented
    here is brief, the most important thing is for you to experiment with all these
    tools.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些工具的学习，我们了解了React Native内置的调试和性能分析工具。我们学会了如何使用开发者菜单中的功能，希望你明白，尽管这里提供的信息很简要，最重要的是让你去尝试所有这些工具。
- en: We've also learned about React DevTools and React Native Debugger. Now that
    we know how to install and start up these tools, it should be fairly easy to experiment
    with our apps to understand more about how exactly React Native works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了React DevTools和React Native Debugger。现在我们知道如何安装和启动这些工具，应该很容易地尝试我们的应用程序，以更多地了解React
    Native的工作原理。
- en: We also learned some ways and tactics for finding out where an error's coming
    from. I really do hope I've done a good job of explaining these topics as they
    usually come packed with your programming experience. Even though I understand
    debugging is not the most exciting experience, it is part of the job and it's
    really cool to learn about it when you get to the point where you actually need
    it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了一些找出错误来源的方法和策略。我真的希望我能很好地解释这些话题，因为它们通常伴随着你的编程经验。尽管我明白调试并不是最令人兴奋的体验，但它是工作的一部分，当你真正需要它的时候，学习它确实很酷。
- en: Now let's move forward because it's time for some practical challenges! We'll
    start by building the Onboarding screen for the Stopwatch app that we're going
    to create further down the road in this book. I really hope you're ready for some
    neat tricks as the Onboarding screen is going to teach us a lot about `FlatList`
    and how to use a reference to control a component via another component. Now,
    get ready, set, go!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续前进，因为是时候进行一些实际挑战了！我们将从为我们将在本书后面创建的秒表应用程序构建引导屏幕开始。我真的希望你已经准备好了一些巧妙的技巧，因为引导屏幕将教会我们很多关于`FlatList`以及如何使用引用来通过另一个组件控制组件的知识。现在，准备好，开始吧！
