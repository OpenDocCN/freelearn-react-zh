- en: '*Chapter 11*: Let''s Build – Stopwatch App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：让我们构建 - 秒表应用'
- en: In the previous chapter, we built the beginning of our cool Stopwatch app by
    creating an onboarding screen. Now, it's time to finish our app by building the
    other features our users are going to use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过创建引导屏幕构建了我们酷炫的秒表应用的开头。现在，是时候通过构建用户将要使用的其他功能来完成我们的应用程序了。
- en: We'll learn lots of new things so that by the end of this chapter, we'll have
    a pretty cool app that I hope is going to inspire you to create more helpful applications
    for the rest of the world. The stuff we've learned so far and will continue to
    learn should give you all the necessary tools to create simple small applications,
    without the need for another tutorial. Even so, you'll sometimes find yourself
    looking all over the internet for solutions to your problems, and that's OK. We
    all do that, so be happy whenever you find a solution and you can make it work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学到很多新东西，到本章结束时，我们将拥有一个相当酷的应用程序，我希望它能激励你为世界其他地方创建更多有用的应用程序。到目前为止，我们学到的东西以及将继续学习的东西应该为你提供创建简单小型应用程序所需的所有工具，而无需另一个教程。即便如此，有时你会发现自己在互联网上四处寻找解决问题的方法，这没关系。我们都会这样做，所以每当你找到解决方案并使其起作用时，都要感到高兴。
- en: To build this React Native mobile app, we're going to start by linking our onboarding
    screen to our actual app by using the React Navigation library. This will help
    us build the navigation of our screens with little to no effort.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个React Native移动应用程序，我们将首先通过使用React Navigation库将我们的引导屏幕链接到我们的实际应用程序。这将帮助我们轻松地构建屏幕的导航。
- en: After that, we'll start working on the Stopwatch part of our app. Creating the
    Stopwatch functionality is pretty straightforward but not as intuitive as you
    might think.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将开始着手应用的秒表部分。创建秒表功能非常直接，但并不像你想象的那样直观。
- en: Once we've created our Stopwatch screen, we will start working on the other
    part of our app, which is the Timer screen. This will teach us how to play sounds
    and how to use what we've already learned by creating the Stopwatch app but with
    a small spin.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了秒表屏幕，我们将开始着手应用的另一部分，即计时器屏幕。这将教会我们如何播放声音，以及如何利用我们已经通过创建秒表应用学到的知识，但加入了一些小的变化。
- en: Finally, we'll learn about local storage and how to use it to make sure our
    onboarding screen is not going to show up every time we open the app since it
    kind of defeats the purpose of having an onboarding screen. So, let's get ready
    and have some fun coding!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习关于本地存储以及如何使用它来确保我们的引导屏幕不会在每次打开应用程序时出现，因为这有点违背了有引导屏幕的初衷。所以，让我们准备好，享受编码的乐趣吧！
- en: 'This chapter will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Linking to React Navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到React Navigation
- en: Creating a Stopwatch
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建秒表
- en: Creating a Timer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计时器
- en: Finalizing our app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们的应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 11` that contains all the code we've written
    in this chapter. To use that project, please follow the instructions in the `README.md`
    file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问GitHub [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)
    查看本章的代码。您会发现一个名为`Chapter 11`的文件夹，其中包含本章中编写的所有代码。要使用该项目，请按照`README.md`文件中的说明进行操作。
- en: Linking to React Navigation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接到React Navigation
- en: We'll begin this challenge by using the same project we used previously in [*Chapter
    10*](B17074_10_epub_Final_SB.xhtml#_idTextAnchor128), *Building an Onboarding
    Screen*. Why, you ask? Well, that's because the purpose of creating an onboarding
    screen was exactly this – to have some sort of introduction to our main app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用与[*第10章*](B17074_10_epub_Final_SB.xhtml#_idTextAnchor128)中先前使用的相同项目来开始这个挑战，*构建一个入职屏幕*。你为什么问？嗯，那是因为创建入职屏幕的目的正是这样
    - 为我们的主要应用程序提供一些介绍。
- en: 'So, open the folder and get ready to code. We''ll start by importing all the
    necessary packages we''ll need to connect our onboarding screen to any new screen
    we''ll be creating moving forward. Let''s open our terminal and move to our project
    folder. There, we''ll begin by writing the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，打开文件夹，准备好编码。我们将从导入我们需要连接我们的入职屏幕到任何我们将来创建的新屏幕所需的所有必要软件包开始。让我们打开我们的终端并移动到我们的项目文件夹。在那里，我们将开始编写以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will install the basis of our navigation system. We''ll also need to install
    all the dependencies this package needs, which we can do via the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们导航系统的基础。我们还需要安装这个软件包需要的所有依赖项，我们可以通过以下命令来做到这一点：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that all our dependencies have been installed, let's talk about the **React
    Navigation** library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的依赖都已经安装好了，让我们谈谈**React Navigation**库。
- en: There are several options for people trying to create a navigation system with
    React Native, but the most commonly used one is React Navigation. You might be
    wondering why that is, and my answer for you would be that this is the most maintained
    and packed features library of them all. I strongly recommend diving into their
    documentation, which you can find at [https://reactnavigation.org/](https://reactnavigation.org/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于试图使用React Native创建导航系统的人来说，有几个选项，但最常用的是React Navigation。你可能想知道为什么会这样，我的答案是，这是它们中最受关注和功能齐全的库。我强烈建议深入研究他们的文档，你可以在[https://reactnavigation.org/](https://reactnavigation.org/)找到。
- en: On top of being such a good navigation library for React Native, it also has
    a really easy and straightforward way of setting up your routes, which we'll look
    at later in this chapter. So, on top of being easy to use, it's completely customizable
    and has native support for iOS and Android. What more could you ask for from a
    navigation library?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为React Native的一个很好的导航库之外，它还有一种非常简单和直接的设置路由的方式，我们将在本章后面讨论。所以，除了易于使用之外，它还是完全可定制的，并且具有对iOS和Android的本地支持。你还能从一个导航库中要求什么呢？
- en: 'Let''s move on with our app and think about what everything should look like.
    I was thinking that once the user is finished with our onboarding screen and they
    hit the **Next** button for the last time, our user will be transported to another
    screen, straight to the **Stopwatch** screen. This screen will have two tabs:
    one for the Stopwatch, which is the main use case of our app, and another for
    the **Timer** screen.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的应用程序，并考虑一切应该是什么样子。我想，一旦用户完成我们的入职屏幕，并且他们最后一次点击**下一步**按钮，我们的用户将被传送到另一个屏幕，直接到**秒表**屏幕。这个屏幕将有两个标签页：一个用于秒表，这是我们应用程序的主要用例，另一个用于**计时器**屏幕。
- en: 'For that to work, we''d need two new components from `@react-navigation`: `stack`
    and `bottom-tabs`. Let''s import them with the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们需要从`@react-navigation`中获得两个新组件：`stack`和`bottom-tabs`。让我们用以下命令导入它们：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, it''s time for us to install the next package we''ll be using:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候安装我们将要使用的下一个软件包了：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that everything has been installed, it's time for us to restructure our
    project so that we have better control over where our files go.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经安装好了，是时候重新构建我们的项目，以便更好地控制我们的文件放在哪里了。
- en: We'll create a new folder inside the root directory of our project called `screens`.
    Next, we must copy and paste our `Onboarding.js` file from the `components` folder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目的根目录内创建一个名为`screens`的新文件夹。接下来，我们必须从`components`文件夹中复制并粘贴我们的`Onboarding.js`文件。
- en: Once you've moved that file into the proper directory, it's time to check our
    files to make sure they all link to this new path we have for our onboarding screen.
    We also need to see if there are any imports inside `Onboarding.js` that need
    to be modified.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将该文件移动到正确的目录中，就是时候检查我们的文件，确保它们都链接到我们引导屏幕的新路径。我们还需要查看`Onboarding.js`内部是否有任何需要修改的导入。
- en: 'Our imports from inside `Onboarding.js` that need to be changed are for the
    components we''re using inside this screen: `OnboardingItem` and `Paginator`.
    Because those components are not in the same folder anymore, we''ll have to make
    sure they''re imported with the correct path. In our case, the path changes to
    `"../components/OnboardingItem"`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Onboarding.js`内部需要更改的导入是我们在此屏幕内使用的组件：`OnboardingItem`和`Paginator`。因为这些组件不再在同一个文件夹中，我们必须确保它们以正确的路径导入。在我们的情况下，路径更改为`"../components/OnboardingItem"`：
- en: '![Figure 11.1 – Our new imports for the onboarding screen'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1-我们引导屏幕的新导入'
- en: '](Images/Figure_11.1_B17074.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.1_B17074.jpg)'
- en: Figure 11.1 – Our new imports for the onboarding screen
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1-我们引导屏幕的新导入
- en: 'Because we''re already here, just go to the `scrollTo()` function. Instead
    of the `console.log()` line that we have inside the `else` statement, write the
    following line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经在这里了，所以去`scrollTo()`函数。在`else`语句内部的`console.log()`行的位置，写入以下行：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is telling `Button` that once it gets to the end of the onboarding screen,
    the next step is to navigate to the next screen, called `''Tab Navigator''`. We''ll
    introduce this screen when we create our routing system. Because we''re using
    a variable called `navigation`, we should also let our component know where to
    get it. Directly above where we''re defining our `Onboarding` function and between
    the parentheses, we''ll allow our function to receive this prop, called `navigation`,
    like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`Button`一旦它到达引导屏幕的末尾，下一步是导航到下一个屏幕，名为`'Tab Navigator'`。当我们创建我们的路由系统时，我们将介绍这个屏幕。因为我们使用了一个名为`navigation`的变量，我们还应该让我们的组件知道从哪里获取它。在我们定义`Onboarding`函数的地方上面直接，并在括号之间，我们将允许我们的函数接收这个属性，称为`navigation`，就像这样：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, if we want to have a working app, we'll have to go to `App.js` and change
    the import for the onboarding screen to the correct path as well. Once we've finalized
    the changes with the correct imports, we can save and run the app. Nothing should
    have changed; all we did was add a new directory so that we have a better folder
    structure. Some text editors or IDEs will automatically change the imports for
    you, so make sure you always read whatever messages might pop up.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要一个正常运行的应用程序，我们需要去`App.js`并且也更改引导屏幕的导入为正确的路径。一旦我们用正确的导入完成了更改，我们可以保存并运行应用程序。什么都不应该改变；我们所做的只是添加了一个新的目录，这样我们就有了更好的文件夹结构。一些文本编辑器或IDE会自动为您更改导入，所以请确保您始终阅读可能弹出的任何消息。
- en: Tip of the day
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每日提示
- en: I often refresh my app and check for changes or error messages, especially when
    all the changes inside the app shouldn't change anything visually. This way, I
    can make sure I'm always up to date with whatever happens inside the app when
    it rerenders.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常刷新我的应用程序并检查更改或错误消息，特别是当应用程序内的所有更改不应该在视觉上改变任何东西时。这样，我就可以确保我始终了解应用程序在重新渲染时发生的任何事情。
- en: 'Now that we have a new folder structure, we can start working on creating the
    routes needed for our app to work. But first, we need to have some placeholders
    for the screen we''re going to work with. So, let''s create two new files in our
    `screens` folder: `Stopwatch.js` and `Timer.js`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新的文件夹结构，我们可以开始创建应用程序所需的路由。但首先，我们需要为即将使用的屏幕创建一些占位符。因此，让我们在我们的`screens`文件夹中创建两个新文件：`Stopwatch.js`和`Timer.js`。
- en: For both, we'll have the same code, besides the name of our functions, which
    will be written inside the `<Text />` component. We'll need those files to test
    if our routes are working correctly before we start diving into the functionality
    of our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个文件，除了我们的函数名称之外，我们将拥有相同的代码，这些函数将被写在`<Text />`组件内。在我们开始深入了解应用程序的功能之前，我们需要这些文件来测试我们的路由是否正常工作。
- en: 'Let''s see what that placeholder screen looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个占位屏幕是什么样子的：
- en: '![Figure 11.2 – Placeholder screen for testing out routes'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 用于测试路由的占位屏幕'
- en: '](Images/Figure_11.2_B17074.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.2_B17074.jpg)'
- en: Figure 11.2 – Placeholder screen for testing out routes
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 用于测试路由的占位屏幕
- en: This example was specifically created for the `Stopwatch.js` file. You'll have
    to create a second one for `Timer.js` as well. As I've already specified, the
    difference between this one and the Timer one is going to be in the name of the
    function and whatever's written inside the `<Text />` component. The rest of it
    should be the same as we're only using these files to test out our routes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是专门为`Stopwatch.js`文件创建的。您还需要为`Timer.js`创建第二个文件。正如我已经指定的，这一个和Timer的区别将在函数的名称和`<Text
    />`组件内的内容上。其余部分应该是相同的，因为我们只是使用这些文件来测试我们的路由。
- en: Now that we have these two new files inside our `screens` folder, we can go
    ahead and create a new file in our root directory called `routes.js`. This is
    where we're going to create the routing system for our cool little app.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`screens`文件夹中有了这两个新文件，我们可以继续在我们的根目录中创建一个名为`routes.js`的新文件。这是我们将为我们很酷的小应用程序创建路由系统的地方。
- en: 'Once you''ve created the new file, we can open it and start coding. We''ll
    begin by importing all the necessary packages and files that we''re going to need
    for this routing system. You can see what packages I''m importing by looking at
    the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了新文件之后，我们可以打开它并开始编码。我们将首先导入所有我们将在这个路由系统中需要的必要包和文件。您可以通过查看以下截图来看到我正在导入哪些包：
- en: '![Figure 11.3 – Imports for routes.js'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - 用于routes.js的导入'
- en: '](Images/Figure_11.3_B17074.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.3_B17074.jpg)'
- en: Figure 11.3 – Imports for routes.js
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 用于routes.js的导入
- en: Now, as you can see, we've been importing all the main packages from `@react-navigation`.
    We started by importing React as we need it to create this component-based routing
    system. Next in line is the `NavigationContainer` component, which was imported
    from `@react-navigation/native`. This component deals with managing the app's
    navigation state and creating the connection between your top-level navigator
    and the app environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，我们已经从`@react-navigation`中导入了所有主要的包。我们首先导入了React，因为我们需要它来创建这个基于组件的路由系统。接下来是`NavigationContainer`组件，它是从`@react-navigation/native`中导入的。这个组件处理管理应用的导航状态，并在顶层导航器和应用环境之间创建连接。
- en: After this, we imported `createStackNavigator` and `createBottomTabNavigator`.
    To understand how the **Stack Navigator** works, we'd have to start thinking of
    our screens as cards in a deck of cards. You're always placing a new card on top
    of an old card so that you can create a stack of cards. That's basically how React
    Navigation works, always placing a new screen on top of another screen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们导入了`createStackNavigator`和`createBottomTabNavigator`。要理解**堆栈导航器**的工作原理，我们必须开始将我们的屏幕视为一叠卡片中的卡片。您总是将新卡片放在旧卡片的顶部，以便您可以创建一叠卡片。这基本上就是React
    Navigation的工作方式，总是将一个新屏幕放在另一个屏幕的顶部。
- en: The **Bottom Tab Navigator** creates the common bottom bar you usually come
    across whenever an app wants you to have easier access to the main functionality.
    This way, we can let our user quickly switch between the Timer and Stopwatch,
    with each screen having easy access from the bottom bar.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**底部选项卡导航器**创建了通常在应用程序希望您更轻松访问主要功能时遇到的底部栏。这样，我们可以让用户快速在计时器和秒表之间切换，每个屏幕都可以从底部栏轻松访问。'
- en: Once we've imported the necessary dependencies to create a routing system for
    our app, it's time to import the screen we'll be using in this system. Of course,
    the onboarding screen is really important as this must be the first screen our
    users see, after which we need the Stopwatch and Timer screens.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了创建应用程序路由系统所需的依赖项，就是时候导入我们将在此系统中使用的屏幕了。当然，入门屏幕非常重要，因为这必须是用户在看到的第一个屏幕，之后我们需要秒表和计时器屏幕。
- en: 'Now that we''re done with the imports, it''s time to see how we can use React
    Navigation to create our routing system. We''ll use `createStackNavigator` and
    `createBottomTabNavigator` to create the variables that we''re going to use as
    components for defining our screens and navigators, so let''s do that now:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们导入完成了，是时候看看我们如何使用React Navigation来创建我们的路由系统了。我们将使用`createStackNavigator`和`createBottomTabNavigator`来创建我们将用作定义屏幕和导航器的组件的变量，所以现在让我们来做吧：
- en: '![Figure 11.4 – Creating variables out of our navigation functions'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 - 从我们的导航函数创建变量'
- en: '](Images/Figure_11.4_B17074.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.4_B17074.jpg)'
- en: Figure 11.4 – Creating variables out of our navigation functions
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 从我们的导航函数创建变量
- en: Having these variables enables us to create easy-to-read routing systems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些变量使我们能够创建易于阅读的路由系统。
- en: 'Let''s begin by writing the function for our main screens; that is, Stopwatch
    and Timer. This should be a normal React function that returns the system for
    a Bottom Tab Navigator. So, we''d use the `Tab` variable for this. Let''s see
    what our function looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编写我们主要屏幕的函数；也就是秒表和计时器。这应该是一个普通的React函数，返回一个底部选项卡导航器的系统。因此，我们会使用`Tab`变量。让我们看看我们的函数是什么样子的：
- en: '![Figure 11.5 – Main screen routing for the Stopwatch and Timer screens'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 - 秒表和计时器屏幕的主屏幕路由'
- en: '](Images/Figure_11.5_B17074.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.5_B17074.jpg)'
- en: Figure 11.5 – Main screen routing for the Stopwatch and Timer screens
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 秒表和计时器屏幕的主屏幕路由
- en: This looks pretty easy to understand, right? We have a `<Tab.Navigator />` component
    that has two screens using the `<Tab.Screen />` component as children. The `Navigator`
    component acts like the glue that lets React Native know that those two screens
    need to be part of the Bottom Tab Navigator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很容易理解，对吧？我们有一个`<Tab.Navigator />`组件，它有两个使用`<Tab.Screen />`组件作为子级的屏幕。`Navigator`组件就像胶水，让React
    Native知道这两个屏幕需要成为底部选项卡导航器的一部分。
- en: For every routing system like this, we need a `Navigator` component and then
    some `Screen` components that let `Navigator` know which screens are part of it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的每个路由系统，我们需要一个`Navigator`组件，然后一些`Screen`组件，让`Navigator`知道哪些屏幕是它的一部分。
- en: I feel like this is pretty straightforward to use in that anybody could just
    go ahead and start creating routing systems for their apps. I encourage you to
    use routing inside your apps as much as possible, just to see how many options
    and things you can change. React Navigation is extremely customizable, so I'm
    pretty sure you'll be amazed by the possibilities of using this library.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这很简单易懂，任何人都可以开始为他们的应用程序创建路由系统。我鼓励你尽可能多地在应用程序中使用路由，看看你可以改变多少选项和东西。React Navigation是非常可定制的，所以我相信你会对使用这个库的可能性感到惊讶。
- en: 'Now, the next step is to set up our main stack of screens. We''ll do that the
    same way we''ve set up our `AppTabs()` function component but this time, we''ll
    also use the `<NavigationContainer />` component as this will be our main routing
    component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步是设置我们的主屏幕堆栈。我们将以与设置`AppTabs()`函数组件相同的方式来做，但这次，我们还将使用`<NavigationContainer
    />`组件，因为这将是我们的主路由组件：
- en: '![Figure 11.6 – Main routing system for our app'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6-我们应用程序的主路由系统'
- en: '](Images/Figure_11.6_B17074.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.6_B17074.jpg)'
- en: Figure 11.6 – Main routing system for our app
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6-我们应用程序的主路由系统
- en: 'Looking at this code of our main function for our routing system might make
    you ask yourself what''s going on here. Fear not – this is not that hard to understand.
    Because this is going to be our main routing system, we''ve used the `<NavigationContainer
    />` component. Inside of it, we have a `<Stack.Navigator />` component creating
    a set of screens that can be applied one on top of each other, just like a deck
    of cards. Here, we have two screens: the `Onboarding` screen and the `AppTabs`
    screen.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看着我们的主函数代码可能会让你想知道这里发生了什么。不要担心-这并不难理解。因为这将是我们的主路由系统，我们使用了`<NavigationContainer
    />`组件。在它里面，我们有一个`<Stack.Navigator />`组件创建了一组可以叠加在一起的屏幕，就像一叠卡片一样。在这里，我们有两个屏幕：`Onboarding`屏幕和`AppTabs`屏幕。
- en: 'As we saw earlier, we''ve defined the `AppTabs` screen component as a Bottom
    Tab Navigator screen containing our two main screens: `Stopwatch` and `Timer`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们已经将`AppTabs`屏幕组件定义为底部选项卡导航器屏幕，其中包含我们的两个主要屏幕：`Stopwatch`和`Timer`。
- en: We also have a `prop` called `options` applied on both of our `<Stack.Screen
    />` components. This prop allows us to apply custom characteristics to our screens.
    Because React Native enables a header bar on each screen in a stack by default,
    we had to get rid of it, so we've given it a value of `false`. If we didn't specify
    this, every time you go to this screen, you'd see the default platform header
    at the top of the screen.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个叫做`options`的`prop`应用在我们的两个`<Stack.Screen />`组件上。这个`prop`允许我们对我们的屏幕应用自定义特性。因为React
    Native默认在堆栈中的每个屏幕上启用了一个标题栏，我们必须摆脱它，所以我们给它一个值为`false`。如果我们没有指定这个，每次你进入这个屏幕，你会看到屏幕顶部的默认平台标题。
- en: Now that we have exported this function, we can go inside our `App.js` file
    and apply our routing system. But this file is filled with tons of stuff we don't
    need, so let's clean it up. Delete everything in `App.js` so that we can start
    rewriting it in the best way possible for our use case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导出了这个函数，我们可以进入我们的`App.js`文件并应用我们的路由系统。但是这个文件里充满了我们不需要的东西，所以让我们清理一下。删除`App.js`中的所有内容，这样我们就可以开始以最佳方式重新编写它以适应我们的用例。
- en: 'After removing everything from inside the file, we can start by importing React.
    After that, import the `AppStack` component we defined earlier in the `routes.js`
    file. Now, all we have to do is create a function called `App()` that returns
    our `<AppStack />` component, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在清空文件内的所有内容后，我们可以开始导入React。之后，导入我们在`routes.js`文件中之前定义的`AppStack`组件。现在，我们只需要创建一个名为`App()`的函数，它返回我们的`<AppStack
    />`组件，如下面的截图所示：
- en: '![Figure 11.7 – The App.js file after making all the necessary modifications'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - 在进行所有必要的修改后的App.js文件'
- en: '](Images/Figure_11.7_B17074.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.7_B17074.jpg)'
- en: Figure 11.7 – The App.js file after making all the necessary modifications
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 在进行所有必要的修改后的App.js文件
- en: Now, our `App.js` file looks a lot cleaner, and we've successfully connected
    our routing system to our React Native app. You should test your app! Save everything,
    start the Expo server, and open your preferred simulator or physical device.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`App.js`文件看起来干净多了，我们已经成功地将我们的路由系统连接到了我们的React Native应用程序。你应该测试你的应用！保存所有内容，启动Expo服务器，然后打开你喜欢的模拟器或物理设备。
- en: Because we've already linked the onboarding screen to the Tab Navigator screen
    in the `scrollTo()` function via the `navigation.navigate()` function, we now
    have a fully functional routing system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经通过`navigation.navigate()`函数将引导屏幕链接到Tab导航器屏幕的`scrollTo()`函数，现在我们有了一个完全功能的路由系统。
- en: You should now be able to see the onboarding screen first. Hit the **Next**
    button until you get to the last screen. Once you are there, hit **Next** one
    more time, and boom! You're now in the `AppTabs()` Tab Navigator. That's the component
    we've been defining in our `routes.js` file. You can click the **Bottom Tab Navigator**
    button to quickly switch between the Stopwatch and Timer apps.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够首先看到引导屏幕。点击**下一步**按钮，直到你到达最后一个屏幕。一旦你到达那里，再点击**下一步**一次，哇！你现在在`AppTabs()`
    Tab导航器中了。这就是我们在`routes.js`文件中定义的组件。你可以点击**底部标签导航器**按钮快速切换秒表和计时器应用程序。
- en: Our React Navigation implementation was a success! Now, it's time for us to
    start coding the functionality of our Stopwatch screen.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的React Navigation实现很成功！现在，是时候开始编写我们的秒表屏幕的功能了。
- en: Creating a Stopwatch
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个秒表
- en: Some of you that have already worked a bit with JavaScript might think that
    creating a Stopwatch is as easy as just calling the `setInterval()` function and
    subtracting a number at every iteration. Well, not really, but fear not – we'll
    make this as easy as possible for everyone, regardless of your experience with
    JavaScript.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些已经在JavaScript上有一些经验的人可能会认为创建一个秒表就像调用`setInterval()`函数并在每次迭代时减去一个数字那样简单。但实际上并不是这样，但不用担心
    - 我们会尽可能地让每个人都能轻松理解，无论你在JavaScript方面的经验如何。
- en: So, let's begin by opening our `Stopwatch.js` file, which we can find inside
    the `screens` folder. Right now, there's only some text with the word Stopwatch
    inside of it that is centered because we styled the main `<View />` component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从打开我们的`Stopwatch.js`文件开始，我们可以在`screens`文件夹中找到它。现在，里面只有一些带有单词Stopwatch的文本，因为我们对主要的`<View
    />`组件进行了样式化。
- en: I'd honestly just start by removing everything from this file and starting fresh
    with the imports. We'll begin by importing `React`, `useState`, and `useEffect`
    from `'react'`. After that, we'll import `StyleSheet` and `SafeAreaView` from
    `'react-native'`. Finally, we will import the `Text`, `Block`, and `Button` components
    from '`galio-framework'`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，我会先从这个文件中删除所有内容，然后从头开始导入。我们将从'react'中导入`React`、`useState`和`useEffect`。之后，我们将从'react-native'中导入`StyleSheet`和`SafeAreaView`。最后，我们将从'galio-framework'中导入`Text`、`Block`和`Button`组件。
- en: 'After importing the components that we''re going to use to create this screen,
    it''s time to build a static screen for us to serve as a starting point. Let''s
    take a look at the following code and try to explain it as this is going to be
    our main layout skeleton:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入我们将用来创建这个屏幕的组件之后，现在是时候为我们建立一个静态屏幕作为起点了。让我们看一下以下代码，并尝试解释一下，因为这将成为我们的主要布局骨架：
- en: '![Figure 11.8 – Basic layout of our Stopwatch component'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 - 我们秒表组件的基本布局'
- en: '](Images/Figure_11.8_B17074.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.8_B17074.jpg)'
- en: Figure 11.8 – Basic layout of our Stopwatch component
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 我们秒表组件的基本布局
- en: Well, this is a big chunk of code, so let's dive right in and explain it. So,
    after importing everything that we need, we will begin writing our `Stopwatch()`
    functional component. Inside of it, we can see that there's a big `<Block/>` component
    and then a `<SafeAreaView />` component. These are here just to take everything
    in and make sure there won't be any problems if we encounter a phone with a notch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是一大块代码，让我们直接深入并解释一下。所以，在导入我们需要的一切之后，我们将开始编写我们的`Stopwatch()`函数组件。在其中，我们可以看到有一个大的`<Block/>`组件，然后是一个`<SafeAreaView
    />`组件。这些只是为了包含所有内容，并确保如果我们遇到有刘海的手机时不会出现任何问题。
- en: Up until now, everything has been really easy, so what happens next? We must
    split the screen into two `<Block />` elements, one with a `flex` property of
    `0.32` and the other with a `flex` property of `0.68`. This is so we can make
    sure we'll have an upper side of the screen containing all the buttons and functionality,
    and then a lower part of the screen where all the laps will appear.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很容易，接下来会发生什么呢？我们必须将屏幕分成两个`<Block />`元素，一个具有`flex`属性为`0.32`，另一个具有`flex`属性为`0.68`。这样我们就可以确保屏幕的上半部分包含所有按钮和功能，然后屏幕的下半部分将显示所有的圈数。
- en: On the upper side of the screen, we can see that we have a `<Text />` element
    with a big font size. This will be our time, which is going to be changed when
    we add all the functionality. After that, we have another `<Block />` element
    with the row prop enabled. This has two buttons inside it. We'll use those buttons
    to start/stop the Stopwatch and also create laps whenever someone has finished
    a lap.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的上方，我们可以看到一个带有大字体大小的`<Text />`元素。这将是我们的时间，在添加所有功能后将会改变。之后，我们有另一个带有row属性的`<Block
    />`元素。里面有两个按钮。我们将使用这些按钮来启动/停止秒表，并在有人完成一圈时创建圈数。
- en: After that, we have another `<Block />` element, whose purpose is to make our
    layout a bit more intuitive to the users. It will point out that the laps will
    show up underneath that line. We've created some styling for those lines that
    you can find in the styles object under `divideLine`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有另一个`<Block />`元素，其目的是使我们的布局对用户更直观一些。它将指出圈数将显示在该行下方。我们已经为这些线条创建了一些样式，你可以在`divideLine`下的样式对象中找到。
- en: 'The following screenshot shows what this will look like on our devices:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这在我们的设备上的样子：
- en: '![Figure 11.9 – Basic layout of our Stopwatch screen'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9 - 秒表屏幕的基本布局'
- en: '](Images/Figure_11.9_B17074.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.9_B17074.jpg)'
- en: Figure 11.9 – Basic layout of our Stopwatch screen
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 秒表屏幕的基本布局
- en: Nice! Now that we have the basic layout coded out, it's time to start working
    on the functionality of our screen. We should start by defining some state variables
    that we're going to use all over this screen. But before that, let's go back to
    the beginning for a second and think about why I said that we can't increment
    the time with the `setInterval()` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！现在我们已经编写了基本布局，是时候开始工作屏幕功能了。我们应该首先定义一些状态变量，这些变量将在整个屏幕上使用。但在此之前，让我们回到一开始，思考一下为什么我说我们不能使用`setInterval()`函数来增加时间。
- en: Using setInterval
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用setInterval
- en: 'So, `setInterval` is a function that does exactly what you''d expect it to
    do. You set a time interval such as 1,000 milliseconds, which is one second, and
    for every second, a function that you''re going to define is going to be called.
    You might think that in theory, we can have something like the following for our
    Stopwatch screen''s functionality:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`setInterval`是一个函数，它确切地做了你期望它做的事情。你设置一个时间间隔，比如1,000毫秒，也就是一秒，然后每秒都会调用一个你要定义的函数。你可能会认为在理论上，我们可以为我们的秒表屏幕功能做如下的事情：
- en: '![Figure 11.10 – setInterval used in a basic example'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10 - 在基本示例中使用setInterval'
- en: '](Images/Figure_11.10_B17074.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.10_B17074.jpg)'
- en: Figure 11.10 – setInterval used in a basic example
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 在基本示例中使用的setInterval
- en: This would work pretty well. Here, every 10ms, we're firing the function that
    increments our variable with 10\. In theory, this works great as we'd now have
    a basic Stopwatch built in five lines of code. But the thing is, `setInterval()`
    is not that reliable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将非常有效。在这里，每10ms，我们都会触发一个增加10的变量的函数。理论上，这很好，因为我们现在有了一个基本的用五行代码构建的秒表。但问题是，`setInterval()`并不那么可靠。
- en: Why am I saying this? Well, if you look at the preceding function, we can see
    that we've specified 10ms as the timing parameter, so our function should fire
    up every 10ms. However, it will not execute the code at the specified time. Instead,
    it will wait *at least* 10ms before it executes. Because of that, we can't say
    our time function will be accurate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我这么说呢？嗯，如果你看一下前面的函数，我们可以看到我们已经指定了10ms作为定时参数，所以我们的函数应该每10ms启动一次。然而，它不会在指定的时间执行代码。相反，它会等待*至少*10ms才执行。因此，我们不能说我们的时间函数是准确的。
- en: I tried a different workaround and I figured out that the best way we can handle
    the time is by using `Date` objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试了不同的解决方法，我发现处理时间的最佳方式是使用`Date`对象。
- en: 'Now that we''ve figured this out, let''s write our state variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了，让我们编写我们的状态变量：
- en: '![Figure 11.11 – State variables used inside the Stopwatch component'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 – 在Stopwatch组件内部使用的状态变量'
- en: '](Images/Figure_11.11_B17074.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.11_B17074.jpg)'
- en: Figure 11.11 – State variables used inside the Stopwatch component
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 在Stopwatch组件内部使用的状态变量
- en: I've explained each of them but basically, we'll have five controls state variables
    called `startTime`, `laps`, `started`, `elapsed`, and `intervalId`. Then, we have
    the time state variables, which we're going to use to see the time change on the
    screen. These are called `minute`, `seconds`, and `ms`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经解释了每一个，但基本上，我们将有五个控制状态变量，称为`startTime`、`laps`、`started`、`elapsed`和`intervalId`。然后，我们有时间状态变量，我们将使用它们来查看屏幕上的时间变化。这些被称为`minute`、`seconds`和`ms`。
- en: 'Now, let''s use the time state variables and make them visible on the screen.
    Let''s see what that `<Text />` component looks like now, after applying the time
    state variables:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用时间状态变量，并在屏幕上显示它们。让我们看看应用时间状态变量后，`<Text />`组件现在是什么样子：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because we might have single-digit numbers at one point in time, by writing
    our variables like this, we can make sure that if they're single-digit numbers,
    we'll add one `0` at the beginning. We will do this for both the `minutes` and
    `seconds` variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在某个时间点上我们可能有个位数的数字，通过这样编写我们的变量，我们可以确保如果它们是个位数，我们将在开头添加一个`0`。我们将对`minutes`和`seconds`变量都这样做。
- en: Saving the file and refreshing the screen should show you no changes at all.
    This is good as it means we've implemented the time state variables inside our
    `Stopwatch` component correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并刷新屏幕应该不会显示任何变化。这是好事，因为这意味着我们已经正确地在`Stopwatch`组件内部实现了时间状态变量。
- en: 'Now that those variables are in place, let''s build a function that will be
    called once we press the **Start** button on the screen. This button needs to
    do several things; first of all, it needs to function as a **Start** and a **Stop**
    button. Secondly, it needs to initialize the `startTime` control state variable
    we''ve just defined with a new `Date` object. Let''s take a look at this function
    now:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些变量已经就位，让我们构建一个函数，一旦我们在屏幕上按下**开始**按钮，它就会被调用。这个按钮需要做几件事情；首先，它需要作为**开始**和**停止**按钮的功能。其次，它需要用一个新的`Date`对象初始化我们刚刚定义的`startTime`控制状态变量。现在让我们来看看这个函数：
- en: '![Figure 11.12 – The startAndStop() function'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12 – startAndStop()函数'
- en: '](Images/Figure_11.12_B17074.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.12_B17074.jpg)'
- en: Figure 11.12 – The startAndStop() function
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 - startAndStop()函数
- en: So, this function can do two things. First, if our `started` state variable
    is `false`, we'll set it to `true` to announce the start of the Stopwatch and
    then set the `startTime` variable to a `new Date()` object. By having a date set
    at the beginning, we can use it later to calculate how much time has passed between
    each iteration, allowing us to have a more accurate time displayed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数可以做两件事情。首先，如果我们的`started`状态变量是`false`，我们将把它设置为`true`，以宣布秒表的开始，然后将`startTime`变量设置为`new
    Date()`对象。通过在开始时设置日期，我们可以在以后使用它来计算每次迭代之间经过了多少时间，从而使我们能够显示更准确的时间。
- en: 'Now, once the started variable has been changed, we need to start the `setInterval()`
    function. Let''s take a look at the following function and talk about how it works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦`started`变量被改变，我们需要启动`setInterval()`函数。让我们来看看下面的函数，并讨论它的工作原理：
- en: '![Figure 11.13 – The useEffect() implementation for starting the setInterval()
    function'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13 - 用于启动setInterval()函数的useEffect()实现'
- en: '](Images/Figure_11.13_B17074.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.13_B17074.jpg)'
- en: Figure 11.13 – The useEffect() implementation for starting the setInterval()
    function
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 - 用于启动setInterval()函数的useEffect()实现
- en: We've implemented this `useEffect()` function because React gave us this cool
    little function that is called every time the component rerenders. The coolest
    thing about it is that we can condition it to work only when the state variable
    in the second parameter is changed. Every time the `started` variable is changed,
    this function is getting called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了这个`useEffect()`函数，因为React给了我们这个很酷的小函数，它在组件重新渲染时被调用。最酷的是，我们可以让它在第二个参数中的状态变量改变时才工作。每当`started`变量改变时，这个函数就会被调用。
- en: The function, which is called once the `started` variable is changed, will be
    the core of our Stopwatch functionality. This functionality will be inside the
    `setInterval()` function. Inside that function, we're setting our elapsed variable
    to a `new Date()` *every 10ms*. After that, we're grabbing our `setInterval()`
    function and applying it to the `intervalId` state variable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`started`变量改变，被调用的函数将成为我们秒表功能的核心。这个功能将在`setInterval()`函数内部。在该函数内部，我们将我们的经过的时间变量设置为`new
    Date()` *每10ms*。之后，我们获取我们的`setInterval()`函数并将其应用到`intervalId`状态变量中。
- en: The `return` function inside the `useEffect()` function cleans up after a side
    effect. This means that this function will be called every time the `started`
    variable changes, just to clean up after the previous render. It also gets called
    when the component unmounts. Because we're working with `setInterval()`, I wanted
    to make extra sure that our interval is going to be cleared every time our `started`
    variable is set to `false` (the Stopwatch stops) so that it won't weigh heavily
    on a user's CPU.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect()`函数内的`return`函数在副作用之后进行清理。这意味着每次`started`变量改变时都会调用此函数，只是为了清理之前的渲染。它还在组件卸载时调用。因为我们正在使用`setInterval()`，我想要确保每当我们的`started`变量设置为`false`（秒表停止）时，我们的间隔都会被清除，以免过重地占用用户的CPU。'
- en: As you can see, clearing an interval is as easy as calling the `clearInterval()`
    function and passing it the interval we want to clear.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，清除间隔就像调用`clearInterval()`函数并传递我们要清除的间隔一样简单。
- en: 'Now that we have the latest time in our elapsed variable, all we have to do
    is check out the difference between the `elapsed` time and `startTime`. We can
    do this with `useEffect()`. Every time the `elapsed` state variable is changed,
    another `useEffect()` function will trigger. Then, we can do all the math there.
    Let''s take a look at how I''ve done this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在elapsed变量中有了最新的时间，我们所要做的就是查看`elapsed`时间和`startTime`之间的差异。我们可以使用`useEffect()`来做到这一点。每当`elapsed`状态变量被更改时，另一个`useEffect()`函数将被触发。然后，我们可以在那里进行所有的数学运算。让我们看看我是如何做到这一点的：
- en: '![Figure 11.14 – The second useEffect() function, which depends on elapsed'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14 - 第二个useEffect()函数，它依赖于elapsed'
- en: '](Images/Figure_11.14_B17074.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.14_B17074.jpg)'
- en: Figure 11.14 – The second useEffect() function, which depends on elapsed
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 - 第二个useEffect()函数，它依赖于elapsed
- en: 'So, this `useEffect()` function is called every time `elapsed` changes, which
    is every 10ms. What we''re doing here is checking if `elapsed` exists (is not
    undefined) and that `started` is `true`. If both these conditions are true, we
    can use `elapsed`, which contains the latest `Date` value, to work out the difference
    and have it in milliseconds. Moving forward, we do the math for the minutes and
    seconds. Once we have all these values, we can set them to the time state variables
    we defined earlier: `minute`, `seconds`, and `ms`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个`useEffect()`函数在`elapsed`改变时被调用，这是每10ms一次。我们在这里做的是检查`elapsed`是否存在（不是未定义），并且`started`为`true`。如果这两个条件都为真，我们可以使用`elapsed`，其中包含最新的`Date`值，来计算差值并将其转换为毫秒。继续进行，我们对分钟和秒进行数学运算。一旦我们有了所有这些值，我们可以将它们设置为我们之前定义的时间状态变量：`minute`，`seconds`和`ms`。
- en: 'Wait… are we done? Kind of, but not really. Let''s go to our **Start** button
    and change it a little bit so that it can be used. We''ll change it like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 等等...我们完成了吗？有点，但不完全。让我们去我们的“开始”按钮，稍微改变一下，以便可以使用它。我们将像这样改变它：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way, we can have different colors and our button will display a different
    text based on whatever it can do at that moment. This is all based on our `started`
    state variable, which tells us if the Stopwatch has started or not. I've picked
    these colors because we've used them in the onboarding screen as well and I thought
    they fit, but you can use whatever colors you want.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以拥有不同的颜色，我们的按钮将根据其当前状态显示不同的文本。这一切都基于我们的`started`状态变量，它告诉我们秒表是否已启动。我选择了这些颜色，因为我们在入职屏幕上也使用了它们，我认为它们很合适，但您可以使用任何您想要的颜色。
- en: Now, we can save and reload our JavaScript and check out what we've been creating.
    By pressing the **Start** button, you'll see it change its text into the **Stop**
    button's text, and that its color is now gray. The time started going up and our
    Stopwatch works correctly, but what type of Stopwatch is this if we can't even
    register any laps?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以保存和重新加载我们的JavaScript，并查看我们一直在创建的东西。通过按下“开始”按钮，您将看到它将其文本更改为“停止”按钮的文本，并且其颜色现在是灰色。时间开始增加，我们的秒表正常工作，但如果我们甚至不能注册任何圈数，这是什么类型的秒表呢？
- en: 'Let''s create the function that''ll be busy registering the laps. We also need
    a way to display those laps, which we''ll do once we''re done with the function.
    I was thinking that we can use this function just like we used the `startAndStop()`
    function, in that we should be able to register laps and clear all the laps with
    the same button. So, let''s take a look at how I did this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个忙于注册圈数的函数。我们还需要一种方法来显示这些圈数，这是我们完成该功能后将要做的事情。我在想，我们可以像使用`startAndStop()`函数一样使用这个函数，我们应该能够使用同一个按钮注册圈数并清除所有圈数。所以，让我们看看我是如何做到这一点的：
- en: '![Figure 11.15 – setLap function used to register and clear all the laps'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.15 - setLap函数用于注册和清除所有圈数'
- en: '](Images/Figure_11.15_B17074.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.15_B17074.jpg)'
- en: Figure 11.15 – setLap function used to register and clear all the laps
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 – 使用setLap函数来注册和清除所有圈数
- en: This is a straightforward function; our function can do two different things
    based on what our started state variable value is. If the Stopwatch is started,
    it's OK for us to register new laps but if the Stopwatch is not working anymore,
    we should be able to clear all the laps and get ready for a new session.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直接的函数；我们的函数可以根据我们的started状态变量值做两件不同的事情。如果计时器已经开始，我们可以注册新的圈数，但如果计时器不再工作，我们应该能够清除所有圈数并准备好进行新的计时。
- en: 'Now that we have this function, let''s link it to our **Lap** button, just
    like we did with the **Start** button:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个函数，让我们将它链接到我们的**Lap**按钮上，就像我们在**Start**按钮上做的那样：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s work on displaying the laps on the screen. We''re going to do that
    by importing `FlatList` from `''react-native''`, so just scroll up to the imports
    part of our file and add `FlatList`. Our new import should look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来展示屏幕上的圈数。我们将通过从`'react-native'`导入`FlatList`来实现这一点，所以只需滚动到文件的导入部分并添加`FlatList`。我们的新导入应该是这样的：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Displaying laps
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示圈数
- en: 'We should use the `FlatList` component in the `<Block flex={0.68} />` component
    instead of the `<Text />` component currently living there. So, delete the `<Text
    />` component and look at my implementation of `<FlatList />`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`<Block flex={0.68} />`组件中使用`FlatList`组件，而不是当前存在的`<Text />`组件。因此，删除`<Text
    />`组件，看看我对`<FlatList />`的实现：
- en: '![Figure 11.16 – FlatList implemented instead of our Text component'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16 – 使用FlatList代替我们的Text组件'
- en: '](Images/Figure_11.16_B17074.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.16_B17074.jpg)'
- en: Figure 11.16 – FlatList implemented instead of our Text component
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 使用FlatList代替我们的Text组件
- en: 'There''s nothing new here. We''ve already used a `FlatList` component to build
    the onboarding screen, and you''ve probably noticed that we have a new component
    there called `<LapItem />`. I''ve defined this component under our main Stopwatch
    component. You could always move it and create a separate file for it under the
    `components` folder, but I felt like having it close to the main component was
    easier for me to always check out. Let''s check out this component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新东西。我们已经使用了`FlatList`组件来构建引导屏幕，你可能已经注意到我们在那里有一个新组件叫做`<LapItem />`。我已经在我们的主计时器组件下定义了这个组件。你可以随时将它移动并在`components`文件夹下创建一个单独的文件，但我觉得让它靠近主组件对我来说更容易查看。让我们来看看这个组件：
- en: '![Figure 11.17 – The LapItem component being used in FlatList'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17 – 在FlatList中使用的LapItem组件'
- en: '](Images/Figure_11.17_B17074.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.17_B17074.jpg)'
- en: Figure 11.17 – The LapItem component being used in FlatList
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 在FlatList中使用的LapItem组件
- en: This component takes a `prop` called `item`, which is an array containing the
    information needed to display the laps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件接受一个叫做`item`的`prop`，它是一个包含显示圈数所需信息的数组。
- en: 'And with that, we''ve finished this beautiful screen. Save and reload the JavaScript
    and try it out. The following screenshot shows what our app should look like right
    now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了这个漂亮的屏幕。保存并重新加载JavaScript，然后试一试。以下截图显示了我们的应用现在应该是什么样子的：
- en: '![Figure 11.18 – Completed Stopwatch component'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.18 – 完成的计时器组件'
- en: '](Images/Figure_11.18_B17074.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.18_B17074.jpg)'
- en: Figure 11.18 – Completed Stopwatch component
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – 完成的计时器组件
- en: It's working! It looks cool and we've had a great time building this. Now, let's
    start working on the Timer screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在工作！看起来很酷，我们在构建过程中度过了愉快的时光。现在，让我们开始在计时器屏幕上工作。
- en: Creating a Timer
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个计时器
- en: Now that we're done with the Stopwatch screen, it's time to open the `Timer.js`
    file and work on our Timer screen. We should dive right in, remove everything,
    and start importing everything we need for this.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了秒表屏幕，是时候打开`Timer.js`文件，开始处理我们的计时器屏幕了。我们应该立即开始，清空所有内容，并开始导入我们需要的一切。
- en: 'First of all, we all know that at the end of a Timer cycle, there''s always
    a sound playing, letting you know that it has stopped. For that, we need a new
    package called `expo-av`. This is an Expo package for dealing with audio. It is
    quite easy to use, so let''s begin by installing it into our project by using
    the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们都知道在计时器周期结束时，总会播放一个声音，让你知道它已经停止了。为此，我们需要一个名为`expo-av`的新包。这是一个用于处理音频的Expo包。它非常容易使用，所以让我们通过以下命令将其安装到我们的项目中：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have installed this, we can start importing everything we'll need
    to build this component. We'll need a timer component that is quite similar to
    the Stopwatch. We'll also need to use intervals and date objects to calculate
    everything, so `useEffect` and `useState` will be imperative for our screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了这个，我们可以开始导入我们需要构建这个组件的一切。我们将需要一个计时器组件，它与秒表非常相似。我们还需要使用间隔和日期对象来计算一切，因此`useEffect`和`useState`对我们的屏幕至关重要。
- en: 'The difference is that we''ll need to let the user input exactly how much time
    they want the Timer to work for. We can do this with a `<TextInput />` component
    from `''react-native''`. Because we''re using an input, we''ll also need a `<KeyboardAvoidingView
    />` component that helps us reorganize the layout so that our inputs will never
    be hidden by the opening of the keyboard. Let''s take a look at our imports:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，我们需要让用户精确输入他们希望计时器工作的时间。我们可以使用`'react-native'`中的`<TextInput />`组件来实现这一点。因为我们使用了输入，我们还需要一个`<KeyboardAvoidingView
    />`组件，它可以帮助我们重新组织布局，以便我们的输入永远不会被键盘的打开所隐藏。让我们来看看我们的导入：
- en: '![Figure 11.19 – Imports for the Timer screen'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19 – 计时器屏幕的导入'
- en: '](Images/Figure_11.19_B17074.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.19_B17074.jpg)'
- en: Figure 11.19 – Imports for the Timer screen
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 – 计时器屏幕的导入
- en: As you can see, the `import` statements are quite similar to the Stopwatch screen.
    This is because these screens are similar. However, by having them doing the same
    thing, we can learn to always inspire ourselves by looking at what we did in the
    past. All the code you've written will help you with other problems you might
    encounter. Because we've created the Stopwatch screen, we now know of the inaccuracy
    of `setInterval()`and how to combat that.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`import`语句与秒表屏幕非常相似。这是因为这些屏幕是相似的。然而，通过让它们做同样的事情，我们可以学会始终通过查看我们过去所做的来激励自己。你编写的所有代码将帮助你解决可能遇到的其他问题。因为我们已经创建了秒表屏幕，现在我们知道了`setInterval()`的不准确性以及如何应对它。
- en: 'Now, let''s start creating the basic functionality for our Timer screen with
    a layout that we can work with. For the layout, we''ll start everything the same
    way we''ve started the Stopwatch screen; that is, with a `<Block />` component
    with `styles.container` attached to it. After that, we''ll use `<SafeAreaView
    />` and then a `<KeyboardAvoidingView />` with a `flex: 1` style applied to it.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们开始为我们的计时器屏幕创建基本功能，以及一个我们可以使用的布局。对于布局，我们将以与我们开始秒表屏幕相同的方式开始一切；也就是说，使用附加了`styles.container`的`<Block
    />`组件。之后，我们将使用`<SafeAreaView />`，然后使用一个附加了`flex: 1`样式的`<KeyboardAvoidingView />`。'
- en: 'Inside of that `<KeyboardAvoidingView />` component, we''ll have two `<Block
    />` elements. The first one is going to have a `<TextInput />` component as a
    child that is going to be the title of the Timer. We''re using `<TextInput />`
    here because you may wish to change the title of the timer; this is just a cool
    little feature. The second one is going to have two `<TextInput />` elements –
    one for minutes and one for seconds. This way, the user can input whatever number
    they need for the timer. The second `<Block />` element will also contain the
    **Start/Stop** button of the timer. Let''s see what that looks like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个`<KeyboardAvoidingView />`组件内部，我们将有两个`<Block />`元素。第一个将有一个`<TextInput />`组件作为子元素，它将是计时器的标题。我们在这里使用`<TextInput
    />`是因为你可能希望更改计时器的标题；这只是一个很酷的小功能。第二个将有两个`<TextInput />`元素 - 一个用于分钟，一个用于秒。这样，用户可以输入他们需要的计时器的任何数字。第二个`<Block
    />`元素还将包含计时器的**开始/停止**按钮。让我们看看它是什么样子的：
- en: '![Figure 11.20 – Layout created for the Timer screen'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20 - 为计时器屏幕创建的布局'
- en: '](Images/Figure_11.20_B17074.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.20_B17074.jpg)'
- en: Figure 11.20 – Layout created for the Timer screen
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 - 为计时器屏幕创建的布局
- en: As we explained earlier, this is not that complicated, but what you'll notice
    here is that I've already filled in the value props for our `<TextInput />` components.
    I've also made sure that a state variable is in place for our **Start/Stop** button.
    This is only because we've already been through the Stopwatch screen, which means
    we've already experienced the fact that we'll need certain state variables so
    that we can change the text inside the buttons.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的那样，这并不复杂，但你会注意到我已经为我们的`<TextInput />`组件填写了值。我还确保了一个状态变量适用于我们的**开始/停止**按钮。这是因为我们已经经历了秒表屏幕，这意味着我们已经体验到我们需要某些状态变量以便我们可以改变按钮内的文本。
- en: As you can see, we also used the `editable` prop on our `<TextInput />` components
    since we only want those values to be **editable** when the timer is not working.
    We can also see another new prop, called `returnKeyType`. This prop allows us
    to tell the device which kind of key we want available for our users. I've opted
    for the `done` key because once they add the number they want, they could just
    press that key and move forward.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们还在我们的`<TextInput />`组件上使用了`editable`属性，因为我们只希望在计时器不工作时才能编辑这些值。我们还可以看到另一个新属性，称为`returnKeyType`。这个属性允许我们告诉设备我们希望为用户提供哪种类型的键。我选择了`done`键，因为一旦他们添加他们想要的数字，他们就可以按下那个键并继续向前。
- en: We also know from the previous chapters that `<TextInput />` is a controlled
    component, which means it needs a state variable for the `value` prop while also
    a way of changing that state via the `onChangeText` prop. Knowing all this, I'd
    suggest reading over that code a couple of times to see if you can understand
    it. We won't make any changes to it anymore as this is enough for us to be able
    to jump right into the Timer's functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从之前的章节中知道`<TextInput />`是一个受控组件，这意味着它需要一个状态变量来适用于`value`属性，同时也需要一种通过`onChangeText`属性来改变状态的方法。知道了这一切，我建议你多读几遍那段代码，看看你是否能理解它。我们不会再对它进行任何更改，因为这已经足够让我们能够直接进入计时器的功能。
- en: 'Let''s look at the state variables we''ve defined for this Timer:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们来看看我们为这个计时器定义的状态变量： '
- en: '![Figure 11.21 – State variables created for the Timer screen'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.21 - 为计时器屏幕创建的状态变量'
- en: '](Images/Figure_11.21_B17074.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.21_B17074.jpg)'
- en: Figure 11.21 – State variables created for the Timer screen
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 - 为计时器屏幕创建的状态变量
- en: So, at the beginning of our functional component for the Timer screen, we'd
    be writing all these state variables. Just like before, we have some time state
    variables and some controls' state variables. We've already seen `intervalId`
    and `startTimer` (we called it `started` in the Stopwatch screen).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在计时器屏幕的功能组件开始时，我们将编写所有这些状态变量。就像以前一样，我们有一些时间状态变量和一些控制状态变量。我们已经看到了`intervalId`和`startTimer`（在秒表屏幕中我们称其为`started`）。
- en: Let's briefly explain the other state variables that we're using. The `countdownMinutes`
    and `countdownSeconds` variables are strictly used to display the minutes and
    seconds of our timer. The `final` variable is there because we'll know how much
    time we want our Timer to last based on the user's input. We'll use it to calculate
    the amount of time once we start the timer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要解释一下我们正在使用的其他状态变量。`countdownMinutes`和`countdownSeconds`变量严格用于显示计时器的分钟和秒钟。`final`变量是因为我们将根据用户的输入知道我们希望我们的计时器持续多长时间。一旦我们启动计时器，我们将使用它来计算时间量。
- en: As you can see, we also have the `timer` and `timeDisplay` variables. The `timer`
    variable acts just like the `elapsed` variable acted when we were working with
    the Stopwatch screen. The `timeDisplay` variable is here for us to always have
    the value of our timer in seconds. This way, we can make sure to stop it whenever
    it hits `0`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们还有`timer`和`timeDisplay`变量。`timer`变量的作用就像我们在工作台时`elapsed`变量的作用一样。`timeDisplay`变量是为了让我们始终拥有计时器的秒数值。这样，我们可以确保在计时器达到`0`时停止它。
- en: Our `title` variable is there for the title of the screen, which the user will
    be able to change whenever they want. The sound variable is there because we need
    to know whenever the sound has been loaded on the screen. This will help us use
    another `useEffect()` function so that we can clean up after ourselves.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`title`变量是屏幕标题，用户可以随时更改。声音变量是因为我们需要知道声音是否已在屏幕上加载。这将帮助我们使用另一个`useEffect()`函数，以便我们可以在自己之后清理。
- en: 'Great! I like how much faster we can move now that we''re done with the Stopwatch
    screen. This means that we''re learning, and experience is the best teacher out
    there! Let''s take a look at the `start()` function, which we''re going to call
    whenever we press the **Start** button:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我喜欢现在我们可以更快地移动，因为我们已经完成了秒表屏幕。这意味着我们正在学习，而经验是最好的老师！让我们来看看`start()`函数，每当我们按下**开始**按钮时我们将调用它：
- en: '![Figure 11.22 – The start() function used to start or stop the timer'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.22 - start()函数用于启动或停止计时器'
- en: '](Images/Figure_11.22_B17074.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.22_B17074.jpg)'
- en: Figure 11.22 – The start() function used to start or stop the timer
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 - start()函数用于启动或停止计时器
- en: As we can see, we're following the same pattern we used for the Stopwatch screen.
    This enables us to use this function as a start or stop function for our button.
    So, if the `startTimer` state variable is `false`, then we will initialize a new
    variable with a `Date` object. Then, we'll set that date with the minutes and
    seconds we've grabbed from our two `<TextInput />` components from the screen,
    adding those to the current date's minutes and seconds. This means that we've
    taken the current date and added the time our user has inputted. This is the final
    date we're trying to reach, so the next step is setting our `final` state variable
    with the date we've just calculated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在遵循我们在秒表屏幕上使用的相同模式。这使我们能够将此函数用作按钮的启动或停止函数。因此，如果`startTimer`状态变量为`false`，那么我们将使用`Date`对象初始化一个新变量。然后，我们将从屏幕上的两个`<TextInput
    />`组件中获取的分钟和秒钟设置为该日期，将这些添加到当前日期的分钟和秒钟。这意味着我们已经获取了当前日期并添加了用户输入的时间。这是我们试图达到的最终日期，因此下一步是使用我们刚刚计算的日期设置我们的`final`状态变量。
- en: 'Then, we must set the `startTimer` variable to true, which will notify our
    component that the timer has started. At this point, we''ll also load the sound.
    Let''s define the `loadSound()` function for this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将`startTimer`变量设置为true，这将通知我们的组件计时器已经启动。在这一点上，我们还将加载声音。让我们为此定义`loadSound()`函数：
- en: '![Figure 11.23 – The loadSound() function with a new keyword called async'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.23 - 带有新关键字async的loadSound()函数'
- en: '](Images/Figure_11.23_B17074.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.23_B17074.jpg)'
- en: Figure 11.23 – The loadSound() function with a new keyword called async
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 - 带有新关键字async的loadSound()函数
- en: As you might have figured out by now, this function has a new keyword called
    `async`. Worry not – this is here to make sure our function will not stop the
    whole application while we're trying to load that sound. If you don't have a sound
    that you can use, you can find the sound that I've created in this project's files
    on GitHub. You can also create your own sounds or even use something online that
    isn't copyrighted. I followed the `'expo-av'` documentation to load the sounds.
    That's why I'm always stressing the fact that your first step, whenever there's
    something you don't understand, should be to look at the documentation of that
    specific package/library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经想到了，这个函数有一个叫做`async`的新关键字。不用担心 - 这是为了确保我们的函数在尝试加载声音时不会停止整个应用程序。如果你没有可以使用的声音，你可以在GitHub上找到我在这个项目文件中创建的声音。你也可以创建自己的声音，甚至使用一些没有版权的在线资源。我遵循了`'expo-av'`文档来加载声音。这就是为什么我总是强调，每当有你不理解的东西时，你的第一步应该是查看特定包/库的文档。
- en: 'Now that we''ve loaded the sounds and started our timer, we should be able
    to see where all the logic behind our screen exists. Just like we did previously,
    we''re using `useEffect()` functions to make sure they''re only triggered when
    a certain state variable changes. The first `useEffect()` function we''re going
    to use is going to depend on the `final` state variable. That''s because this
    variable is needed for all the math, so, naturally, we''re going to check for
    it before we do anything else:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了声音并启动了计时器，我们应该能够看到我们屏幕背后的所有逻辑存在的地方。就像我们之前做的一样，我们使用`useEffect()`函数来确保它们只在特定状态变量改变时触发。我们要使用的第一个`useEffect()`函数将依赖于`final`状态变量。这是因为这个变量对于所有的数学运算都是必需的，所以自然地，在做任何其他事情之前，我们会检查它：
- en: '![Figure 11.24 – The first useEffect() function depending on the final variable'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.24 - 第一个useEffect()函数取决于最终变量'
- en: '](Images/Figure_11.24_B17074.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.24_B17074.jpg)'
- en: Figure 11.24 – The first useEffect() function depending on the final variable
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 - 第一个useEffect()函数取决于最终变量
- en: 'So, this is exactly like what we did previously. Here, we have a `setInterval()`
    function being called – this time, every 250ms – but only if the final variable
    has been initialized. By this, we mean if the user has pressed the **Start**/**Stop**
    button. There''s nothing weird going on down here, so I think we should be able
    to move on and check out the following `useEffect()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就像我们之前做的一样。在这里，我们调用了一个`setInterval()`函数 - 这一次是每250毫秒一次 - 但只有在最终变量被初始化的情况下才会调用。也就是说，如果用户按下了**开始**/**停止**按钮。这里没有什么奇怪的事情发生，所以我认为我们应该能够继续并查看下面的`useEffect()`函数：
- en: '![Figure 11.25 – The second useEffect() function depending on the timer variable'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.25 - 第二个useEffect()函数取决于计时器变量'
- en: '](Images/Figure_11.25_B17074.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.25_B17074.jpg)'
- en: Figure 11.25 – The second useEffect() function depending on the timer variable
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 - 第二个useEffect()函数取决于计时器变量
- en: Because we're setting the `timer` state variable in the first `useEffect()`
    function, it will act as a trigger for the second `useEffect()` function so that
    it's called. This is the function where we're doing all the math necessary for
    our timer to work. We're calculating the difference in seconds between the final
    date and the new date we've received from the `timer` variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在第一个useEffect()函数中设置了timer状态变量，它将作为第二个useEffect()函数的触发器，以便调用它。这是我们进行计时器所需的所有数学运算的函数。我们正在计算最终日期和从timer变量接收到的新日期之间的秒数差。
- en: After calculating the difference in seconds, the next step is to check if the
    `timeDisplay` variable is different than the newly calculated difference. If it's
    different, we'll set `timeDisplay` to this new value. We're doing this to make
    sure we're always calculating everything with a new value.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算出秒数差之后，下一步是检查timeDisplay变量是否与新计算出的差异不同。如果不同，我们将timeDisplay设置为这个新值。我们这样做是为了确保我们始终使用新值计算所有内容。
- en: After that, we just do the usual math for calculating the minutes and seconds.
    Next, we must set our `<TextInput />` components via the `countdownMinutes` and
    `countdownSeconds` variables to our newly calculated values. The reason we've
    used `toString()` here is because a `<TextInput />` component only accepts strings
    as values, so with this function, we're transforming the value from a number into
    a string.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需按照通常的数学方法计算分钟和秒数。接下来，我们必须通过countdownMinutes和countdownSeconds变量将我们的<TextInput
    />组件设置为新计算出的值。我们在这里使用toString()的原因是因为<TextInput />组件只接受字符串作为值，所以通过这个函数，我们将值从数字转换为字符串。
- en: 'Now, let''s check out the following `useEffect()` function, which depends on
    the `timeDisplay` state variable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看下一个依赖于timeDisplay状态变量的useEffect()函数：
- en: '![Figure 11.26 – The third useEffect() function depending on the timeDisplay
    variable'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.26 - 第三个useEffect()函数取决于timeDisplay变量'
- en: '](Images/Figure_11.26_B17074.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.26_B17074.jpg)'
- en: Figure 11.26 – The third useEffect() function depending on the timeDisplay variable
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 - 第三个useEffect()函数取决于timeDisplay变量
- en: This one will only work if `timeDisplay` is `0` or less. Once we hit `0`, we
    should stop and reset all the variables we've been using until now. This is where
    we're making sure our interval will be cleared, our `timeDisplay` variable goes
    back to `0`, and that the countdown variables go back to 0\. This should also
    be where we play our sound, so we must check if that sound has been loaded and
    then use the `playAsync()` function to start it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当timeDisplay为0或更少时，这个函数才起作用。一旦达到0，我们应该停止并重置到目前为止使用的所有变量。在这里，我们要确保我们的间隔将被清除，我们的timeDisplay变量回到0，并且倒计时变量回到0。这也应该是我们播放声音的地方，所以我们必须检查该声音是否已加载，然后使用playAsync()函数来启动它。
- en: 'Because we''ve been loading the sound when our timer application starts, we
    should also unload it when the screen unmounts. Practically speaking, there is
    no reason for us to keep a sound in the memory of our device if we''re not using
    it. We will do this by using a cleanup function inside another `useEffect()` function.
    Let''s check out what that looks like:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在计时器应用程序启动时加载了声音，所以在屏幕卸载时也应该卸载它。实际上，如果我们不使用声音，就没有理由将其保留在设备的内存中。我们将通过在另一个useEffect()函数中使用清理函数来实现这一点。让我们看看它是什么样子的：
- en: '![Figure 11.27 – The fourth useEffect() function being used only for the cleanup
    function'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.27 - 仅用于清理函数的第四个useEffect()函数'
- en: '](Images/Figure_11.27_B17074.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.27_B17074.jpg)'
- en: Figure 11.27 – The fourth useEffect() function being used only for the cleanup
    function
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27 - 仅用于清理函数的第四个useEffect()函数
- en: So, yet again, this is directly inspired by their documentation. Once the component
    unmounts, we must call this function, which checks if the sound has been loaded.
    If it has, then we must call the `unloadAsync()` function on our `sound` state
    variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次强调，这直接受到他们文档的启发。一旦组件卸载，我们必须调用这个函数，它会检查声音是否已加载。如果是，那么我们必须在我们的`sound`状态变量上调用`unloadAsync()`函数。
- en: 'Congratulations! We''re done with the Timer screen! Let''s check out how it
    looks and if it works:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经完成了计时器屏幕！让我们看看它的外观和它是否工作：
- en: '![Figure 11.28 – Completed Timer screen'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.28 - 完成的计时器屏幕'
- en: '](Images/Figure_11.28_B17074.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.28_B17074.jpg)'
- en: Figure 11.28 – Completed Timer screen
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28 - 完成的计时器屏幕
- en: It looks great! Here, we can change the title; we can also change the timer's
    values and that it works once we hit start. Upon waiting for 30 seconds, a cool
    little sound will play!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！在这里，我们可以更改标题；我们还可以更改计时器的值，并且在我们点击开始后它可以工作。等待30秒后，会播放一个很酷的小声音！
- en: With that, we're done with this app! Wait… not really – the Bottom Tab Navigator
    looks kind of empty, so we should add some icons. There are also some small things
    we can still do to enhance the user experience. Let's move on and start adding
    all these little enhancements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了这个应用程序！等等...其实不是 - 底部选项卡导航器看起来有点空，所以我们应该添加一些图标。我们还可以做一些小的事情来增强用户体验。让我们继续并开始添加所有这些小的增强。
- en: Finalizing our app
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的应用程序
- en: At this point, we need to add some icons to the Bottom Tab Navigator.. But how
    should we do this? Luckily for us, React Navigation has a pretty straightforward
    way of modifying its default components.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要向底部选项卡导航器添加一些图标。但我们应该如何做呢？幸运的是，React Navigation有一种非常直接的方式来修改其默认组件。
- en: And because we're already here, we should also change the focus color of whatever
    tab we're using at the moment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经在这里，我们还应该改变我们目前使用的选项卡的焦点颜色。
- en: 'So, let''s go back to our `routes.js` file. Because we want to add icons to
    our tabs, we should import the `Icon` component from `''galio-framework''`. After
    all the imports, we should write the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们回到我们的`routes.js`文件。因为我们想要向我们的选项卡添加图标，我们应该从`'galio-framework'`中导入`Icon`组件。在所有导入之后，我们应该写下以下内容：
- en: '[PRE11]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we''ve imported the component that we''ll use to display icons, let''s
    see how we should do that. Search your `AppTabs()` function and find the `<Tab.Navigator
    />` component. Here, we''ll add two new props called `screenOptions` and `tabBarOptions`.
    Let''s quickly check them out and see how exactly we''re using them to implement
    an icon inside our Bottom Tab Navigator:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了用于显示图标的组件，让我们看看应该如何做。搜索你的`AppTabs()`函数，并找到`<Tab.Navigator />`组件。在这里，我们将添加两个新的属性，称为`screenOptions`和`tabBarOptions`。让我们快速检查它们，并看看我们如何使用它们在底部选项卡导航器中实现图标：
- en: Important Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As of August 14, 2021, React Navigation has been updated to v6 and `tabBarOptions`
    was deprecated in favor of the `options` prop, which works on a per-screen basis.
    For more information regarding versioning and the React Navigation library, I'd
    suggest reading the documentation, which can be found at [https://reactnavigation.org/](https://reactnavigation.org/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2021年8月14日，React Navigation已更新到v6，并且`tabBarOptions`已被弃用，而是使用了`options`属性，它可以在每个屏幕上进行设置。关于版本和React
    Navigation库的更多信息，我建议阅读文档，可以在[https://reactnavigation.org/](https://reactnavigation.org/)找到。
- en: '![Figure 11.29 – Our fresh AppTabs() functional component with Icon implemented'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.29 - 我们的新AppTabs()功能组件已实现图标'
- en: '](Images/Figure_11.29_B17074.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.29_B17074.jpg)'
- en: Figure 11.29 – Our fresh AppTabs() functional component with Icon implemented
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29 - 我们的新AppTabs()功能组件已实现图标
- en: So, as we can see, the `screenOptions` prop works with a function that accepts
    the `navigation` and `route` props for each screen. Right now, we're using `route`
    as we want to check which screen is equal to each route. This way, we can have
    a case for every screen in our Bottom Tab Navigator. That function returns an
    object with a key called `tabBarIcon`, which has its value set to a function that's
    gathering a lot of information about the screen our user is currently focusing
    on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，`screenOptions`属性与一个函数一起使用，该函数接受每个屏幕的`navigation`和`route`属性。现在，我们正在使用`route`，因为我们想要检查哪个屏幕等于每个路由。这样，我们就可以为底部选项卡导航器中的每个屏幕设置一个情况。该函数返回一个带有名为`tabBarIcon`的键的对象，其值设置为一个正在收集有关用户当前关注的屏幕的大量信息的函数。
- en: This is where we check if the user is focused on a specific screen. Depending
    on that, we can render different types of icons. So, if the user is focusing on
    the Stopwatch screen, then we'll display a filled-in icon, while if they're not
    focusing, we'll only display the outline of that icon. This is a small detail
    that helps the user know when they're on the screen that they think they're on.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们检查用户是否关注特定屏幕的地方。根据这一点，我们可以呈现不同类型的图标。因此，如果用户关注秒表屏幕，那么我们将显示填充的图标，而如果他们没有关注，我们将只显示该图标的轮廓。这是一个小细节，可以帮助用户知道他们认为自己在的屏幕。
- en: 'Now, setting the colors for our icons is a lot easier. For this, we''ll use
    the `tabBarOptions` prop. We''ll pass it an object containing two keys: `activeTintColor`
    for when the user is currently focused on that specific screen and `inactiveTintColor`
    for when the user is *not* currently focused on that specific screen.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置我们图标的颜色就容易多了。为此，我们将使用`tabBarOptions`属性。我们将向其传递一个包含两个键的对象：`activeTintColor`用于当用户当前关注特定屏幕时，以及`inactiveTintColor`用于当用户*不*当前关注特定屏幕时。
- en: 'Let''s save this and check out our app! I think we can both agree that it looks
    10x better now:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存这个并检查我们的应用程序！我认为我们都可以同意现在看起来好了10倍：
- en: '![Figure 11.30 – Final app layout after adding icons to the Bottom Tab Navigator'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.30 – 在底部选项卡导航器中添加图标后的最终应用程序布局'
- en: '](Images/Figure_11.30_B17074.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.30_B17074.jpg)'
- en: Figure 11.30 – Final app layout after adding icons to the Bottom Tab Navigator
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30 – 在底部选项卡导航器中添加图标后的最终应用程序布局
- en: Don't close the `routes.js` file yet! We still have one more thing to do. As
    we discussed in [*Chapter 10*](B17074_10_epub_Final_SB.xhtml#_idTextAnchor128),
    *Building an Onboarding Screen*, the onboarding screen should only appear the
    first time you open the app. There is no reason to always see that onboarding
    screen. A lot of your users will be like, *OK, we get it, it's a Stopwatch app,
    just let me get to the Stopwatch part!*
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不要关闭`routes.js`文件！我们还有一件事要做。正如我们在[*第10章*](B17074_10_epub_Final_SB.xhtml#_idTextAnchor128)中讨论的那样，*构建入门屏幕*，入门屏幕应该只在您第一次打开应用程序时出现。没有理由总是看到那个入门屏幕。您的许多用户会说，“好的，我们知道了，这是一个秒表应用程序，让我直接进入秒表部分！”
- en: 'How can we do that, though? This is where `AsyncStorage` comes in handy! For
    us to be able to use this package, we need to install it. Let''s open our terminal
    again and write the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们该如何做到呢？这就是`AsyncStorage`派上用场的地方！为了能够使用这个包，我们需要安装它。让我们再次打开我们的终端并输入以下命令：
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we''ve installed this cool little package, let''s import it inside
    our `routes.js` file. Do that right after our `Icon` import, just like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们安装了这个很酷的小包，让我们在`routes.js`文件中导入它。在我们的`Icon`导入之后，就像这样：
- en: '[PRE13]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can use this `Icon` import inside our `AppStack()` function. Once you
    have found that function, we should create a state variable called `viewedOnboarding`.
    This variable will help us know if the user has already seen the onboarding screen
    or not.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的`AppStack()`函数中使用这个`Icon`导入。一旦找到了那个函数，我们应该创建一个名为`viewedOnboarding`的状态变量。这个变量将帮助我们知道用户是否已经看过引导屏幕。
- en: After defining that variable, we'd need to run a function right at the beginning
    of our mobile app. Do you remember the way we're supposed to that? That's right
    – another `useEffect()` function. I bet you're getting tired of these functions,
    but they're so great!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了那个变量之后，我们需要在我们的移动应用程序的开头立即运行一个函数。你还记得我们应该怎么做吗？没错 - 另一个`useEffect()`函数。我打赌你已经厌倦了这些函数，但它们真的很棒！
- en: 'This `useEffect()` function should call another function called `checkOnboarding()`,
    whose purpose is to check if the user has seen the onboarding screen or not. Depending
    on that, we''ll be setting our state variable, `viewedOnboarding`, to either `true`
    or `false`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`useEffect()`函数应该调用另一个名为`checkOnboarding()`的函数，其目的是检查用户是否已经看过引导屏幕。根据这一点，我们将设置我们的状态变量`viewedOnboarding`为`true`或`false`：
- en: '![Figure 11.31 – Logic written for our AppStack() function'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.31 - 为我们的AppStack()函数编写的逻辑'
- en: '](Images/Figure_11.31_B17074.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.31_B17074.jpg)'
- en: Figure 11.31 – Logic written for our AppStack() function
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31 - 为我们的AppStack()函数编写的逻辑
- en: Now, we need another `async` function. But we can only use this package with
    an `async` function. We'll try to see if the local storage has that item stored
    and if it does, then we'll set the `viewedOnboarding` state variable to `true`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要另一个`async`函数。但我们只能在`async`函数中使用这个包。我们将尝试看看本地存储是否存储了该项，如果是的话，我们将把`viewedOnboarding`状态变量设置为`true`。
- en: You might be wondering when exactly we will add that item to our local storage.
    Well, we should do that when our user presses **Next** for the last time inside
    the onboarding screen. So, let's move on to the `Onboarding.js` file and make
    that happen.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道我们什么时候会将该项添加到我们的本地存储中。嗯，当用户在引导屏幕内最后一次按下**下一步**时，我们应该这样做。所以，让我们继续前进到`Onboarding.js`文件并让它发生。
- en: 'Now that we''re in the `Onboarding.js` file, we should begin by importing the
    `AsyncStorage` package again. After this, we should jump straight to the `scrollTo()`
    function. First, we''ll make this function `async`. After that, we have an `if-else`
    statement. We''ll change the *else* part, where we''ve had a `console.log()` living
    for no real reason and have the `navigation.navigate()` function instead. Let''s
    see how we''ll change that:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`Onboarding.js`文件中，我们应该先再次导入`AsyncStorage`包。之后，我们应该直接跳转到`scrollTo()`函数。首先，我们会将这个函数改为`async`。之后，我们有一个`if-else`语句。我们将改变*else*部分，在那里我们有一个`console.log()`没有真正原因存在，并且使用`navigation.navigate()`函数代替。让我们看看我们将如何改变它：
- en: '![Figure 11.32 – Our modified scrollTo() function'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.32 - 我们修改后的scrollTo()函数'
- en: '](Images/Figure_11.32_B17074.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.32_B17074.jpg)'
- en: Figure 11.32 – Our modified scrollTo() function
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32 - 我们修改后的scrollTo()函数
- en: Here, again, we'll try using a try-catch. As you can see, we're using `setItem`
    to set that item to `true` in the local storage. This is how this library knows
    that this item has been set to true in the storage.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次尝试使用try-catch。正如你所看到的，我们正在使用`setItem`将该项设置为本地存储中的`true`。这就是这个库知道这个项目在存储中被设置为true的方式。
- en: 'Now, let''s go back to the `routes.js` file. We''re all set, but we need to
    make sure that we only display that route if our users have not seen the onboarding
    screen yet. We''ll do that with **conditional rendering**, which is a technique
    we''ve been using since the beginning of this chapter. Let''s see what that looks
    like:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`routes.js`文件。我们已经准备好了，但我们需要确保只有在我们的用户还没有看到入门屏幕时才显示该路由。我们将使用**条件渲染**来实现这一点，这是我们自本章开始以来一直在使用的技术。让我们看看它是什么样子的：
- en: '![Figure 11.33 – Conditional rendering applied to our <Stack.Screen /> onboarding
    component'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.33 – 条件渲染应用于我们的<Stack.Screen />入门组件'
- en: '](Images/Figure_11.33_B17074.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_11.33_B17074.jpg)'
- en: Figure 11.33 – Conditional rendering applied to our <Stack.Screen /> onboarding
    component
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33 – 条件渲染应用于我们的<Stack.Screen />入门组件
- en: As you can see, we're checking for our state variable, `viewedOnboarding`. If
    this has been set to `false`, that means our user has not seen the onboarding
    screen yet, so our route should be displayed. If this is set to `true`, that means
    we're not going to display any route, practically making the onboarding non-existent.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在检查我们的状态变量`viewedOnboarding`。如果这个变量被设置为`false`，那意味着我们的用户还没有看到入门屏幕，所以我们的路由应该显示出来。如果设置为`true`，那意味着我们不会显示任何路由，实际上使得入门变得不存在。
- en: And with that, we're done with this app! Save all your files, reload your JavaScript,
    and take a look at your app. At first, you'll see the onboarding screen. Tap next
    until it disappears and play around with the Stopwatch and Timer screens. After
    that, open the app again and you'll see something amazing – the onboarding screen
    is not displayed anymore! Instead, you'll be transported straight to the Stopwatch
    screen – more exactly, the Tab Navigator screen.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们完成了这个应用程序！保存所有文件，重新加载JavaScript，然后查看你的应用程序。一开始，你会看到入门屏幕。点击下一步直到它消失，然后在秒表和计时器屏幕上玩耍。之后，再次打开应用程序，你会看到一些惊人的事情
    – 入门屏幕不再显示了！相反，你将直接进入秒表屏幕 – 更确切地说，是选项卡导航屏幕。
- en: Congratulations! You now have a pretty cool and functional app at your disposal.
    Go ahead and brag about it to your friends and family; let them see how much you've
    progressed!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在拥有一个相当酷和功能齐全的应用程序。向你的朋友和家人炫耀吧；让他们看看你取得了多大的进步！
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been a long journey for both of us. Fear not! The greater the
    challenge, the better the reward. You have reached the end of a pretty long and
    interesting journey. You now have a fully functional app that you can show to
    your friends. These are the first stepping stones of your journey toward becoming
    a great React Native developer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章对我们两个人来说是一段漫长的旅程。不要害怕！挑战越大，回报就越好。你已经完成了一段相当漫长而有趣的旅程。现在你有一个完全功能的应用程序，可以向朋友展示。这些是你成为一名优秀的React
    Native开发人员的第一步。
- en: We've started this chapter by looking at React Navigation. Creating routes and
    linking them to the onboarding screen was one of the coolest things we've ever
    done. This was also incredibly easy, which proves once again how great the React
    Native community is.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从React Navigation开始了这一章。创建路由并将它们链接到入门屏幕是我们做过的最酷的事情之一。这也非常容易，再次证明了React Native社区是多么伟大。
- en: After linking our app to the React Navigation library, we started working on
    the Stopwatch screen. We learned that the `setInterval()` function is not that
    accurate, due to which we started working with date objects, which proved to be
    a lot more efficient for keeping time.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序链接到React Navigation库后，我们开始着手处理秒表屏幕。我们发现`setInterval()`函数并不那么准确，因此我们开始使用日期对象，这对于计时来说更加高效。
- en: Finishing the Stopwatch screen felt like a big win, so because of that, creating
    our Timer screen went a lot smoother. But yet again, we learned something new
    and that was how to play a sound after the timer finished running. I hope doing
    this opened a lot of doors of creativity for you.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 完成秒表屏幕感觉像是一次重大胜利，因此，创建我们的计时器屏幕进展顺利得多。但是，我们又学到了新的东西，那就是在计时器完成运行后如何播放声音。我希望做这件事为你打开了许多创造力的大门。
- en: At the end of this chapter, we focused on the user experience and made sure
    that the user will see some icons whenever they're looking at the Bottom Tab Navigator.
    On top of that, we worked with a library called `AsyncStorage` so that we could
    keep the onboarding screen away from an already experienced user.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们专注于用户体验，并确保用户在查看底部选项卡导航器时会看到一些图标。除此之外，我们还使用了一个叫做`AsyncStorage`的库，这样我们就可以让已经有经验的用户远离入门屏幕。
- en: Learning so many things was a breath of fresh air. Yes, this was a lot of information,
    but I hope you realize how important it is to tackle as many challenges as possible.
    Just like in real life, they help us build experience, which helps us become great
    programmers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这么多东西真是令人耳目一新。是的，这是很多信息，但我希望你意识到尽可能应对多种挑战有多么重要。就像在现实生活中一样，它们帮助我们积累经验，这有助于我们成为优秀的程序员。
- en: Now, let's get ready for the next chapter, where we're going to discuss what
    other paths you can take as a React Native developer to become a great programmer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为下一章做好准备，我们将讨论作为React Native开发人员可以选择的其他路径，以成为一名优秀的程序员。
