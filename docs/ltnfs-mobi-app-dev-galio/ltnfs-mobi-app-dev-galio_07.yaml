- en: '*Chapter 7*: Exploring the State of Our App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：探索我们应用程序的状态'
- en: After going through so many different ideas about how to build an app, it's
    time to get to set one of the final stones for our house's foundation. In this
    chapter, we'll understand what state is, and most importantly, how state works
    inside a React application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了关于如何构建应用的许多不同想法之后，是时候为我们房屋的基础设置最后的石头之一了。在本章中，我们将了解状态是什么，更重要的是，状态在React应用程序中是如何工作的。
- en: We'll go through a basic definition of what exactly state is and how it was
    traditionally used in React applications. We'll also learn about some new modern
    ways of using state and how exactly they work. We'll have to decide on our own
    which one is the best fit to be used in our specific case, but of course, I'm
    going to give you my recommendations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对状态的基本定义进行讨论，以及它在React应用程序中的传统用法。我们还将了解一些新的现代状态使用方式以及它们的工作原理。我们将不得不自己决定哪种状态最适合在我们的特定情况下使用，但当然，我会给出我的建议。
- en: We'll then apply all our new information to a practical exercise, which is going
    to help us reinforce these new concepts in our brain so we can properly understand
    everything we cover.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把所有新的信息应用到一个实际的练习中，这将帮助我们巩固我们的大脑中的这些新概念，以便我们能够正确理解我们所涵盖的一切。
- en: After the practical exercise, it'll be time to look at some different hooks
    and what exactly they are. We'll learn about the differences about using state
    in a class component and how hooks can help us write less code. We'll also learn
    about another hook, which deals with lifecycle functions. All this will help us
    move forward with our studying and is imperative for us to know before creating
    more complex applications with React Native and Galio.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际练习之后，将是时候看一些不同的钩子以及它们究竟是什么。我们将了解在类组件中使用状态与使用钩子如何帮助我们编写更少的代码之间的区别。我们还将了解另一个处理生命周期函数的钩子。所有这些将帮助我们在React
    Native和Galio中创建更复杂的应用程序之前继续学习，并且在创建更复杂的应用程序之前，这对我们来说是必不可少的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is state?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是状态？
- en: Leveling up our screens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级我们的屏幕
- en: Other hooks and why they're relevant
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他钩子及其相关性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 07`, which contains all the code we've written
    for this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问GitHub [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)
    来查看本章的代码。您会发现一个名为`Chapter 07`的文件夹，其中包含我们为本章编写的所有代码。为了使用该项目，请按照`README.md`文件中的说明进行操作。
- en: What is state?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是状态？
- en: Now that we've got to this point, it's imperative for us moving forward to understand
    what state is and how it works inside a React component. Once we learn this, we'll
    be fully capable of using React to the best of our abilities. This unlocks the
    missing link we've had until now, more exactly, it will unlock the key to making
    our mobile apps more dynamic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了这一步，对于我们继续前进来说，了解状态是什么以及它在React组件中是如何工作的是至关重要的。一旦我们学会了这一点，我们将完全能够充分利用React的能力。这将解开我们迄今为止一直缺少的环节，更确切地说，它将解开使我们的移动应用程序更加动态的关键。
- en: We learned about *props* in [*Chapter 3*](B17074_03_epub_Final_SB.xhtml#_idTextAnchor063),
    *The Correct Mindset*. It's the technique we use to pass data from one component
    to another. Think of props as the first level of a component. We need to level
    up our component creation skills so the most logical step now before going into
    any practical challenges is to learn about state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第3章*](B17074_03_epub_Final_SB.xhtml#_idTextAnchor063)中学习了*props*。这是我们用来从一个组件传递数据到另一个组件的技术。将props视为组件的第一层。我们需要提升我们的组件创建技能，所以在进入任何实际挑战之前，现在最合乎逻辑的步骤是学习关于状态的知识。
- en: Traditionally, in order to be able to use state inside our components, we had
    to use *class components*. Later versions of React, we got introduced to being
    able to use state even in functional components with something called *hooks*.
    We'll discuss hooks more right after we learn the basics of state, and for that,
    we have to start with class components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，为了能够在组件中使用状态，我们必须使用*类组件*。在React的后续版本中，我们还可以使用一种叫做*hooks*的东西，在函数组件中使用状态。在学习状态的基础知识之后，我们将讨论hooks，而为此，我们必须从类组件开始。
- en: What is a class, though? A class is a template for creating an object. Objects
    are usually used in **OOP** – **Object-Oriented Programming**. Although JavaScript
    is not a class-based object-oriented language, it still has ways of using OOP.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么是类呢？类是创建对象的模板。对象通常用于面向对象编程。尽管JavaScript不是基于类的面向对象语言，但它仍然有使用面向对象编程的方式。
- en: 'Let''s look at how a class is created in JavaScript and what exactly it requires
    to function properly inside a React/React Native project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在JavaScript中如何创建一个类，以及在React/React Native项目中它需要什么才能正常运行：
- en: '![Figure 7.1 – Code for a class component in React'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - React中类组件的代码'
- en: '](Images/Figure_7.1_B17074.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.1_B17074.jpg)'
- en: Figure 7.1 – Code for a class component in React
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - React中类组件的代码
- en: This is really similar to a function but it does not have any *parameters* and
    also, we can see that `extends` word there. The keyword `extends` is basically
    used to let the class know it should *inherit* properties from another class;
    in this case, the other class is `React.Component`. All classes need to inherit
    from `React.Component` so the class can get used as a React component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这与函数非常相似，但它没有任何*参数*，而且我们可以看到那里的`extends`单词。关键字`extends`基本上是用来让类知道它应该从另一个类继承属性；在这种情况下，另一个类是`React.Component`。所有类都需要从`React.Component`继承，以便该类可以作为React组件使用。
- en: We also see the `render()` function. This function is required by a React component.
    It's the place where we write all our JSX. Now, there's another function we're
    supposed to use. It's the function that gets called when a new object is created
    using the class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了`render()`函数。这个函数是React组件所必需的。这是我们编写所有JSX的地方。现在，还有另一个函数我们应该使用。这是在使用类创建新对象时调用的函数。
- en: 'Now that we''ve been through how to create a class, it''s time to finally go
    into state. Let''s see how we can add *state* to our `App` class component. For
    that, we need to create another function inside our `App` class called `constructor()`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建一个类，是时候进入状态了。让我们看看如何将*状态*添加到我们的`App`类组件中。为此，我们需要在`App`类中创建另一个名为`constructor()`的函数：
- en: '![Figure 7.2 – The constructor function added to our class'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 添加到我们类中的构造函数'
- en: '](Images/Figure_7.2_B17074.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.2_B17074.jpg)'
- en: Figure 7.2 – The constructor function added to our class
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 添加到我们类中的构造函数
- en: Important note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In class-based OOP, a constructor is a special type of function that is called
    whenever we're creating an object. It often accepts arguments to custom-initialize
    a new object in any way we want to.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于类的面向对象编程中，构造函数是一种特殊类型的函数，每当我们创建一个对象时就会被调用。它通常接受参数，以便以任何我们想要的方式自定义初始化一个新对象。
- en: As you can see, this function accepts one argument, `props`, which enables us
    to use the props this component might receive. The `super()` function inside the
    constructor is a keyword used to access and call functions on an object's parent.
    This function must be used before the `this` keyword is used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数接受一个参数`props`，这使我们能够使用这个组件可能接收的props。构造函数中的`super()`函数是一个关键字，用于访问并调用对象父级的函数。这个函数必须在使用`this`关键字之前使用。
- en: As we can see, our state variable has a `this` keyword in front of it. This
    keyword refers to the object it belongs to. It basically refers to the fact that
    the `state` variable is linked to *this* object only so you can't really access
    it directly from another object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的状态变量前面有一个`this`关键字。这个关键字指的是它所属的对象。它基本上指的是`状态`变量只与*这个*对象相关联，所以你不能直接从另一个对象访问它。
- en: 'Now let''s see how we can use it inside our `render` function. This is the
    exact same way we''d use `props`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何在`render`函数中使用它。这与我们使用`props`的方式完全相同：
- en: '![Figure 7.3 – State used in the render function'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - 在渲染函数中使用的状态'
- en: '](Images/Figure_7.3_B17074.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.3_B17074.jpg)'
- en: Figure 7.3 – State used in the render function
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 在渲染函数中使用的状态
- en: As we can see, we still use the `this` keyword in order to make sure that the
    `state` variable refers to this specific object when it is rendered. Now the message
    that should appear onscreen is **Hi everybody! I'm 24 years old!**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们仍然使用`this`关键字，以确保`状态`变量在渲染时指的是这个特定的对象。现在应该在屏幕上显示的消息是**大家好！我今年24岁了！**。
- en: This is really similar to the `props` we've been using, but what exactly is
    different?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们一直在使用的`props`非常相似，但到底有什么不同呢？
- en: The actual difference is that `state` is local while `props` is something we
    transfer from one component to another. Another difference is that because `state`
    is a local variable, we can change it inside our component and the only thing
    that has to render is that specific component. The thing with `props` is that
    once we update a prop, all the children that are using that prop need to be re-rendered
    and that puts some **stress** on our app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的区别在于`状态`是局部的，而`props`是我们从一个组件传递到另一个组件的东西。另一个区别是，因为`状态`是一个局部变量，我们可以在组件内部改变它，唯一需要重新渲染的是特定的组件。而`props`的情况是，一旦我们更新了一个prop，使用该prop的所有子组件都需要重新渲染，这会给我们的应用程序带来一些压力。
- en: What is state?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是状态？
- en: In computer science, a system is called stateful as long as it is designed to
    remember previous information. The remembered information is called the state
    of the system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，只要系统被设计为记住先前的信息，就被称为有状态的系统。被记住的信息被称为系统的状态。
- en: This is **not** to say that `state` is better than `props`. They all have their
    purpose and you'll use all of these concepts when building an app. Sometimes,
    you need state and we'll look at some examples using both so we can better understand
    how exactly they work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说`状态`比`props`更好。它们都有各自的目的，当构建应用程序时，你会使用所有这些概念。有时，你需要状态，我们将看一些使用两者的例子，这样我们就可以更好地理解它们的工作原理。
- en: 'So how do we change this variable? Some of you might naturally think "Hey,
    this is easy – just change the variable as you''d normally do" and you''re going
    to try something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何改变这个变量呢？你们中的一些人可能自然地会想到“嘿，这很容易 - 就像平常一样改变变量”，然后你会尝试像这样做一些事情：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But this won't really work. You could try doing it inside your component but
    you won't see any differences. The state will remain `24` on your screen and the
    component will not re-render. React state should be treated as immutable. In the
    programming world, an immutable object is an object that cannot be modified after
    it has been created.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不会真正起作用。你可以尝试在组件内部进行操作，但你不会看到任何变化。状态将保持在你的屏幕上为`24`，组件不会重新渲染。React状态应该被视为不可变的。在编程世界中，不可变对象是指在创建后无法修改的对象。
- en: We actually have a React function implemented for us called `setState()`. This
    helps us replace the state with another state so we don't really modify the main
    variable; we actually replace the variable with another variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们有一个React函数为我们实现了`setState()`。这有助于我们用另一个状态替换状态，因此我们实际上并没有修改主变量；我们实际上是用另一个变量替换了变量。
- en: 'So, if we wanted to change the age, we would need to write something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要改变年龄，我们需要写类似这样的东西：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, this seems fairly easy, but where exactly do we change the state? Well,
    there are lots of places where we can change the state but that depends on your
    app and how exactly you want it to work. Let's say we want to change the age right
    when the component is getting rendered on the screen. React gives us certain functions
    for our class component called *lifecycle functions*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这似乎相当容易，但我们到底在哪里改变状态呢？嗯，有很多地方可以改变状态，但这取决于你的应用程序以及你希望它如何工作。假设我们想在组件在屏幕上渲染时立即改变年龄。React为我们的类组件提供了一些称为*生命周期函数*的特定函数。
- en: 'These functions are called at specific moments in a component''s life. We''ll
    discuss two of them: `componentDidMount()` and `componentWillUnmount()`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在组件生命周期的特定时刻被调用。我们将讨论其中的两个：`componentDidMount()`和`componentWillUnmount()`。
- en: These represent exactly what the names suggest. The first one gets called once
    our component has already mounted (rendered) to the screen. The second one is
    called once the component has to be removed from the screen. So, we have these
    moments in a component's life where we can insert code to make sure the components
    behave as we expect them to behave.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数确切地代表了它们的名字所暗示的。第一个函数在我们的组件已经挂载（渲染）到屏幕上后被调用。第二个函数在组件需要从屏幕上移除时被调用。因此，我们在组件生命周期中有这些时刻，我们可以插入代码来确保组件的行为符合我们的期望。
- en: 'Obviously, if we wanted to change the age once the component gets rendered,
    we''d have to use the `componentDidMount()` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想要在组件渲染后改变年龄，我们必须使用`componentDidMount()`函数：
- en: '![Figure 7.4 – Using componentDidMount inside our class component'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 - 在我们的类组件中使用componentDidMount'
- en: '](Images/Figure_7.4_B17074.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.4_B17074.jpg)'
- en: Figure 7.4 – Using componentDidMount inside our class component
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 在我们的类组件中使用componentDidMount
- en: 'Now when we open up our app, we''ll see **Hi everybody! I''m 54 years old!**.
    But the state actually was `24` at the start of rendering, and once it rendered,
    the state changed to `54`. So, this is really cool, we have so many different
    new functions and properties. I''d totally recommend you read more about how a
    class works inside JavaScript if there''s anything you feel you don''t really
    understand. You can do that by visiting Mozilla''s website, which is full of interesting
    information about JavaScript: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
    Just so you know, a lot of people have problems or feel confused about how the
    `this` keyword works and how exactly state works. I feel like this confusion always
    clears once you learn a lot more about how JavaScript actually works.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们打开应用程序时，我们会看到**大家好！我今年54岁！**。但实际上状态在渲染开始时是`24`，一旦渲染完成，状态就变成了`54`。所以，这真的很酷，我们有很多不同的新功能和属性。我完全建议你阅读更多关于JavaScript类如何工作的信息，如果有任何你觉得不太理解的地方。你可以通过访问Mozilla的网站来做到这一点，那里充满了有关JavaScript的有趣信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)。只是让你知道，很多人在`this`关键字的工作方式以及状态的确切工作方式上遇到问题或感到困惑。我觉得一旦你更多地了解JavaScript的工作原理，这种困惑就会消失。
- en: Now let's use what we've learned so far and apply it to a cool little practical
    exercise. We'll now begin using state in order to make our screens look more dynamic
    instead of just our usual static screens.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运用到目前为止学到的知识，进行一个有趣的小实践。我们将开始使用状态，使我们的屏幕看起来更加动态，而不仅仅是我们通常的静态屏幕。
- en: Leveling up our screens
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级我们的屏幕
- en: 'Let''s see what kind of app we''re going to create. I was thinking we could
    have a screen where it shows our current age down to months, days, hours, and
    minutes. I mean, that''s pretty cool, right? Whenever someone asks you your age,
    you''ll be able to just take your phone out of your pocket and show them the screen
    you''ve created. Let''s get started:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们要创建什么样的应用程序。我在想我们可以有一个屏幕，显示我们当前的年龄，包括月份、天数、小时和分钟。我是说，那挺酷的，对吧？每当有人问起你的年龄，你就可以从口袋里拿出手机，展示你创建的屏幕。让我们开始吧：
- en: 'Let''s open up our terminal and create a new `expo` managed project just like
    we always do, using the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开终端，并像往常一样使用以下命令创建一个新的`expo`托管项目：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let's open up our project and start writing some code!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开项目并开始编写一些代码！
- en: Let's go straight to the `App.js` file and delete everything in there besides
    the imports and StyleSheet. I always leave the StyleSheet because I'm a fan of
    centered text.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们直接打开`App.js`文件，除了导入和样式表之外，删除里面的所有内容。我总是保留样式表，因为我喜欢居中的文本。
- en: Now let's rewrite the `App` component as a `class` component.![Figure 7.5 –
    App.js rewritten as a class component
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`App`组件重写为`class`组件。![图7.5 - App.js重写为类组件
- en: '](Images/Figure_7.5_B17074.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.5_B17074.jpg)'
- en: Figure 7.5 – App.js rewritten as a class component
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - App.js重写为类组件
- en: 'Now let''s open up our Expo app by using the following command inside our terminal:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过终端内使用以下命令打开我们的Expo应用程序：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I always use this command as it clears out the cache. So, this way, I make sure
    the cache will never interfere with my changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是使用这个命令来清除缓存。这样，我就确保缓存不会干扰我的更改。
- en: Now that the Expo server is open, just as we learned, open up the simulator
    of your choice. You should be able to see the text `My real age is:` on the screen
    once your app opens up.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在Expo服务器已经打开，就像我们学到的那样，打开你选择的模拟器。一旦你的应用程序打开，你应该能在屏幕上看到`我的真实年龄是：`的文字。
- en: Now let's integrate our age as a state inside the `App` class component.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将我们的年龄作为`App`类组件内的状态集成进去。
- en: 'Just as we''ve seen before, we need to write our `constructor()` function above
    everything else inside our class component. *Don''t forget* about the `super(props)`
    line – that one''s important! We''ll then create our state inside our `constructor`
    function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的那样，我们需要在类组件的所有其他内容之上编写我们的`constructor()`函数。*不要忘记*关于`super(props)`这一行
    - 这很重要！然后我们将在`constructor`函数中创建我们的状态：
- en: '![Figure 7.6 – constructor function with our newly created state'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - 带有我们新创建的状态的构造函数'
- en: '](Images/Figure_7.6_B17074.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.6_B17074.jpg)'
- en: Figure 7.6 – constructor function with our newly created state
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 带有我们新创建的状态的构造函数
- en: I've already mentioned we're going to display our age in terms of years, months,
    and days, all the way to seconds, so I've put an object filled with zeros in there
    just as a placeholder. It could've really been anything in there as we're going
    to change it after some quick math.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到我们将以年、月和日的形式显示我们的年龄，一直到秒，所以我在那里放了一个填满零的对象作为占位符。它实际上可以是任何东西，因为我们将在一些快速的数学运算之后更改它。
- en: Now let's dive right into how we're going to calculate the age. For this little
    trick, we're going to use the `Date()` object inside JavaScript. Even though this
    object might seem a little bit confusing for some people, after you learn more
    about time zones, it really becomes just another object to play with. Don't sweat
    it, we're not going to go that deep into dates with JavaScript as we have better
    stuff to learn about.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们直接进入如何计算年龄的方法。为了这个小技巧，我们将使用JavaScript中的`Date()`对象。尽管这个对象对一些人来说可能有点令人困惑，但在你了解更多关于时区的知识之后，它真的只是另一个可以玩耍的对象。别担心，我们不会深入研究JavaScript中的日期，因为我们有更好的东西要学习。
- en: So, we're going to create a new function called `getAge()`, which is going to
    receive your birthday date. This function will take the current time and will
    subtract from it the date of your birth. All of this will be done in milliseconds.
    After that, we're going to take the result and create a new `Date` object with
    it. From that new object, we're going to extract all the information about how
    old we are.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个名为`getAge()`的新函数，它将接收您的生日日期。这个函数将获取当前时间，并从中减去您的出生日期。所有这些都将以毫秒为单位完成。之后，我们将取得的结果创建一个新的`Date`对象。从这个新对象中，我们将提取关于我们年龄的所有信息。
- en: 'At the end of it, we''re going to use `setState` to create a new state with
    all the information we''ve calculated from our `Date` objects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`setState`来创建一个新的状态，其中包含我们从`Date`对象中计算出的所有信息：
- en: '![Figure 7.7 – Our function to calculate our current age'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 我们计算当前年龄的函数'
- en: '](Images/Figure_7.7_B17074.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.7_B17074.jpg)'
- en: Figure 7.7 – Our function to calculate our current age
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 我们计算当前年龄的函数
- en: Now, you're probably wondering why we subtracted `1970` for years and `1` for
    days. Oh well, as I was saying, the `Date` object is a little bit weird. We had
    to subtract `1970` because UTC time starts at 1970, so in order to be sure we're
    getting our correct year value, that had to disappear from our equation. As for
    the value for days, this might have something to do with the fact that I really
    wanted to make sure that time zones would be taken into consideration and my time
    zone needed that `-1`. The thing is, even if we get 1 day off, the important thing
    is to see this thing really work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道为什么我们要减去`1970`年和`1`天。噢，正如我所说的，`Date`对象有点奇怪。我们必须减去`1970`，因为UTC时间从1970年开始，所以为了确保我们得到正确的年份值，它必须从我们的方程中消失。至于天数的值，这可能与我真的想确保时区被考虑进去有关，我的时区需要那个`-1`。事实上，即使我们少了1天，重要的是要看到这个东西真的起作用。
- en: Now that we have the function, and we're using the `setState` function to correctly
    change the state, it's time to call this function from somewhere. As you know,
    a normal function won't just call itself (even though there are functions out
    there that can do that).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个函数，并且我们正在使用`setState`函数来正确地改变状态，是时候从某个地方调用这个函数了。正如你所知，一个普通的函数不会自己调用（尽管有一些函数可以做到这一点）。
- en: 'So, let''s do the same thing we did before – let''s call our function in `componentDidMount()`
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们做和之前一样的事情 - 让我们在`componentDidMount()`中调用我们的函数，就像这样：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, I've used the keyword `this` to make sure our object knows we're
    referring to its function `getAge`. I've also used my own birthday inside the
    function but you may use your own birthday to make this even more personal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我使用了关键字`this`来确保我们的对象知道我们正在引用它的函数`getAge`。我还在函数内使用了我的生日，但你可以使用你自己的生日来使这更加个人化。
- en: 'Our job is not done! Let''s get to our `render` function and make some modifications
    so we can display everything properly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作还没有完成！让我们进入我们的`render`函数并进行一些修改，以便我们可以正确显示一切：
- en: '![Figure 7.8 – Our render function after we''ve implemented our state'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - 在我们实现状态后的渲染函数'
- en: '](Images/Figure_7.8_B17074.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.8_B17074.jpg)'
- en: Figure 7.8 – Our render function after we've implemented our state
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 在我们实现状态后的渲染函数
- en: The first line inside our `render` function might seem a little bit weird to
    some of you. It's called **object destructuring**. This is what we've already
    been doing with our imports. This is a really useful JavaScript feature used to
    extract properties from objects and even bind them to variables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`render`函数内的第一行可能对你们中的一些人来说有点奇怪。这被称为**对象解构**。这就是我们之前在导入中已经做过的事情。这是一个非常有用的JavaScript特性，用于从对象中提取属性，甚至将它们绑定到变量上。
- en: For example, we're now able to just say `years` whenever we're referring to
    `this.state.age.years`. It saves us writing time and it also looks a lot clearer.
    You'll see people destructuring variables like this all the time – it's a really
    cool feature!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在我们可以在引用`this.state.age.years`时只说`years`。这节省了我们的写作时间，而且看起来也清晰得多。你会经常看到人们像这样解构变量
    - 这是一个非常酷的特性！
- en: Now that we've made sure that we're going to use all the variables inside our
    `state`, our `componentDidMount` is calling our `getAge` function and the `state`
    is set inside that function, everything is ready. Run your app and check out the
    result. You should be able to look at the screen and see how old you really are,
    down to the smallest detail.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确保我们将使用`state`内的所有变量，我们的`componentDidMount`正在调用我们的`getAge`函数，并且`state`是在那个函数内设置的，一切准备就绪。运行你的应用程序并检查结果。你应该能够看到屏幕上显示出你真正的年龄，甚至可以看到最细微的细节。
- en: But there's something wrong – the seconds don't refresh, so everything stays
    the same. You're probably thinking that I could've lied to you, but trust me I
    didn't. Right now, your real age is not updating because our `getAge` function
    is only getting called once. As we said, `componentDidMount` calls the function
    when the component first renders on the screen. Our component rendered, the function
    got called, and that's the end of the story.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一些问题 - 秒数不会刷新，所以一切都保持不变。你可能会认为我可能欺骗了你，但相信我，我没有。现在，你的真实年龄没有更新，因为我们的`getAge`函数只被调用了一次。正如我们所说，`componentDidMount`在组件首次渲染在屏幕上时调用该函数。我们的组件渲染了，函数被调用了，故事就此结束。
- en: We somehow have got to make that function call multiple times; I'm thinking
    at least once a second so we make sure our seconds are in sync with the real time.
    Let's do that now!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知何故必须让那个函数多次调用；我认为至少每秒一次，这样我们才能确保我们的秒数与真实时间同步。现在让我们来做吧！
- en: 'Inside our `componentDidMount` function, we''ll call a cool little function
    called `setInterval()`. The first parameter it accepts is a function. This will
    be called at an interval of time. The second parameter it accepts is actually
    the time in milliseconds for how often to execute the function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`componentDidMount`函数内部，我们将调用一个很酷的函数叫做`setInterval()`。它接受的第一个参数是一个函数。这个函数将会以一定的时间间隔被调用。它接受的第二个参数实际上是以毫秒为单位的时间，用于执行这个函数的频率。
- en: '![Figure 7.9 – componentDidMount with our setInterval function'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 - 使用我们的setInterval函数的componentDidMount'
- en: '](Images/Figure_7.9_B17074.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.9_B17074.jpg)'
- en: Figure 7.9 – componentDidMount with our setInterval function
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 使用我们的setInterval函数的componentDidMount
- en: Now we've created this interval at which our `getAge()` function is called.
    It's a good practice to stop the interval when we don't really need it to work
    anymore. The question popping right now in your mind is probably "When don't we
    need it run?". Well… That's usually subjective but in our specific case, the answer
    is at the end of our component's life.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了这个间隔，`getAge()`函数被调用。当我们不再需要它工作时，停止间隔是一个很好的做法。你脑海中现在可能会冒出一个问题：“什么时候我们不需要它运行呢？”嗯...这通常是主观的，但在我们的特定情况下，答案是在组件的生命周期结束时。
- en: 'Remember we said there''s another lifecycle function called `componentWillUnmount()`?
    Well, that''s exactly where we''re going to stop this function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们说过还有另一个叫做`componentWillUnmount()`的生命周期函数吗？好吧，这正是我们要结束这个函数的地方：
- en: '![Figure 7.10 – The componentWillUnmount function used in our class component'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 - 在我们的class组件中使用的componentWillUnmount函数'
- en: '](Images/Figure_7.10_B17074.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.10_B17074.jpg)'
- en: Figure 7.10 – The componentWillUnmount function used in our class component
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 - 在我们的class组件中使用的componentWillUnmount函数
- en: Now that we've done this, our app should be ready to display our current age
    correctly. Save everything, refresh the simulator, and check it out! Your real
    age is now displaying right on the screen. Don't let those numbers ruin the day
    for you though – we're all as young as we feel!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做到了这一点，我们的应用应该准备好正确显示我们当前的年龄了。保存一切，刷新模拟器，然后检查一下！你的真实年龄现在正确地显示在屏幕上。不过，不要让这些数字毁了你的一天
    - 我们都只有自己感觉年轻！
- en: Now that we've seen how state behaves in a `class` component, which is a bit
    more of a traditional use of state, it's time to see other ways of using state.
    In the recent past, React blessed us with some cool little things called **hooks**.
    Let's learn more about them, how exactly they differ from our traditional state,
    and what new features they bring to the table.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了状态在`class`组件中的行为，这在某种程度上是状态的传统用法，是时候看看其他使用状态的方式了。在最近，React给我们带来了一些很酷的小东西，叫做**hooks**。让我们更多地了解它们，它们与传统状态有什么不同，以及它们为我们带来了什么新功能。
- en: Other hooks and why they're relevant
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他hooks及其相关性
- en: The main problem with state is the fact that the only way we can use it is in
    a `class` component. Class components are generally seen as a bit ugly and hard
    to learn for some beginners, so the React team tried creating something new that
    promised to solve the problems beginners and advanced users could have gotten
    into while using a class component with the traditional use of state. This is
    how **hooks** were born.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的主要问题在于我们只能在`class`组件中使用它。对于一些初学者来说，类组件通常被认为有点丑陋且难以学习，因此React团队尝试创建一些新的东西，承诺解决初学者和高级用户在使用传统状态的类组件时可能遇到的问题。这就是**hooks**诞生的原因。
- en: Hooks were introduced in React v16.8 and React Native v0.59\. They basically
    let you use state and other React features without writing a class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks是在React v16.8和React Native v0.59中引入的。它们基本上让你在不编写类的情况下使用状态和其他React特性。
- en: 'So, what exactly does that mean for us? Let''s look at an example of how state
    is written with our new hooks feature:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对我们究竟意味着什么？让我们看一个示例，看看我们如何使用新的钩子功能编写状态：
- en: '![Figure 7.11 – Example of using hooks'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 - 使用钩子的示例'
- en: '](Images/Figure_7.11_B17074.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.11_B17074.jpg)'
- en: Figure 7.11 – Example of using hooks
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 - 使用钩子的示例
- en: Woah! So, what do we have here? Is this really the same state feature we've
    been using so far? Yes, it is. If you were to copy this code into a fresh new
    project, you'd see that once you started up your app, every time you pressed that
    button, the number would keep updating from 0 to however many times you pressed
    it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是什么？这真的是我们迄今为止一直在使用的相同状态特性吗？是的，是的。如果你将这段代码复制到一个全新的项目中，你会发现一旦启动你的应用程序，每次你按下那个按钮，数字都会从0更新到你按下它的次数。
- en: Let's see what exactly we wrote here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们到底写了什么。
- en: As you can see, we've created a function called `Example`. The name doesn't
    really matter as long as it's not your main function, which should always be called
    `App`. A function looks much cleaner than a class and it's obviously a lot easier
    to write.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们创建了一个名为`Example`的函数。只要不是你的主要函数，名字并不重要，主要函数应该总是叫做`App`。函数看起来比类清晰得多，显然更容易编写。
- en: Then we've defined two variables inside our function using the hook `useState()`.
    How exactly does that work?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`useState()`钩子在我们的函数中定义了两个变量。这到底是如何工作的呢？
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, `useState` is a hook. We call this method inside a function
    component in order to add local state to our component. This function returns
    a pair: the *current* state value – `count`, and a function that lets you update
    that value - `setCount`. The `setCount` function is pretty similar to the `this.setState`
    function in a class, except it doesn''t merge the old and new state together.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`useState`是一个钩子。我们在函数组件中调用这个方法，以便为我们的组件添加本地状态。这个函数返回一对值：*当前*状态值 - `count`，以及一个可以更新该值的函数
    - `setCount`。`setCount`函数与类中的`this.setState`函数非常相似，只是它不会合并旧状态和新状态。
- en: The only argument `useState` accepts is the initial state given to our `count`
    variable. Remember that our `this.state` variable had to be an object and everything
    was inside that object. `count` doesn't have to be an object even though it could
    be if you want it to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`接受的唯一参数是赋给我们的`count`变量的初始状态。请记住，我们的`this.state`变量必须是一个对象，而且一切都在那个对象里。`count`不必是一个对象，尽管如果你愿意的话它也可以是。'
- en: Now let's see a straight comparison between using `this.state` and the `useState`
    hook. We'll see the same state written with both of these features so we can have
    a clear way of comparing the two.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们直接比较使用`this.state`和`useState`钩子。我们将看到相同的状态使用这两个特性写成，这样我们就可以清楚地比较这两者。
- en: 'First, we''ll take a look at `this.state`. We''ll imagine having an app that
    needs to have some information regarding a user, some comments that their friends
    have left on the user''s profile, but also the number of likes this profile has:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下`this.state`。我们想象一下有一个应用程序，需要一些关于用户的信息，一些朋友在用户个人资料上留下的评论，还有这个个人资料有多少个赞：
- en: '![Figure 7.12 – State object as written in a class component'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 - 在类组件中编写的状态对象'
- en: '](Images/Figure_7.12_B17074.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.12_B17074.jpg)'
- en: Figure 7.12 – State object as written in a class component
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 - 在类组件中编写的状态对象
- en: 'This is pretty easy to understand, right? Our `state` has the following values:
    `userInfo` – an object, `comments` – an array of strings, and `likes` – a number.
    Let''s see how the same thing would look using *hooks*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解，对吧？我们的`state`有以下值：`userInfo` - 一个对象，`comments` - 一个字符串数组，`likes` - 一个数字。让我们看看使用*hooks*会是什么样子：
- en: '![Figure 7.13 – Our state written in a functional component'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 - 我们在函数组件中编写的状态'
- en: '](Images/Figure_7.13_B17074.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.13_B17074.jpg)'
- en: Figure 7.13 – Our state written in a functional component
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 - 我们在功能组件中编写的状态
- en: This is the exact same thing but we've been using the `useState` hook. Everything
    has the exact same values as the previous example but the difference is in the
    fact that our state is not living in a single object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这和之前的例子完全一样，但我们使用了`useState`钩子。所有的值和之前的例子完全一样，不同之处在于我们的状态不再存在于单个对象中。
- en: 'Now, let''s say, for example, we want to change the number of likes. Maybe
    someone clicked the like button and we want to update the number displayed on
    the screen. Let''s see how we would change it in a class component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，举个例子，假设我们想改变喜欢的数量。也许有人点击了喜欢按钮，我们想要更新屏幕上显示的数字。让我们看看在类组件中如何改变它：
- en: '![Figure 7.14 – Changing the state in a class component'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14 - 在类组件中改变状态'
- en: '](Images/Figure_7.14_B17074.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.14_B17074.jpg)'
- en: Figure 7.14 – Changing the state in a class component
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 - 在类组件中改变状态
- en: This looks complicated, right? On top of that, there's a bunch of new things
    compared to the usual `setState()` function we've been using until now. The thing
    is, because we need to update the state just for the likes value, we used something
    called *previous state*. That's where `prevState` comes from. Once you need to
    change the state based on the previous state, as we need to do here because we
    need to increment the number of likes, it's imperative to pass to `this.setState`
    a function as an argument. This provides us with a snapshot (`prevState`) of the
    previous state. We've been using the short version until now because we didn't
    need to update it based on the previous state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来复杂，对吧？除此之外，与我们一直使用的`setState()`函数相比，还有很多新的东西。问题是，因为我们只需要更新喜欢的数量，所以我们使用了一种叫做*previous
    state*的东西。这就是`prevState`的来源。一旦需要根据先前的状态来改变状态，就像我们在这里需要增加喜欢的数量一样，就必须将一个函数作为参数传递给`this.setState`。这为我们提供了先前状态的快照（`prevState`）。到目前为止，我们一直使用简化版本，因为我们不需要根据先前的状态来更新它。
- en: 'Now let''s see how the same thing would look if we''d been using hooks:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如果我们使用钩子会是什么样子：
- en: '![Figure 7.15 – Changing the state in a functional component'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15 - 在功能组件中改变状态'
- en: '](Images/Figure_7.15_B17074.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_7.15_B17074.jpg)'
- en: Figure 7.15 – Changing the state in a functional component
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 - 在功能组件中改变状态
- en: This is obviously a lot cleaner and easier. We know we want to change only the
    likes, so we're using `setLikes`. Here, we can take the `likes` state and just
    increment it by `1`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然更加清晰和简单。我们知道我们只想改变喜欢的数量，所以我们使用了`setLikes`。在这里，我们可以取`likes`状态，然后将其增加`1`。
- en: As you can see, hooks make our life a lot easier. They're really simple to use
    and require a lot less writing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，钩子使我们的生活变得更加容易。它们非常简单易用，需要写的代码也少得多。
- en: Now, the thing is, if we were to take the app we created before going into **hooks**,
    the one that displays our real age, how exactly would we be able to call the `setInterval`
    function because the lifecycle functions – `componentDidMount` or `componentWillUnmount`
    – are only available in a class component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题是，如果我们在进入**hooks**之前创建的应用程序，显示我们真实年龄的应用程序，我们如何能够调用`setInterval`函数，因为生命周期函数
    - `componentDidMount`或`componentWillUnmount` - 仅在类组件中可用。
- en: We're in luck because the React team provides us with a lot more hooks for us
    to use besides `setState`. First, let's see what exactly a hook is.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运，因为React团队为我们提供了除了`setState`之外更多的钩子供我们使用。首先，让我们看看什么是钩子。
- en: 'As we know, React is all about code reusability. Right now, we can write simple
    functions and call them whenever we need to calculate something or even write
    components in order to reuse them in any part of our application, but the problem
    with components is the fact that they have to render some UI. This makes components
    kind of inconvenient. The React team got the hooks idea because they wanted to
    be able to share complex logic without having to render some sort of UI. Hooks
    let you use React features from a function with just a simple function call. The
    hooks we''ve been provided with cover the most important parts of React: state,
    lifecycle, and context.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，React是关于代码重用的。现在，我们可以编写简单的函数，并在需要计算某些东西时调用它们，甚至编写组件以便在应用程序的任何部分重用它们，但组件的问题在于它们必须渲染一些UI。这使得组件有点不方便。React团队提出了钩子的想法，因为他们希望能够共享复杂的逻辑而不必渲染某种UI。钩子让你可以通过简单的函数调用从函数中使用React功能。我们提供的钩子涵盖了React的最重要部分：状态、生命周期和上下文。
- en: So, let's see what type of hook we could use instead of the `componentDidMount`
    function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们可以用什么类型的钩子来替代`componentDidMount`函数。
- en: useEffect
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useEffect
- en: The `useEffect` hook enables us to use side effects from a function component.
    What are *side effects*? For example, *data fetching* or *subscriptions* are side
    effects. They're called that because they can affect other components and can't
    be done during rendering.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子使我们能够从函数组件中使用副作用。什么是*副作用*？例如，*数据获取*或*订阅*都是副作用。它们被称为副作用，因为它们可以影响其他组件，并且不能在渲染期间完成。'
- en: Usually, those operations are performed with lifecycle functions in a class
    component. You can think of `useEffect` like all those lifecycle functions all
    combined in a single function. Just like `useState`, `useEffect` may be used multiple
    times inside the same functional component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些操作是在类组件中使用生命周期函数执行的。你可以把`useEffect`想象成所有这些生命周期函数合并在一个函数中。就像`useState`一样，`useEffect`可以在同一个函数组件中多次使用。
- en: By using this hook, you'll basically tell React that your component needs to
    do something after rendering. React will remember the function you passed and
    call it later after performing all the updates. `useEffect` runs after every render.
    So basically, it runs after the first render and after every update your component
    does.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个钩子，你基本上告诉React你的组件需要在渲染后做一些事情。React会记住你传递的函数，并在执行所有更新后调用它。`useEffect`在每次渲染后运行。所以基本上，它在第一次渲染后运行，并在你的组件进行每次更新后运行。
- en: Okay, so what about `componentWillUnmount`? How can we make sure that our function
    will only work when it's time to remove the component? `useEffect` is enough for
    this and we don't need another hook. If we do return a function from our effect,
    React will make sure to call that function once our component is unmounted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，那么`componentWillUnmount`呢？我们如何确保我们的函数只在移除组件时才起作用？`useEffect`就足够了，我们不需要另一个钩子。如果我们从我们的effect中返回一个函数，React会确保在组件卸载时调用该函数一次。
- en: Hooks are a really big part of React and they require lots of explaining, and
    I feel you'd get the most out of just reading the documentation. There are other
    hooks out there, for example, `useMemo`, `useRef`, and `useReducer`. So, reading
    the documentation is a lifesaver for all programmers, especially because you'll
    find in there lots of really cool information that I can guarantee you won't find
    in any book. When learning a new technology, your first step should be the documentation
    and then researching other ways that are more specific and more to the point about
    what you're really trying to study. Just like this book, we're here to learn how
    to build some React Native cross-platform applications, so let's move on and we'll
    explain more about hooks when we get to the point of using them in the next chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks是React的一个非常重要的部分，需要大量的解释，我觉得你最好的学习方式就是阅读文档。还有其他的hooks，比如`useMemo`、`useRef`和`useReducer`。所以，阅读文档对所有程序员来说都是救命稻草，特别是因为你会在里面找到很多很酷的信息，我敢保证你在任何书中都找不到。当学习一门新技术时，你的第一步应该是阅读文档，然后研究其他更具体、更关键的方法来深入研究你真正想学习的东西。就像这本书一样，我们在这里学习如何构建一些React
    Native跨平台应用，所以让我们继续前进，当我们在下一章节开始使用hooks时，我们会更详细地解释。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has gone over most of the information about state required for
    us to move forward. By now, we should be able to understand how state works both
    in a class component and a functional component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章已经涵盖了我们继续前进所需的大部分关于状态的信息。到现在为止，我们应该能够理解状态在类组件和函数组件中是如何工作的。
- en: After learning about state and what exactly state is, we learned about some
    lifecycle functions and how exactly they work. Learning about this is really important
    because we've now understood that a component lives through different stages and
    at different points, we're able to interfere with some JavaScript code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了关于状态以及状态的确切含义之后，我们了解了一些生命周期函数以及它们的工作原理。学习这些非常重要，因为我们现在明白了一个组件会经历不同的阶段，并且在不同的时刻，我们能够干预一些JavaScript代码。
- en: This whole adventure gave us an idea, the real age app. We're now able to create
    an app with dynamic numbers that change over time. We've learned how to implement
    everything we've learned so far about state and create an awesome idea displaying
    our age.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 整个冒险给了我们一个想法，真实年龄应用。我们现在能够创建一个动态数字随时间变化的应用。我们学会了如何实现我们到目前为止学到的关于状态的一切，并创造一个展示我们年龄的绝妙想法。
- en: Because class components look a bit like there's too much code to write, we
    started learning about hooks. After a careful analysis of how exactly they're
    different, we learned about a hook called `useEffect`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类组件看起来有点像需要写太多代码，我们开始学习关于hooks的知识。经过仔细分析它们的区别，我们了解了一个叫做`useEffect`的hook。
- en: Learning all this will be really beneficial in the long run, especially in the
    following chapters when it's all about practical challenges, where we'll learn
    lots of tricks and create many different types of React Native applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 长期来看，学习所有这些将会非常有益，特别是在接下来的章节中，那些都是关于实际挑战，我们将学到很多技巧，并创建许多不同类型的React Native应用。
