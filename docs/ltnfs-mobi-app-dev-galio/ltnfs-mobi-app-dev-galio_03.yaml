- en: '*Chapter 3*: The Correct Mindset'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：正确的思维方式'
- en: I think I'm right in saying that we've learned quite a lot together, and I hope
    you're excited to keep up the learning process. In the previous chapter, we learned
    more about how a React Native project works and what role each file or folder
    has. After that, we started learning about **JavaScript XML** (**JSX**) and how
    to use it, and we've actually imported our first component. Learning about the
    core components you're going to use every time a new project is created set us
    on the path of understanding and creating our own component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们一起学到了很多东西，希望您会对继续学习过程感到兴奋。在上一章中，我们更多地了解了React Native项目的工作原理以及每个文件或文件夹的作用。之后，我们开始学习**JavaScript
    XML**（**JSX**）以及如何使用它，并且实际上导入了我们的第一个组件。了解您每次创建新项目时要使用的核心组件，使我们开始理解并创建自己的组件。
- en: This chapter will focus mostly on the React architecture and how it makes us
    think in a certain way after we spend some time with the framework. For starters,
    we'll begin with the main idea about how people start a React application—or,
    in our case, a React Native application, and we'll easily transition into the
    more advanced concepts of React, such as props.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要关注React架构以及在花费一些时间与框架一起后它如何让我们以一种特定的方式思考。首先，我们将从人们启动React应用程序的主要思想开始，或者在我们的情况下，启动React
    Native应用程序，然后我们将轻松过渡到React的更高级概念，如props。
- en: By grasping the concept of props, we'll be able to add the next level of complexity
    to our applications. This will allow us to create even cooler components, unlocking
    more powers of React. You'll find yourself using props in almost every component
    you create.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握props的概念，我们将能够为我们的应用程序添加更高级别的复杂性。这将使我们能够创建更酷的组件，释放React的更多功能。您会发现自己在几乎每个创建的组件中都在使用props。
- en: After that, it's time to learn about rendering lists and how to use those to
    change the information inside our components. This sounds pretty neat, right?
    We'll be able to have different information shown based on whatever calculations
    we want to do inside the component or however many items we need to showcase.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，是时候学习如何渲染列表以及如何使用它们来更改组件内的信息。听起来很不错，对吧？我们将能够根据我们想要在组件内进行的任何计算或我们需要展示的项目数量来显示不同的信息。
- en: Completing this chapter will teach you great ways of thinking as a React developer.
    This will serve as a good time saver for when you first start any project, and
    it's really important to understand how to correctly structure our files and code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章将教会您作为React开发人员的思考方式。这将为您节省大量时间，特别是在您首次启动任何项目时，了解如何正确地构建文件和代码非常重要。
- en: 'We''ll realize how programmers are reusing their code in such a way that you''ll
    keep repeating to your family: "Write once, use everywhere!"'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将意识到程序员是如何以一种方式重复使用他们的代码，以至于您会一直对您的家人说：“写一次，到处使用！”
- en: 'This chapter will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Thinking in React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以React思考
- en: Always build the static version first
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终首先构建静态版本
- en: Props and how to use them
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props以及如何使用它们
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 03` that contains all the code we've written
    inside this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问GitHub上的[https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)来查看本章的代码。您会发现一个名为`Chapter
    03`的文件夹，其中包含本章中编写的所有代码。为了使用该项目，请按照`README.md`文件中的说明进行操作。
- en: Thinking in React
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以React思考
- en: Let's not forget the fact that Facebook created React for their own projects
    and it's actually used in almost any type of website (or mobile app with React
    Native), so it has big scalability features. If Facebook can use it in their platform,
    we can surely use it inside our apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记Facebook为他们自己的项目创建了React，并且它实际上在几乎任何类型的网站（或使用React Native的移动应用程序）中都有大规模的可扩展功能。如果Facebook可以在他们的平台上使用它，我们肯定可以在我们的应用程序中使用它。
- en: For us to take full advantage of this framework, we need to start thinking in
    React. When I first started my programming journey, the idea of a framework seemed
    kind of alien to me. I didn't understand the fact that it's called a framework
    because it comes packed with a specific workflow. Well, that's not the only reason
    why it's called a framework—it's also because it comes packed with tons of features
    and methods to make our work easier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个框架，我们需要开始思考React。当我开始我的编程之旅时，框架的概念对我来说似乎有点陌生。我不明白它被称为框架，是因为它带有特定的工作流程。嗯，这不是它被称为框架的唯一原因——它还因为它带有大量的功能和方法来使我们的工作更容易。
- en: Let's imagine we're working with our friends on an app idea that we're going
    to call *PiggyBank* just for fun. The idea is that we need to always keep track
    of all the transactions we're making with our credit card. So, this basically
    means we'll have a card keeping track of all our transactions somewhere in our
    app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们和朋友们一起合作开发一个应用想法，我们打算只是为了好玩而将其称为*PiggyBank*。这个想法是，我们需要始终跟踪我们用信用卡进行的所有交易。因此，基本上意味着我们将在我们的应用程序中的某个地方有一张卡来跟踪我们所有的交易。
- en: 'I''ve designed the following card in Adobe XD, which I think will help us visualize
    things better:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Adobe XD中设计了下面的卡片，我认为这将帮助我们更好地可视化事物：
- en: '![Figure 3.1 – Card component displaying our transactions'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 显示我们交易的卡组件'
- en: '](Images/Figure_3.01_B17074.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.01_B17074.jpg)'
- en: Figure 3.1 – Card component displaying our transactions
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 显示我们交易的卡组件
- en: So, our friend came up with this cool card design and he's asking us to implement
    it in the mobile app. Easy, right? We've seen how everything can be coded from
    top to bottom just by using JSX code; on top of that, there's so much text on
    this card that it makes things even easier for us. You might even think we don't
    need any custom components or we might only need one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的朋友设计了这个很酷的卡片，并要求我们在移动应用程序中实现它。很简单，对吧？我们已经看到如何通过使用JSX代码从上到下编写所有内容；除此之外，这张卡上有很多文本，这使得事情对我们来说更容易。你甚至可能认为我们不需要任何自定义组件，或者我们可能只需要一个。
- en: Well, that's not entirely true. This is the moment where our React knowledge
    shines through and it helps us divide everything into components for much easier
    and cleaner code. But the question remains… how do you know where to draw the
    rectangles, and how do we delimitate the components? One technique that React
    recommends is the **single-responsibility principle** (**SRP**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不完全正确。这是我们的React知识发光的时刻，它帮助我们将一切划分为组件，使代码更容易、更清晰。但问题仍然存在...你如何知道在哪里画矩形，我们如何划分组件？React推荐的一种技术是**单一责任原则**（**SRP**）。
- en: Tip
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The SRP is a programming principle that dictates the fact that every class in
    a program we're writing should have responsibility over a single part of that
    program's functionality. This is part of **SOLID**, which is an acronym for five
    design principles for software engineers to create more maintainable, flexible,
    and understandable code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SRP是一个编程原则，它规定我们编写的程序中的每个类都应该对程序功能的一个部分负责。这是**SOLID**的一部分，它是软件工程师创建更易于维护、灵活和可理解的代码的五个设计原则的首字母缩写。
- en: 'Using this principle, we should now be able to divide the card into components.
    Let''s take this card and draw rectangles on it for each and every component we
    encounter, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个原则，我们现在应该能够将卡分成组件。让我们拿这张卡，并为我们遇到的每个组件在上面画一个矩形，如下所示：
- en: '![Figure 3.2 – Rectangles drawn to divide components'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 绘制矩形以划分组件'
- en: '](Images/Figure_3.02_B17074.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.02_B17074.jpg)'
- en: Figure 3.2 – Rectangles drawn to divide components
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 绘制矩形以划分组件
- en: 'So, we''ve extracted the following components:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们提取了以下组件：
- en: '`TransactionCard` (*red*)—Contains the full card and all of its elements'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionCard`（*红色*）- 包含整个卡和所有元素'
- en: '`TransactionCardHeader` (*green*)—Represents the upper part of the card, the
    part with the name and total money spent'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionCardHeader`（*绿色*）- 代表卡的上半部分，即名称和总花费的部分'
- en: '`TransactionCardList` (*yellow*)—Contains a list of items'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionCardList`（*黄色*）- 包含项目列表'
- en: '`TransactionItem` (*pink*)—A single item displaying the transaction and the
    price'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionItem`（*粉色*）- 显示交易和价格的单个项目'
- en: As you can see, we've successfully divided this card into four different components
    that will have to somehow talk to each other and at the end have this one purpose
    of showing information regarding our transactions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们成功地将这张卡分成了四个不同的组件，它们将不得不以某种方式相互交流，并最终具有显示有关我们交易的信息的这一目的。
- en: Each of them has only one single purpose, so that checks the SRP we've been
    talking about. Let's code it, without styling yet—we'll do that in the following
    chapter. Always build the static version first.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它们每个都只有一个单一的目的，这样就可以检查我们一直在谈论的SRP。让我们编写它，暂时不要样式 - 我们将在下一章中进行。始终先构建静态版本。
- en: First of all, we need to understand that the easiest way we can start working
    on an application is by building static pages and then separating everything and
    building the logic. For that, we'll have to basically copy everything we see in
    the image, even the text—that's why we call it a static version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要明白，我们可以开始开发一个应用程序的最简单方法是构建静态页面，然后分离一切并构建逻辑。为此，我们将基本上复制我们在图像中看到的一切，甚至文本
    - 这就是为什么我们称其为静态版本。
- en: 'Let''s start by creating a new project by opening up the terminal, moving to
    our project''s folder, and writing the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开终端，转到我们项目的文件夹，并输入以下命令来创建一个新项目：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I've picked `TransactionCard` as my project name, but don't forget that you
    can name it whatever you want. Next, we'll be choosing the blank managed workflow
    template and will wait for it to start initializing our project. Once that's done,
    let's open up our **integrated development environment** (**IDE**)/text editor
    of choice and look over the project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了`TransactionCard`作为我的项目名称，但不要忘记你可以随意命名它。接下来，我们将选择空白的托管工作流模板，并等待它开始初始化我们的项目。一旦完成，让我们打开我们的**集成开发环境**（**IDE**）/文本编辑器，并查看项目。
- en: I'll open up `App.js` and delete the `StatusBar` import (not really important
    for this exercise) and everything from the inside of our `View` component in our
    `App` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我将打开`App.js`并删除`StatusBar`导入（对于这个练习来说并不重要），以及我们`App`函数中`View`组件内的所有内容。
- en: Let's decide what types of components we need. It's pretty easy to see that
    this card only needs a `View` component and a `Text` component. Luckily for us,
    we already have those imported in the file, so let's use them to build our static
    version of the card.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们决定我们需要哪些类型的组件。很容易看到，这张卡只需要一个`View`组件和一个`Text`组件。幸运的是，我们已经在文件中导入了它们，所以让我们使用它们来构建卡的静态版本。
- en: 'We''ll start by looking at our design and try to divide everything into containers.
    As we can see, this card has two parts: the upper part is the header with general
    information, and the lower part is full of all of our recent transactions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的设计开始，尝试将一切划分为容器。正如我们所看到的，这张卡片有两部分：上半部分是带有一般信息的标题，下半部分则充满了我们最近的所有交易。
- en: 'So, let''s write the code for those parts, but first, we''ll focus on the upper
    side of our card, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们写一下那些部分的代码，但首先，我们将专注于我们卡片的上半部分，如下所示：
- en: '![Figure 3.3 – Upper side of our card'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 我们卡片的上半部分'
- en: '](Images/Figure_3.03_B17074.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.03_B17074.jpg)'
- en: Figure 3.3 – Upper side of our card
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 我们卡片的上半部分
- en: We see a lot of `View` components here, but why is that? As we discussed in
    the last chapter, the `View` component is usually used for layout design and grouping
    elements together. So, we've grouped the two parts inside of it and then wrote
    code for the header. If we save and open our simulators, we should be able to
    see the text we've just written.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了很多“View”组件，但为什么呢？正如我们在上一章中讨论的那样，“View”组件通常用于布局设计和将元素分组在一起。所以，我们将这两部分放在其中，然后为标题编写代码。如果我们保存并打开我们的模拟器，我们应该能够看到我们刚刚写的文本。
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't forget that if you use the Android simulator, you first need to open up
    Android Studio and then go to the **Android Virtual Device** (**AVD**) Manager.
    Run your simulator and afterward start the app from the Expo dashboard.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，如果你使用的是安卓模拟器，你首先需要打开安卓工作室，然后转到**安卓虚拟设备**（**AVD**）管理器。运行你的模拟器，然后从Expo仪表板启动应用程序。
- en: Let's think about our transactions now. We have two pieces of text—to the left
    is the name of the company from which we bought whatever we bought, and to the
    right, we can see the price of the transaction. How can we do that? As far as
    we have seen until now, the elements we've printed out to the screen were always
    aligned in a columnar style from top to bottom.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下我们的交易。我们有两段文本 - 左边是我们购买商品的公司名称，右边是交易的价格。我们该如何做呢？到目前为止，我们看到的元素总是以从上到下的列式样式对齐在屏幕上。
- en: Well, we need to style it for that to work, but the important point here is
    that we need to understand the fact that those two components are somehow connected,
    so we'd have to put those elements in the same `View` component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们需要为此进行样式设置，但这里的重要一点是，我们需要理解这两个组件在某种程度上是相互连接的，所以我们必须将这些元素放在同一个“View”组件中。
- en: Let's do that now and get our components ready for writing all these transactions.
    First, try to do it on your own and then see if you got the same code as I did.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们这样做，准备好我们的组件来写所有这些交易。首先，试着自己做一下，然后看看你是否得到了和我一样的代码。
- en: 'I''ll start by creating a different `View` component for each line and then
    add the text inside it, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为每一行创建一个不同的“View”组件，然后在其中添加文本，就像这样：
- en: '![Figure 3.4 – The rest of the static code'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 静态代码的其余部分'
- en: '](Images/Figure_3.04_B17074.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.04_B17074.jpg)'
- en: Figure 3.4 – The rest of the static code
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 静态代码的其余部分
- en: Let's open up our app and take a peek at how everything looks. Right now, it's
    just a bunch of text in the form of a column displaying all the information we
    have in our design. It doesn't look like a card, though, but we can definitely
    see a resemblance to our design in terms of having the same information in the
    same order. So, we've now created the most basic version of our card.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的应用程序，看看一切的样子。现在，它只是一堆文本，以列的形式显示我们设计中的所有信息。不过，它看起来并不像一张卡片，但我们肯定可以看到与我们的设计相似之处，即以相同的顺序包含相同的信息。因此，我们现在创建了我们卡片的最基本版本。
- en: The next step is to finally break down this big tree into smaller components.
    By doing this, we'll make the code easier to read and understand and also more
    modulated, which basically means we could use the same component in a different
    card or whatever we need it for at that moment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是最终将这棵大树分解成更小的组件。通过这样做，我们将使代码更易于阅读和理解，同时也更模块化，这基本上意味着我们可以在不同的卡片或其他需要时使用相同的组件。
- en: Breaking down our code
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解我们的代码
- en: 'So, remember we''ve been dividing the design into four different components?
    Let''s create a `components` folder and create four different files for each component,
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，记得我们已经将设计分成了四个不同的组件吗？让我们创建一个`components`文件夹，并为每个组件创建四个不同的文件，如下所示：
- en: '![Figure 3.5 – Our folder with all the files created'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 我们的文件夹中所有文件的创建'
- en: '](Images/Figure_3.05_B17074.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.05_B17074.jpg)'
- en: Figure 3.5 – Our folder with all the files created
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 我们的文件夹中所有文件的创建
- en: Now, it's time to start coding each one. So, we know that the big card—or the
    first component—should be able to be split into two parts, the `List` and the
    `Header` components. Let's copy all of our code from `App.js` into `TransactionCard`,
    as this one is the main component. By all the code, I mean only what's inside
    the first `View` component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始编写每一个了。所以，我们知道大卡片——或者第一个组件——应该能够分成两部分，`List`和`Header`组件。让我们将`App.js`中的所有代码复制到`TransactionCard`中，因为这是主要组件。所有的代码，我指的是只有在第一个`View`组件内的代码。
- en: 'After creating our function, we paste all the code inside it. Let''s export
    the component and take a look at it, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完我们的函数后，我们将所有的代码粘贴到其中。让我们导出组件并查看它，如下所示：
- en: '![Figure 3.6 – TransactionCard component written as an arrow function'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 以箭头函数形式编写的TransactionCard组件'
- en: '](Images/Figure_3.06_B17074.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.06_B17074.jpg)'
- en: Figure 3.6 – TransactionCard component written as an arrow function
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 以箭头函数形式编写的TransactionCard组件
- en: We've written this component as an arrow function because it's easier to write—at
    least, in my opinion—but honestly, you can write it even as a class if you want.
    As a rule of thumb, you usually use `class` only if there's state involved, but
    state is something we need to go into in more depth in the later chapters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个组件写成箭头函数，因为这样写起来更容易——至少在我看来是这样的——但老实说，如果你愿意，你甚至可以将其写成类。作为一个经验法则，通常只有在涉及状态时才使用`class`，但状态是我们需要在后面的章节中更深入地讨论的东西。
- en: So, we have all the code here and we've exported our function. All good—now,
    the next step is to go even deeper with our division. Let's take the header side
    of our component and move it to its specific file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在这里有所有的代码，并且我们已经导出了我们的函数。一切顺利——现在，下一步是更深入地划分我们的组件。让我们将组件的头部部分移到它特定的文件中。
- en: 'After we''ve finished copying the code into our `TransactionCardHeader` component,
    let''s import the component into our `TransactionCard` component and use it instead
    of our copied code. We should do the same thing with the second part of our card,
    and that is the `TransactionCardList` component. Let''s do it and see what everything
    looks like. Here''s the result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将代码复制到`TransactionCardHeader`组件后，让我们将该组件导入到`TransactionCard`组件中，并在其中使用它，而不是复制的代码。我们应该对我们卡片的第二部分做同样的事情，也就是`TransactionCardList`组件。让我们这样做，看看一切是什么样子。这是结果：
- en: s
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: '![Figure 3.7 – Our newly created TransactionCard component'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 我们新创建的TransactionCard组件'
- en: '](Images/Figure_3.07_B17074.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.07_B17074.jpg)'
- en: Figure 3.7 – Our newly created TransactionCard component
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 我们新创建的TransactionCard组件
- en: OK—so, this looks much, much cleaner. If we import this component into our `App.js`
    file, everything should look identical to how it used to look before we started
    making all these changes to our code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的 - 这看起来干净多了。如果我们将这个组件导入到我们的`App.js`文件中，一切应该看起来和我们在开始对代码进行所有这些更改之前一样。
- en: Tip
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget that we always need to run `import React from 'react';` so that
    we can use all of our components. For a component to run, it needs to know it's
    a component and not just random writing in a file. That import helps our code
    identify which objects are React objects and how to render everything.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们总是需要运行`import React from 'react';`，这样我们才能使用我们所有的组件。组件需要知道它是一个组件，而不仅仅是文件中的随机写入。这个导入帮助我们的代码识别哪些对象是React对象，以及如何渲染一切。
- en: Everything works, right? If you've encountered any issues, stop for 2 seconds
    before moving further and check everything we've been doing until now; maybe you
    got something misspelled or you forgot some exports somewhere in your files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都正常，对吧？如果你遇到任何问题，在继续之前停顿2秒钟，检查我们到目前为止所做的一切；也许你拼错了什么，或者在你的文件中忘记了一些导出。
- en: If everything's fine, let's get inside our `TransactionItem` component. Well,
    as the name suggests, this is one single item, so what does that mean? As we can
    see in our `TransactionCardList` component, we do have several different items.
    Are we going to create a different component for each one of them?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，让我们进入我们的`TransactionItem`组件。嗯，顾名思义，这是一个单独的项目，那是什么意思？正如我们在`TransactionCardList`组件中所看到的，我们确实有几个不同的项目。我们要为每一个创建一个不同的组件吗？
- en: Not really—we're actually going to create a single component that changes the
    information displayed based on whatever information it receives as input. This
    sounds pretty cool, right? Well, that input is called a prop, and each component
    gets a set of props when it renders by default, but it can also receive custom
    props created by us. Let's dive into props and learn how to use them in the context
    of our card.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上不是 - 我们实际上要创建一个单一的组件，根据接收的任何信息来改变显示的信息。听起来很酷，对吧？嗯，这个输入被称为prop，每个组件在渲染时默认会得到一组props，但它也可以接收我们创建的自定义props。让我们深入了解props，并学习如何在我们的卡片上下文中使用它们。
- en: Props and how to use them
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props及如何使用它们
- en: So, what exactly are props? Up to now, we've only used normal tags to identify
    our components such as `TransactionCardHeader`. However, as we saw earlier when
    we presented different components, these ones could also have **props** that are
    used to pass down information from the bigger component (**parent**) to a smaller
    component (**children**).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，props到底是什么？到目前为止，我们只使用普通标签来标识我们的组件，比如`TransactionCardHeader`。然而，正如我们之前展示不同组件时所看到的，这些组件也可以有**props**，用于从更大的组件（**父组件**）传递信息到更小的组件（**子组件**）。
- en: 'Let''s go into `TransactionCardList` and look at our code. As far as we can
    see, there''s a lot of code repeating itself in terms of components being used.
    So, we can see this pattern emerging from inside our main `<View />` tag:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入`TransactionCardList`并查看我们的代码。据我们所见，就组件的使用而言，有很多重复的代码。因此，我们可以看到这种模式从我们主要的`<View
    />`标签中出现：
- en: '![Figure 3.8 – TransactionCardList component ready to be divided into smaller
    components'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 - TransactionCardList组件准备分解为更小的组件'
- en: '](Images/Figure_3.08_B17074.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.08_B17074.jpg)'
- en: Figure 3.8 – TransactionCardList component ready to be divided into smaller
    components
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - TransactionCardList组件准备分解为更小的组件
- en: The pattern is pretty easy to see—we have four identically written pieces of
    code but with different information written inside of it. We basically have four
    instances of `View` components with two `Text` components inside of them. Seeing
    how this repeats, we can clearly realize that we could write an external component
    for this specific case.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式很容易看出来——我们有四个完全相同的代码片段，但里面写着不同的信息。基本上我们有四个`View`组件的实例，里面有两个`Text`组件。看到这种重复，我们可以清楚地意识到我们可以为这种特定情况编写一个外部组件。
- en: Let's begin by writing a static component inside our `TransactionItem` component
    and see how we can implement it inside our list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`TransactionItem`组件内编写一个静态组件开始，看看我们如何在列表中实现它。
- en: 'Just go ahead and write one of these pieces of pattern; we only need one—otherwise,
    we''ll kind of defeat the purpose of a singular item. This is what the code should
    look like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 随便写一个这种模式的片段；我们只需要一个——否则，我们会有点违背单个项目的目的。代码应该是这样的：
- en: '![Figure 3.9 – Static version of TransactionItem'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – TransactionItem的静态版本'
- en: '](Images/Figure_3.09_B17074.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.09_B17074.jpg)'
- en: Figure 3.9 – Static version of TransactionItem
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – TransactionItem的静态版本
- en: Now, let's use this component instead of all our pieces of pattern we've used
    inside our list. After importing the file and replacing everything with four or
    five instances of `TransactionItem`, we can see that the data is now `Starbucks`
    and `$ 10.12` everywhere. Repeating itself like crazy is not really how a great
    mobile app is designed, right?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个组件来代替我们在列表中使用的所有模式片段。导入文件并用四到五个`TransactionItem`的实例替换所有内容后，我们可以看到数据现在在所有地方都是`Starbucks`和`$
    10.12`。像疯狂重复一样并不是一个伟大的移动应用程序设计，对吧？
- en: 'Now, how can we change that? How can we have different pieces of information
    displayed by our component? By using props. Let me change the `TransactionItem`
    component and see how props need to be implemented. This is what the code should
    look like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何改变这种情况？我们如何让组件显示不同的信息？通过使用props。让我改变`TransactionItem`组件，并看看props需要如何实现。代码应该是这样的：
- en: '![Figure 3.10 – Implementing props into our component'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 将props实现到我们的组件中'
- en: '](Images/Figure_3.10_B17074.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.10_B17074.jpg)'
- en: Figure 3.10 – Implementing props into our component
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 将props实现到我们的组件中
- en: Right now, your `TransactionCardList` component contains multiple instances
    of `TransactionItem`. If you save right now there's nothing showing up for these
    components besides the `$` sign. Why is that?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的`TransactionCardList`组件包含多个`TransactionItem`的实例。如果你现在保存，除了`$`符号外，这些组件上什么都不显示。为什么呢？
- en: This all happens because our component has nothing stored in those variables.
    For us to actually get something displayed on the screen, we'd have to send some
    information over to our `TransactionItem` component from `TransactionCardList`.
    Let's move inside of it and use our newly updated components to display the correct
    information on our phone.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切发生是因为我们的组件在这些变量中没有存储任何东西。为了实际在屏幕上显示一些信息，我们需要从`TransactionCardList`向`TransactionItem`组件发送一些信息。让我们进入其中，并使用我们新更新的组件来在手机上显示正确的信息。
- en: 'Inside the `TransactionCardList` component, find our components and add the
    following props to each component, like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TransactionCardList`组件中，找到我们的组件，并为每个组件添加以下props，就像这样：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After we've added props to all of our components, the next step is to save.
    We'll see how our simulator refreshes automatically—and congratulations! We've
    successfully sent information from one **parent** component to our **child** component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为所有组件添加了props之后，下一步是保存。我们将看到我们的模拟器会自动刷新——恭喜！我们成功地从一个**父**组件向我们的**子**组件发送了信息。
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: All the information being sent from one component to another will formally be
    inside curly braces, as we've seen by writing the number for the price prop. Even
    though strings could still be placed inside curly braces, they're not mandatory
    for sending information, so you could even write `name="Mircea"`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个组件发送到另一个组件的所有信息都将正式地放在花括号内，就像我们通过为价格prop编写数字所看到的那样。即使字符串仍然可以放在花括号内，但它们对于发送信息并不是强制的，所以你甚至可以写`name="Mircea"`。
- en: Now, let's try to understand our code a little bit. So, what's going on, really,
    inside our app?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着稍微了解一下我们的代码。那么，我们的应用程序内部到底发生了什么？
- en: When the app first runs, it goes straight to `App.js` and starts rendering all
    the components first written there. For that, that'll be our `TransactionCard`
    component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序首次运行时，它直接转到`App.js`并开始首先在那里编写的所有组件。对于这一点，那将是我们的`TransactionCard`组件。
- en: React sees that our component actually has two different components inside it
    and begins rendering the next components. Now, one of these components is actually
    our `TransactionCardList` component, which contains all our `TransactionItem`
    components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React看到我们的组件实际上有两个不同的组件在其中，并开始渲染下一个组件。现在，其中一个组件实际上是我们的`TransactionCardList`组件，其中包含所有我们的`TransactionItem`组件。
- en: Because the first component contains another component, we call the first one
    a **parent** and the second one a **child** to the first one. So, if `TransactionItem`
    is a **child** to `TransactionCardList`, try to figure out what `TransactionCard`
    is to `TransactionCardHeader`. Ready? `TransactionCard` is the **parent** of `TransactionCardHeader`
    because it contains the other component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第一个组件包含另一个组件，我们将第一个称为**父**，第二个称为第一个的**子**。所以，如果`TransactionItem`是`TransactionCardList`的**子**，试着想一想`TransactionCard`是`TransactionCardHeader`的什么。准备好了吗？`TransactionCard`是`TransactionCardHeader`的**父**，因为它包含了另一个组件。
- en: 'Now, when React reaches `TransactionCardList`, it''ll send some information
    to each `TransactionItem` component via the **props**. The information being sent
    is a JavaScript object that looks like this: `{name: ''Starbucks'', price=10.12}`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当React到达`TransactionCardList`时，它将通过**props**向每个`TransactionItem`组件发送一些信息。被发送的信息是一个看起来像这样的JavaScript对象：`{name:
    ''Starbucks'', price=10.12}`。'
- en: 'That''s why we can use props as an argument for our function in `TransactionItem`
    and then access the keys of our object with a dot, like this: `props.name`. You
    must be wondering how React knows how to handle all these processes because a
    more complex app might have hundreds of components nested into each other while
    sending props to one another at the first render.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们可以在`TransactionItem`中将props作为函数的参数使用，然后通过点来访问我们对象的键，就像这样：`props.name`。你一定想知道React如何知道如何处理所有这些过程，因为一个更复杂的应用程序可能有数百个组件嵌套在一起，同时在第一次渲染时向彼此发送props。
- en: The thing is, React first renders everything that's at the surface, and when
    all the information is being sent from one parent component to a child, then it
    renders that information.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，React首先渲染表面上的所有内容，当所有信息从一个父组件发送到子组件时，它才会渲染该信息。
- en: 'Now, just to make our component even more usable and reusable, we''d have to
    make the number of items in our list a little more variable. For a bigger app,
    we''d have to ask ourselves questions such as these: "What if the number of transactions
    a user makes is bigger or smaller than five?"; "What if I''ll need more cards
    for future screens but with the same design? How can I reuse this card component?"'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使我们的组件更加可用和可重用，我们必须使列表中的项目数量更加可变。对于更大的应用程序，我们必须问自己这样的问题："如果用户进行的交易数量比五个更多或更少会怎么样？";
    "如果我将来需要更多的卡片，但设计相同，我该如何重用这个卡片组件？"
- en: Using the map function to dynamically change the number of components
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用map函数动态更改组件的数量。
- en: 'Well, let''s first see how we can output as many `TransactionItem` components
    as we can. We''ll go inside our `TransactionCardList` component and create a constant
    array of objects, outside of our function, called `transactions`. This variable
    will contain all the information needed for our items. Let''s see what this looks
    like, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何输出尽可能多的`TransactionItem`组件。我们将进入`TransactionCardList`组件，并在函数外创建一个名为`transactions`的对象常量数组。这个变量将包含所有项目所需的信息。让我们看看这是什么样子，如下所示：
- en: '![Figure 3.11 – transactions variable'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - transactions变量'
- en: '](Images/Figure_3.11_B17074.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.11_B17074.jpg)'
- en: Figure 3.11 – transactions variable
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - transactions变量
- en: 'Once we have this variable with all the information that we need, we could
    **map** our array and output a different component for each item. This might sound
    a bit confusing if you''re not really comfortable with JavaScript, but trust me,
    it''s really easy. Let''s delete everything from inside the `<View />` component
    and replace it with the `map` function, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了包含所有所需信息的这个变量，我们就可以对数组进行**映射**，并为每个项目输出一个不同的组件。如果你对JavaScript不太熟悉，这可能听起来有点混乱，但相信我，这其实非常简单。让我们删除`<View
    />`组件内的所有内容，并用`map`函数替换，如下所示：
- en: '![Figure 3.12 – map function used inside TransactionCardList component'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - 在TransactionCardList组件内部使用的map函数'
- en: '](Images/Figure_3.12_B17074.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.12_B17074.jpg)'
- en: Figure 3.12 – map function used inside TransactionCardList component
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - 在TransactionCardList组件内部使用的map函数
- en: OK—so, this might look a bit strange. Don't worry—it's actually really easy.
    So, we've used the `map` function on our `transactions` array. This `map` function
    goes over each element of our array and uses the function inside its argument
    to output *something*. That something is where you come in and make use of this
    cool function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这可能看起来有点奇怪。别担心，其实很简单。所以，我们在`transactions`数组上使用了`map`函数。这个`map`函数遍历数组的每个元素，并使用其参数内的函数来输出*某些东西*。这个东西就是你要做的，利用这个很酷的函数。
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All external code used inside JSX **must** be put between curly braces so that
    React can understand that we're doing an operation that could result in other
    elements being outputted for rendering.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX内部使用的所有外部代码**必须**放在花括号之间，以便React能够理解我们正在进行的操作可能会导致其他元素被输出以进行渲染。
- en: 'Basically, because of the `map` function, we''re taking the first item of our
    array— `{name: "Starbucks", price: 10.12}`—outputting a `TransactionItem` component,
    and passing as props the values we''ve had in our array. But we also see the **key
    prop** and we both know we haven''t used the key prop inside our component. Every
    list needs a key for each child so that React can keep track of them and avoid
    excessive re-rendering. This is one of React''s rules that we need to understand
    whenever we''re using lists such as these.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '基本上，由于`map`函数，我们正在取数组的第一个项目 - `{name: "Starbucks", price: 10.12}` - 输出一个`TransactionItem`组件，并将我们数组中的值作为props传递。但我们还看到了**key
    prop**，我们都知道我们在组件内部并没有使用key prop。每个子元素都需要一个key，以便React可以跟踪它们并避免过度重新渲染。这是我们在使用这样的列表时需要理解的React规则之一。'
- en: But we've said we'd go even further, right? We need to use this card component
    multiple times if we need to. Seeing how `transactions` is just a random variable
    sitting in our `TransactionCardList` component, maybe we could send that as a
    **prop**?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们说过我们会更进一步，对吧？如果需要，我们需要多次使用这个卡片组件。看到`transactions`只是一个随机变量坐在我们的`TransactionCardList`组件中，也许我们可以将其作为一个**prop**发送？
- en: Let's add the `props` keyword inside our function's argument and change from
    `transactions.map` to `props.transactions.map`. If we save now, we get an error—our
    component expects a prop called `transactions` to come in but there's nothing
    sending it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们函数的参数中添加`props`关键字，并从`transactions.map`更改为`props.transactions.map`。如果我们现在保存，我们会得到一个错误
    - 我们的组件期望一个名为`transactions`的属性进来，但没有任何东西发送它。
- en: We'd have to send this from our parent component—namely, `TransactionCard`.
    But nonetheless, this doesn't really change the fact that we still can't use the
    card properly, so maybe we need to add this prop to even our `TransactionCard`
    component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从我们的父组件 - 即`TransactionCard`发送这个。但尽管如此，这并不真正改变我们仍然无法正确使用这张卡片的事实，所以也许我们需要将这个属性添加到我们的`TransactionCard`组件甚至。
- en: 'Let''s copy our `transactions` variable and move it inside our `App.js` file.
    After that, let''s add the `transactions` prop to our `TransactionCard` component,
    like this: `<TransactionCard transactions={transactions} />.`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制我们的`transactions`变量并将其移动到我们的`App.js`文件中。之后，让我们将`transactions`属性添加到我们的`TransactionCard`组件中，就像这样：`<TransactionCard
    transactions={transactions} />.`
- en: 'Now, we''ll have to go to our `TransactionCard` component and enable it to
    take this prop and send it even further to our `TransactionCardList` component.
    Our component now needs to look something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要去我们的`TransactionCard`组件，并使其能够接受这个属性，并将其进一步发送到我们的`TransactionCardList`组件。我们的组件现在需要看起来像这样：
- en: '![Figure 3.13 – Our newly created version of the TransactionCard component'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 - 我们新创建的TransactionCard组件的版本'
- en: '](Images/Figure_3.13_B17074.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_3.13_B17074.jpg)'
- en: Figure 3.13 – Our newly created version of the TransactionCard component
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - 我们新创建的TransactionCard组件的版本
- en: So, we've been sending this information from the `App.js` file all the way to
    our `TransactionItem` component where we finally display the information. How
    did this help us? Well, right now, we can have multiple instances of this card
    with different transactions, or we can even add or lower the number of transactions
    based on the constant that we now have declared inside our `App.js` file. We can
    use different variables altogether; we can have a different array called `biggerTransactions`
    and pass it to another component. Maybe this one will display the biggest transactions
    you've done.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们一直从`App.js`文件发送这些信息，一直到我们的`TransactionItem`组件，最终显示这些信息。这对我们有什么帮助？嗯，现在，我们可以有多个具有不同交易的此卡片实例，或者甚至可以根据我们现在在`App.js`文件中声明的常量来增加或减少交易的数量。我们可以完全使用不同的变量；我们可以有一个名为`biggerTransactions`的不同数组，并将其传递给另一个组件。也许这个组件将显示你做过的最大交易。
- en: The important thing here is the fact that we now don't have to touch our card
    component at all and we can still use it while displaying different information.
    This is much easier than creating different files for each piece of information
    we need, or maybe at one point you need to change specific information and you
    start browsing every file looking for that specific thing. You now don't have
    to do that—just go into your main file and change all the information from there.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，我们现在根本不需要触碰我们的卡片组件，而且我们仍然可以在显示不同信息的同时使用它。这比为我们需要的每一条信息创建不同的文件要容易得多，或者也许有一天你需要改变特定的信息，你开始浏览每个文件寻找那个特定的东西。现在你不必这样做
    - 只需进入你的主文件并从那里更改所有信息。
- en: Let's do some homework. You'll find the answer in our GitHub repository, in
    the `Chapter 03` folder. Having the same name all the time on our card could become
    boring. Make this easier by allowing yourself to use multiple instances of the
    same card component but for different users. After finishing this, go check out
    the code and compare it to mine. See if you did the same thing!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些作业。你会在我们的GitHub存储库的`第03章`文件夹中找到答案。一直在我们的卡上使用相同的名称可能会变得无聊。通过允许自己使用同一张卡组件的多个实例，但用于不同的用户，可以使这变得更容易。完成后，去检查代码并将其与我的进行比较。看看你是否做了同样的事情！
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've gone even deeper with React Native. We've learned so
    much about new concepts such as props and the SRP. We should be able to start
    thinking using the React methodology based on props for now, and, later, even
    state. But understanding all this is a great step toward you becoming a real React
    Native developer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地了解了React Native。我们学到了许多关于道具和SRP等新概念。我们应该能够开始思考使用基于道具的React方法论，甚至稍后使用状态。但理解所有这些对你成为真正的React
    Native开发人员是一个很大的进步。
- en: You should feel even more comfortable regarding the way props are handled and
    how we can use this special feature of React called components for our benefit,
    for reusability and cleaner code. There's no such thing as your code being too
    clean, but at the same time, keep in mind the fact that sometimes there's no need
    for multiple layers of props. Maybe your component needs only one layer or no
    props at all. Only use this feature when you feel it might make your work easier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于道具的处理方式以及我们如何利用React的组件这一特殊功能来使代码更具可重用性和更清晰，你应该感到更加舒适。代码永远不会太干净，但同时要记住，有时候并不需要多层道具。也许你的组件只需要一层，或者根本不需要道具。只有在觉得这可能会让你的工作更容易时才使用这个功能。
- en: We've also created a list for the first time and learned that each item of a
    list needs a key, a key that could sometimes be even our array's index, but there's
    always a unique key being sent to each of our items.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还第一次创建了一个列表，并学会了列表的每个项目都需要一个键，有时甚至可以是我们数组的索引，但总会向我们的每个项目发送一个唯一的键。
- en: At the end of this chapter, we finished with a little bit of homework and a
    lot of hope for the next chapter, where we'll finally create our first small application
    to show our friends.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们完成了一点作业，并对下一章充满了希望，届时我们将终于创建我们的第一个小应用程序来展示给朋友们看。
