- en: '*Chapter 4*: Your First Cross-Platform App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：你的第一个跨平台应用'
- en: We started by learning how to set up a React Native development environment.
    After that, we went ahead and started learning about JSX, components, and props.
    We've already learned so much that we should be quite confident going forward.
    But if you still feel like something is missing, then you're right. We haven't
    styled anything, and we still haven't constructed a real screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始学习如何建立React Native开发环境。之后，我们继续学习JSX、组件和属性。我们已经学到了很多，应该对未来有足够的信心。但如果你仍然觉得有些东西缺失，那么你是对的。我们还没有进行样式设计，也还没有构建一个真正的屏幕。
- en: This chapter will revolve around an app idea I had some time ago that constantly
    tracks your gaming history. We're not going to start discussing servers and databases
    as they are out of our learning scope, especially because we have bigger, more
    essential things to learn about. We'll start by detailing all the information
    about our app while using everything we've learned in the previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将围绕我之前想到的一个应用点子展开，该应用不断跟踪你的游戏历史。我们不会开始讨论服务器和数据库，因为它们超出了我们的学习范围，特别是因为我们有更重要的事情要学习。我们将从详细介绍我们应用的所有信息开始，同时使用我们在前几章学到的一切。
- en: After that, we'll take start creating the static version of our app so that
    you can understand how your brain needs to think before creating an app. Having
    learned all the principles in the previous chapters will help us understand our
    first real assignment more easily, so if there's anything you still aren't sure
    about, go back to the previous chapters and see where exactly you feel like things
    could be improved.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将开始创建应用的静态版本，以便你了解在创建应用之前你的大脑需要如何思考。在前几章学到的所有原则将帮助我们更容易地理解我们的第一个真正的任务，所以如果有任何你仍然不确定的地方，回到前几章，看看你觉得哪些地方可以改进。
- en: The next step is to learn about styling. We'll go in-depth regarding styling
    and how that works with React Native. We'll understand what flex is and how to
    use it inside our app while also figuring out tricks we can use to make our development
    easier.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是学习样式设计。我们将深入了解样式设计以及它在React Native中的工作原理。我们将了解flex是什么，以及如何在应用中使用它，同时找出我们可以使用的技巧，使开发更容易。
- en: After styling the app, we'll refactor our code while keeping everything we've
    built so far intact. This is where Galio will come in and help us realize how
    useful it is to have already-built components at our disposal. We'll learn how
    to use one of the most important components to build the layout without worrying
    about creating different styles for our containers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用添加样式之后，我们将重构我们的代码，同时保持我们迄今为止构建的一切。这就是Galio将会发挥作用的地方，帮助我们意识到拥有已构建的组件是多么有用。我们将学习如何使用最重要的组件之一来构建布局，而不必担心为我们的容器创建不同的样式。
- en: After this, we will install the app on our phones. This is a single-screen app,
    so we'll be using our phones for testing purposes only. We'll also learn some
    basics techniques that we can use to make sure our app runs smoothly on all screen
    sizes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将在手机上安装应用。这是一个单屏应用，所以我们只会用手机进行测试。我们还将学习一些基本技巧，以确保我们的应用在所有屏幕尺寸上运行顺畅。
- en: 'Everything seems straightforward and pretty easy, right? Let''s head right
    in and start building our app. The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很简单和容易，对吧？让我们直接开始构建我们的应用。本章将涵盖以下主题：
- en: Building our first app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的第一个应用
- en: Creating your first screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个屏幕
- en: Let's style it!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们为它添加样式！
- en: The superhero, Galio
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超级英雄，Galio
- en: Let's install it on our phone
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在手机上安装它
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 04` that contains all the code we've written
    inside this chapter. To use that project, please follow the instructions in the
    `README.md` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问GitHub [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)
    查看本章的代码。您会发现一个名为“Chapter 04”的文件夹，其中包含本章中编写的所有代码。要使用该项目，请按照“README.md”文件中的说明进行操作。
- en: Building our first app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个应用程序
- en: Let's start discussing the main idea of our app and how we're going to start
    building it. We'll call this app **MGA**, which is short for **My Gaming History**.
    Pretty clever, right? It will only have one screen, and it will act as the welcoming
    screen once the user is logged in. We'll pretend that the user has already logged
    into our app, so we'll only code that main screen without looking at authorization,
    which is a more advanced concept.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论我们应用程序的主要思想以及我们将如何开始构建它。我们将称此应用程序为MGA，这是My Gaming History的缩写。相当聪明，对吧？它只会有一个屏幕，并且将作为用户登录后的欢迎屏幕。我们假装用户已经登录到我们的应用程序中，因此我们只会编写主屏幕，而不会考虑授权，这是一个更高级的概念。
- en: By having a clear understanding of what our screen needs to look like and describing
    our component's purpose, we're building a clear path to our development. In the
    end, if we weren't doing all this preparation, we'd get stuck during our programming,
    and we don't want that.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过清楚地了解我们的屏幕需要看起来像什么，并描述我们组件的目的，我们正在为我们的开发建立一条清晰的道路。最后，如果我们没有做好所有这些准备工作，我们在编程过程中会遇到困难，我们不希望发生这种情况。
- en: 'We should start by looking at our design, identifying the main purpose of it,
    and how to start sectioning our screen into components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从设计开始，确定其主要目的，以及如何开始将屏幕分成组件：
- en: '![Figure 4.1 – My Gaming History''s main screen'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 我的游戏历史主屏幕'
- en: '](Images/Figure_4.1_B17074.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.1_B17074.jpg)'
- en: Figure 4.1 – My Gaming History's main screen
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 我的游戏历史主屏幕
- en: It looks great, right? Well, it should because this time, we're going to fully
    implement everything in this screen, even the colors and element positioning.
    After all, this is our first fully created screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？好吧，应该是的，因为这一次，我们将完全实现屏幕上的所有内容，甚至包括颜色和元素定位。毕竟，这是我们第一个完全创建的屏幕。
- en: Let's try to think about how we could separate everything into smaller sections,
    which is one of the most important steps in UI creation. Remember that this is
    mandatory because if we were to just code everything without even trying to have
    some sort of strategy in mind, we would run into some issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着考虑如何将所有内容分成更小的部分，这是UI创建中最重要的步骤之一。请记住，这是强制性的，因为如果我们只是试图在脑海中编写所有内容，而没有任何策略，我们将会遇到一些问题。
- en: 'We''re going to use squares to easily identify each element on our screen,
    so let''s take a look at that:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用方块来轻松识别屏幕上的每个元素，让我们来看一下：
- en: '![Figure 4.2 – Component division'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - 组件划分'
- en: '](Images/Figure_4.2_B17074.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.2_B17074.jpg)'
- en: Figure 4.2 – Component division
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 组件划分
- en: 'I''ve sectioned the entire screen here, color-coded so that you can see them
    better:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里将整个屏幕分成了几个部分，并进行了颜色编码，以便您更好地看到它们：
- en: '**Home** (*red*): Our container component, also known as our screen.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页（红色）：我们的容器组件，也称为我们的屏幕。
- en: '**WelcomeHeader** (*blue*): This will contain all the basic information regarding
    the user, such as their name, level, and profile picture.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎页（蓝色）：这将包含有关用户的所有基本信息，例如他们的姓名、级别和个人资料图片。
- en: '**MostPlayedGame** (*blue*): This will be a container that will receive information
    regarding the most played game but also a picture.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MostPlayedGame**（*蓝色*）：这将是一个容器，将接收关于最常玩的游戏以及图片的信息。'
- en: '**LastPlayedGameList** (*blue*): This contains a list of items.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LastPlayedGameList**（*蓝色*）：这包含一个项目列表。'
- en: '**PlayedGameItem** (*green*): This is a single item displaying the most played
    games and the times spent on each one.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PlayedGameItem**（*绿色*）：这是显示最常玩的游戏和每个游戏所花费的时间的单个项目。'
- en: As we can see, we're using the same color for three different components. Why
    is that? Because those three components are equally important in our main bigger
    component called `Home`. They're all sitting at the same level in our component
    tree. Even though the `Home` component is a screen, it is defined the same way
    as a component, and you'll see what I mean by that when we start coding.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们在三个不同的组件中使用了相同的颜色。为什么呢？因为这三个组件在我们的主要更大的名为`Home`的组件中同样重要。它们都位于我们的组件树中的同一级别。即使`Home`组件是一个屏幕，它的定义方式与组件相同，当我们开始编码时，你会明白我的意思。
- en: Now that we have divided our components, we're ready to move on and start coding
    our app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分割了我们的组件，准备继续并开始编写我们的应用程序。
- en: Creating your first screen
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个屏幕
- en: Once the development plan has been completed and we know where each component
    needs to go and what our application is going to look like, we're ready to create
    a new project. This project will set the first stones for this creative path that
    we've taken toward being a React-Native developer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发计划完成，我们知道每个组件需要放在哪里，以及我们的应用程序将会是什么样子，我们就可以创建一个新项目了。这个项目将为我们成为React-Native开发者的创造之路奠定第一块基石。
- en: 'Let''s begin by creating a new project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个新项目：
- en: 'Go to your Terminal in your preferred directory and run the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你喜欢的目录中的终端，并运行以下命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Choose the blank template for *Managed Workflow* and open the project folder.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择*托管工作流*的空白模板，并打开项目文件夹。
- en: As we mentioned previously, we'll have five different components, one of which
    will be the screen itself. So, let's create two different directories called `screens`
    and `components`. This will make it easier to organize when we have several different
    screens.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将有五个不同的组件，其中一个将是屏幕本身。所以，让我们创建两个不同的目录，分别叫做`screens`和`components`。这样在有多个不同的屏幕时，更容易组织起来。
- en: It's a good rule of thumb to always have a basic structure in your head when
    you start coding because you never know when you might want to add more and more
    to your app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码时，始终在脑海中有一个基本结构是一个好的经验法则，因为你永远不知道何时可能想要为你的应用程序添加更多内容。
- en: Inside our `screens` folder, let's create a file named `Home.js`. This will
    be our main screen, so we will begin by writing the most essential code for a
    component. This is just the boilerplate for a functional component. Remember how
    those were created? We did this in [*Chapter 2*](B17074_02_epub_Final_SB.xhtml#_idTextAnchor045),
    *Basics of React Native*. Now, try to do it by yourself and come back here once
    you've managed to do it:![Figure 4.3 – Basic Home screen with nothing to render
    but a View component
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`screens`文件夹中，让我们创建一个名为`Home.js`的文件。这将是我们的主屏幕，所以我们将开始编写组件的最基本代码。这只是一个功能组件的样板。还记得它们是如何创建的吗？我们在[*第2章*](B17074_02_epub_Final_SB.xhtml#_idTextAnchor045)中做过，*React
    Native的基础*。现在，试着自己做一遍，一旦你成功做到了，就回到这里来：![图4.3 - 基本的主屏幕，除了一个视图组件外没有任何内容要渲染
- en: '](Images/Figure_4.3_B17074.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.3_B17074.jpg)'
- en: Figure 4.3 – Basic Home screen with nothing to render but a View component
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 基本的主屏幕，除了一个视图组件外没有任何内容要渲染
- en: Once you've done that, we must go to our main file, `App.js`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们必须转到我们的主文件`App.js`。
- en: Here, we'll start by removing everything that's not necessary for our main file.
    We won't need all the styling, the `StatusBar` import, or even any components
    that have been imported from React Native.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从主文件中删除所有不必要的内容。我们不需要所有的样式，也不需要`StatusBar`导入，甚至不需要从React Native导入的任何组件。
- en: After deleting everything, we can import our component right after the `React`
    import and place it inside our main `App` function.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有内容后，我们可以在`React`导入之后立即导入我们的组件，并将其放入我们的主`App`函数中。
- en: 'So, our new component should now look something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的新组件现在应该看起来像这样：
- en: '![Figure 4.4 – The App.js file after removing all the unnecessary code'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4-删除所有不必要代码后的App.js文件'
- en: '](Images/Figure_4.4_B17074.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.4_B17074.jpg)'
- en: Figure 4.4 – The App.js file after removing all the unnecessary code
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4-删除所有不必要代码后的App.js文件
- en: You might be wondering, "Well, what's with that weird `<>` syntax?". That's
    the short syntax for a **Fragment**, which is a React feature. This is used so
    you don't add more unnecessary nodes to your component tree. We could have used
    a `<View />` component instead, as we saw in our earlier examples, but by using
    a **Fragment**, we're creating a wrapper for our components without an unnecessary
    wrap component as we won't be styling anything in our main file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“嗯，那个奇怪的`<>`语法是什么意思？”。那是**Fragment**的简短语法，这是React的一个特性。这样做是为了不向你的组件树添加更多不必要的节点。我们可以使用`<View
    />`组件，就像我们在之前的例子中看到的那样，但是通过使用**Fragment**，我们创建了一个包装器，而不是一个不必要的包装组件，因为我们不会在我们的主文件中进行任何样式设置。
- en: If this still creates some problems, you can easily wrap your `<Home />` component
    into a `<View />` component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然造成一些问题，你可以很容易地将你的`<Home />`组件包装到一个`<View />`组件中。
- en: Now that we're here, let's look at our `components` folder and create all the
    necessary files we'll be working with.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这里，让我们看看我们的`components`文件夹，并创建我们将要使用的所有必要文件。
- en: Create four new files called `WelcomeHeader.js`, `MostPlayedGame.js`, `LastPlayedGameList.js`,
    and `PlayedGameItem.js`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个新文件，分别命名为`WelcomeHeader.js`、`MostPlayedGame.js`、`LastPlayedGameList.js`和`PlayedGameItem.js`。
- en: Let's do the same thing we did with `Home.js` for each of our newly created
    files. You could even copy the code from the `Home.js` file and then paste it
    into each file; just don't forget to change the names from **Home** to whatever
    your component is called.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对我们新创建的每个文件都做与`Home.js`相同的事情。你甚至可以从`Home.js`文件中复制代码，然后粘贴到每个文件中；只是不要忘记将名称从**Home**改为你的组件名称。
- en: Now that we have initialized all our files, we're ready to start moving on with
    our code. We should see some sort of similarities between these components and
    the previous chapter's components. It's almost the same thing, so you should have
    an idea about how we could move forward.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了所有的文件，我们准备开始进行代码移植。我们应该能够看到这些组件与上一章的组件之间的某些相似之处。几乎是一样的东西，所以你应该对我们如何继续有一个想法。
- en: We'll start with `WelcomeHeader.js` and then look at each of our files. If you
    were to start up your app right now, you'd see a blank white screen. We'll ignore
    that for now and just sketch our app with some basic static code so that we have
    some sort of a basis for when we begin styling.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`WelcomeHeader.js`开始，然后查看我们的每个文件。如果你现在启动你的应用程序，你会看到一个空白的白屏。我们暂时忽略这一点，只是用一些基本的静态代码来勾勒我们的应用程序，这样当我们开始样式化时，就有一定的基础。
- en: 'Open your file so that we can start adding some new elements. What can we observe
    from the design that we might need inside our component? Well, first of all, there''s
    a lot of **text**, but we also need a **profile picture** (that circle on the
    right-hand side of the component). Knowing this, we can now start importing the
    components needed for this, so go ahead and edit the second line where we''re
    importing the `View` component so that it looks something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的文件，这样我们就可以开始添加一些新元素。我们从设计中可以观察到什么，我们可能需要在我们的组件内部？嗯，首先，有很多**文本**，但我们还需要一个**个人资料图片**（在组件右侧的圆圈）。知道了这些，我们现在可以开始导入所需的组件，所以继续编辑我们导入`View`组件的第二行，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember when we said we should group components if they're on the same line?
    This will make things easier when we begin styling as those components are on
    the same horizontal line.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们说过如果它们在同一行上，我们应该将组件分组吗？当我们开始样式化时，这将使事情变得更容易，因为这些组件在同一水平线上。
- en: 'So, I''ve started by adding another `View` inside our main `View` component.
    After that, I''ll add the components that are sitting on the same line: our welcome
    *message* and our *profile picture*. Beneath this `View` component, we''ll add
    another `Text` component that will render our `Level`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我首先在我们的主`View`组件内添加了另一个`View`。之后，我将添加坐在同一行上的组件：我们的欢迎*消息*和我们的*个人资料图片*。在这个`View`组件下面，我们将添加另一个`Text`组件，它将呈现我们的`Level`：
- en: '![Figure 4.5 – Our static version of WelcomeHeader'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 我们的WelcomeHeader的静态版本'
- en: '](Images/Figure_4.5_B17074.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.5_B17074.jpg)'
- en: Figure 4.5 – Our static version of WelcomeHeader
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 我们的WelcomeHeader的静态版本
- en: In [*Chapter 2*](B17074_02_epub_Final_SB.xhtml#_idTextAnchor045), *Basics of
    React Native*, we discussed how an `Image` needs a source to work. That's why
    we've used the `source` prop and passed a placeholder image link. It's easier
    to use placeholders as we don't need to waste time searching for images when our
    main purpose is to just code a static version for now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B17074_02_epub_Final_SB.xhtml#_idTextAnchor045)，*React Native的基础*中，我们讨论了`Image`需要一个源来工作。这就是为什么我们使用了`source`属性并传递了一个占位图像链接。使用占位符更容易，因为我们不需要浪费时间搜索图像，当我们的主要目的只是编写一个静态版本时。
- en: 'Let''s move on and start coding our next component: `MostPlayedGame`. As we
    can see, here, we need the same things as we did in our previous component. So,
    let''s import everything and use it inside our component. Once you''ve done that,
    we will use our components to display all the information. Now, your code should
    look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并开始编写我们的下一个组件：`MostPlayedGame`。正如我们在之前的组件中所看到的，我们在这里需要与之前的组件相同的东西。所以，让我们导入一切并在我们的组件内使用它。一旦你做到了，我们将使用我们的组件来显示所有信息。现在，你的代码应该是这样的：
- en: '![Figure 4.6 – Our static version of MostPlayedGame'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 我们的MostPlayedGame的静态版本'
- en: '](Images/Figure_4.6_B17074.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.6_B17074.jpg)'
- en: Figure 4.6 – Our static version of MostPlayedGame
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 我们的MostPlayedGame的静态版本
- en: I've written `300` instead of `75` in our placeholder link because that changes
    the width of the image. But beside that, this was pretty easy to understand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我们的占位链接中写了`300`而不是`75`，因为这会改变图像的宽度。但除此之外，这很容易理解。
- en: 'At this point, we''ll notice something really interesting. We have a list that
    follows the same pattern we''re used to. It''s a list of items, and each of those
    items renders a game we''ve played and how much we''ve been playing it. We could
    copy the same pattern we''ve used previously and it would work exceptionally well:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们会注意到一些非常有趣的事情。我们有一个遵循我们习惯的相同模式的列表。这是一个项目列表，每个项目都呈现了我们玩过的游戏以及我们玩了多少。我们可以复制我们以前使用的相同模式，它将工作得非常好：
- en: '![Figure 4.7 – The PlayedGameItem component'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – PlayedGameItem组件'
- en: '](Images/Figure_4.7_B17074.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.7_B17074.jpg)'
- en: Figure 4.7 – The PlayedGameItem component
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – PlayedGameItem组件
- en: 'I''m sure you remember how easy it was to pass `props` from a parent component
    to a child one. We shouldn''t be wasting any time if we already know how certain
    components should be coded. Now, it''s time to create the list, just like we did
    the last time, but now, we have another element inside of it, a `Text` component
    acting as a header for our component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你还记得如何从父组件传递`props`到子组件是多么容易。如果我们已经知道某些组件应该如何编码，我们就不应该浪费任何时间。现在，是时候创建列表了，就像上次一样，但现在，我们在其中有另一个元素，一个`Text`组件作为我们组件的标题：
- en: '![Figure 4.8 – Our finished LastPlayedGameList component'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – 我们完成的LastPlayedGameList组件'
- en: '](Images/Figure_4.8_B17074.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.8_B17074.jpg)'
- en: Figure 4.8 – Our finished LastPlayedGameList component
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 我们完成的LastPlayedGameList组件
- en: We've moved pretty fast but that's because we've already been through this,
    so you should understand what's happening here. The problem with our code right
    now is that we're not sending any information to our items. We don't have that
    array that our `map` function needs to run. As you can see, the array comes from
    `props`, so our `LastPlayedGameList` component is expecting a **prop** called
    `games` with an array so that it can start rendering our list of games.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们走得很快，但那是因为我们已经经历过这个，所以你应该明白这里发生了什么。我们代码目前的问题是我们没有向我们的项目发送任何信息。我们没有`map`函数需要运行的数组。正如你所看到的，数组来自`props`，所以我们的`LastPlayedGameList`组件期望一个名为`games`的**prop**，带有一个数组，这样它就可以开始渲染我们的游戏列表了。
- en: 'Let''s move inside our **Home** screen component and set everything up. First,
    we''ll begin by importing all the components needed for our screen. We only need
    three out of these four components because one of them is `PlayedGameItem`, which
    is already being used and rendered by our `LastPlayedGameList` component. Importing
    them is easy, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的**Home**屏幕组件并设置一切。首先，我们将开始导入屏幕所需的所有组件。我们只需要这四个组件中的三个，因为其中一个是`PlayedGameItem`，它已经被我们的`LastPlayedGameList`组件使用和渲染。导入它们很容易，如下所示：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After importing everything we need, it''s time to place the components in the
    order they''ll appear on the screen, inside our main `View` tag:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入我们需要的一切之后，是时候将组件放置在它们将出现在屏幕上的顺序中，放在我们的主`View`标签内：
- en: '![Figure 4.9 – Our Home component with the rest of the components inside it'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 – 我们的Home组件与其中的其他组件'
- en: '](Images/Figure_4.9_B17074.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.9_B17074.jpg)'
- en: Figure 4.9 – Our Home component with the rest of the components inside it
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 我们的Home组件与其中的其他组件
- en: As you can see, I've already passed the `games` array we need for our list,
    above our component. Let's create an array so that we have something to pass over
    to our `LastPlayedGameList`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我已经传递了我们需要的`games`数组给我们的列表，在我们的组件之上。让我们创建一个数组，这样我们就有东西可以传递给我们的`LastPlayedGameList`。
- en: 'First, try it out for yourself – remember that we need an **array of objects**
    with the `game` and `time` keys. Once you''ve tried this for yourself, come back
    here and take a look at the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，自己尝试一下 - 记住我们需要一个带有`game`和`time`键的**对象数组**。一旦你自己尝试了这个，回到这里看看下面的代码：
- en: '![Figure 4.10 – The games object ready to be sent over to our list component'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – 游戏对象准备发送到我们的列表组件'
- en: '](Images/Figure_4.10_B17074.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.10_B17074.jpg)'
- en: Figure 4.10 – The games object ready to be sent over to our list component
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 游戏对象准备发送到我们的列表组件
- en: That wasn't that hard, right? Here, we've coded our entire static screen. I'm
    pretty sure you should be able to see something popping up on the screen if you
    were to go back to your simulator. If there aren't any errors, then we should
    be able to move on. If you did encounter any errors on the screen or you still
    can't see anything, try to reread everything and make sure you haven't missed
    a word. I'd say 70% of errors are thrown out in the development stage because
    we're usually missing some characters in our variables (don't quote me on that,
    it's just personal experience). JavaScript, being a **loosely typed language**,
    means you don't have to specify what type of information will be stored in a variable,
    so we don't have to worry about defining variables incorrectly as much as a **Java**
    or **C#** developer has to but at the same time, a variable needs to have the
    same name wherever it's used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难，对吧？在这里，我们编写了整个静态屏幕。我相当肯定，如果您回到模拟器，应该能够看到屏幕上弹出了一些东西。如果没有任何错误，那么我们应该可以继续。如果您在屏幕上遇到任何错误，或者仍然看不到任何东西，请尝试重新阅读一切，并确保您没有漏掉任何单词。我会说，70%
    的错误是在开发阶段抛出的，因为我们通常会在变量中漏掉一些字符（不要引用我，这只是个人经验）。JavaScript 作为一种**弱类型语言**，意味着您不必指定变量中将存储什么类型的信息，因此我们不必像**Java**或**C#**开发人员那样担心错误地定义变量，但与此同时，变量在任何地方使用时都需要具有相同的名称。
- en: Now, let's start making it pretty.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始让它变得漂亮起来。
- en: Let's style it!
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来设置样式吧！
- en: Before we start styling our app, we should understand how styling works in React
    Native. If you do have any prior experience with React, you'd know that styling
    is done via CSS. However, in React Native, we can't use CSS, so everything is
    done through the StyleSheet.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为应用程序设置样式之前，我们应该了解 React Native 中的样式工作原理。如果您之前有 React 的经验，您会知道样式是通过 CSS
    完成的。然而，在 React Native 中，我们不能使用 CSS，所以一切都是通过 StyleSheet 完成的。
- en: A StyleSheet was created by the React Native team. Here, you have similar rules
    to CSS but everything is done through JavaScript.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: StyleSheet 是由 React Native 团队创建的。在这里，您有类似 CSS 的规则，但一切都是通过 JavaScript 完成的。
- en: When passing these styling objects over to our components, we do so via a prop
    called `style`. Let's start by directly creating some styles for our **Home**
    screen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当将这些样式对象传递给我们的组件时，我们通过一个名为 `style` 的属性来进行。让我们首先直接为我们的**Home**屏幕创建一些样式。
- en: 'There are two ways we can pass these objects over to our components – we could
    write them directly in our component or pass them via a new instance of the StyleSheet.
    Let''s write it in-line and change our background color for the screen. By going
    over to our `Home.js` file, we can add the `style` prop to the `our <View />`
    component, which wraps the rest of our components:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式将这些对象传递给我们的组件 - 我们可以直接在组件中编写它们，或者通过一个新的 StyleSheet 实例传递它们。让我们在行内编写，并为屏幕更改我们的背景颜色。通过转到我们的
    `Home.js` 文件，我们可以为包裹其余组件的 `<View />` 组件添加 `style` 属性：
- en: '![Figure 4.11 – Adding in-line styling to our component'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 - 为我们的组件添加行内样式'
- en: '](Images/Figure_4.11_B17074.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.11_B17074.jpg)'
- en: Figure 4.11 – Adding in-line styling to our component
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 - 为我们的组件添加行内样式
- en: After adding this and saving the file, you should be able to see how the whole
    background color changes to that hex color. Now, our background color is the same
    as the design image's. This is pretty cool, right? It's also easy to read as this
    is essentially CSS but written a bit differently.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加这个并保存文件后，您应该能够看到整个背景颜色如何改变为该十六进制颜色。现在，我们的背景颜色与设计图像的相同。这很酷，对吧？这也很容易阅读，因为本质上这就是
    CSS，只是写法有点不同。
- en: 'If we were to write CSS, we''d be saying, for example, `background-color: ''red''`,
    but because everything is JavaScript in React Native, we can''t write variables
    or object keys with the dash between characters, so we''re using camel case.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们要编写CSS，我们会说，例如，`background-color: ''red''`，但因为在React Native中一切都是JavaScript，我们无法用破折号在字符之间写变量或对象键，所以我们使用驼峰命名法。'
- en: But there's an issue regarding the in-line styling; we could easily have thousands
    of styles and in that case, we're going to forget where some things are or how
    to change certain things in our app. That's why we should try and use a cleaner
    way of writing styles.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是关于内联样式存在一个问题；我们可能会有成千上万种样式，在这种情况下，我们会忘记一些东西在哪里，或者如何在我们的应用程序中更改某些东西。这就是为什么我们应该尝试使用更清晰的方式来编写样式。
- en: 'Let''s delete our in-line styling and start by changing the import by adding
    `StyleSheet` next to `View`, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除我们的内联样式，并通过在`View`旁边添加`StyleSheet`来更改导入，就像这样：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have imported `StyleSheet`, we''re ready to create some styles.
    To do that, we will use the `.create()` method. This method will return an object
    with all the necessary styling information:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了`StyleSheet`，我们准备创建一些样式。为此，我们将使用`.create()`方法。这个方法将返回一个带有所有必要样式信息的对象：
- en: '![Figure 4.12 – The styles object'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12 - 样式对象'
- en: '](Images/Figure_4.12_B17074.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.12_B17074.jpg)'
- en: Figure 4.12 – The styles object
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 - 样式对象
- en: Right now, we can go back to our `<View />` component and inject the styling
    into our style prop by using `style={styles.container}`. Now, everything should
    look identical to how it looked when we had our inline styling. I'd recommend
    using the `.create()` method to add styles as it's much cleaner and easier to
    read.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到我们的`<View />`组件，并通过使用`style={styles.container}`将样式注入到我们的样式属性中。现在，一切应该看起来和我们内联样式时一样。我建议使用`.create()`方法来添加样式，因为它更清晰，更容易阅读。
- en: Now, you might have some questions regarding `flex`. I mean, you've seen it
    there, but you haven't realized what that property is doing yet. Those questions
    should extend to "Can I use all CSS rules inside React Native just by writing
    them in camel case?"
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会对`flex`有一些疑问。我的意思是，你在那里看到了它，但你还没有意识到那个属性到底在做什么。这些问题应该延伸到“我能通过以驼峰命名法编写所有CSS规则来在React
    Native中使用吗？”
- en: 'The thing is that CSS has two options for the layout: **Grid** and **flexbox**.
    You won''t be able to use Grid inside React Native, though. The whole layout is
    based on flexbox, so you''re able to use all the rules for flexbox.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是CSS有两种布局选项：**网格**和**flexbox**。虽然你无法在React Native中使用网格，但整个布局都是基于flexbox的，所以你可以使用所有flexbox的规则。
- en: You can easily use almost all the rules from CSS in one form or another. If
    there's something that you feel doesn't work if you're writing it in camel case,
    then go ahead and Google up that rule. You'll easily find out how to use almost
    every rule.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以以某种形式轻松地使用CSS中的所有规则。如果有一些你觉得在驼峰命名法中写不起作用的东西，那就去谷歌一下这个规则。你很容易找到如何使用几乎每一个规则。
- en: 'The `flex: 1` rule means "*let the* `<View />` *component take up as much space
    as it can*," so our **Home** screen is now the full width and height of our screen.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex: 1`规则意味着“*让* `<View />` *组件尽可能占据尽可能多的空间*”，所以我们的**主页**现在是屏幕的全宽和全高。'
- en: 'Let''s add some new rules to our container object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的容器对象添加一些新规则：
- en: 'Add `paddingHorizontal: 32` and `paddingVertical: 64`. This will create some
    beautiful breathing space for us to continue styling our components.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加`paddingHorizontal: 32`和`paddingVertical: 64`。这将为我们创建一些美丽的呼吸空间，以便我们继续为我们的组件添加样式。'
- en: Let's start with our `WelcomeHeader` component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的`WelcomeHeader`组件开始。
- en: We'll begin by adding `StyleSheet` to our list of imports and then create the
    `styles` object.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将`StyleSheet`添加到我们的导入列表中，然后创建`styles`对象。
- en: After that, we'll create the `upperSide`, `profilePicture`, `welcomeText`, and
    `levelText` styles.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将创建`upperSide`，`profilePicture`，`welcomeText`和`levelText`样式。
- en: We still can't see our picture, so let's give it a `width` and `height` of `55`.
    To make it round, we'll give it a `borderRadius` of `55/2`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然看不到我们的图片，所以让我们给它一个`宽度`和`高度`为`55`。为了使它变成圆形，我们将给它一个`borderRadius`为`55/2`。
- en: Now, we'll add the `profilePicture` styles to our picture via the `style` prop.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过`style`属性向我们的图片添加`profilePicture`样式。
- en: For our `welcomeText` and `levelText`, we'll need to specify a `fontSize` and
    a color, so let's go ahead and do that too. I'll use `38` for `welcomeText` and
    `18` for `levelText`. The color of our text is going to be set to `'#707070'`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的`welcomeText`和`levelText`，我们需要指定`fontSize`和颜色，所以让我们继续做。我会用`38`作为`welcomeText`的字体大小，`18`作为`levelText`的字体大小。文本的颜色将设置为`'#707070'`。
- en: 'We''ll continue adding rules until our `WelcomeHeader` component looks like
    it does in our design case. Do this on your own initially. Once you''ve done that,
    check out the following code and see if you got something close to what I have
    here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续添加规则，直到我们的`WelcomeHeader`组件看起来像我们设计案例中的样子。一开始你可以自己试试。一旦你做到了，看看下面的代码，看看你是否得到了与我这里类似的东西：
- en: '![Figure 4.13 – Our fully styled WelcomeHeader component'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13 – 我们完全样式化的WelcomeHeader组件'
- en: '](Images/Figure_4.13_B17074.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.13_B17074.jpg)'
- en: Figure 4.13 – Our fully styled WelcomeHeader component
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – 我们完全样式化的WelcomeHeader组件
- en: With that, we've managed to style our `WelcomeHeader` component. I used `justifyContent`
    to push the image and text in opposite directions and I also specified the `flexDirection`
    because, by default, all the components are rendered in a column fashion. However,
    we needed a row for this particular example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们成功地为我们的`WelcomeHeader`组件添加了样式。我使用`justifyContent`将图像和文本推向相反的方向，我还指定了`flexDirection`，因为默认情况下，所有组件都以列的方式呈现。然而，对于这个特定的例子，我们需要一行。
- en: We won't look at styling rules any further here as you might need to discover
    them by yourself through practice. So, my best advice right now would be to just
    go ahead and get creative. Get inspiration from the apps you're using daily and
    create some components that look similar to whatever you picked. Try to recreate
    as many components as you can and see which are visually appealing to you. After
    a while, this will become second nature.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里进一步查看样式规则，因为你可能需要通过练习自己去发现它们。所以，我现在最好的建议就是继续前进，创造一些东西。从你每天使用的应用程序中获得灵感，并创建一些外观类似于你选择的东西的组件。尽量重现尽可能多的组件，并看看哪些对你有视觉吸引力。过一段时间，这将成为你的第二天性。
- en: Don't be upset if you can't remember a certain rule or you can't think of a
    way to style something in a certain way. The truth is, most programmers do forget
    and most of them look up really basic things on Google. The most important thing
    for you right now is not to get upset if something doesn't work but to see that
    as a challenge – a challenge that will 100% improve you as a developer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不住某个规则，或者无法想出某种方式来以某种方式对某个东西进行样式设置，不要沮丧。事实上，大多数程序员都会忘记，他们中的大多数人会在Google上查找非常基本的东西。你现在最重要的事情不是因为某些事情不起作用而感到沮丧，而是把它看作一种挑战——这将百分之百地提高你作为开发者的能力。
- en: 'We''ll stop with the styling part because we''ve already done it for one component,
    and I feel like I could show you something that might change the way you view
    styling. This is something that we''ll start using from now on whenever we start
    creating apps: Galio.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将停止样式部分，因为我们已经为一个组件做了，我觉得我可以向你展示一些可能会改变你对样式的看法的东西。这是我们从现在开始创建应用程序时将开始使用的东西：加里奥。
- en: The superhero, Galio
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级英雄，加里奥
- en: We talked about Galio at the beginning of this book. We discussed why you'd
    want to use it and how exactly it brings value to your app. Now, it's time to
    use it and see what this UI library is all about.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书开头谈到了Galio。我们讨论了为什么要使用它，以及它如何为您的应用程序带来价值。现在，是时候使用它，看看这个UI库到底是什么。
- en: Right now, we need to write a different styles object for each element we're
    using. Galio can help solve that problem by using `props`, which will help you
    style your code as you develop the app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们使用的每个元素编写不同的样式对象。Galio可以通过使用`props`来解决这个问题，这将帮助您在开发应用程序时为您的代码添加样式。
- en: 'Let''s start by installing Galio to our application. For that, we need to go
    to our Terminal and run the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装Galio到我们的应用程序开始。为此，我们需要打开我们的终端并运行以下命令：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will install the latest available version of Galio into our project. Now
    that we've installed Galio, let's import some components from it into our `WelcomeHeader`
    component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装最新可用版本的Galio到我们的项目中。现在我们已经安装了Galio，让我们从中导入一些组件到我们的`WelcomeHeader`组件中。
- en: 'Let''s go to our `import` section and write the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去我们的`import`部分并写下以下内容：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you've written this down and saved your file, then an error will appear.
    That's because we're importing `Text` from both `react-native` and `galio-framework`.
    Delete it from `react-native` and everything should work nicely again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经写下并保存了你的文件，那么会出现一个错误。那是因为我们从`react-native`和`galio-framework`都导入了`Text`。从`react-native`中删除它，一切应该再次正常工作。
- en: Oh well, nothing has changed. This is because the `Text` component from Galio
    is just extending your usual `Text` component. However, it comes packed with new
    props that will allow us to remove certain styles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，好吧，什么都没有改变。这是因为Galio的`Text`组件只是扩展了您通常的`Text`组件。但是，它附带了新的props，可以让我们删除某些样式。
- en: Let's delete the `style` prop on both of our `Text` elements and add `color="#707070"`
    instead. Now, our texts are small but they are the same color, which is cool.
    This means our props are working correctly. If we want to change the font size,
    we just have to add a prop. For our first `Text` element, we'll add `h3`, which
    stands for *Heading 3*, while for our second `Text` element, we'll add `p`, which
    stands for *paragraph*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除我们两个`Text`元素上的`style`属性，并改为添加`color="#707070"`。现在，我们的文本很小，但它们是相同的颜色，这很酷。这意味着我们的props正常工作。如果我们想要改变字体大小，我们只需添加一个prop。对于我们的第一个`Text`元素，我们将添加`h3`，代表*标题3*，而对于我们的第二个`Text`元素，我们将添加`p`，代表*段落*。
- en: Now, if we hit save, we'll see how our **Text** elements suddenly have different
    sizes and everything looks good. We can now remove the unused style objects; that
    is, `welcomeText` and `levelText`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击保存，我们会看到我们的**文本**元素突然有了不同的大小，一切看起来都很好。我们现在可以删除未使用的样式对象；也就是`welcomeText`和`levelText`。
- en: Let's move on and see if we can remove even more. We should replace the `<View
    />` component that wraps our `Text` and `Image` elements with a `Block` component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看是否可以删除更多。我们应该用`Block`组件替换包裹我们的`Text`和`Image`元素的`<View />`组件。
- en: 'Now, let''s add the following props to our newly implemented `Block` element:
    `row` and `space="between"`. Because of this, we can delete the `upperSide` object
    from our `styles` object. Now, everything looks the same but with much less code
    and is easier to notice.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们新实现的`Block`元素添加以下props：`row`和`space="between"`。因此，我们可以从我们的`styles`对象中删除`upperSide`对象。现在，一切看起来都一样，但代码更少，更容易注意到。
- en: A `Block` component is the same as a `View` component but it is packed with
    a lot of props that can make our development process easier.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Block`组件与`View`组件相同，但它包含了许多可以简化我们开发过程的props。'
- en: 'Once we''ve replaced it, let''s replace the other `View` element as well. We
    will also remove it from the imports because we don''t need it anymore:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们替换了它，让我们也替换另一个`View`元素。我们还将从导入中删除它，因为我们不再需要它：
- en: '![Figure 4.14 – Our WelcomeHeader component with newly implemented elements
    from Galio'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14–我们的WelcomeHeader组件，其中包含了新实现的Galio元素'
- en: '](Images/Figure_4.14_B17074.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.14_B17074.jpg)'
- en: Figure 4.14 – Our WelcomeHeader component with newly implemented elements from
    Galio
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14–我们的WelcomeHeader组件，其中包含了新实现的Galio元素
- en: We now understand how Galio works and we'll how much it will help us moving
    forward with this app. So, let's go ahead and start modifying the rest of the
    components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了Galio的工作原理，我们将看到它将如何帮助我们继续开发这个应用。所以，让我们继续开始修改其余的组件。
- en: Let's go into our `MostPlayedGame` component and start importing whatever we
    need from Galio. Again, we need to use `Block` and `Text`. After importing these
    two components, we can remove the `View` and `Text` imports from `react-native`
    as we don't need them anymore. Don't hit save yet as we need to replace the `View`
    element from inside our function with the `Block` element, as we did previously.
    Now, you can go ahead and save your file and you'll see no changes. That's perfect
    – we can now start styling this component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的`MostPlayedGame`组件，并开始从Galio中导入我们需要的任何内容。同样，我们需要使用`Block`和`Text`。在导入这两个组件之后，我们可以从`react-native`中删除`View`和`Text`的导入，因为我们不再需要它们。但是在替换`View`元素之前，不要立即保存，我们需要将函数内部的`View`元素替换为`Block`元素，就像之前一样。现在，您可以继续保存文件，您将看不到任何更改。这很完美–我们现在可以开始为这个组件设置样式了。
- en: 'Let''s go ahead and add the following props to our `Text` component: `size={15}`
    and `color="#707070"`. This will change the font size of our text and also its
    color.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为我们的`Text`组件添加以下props：`size={15}`和`color="#707070"`。这将改变我们文本的字体大小和颜色。
- en: Now, we need to import `StyleSheet` from `react-native` and use it to style
    `Image` so that it can be rendered on our screen. We'll create a new `styles`
    object from our `StyleSheet.create` method and we'll have the `image` object inside
    it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从`react-native`中导入`StyleSheet`并使用它来为`Image`设置样式，以便它可以在我们的屏幕上呈现。我们将使用`StyleSheet.create`方法创建一个新的`styles`对象，并在其中放置`image`对象。
- en: After that, we'll add a `container` object as well so that we can create some
    space between our components. This will be used in our `Block` element.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还将添加一个`container`对象，以便我们可以在组件之间创建一些空间。这将在我们的`Block`元素中使用。
- en: 'Our new `styles` object should look something like this and have the following
    values:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`styles`对象应该看起来像这样，并具有以下值：
- en: '![Figure 4.15 – styles being used for our MostPlayedGame component'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15–用于我们的MostPlayedGame组件的样式'
- en: '](Images/Figure_4.15_B17074.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.15_B17074.jpg)'
- en: Figure 4.15 – styles being used for our MostPlayedGame component
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15–用于我们的MostPlayedGame组件的样式
- en: After writing all this and linking our `styles.container` and `styles.image`
    objects to the proper elements (the `Block` element and the `Image` element),
    we can see that our screen is starting to look more and more like the design we
    saw at the beginning of this chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在写下所有这些并将我们的`styles.container`和`styles.image`对象链接到正确的元素（`Block`元素和`Image`元素）之后，我们可以看到我们的屏幕开始越来越像我们在本章开头看到的设计。
- en: By the way, I've added 4px of `paddingBottom` to our container style just because
    I felt like our `Text` element could have some breathing space. We could've also
    created a new style for `Text` and created some padding around it. There is no
    *right way* of writing styles, so long as its purpose, which is to display what
    you want to have displayed, is respected, so have fun and experiment as much as
    you like.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我在我们的容器样式中添加了4px的`paddingBottom`，只是因为我觉得我们的`Text`元素需要一些呼吸空间。我们也可以为`Text`创建一个新的样式，并在周围创建一些填充。写样式没有*正确的方法*，只要它的目的，也就是显示你想要显示的内容，得到尊重，那么尽情地玩耍和尝试吧。
- en: Don't forget that we're linking our styles to each element via the `style` prop.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们通过`style`属性将样式链接到每个元素。
- en: Oh well – I guess things are getting easier with Galio and styling as we've
    already been through this much, so I'll take a break and let you style the rest
    of the components. Once you've done that, come back to this book and see if we've
    taken the same path by comparing your results with mine. Maybe yours will look
    even better than mine while also having cleaner code and if that's the case, you
    should treat yourself tonight.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，好吧 - 我想随着我们已经经历了这么多，使用Galio和样式变得更容易了，所以我会休息一下，让你来为其余的组件添加样式。一旦你完成了，回到这本书上来，看看我们是否采取了相同的路径，通过比较你的结果和我的结果。也许你的看起来甚至比我的更好，同时代码更清晰，如果是这样的话，你今晚应该奖励自己。
- en: Have you finished? Cool – let's move on! Let's jump to our `LastPlayedGameList`
    component. This should be straightforward, so let's import our `Block` and `Text`
    components from `galio-framework` while also completely removing our imports from
    `react-native`. That's right – we don't need those anymore.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了吗？很好 - 让我们继续吧！让我们跳到我们的`LastPlayedGameList`组件。这应该很简单，所以让我们从`galio-framework`中导入我们的`Block`和`Text`组件，同时完全删除我们从`react-native`中的导入。没错
    - 我们不再需要那些了。
- en: 'We''ll then change the `View` element into a `Block` element. While we''re
    here, let''s add some in-line styling as well; that is, `style={{ marginTop: 32
    }}`. We''ve added that to create more space between our components.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们将把`View`元素改为`Block`元素。在这里，让我们也添加一些内联样式；即`style={{ marginTop: 32 }}`。我们添加了这个来在组件之间创建更多的空间。'
- en: Now, let's go to our `Text` component and add the `color="#707070"` and `size={18}`
    props. And with that, we're done. We've created this component pretty quickly,
    right? Well, styling isn't that hard, especially when Galio is involved.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去我们的`Text`组件，并添加`color="#707070"`和`size={18}`属性。就这样，我们完成了。我们创建了这个组件非常快，对吧？嗯，样式并不难，特别是当涉及到Galio时。
- en: Let's move on to our last component, `PlayedGameItem`. This one will be the
    same thing as the previous one. We'll remove the imports from `react-native` while
    adding the `Block` and `Text` imports from `galio-framework`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的最后一个组件，`PlayedGameItem`。这个将和前一个一样。我们将从`galio-framework`中移除`react-native`的导入，同时添加`Block`和`Text`的导入。
- en: 'Now, let''s replace the `View` element with our new `Block` element and add
    the `row`, `space="between"`, and `style={{ marginTop: 16}}` props to it. After
    that, we''ll add our `color="#707070"` and `size={14}` props to both our `Text`
    elements:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们用我们的新`Block`元素替换`View`元素，并为其添加`row`，`space="between"`和`style={{ marginTop:
    16}}`属性。之后，我们将为我们的两个`Text`元素添加`color="#707070"`和`size={14}`属性：'
- en: '![Figure 4.16 – Our fresh new component after adding Galio and styles'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16 - 在添加Galio和样式后，我们的全新组件'
- en: '](Images/Figure_4.16_B17074.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.16_B17074.jpg)'
- en: Figure 4.16 – Our fresh new component after adding Galio and styles
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 - 在添加Galio和样式后，我们的全新组件
- en: And with that, we've finished. Save your file and take a look at your simulator.
    It looks just like what we wanted. Take a moment to add more character to the
    screen before moving on. Change the pictures to whatever images you'd like to
    see there – maybe add a profile picture and an image of your favorite game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了。保存你的文件，看看你的模拟器。它看起来就像我们想要的样子。在继续之前，花点时间为屏幕增添更多特色。将图片更改为你想要看到的任何图片
    - 也许添加一个个人资料图片和你最喜欢的游戏的图片。
- en: Remember how we used props to pass down information from a **parent component**
    to a **child component**? You can do the same thing and change the name in our
    `WelcomeHeader` or even make it more modular and send all the information from
    the **Home** screen to your components.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们是如何使用props将信息从**父组件**传递到**子组件**的吗？你可以做同样的事情，改变我们的`WelcomeHeader`中的名字，甚至可以更模块化，将所有信息从**Home**屏幕发送到你的组件中。
- en: Now that we've finished styling our app, let's see how we can use it on our
    phones.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对我们的应用进行样式设置，让我们看看如何在我们的手机上使用它。
- en: Let's install it on our phone
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们在手机上安装它
- en: We discussed why Expo is great in [*Chapter 1*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015),
    *Introduction to React Native and Galio*, and I think that the people from Expo
    did a great job at creating that framework. The thing with smartphones is that
    you can't install the app very easily on your phone.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第1章*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015)中讨论了为什么Expo很棒，*React
    Native和Galio的介绍*，我认为Expo的人们在创建这个框架时做得很好。智能手机的问题在于你不能很容易地在手机上安装应用。
- en: Android is a lot more open compared to iOS and you'd probably be able to export
    an `.apk` file into your phone just to have it there. However, iOS doesn't let
    you do that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Android比iOS更开放，你可能可以将一个`.apk`文件导出到你的手机上。然而，iOS不允许你这样做。
- en: Of course, we could use **TestFlight**, which is an Apple service that allows
    you to test and share your app with other testers. But that doesn't help us because
    who would install TestFlight on their phone just to see your one-screen app, especially
    when you need an Apple Developer account?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用**TestFlight**，这是苹果的一个服务，允许你与其他测试人员测试和分享你的应用。但这对我们没有帮助，因为谁会在他们的手机上安装TestFlight来看你的一个屏幕应用，特别是当你需要一个苹果开发者账号时？
- en: Expo offers us a great little app called **Expo Go**. You can find it on both
    **App Store** and **Google Play Store**. Download it and log in or create a new
    account if you don't already have one. Here, you can create a build for your projects
    that can be tested at a later date. By doing this, we can show our friends our
    app without worrying too much about the other obstacles.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Expo为我们提供了一个名为**Expo Go**的小应用。你可以在**App Store**和**Google Play Store**上找到它。下载并登录，或者如果你还没有账号的话就创建一个新账号。在这里，你可以为你的项目创建一个构建，以便以后测试。通过这样做，我们可以向朋友展示我们的应用，而不用太担心其他障碍。
- en: 'Publishing a project on Expo is easy; we just have to follow some steps. Let''s
    close our development server by going into our Terminal and pressing *Ctrl* +
    *C*; then, type `expo signin` and press *Enter*. A message should appear, asking
    you for your username and password. If you still don''t have an account, jump
    over to Expo''s website and create one. After writing down your username and password,
    you should get the following response: **Success. You are now logged in as YOUR-USERNAME**.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Expo上发布项目很容易；我们只需要按照一些步骤。让我们通过进入终端并按下*Ctrl* + *C*来关闭我们的开发服务器；然后，输入`expo signin`并按*Enter*。会出现一条消息，要求你输入用户名和密码。如果你还没有账号，就跳转到Expo的网站上创建一个。在输入用户名和密码后，你应该会得到以下回应：**成功。你现在以YOUR-USERNAME的身份登录**。
- en: Right now, there are two options available for us to use if we want to publish
    our app with Expo. We'll talk about both of them in the following sections as
    errors might happen anytime. If you encounter an error, it's best to just try
    an alternative method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要使用Expo发布我们的应用程序，有两个选项可供我们使用。我们将在接下来的章节中讨论它们，因为错误可能随时发生。如果遇到错误，最好尝试另一种方法。
- en: Publishing via Expo Developer Tools
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Expo开发者工具发布
- en: Now that you've logged in, let's open our server again by typing `expo start`
    into our Terminal and hitting *Enter*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经登录，让我们通过在终端中输入`expo start`并按下*Enter*来再次打开我们的服务器。
- en: 'The development server has started and a new tab containing Expo Developer
    Tools should have loaded in your browser. Remember that in [*Chapter 1*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015),
    *Introducing React Native and Galio*, we showed all the available options; let''s
    click on **Publish or republish project to the internet**:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务器已启动，并且应该在您的浏览器中加载一个包含Expo开发者工具的新选项卡。请记住，在[*第1章*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015)中，*介绍React
    Native和Galio*，我们展示了所有可用的选项；让我们点击**发布或重新发布项目到互联网**：
- en: '![Figure 4.17 – All the information is displayed when we click the Publish
    button'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17 - 单击发布按钮时显示的所有信息'
- en: '](Images/Figure_4.17_B17074.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_4.17_B17074.jpg)'
- en: Figure 4.17 – All the information is displayed when we click the Publish button
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 - 单击发布按钮时显示的所有信息
- en: Now, your app should be published, which means you can go inside your Expo Go
    app on your phone and open your app. See? Easy! Go ahead and show it off to your
    friends!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序应该已经发布，这意味着您可以在手机上的Expo Go应用程序中打开您的应用程序。看？很容易！继续向朋友们展示吧！
- en: Publishing via the Expo CLI
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Expo CLI发布
- en: Now, there may be a possibility that the first option doesn't work for you or
    you encountered an error. Sometimes, errors just happen and it might not even
    be your fault. In that case, stop our development server and write the `expo publish`
    command in the Terminal. A big message will appear, stating that it's going to
    start bundling your app and prepare it for publishing. After a while, you'll see
    that it has been successfully published to Expo.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一种选项可能不适用于您，或者您遇到了错误的可能性。有时，错误就会发生，甚至可能不是您的错。在这种情况下，停止我们的开发服务器，并在终端中输入`expo
    publish`命令。将会出现一条大消息，说明它将开始捆绑您的应用程序并准备发布。过一会儿，您将看到它已成功发布到Expo。
- en: Now, your app is ready to be seen by the world. Well, kind of. You could log
    into your Expo Go app and see your apps under the published projects category
    on your profile tab. The thing is... other people from the internet might see
    it on the Expo website and download it on their computer, but your friends won't
    be able to download the app on their mobile phones. That's because we haven't
    published the app on the official stores. It's not even on a store – it's saved
    in the cloud for other Expo users to see and, of course, for you to have access
    to it any time you want.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序已经准备好向世界展示了。嗯，有点。您可以登录到Expo Go应用程序，然后在个人资料选项卡下的已发布项目类别中查看您的应用程序。问题是……来自互联网的其他人可能会在Expo网站上看到它，并在他们的计算机上下载它，但您的朋友们无法在他们的手机上下载该应用程序。这是因为我们还没有在官方商店上发布该应用程序。它甚至不在商店上
    - 它保存在云端供其他Expo用户查看，当然，您随时都可以访问它。
- en: Congratulations! We've finally created our first complete screen. I hope you're
    feeling good because there's more knowledge to come that will make development
    even easier and a lot more fun!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们终于创建了我们的第一个完整屏幕。我希望您感觉良好，因为还有更多的知识将使开发变得更容易，更有趣！
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've experienced the process of creating a screen for our
    app. We took a design file, looked at it, and recreated the design with no functionality.
    This is a great step in anyone's career as this is your first time finishing an
    app idea. I think you should pat yourself on the back and realize that what you're
    doing here is not that easy. A lot of people would not even try to start learning
    about this, but you've done it. On top of that, you've even created a fully styled
    screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了为我们的应用程序创建屏幕的过程。我们拿到了一个设计文件，看了一下，然后重新设计了没有功能的设计。这对任何人的职业生涯来说都是一个很大的进步，因为这是你第一次完成一个应用想法。我认为你应该给自己鼓掌，并意识到你在这里所做的并不容易。很多人甚至不会尝试开始学习这个，但你做到了。而且，你甚至创建了一个完全样式化的屏幕。
- en: Once we'd learned about styling, Galio came in. We learned how building a layout
    with Galio makes it a lot easier for us. We're still not escaping the styling
    part entirely but we would never be able to not style something. After all, styling
    is fun. By using Galio, we've seen how easy it is to arrange elements and create
    fast prototypes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了样式，Galio就出现了。我们学会了如何使用Galio构建布局，这让我们的工作变得更容易。我们仍然没有完全摆脱样式的部分，但我们永远不可能不给东西加上样式。毕竟，样式是有趣的。通过使用Galio，我们看到了如何轻松地排列元素并创建快速原型。
- en: By the end of this chapter, we looked at two different ways of publishing our
    app idea to Expo Go, a mobile app that helps us play with our project without
    actually pushing it to the store. That's cool and I bet your friends and family
    will be overjoyed with seeing how much progress you're making.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们看了两种不同的发布应用想法到Expo Go的方法，这是一个移动应用程序，可以帮助我们在不实际推送到商店的情况下玩我们的项目。这很酷，我敢打赌你的朋友和家人会因为看到你取得的进展而感到非常高兴。
- en: Now, it's time for us to move on to the next chapter where we will discuss the
    benefits of using Galio.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进入下一章了，我们将讨论使用Galio的好处。
