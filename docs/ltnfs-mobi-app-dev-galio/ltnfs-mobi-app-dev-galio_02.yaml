- en: '*Chapter 2*: Basics of React Native'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：React Native基础知识'
- en: We started by learning about why React Native and Galio form the best combination
    for us to start building our first cross-platform mobile application. After setting
    up our environment and configuring the necessary files, we created our first React
    Native project with Expo and we learned about the different ways we can test the
    app both physically and digitally.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了为什么React Native和Galio形成了最佳组合，可以帮助我们开始构建我们的第一个跨平台移动应用程序。在设置环境并配置必要文件后，我们使用Expo创建了我们的第一个React
    Native项目，并学习了不同的测试应用程序的方法，包括物理和数字化测试。
- en: I believe that learning about the whys before the hows helps build a better,
    more robust knowledge base. Having passed through the whys, it is now time to
    learn about how React Native works and how to use it to create our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信在学习如何之前先了解为什么有助于建立更好、更健壮的知识基础。经过了解为什么，现在是时候学习React Native的工作原理以及如何使用它来创建我们的应用程序了。
- en: That is why we'll start this chapter by going through the file structure of
    our React Native project for us to understand how these files and folders are
    connected. We'll then go through the `App.js` file and explain how this works
    for us as the main entry point into our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们将从我们的React Native项目的文件结构开始这一章，以便我们了解这些文件和文件夹是如何连接的。然后我们将详细介绍`App.js`文件，并解释这对我们作为应用程序的主要入口点是如何工作的。
- en: Once we've learned about the file structure, it is time for us to learn about
    what **JSX** is and how to use it – the skeleton of any React application. We'll
    be comparing JSX to HTML a lot, so you'll have to know a bit of HTML beforehand.
    Rest easy if you don't know much about web development – we'll lay down some HTML
    concepts as well, but learning a bit about it on your own may help you a lot in
    the long run. *Understanding the concept of JSX* is where we'll deal with the
    concept of **components**, a concept we barely touched on in the first chapter.
    This should be completely understood by the end of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了文件结构，就是时候学习**JSX**是什么以及如何使用它了——这是任何React应用程序的骨架。我们将经常将JSX与HTML进行比较，因此您必须事先了解一些HTML。如果您对Web开发了解不多，也不用担心——我们也会介绍一些HTML概念，但自己学习一些可能会对您有所帮助。*理解JSX的概念*是我们将处理**组件**概念的地方，这是我们在第一章中几乎没有涉及的概念。到本章结束时，这应该是完全理解的。
- en: Once we've understood the main concepts of JSX and how it is connected to React
    and React Native, we'll do our first component import. We'll learn what npm/yarn
    is and how to use it for importing and uploading components or libraries on the
    web. This is exciting as you'll see the importance of having a huge community
    backing a framework and how you can participate and make new friends.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了JSX的主要概念以及它与React和React Native的关系，我们将进行我们的第一个组件导入。我们将学习npm/yarn是什么以及如何使用它来导入和上传组件或库到网络上。这是令人兴奋的，因为您将看到拥有一个庞大的社区支持一个框架的重要性，以及您如何参与并结交新朋友。
- en: It is now time to learn about the core components of React Native. We'll understand
    how and in which contexts they're useful while we discuss different ways of improving
    them or even changing them completely. The core components are the base components
    for all the components we'll find online. That means that almost every component
    inherits from the core ones, which makes them important to learn about and understand.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习React Native的核心组件了。我们将了解它们的用途和上下文，并讨论改进它们或完全更改它们的不同方法。核心组件是我们在网上找到的所有组件的基础组件。这意味着几乎每个组件都继承自核心组件，这使得了解和理解它们非常重要。
- en: By the end of this chapter, you'll have learned how to build a component. You'll
    have also learned how to use it in our app or future apps and how to organize
    the files so that you'll never get lost searching for your components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将学会如何构建一个组件。你还将学会如何在我们的应用程序或未来的应用程序中使用它，以及如何组织文件，这样你就永远不会迷失在寻找你的组件中。
- en: I believe that by the end of this chapter, you will be able to start building
    really simple apps that can serve as a stepping stone for building bigger, more
    complex projects. Understanding these concepts doesn't stop at reading this book
    – it goes further than that, and you'll see me always encouraging you to check
    out the official documentation of whatever project/framework we're using as the
    documentation should always be something a programmer should feel comfortable
    reading. Learning to read the documentation is a skill you'll develop in time
    by reading and being as interested as possible in the project you're passionate
    about.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信在本章结束时，你将能够开始构建非常简单的应用程序，这些应用程序可以作为构建更大、更复杂项目的基石。理解这些概念并不仅限于阅读本书 - 它会更进一步，你会看到我一直鼓励你查看我们使用的项目/框架的官方文档，因为文档应该始终是程序员应该感到舒适阅读的东西。学会阅读文档是一个你会通过阅读和对你热衷的项目尽可能感兴趣来发展的技能。
- en: 'This chapter will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using `App.js` – the main entry point
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`App.js` - 主入口点
- en: Understanding the concept of JSX
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JSX的概念
- en: Importing your first component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入你的第一个组件
- en: Core components
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心组件
- en: Understanding and creating a component
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和创建一个组件
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 02` that contains all the code we've written
    inside this chapter. To use that project, please follow the instructions in the
    `README.md` file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问GitHub上的[https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio)来查看本章的代码。你会发现一个名为`Chapter
    02`的文件夹，其中包含我们在本章中编写的所有代码。要使用该项目，请按照`README.md`文件中的说明进行操作。
- en: Using App.js – the main entry point
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用App.js - 主入口点
- en: As we know, React Native is an open source framework used for building iOS and
    Android applications. It uses React to describe the UI while accessing the platform's
    capabilities through the methods we have at our disposal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所知道的，React Native是一个用于构建iOS和Android应用程序的开源框架。它使用React来描述UI，同时通过我们可用的方法访问平台的功能。
- en: Understanding our folder structure is important because we're not supposed to
    touch some of the files– at least at the beginning of our development. Let's take
    a look at our newly created project's structure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们的文件夹结构很重要，因为在开发初期我们不应该触碰一些文件。让我们来看看我们新创建的项目结构。
- en: Tip
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget that you can use any text editor you want to; I'm only using VSCode
    because I like the way it looks and it has lots of plugins that I use, but that
    doesn't mean you can't open up the project with whatever text editor you feel
    comfortable with. Of course, that'll mean you won't be able to use the `code.`
    command as that's only used for VSCode.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记你可以使用任何你喜欢的文本编辑器；我只是使用VSCode是因为我喜欢它的外观，并且它有很多我使用的插件，但这并不意味着你不能用任何你感觉舒适的文本编辑器打开项目。当然，这意味着你将无法使用`code.`命令，因为那只能用于VSCode。
- en: First, let's open our Terminal and navigate to our folder. Now, if we write
    `code.` once we get to the folder, it will open Visual Studio Code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开我们的终端并导航到我们的文件夹。现在，如果我们到达文件夹后写`code.`，它将打开Visual Studio Code。
- en: 'Once our text editor has opened, we will see the following output in the project
    directory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的文本编辑器打开，我们将在项目目录中看到以下输出：
- en: '![Figure 2.1 – Project directory once you open the text editor'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 打开文本编辑器后的项目目录'
- en: '](Images/Figure_2.01_B17074.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.01_B17074.jpg)'
- en: Figure 2.1 – Project directory once you open the text editor
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 打开文本编辑器后的项目目录
- en: As we can see, there are several folders and files here and they're all meant
    to help bundle the project once you finish your app. We'll look at each of these
    folders in the next few sections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里有几个文件夹和文件，它们都旨在在你完成应用程序后帮助捆绑项目。我们将在接下来的几节中查看这些文件夹中的每一个。
- en: The .expo and .expo-shared folders
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .expo和.expo-shared文件夹
- en: 'We''ll start with the folders with a dot in front of them: `.expo` and `.expo-shared`.
    The dot is there to show a hidden file. That''s a file you can''t see directly
    while opening the file browser; you can only see it if you specifically choose
    to see it. Such files are hidden because you don''t need to touch them. They''re
    config files that are created when you first use the `expo start` command.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从带有点的文件夹开始：`.expo`和`.expo-shared`。点在那里是为了显示一个隐藏文件。这是一个你在打开文件浏览器时无法直接看到的文件；只有在你明确选择查看它时才能看到。这些文件是隐藏的，因为你不需要触碰它们。它们是在你第一次使用`expo
    start`命令时创建的配置文件。
- en: The assets folder
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产文件夹
- en: The next folder is the `assets` folder. Inside, you'll find several `.png` images,
    which are used by Expo for the splash screen – the screen that appears while the
    app is loading – and icons for the app to use when it's installed on a device.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的文件夹是`assets`文件夹。在里面，你会找到几个`.png`图像，这些图像是Expo用于启动屏幕的 – 应用程序加载时出现的屏幕 – 以及应用程序在设备上安装时使用的图标。
- en: The node_modules folder
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: node_modules文件夹
- en: Now, you'll see a folder called `node_modules`. If you open that folder, you'll
    be able to see lots and lots of folders. All these folders are packages and **dependencies**
    that we're using to make this app work. Everything that you're installing or bringing
    in from over the internet is going to go straight into this folder. This folder
    is going to get bigger and bigger, depending on how many external packages you'll
    be using for your app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会看到一个名为`node_modules`的文件夹。如果你打开这个文件夹，你会看到很多很多的文件夹。所有这些文件夹都是我们用来使这个应用程序工作的包和**依赖项**。你安装或从互联网引入的所有东西都会直接放入这个文件夹。这个文件夹会随着你为应用程序使用的外部包的数量而变得越来越大。
- en: Once we get past these folders, we've got some files with some interesting features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过这些文件夹，我们会发现一些具有一些有趣特征的文件。
- en: The files within
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件内部
- en: First, we can see `.gitignore`, which helps us save size when uploading on GitHub.
    If you open the file, you'll see there's already some text written in it. Everything
    you see in there will be ignored once you upload your project on GitHub. You'll
    find that `.expo` is there because those folders are only relevant for the programmer
    and they're not intended for sharing. You can edit this file by using any filename
    you don't want to move over to online or you don't intend on changing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到`.gitignore`，它可以帮助我们在GitHub上上传时节省空间。如果你打开这个文件，你会看到里面已经写了一些文字。一旦你上传项目到GitHub，你在里面看到的所有东西都会被忽略。你会发现`.expo`在那里，因为那些文件夹只对程序员有用，不打算共享。你可以通过使用任何你不想转移到在线或者你不打算更改的文件名来编辑这个文件。
- en: Important Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: GitHub is a platform that acts like an internet hosting company for open source
    software programs while also providing the programmer with version control using
    Git. Developers are using Git to track changes in their projects and coordinating
    with their teammates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是一个像互联网托管公司一样为开源软件程序提供服务的平台，同时还使用Git为程序员提供版本控制。开发人员使用Git来跟踪他们项目中的变化，并与他们的团队协调。
- en: For now, we'll ignore `App.js` because we'll explain this file at the end of
    this section. So, let's go directly to the `app.json` file. This file acts like
    a config file for your app – basically, everything that's not code-related will
    be found there. Let's say, for example, we want to change the image of our splash
    screen. We don't have any way of doing that besides going into this file and editing
    the splash image's path. From here, you can change almost everything related to
    your application, such as the icon or its orientation. You'll see yourself going
    there quite a lot, configuring your app for the final release version.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们会忽略`App.js`，因为我们将在本节末尾解释这个文件。所以，让我们直接转到`app.json`文件。这个文件就像是你的应用程序的配置文件
    - 基本上，所有与代码无关的东西都会在那里找到。比如，例如，我们想要更改启动画面的图片。除了进入这个文件并编辑启动图片的路径之外，我们没有其他办法。从这里，你可以改变几乎与你的应用程序相关的一切，比如图标或其方向。你会发现自己经常去那里，为最终发布版本配置你的应用程序。
- en: We don't care about `babel.config.js` but I'm pretty sure you'd be curious about
    that one as well. Babel is a JavaScript compiler almost everyone is using to get
    access to the latest standards of JavaScript. It's not necessary to edit this
    file but if you want to learn more about compilers, I recommend searching for
    more information about Babel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不关心`babel.config.js`，但我相信你对那个文件也会感到好奇。Babel是一个几乎每个人都在使用的JavaScript编译器，用于获得对JavaScript最新标准的访问权限。编辑这个文件并不是必要的，但如果你想了解更多关于编译器的信息，我建议搜索更多关于Babel的信息。
- en: The last two files are `package-lock.json` and `package.json`. The first one
    always gets created when you're using npm to install dependencies in your project.
    I've already told you that we'll learn about npm in this chapter, but not right
    now. Right now, I want you to become familiar with all the files in the project
    directory. By creating your app via the command line, Expo automatically used
    npm to bring lots of files you'd use in your project over the internet. Those
    files are stored in the `node_modules` folder. You can find out more about all
    the direct dependencies that you're using in `package.json`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个文件是`package-lock.json`和`package.json`。当你在项目中使用npm安装依赖时，第一个文件总是会被创建。我已经告诉过你，我们将在本章学习npm，但现在不是时候。现在，我希望你熟悉项目目录中的所有文件。通过命令行创建应用程序时，Expo自动使用npm从互联网上获取了许多你在项目中会使用的文件。这些文件存储在`node_modules`文件夹中。你可以在`package.json`中找到更多关于你正在使用的所有直接依赖项的信息。
- en: Now that we've finally got to the end of all the files, we should start talking
    about `App.js`. So, let's open that file and take a look at it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于到了所有文件的末尾，我们应该开始讨论`App.js`。所以，让我们打开那个文件，看看它。
- en: The App.js file
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App.js文件
- en: 'Upon opening the `App.js` file, you will see the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`App.js`文件后，你会看到以下内容：
- en: '![Figure 2.2 – Code in the App.js file'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - App.js文件中的代码'
- en: '](Images/Figure_2.02_B17074.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.02_B17074.jpg)'
- en: Figure 2.2 – Code in the App.js file
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - App.js文件中的代码
- en: You can immediately see the **Open up App.js to start working on your app!**
    text. I'm pretty sure you remember but in the previous chapter, when we tested
    our app, this was the text that appeared on the center of the screen. This means
    that by changing the text, we should also see a change in our app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看到**打开App.js开始工作你的应用程序！**文本。我相信你记得，在上一章中，当我们测试我们的应用程序时，这就是出现在屏幕中央的文本。这意味着通过更改文本，我们也应该在我们的应用程序中看到变化。
- en: We won't do that right now as our focus is understanding the files and code,
    and then changing it to our liking.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会这样做，因为我们的重点是理解文件和代码，然后根据自己的喜好进行更改。
- en: I'm pretty sure you connected the dots after seeing this file and realized that
    this is the entry point of our app. An entry point is the main file that connects
    all the files and starts the application. Our main function for using Expo is
    the `App()` function. Your entire application will be living inside that function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我相当肯定，在看到这个文件后，你已经连接了其中的内容，并意识到这是我们应用的入口点。入口点是连接所有文件并启动应用程序的主文件。我们使用Expo的主要函数是`App()`函数。整个应用程序将存在于该函数内。
- en: The reason you saw the centered text when you opened the app was because the
    text is inside the `App()` function. Here, we'll start building our app. For that
    to happen, we must understand what JSX is and how to use it inside our app. I'm
    assuming you can already read a bit of JavaScript and you understand notions such
    as functions and objects; we won't be covering this topic in this book. We'll
    get to grips with JSX in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开应用程序时看到居中的文本，原因是文本位于`App()`函数内。在这里，我们将开始构建我们的应用程序。为了实现这一点，我们必须理解JSX是什么，以及如何在我们的应用程序中使用它。我假设你已经能够阅读一些JavaScript，并且理解诸如函数和对象之类的概念；我们不会在本书中涉及这个主题。我们将在下一节中掌握JSX。
- en: Understanding the concept of JSX
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JSX的概念
- en: We've finally got here, we're now ready to look over JSX and learn how to use
    it inside our apps. React is heavily dependent on JSX as it's the main way of
    building the layout for our apps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了这里，现在准备好审查JSX并学习如何在我们的应用程序中使用它。React非常依赖于JSX，因为这是构建应用程序布局的主要方式。
- en: 'First, we''ll take a look at a variable containing some JSX code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一个包含一些JSX代码的变量：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This weird-looking syntax looks kind of familiar, right? It looks like **HTML**.
    I'm pretty sure you have seen what HTML code looks like at least once. If you
    haven't, go ahead and open your favorite browser and go to something like [https://reactnative.dev](https://reactnative.dev).
    Once you get there, right-click anywhere on the website and then left-click **Inspect**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看起来很奇怪的语法看起来有点熟悉，对吧？它看起来像**HTML**。我相当肯定你至少见过一次HTML代码是什么样子。如果你还没有，那就打开你最喜欢的浏览器，然后转到[https://reactnative.dev](https://reactnative.dev)之类的网站。一旦你到达那里，右键单击网站的任何位置，然后左键单击**检查**。
- en: Once you've done that, you'll see lots and lots of HTML code. Randomly clicking
    on any of those HTML elements will take you to that specific element on the website.
    So, as you can see, HTML is a language that describes the way things should look,
    or more correctly, it semantically defines what each element is for the browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做到了，你会看到大量的HTML代码。随机点击其中任何一个HTML元素都会带你到网站上的特定元素。所以，你可以看到，HTML是一种描述事物应该如何看起来的语言，或者更准确地说，它语义地定义了每个元素对于浏览器来说是什么。
- en: We don't use HTML with React/React Native, though. Instead, we use something
    called **JavaScript XML** (**JSX**).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们在React/React Native中不使用HTML。相反，我们使用一种叫做**JavaScript XML**（**JSX**）的东西。
- en: JSX is an extension to JavaScript that allows us to write HTML elements in JavaScript.
    The thing is, React Native doesn't even use the HTML part of JSX. It just uses
    its syntax because it makes things easier to observe and read. It is also based
    on React, so it's kind of obvious that it is going to be pretty similar in terms
    of writing code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是JavaScript的扩展，允许我们在JavaScript中编写HTML元素。事实上，React Native甚至不使用JSX的HTML部分。它只是使用它的语法，因为这样更容易观察和阅读。它也是基于React的，所以很明显它在编写代码方面会非常相似。
- en: I feel like just by reading the preceding JSX code, we can easily understand
    what's going on there. It's supposed to be a text with a message stating "*Hi,
    this is a message*."
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得仅仅通过阅读前面的JSX代码，我们就可以很容易地理解那里发生了什么。它应该是一个带有消息“*嗨，这是一条消息*”的文本。
- en: We all know that "**text**" isn't the correct tag to be used in HTML because
    it doesn't exist. We are calling it **text** here because this is a React Native
    **component**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道在HTML中“**text**”不是要使用的正确标记，因为它不存在。我们在这里称之为**text**，因为这是一个React Native **组件**。
- en: Great! So, it's finally time to touch on components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！所以，现在终于是时候涉及组件了。
- en: Discovering components
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现组件
- en: 'Components are – simply put – just JavaScript functions. So, we can write something
    like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 组件只是JavaScript函数。因此，我们可以这样写：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is called a component because it returns a JSX element. We'll
    talk about **props** later, but they are really important because any component
    can receive a props argument inside their function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被称为组件，因为它返回一个JSX元素。我们稍后会讨论**props**，但它们非常重要，因为任何组件都可以在其函数内部接收一个props参数。
- en: Defining a component is easy but its usage is incredibly important. This allows
    us to create as many components as possible, and they can be as different as we
    like. This is because it clears our code out and makes things easier to organize.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个组件很容易，但它的使用非常重要。这使我们能够创建尽可能多的组件，它们可以是我们喜欢的任何样子。这是因为它清除了我们的代码，并使事情更容易组织。
- en: Let's take a look at the code we've found in the `App.js` file. Try and observe
    the way the `App()` function looks. The only thing it does is return a big stack
    of JSX elements. In this case, we can even call this function a component and
    we could write it off as a JSX tag.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在`App.js`文件中找到的代码。试着观察`App()`函数的样子。它唯一要做的就是返回一大堆JSX元素。在这种情况下，我们甚至可以将这个函数称为一个组件，并且我们可以将其视为一个JSX标记。
- en: Expo is using this component to start your app, which means that your React
    Native application is just a big component that encapsulates all the other components
    you're going to write.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Expo正在使用此组件来启动您的应用程序，这意味着您的React Native应用程序只是一个封装了您将要编写的所有其他组件的大组件。
- en: What I meant by using this component as a JSX tag is that if, for some reason,
    we'd like to take this component and use it in a different part of our app, we
    could easily just go to the file where we need it and write `<App />` inside the
    stack. Then, everything that's inside the `App()` function will get rendered.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的通过将此组件用作JSX标记是，如果出于某种原因，我们想将此组件带到应用程序的不同部分中，我们可以轻松地转到需要它的文件并在堆栈中写入`<App
    />`。然后，`App()`函数中的所有内容都将被呈现。
- en: Let's try and use one of the already existent components in our only `App.js`
    file. We know `<Text>` is an already-defined component that's being used because
    we saw it work when we first tested our app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在我们唯一的`App.js`文件中使用一个已经存在的组件。我们知道`<Text>`是一个已经定义的组件，因为当我们第一次测试我们的应用程序时，我们看到它起作用了。
- en: You should already have the project and terminal open. Let's go ahead and write
    `expo start` in our terminal so that the server will start booting up.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经打开了项目和终端。让我们继续在终端中写入`expo start`，这样服务器就会开始启动。
- en: A new window will open in your browser, just like in the previous chapter. Click
    **Run on…** and pick the simulator that you want to use (or use your physical
    device if that's easier for you). We've already discussed how to run the app,
    so if something seems a bit hard to understand, please go back to [*Chapter 1*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015),
    *Introduction to React Native and Galio*, to refresh your memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的窗口将在您的浏览器中打开，就像在上一章中一样。点击**Run on…**并选择您想要使用的模拟器（或者如果对您来说更容易，可以使用您的物理设备）。我们已经讨论了如何运行应用程序，所以如果有什么东西似乎有点难以理解，请回到[*第1章*](B17074_01_epub_Final_SB.xhtml#_idTextAnchor015)，*React
    Native和Galio简介*，以刷新您的记忆。
- en: Now that the app is alive and well on your device, we're seeing the basic screen
    we've already seen. Let's change it a bit by removing the text between the `<Text>`
    tags and replacing it with something else. Write your name in there; I'm going
    to do the same.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序在您的设备上运行良好，我们看到的是我们已经看到的基本屏幕。让我们通过删除`<Text>`标签之间的文本并用其他内容替换来稍微改变一下。在那里写上你的名字；我也会这样做。
- en: 'So, right now, we have the following line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在，我们有以下行：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, it should look something like this (but with your name instead
    of mine):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，它应该看起来像这样（但是用您的名字代替我的）：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After doing that, go to the end of the line and press *Enter*. A new line will
    be created, so let's add something to make this starting app feel more like something
    personal, something that's ours.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，转到行的末尾并按*Enter*。将创建一个新行，所以让我们添加一些内容，使这个起始应用程序感觉更像是个人的东西，是我们自己的东西。
- en: 'We should add some more text describing our age and hometown. Your `App()`
    function should now look something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加一些描述我们年龄和家乡的文本。您的`App()`函数现在应该看起来像这样：
- en: '![Figure 2.3 – Your recently modified code'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3-您最近修改的代码'
- en: '](Images/Figure_2.03_B17074.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.03_B17074.jpg)'
- en: Figure 2.3 – Your recently modified code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3-您最近修改的代码
- en: Now, save the file you've modified (usually by hitting *Ctrl* + *S* or *cmd*
    + *S*) and you'll suddenly observe something cool. Once you've done this, the
    code automatically changed on your simulator/physical device.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存您修改过的文件（通常通过按下*Ctrl* + *S*或*cmd* + *S*），您会突然观察到一些很酷的东西。一旦您这样做了，代码会自动在您的模拟器/物理设备上更改。
- en: This is so great, right? Usually, you'd have to restart the server, but we didn't
    have to do anything more than save the file we've been editing. This is called
    **hot reload** and is a great feature that comes packed with React Native.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了，对吧？通常，您需要重新启动服务器，但我们只需要保存我们一直在编辑的文件。这被称为**热重载**，是React Native自带的一个很棒的功能。
- en: Since we've added a new `Text` component inside our `App` function, you've probably
    guessed that we need to take this component from somewhere. You can't use a component
    without having it imported into your file first. So, let's learn how to do this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在我们的`App`函数中添加了一个新的`Text`组件，您可能已经猜到我们需要从某个地方获取这个组件。您不能在文件中使用组件而没有先导入它。所以，让我们学习如何做到这一点。
- en: Importing your first component
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入您的第一个组件
- en: Now, it's time for us to learn more about importing components. Importing is
    great because we can grab components from anywhere and use them in our app. I
    mean it – you could grab a component from anywhere on the internet.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候让我们更多地了解导入组件了。导入很棒，因为我们可以从任何地方获取组件并在我们的应用程序中使用它们。我的意思是-您可以从互联网的任何地方获取组件。
- en: First, let's see how the `Text` component we've been using got into our `App.js`
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们一直在`App.js`文件中使用的`Text`组件是如何进入的。
- en: 'If we look above the `App()` function, we will see that the first lines of
    code are all imports of different components. Let''s take a look at those and
    see if they''re that complicated:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`App()`函数上面，我们会看到代码的第一行都是不同组件的导入。让我们看看它们是否那么复杂：
- en: '![Figure 2.4 –  Imports displayed in the App.js file'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4-在App.js文件中显示的导入'
- en: '](Images/Figure_2.04_B17074.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.04_B17074.jpg)'
- en: Figure 2.4 – Imports displayed in the App.js file
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4-在App.js文件中显示的导入
- en: It's pretty easy to read and to understand what exactly is going on here. Let's
    take the first line, for example. We're **importing** `StatusBar` **from** a **package**
    called `expo-status-bar`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易阅读和理解这里到底发生了什么。让我们以第一行为例。我们从名为`expo-status-bar`的**包**中**导入**`StatusBar`。
- en: Why are we're doing that? In our `App()` function, you'll see that we've used
    a component called `StatusBar`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要这样做？在我们的`App()`函数中，您会看到我们使用了一个名为`StatusBar`的组件。
- en: For us to be able to use a specific component, we'll need to import it from
    a package or a defined path inside our project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用特定组件，我们需要从软件包或项目内的定义路径中导入它。
- en: We can see an import from **React** but we can't find the React component anywhere
    inside our code; why is that? This is mostly because we need React to be able
    to use the React framework while creating all those components and writing JSX.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到来自**React**的导入，但我们在代码中找不到React组件；为什么呢？这主要是因为我们需要React来能够在创建所有这些组件和编写JSX时使用React框架。
- en: Underneath, we can see there are three different imports from a package called
    `react-native`. We can see `StyleSheet`, `Text`, and `View`. React Native comes
    packed with a lot of basic but really important implementations of native code
    for us to use in our React app.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，我们可以看到有三个来自名为`react-native`的软件包的不同导入。我们可以看到`StyleSheet`，`Text`和`View`。React
    Native内置了许多基本但非常重要的本地代码实现，供我们在React应用程序中使用。
- en: We'll look at these core components in more detail in the next section, but
    you must understand the fact that those components were imported and then used
    inside our main function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节更详细地查看这些核心组件，但您必须了解这样一个事实，即这些组件被导入然后在我们的主函数中使用。
- en: You can find *packages* online, so you could import them into your files easily
    by using **npm**. This is already installed with your Node.js configuration, so
    it's ready to use right now. We can search for packages on [https://npmjs.com](https://npmjs.com)
    and easily install any of them with the `npm i package-name` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上找到*软件包*，因此您可以通过使用**npm**轻松将它们导入到您的文件中。这已经与您的Node.js配置一起安装好了，所以现在就可以使用了。我们可以在[https://npmjs.com](https://npmjs.com)上搜索软件包，并使用`npm
    i package-name`命令轻松安装其中任何一个。
- en: Right now, we'll focus on the components we received from `react-native`. We'll
    install more components in the following chapters but first, we need to learn
    how to use what we already have at our disposal and how we can build on top of
    that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于我们从`react-native`中收到的组件。我们将在接下来的章节中安装更多组件，但首先，我们需要学习如何使用我们已经拥有的东西，以及如何在此基础上构建。
- en: Let's start by importing some of the most important components and use them
    inside of our app. So, let's go to the third line in our `App.js` file. Between
    those brackets where we've imported `StyleSheet`, `Text`, and `View`, we'll add
    the `Image`, `TextInput`, and `Button` components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入一些最重要的组件并在我们的应用程序中使用它们开始。因此，让我们转到我们的`App.js`文件中的第三行。在我们导入`StyleSheet`，`Text`和`View`的大括号之间，我们将添加`Image`，`TextInput`和`Button`组件。
- en: 'Now, our line will look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的行将如下所示：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's try to understand what the purpose of each component is and how we can
    use them inside our application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解每个组件的目的以及我们如何在应用程序中使用它们。
- en: Core components
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心组件
- en: 'We need to understand all the basic components before we can move on. This
    will help us realize how to mix them so that we can create even bigger and more
    complex components. This will also make things easier when we''re planning our
    app. In [*Chapter 4*](B17074_04_epub_Final_SB.xhtml#_idTextAnchor070), *Your First
    Cross-Platform App*, we''ll create a functional app for us to be proud of and
    our friends to look up to. The following list shows the core components:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要了解所有基本组件。这将帮助我们意识到如何混合它们，以便我们可以创建更大更复杂的组件。这也将使我们在规划应用程序时更容易。在[*第4章*](B17074_04_epub_Final_SB.xhtml#_idTextAnchor070)，*您的第一个跨平台应用程序*中，我们将创建一个功能齐全的应用程序，让我们为之自豪，让我们的朋友仰慕。以下列表显示了核心组件：
- en: '**View**:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：'
- en: 'So, let''s start by discussing the most important component in React Native:
    **View**. This component is the fundamental of all components. The `View` component
    is so important because you cannot build a UI without it. Acting like a container
    for other components, this is your best bet if you want to style something differently
    or arrange the layout in a specific way.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始讨论React Native中最重要的组件：**View**。这个组件是所有组件的基础。`View`组件非常重要，因为没有它，你无法构建UI。作为其他组件的容器，如果你想以特定的方式进行样式设置或布局排列，这是你最好的选择。
- en: 'Let''s see a basic example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本的例子：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Text**:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Text**：'
- en: We've already used this component and it's pretty straightforward. We can use
    this component to display text on the screen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了这个组件，它非常直接了当。我们可以使用这个组件在屏幕上显示文本。
- en: 'Let''s see a basic example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本的例子：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Image:**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Image**：'
- en: This is cool because it allows us to display an image and style it the way we
    want to..
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，因为它允许我们显示一张图片并按照我们想要的方式进行样式设置。
- en: 'Let''s see a basic example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本的例子：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**StyleSheet**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StyleSheet**'
- en: We can find an example of how this component is used by looking at our `App.js`
    file again. It creates a stylesheet similar to CSS but with fewer styling rules.
    It's really easy to use once you understand it, and we'll go further into styling
    once we get to our first practical challenge, where we'll create and style our
    very own first screen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过再次查看我们的`App.js`文件找到这个组件的使用示例。它创建了一个类似于CSS但具有更少样式规则的样式表。一旦你理解了它，就会发现它真的很容易使用，一旦我们到达我们的第一个实际挑战，我们将创建和设计我们自己的第一个屏幕时，我们将进一步进行样式设置。
- en: 'Let''s see a basic example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本的例子：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**TextInput**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TextInput**'
- en: This is a component that was created for inputting text into the app using the
    keyboard. It is packed with all the necessary methods you'd want from an input,
    such as `onSubmitEditing` and `onFocus`. Don't worry – we'll use all of these
    when we need them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于使用键盘将文本输入到应用程序中的组件。它包含了您希望从输入中获得的所有必要方法，比如`onSubmitEditing`和`onFocus`。别担心
    - 当我们需要时，我们会使用所有这些方法。
- en: 'Let''s see a basic example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本的例子：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Button**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Button**'
- en: This component renders a basic button that handles touches.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件渲染一个处理触摸的基本按钮。
- en: 'Let''s see a basic example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本的例子：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I'm pretty sure you've noticed some of these components have another word inside
    their tags. For example, for our `Image` component, we have the word "source,"
    which grabs the link we're giving to know what image to display. That word is
    called a **prop**, and we'll learn more about them in the next chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我相当肯定你已经注意到一些这些组件在它们的标签内有另一个单词。例如，对于我们的`Image`组件，我们有单词“source”，它获取我们提供的链接以知道要显示哪个图像。那个词叫做**prop**，我们将在下一章中更多地了解它们。
- en: Before moving on, let's use the examples we have here for `Button` and `TextInput`
    in our app. We're doing this for practice and to get used to what things look
    like on our devices once we use these components.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们在我们的应用程序中使用这里的`Button`和`TextInput`的示例。我们这样做是为了练习，并且在使用这些组件后，习惯于在我们的设备上看到的东西。
- en: 'Let''s go and write some code displaying our age and hometown underneath our
    `Text` component using the examples we have for `TextInput` and `Button`. Now,
    the main function will look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去编写一些代码，在我们的`Text`组件下面显示我们的年龄和家乡，使用我们为`TextInput`和`Button`的示例。现在，主要函数将如下所示：
- en: '![Figure 2.5 – Your new code after importing and using the new components'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 - 导入和使用新组件后的新代码'
- en: '](Images/Figure_2.05_B17074.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.05_B17074.jpg)'
- en: Figure 2.5 – Your new code after importing and using the new components
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 导入和使用新组件后的新代码
- en: 'Now, let''s hit refresh and look at our simulator/physical device. We''ll see
    two new things: an input that, if pressed, opens a keyboard where you can write
    things, and a blue button with text written in uppercase.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们刷新并查看我们的模拟器/物理设备。我们会看到两个新的东西：一个输入框，如果按下，会打开一个键盘，您可以在其中写东西，以及一个蓝色的按钮，上面写着大写字母的文本。
- en: We haven't used the `Image` component yet as it requires styling for it to work.
    It needs to be told what size the image should be. We'll look at styling in more
    detail in the next chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用`Image`组件，因为它需要样式才能工作。它需要告诉图像应该是什么大小。我们将在下一章更详细地讨论样式。
- en: At this point, we've talked about all these components in a bit more detail
    and explained what the purpose for each one is. These are all **core components**
    because they deal with hardware capabilities and they need **native code** to
    run. By native code, we mean code written in Swift or Java for iOS or Android.
    Developers are building and styling components that inherit from these.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经稍微详细地讨论了所有这些组件，并解释了每个组件的目的是什么。这些都是**核心组件**，因为它们涉及硬件功能，并且它们需要**本地代码**来运行。通过本地代码，我们指的是为iOS或Android编写的Swift或Java代码。开发人员正在构建和设计从这些组件继承的组件。
- en: Next, we'll learn how to create components and how to organize our files so
    that we'll never forget where to import from.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建组件以及如何组织我们的文件，以便我们永远不会忘记从哪里导入。
- en: Understanding and creating your own component
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并创建您自己的组件
- en: 'We''re getting closer to our goal: creating a cross-platform mobile app. For
    this to become a reality, we need to learn how to create components.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离我们的目标越来越近：创建一个跨平台的移动应用程序。为了使这成为现实，我们需要学习如何创建组件。
- en: First, let's create a new folder in our project's main directory and call it
    `components`. Here, we'll create a new file named `PersonalInformation.js`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在项目的主目录中创建一个新文件夹，并将其命名为`components`。在这里，我们将创建一个名为`PersonalInformation.js`的新文件。
- en: This folder will serve as a safe space for all our components to live in, a
    place where we can always import our components, just like we'd normally do with
    any package we'd find online.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹将作为所有我们组件的安全空间，一个我们可以随时导入我们组件的地方，就像我们通常会在网上找到的任何包一样。
- en: So, we've already talked about how components are created – they're JavaScript
    functions that return a bunch of JSX code. However, what I haven't told you is
    that these components are called **functional components** and that there are
    different types of components out there.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经讨论了组件是如何创建的 - 它们是返回一堆JSX代码的JavaScript函数。但是，我还没有告诉你这些组件被称为**功能组件**，并且那里有不同类型的组件。
- en: Let's build our first functional component by writing all the necessary code
    inside our newly created file. We'll create a component whose main purpose will
    be to display our already written personal information on the screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在新创建的文件中编写所有必要的代码来构建我们的第一个功能组件。我们将创建一个组件，其主要目的是在屏幕上显示我们已经编写的个人信息。
- en: 'We''ll begin by writing our necessary imports. So, for this component, we know
    we need a `Text` component. Let''s go ahead and import that. Write the following
    at the beginning of your file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写我们需要的导入。因此，对于这个组件，我们知道我们需要一个`Text`组件。让我们继续导入。在文件开头写入以下内容：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've imported React because, as I mentioned earlier in this chapter, we need
    it if we want to create components and use JSX. Because that's the most important
    and basic import, we're going to place it at the beginning of our code. After
    that, we imported the `Text` component from React Native.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了React，因为正如我在本章前面提到的，如果我们想要创建组件并使用JSX，我们需要它。因为这是最重要和基本的导入，我们将把它放在我们代码的开头。之后，我们从React
    Native导入了`Text`组件。
- en: Creating the function
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数
- en: 'Let''s continue and write our functional component now, just like we learned
    earlier:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写我们的功能组件，就像我们之前学到的那样：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Earlier, we mentioned that we need it to display the same information we did
    previously (our name, age, and hometown) but I haven't written anything like that.
    That's because we've run into our first problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到我们需要它来显示我们之前所做的相同信息（我们的姓名，年龄和家乡），但我还没有写过类似的东西。那是因为我们遇到了我们的第一个问题。
- en: 'Let''s say we try to write something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试写这样的东西：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we''ll see a bunch of red lines underneath our code. That''s because
    JSX doesn''t allow two tags to be next to each other if they''re not encapsulated
    in a bigger tag. This is where `View` comes in handy. So, let''s import that as
    well. Our second line of code will now look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们会看到一堆红线在我们的代码下面。那是因为JSX不允许两个标签挨在一起，如果它们没有封装在一个更大的标签中。这就是`View`派上用场的地方。所以，让我们也导入它。我们的第二行代码现在会是这样的：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because we now have the `View` component, we can write our function with it
    while encapsulating our `Text` components, like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在有了`View`组件，我们可以在其中编写我们的函数，同时封装我们的`Text`组件，就像这样：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With that, we've successfully created our first component. But why did we write
    the same thing? We already had this information in our main `App.js` file. We're
    doing this to understand why components are so cool.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们成功地创建了我们的第一个组件。但为什么我们要写相同的东西呢？我们已经在我们的主`App.js`文件中有了这些信息。我们这样做是为了理解为什么组件是如此酷。
- en: Exporting and importing our component
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出和导入我们的组件
- en: 'Before we move to the main file, we''ll have to be able to **import** this.
    We can''t do this before we **export** it. Makes sense, right? Let''s go ahead
    and add the following line to the top of the file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转到主文件之前，我们必须能够**导入**它。在我们**导出**它之前，我们不能这样做。有道理，对吧？让我们继续在文件顶部添加以下行：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, your code should look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的代码应该是这样的：
- en: '![Figure 2.6 –  The code we''ve written in our PersonalInformation.js file'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 - 我们在PersonalInformation.js文件中编写的代码'
- en: '](Images/Figure_2.06_B17074.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.06_B17074.jpg)'
- en: Figure 2.6 – The code we've written in our PersonalInformation.js file
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 - 我们在PersonalInformation.js文件中编写的代码
- en: 'If everything looks correct, save the file and move to `App.js` so that we
    can look at the most useful features of components: **reusability** and **readability**.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来正确，保存文件并转到`App.js`，这样我们就可以看看组件最有用的特性：**可重用性**和**可读性**。
- en: 'Now that we''re in `App.js`, let''s delete what we already have in our custom-made
    component – I''m talking about the `Text` components that are displaying our personal
    information. After deleting those, we can import our new component. Importing
    this should be easy if you''ve followed along so far – you just have to go underneath
    your last import and add another line. There, you''ll import your component, like
    this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`App.js`中，让我们删除我们自定义组件中已经有的东西 - 我说的是显示我们个人信息的`Text`组件。删除这些之后，我们可以导入我们的新组件。如果你迄今为止一直跟着做，那么导入这个应该很容易
    - 你只需要在最后一个导入的下面添加另一行。在那里，你将导入你的组件，就像这样：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's use this component instead of the already removed `Text` components
    we had previously. This is as easy as writing `<PersonalInformation />`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个组件来代替之前已经移除的`Text`组件。这就像写`<PersonalInformation />`一样简单。
- en: 'Now, your code should look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的代码应该是这样的：
- en: '![Figure 2.7 – Our code after all the modifications'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 - 在所有修改后我们的代码'
- en: '](Images/Figure_2.07_B17074.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.07_B17074.jpg)'
- en: Figure 2.7 – Our code after all the modifications
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - 在所有修改后我们的代码
- en: Now, let's save and look at our app. As you can see, nothing has changed, but
    we've cleaned our code because we're only writing one line of code to get two
    lines of output, and that makes it a lot more natural to follow. It's a lot simpler
    to read because we instantly know that the `Personal Information` component will
    output personal information, and on top of that, it's really easy for us to find
    exactly what is of interest when we're looking for a specific part of our code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们保存并查看我们的应用程序。正如你所看到的，没有什么改变，但我们已经清理了我们的代码，因为我们只需要写一行代码就可以得到两行输出，这样更容易理解。它更简单易读，因为我们立即知道`Personal
    Information`组件将输出个人信息，而且，当我们寻找代码的特定部分时，很容易找到我们感兴趣的内容。
- en: So, if we want to go ahead and change something from our main screen – let's
    say we want to change our age because we're now 1 year older – you can easily
    see that your personal information is in a **component** called `PersonalInformation`
    that was **imported** from a folder called `components`. Now, all you have to
    do is go inside that folder, look for that specific file, and modify the text.
    That's easy to follow, right?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想继续并从我们的主屏幕更改一些东西 - 比如说我们想改变我们的年龄，因为我们现在大了1岁 - 你可以很容易地看到你的个人信息在一个叫做`PersonalInformation`的**组件**中，它是从一个叫做`components`的文件夹中**导入**的。现在，你只需要进入那个文件夹，找到那个特定的文件，并修改文本。这很容易理解，对吧？
- en: Let's create another one so that we can see how we can simplify and clean up
    this process even more.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个，这样我们就可以看到如何进一步简化和清理这个过程。
- en: Creating the Bio component
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Bio组件
- en: For now, let's remove the `TextInput` and `Button` components from `App.js`.
    We're not using those right now and they don't look like they have anything to
    do with our personal information.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从`App.js`中删除`TextInput`和`Button`组件。我们现在不使用它们，而且它们似乎与我们的个人信息无关。
- en: After removing those from your main function, go inside our `components` folder
    and create a new file called `Bio.js`. This is pretty self-explanatory, but I
    feel like a profile should have a small biography at the top with just your name
    and age.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在从主函数中删除它们之后，进入我们的`components`文件夹并创建一个名为`Bio.js`的新文件。这是相当不言自明的，但我觉得个人资料应该在顶部有一个简短的传记，只有你的名字和年龄。
- en: We already know that we want to import a `Text` component and create our functional
    component. I won't repeat the process of creating a new component; instead, I
    will write something personal inside the `Text` component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们想要导入一个`Text`组件并创建我们的功能组件。我不会重复创建新组件的过程；相反，我会在`Text`组件内写一些个人的东西。
- en: Important Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't forget that you don't need a `View` component now because we're only using
    a `Text` component here. The fact that we only have one JSX element means our
    component can easily return it without needing a parent component encapsulating
    it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记现在不需要`View`组件，因为我们这里只使用了`Text`组件。我们只有一个JSX元素的事实意味着我们的组件可以轻松地返回它，而不需要一个封装它的父组件。
- en: 'The new component should look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件应该是这样的：
- en: '![Figure 2.8 – Our new Bio component'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 我们的新Bio组件'
- en: '](Images/Figure_2.08_B17074.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.08_B17074.jpg)'
- en: Figure 2.8 – Our new Bio component
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 我们的新Bio组件
- en: 'Let''s save and import it into our main file, `App.js`. As we did previously,
    we create a new line underneath our last import and write the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存并将其导入到我们的主文件`App.js`中。就像之前一样，我们在最后一个导入的下面创建一行新的，并写入以下内容：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's use it inside our app – I'm placing it underneath our `<PersonalInformation
    />` component. Save and refresh. You should now be able to see your bio underneath
    your age and hometown on your device.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的应用程序中使用它 - 我把它放在我们的`<PersonalInformation />`组件下面。保存并刷新。现在你应该能够在设备上看到你的年龄和家乡下面的个人简介了。
- en: This is great, but are we going to keep on having a new line for each component?
    Imagine having 30 custom components. That's going to turn into a hellish nightmare
    to scroll past.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但我们要继续为每个组件都添加一个新行吗？想象一下有30个自定义组件。那将变成一个可怕的噩梦，让人难以忍受。
- en: Creating the main file for our components
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的组件创建主文件
- en: 'We can easily solve this by going into the `PersonalInformation.js` file and
    removing the `default` keyword from the last line of our file. Do the same thing
    with `Bio.js`. Your last line in both files should say something like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进入“PersonalInformation.js”文件并从文件的最后一行删除“default”关键字来轻松解决这个问题。对“Bio.js”做同样的事情。你们两个文件的最后一行应该是这样的：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, instead of `Component`, you'll have the actual name of your function,
    which should be `PersonalInformation` or `Bio`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您将使用实际的函数名称，应该是“PersonalInformation”或“Bio”，而不是“Component”。
- en: Because we've done that, we can create a new file inside our `components` folder
    called `index.js`. We'll create a list of all of our components here, which will
    allow us to import these custom components from a single line.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经这样做了，我们可以在我们的“components”文件夹中创建一个名为“index.js”的新文件。我们将在这里创建所有组件的列表，这将允许我们从一行中导入这些自定义组件。
- en: Inside our newly created file, `index.js`, we'll import our components and then
    export them. This sounds easy and somehow redundant but this is useful as it's
    going to make things even clearer and easier to read and follow.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新创建的文件“index.js”中，我们将导入我们的组件，然后导出它们。这听起来很容易，有点多余，但这很有用，因为这将使事情变得更清晰，更容易阅读和遵循。
- en: 'After writing everything in our index file, the code inside should look like
    this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的索引文件中写完所有内容后，代码内部应该是这样的：
- en: '![Figure 2.9 – The index.js file with all the code written inside it'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 - index.js文件中包含的所有代码'
- en: '](Images/Figure_2.09_B17074.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.09_B17074.jpg)'
- en: Figure 2.9 – The index.js file with all the code written inside it
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - index.js文件中包含的所有代码
- en: Now that we have this file that stores all of our newly created custom components,
    let's go into our `App.js` file and rewrite our imports the way they should be
    written.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储所有新创建的自定义组件的文件，让我们进入我们的“App.js”文件，并按照应该编写的方式重写我们的导入。
- en: Refactoring our main code
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构我们的主要代码
- en: 'Here, we must delete our first two custom component imports and write the following
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须删除我们的前两个自定义组件导入，并编写以下代码：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's the only change we're making. Pretty easy, right? And it looks so much
    better and more organized.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们正在做的唯一改变。很容易，对吧？看起来更好，更有组织。
- en: 'Now, let''s remove the unused components, such as `Text` and `Image`, and save
    our file. After making all these modifications, your `App.js` file will look like
    this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除未使用的组件，如“Text”和“Image”，并保存我们的文件。在进行所有这些修改后，您的“App.js”文件将如下所示：
- en: '![Figure 2.10 – Our final code for this chapter'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 - 本章的最终代码'
- en: '](Images/Figure_2.10_B17074.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/Figure_2.10_B17074.jpg)'
- en: Figure 2.10 – Our final code for this chapter
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 - 本章的最终代码
- en: 'Yay! We''ve finished creating two new components for our app while also organizing
    the code in such a manner that any programmer would be proud of us. I''m not a
    believer in homework but I do believe in the power of exercise. Now, it''s your
    turn. Create as many components as you can think of. Don''t stop at simple text-based
    components; try and use more of the core components React Native has at its disposal.
    Don''t be afraid of getting something wrong – that is the best way to learn: trial
    and error.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！我们已经完成了为我们的应用程序创建两个新组件，同时以一种任何程序员都会为我们感到自豪的方式组织代码。我不相信作业，但我相信锻炼的力量。现在轮到你了。创建尽可能多的组件。不要止步于简单的基于文本的组件；尝试并使用更多React
    Native提供的核心组件。不要害怕出错 - 这是学习的最佳方式：反复试验。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started learning about our Expo's basic file structure and
    how all those files are connected, how `App.js` is the main entry point into our
    application, and which function is getting called at startup. After that, we delved
    into the main concepts of JSX, explaining and comparing JSX to other markup languages
    and understanding that JSX is more of an extension of JavaScript.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习有关Expo基本文件结构的知识，以及所有这些文件是如何连接的，`App.js`是我们应用程序的主要入口点，以及在启动时调用了哪个函数。之后，我们深入了解了JSX的主要概念，解释并将JSX与其他标记语言进行了比较，并理解JSX更像是JavaScript的扩展。
- en: We left the theory aside and started importing our first component while talking
    about npm and how we will use it in the future when creating more complex applications.
    We imported the core components of React Native and explained them all. Using
    them felt comfortable and pretty easy, so we figured, why not create a component?
    After we created a component, we learned more about file structure and how to
    index all of our components into a single file, which helped us clean our code
    even more.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把理论放在一边，开始导入我们的第一个组件，同时讨论npm以及在创建更复杂的应用程序时我们将如何使用它。我们导入了React Native的核心组件并对它们进行了解释。使用它们感觉很舒适，而且相当容易，所以我们想，为什么不创建一个组件呢？创建了一个组件后，我们学到了更多关于文件结构以及如何将所有组件索引到单个文件中，这帮助我们进一步清理了我们的代码。
- en: In the next chapter, we'll study the correct mindset of a React/React Native
    developer and understand how to think in React. This is going to help us greatly
    because it will save us time when we're starting a new project. If the planning
    is correct from the start, we won't have any problems building the project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习React/React Native开发者的正确思维方式，并了解如何以React的方式思考。这将极大地帮助我们，因为当我们开始一个新项目时，它将节省我们的时间。如果从一开始规划正确，我们在构建项目时就不会遇到任何问题。
