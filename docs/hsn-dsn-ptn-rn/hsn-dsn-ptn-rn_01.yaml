- en: React Component Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件模式
- en: Developing Android and iOS has never been easier than it is now. React Native
    has changed how fast we develop new apps and deliver value to the end user. Knowing
    this technology will give you a great edge in the market. I'm Matt and I'm happy
    to show you the best practices I have learned while working in a React Native
    ecosystem. Through this book, we will explore design patterns by example. In just
    this first chapter, we will create over 10 small applications. Later on in this
    book, we will create more complex applications, using the patterns that I will
    gradually introduce to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Android和iOS从未像现在这样简单。React Native改变了我们开发新应用并向最终用户提供价值的速度。了解这项技术将使你在市场上拥有巨大优势。我是Matt，很高兴向你展示我在React
    Native生态系统中学到的最佳实践。通过本书，我们将通过示例探索设计模式。仅在本章中，我们将创建超过10个小应用程序。在本书的后面，我们将使用我逐渐向你介绍的模式创建更复杂的应用程序。
- en: In this chapter, we will explore React patterns that also apply to the React
    Native world. The most crucial patterns you need to understand are stateless and
    stateful components. Understanding how to use these will make you a much better
    React Native developer and empower you with standard patterns in every React Native
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨同样适用于React Native世界的React模式。你需要理解的最关键的模式是无状态和有状态组件。了解如何使用这些模式将使你成为一个更好的React
    Native开发者，并赋予你在每个React Native应用程序中使用的标准模式。
- en: When it comes to components, it is crucial to make them as reusable as possible
    and follow the well-known programmer principle—**Don't Repeat Yourself** (**DRY**).
    Presentational components and container components are meant to do just that.
    We will dive into them with a couple of examples to learn how to split features
    into reusable pieces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件方面，使它们尽可能可重用并遵循众所周知的程序员原则——**不要重复自己**（**DRY**）是至关重要的。展示性组件和容器组件就是为了做到这一点。我们将通过几个示例来深入了解它们，学习如何将功能分割成可重用的部分。
- en: 'To be more precise, in this first chapter, we will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，在本章中，我们将研究以下主题：
- en: Stateless and stateful components, using short and then more complex examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态和有状态组件，使用简短然后更复杂的示例
- en: How to create reusable and easily configurable presentational components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建可重用且易于配置的展示性组件
- en: Container components and their role in the encapsulation of features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器组件及其在功能封装中的作用
- en: When to compose components and how to create **Higher Order Components** (**HOCs**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时组合组件以及如何创建**高阶组件**（**HOCs**）
- en: It's time to act on your side. **Prepare your environment for React Native development
    right now **if you want to follow along and play with the examples. Most of the
    code samples that you will see in this book can be run and displayed either on
    a simulator or on a real mobile device. Now, make sure that you can launch the
    `Hello World` example on your mobile or simulator.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候采取行动了。**如果你想跟着学习并尝试示例，请立即为React Native开发准备好你的环境**。本书中的大部分代码示例都可以在模拟器或真实移动设备上运行和显示。现在，确保你可以在手机或模拟器上启动`Hello
    World`示例。
- en: Code examples are checked into a Git repository on GitHub, which can be found
    at [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例已经提交到GitHub上的Git存储库中，可以在[https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native)找到。
- en: Please follow the `readme.md` instructions to set up your machine and launch
    our first example. The `Hello World` example can be found in the following directory `src/Chapter_1_React_component_patterns/Example_1_Hello_World`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照`readme.md`中的说明设置您的计算机并启动我们的第一个示例。`Hello World`示例可以在以下目录中找到`src/Chapter_1_React_component_patterns/Example_1_Hello_World`。
- en: Stateless and stateful components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态和有状态组件
- en: 'First of all, let''s look at the first stateless component that has been created
    for us. It has been automatically generated by **Create React Native App** (**CRNA**)
    for our `Hello World` application. This component was created using the class
    syntax that was introduced in ECMAScript 2015 (ES6). Such components are usually
    called **class components**:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看为我们创建的第一个无状态组件。它是由**Create React Native App**（**CRNA**）自动生成的，用于我们的`Hello
    World`应用程序。这个组件是使用ECMAScript 2015（ES6）中引入的类语法自动生成的。这样的组件通常被称为**类组件**：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Class components can be used to create stateful components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件可用于创建有状态组件。
- en: The code samples provided in this book use ECMAScript 2018 syntax with Stage
    3 feature *class field declarations*. Babel is the transpiler that supports such
    code by relevant plugins that are pre-configured for us by the CRNA toolbox. If
    you decide not to use CRNA, then you may need to configure Babel yourself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例使用具有Stage 3功能*类字段声明*的ECMAScript 2018语法。 Babel是支持这样的代码的转换器，相关插件由CRNA工具箱预先配置。如果您决定不使用CRNA，则可能需要自行配置Babel。
- en: 'However, in this case, the class component is unnecessary. We can safely use
    a stateless one, as it''s simpler. Let''s see how we can declare a **stateless
    component**. The most common approach is by using ES6 arrow syntax. Such components
    are called **functional components**. Check out the following code to see what
    our rewritten component looks like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，类组件是不必要的。我们可以安全地使用无状态组件，因为它更简单。让我们看看如何声明**无状态组件**。最常见的方法是使用ES6箭头语法。这样的组件称为**功能组件**。查看以下代码，看看我们重写的组件是什么样子的：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are not a fan of arrow syntax, you can also use regular `function` syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢箭头语法，您也可以使用常规的`function`语法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The very first question that pop ups is: why is it stateless? The answer is
    simple: it doesn''t contain any inner state. This means that we are not storing
    any private data inside it. Everything the component needs to render itself is
    provided from the external world, which the component does not care about.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先弹出的第一个问题是：为什么它是无状态的？答案很简单：它不包含任何内部状态。这意味着我们没有在其中存储任何私有数据。组件需要渲染自身的一切都来自外部世界，而组件并不关心。
- en: 'In this little example, we actually never pass any external data to the component.
    Let''s do that now. To do so, we will create another component called `HelloText`
    that consumes one property: text to display. The usual convention to pass the
    text to such a component is to place the text between the opening and closing
    tag, for instance, `<HelloText> example text that is passed </HelloText>`. Hence,
    to retrieve such a prop within our functional component, we will need to use a
    special key called `children`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小例子中，我们实际上从未将任何外部数据传递给组件。现在让我们来做这件事。为此，我们将创建另一个名为`HelloText`的组件，它消耗一个属性：要显示的文本。将文本传递给这样一个组件的通常约定是将文本放在开放和关闭标签之间，例如`<HelloText>传递的示例文本</HelloText>`。因此，在我们的功能组件中检索这样的属性，我们将需要使用一个名为`children`的特殊键：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the `children` prop makes our `HelloText` component way more powerful.
    Props are a very flexible mechanism. Using props, you can send any valid JavaScript
    type. In this case, we have sent just text, but you can send other components,
    too.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`children`属性使我们的`HelloText`组件更加强大。属性是一种非常灵活的机制。使用属性，您可以发送任何有效的JavaScript类型。在这种情况下，我们只发送了文本，但您也可以发送其他组件。
- en: It's time to add some vitality to our component. We will make it expand the
    third text block, but only after pressing the chapter or title text. For this
    functionality, we need to store a state that remembers if the component is expanded
    or collapsed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的组件添加一些活力了。我们将使其展开第三个文本块，但只有在按下章节或标题文本后才会展开。为了实现这个功能，我们需要存储一个状态，记住组件是展开还是折叠的。
- en: 'Here is what you need to do:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的是：
- en: Change the component to the class syntax.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件更改为类语法。
- en: Leverage the state object of the React library. We must initialize the state
    within the class constructor and make the text collapsed by default.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用React库的状态对象。我们必须在类构造函数中初始化状态，并默认使文本折叠。
- en: Add conditional rendering to the component `render` function.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`render`函数中添加条件渲染。
- en: Add the press handler, which will change the state once we tap on the title
    or chapter text.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按下处理程序，当我们点击标题或章节文本时将改变状态。
- en: 'The solution is presented in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations—we have made our first stateless and stateful components!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——我们已经创建了我们的第一个无状态和有状态组件！
- en: Note the `&&` operator that displays the component. If a Boolean value on the
    left side of the operator is `true`, then the component on the right-hand side
    will be displayed. The whole expression needs to be wrapped into curly brackets.
    We will explore more of its capabilities in [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml),
    Style Patterns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意显示组件的`&&`运算符。如果运算符左侧的布尔值为`true`，那么右侧的组件将被显示。整个表达式需要用大括号括起来。我们将在[第3章](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml)中探索更多功能，样式模式。
- en: 'It''s time to create something more challenging: `Task list`. Please start
    over and prepare your code. Clean up `App.js` so that it only includes the `App`
    class component:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一些更具挑战性的东西：`任务列表`。请重新开始并准备好您的代码。清理`App.js`，使其只包括`App`类组件：
- en: The constructor should initialize the task list in its state. In my example,
    the task list will be an array of strings.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数应该在其状态中初始化任务列表。在我的示例中，任务列表将是一个字符串数组。
- en: Iterate over the tasks to create the `Text` component for each task. This should
    happen in the `render` function of the `App` component. Please note that you can
    simplify iteration by using the `map` function instead of a regular `for` loop.
    Doing this should become second nature, since it's became a standard in almost
    every JS project.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代任务以为每个任务创建`Text`组件。这应该发生在`App`组件的`render`函数中。请注意，您可以使用`map`函数简化迭代，而不是使用常规的`for`循环。这应该成为第二天性，因为它已经成为几乎每个JS项目的标准。
- en: 'My solution is presented in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Iterating using `map` is a nice feature, but the whole component doesn't look
    like a task list yet. Don't worry, you will learn how to style components in [Chapter
    3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml), *Style Patterns*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`进行迭代是一个很好的功能，但整个组件看起来还不像一个任务列表。别担心，您将学会如何在[第3章](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml)中为组件添加样式，*样式模式*。
- en: What are the advantages of stateless components?
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态组件的优势是什么？
- en: It may seem tempting to only use stateful class components and develop a whole
    application like that. Why would we even bother with stateless functional components?
    The answer is performance. Stateless functional components can be rendered faster.
    One of the reasons why this is the case is because stateless functional components
    do not require some of the life cycle hooks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也许只使用有状态的类组件并开发整个应用程序似乎很诱人。为什么我们要费心使用无状态的函数组件呢？答案是性能。无状态的函数组件可以更快地渲染。这样做的原因之一是因为无状态的函数组件不需要一些生命周期钩子。
- en: What are life cycle hooks? React components have life cycles. This means that
    they have different stages like mounting, unmounting, and updating. You can hook
    each stage and even sub stage. Please check the official React documentation to
    see the full list of available life cycle methods: [https://reactjs.org/docs/state-and-lifecycle.html](https://reactjs.org/docs/state-and-lifecycle.html).
    [](https://reactjs.org/docs/state-and-lifecycle.html) These are useful to trigger
    fetching data from the API or to update the view.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是生命周期钩子？React组件有生命周期。这意味着它们有不同的阶段，如挂载、卸载和更新。您可以挂钩每个阶段甚至子阶段。请查看官方React文档以查看可用生命周期方法的完整列表：[https://reactjs.org/docs/state-and-lifecycle.html](https://reactjs.org/docs/state-and-lifecycle.html)。这些对于触发从API获取数据或更新视图非常有用。
- en: 'Please note that if you are using React v16 or later, it is not true that functional
    components are wrapped into class components internally within the React library:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您使用的是React v16或更高版本，功能组件不会在React库内部被包装成类组件。
- en: '"Functional components in React 16 don''t go through the same code path as
    class components, unlike in the previous version where they were converted to
    classes and would have the same code path. Class components have additional checks
    that are required and overhead in creating the instances that simple functions
    don''t have. These are micro-optimizations though and shouldn''t make a huge difference
    in real-world apps – unless your class component is overly complex." - Dominic
    Gannaway, engineer on the React core team at Facebook ([https://github.com/reactjs/reactjs.org/issues/639#issuecomment-367858928](https://github.com/reactjs/reactjs.org/issues/639#issuecomment-367858928))'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React 16中的功能组件与类组件不走相同的代码路径，不像在之前的版本中它们被转换为类并且会有相同的代码路径。类组件有额外的检查和创建实例的开销，而简单函数没有。尽管这些是微优化，不应该在真实应用中产生巨大差异，除非你的类组件过于复杂。-
    Dominic Gannaway，Facebook React核心团队的工程师
- en: 'Functional components are faster, but in most cases are outperformed by class
    components extending `React.PureComponent`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件更快，但在大多数情况下被扩展`React.PureComponent`的类组件性能更好：
- en: '"Still, to be clear, they don''t bail out of rendering like PureComponent does
    when props are shallowly equal." - Dan Abramov, co-author of Redux and Create
    React App, engineer on the React core team at Facebook ([https://twitter.com/trueadm/status/916706152976707584](https://twitter.com/trueadm/status/916706152976707584))'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “但要明确的是，当props浅相等时，它们不会像PureComponent那样退出渲染。”- Dan Abramov，Redux和Create React
    App的共同作者，Facebook React核心团队的工程师
- en: Functional components are not only more concise, but they usually are also pure
    functions. We will explore this concept further in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml),
    *Elements of Functional Programming Patterns*. Pure functions provide a lot of
    benefits, such as a predictable UI and easy tracking of user behavior. The application
    can be implemented in a certain way to record user actions. Such data helps with
    debugging and reproducing errors in tests. We will dig into this topic later on
    in this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件不仅更简洁，而且通常也是纯函数。我们将在《第9章》中进一步探讨这个概念，*函数式编程模式的元素*。纯函数提供了许多好处，如可预测的UI和轻松跟踪用户行为。应用程序可以以某种方式实现来记录用户操作。这些数据有助于调试和在测试中重现错误。我们将在本书的后面深入探讨这个话题。
- en: Component composition
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件组合
- en: If you have learned any **Object-Oriented** (**OO**) language, you may have
    used inheritance extensively. In JavaScript, this concept is a little bit different.
    JavaScript inheritance is based on prototypes, and so we call it **prototypal
    inheritance**. Functionalities are not copied to the object itself—they are inherited
    from the prototype of the object and possibly even through other prototypes in
    the prototype tree. We call this a **prototype chain**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您学习过任何**面向对象**（**OO**）语言，您可能已经广泛使用了继承。在JavaScript中，这个概念有点不同。JavaScript继承是基于原型的，因此我们称之为**原型继承**。功能不是复制到对象本身，而是从对象的原型继承，甚至可能通过原型树中的其他原型继承。我们称之为**原型链**。
- en: 'However, in React, using inheritance is not very common. Thanks to components,
    we can embrace another pattern called **component composition**. Instead of creating
    a new class and inheriting from the base class, we will create a new parent component
    that will use its child component to make itself more specific or more powerful.
    Let''s look at an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在React中，使用继承并不是很常见。由于组件，我们可以采用另一种称为**组件组合**的模式。我们将创建一个新的父组件，该组件将使用其子组件使自己更具体或更强大，而不是创建一个新类并从基类继承。让我们看一个例子：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `App` component is being built out of three components: `View`, `Text`,
    and `WarningText`. It is a perfect example of how one component, through composition,
    can reuse the capabilities of others.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件由三个组件构建：`View`，`Text`和`WarningText`。这是一个完美的例子，说明一个组件如何通过组合来重用其他组件的功能。'
- en: The `WarningText` component uses composition to enforce the orange text color
    in the `Text` component. It makes the generic `Text` component more specific.
    Now, we can reuse `WarningText` in any place of the app where it is necessary.
    If our app designer decides to alter the warning text, we can quickly adapt to
    the new design in one place.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`WarningText`组件使用组合来强制`Text`组件中的橙色文本颜色。它使通用的`Text`组件更具体。现在，我们可以在应用程序的任何地方重用`WarningText`。如果我们的应用程序设计师决定更改警告文本，我们可以快速适应一个地方的新设计。'
- en: Note the implicit pass of a special prop called children. It represents the
    children of the component. In `Example 6_ Component composition *-* red text`,
    we first pass warning text as children to the `WarningText` component and then
    using the spread operator it is passed to the `Text` component, which `WarningText`
    encapsulates.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意隐式传递了一个名为children的特殊prop。它代表组件的子元素。在`Example 6_ Component composition *-*
    red text`中，我们首先将警告文本作为子元素传递给`WarningText`组件，然后使用扩展运算符将其传递给`Text`组件，`WarningText`封装了它。
- en: Composing the application layout
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合应用程序布局
- en: Let's suppose we have to create a welcome screen for our application. It should
    be divided into three sections—header, main content, and footer. We would like
    to have consistent margins and styling for both logged and anonymous users. However,
    the header and footer content will differ. Our next task is to create a component
    that supports these requirements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须为我们的应用程序创建一个欢迎屏幕。它应该分为三个部分 - 头部，主要内容和页脚。我们希望对已登录和匿名用户都有一致的边距和样式。但是，头部和页脚内容将不同。我们的下一个任务是创建一个支持这些要求的组件。
- en: Let's create a welcome screen that will use a generic component for encapsulating
    an app layout.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个欢迎屏幕，它将使用一个通用组件来封装应用程序布局。
- en: 'Follow this step-by-step guide to do so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下逐步指南操作：
- en: 'Create the `AppLayout` component that enforces some styling. It should accept
    three props: `header`, `MainContent`, and `Footer`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`AppLayout`组件，强制一些样式。它应该接受三个props：`header`，`MainContent`和`Footer`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It''s now time to create placeholders for header, footer, and content. We have
    created three components: `WelcomeHeader`, `WelcomeContent`, and `WelcomeFooter`.
    If you wish, you can extend them to be more complex than a trivial piece of text:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候为标题、页脚和内容创建占位符了。我们创建了三个组件：`WelcomeHeader`，`WelcomeContent`和`WelcomeFooter`。如果你愿意，你可以将它们扩展为比一个微不足道的文本更复杂的组件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should connect `AppLayout` with our placeholder components. Create the `WelcomeScreen`
    component, which will pass placeholder components (from *step 2*) down to the `AppLayout`
    as props:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该将`AppLayout`与我们的占位符组件连接起来。创建`WelcomeScreen`组件，它将占位符组件（来自*步骤2*）作为props传递给`AppLayout`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last step is going to be creating the root component for our app and adding
    some styles:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将是为我们的应用程序创建根组件并添加一些样式：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please note the use of `StyleSheet.create({...})`. This creates a style object
    that represents our app styles. In this case, we have created four different styles
    (`container`, `layoutHeader`, `layoutContent`, and `layoutFooter`) that will be
    available to use with the markup we defined. We previously customized styles using
    keys such as `width`, `height`, and `backgroundColor`, which are trivial. In this
    example, however, we also use `flex`, which comes from the term **flexbox pattern**.
    We will explain this approach in detail in [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml), *Style
    Patterns*,  where we focus primarily on `StyleSheet` patterns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`StyleSheet.create({...})`。这将创建一个表示我们应用程序样式的样式对象。在这种情况下，我们创建了四种不同的样式（`container`，`layoutHeader`，`layoutContent`和`layoutFooter`），可以在我们定义的标记中使用。我们以前使用诸如`width`，`height`和`backgroundColor`之类的键来自定义样式，这些都是微不足道的。然而，在这个例子中，我们还使用了来自术语**flexbox模式**的`flex`。我们将在[第3章](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml)中详细解释这种方法，*样式模式*，我们主要关注`StyleSheet`模式。
- en: This is pretty good. We have made a trivial layout for our application and then
    created the welcome screen with it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这很不错。我们为我们的应用程序制作了一个微不足道的布局，然后创建了欢迎屏幕。
- en: What about component inheritance?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件继承怎么样？
- en: '"At Facebook, we use React in thousands of components, and we haven''t found
    any use cases where we would recommend creating component inheritance hierarchies."
    - React official documentation ([https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html))'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “在Facebook，我们在成千上万的组件中使用React，并且我们没有发现任何我们建议创建组件继承层次结构的用例。”- React官方文档（[https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html)）
- en: I have not come across a situation where I had to step away from component composition
    in favor of inheritance. Neither have developers at Facebook (as per the preceding
    quotation). Hence, I highly recommend you get used to composition.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有遇到过必须放弃组件组合而选择继承的情况。Facebook的开发人员也没有（根据前面的引用）。因此，我强烈建议你习惯于组合。
- en: Testing components on high-level patterns
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在高级模式上测试组件
- en: 'Testing is something very important when it comes to creating reliable and
    stable applications. First of all, let''s look at the most common three types
    of tests you will need to write:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建可靠和稳定的应用程序时，测试是非常重要的。首先，让我们看看你需要编写的最常见的三种测试类型：
- en: '**Trivial unit tests**: I don''t understand it, but is it working or not working
    at all? Usually, tests that check whether the component renders or whether the
    function runs with no errors are called trivial unit tests. If you do this manually,
    you call these tests smoke tests. Such tests are vital to have. Whether you like
    it or not, you should write trivial tests, at least to know if every feature is
    *somehow* working.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**琐碎的单元测试：**我不明白，但它是否工作或根本不工作？通常，检查组件是否渲染或函数是否无错误运行的测试被称为琐碎的单元测试。如果你手动进行这些测试，你会称这些测试为冒烟测试。这些测试非常重要。不管你喜不喜欢，你都应该编写琐碎的测试，至少要知道每个功能*某种程度*上是否工作。'
- en: '**Unit tests**: Does the code work as I expect it to? Does it work in all of
    the code branches? By branch, we mean places in the code where it branches, for
    instance, if statements are branching code into different code paths, which is
    similar to switch-case statements. Unit testing refers to testing a single unit
    of code. In crucial features of an application, unit tests should cover whole
    function code (as a principle: 100% code coverage for crucial features).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试：**代码是否按照我的预期工作？它是否在所有的代码分支中工作？分支指的是代码中的分支位置，例如，if语句将代码分支到不同的代码路径，这类似于switch-case语句。单元测试是指测试单个代码单元。在应用程序的关键特性中，单元测试应该覆盖整个函数代码（原则上：对于关键特性，代码覆盖率达到100%）。'
- en: '**Snapshot tests**: Testing if the previous and actual version produce the
    same result is called snapshot testing. Snapshot tests are just creating text
    output, but once the output is proven to be correct (through developer assessment
    and code review), it may work as a comparison tool. Try to use snapshot tests
    a lot. Such tests should be committed into your repository and undergo review
    process. This new feature in Jest saves a lot of time for developers:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快照测试：**测试之前和实际版本是否产生相同的结果被称为快照测试。快照测试只是创建文本输出，但一旦输出被证明是正确的（通过开发人员评估和代码审查），它可能会作为比较工具。尽量多使用快照测试。这些测试应该提交到你的代码库并经过审查过程。Jest中的这个新功能为开发人员节省了大量时间：'
- en: '**Image snapshot tests:** In Jest, snapshot tests compare text (JSON to JSON),
    however, you may encounter references to snapshot tests on mobile devices, where
    this means comparing images to images. This is a more advanced topic, but is commonly
    used by big websites. Taking such a screenshot most likely requires building the
    whole app instead of a single component. Building the whole app is time-consuming,
    so some companies only run these type of tests when they plan for a release, for
    instance, on a release candidate build. This strategy can be automated to follow
    *continuous integration* and *continuous delivery* principles.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像快照测试：**在Jest中，快照测试比较文本（JSON到JSON），但是你可能会在移动设备上遇到快照测试的引用，这意味着比较图像和图像。这是一个更高级的话题，但是大型网站通常会使用。拍摄这样的屏幕截图很可能需要构建整个应用程序，而不仅仅是一个单独的组件。构建整个应用程序是耗时的，因此一些公司只在计划发布时运行这种类型的测试，例如在发布候选版本构建上。这种策略可以自动化遵循*持续集成*和*持续交付*原则。'
- en: Since we are using the CRNA toolbox in this book, the testing solution you want
    to check is Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本书中使用CRNA工具箱，你想要检查的测试解决方案是Jest（[https://facebook.github.io/jest/](https://facebook.github.io/jest/)）。
- en: Watch out if you come from a React web development background. React Native,
    as the name suggests, operates in a native environment and hence has many components,
    such as react-native-video package, which may need special testing solutions.
    In many cases, you will need to mock (create placeholders/mimic behaviour) these
    packages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自React web开发背景，请注意。React Native，顾名思义，是在本地环境中运行的，因此有许多组件，比如react-native-video包，可能需要特殊的测试解决方案。在许多情况下，你需要模拟（创建占位符/模仿行为）这些包。
- en: Check out [https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock](https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock) for
    more information.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock](https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock)了解更多信息。
- en: We will address some of these concerns in [Chapter 10](02308da0-7093-4573-97b0-30d147b28cc2.xhtml),
    *Managing Dependencies*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](02308da0-7093-4573-97b0-30d147b28cc2.xhtml)中解决其中一些问题，*管理依赖*。
- en: There are usually some metrics to testing, such as code coverage (the number
    of lines covered by tests), the number of reported bugs, and the number of registered
    errors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有一些测试指标，比如代码覆盖率（测试覆盖的行数）、报告的错误数量和注册的错误数量。
- en: Although very valuable, these may create a false belief that the application
    is well-tested.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常有价值，但这些指标可能会产生一个错误的信念，即应用程序经过了充分测试。
- en: 'There are a few utterly wrong practices that I need to mention when it comes
    to testing patterns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及测试模式时，有一些完全错误的做法需要提及：
- en: '**Relying only on unit tests**:Unit tests mean testing just a single piece
    of code in isolation, for instance, a function by passing arguments to it and
    checking the output. This is great and saves you from a lot of bugs, but no matter
    what code coverage you have, you may bump into problems with the integration of
    well-tested components. The real-life example I like to use is a video of two
    sliding doors that are placed too close to each other, which causes them to keep
    on opening and closing forever.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅依赖单元测试**：单元测试意味着仅测试单独的代码片段，例如，通过向函数传递参数并检查输出来测试。这很好，可以避免很多错误，但无论你有多高的代码覆盖率，你可能会在集成经过充分测试的组件时遇到问题。我喜欢用的一个现实例子是两扇门放得太靠近，导致它们不断开合。'
- en: '**Relying on code coverage too much**:Stop stressing yourself or other developers
    to reach that 100% or 90% code coverage mark. If you can afford it, great, but
    usually it makes developers write less valuable tests. Sometimes, it is crucial
    to send different integer values to functions; for instance, when testing division,
    it is not enough to send two positive integers. You need to also check what happens
    when you divide by zero. Coverage won''t tell you that.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过分依赖代码覆盖率**：不要过分强调自己或其他开发人员达到100%或90%的代码覆盖率。如果你有能力做到，那很好，但通常这会导致开发人员编写价值较低的测试。有时，向函数发送不同的整数值是至关重要的；例如，在测试除法时，仅发送两个正整数是不够的。你还需要检查当除以零时会发生什么。覆盖率无法告诉你这一点。'
- en: '**Not tracking how your testing metrics influence the number of bugs**: If
    you just rely on some metrics, whether it be code coverage or any other, please
    reassess if the metrics tell the truth, for instance, whether increase in the
    metric causes less bugs. To give you a nice example, I''ve heard developers from
    many different companies say that the code coverage increasing above 80% didn''t
    help them much.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不追踪测试指标如何影响错误数量**：如果你只依赖于一些指标，无论是代码覆盖率还是其他任何指标，请重新评估这些指标是否反映了真相，例如，指标的增加是否导致了更少的错误。举个例子，我听过许多不同公司的开发人员说，代码覆盖率超过80%并没有对他们有太大帮助。'
- en: If you are a product owner and have checked the point *Not tracking how your
    testing metrics influence the number of bugs* above, please also consult with
    the tech leader or senior developers of your project. There may be certain specifics
    that influence this process, for instance, development schedule shifting to more
    repeatable code. Please don't jump to conclusions too quickly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是产品所有者，并且已经查看了上面的*不追踪测试指标如何影响错误数量*，请与项目的技术负责人或资深开发人员进行咨询。可能会有一些特定因素影响这个过程，例如，开发进度转向更可重复的代码。请不要过快下结论。
- en: Snapshot testing expandable components
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照测试可扩展组件
- en: This time, we will demonstrate a tricky part of snapshot testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将展示快照测试的一个棘手部分。
- en: Let's start by creating our first snapshot test. Go to `Chapter_1/Example 4_Stateful_expandable_component`and
    run `yarn test` in the command line. You should see that one test passes. What
    kind of test is it? It's a trivial unit test that's located in the `App.test.js` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的第一个快照测试开始。转到`Chapter_1/Example 4_Stateful_expandable_component`并在命令行中运行`yarn
    test`。您应该会看到一个测试通过。这是什么样的测试？这是一个位于`App.test.js`文件中的微不足道的单元测试。
- en: 'It''s time to create our first snapshot test. Replace `expect(rendered).toBeTruthy();`
    with `expect(rendered).toMatchSnapshot();`. It should look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的第一个快照测试了。将`expect(rendered).toBeTruthy();`替换为`expect(rendered).toMatchSnapshot();`。它应该是这样的：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you have this, rerun `yarn test`. A new directory called ` __snapshots__`
    should be created with the `App.test.js.snap` file inside it. Take a look at its
    contents. This is your first snapshot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，重新运行`yarn test`。将创建一个名为`__snapshots__`的新目录，其中包含`App.test.js.snap`文件。查看其内容。这是您的第一个快照。
- en: 'It''s time to test the app''s coverage. You can do this with the following
    command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试应用的覆盖率了。您可以使用以下命令来完成：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It yields something a little concerning:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生了一些令人担忧的东西：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have one component that has one branch (`if`), and after performing a snapshot
    test, the coverage is not even near 100%. What's wrong?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个组件有一个分支（`if`），进行快照测试后，覆盖率甚至没有接近100%。出了什么问题？
- en: 'There is obviously a problem with the branch that relies on state, but would
    it account for over 30% of the lines? Let''s see the full report. Open the `./coverage/lcov-report/App.js.html` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，依赖状态的分支存在问题，但是否会占据超过30%的代码行数？让我们看看完整的报告。打开`./coverage/lcov-report/App.js.html`文件：
- en: '![](Images/a30aada2-a239-4b49-be3f-6d5d3530d170.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a30aada2-a239-4b49-be3f-6d5d3530d170.png)'
- en: The coverage report file. You can see that the code has been uncovered with
    the tests marked in red.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告文件。您可以看到代码未被覆盖，测试标记为红色。
- en: Now, you see what is wrong. The answer is pretty simple—snapshot tests do not
    test prop functions. Why? First of all, this does not make much sense. Why would
    we convert a function to JSON, and how would it help? Secondly, tell me how to
    serialize the function. Shall I return function code as text or compute output
    in some other way?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你看到了问题所在。答案很简单——快照测试不测试属性函数。为什么？首先，这没有太多意义。我们为什么要将一个函数转换为JSON，这有什么帮助呢？其次，告诉我如何序列化这个函数。我应该将函数代码作为文本返回，还是以其他方式计算输出？
- en: Take this example as a lesson that **snapshot tests are not enough**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以此例为教训，**快照测试并不足够**。
- en: Test-driven development approach
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发方法
- en: 'You will often hear about the **test-driven development** (**TDD**) approach,
    which basically means writing tests first. To simplify this, let''s summarize
    this in the following three steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会听到**测试驱动开发**（**TDD**）方法，基本上意味着先编写测试。为了简化这个过程，让我们总结为以下三个步骤：
- en: Write tests and watch them fail.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试并观察它们失败。
- en: Implement functionality until you see your tests passing.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现功能直到看到测试通过。
- en: Refactor to the best practices (optional).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构为最佳实践（可选）。
- en: I must admit that I really love this approach. However, the truth is that most
    developers will glorify this approach and barely any will use it. This is usually
    because it's time-consuming and it is hard to predict what the thing you are about
    to test looks like.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我真的很喜欢这种方法。然而，事实是大多数开发人员会赞美这种方法，但几乎没有人会使用它。这通常是因为它很耗时，而且很难预测即将测试的东西是什么样子。
- en: Going further, you will find that one of the test types is against TDD. Snapshot
    tests can only be created if the component is implemented, as they rely on its
    structure. This is another reason why snapshot tests are more of an addition to
    your tests rather than a replacement.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，你会发现测试类型之一是针对TDD的。快照测试只能在组件实现后创建，因为它们依赖于其结构。这也是为什么快照测试更多是对你的测试的一种补充，而不是替代品的另一个原因。
- en: This approach works best in huge applications that go on for years, where a
    team of tech architects plan the interfaces and patterns to be used. This is most
    likely in backend projects, and you will have a general idea of how all of the
    classes and patterns connect to each other. Then, you simply take the interface
    and write the tests. Next, you follow up with implementation. If you want to create
    interfaces in React Native, you will need to support TypeScript.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在长期运行的大型应用程序中效果最好，其中一组技术架构师规划要使用的接口和模式。这最有可能出现在后端项目中，你会对所有类和模式如何相互连接有一个大致的了解。然后，你只需拿出接口并编写测试。接下来，你跟进实现。如果你想在React
    Native中创建接口，你需要支持TypeScript。
- en: Some argue that TDD is great in small projects, and you may quickly find such
    threads on Stack Overflow. Don't get me wrong; I'm happy that some people are
    happy. However, small projects tend to be very unstable and are likely to change
    often. If you are building a **Minimum Viable Product (MVP)**, it doesn't work
    very well with TDD. You are better off relying on the fact that the libraries
    you use are well-tested and deliver the project on time, while quickly testing
    it with snapshots.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有人认为TDD在小型项目中很棒，你可能很快就会在Stack Overflow上找到这样的讨论。不要误会我的意思；我很高兴有些人很开心。然而，小型项目往往非常不稳定，很可能经常变化。如果你正在构建一个**最小可行产品（MVP）**，它与TDD并不很搭配。你最好依赖于你使用的库经过了充分测试，并及时使用快照测试来交付项目。
- en: 'To summarize: abandoning TDD should not mean writing less tests.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：放弃TDD不应该意味着写更少的测试。
- en: Presentational components
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表现组件
- en: 'It''s time to learn how to make components reusable. For this goal, we will
    use the best tool in our hands: the **presentational component** pattern. It decouples
    components from logic and makes them flexible.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何使组件可重用了。为了实现这个目标，我们将利用我们手中最好的工具：**表现组件**模式。它将组件与逻辑解耦，并使它们更加灵活。
- en: The presentational component is a pattern name that you will hear very often,
    if, later on, you decide to use the Redux library. For instance, presentational
    components are heavily used in Dan Abramov's Redux course.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表现组件是一个模式名称，如果以后你决定使用Redux库，你会经常听到。例如，在Dan Abramov的Redux课程中，表现组件被大量使用。
- en: 'I like to explain that the presentational component pattern is a website''s
    world. For a long time now, there has been three leading blocks for every website:
    CSS, HTML, and JavaScript. React, however, introduced a bit of a different approach,
    that is, the automated generation of HTML based on JavaScript. HTML became virtual.
    Hence, you may have heard of the **Virtual Document Object Model** (**Virtual
    DOM**). This separation of concerns—HTML (view), CSS (styles), and JavaScript
    (logic, sometimes called the controller)—should remain untouched in our JavaScript-only
    world. Therefore, use presentational components to mimic HTML and container components
    for logic.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢解释，表现组件模式是网站的世界。很长一段时间以来，每个网站都有三个主要的组成部分：CSS、HTML和JavaScript。然而，React引入了一种有点不同的方法，即基于JavaScript自动生成HTML。HTML变成了虚拟的。因此，你可能听说过**虚拟文档对象模型**（**虚拟DOM**）。这种关注点的分离——HTML（视图）、CSS（样式）和JavaScript（逻辑，有时称为控制器）——应该在我们的JavaScript世界中保持不变。因此，在我们的JavaScript世界中，使用表现组件来模仿HTML，使用容器组件来处理逻辑。
- en: Approach this problem in the same fashion in React Native applications. The
    markup you write should be separated from the logic it consumes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以与React Native应用程序相同的方式解决这个问题。你编写的标记应该与它所消耗的逻辑分离。
- en: 'Let''s see this in action. Do you remember `Example 4_Stateful expandable component`?
    It has one presentational component already:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个问题。你还记得`Example 4_Stateful expandable component`吗？它已经有一个呈现层组件了：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This component does not introduce any logic and contains only markup, which
    is very short in this case. Any logic that can be useful is hidden within props
    and passed along, as this component does not need to consume it. In more complex
    examples, you may need to destructure props to pass them to the right components;
    for example, when using the spread operator above, all props that are not destructured
    are being passed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件不引入任何逻辑，只包含标记，在这种情况下非常简短。任何有用的逻辑都隐藏在props中并传递，因为这个组件不需要使用它。在更复杂的例子中，你可能需要解构props并将它们传递给正确的组件；例如，当使用上面的展开运算符时，所有未解构的props都被传递了。
- en: 'But, instead of focusing on this simple example, let''s start refactoring the
    `App` component. First of all, we will move the markup to the separate presentational
    component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与其专注于这个简单的例子，不如开始重构`App`组件。首先，我们将把标记移到单独的呈现层组件中：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to replace the `render` function in the `App` component with the
    following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要用以下内容替换`App`组件中的`render`函数：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, if you run the code now, you will end up with an error on the `HelloText` press
    event. This is due to how JavaScript handles the `this` keyword. In this refactor,
    we pass the `expandOrCollapse` function to another object, and there, `this` refers
    to a completely different object. Therefore, it cannot access state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你现在运行代码，你会在`HelloText`的按键事件上遇到一个错误。这是由于JavaScript处理`this`关键字的方式。在这次重构中，我们将`expandOrCollapse`函数传递给另一个对象，在那里，`this`指的是一个完全不同的对象。因此，它无法访问状态。
- en: 'There are a few solutions to this problem, and one is by using the arrow function.
    I will stick to the best approach performance-wise. It comes down to adding the
    following line to your constructor:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种解决这个问题的方法，其中一种是使用箭头函数。我将坚持性能最佳的方法。关键是在你的构造函数中添加以下行：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There we go; the application is fully functional, just as before. We have refactored
    one component into two—one presentational and one responsible for logic. Sweet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定了；应用程序已经完全可用，就像以前一样。我们已经将一个组件重构为两个——一个是呈现层的，一个负责逻辑的。很好。
- en: Imagine that we had only shallow unit tests of two components.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只对两个组件进行了浅层单元测试。
- en: Would we identify the problem with the `this` keyword?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否识别出`this`关键字的问题？
- en: Perhaps not. This simple gotcha may catch you in big projects, where you will
    be too busy to rethink every single component. Watch out and remember **integration
    tests**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不记得了。这个简单的陷阱可能会在大型项目中让你陷入困境，到时候你会太忙碌而无法重新思考每一个组件。小心并记住**集成测试**。
- en: Decoupling styles
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦样式
- en: In the preceding examples, you may have noticed that styles are tightly coupled
    to presentational components. Why tightly? Because we explicitly include them
    by using `style={styles.container}`*, *but the `styles` object is not configurable.
    We cannot replace any style part with props, and that tightly couples us to the
    existing implementation. In some cases, this is a desired behavior, but in others,
    it is not.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可能已经注意到样式与呈现层组件紧密耦合。为什么紧密？因为我们通过`style={styles.container}`明确地包含它们，但`styles`对象是不可配置的。我们无法用props替换任何样式部分，这使我们与现有的实现紧密耦合。在某些情况下，这是期望的行为，但在其他情况下则不是。
- en: If you are interested in how styles work, we will deep dive into patterns involving
    them in  [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml), *Styling Patterns*.
    You will also learn about the flexbox pattern from CSS and many other conventions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对样式工作感兴趣，我们将深入研究涉及它们的模式，在[第3章](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml)中，*样式模式*。您还将了解来自CSS的flexbox模式和许多其他约定。
- en: You will bump into this problem if you have tried to split code into separate
    files. How can we fix this issue?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将代码拆分为单独的文件，您将遇到这个问题。我们该如何解决这个问题？
- en: 'Let the styles be the optional prop. If styles are not provided, then we can
    fall back to the default values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让样式成为可选属性。如果未提供样式，则我们可以回退到默认值：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the use of the `||` operator. In the preceding example (`expandedTextStyles
    || styles.text`), it first checks if `expandedTextStyles` is defined and if so
    returns that value. If `expandedTextStyles` is undefined, then it return `styles.text`,
    which is a default style object that was hard-coded by us.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`||`运算符。在上面的例子（`expandedTextStyles || styles.text`）中，它首先检查`expandedTextStyles`是否已定义，如果是，则返回该值。如果`expandedTextStyles`未定义，则返回我们硬编码的默认样式对象`styles.text`。
- en: 'Now, if we wish, in some places, we can override our styles by passing respective
    props:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望，在某些地方，我们可以通过传递相应的props来覆盖我们的样式：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is how we split markup, styles, and logic. Remember to use presentational
    components as often as possible to make your features truly reusable across many
    screens/views.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何分割标记、样式和逻辑。请记住尽可能经常使用表现性组件，以使您的功能在许多屏幕/视图上真正可重用。
- en: 'If you come from a backend background, you may quickly jump into assumptions
    that it is just like the **MVC pattern**: **Model**, **View**, and **Controller**.
    It is not necessarily 1:1 relation, but in general, you may simplify it to the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自后端背景，您可能会迅速假设它就像**MVC模式**：**Model**，**View**和**Controller**。它不一定是1:1的关系，但一般来说，您可以简化为以下内容：
- en: '**View**: This is a presentational component.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**View**：这是一个表现性组件。'
- en: '**Model**: This is a data representation, which in our case is the state that
    is built either in a stateful component or using so-called store and reducers
    (check [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store Patterns*,
    to learn more details about what Redux is and how to use it).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Model**：这是数据表示，对我们来说，它是在有状态组件中构建的状态，或者使用所谓的存储和reducers（查看[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)，*存储模式*，了解有关Redux是什么以及如何使用它的更多细节）。'
- en: '**Controller**: This is a container component that is responsible for application
    logic, including event handlers and services. It should be lean and import logic
    from the respective files.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Controller**：这是一个负责应用程序逻辑的容器组件，包括事件处理程序和服务。它应该是精简的，并从相应的文件中导入逻辑。'
- en: Container component
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器组件
- en: 'The container component pattern was introduced a long time ago and was popularized
    within the React community by Dan Abramov. So far, we have created one container
    component when we refactored the contents of the App component to become a *presentational
    component*. It turns out that the `App` component became a container component—it
    contains the `HelloBox` component and implements the necessary logic for it. What
    did we gain from this approach?  We gained the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件模式是很久以前引入的，并在React社区中由Dan Abramov推广。到目前为止，当我们将App组件的内容重构为*表现性组件*时，我们已经创建了一个容器组件。事实证明，`App`组件成为了一个容器组件——它包含了`HelloBox`组件并实现了必要的逻辑。我们从这种方法中获得了什么？我们获得了以下内容：
- en: We can implement expanding and collapsing in a different way and reuse the markup
    of the `HelloBox` component
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以以不同的方式实现展开和折叠，并重用`HelloBox`组件的标记
- en: '`HelloBox` does not contain logic'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloBox`不包含逻辑'
- en: The container component encapsulates logic and hides it from the other components
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器组件封装了逻辑，并将其隐藏在其他组件中
- en: I highly recommend reading Dan Abramov's medium post on this. Check out [https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) for
    more information. Container components are very useful tools when it comes to
    dependency injection patterns. Have a look at [Chapter 10](02308da0-7093-4573-97b0-30d147b28cc2.xhtml),
    *Managing Dependencies*, to learn more.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议阅读Dan Abramov在medium上的文章。查看[https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)获取更多信息。当涉及到依赖注入模式时，容器组件是非常有用的工具。查看[第10章](02308da0-7093-4573-97b0-30d147b28cc2.xhtml)，*管理依赖项*，以了解更多信息。
- en: HOC
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HOC
- en: 'The **HOC** is a pattern that exists to enhance components with additional
    props or functionality, for instance, if you want to make the component expandable.
    Instead of just creating a stateful container as we did previously, we could use
    the HOC pattern. Let''s refactor our stateful container component to a HOC and
    name it `makeExpandable`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**HOC**是一种模式，用于增强组件的附加属性或功能，例如，如果您想使组件可扩展。我们可以使用HOC模式，而不是像之前那样只创建一个有状态的容器。让我们将我们的有状态容器组件重构为HOC，并将其命名为`makeExpandable`：'
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `makeExpandable` component accepts `ComponentToEnrich`. So, we can create
    a root component (`App`) like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeExpandable`组件接受`ComponentToEnrich`。因此，我们可以创建一个根组件（`App`）如下：'
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Cool, isn''t it? Now, let''s create some other component and enrich it with
    our HOC. This will be a small button that displays the text hide or show. If the
    user presses the button, it should show or hide a small colored box. For this
    task, you can use the following styles:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 酷，不是吗？现在，让我们创建一些其他组件，并用我们的HOC来丰富它。这将是一个显示文本隐藏或显示的小按钮。如果用户按下按钮，它应该显示或隐藏一个小的彩色框。对于这个任务，你可以使用以下样式：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Place them within `StyleSheet.create({ ... })`. My solution is pretty straightforward:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们放在`StyleSheet.create({ ... })`中。我的解决方案非常简单：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, the `SomeSection` component is wrapped by the `makeExpandable` HOC,
    and receives the `isExpanded` and `expandOrCollapse` props.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`SomeSection`组件被`makeExpandable` HOC包装，并接收`isExpanded`和`expandOrCollapse`属性。
- en: Great! We have just made a reusable HOC, and it is working flawlessly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚制作了一个可重用的HOC，它运行得非常完美。
- en: 'Now, I will show you a rather unknown but sometimes useful technique to push
    your HOC to be even more flexible. Imagine that you are about to enhance a component
    that is strict about props naming, as in the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将向您展示一个相当不为人知但有时很有用的技术，可以使您的HOC更加灵活。想象一下，您将增强一个对属性命名要求严格的组件，就像以下示例中一样：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unfortunately, our HOC, `makeExpandable`, is passing the wrong prop names.
    Let''s fix that:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的HOC，“makeExpandable”，传递了错误的属性名称。让我们来修复一下：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a tricky example. It provides a capability to rename props that are
    passed down by HOC. To rename it, we need to pass a configuration object called
    `propNames` to HOC. If such an object is passed, and it contains a certain key,
    then we override the name. If the key is not present, then we fall back to the
    default prop name, for instance, `isExpanded`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的例子。它提供了重命名由HOC传递的属性的能力。要重命名它，我们需要将一个名为`propNames`的配置对象传递给HOC。如果传递了这样的对象，并且它包含某个键，那么我们将覆盖该名称。如果该键不存在，则我们将回退到默认的属性名称，例如`isExpanded`。
- en: Notice the use of `[]` inside of the object. It allows you to dynamically name
    keys in the object. In this example, the key was dynamically chosen based on the
    presence of `propNames`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对象内部的`[]`的使用。它允许您在对象中动态命名键。在这个例子中，键是根据`propNames`的存在动态选择的。
- en: 'To make everything work, we also need to accept the optional argument `propNames`in
    the `makeExpandable` HOC:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切正常工作，我们还需要在`makeExpandable` HOC中接受可选参数`propNames`：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Cool! Now our HOC is more flexible when it comes to prop names! We can use
    it with the aforementioned strict `SomeSection` component:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们的HOC在处理prop名称时更加灵活了！我们可以将其与前面提到的严格的`SomeSection`组件一起使用：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Beware of the performance implications when creating variables inside the `render`
    function. It will slow your application down. Sometimes, patterns can sacrifice
    performance a little and sometimes they cannot. Use them wisely. You could also
    the inline `propNames` variable as two props.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`函数内创建变量时要注意性能影响。它会减慢你的应用程序。有时，模式可能会牺牲一点性能，有时则不会。明智地使用它们。你也可以将内联的`propNames`变量作为两个props。
- en: Make sure to check the next section for a cleaner and decoupled approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确保查看下一节以获得更清晰和解耦的方法。
- en: HOC composition
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HOC组合
- en: The primary reason to create HOCs it to have the ability to compose the features
    they provide.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HOC的主要原因是能够组合它们提供的功能。
- en: 'Look at the problem from the previous section again. What if we could delegate
    work to another HOC? For instance, having a mapper HOC called `mapPropNames`,
    you can compose it with our previous HOC like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从上一节的问题来看。如果我们可以将工作委托给另一个HOC呢？例如，有一个名为`mapPropNames`的mapper HOC，你可以像这样与我们之前的HOC组合：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is the implementation of `mapPropNames`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`mapPropNames`的实现：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Nice and quick, isn't it? This is a common pattern and is also used when working
    with backend data sent as JSON. It may adapt the data format to our representation
    on the frontend layer. As you see, we can employ this great idea when working
    with HOCs as well!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，很快，不是吗？这是一个常见的模式，也在处理作为JSON发送的后端数据时使用。它可以将数据格式适应到前端层的表示。正如你所看到的，我们在处理HOC时也可以采用这个好主意！
- en: If you come from an object-oriented background, please notice that the HOC pattern
    is very similar to the decorator pattern. The decorator, however, also relies
    on inheritance and needs to implement the interface that it decorates.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象的背景，请注意HOC模式与装饰器模式非常相似。然而，装饰器还依赖继承，并且需要实现它装饰的接口。
- en: Please check [https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)
    for examples.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)以获取示例。
- en: You can also compose decorators. It works in a similar way.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以组合装饰器。它的工作方式类似。
- en: Examples of useful HOCs
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的HOC示例
- en: 'Do you need a quick logger that will show you how your app behaves? Or maybe
    you are preparing a live presentation and you want to show some dynamic information
    on a screen? Here we go:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个快速的记录器来显示应用程序的行为吗？或者你正在准备一个实时演示，想在屏幕上显示一些动态信息？来吧：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Okay, good. Now, let''s suppose that you are waiting on some data to load.
    Here comes the spinner:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在，假设你正在等待一些数据加载。这里就是加载动画：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You might want to ask a user to five star your app. You need a modal to do
    this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要求用户为你的应用打五星。你需要一个模态框来做这个：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Sometimes, modals should be intelligent enough to maintain their visibility,
    too:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模态框也应该足够智能，以维持它们的可见性。
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we enriched the component with `Modal`. `Modal` can be opened
    or closed using the props that are named `openModal` and `closeModal`. The information
    regarding whether the modal is opened or closed is stored within a private state
    of the HOC and, in this example, is not exposed to the original component. Nice
    separation, right? This HOC is also reusable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们用`Modal`来丰富组件。`Modal`可以使用名为`openModal`和`closeModal`的props打开或关闭。关于模态框是打开还是关闭的信息存储在HOC的私有状态中，在这个例子中不会暴露给原始组件。很好的分离，对吧？这个HOC也是可重用的。
- en: 'Time for your homework: how do we make `Modal` open along with the box show?
    You cannot change `SomeComponent`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你的作业时间：我们如何使`Modal`在盒子显示的同时打开？你不能改变`SomeComponent`。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to create basic components with React
    in the React Native environment. Now, you should be fairly comfortable with stateless
    and stateful components. In addition, you learned about presentational and container
    components. You know that these patterns serve to decouple markup and logic. You
    have also learned how to enhance component features by using HOCs. Hopefully,
    you have also played with the ready-to-run examples that I collected for you in
    the Git repository.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你已经学会了如何在React Native环境中使用React创建基本组件。现在，你应该对无状态和有状态组件感到相当舒适。此外，你还学会了关于展示性和容器性组件。你知道这些模式用于解耦标记和逻辑。你还学会了如何通过使用高阶组件来增强组件功能。希望你也已经在Git存储库中玩过我为你收集的可运行示例。
- en: In [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View Patterns*,
    we will focus more on the markup. You will also learn about a handful of tags
    that you can use.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml) *视图模式* 中，我们将更多关注标记。你还将学习一些可以使用的标签。
