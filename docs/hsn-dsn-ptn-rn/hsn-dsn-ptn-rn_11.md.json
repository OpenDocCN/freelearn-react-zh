["```jsx\n// Passing by value\n\nfunction increase(x) {\n    x = x + 1;\n    return x;\n}\n\nvar num = 5;\nincrease(num);\nconsole.log(num); // prints 5\n```", "```jsx\n// Passing by reference\n\nfunction increase(obj) {\n    obj.x = obj.x + 1;\n    return obj;\n}\n\nvar numObj = { x: 5 };\nincrease(numObj);\nconsole.log(numObj); // prints { x: 6 }\n```", "```jsx\nfunction increase(obj) {\n    obj.x = obj.x + 1;\n    return obj;\n}\n\nvar numObj = { x: \"5\" };\nincrease(numObj);\nconsole.log(numObj); // prints { x: \"51\" }\n```", "```jsx\n// Runtime checking if obj.x is a number\n\nfunction increase(obj) {\n if (**typeof obj.x === 'number'**) {\n        obj.x = obj.x + 1;\n        return obj;\n    } else {\n        throw new Error(\"Obj.x must be a number\");\n    }\n}\n\nvar numObj = { x: \"5\" };\nincrease(numObj);\nconsole.log(numObj); // do not print, an Error message is shown\n// Uncaught Error: Obj.x must be a number\n```", "```jsx\ntype ObjXType = {\n x: number\n}\n\nfunction increase(obj: ObjXType) {\n    obj.x = obj.x + 1;\n    return obj;\n}\n\nvar numObj = { x: \"5\" };\nincrease(numObj);\nconsole.log(numObj);\n```", "```jsx\nArgument of type '{ x: string; }' is not assignable to parameter of type 'ObjXType'.\n Types of property 'x' are incompatible.\n **Type 'string' is not assignable to type 'number'.**\n```", "```jsx\n// src/ Chapter_11/ Example_1_TypeScript_support/ App.js\n\nimport StandaloneApp from './build/dist/Root'; import StoryBookApp from './build/dist/storybook';   // ... export default process.env['REACT_NATIVE_IS_STORY_BOOK'] ? StoryBookApp : StandaloneApp; \n```", "```jsx\nimport PropTypes from 'prop-types';   export const NavigateButton = ({\n    navigation, to, data, text\n}) => (\n    // ...  );   NavigateButton.propTypes = {\n    // ...\n};  \n```", "```jsx\nimport {\n    NavigationParams, NavigationScreenProp, NavigationState\n} from 'react-navigation';   type NavigateButtonProps = {\n to: string,\n data: any,\n text: string,\n **navigation: NavigationScreenProp<NavigationState, NavigationParams>** }; \n```", "```jsx\nexport const NavigateButton:React.SFC<NavigateButtonProps> = ({\n    navigation, to, data, text }) => (\n    // ...  );\n\n// Full example available at\n// src/ Chapter_11/ Example_1/ src/ common/ NavigateButton/ view.tsx\n```", "```jsx\nconst ENV_TEST = 'environment_test';\n// ...\n\nconst availableEnvironments = [ENV_TEST, ENV_DEV, ENV_QA, ENV_PROD]\n```", "```jsx\n// src/ Chapter_11/\n// Example_2/ src/ features/ tasks/ actions/ TasksActionTypes.ts\n\nenum TasksActionType {\n    ADD_TASK = 'ADD_TASK',\n  TASKS_FETCH_START = 'TASKS_FETCH_START',\n  TASKS_FETCH_COMPLETE = 'TASKS_FETCH_COMPLETE',\n  TASKS_FETCH_ERROR = 'TASKS_FETCH_ERROR',\n  TASK_FETCH_START = 'TASK_FETCH_START',\n  TASK_FETCH_COMPLETE = 'TASK_FETCH_COMPLETE',\n  TASK_FETCH_ERROR = 'TASK_FETCH_ERROR' }\n```", "```jsx\nexport type TaskAddFormData = {\n    name: string,\n  description: string }\n\nexport type AddTaskActionType = {\n type: TasksActionType.ADD_TASK,\n task: TaskAddFormData\n};\n```", "```jsx\n// src/ Chapter_11/\n// Example_2/ src/ features/ tasks/ actions/ TaskActions.ts\n\nconst addTask = (task:TaskAddFormData): AddTaskActionType => ({\n    type: TasksActionType.ADD_TASK,\n  task\n});\n```", "```jsx\nexport type TaskReduxActionType =\n    AddTaskActionType |\n    TasksFetchActionType |\n    TasksFetchCompleteActionType |\n    TasksFetchErrorActionType |\n    TaskFetchActionType |\n    TaskFetchCompleteActionType |\n    TaskFetchErrorActionType;\n```", "```jsx\n// src/ Chapter_11/ \n// Example_3/ src/ features/ tasks/ state/ reducers/ tasksReducer.ts\n\nconst tasksReducer = (\n    state = Immutable.Map<string, any>({\n        entities: Immutable.List<TaskType>([]),\n  isLoading: false,\n  hasError: false,\n  errorMsg: ''\n  }),\n  action:TaskReduxActionType\n) => {\n    // ...\n}\n```", "```jsx\ntype TaskType = {\n    name: string,\n    description: string\n    likes: number,\n  id: number }\n```", "```jsx\n\nexport type TaskAddFormData = {\n    name: string,\n  description: string }\n\nexport type TaskType = TaskAddFormData & {\n    likes: number,\n  id: number }\n```", "```jsx\n{\n    name: string,\n    description: string\n    likes: number,\n  id: number\n}\n```", "```jsx\ntype NavigateButtonProps = {\n    to: string,\n  data: any,\n  text: string,\n  navigation: NavigationScreenProp<NavigationState, NavigationParams>\n};\n```", "```jsx\n// src/ Chapter_11/ \n// Example_3/ src/ common/ NavigateButton/ view.tsx\n\nimport { NavigationInjectedProps, NavigationParams } from 'react-navigation';   type NavigateButtonProps = {\n    to: string,\n  data: any,\n  text: string, } & NavigationInjectedProps<NavigationParams>;\n```", "```jsx\nImmutable.List<TaskType>\n```", "```jsx\nexport type MaybeType<T> = Something<T> | Nothing; \nconst Maybe = <T>(value: T):MaybeType<T> => {\n    // ...  }; \n```", "```jsx\nexport type Nothing = {\n    map: (args: any) => Nothing,\n  isNothing: () => true,\n  val: () => **null** }\n```", "```jsx\nexport type Something<T> = {\n    map: <Z>(fn: ((a:T) => Z)) => MaybeType<Z>,\n  isNothing: () => false,\n  val: () => T\n}\n```", "```jsx\nexport type MaybeType<T> = {\n    map: <Z>(fn: ((a:T) => Z)) => (MaybeType<Z> | Nothing),\n  isNothing: () => boolean,\n  val: () => (T | null)\n}\n```", "```jsx\n// src/ Chapter_11/ \n// Example_4/ src/ features/ tasks/ state/ selectors/ tasks.ts\n\nexport const tasksSelector =\n    (state: TasksState):MaybeType<Immutable.Map<string, any>> =>\n        Maybe<TasksState>(state).map((x:TasksState) => x.tasks);\n```", "```jsx\nconst someVar = 123; // someVar type is number\n```", "```jsx\nenum FLAVOURS {\n    CHOCOLATE = 'Chocolate',\n    VANILLA = 'Vanilla',\n}\ntype ChocolateDonut = { flavour: FLAVOURS.CHOCOLATE }\n\nconst clone = <T>(sth:T):T => JSON.parse(JSON.stringify(sth));\n\nconst produceBox: <T>(recipe: T) => T[] = <T>(recipe: T) => [\n    clone(recipe), clone(recipe), clone(recipe)\n];\n\n// box type is inferred\nconst box = produceBox<ChocolateDonut>({ flavour: flavours.CHOCOLATE });\n\n// inferred type correctly contains flavor key within donut object\nfor (const donut of box) {\n    console.log(donut.flavour);\n} // compiles and when run prints \"Chocolate\" three times\n```", "```jsx\ninterface Donut {\n    flavour: FLAVOURS;\n}\n\nclass ChocolateDonut {\n    flavour: FLAVOURS.CHOCOLATE;\n}\n\nlet p: Donut;\n\n// OK, because of structural typing\np = new ChocolateDonut();\n```", "```jsx\nclass ChocolateDonut implements Donut {\n    flavour: FLAVOURS.CHOCOLATE;\n}\n```", "```jsx\nexport type TasksReducerState = {\n    readonly entities: TaskType[],\n readonly isLoading: boolean,\n readonly hasError: boolean,\n readonly errorMsg: string }\n```", "```jsx\nexport type TasksReducerState = Readonly<{\n    entities: TaskType[],\n  isLoading: boolean,\n  hasError: boolean,\n  errorMsg: string }>\n```", "```jsx\nexport type TasksReducerState = Readonly<{\n    entities: ReadonlyArray<TaskType>,\n // ...  }>\n```", "```jsx\n\"no-var-keyword\": true,  \"no-let\": true,  \"no-object-mutation\": true, \"no-delete\": true,  \"no-parameter-reassignment\": true,  \"readonly-keyword\": true, \"readonly-array\": true,\n```", "```jsx\n  yarn run lint\n```"]