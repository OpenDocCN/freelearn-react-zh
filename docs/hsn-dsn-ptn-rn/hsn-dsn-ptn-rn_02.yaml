- en: View Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看模式
- en: One very demanding skill is writing good view code the first time around. It
    comes with experience and becomes almost automatic at some point. Hence, it is
    vital to do it right from the beginning. In this chapter, we will explore best
    practices and go through the React JSX patterns that you already used in the previous
    chapter. We will also focus on the broader spectrum of built-in components, which
    include input and forms. At the very end, I will show you a nice tool called a
    linter that is essential for any new frontend project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常苛刻的技能是第一次写好视图代码。这需要经验，并且在某个时候几乎变得自动化。因此，从一开始就做对是至关重要的。在本章中，我们将探讨最佳实践，并深入研究您在上一章中已经使用的React
    JSX模式。我们还将专注于更广泛的内置组件范围，其中包括输入和表单。最后，我将向您展示一个名为linter的好工具，它对于任何新的前端项目都是必不可少的。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Write concise JSX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写简洁的JSX
- en: Use common React Native built-in components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常见的React Native内置组件
- en: Create simple forms using `TextInput`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TextInput`创建简单的表单
- en: Distinguish between controlled and uncontrolled input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分受控和不受控输入
- en: Create error boundaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建错误边界
- en: Eliminate Mixins from your code base
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从代码库中消除混合物
- en: Set up a linter to enforce your code style guide
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个代码风格指南的linter
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will learn about various patterns, along with their code
    snippets. However, to run them, you will need the Create React Native App package.
    I have separated every example into a standalone application that you can launch
    on your phone or simulator.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解各种模式，以及它们的代码片段。但是，要运行它们，您将需要Create React Native App包。我已经将每个示例分成一个独立的应用程序，您可以在手机或模拟器上启动。
- en: 'To follow along with the examples in this chapter, you will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着本章的示例，您将需要以下内容：
- en: An Android/iOS phone or simulator
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Android/iOS手机或模拟器
- en: Git, to pull the examples: [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git，获取示例：[https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native)
- en: Follow the installation and running instructions from the GitHub page to get
    started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 按照GitHub页面上的安装和运行说明开始。
- en: Introduction to JSX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX简介
- en: We have been using JSX so far, but what does it mean? JSX stands for JavaScript
    extension. How can it be an extension?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用JSX，但是它是什么意思呢？JSX代表JavaScript扩展。它怎么能是一个扩展呢？
- en: As you probably know, ECMAScript is also an extension to JavaScript (kind of).
    ECMAScript transpiles to JavaScript. What does this mean? It means that it just
    transforms ECMAScript code into valid JavaScript code. JavaScript misses out on
    many features that we like from ECMAScript, such as arrow functions, classes,
    and destructuring operators.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道，ECMAScript也是JavaScript的一个扩展（有点）。ECMAScript被转译成JavaScript。这意味着什么？这意味着它只是将ECMAScript代码转换为有效的JavaScript代码。JavaScript缺少我们从ECMAScript中喜欢的许多功能，例如箭头函数、类和解构运算符。
- en: JSX works the same way. JSX is being transpiled to JavaScript, and its main
    feature is creating React elements based on the markup you write.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JSX的工作方式也是一样的。JSX被转译成JavaScript，它的主要特点是根据您编写的标记创建React元素。
- en: Could we use only JavaScript? Yes. Is it worth it? Most likely not.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能只使用JavaScript吗？是的。值得吗？很可能不值得。
- en: 'Let''s check this out in action. This is JSX *and* ECMAScript:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实例。这是JSX *和* ECMAScript：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, compare this to pure JavaScript:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这与纯JavaScript进行比较：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's no doubt that the first code snippet is easier to read and understand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，第一个代码片段更容易阅读和理解。
- en: Babel transpiles JSX to JavaScript. Check out this interactive tool so that
    you can play around and see what the output is in more complex examples: [https://goo.gl/RjMXKC](https://goo.gl/RjMXKC).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Babel将JSX转译为JavaScript。查看这个交互式工具，以便您可以玩耍并查看更复杂示例中的输出：[https://goo.gl/RjMXKC](https://goo.gl/RjMXKC)。
- en: JSX standard tricks
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX标准技巧
- en: Before we proceed further, I want to show you the best practices when it comes
    to writing your JSX markup. This will make your journey through my further examples
    much easier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想向您展示在编写JSX标记时的最佳实践。这将使您在接下来的示例中更容易理解。
- en: 'Let''s start with the simple rules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的规则开始：
- en: 'If there are no children within your component, use a self-closing tag:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的组件内没有子元素，请使用自闭合标签：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you need to display a component based on some condition, then use the `&&` operator:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要根据某些条件显示组件，则使用`&&`运算符：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding practices only apply if the other option is `null`. If the false
    case is also a component, you can use the *b ? x : y* operator or even a simple `if-else` approach,
    however, it should comply with your project''s best practices.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '前述做法仅适用于其他选项为`null`的情况。如果false情况也是一个组件，您可以使用`*b ? x : y*`运算符，甚至是简单的`if-else`方法，但是它应符合您项目的最佳实践。'
- en: 'If you use the *b ? x : y* operator, then you may find that curly braces (`{}`)
    come in handy:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果使用`*b ? x : y*`运算符，则可能会发现大括号（`{}`）很有用：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also use curly braces (`{}`) to destructure props objects:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用大括号（`{}`）来解构props对象：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to pass `isLoggedIn` as `true`, you can do so by just writing the
    prop name:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要将`isLoggedIn`传递为`true`，只需写入prop名称即可：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In some cases, you may want to pass on all of the other props. You can use
    the spread operator in such a case:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望传递所有其他props。在这种情况下，您可以使用展开运算符：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A beginner's guide to naming
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初学者命名指南
- en: Naming may sound trivial, but there are some standard practices in React that
    you should comply with. These practices may vary from project to project, but
    keep in mind that you should respect at least the ones that are mentioned here.
    In other cases, check your project's style guide and possibly your linter configuration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 命名可能听起来微不足道，但在React中有一些标准做法，您应该遵守。这些做法可能因项目而异，但请记住，您至少应该尊重这里提到的做法。在其他情况下，请检查您项目的样式指南，可能还有您的linter配置。
- en: One of the great React style guides comes from Airbnb and can be checked out
    at [https://github.com/airbnb/javascript/tree/master/react#naming](https://github.com/airbnb/javascript/tree/master/react#naming).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的React样式指南之一来自Airbnb，可以在[https://github.com/airbnb/javascript/tree/master/react#naming](https://github.com/airbnb/javascript/tree/master/react#naming)上查看。
- en: 'A component name should start with an uppercase letter unless it''s a HOC.
    Use the component name as the filename. The filename should be in UpperCamelCase
    (for more information on CamelCase, see [https://en.wikipedia.org/wiki/Camel_case](https://en.wikipedia.org/wiki/Camel_case)):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 组件名称应以大写字母开头，除非它是HOC。使用组件名称作为文件名。文件名应为UpperCamelCase（有关CamelCase的更多信息，请参见[https://en.wikipedia.org/wiki/Camel_case](https://en.wikipedia.org/wiki/Camel_case)）：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are rules on importing your component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关导入组件的规则：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If it's HOC, start its name with a lowercase letter in lower CamelCase, for
    instance, `makeExpandable`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是HOC，请使用小写字母的小驼峰命名法开始其名称，例如`makeExpandable`。
- en: 'Airbnb also suggests that you take care of the name of the inner component.
    We need to specify a `displayName` prop to do, as in the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Airbnb还建议您注意内部组件的名称。我们需要指定`displayName`属性，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a valid point as in some tools you may benefit from seeing the proper
    component names. Following this pattern is optional and up to the team to decide
    upon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的观点，因为在某些工具中，您可能会从看到正确的组件名称中受益。遵循此模式是可选的，并由团队决定。
- en: One can create a HOC that takes care of the `displayName` prop. Such a HOC can
    be reused on top of the HOCs we created in [Chapter 1](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml),
    *React Component Patterns*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个HOC来处理`displayName` prop。这样的HOC可以在我们在[第1章](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml)中创建的HOC之上重复使用，*React组件模式*。
- en: When defining new props, please avoid the common props that used to mean something
    else. An example may be the style prop we used to pass styles to our components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义新的props时，请避免使用曾经表示其他含义的常见props。一个例子可能是我们用来将样式传递给组件的style prop。
- en: 'Please check out the following links to check what props you should avoid using:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下链接，了解应避免使用哪些props：
- en: 'Props corresponding to your application layout:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与您的应用程序布局对应的Props：
- en: '[https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html)'
- en: 'Props reserved for component styling, as it may create confusion:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组件样式保留的Props，因为它可能会造成混淆：
- en: '[https://facebook.github.io/react-native/docs/image-style-props.html](https://facebook.github.io/react-native/docs/image-style-props.html)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/image-style-props.html](https://facebook.github.io/react-native/docs/image-style-props.html)'
- en: '[https://facebook.github.io/react-native/docs/text-style-props.html](https://facebook.github.io/react-native/docs/text-style-props.html)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/text-style-props.html](https://facebook.github.io/react-native/docs/text-style-props.html)'
- en: '[https://facebook.github.io/react-native/docs/view-style-props.html](https://facebook.github.io/react-native/docs/view-style-props.html)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/view-style-props.html](https://facebook.github.io/react-native/docs/view-style-props.html)'
- en: Don't get too scared. It will feel more natural sooner or later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太害怕。迟早会感觉更自然。
- en: Type checking with PropTypes
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PropTypes进行类型检查
- en: React comes with support for basic type checking. It does not require you to
    upgrade to TypeScript or another, more advanced solution. To achieve type checking
    straight away, you can use the `prop-types` library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React带有对基本类型检查的支持。它不需要您升级到TypeScript或其他更高级的解决方案。要立即实现类型检查，您可以使用`prop-types`库。
- en: 'Let''s provide type definitions for our `HelloBox` component from`Chapter 1/Example
    12`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Chapter 1/Example 12`中的`HelloBox`组件提供类型定义：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This way, we force `isExpanded` to be of the Boolean type (`true` or `false`),
    and `expandOrCollapse` to be a function. We also let React know about two optional
    style props (`containerStyles` and `expandedTextStyles`). If styles are not provided,
    we simply return the default styles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们强制`isExpanded`为布尔类型（`true`或`false`），并且`expandOrCollapse`为函数。我们还让React知道两个可选的样式props（`containerStyles`和`expandedTextStyles`）。如果未提供样式，我们将简单地返回默认样式。
- en: 'There is also a neat feature to avoid explicit `if` in the markup—default props.
    Check it out:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记中还有一个很好的功能可以避免显式的`if`——默认props。看一下：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Cool! Now, if `containerStyles` or `expandedTextStyles` are be null, then they
    will get a respective default value. However, if you run your application now,
    you will notice a little warning:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，如果`containerStyles`或`expandedTextStyles`为null，那么它们将获得相应的默认值。但是，如果您现在运行应用程序，您会注意到一个小警告：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may be freaking out right now, but this is correct. This is a nice optimization
    that has been made by the React Native team that you may not be aware of. It caches
    the stylesheet and simply sends the cached ID. The following line is returning
    the number and ID of a stylesheet that represents the `styles` object that was
    passed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能感到恐慌，但这是正确的。这是React Native团队做出的一个很好的优化，你可能不知道。它缓存样式表，只是发送缓存的ID。以下行返回了表示传递的`styles`对象的样式表的数字和ID：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Hence, we need to adapt our type definitions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要调整我们的类型定义：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can remove explicit `if` statements in the component markup. It should
    look more or less like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在组件标记中删除显式的`if`语句。它应该看起来更或多如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Good job! We have defined default props and type checks for our component. Please
    check the full working `Example 2` in the `src/chapter 2` directory for more details.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们已经为我们的组件定义了默认属性和类型检查。请查看`src/chapter 2`目录中的完整工作`Example 2`以获取更多详细信息。
- en: Please note that, from now on, all code examples will be split into a few modular
    source files. All files will be placed under the `./src` directory of the respective
    example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从现在开始，所有的代码示例都将被拆分成几个模块化的源文件。所有文件将放在各自示例的`./src`目录下。
- en: 'For instance, `Example 2` is organized in the following way:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Example 2`的组织方式如下：
- en: '`src`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`'
- en: '`HelloBox.js`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloBox.js`'
- en: '`HelloText.js`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloText.js`'
- en: '`makeExpandable.js`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeExpandable.js`'
- en: '`App.js`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.js`'
- en: This structure will evolve as the application grows. In [Chapter 10](02308da0-7093-4573-97b0-30d147b28cc2.xhtml),
    *Managing Dependencies*, you will learn how to organize files in big projects
    with over one million lines of code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构将随着应用程序的发展而发展。在[第10章](02308da0-7093-4573-97b0-30d147b28cc2.xhtml)中，*管理依赖关系*，您将学习如何在拥有一百万行代码的大型项目中组织文件。
- en: Built-in components you need to know about
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您需要了解的内置组件
- en: React Native is growing fast and changing often. I have selected a curated list
    of components that are likely to stay within the API for a long time. We will
    spend some time learning them so that we will be able to proceed faster later
    on in this book. Any further examples will rely on these components and will assume
    that you know what these components are for.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: React Native正在快速发展并经常变化。我已经选择了一系列组件的精选列表，这些组件可能会在API中长期存在。我们将花一些时间学习它们，这样我们以后在这本书中就能更快地进行下去。任何进一步的示例都将依赖于这些组件，并假设您知道这些组件的用途。
- en: The ScrollView component
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScrollView组件
- en: 'So far, we know about three components: `View` , `Text`, and `StyleSheet`.
    Now, imagine a case where we have a lot of rows to show in the application—something
    such as table of information pops into my mind. Obviously, it will be a long table,
    but the screen is small, so we will make it scrollable—up and down, like in a
    browser. This may seem trivial as a concept, but this isn''t very easy to implement,
    which is why React Native provides the `ScrollView` component.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道了三个组件：`View`，`Text`和`StyleSheet`。现在，想象一种情况，我们在应用程序中有很多行要显示——比如我脑海中浮现出的信息表。显然，这将是一个很长的表，但屏幕很小，所以我们将使其可滚动——上下滚动，就像在浏览器中一样。这在概念上可能看起来微不足道，但实现起来并不容易，这就是为什么React
    Native提供了`ScrollView`组件。
- en: Let's see this problem in action. Check out `Example 3_ No ScrollView problem`
    from the `Chapter 2` folder to get started.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个问题是如何发生的。从`Chapter 2`文件夹中查看`Example 3_ No ScrollView problem`来开始。
- en: 'Here, we have a typical `TaskList` component, which converts every task into
    a `Task` component. `Task` displays its name and description as `Text`. It''s
    a very simple mechanism, but once a number of tasks is huge, such as 20 or more
    tasks, it fills the entire screen, and suddenly you realize that you cannot scroll
    like in a browser window:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个典型的`TaskList`组件，它将每个任务转换为一个`Task`组件。`Task`以`Text`的形式显示其名称和描述。这是一个非常简单的机制，但是一旦任务数量庞大，比如20个或更多个任务，它就会填满整个屏幕，突然间你意识到你无法像在浏览器窗口中那样滚动：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To fix this issue and make the content scrollable, replace `View` with `ScrollView`.
    You also need to rename the `style` prop to `contentContainerStyle`. Please see
    the full example, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并使内容可滚动，将`View`替换为`ScrollView`。您还需要将`style`属性重命名为`contentContainerStyle`。请参见完整示例，如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I have also included `PropTypes` definitions so that you can practice what we
    have learned in the previous section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我还包括了`PropTypes`定义，这样您就可以练习我们在上一节中学到的内容。
- en: Notice the use of the `key` prop (`key={task.name + task.description}`) on the
    `Task` component. This is required when you render collections so that React can
    distinguish elements on prop changes and, if possible, avoid unnecessary repainting
    of the component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在“Task”组件上使用“key”属性（“key={task.name + task.description}”）。这在渲染集合时是必需的，以便React可以区分元素的属性更改，并在可能的情况下避免不必要的重绘组件。
- en: The Image component
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像组件
- en: 'The next component that you will often use is the `Image` component. Let''s
    extend our task list with the React logo. After each task, we will show a `.png`
    image of the React logo:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会使用的下一个组件是“Image”组件。让我们用React标志扩展我们的任务列表。在每个任务之后，我们将展示React标志的.png图片：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Please note that not every image type is supported right now. For instance,
    SVG images will need a separate library to work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前并非所有图像类型都受支持。例如，SVG图像将需要一个单独的库来工作。
- en: You can check out the props that the `Image` component consumes in the official
    documentation here: [https://facebook.github.io/react-native/docs/image](https://facebook.github.io/react-native/docs/image).
    You will find useful props such as `loadingIndicatorSource` here—this is an image
    that is shown while a big source image is loading.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中查看“Image”组件消耗的props：[https://facebook.github.io/react-native/docs/image](https://facebook.github.io/react-native/docs/image)。您会在这里找到有用的props，比如“loadingIndicatorSource”——这是在加载大源图像时显示的图像。
- en: The TextInput component
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本输入组件
- en: We will use this component often in the next section. The general idea is to
    be able to pass data from a smartphone keyboard. `TextInput` is used in login
    and registration forms and many other places where the user needs to send text
    data to an application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节经常使用这个组件。总体思路是能够从智能手机键盘传递数据。“TextInput”用于登录和注册表单以及用户需要向应用程序发送文本数据的许多其他地方。
- en: 'Let''s extend the `HelloWorld` example from [Chapter 1](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml),
    *React Component Patterns*, to accept a name:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展[第1章](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml)中的“HelloWorld”示例，“React组件模式”，以接受一个名字：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If a user enters text in the `TextInput` component, then we display the entered
    text in a short greeting. Conditional rendering uses `state` to check whether
    the name has been defined or not. As the user types, the `onChangeText` event
    handler is invoked, and the function we passed updates the state with the new
    name.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在“TextInput”组件中输入文本，那么我们会在简短的问候语中显示输入的文本。条件渲染使用“state”来检查名字是否已经定义。当用户输入时，“onChangeText”事件处理程序被调用，并且我们传递的函数会用新的名字更新状态。
- en: Sometimes, native keyboards may overlap with your `View` component and hide
    important information. Please get familiar with the `KeyboardAvoidingView` component
    if this is the case in your app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，本地键盘可能会与您的“View”组件重叠，并隐藏重要信息。如果您的应用程序出现这种情况，请熟悉“KeyboardAvoidingView”组件。
- en: Check out [https://facebook.github.io/react-native/docs/keyboardavoidingview.html](https://facebook.github.io/react-native/docs/keyboardavoidingview.html) for
    more information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://facebook.github.io/react-native/docs/keyboardavoidingview.html](https://facebook.github.io/react-native/docs/keyboardavoidingview.html)获取更多信息。
- en: The Button component
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮组件
- en: '`Button` is such a common component that you will find yourself using it in
    any kind of app. Let''s build a small `like` counter with up and down buttons:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “Button”是一个常见的组件，你会发现自己在任何类型的应用程序中使用它。让我们用上下按钮构建一个小的“like”计数器：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Further modifications to this concept can implement upvotes/downvotes for comments
    or a star system for reviews.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个概念的进一步修改可以实现对评论的点赞/踩或者对评论的星级评价系统。
- en: The `Button` component is very limited, and those who are used to web development
    may be surprised. For instance, you cannot set the text in a web-way, for example, `<Button>Like</Button>`, nor
    can you pass the style prop. If you need to style your button, please use `TouchableXXXX`.
    Check out the next section for an example on `TouchableOpacity`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`组件非常有限，习惯于Web开发的人可能会感到惊讶。例如，您不能以Web方式设置文本，例如`<Button>Like</Button>`，也不能传递样式属性。如果您需要为按钮设置样式，请使用`TouchableXXXX`。查看下一节以获取`TouchableOpacity`的示例。'
- en: Touchable opacity
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不透明的触摸
- en: 'When a button needs a custom look, it quickly seems like you need a better
    alternative. This is where `TouchableOpacity` comes into play. It serves every
    purpose when inner content needs to become touchable. Hence, we will make our
    own button and style it as we like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮需要自定义外观时，很快似乎需要更好的替代方案。这就是`TouchableOpacity`发挥作用的地方。当内部内容需要变得可触摸时，它可以满足任何目的。因此，我们将制作自己的按钮并根据需要进行样式设置：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Some example styles follow. We will dig further into styles in [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml),
    *Styling Patterns*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例样式。我们将在[第3章](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml)中深入探讨样式模式：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The button's contents are centered vertically and horizontally. We have a custom
    gray background color and padding inside of the button. Padding is the space from
    the children to the border of the component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的内容在垂直和水平方向上都居中。我们有一个自定义的灰色背景颜色和按钮内的填充。填充是从子元素到组件边框的空间。
- en: Now that we know about these simple components, we are ready to proceed further
    and explore how forms are built and how to handle more complicated use cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这些简单的组件，我们准备进一步探索如何构建表单以及如何处理更复杂的用例。
- en: Building forms
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表单
- en: 'In this section, we will explore how we can handle text input from users. Traditional
    means of collecting input from so-called forms is divided into two major ways:
    controlled and uncontrolled. In a native environment, this means either handling
    any keypress on the React Native side (c*ontrolled input*), or letting it be handled
    on the native system level and collecting data in React on demand (*uncontrolled
    input*).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何处理用户的文本输入。从所谓的表单中收集输入的传统方式分为两种主要方式：受控和不受控。在本机环境中，这意味着要么在React Native端处理任何按键（*受控输入*），要么让其在本机系统级别上处理并根据需要在React中收集数据（*不受控输入*）。
- en: If you come from a web development background, please note that, at the time
    of writing this book, there is no form component, and I don't see it coming. There
    are also limitations to refs and what you can do with them. For instance, you
    cannot ask a ref to a `TextInput` for its current value. Please follow the following
    two subsections for more details. You can also use custom libraries, but I will
    not discuss such solutions here as these tend to change often.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自Web开发背景，请注意，写作本书时，没有表单组件，我也看不到它的出现。对于引用和您可以使用它们的方式也有限制。例如，您不能要求`TextInput`的引用获取其当前值。请查看以下两个小节以获取更多详细信息。您也可以使用自定义库，但我不会在这里讨论这样的解决方案，因为这些解决方案往往经常变化。
- en: Controlled inputs
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受控输入
- en: Controlled inputs are those which handle all user input on the JavaScript side,
    most likely in the React state or some other state alternative (see [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml),
    *Store Patterns,* for more information). This means that, as the user types, the
    keystrokes are remembered on both the native system level and the JavaScript level.
    This, of course, may be ineffective and should not be used in complicated UIs,
    which appear to be rare in the mobile world.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 受控输入是在JavaScript端处理所有用户输入的输入，很可能是在React状态或其他状态替代品中（有关更多信息，请参见[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)
    *Store Patterns*）。这意味着，当用户输入时，按键在本地系统级别和JavaScript级别都被记住。当然，这可能是低效的，不应该在复杂的UI中使用，这在移动世界中似乎是罕见的。
- en: 'Do you remember the *hello world with your name* example from earlier in this
    chapter? This is a perfect example of controlled input. Let''s see it again:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得本章前面的*带有你的名字的hello world*示例吗？这是受控输入的一个完美例子。让我们再看一遍：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We listen on every change in the text (`onChangeText`) and then immediately
    update the component state (`this.setState({name})`). State becomes a single source
    of truth. We do not need to ask for a native component value. We only care about
    what is in the state. Hence, we use state to display the new `Hello` message,
    along with the typed text.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监听文本的每一次改变（`onChangeText`），然后立即更新组件状态（`this.setState({name})`）。状态成为唯一的真相来源。我们不需要请求本地组件的值。我们只关心状态中的内容。因此，我们使用状态来显示新的`Hello`消息，以及输入的文本。
- en: 'Let''s see how it works in a more complex example. Our task is to create a
    login form with a login `TextInput`, password `TextInput`, and a `Button` component
    with the displayed text Login. Upon a user pressing the button, it should log
    information to our debug console. In a real application, you would pass the login
    details to the server to verify and then log the user in. You will learn how to
    do this in [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store Patterns*,
    when we talk about side effects:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在一个更复杂的例子中它是如何工作的。我们的任务是创建一个登录表单，其中包括登录`TextInput`、密码`TextInput`和一个显示文本为“登录”的`Button`组件。当用户按下按钮时，它应该将信息记录到我们的调试控制台。在一个真实的应用程序中，你会将登录详情传递给服务器进行验证，然后登录用户。你将在[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)
    *Store Patterns*中学习如何做到这一点，当我们讨论副作用时：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Please note three important things here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里的三个重要事项：
- en: It provides the ability to pass remembered login text. The complete feature
    would require remembering the login on the physical device memory, and so I omitted
    this for clarity.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了传递记住的登录文本的能力。完整的功能需要在物理设备内存中记住登录信息，因此我为了清晰起见省略了这一点。
- en: The `secureTextEntry` prop of `TextInput` that hides the password behind dots.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextInput`的`secureTextEntry`属性可以将密码隐藏在点后面。'
- en: The `onPress` handler on the button component so that it can do something with
    the collected data. In this simple example, we just log to the debug console.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在按钮组件上设置`onPress`处理程序，以便它可以对收集到的数据进行操作。在这个简单的例子中，我们只是将日志记录到调试控制台。
- en: Uncontrolled input
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不受控输入
- en: 'Uncontrolled input in React Native is not really what it is in web development.
    In fact, `TextInput` cannot be uncontrolled entirely. You need to listen to a
    value change in some way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: React Native中的不受控输入并不是在Web开发中的真实情况。事实上，`TextInput`不能完全不受控制。你需要以某种方式监听数值的变化：
- en: '`onChangeText` fires every time the text input changes'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChangeText`在文本输入改变时触发'
- en: '`onSubmitEditing` fires when the text input''s submit button is pressed'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubmitEditing`在按下文本输入的提交按钮时触发'
- en: 'Additionally, `TextInput` by itself is a controlled component. Check further
    for an explanation. A long time ago, it used to have a prop called `controlled`
    that allowed you to specify a Boolean value, but this has changed. The documentation
    at that time specified the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`TextInput`本身就是一个受控组件。进一步查看解释。很久以前，它曾经有一个叫做`controlled`的属性，允许您指定一个布尔值，但是这已经改变了。当时的文档指定了以下内容：
- en: '"If you really want this to behave as a controlled component, you can set this
    to true, but you will probably see flickering, dropped keystrokes, and/or laggy
    typing, depending on how you process onChange events."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果您真的希望它表现得像一个受控组件，您可以将其设置为true，但是您可能会看到闪烁、丢失的按键和/或输入延迟，这取决于您如何处理onChange事件。"'
- en: – [https://facebook.github.io/react-native/docs/0.7/textinput.html](https://facebook.github.io/react-native/docs/0.7/textinput.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://facebook.github.io/react-native/docs/0.7/textinput.html](https://facebook.github.io/react-native/docs/0.7/textinput.html)。'
- en: I realize that the React Native team did put a lot of effort into addressing
    these issues and they fixed `TextInput`. However, `TextInput` became a controlled
    input to some extent. For instance, selection on `TextInput` is managed by React
    Native within the `componentDidUpdate` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到React Native团队在解决这些问题上付出了很多努力，并且他们修复了`TextInput`。然而，`TextInput`在某种程度上变成了受控输入。例如，`TextInput`上的选择由React
    Native在`componentDidUpdate`函数中进行管理。
- en: '"Selection is also a controlled prop. If the native value doesn''t match JS,
    update to the JS value."'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '"选择也是一个受控属性。如果本地值与JS值不匹配，则更新为JS值。"'
- en: – React Native source code for TextInput: [https://github.com/facebook/react-native/blob/c595509048cc5f6cab360cd2ccbe7c86405baf92/Libraries/Components/TextInput/TextInput.js](https://github.com/facebook/react-native/blob/c595509048cc5f6cab360cd2ccbe7c86405baf92/Libraries/Components/TextInput/TextInput.js).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '- TextInput的React Native源代码：[https://github.com/facebook/react-native/blob/c595509048cc5f6cab360cd2ccbe7c86405baf92/Libraries/Components/TextInput/TextInput.js](https://github.com/facebook/react-native/blob/c595509048cc5f6cab360cd2ccbe7c86405baf92/Libraries/Components/TextInput/TextInput.js)。'
- en: Unless you specify the `onChangeText` or `value` props, then your component
    does not appear to get any more overhead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您指定`onChangeText`或`value`属性，否则您的组件似乎不会有任何额外的开销。
- en: 'The fact is that you can still use refs. Check out the following example to
    learn how to use React''s latest API:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您仍然可以使用引用。查看以下示例，了解如何使用React的最新API：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, there are some limitations. You cannot ask ref for the input value**.**
    Sadly, I find this unlikely to change. If you look at this from the other side,
    it feels more natural. You probably only need controlled components. The benefit
    from uncontrolled ones is performance that, as of now, does not differ much. Hence,
    I doubt that you need uncontrolled components in React Native. I couldn't even
    come up with a use case where you would need a lot of uncontrolled components
    because of performance issues.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些限制。您不能要求输入值的引用。可悲的是，我觉得这种情况不太可能改变。如果你从另一个角度来看，这种情况更自然。你可能只需要受控组件。目前，非受控组件的好处在于性能，并没有太大的不同。因此，我怀疑你在React
    Native中是否需要非受控组件。我甚至无法想出一个需要大量非受控组件的用例，因为性能问题。
- en: The closest I could get to leaving a component on its own was by using `onSubmitEditing` or
    `onEndEditing`. Such callbacks can be used like the `onChangeText` prop. They
    do not fire until the user presses the Submit/Return button on the native keyboard.
    Unfortunately, you can probably imagine the case when the user, instead of pressing
    the expected button, presses the login button instead. In such a case, the state
    would not be updated with the latest data, because the native keyboard remains
    opened. Such nuances may lead to incorrect data submission and critical bugs.
    Be careful.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我能做的最接近让组件独立的是使用`onSubmitEditing`或`onEndEditing`。这样的回调可以像`onChangeText`属性一样使用。它们直到用户按下本机键盘上的提交/返回按钮才会触发。不幸的是，您可能可以想象到当用户按下预期的按钮而不是按下登录按钮时的情况。在这种情况下，状态不会更新为最新数据，因为本机键盘仍然打开。这样的细微差别可能导致不正确的数据提交和关键错误。要小心。
- en: If you are developing websites using React, don't get discouraged by this section.
    refs are powerful for brown field websites and are useful for those who cannot
    afford to rewrite existing pieces into React. If this is your case, please also
    check out the portals API from React v16 [https://reactjs.org/docs/portals.html](https://reactjs.org/docs/portals.html).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用React开发网站，请不要因为这一部分而感到沮丧。refs对于棕地网站非常有用，对于那些无法将现有部分重写为React的人也很有用。如果这是您的情况，请还要查看React
    v16的门户API[https://reactjs.org/docs/portals.html]（https://reactjs.org/docs/portals.html）。
- en: Introduction to error boundaries
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误边界介绍
- en: 'This is quite an overlooked feature that came with React version 16\. As you
    should already know, JavaScript can throw errors. Such errors should not break
    your app, especially if it is from the financial sector. The regular imperative
    solution from JavaScript is a `try-catch` block:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是React版本16中带来的一个被忽视的功能。正如您应该已经知道的，JavaScript可能会抛出错误。这样的错误不应该破坏您的应用程序，特别是如果它来自金融部门。JavaScript的常规命令式解决方案是`try-catch`块：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This approach is hard to use with JSX. Hence, the React team developed an alternative
    solution for React views. It''s called `Error Boundaries`. Any class component
    can become an `ErrorBoundary` component, given that it implements the `componentDidCatch` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在JSX中很难使用。因此，React团队为React视图开发了一种替代解决方案。它被称为“错误边界”。任何类组件都可以成为`ErrorBoundary`组件，只要它实现了`componentDidCatch`函数：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you follow along with these examples, you may see a red screen with an error
    nonetheless. This is a default behavior in development mode. You will have to
    dismiss the screen to see what the app looks like: the error boundary will work
    as expected. If you switch to release mode, the error screen will not appear.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟随这些示例，您可能会看到一个带有错误的红色屏幕。这是开发模式下的默认行为。您将不得不关闭屏幕才能看到应用程序的外观：错误边界将按预期工作。如果切换到发布模式，错误屏幕将不会出现。
- en: '`LoginForm` is now wrapped into `ErrorBoundary`. It catches any error that
    occurs while rendering `LoginForm`. If `Error` is caught, we display a short message
    stating that `Something went wrong`. We can get a real error message from the
    error object. However, it is not good practice to share it with the end user.
    Instead, send it to your analytics server:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginForm`现在被包装在`ErrorBoundary`中。它捕获渲染`LoginForm`时发生的任何错误。如果捕获到`Error`，我们会显示一个简短的消息，说明“出了点问题”。我们可以从错误对象中获取真正的错误消息。但是，与最终用户分享它并不是一个好的做法。相反，将其发送到您的分析服务器：'
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How error boundaries catch errors
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误边界如何捕获错误
- en: It appears that error boundaries are meant to catch runtime errors that prevent
    rendering to finish successfully. Hence, they are very specific to React and are
    implemented using a special life cycle hook of the class component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界似乎是用来捕获阻止渲染成功完成的运行时错误的。因此，它们非常特定于React，并且是使用类组件的特殊生命周期钩子来实现的。
- en: 'Error boundaries do not catch errors for the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界不会捕获以下错误：
- en: Event handlers
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: Asynchronous code (for example, setTimeout or requestAnimationFrame callbacks)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步代码（例如，`setTimeout`或`requestAnimationFrame`回调）
- en: Server-side rendering
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Errors thrown in the error boundary itself (rather than its children)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误边界本身抛出的错误（而不是其子组件）
- en: '- React official documentation at [https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '- React官方文档网址：[https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)。'
- en: 'Let''s discuss the previously mentioned error boundaries limitations further:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步讨论之前提到的错误边界的限制：
- en: '**Event handlers**: This limitation is due to event handlers asynchronous nature.
    Callbacks are being invoked by an external function, and the event object is passed
    to a callback as a parameter. We do not have any control over this and when this
    will happen. The code is executed and never goes into the catch clause. Hint:
    This also impacts `try-catch` in the same way.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理程序**：这个限制是由于事件处理程序的异步性质。回调是由外部函数调用的，并且事件对象作为参数传递给回调。我们对此没有任何控制，也不知道何时会发生。代码被执行，永远不会进入catch子句。提示：这也以同样的方式影响`try-catch`。'
- en: '**Asynchronous code**: Most asynchronous code will not work with error boundaries.
    The exception to this rule is asynchronous render functions, which will come with
    future releases of React.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步代码**：大多数异步代码不会与错误边界一起工作。这个规则的例外是异步渲染函数，这将在未来的React版本中推出。'
- en: '**Server-side rendering**: This usually concerns server-side rendered websites.
    Such websites are computed on the server and sent to the browser. Thanks to this,
    a user can immediately see the website''s content. Most of the time, such server
    responses are cached and reused.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**：这通常涉及服务器端渲染的网站。这些网站是在服务器上计算并发送到浏览器的。由于这个原因，用户可以立即看到网站的内容。大多数情况下，这样的服务器响应会被缓存和重复使用。'
- en: '**Errors thrown in the error boundary itself**: You cannot catch errors that
    occur within the same class component. Hence, error boundaries should contain
    as little logic as possible. I always recommend using a separate component for
    them.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误边界本身抛出的错误**：您无法捕获发生在同一类组件内部的错误。因此，错误边界应该包含尽可能少的逻辑。我总是建议为它们使用单独的组件。'
- en: Understanding error boundaries
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解错误边界
- en: Error boundaries can be placed in many different fashions, and each approach
    has its own benefits. Choose one that fits your use case. For ideas, skip to the
    next section. Here, we will demonstrate how the app behaves, depending on the
    placement of the error boundaries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界可以以许多不同的方式放置，每种方法都有其自己的好处。选择适合您用例的方法。有关想法，请跳转到下一节。在这里，我们将演示应用程序根据错误边界的放置方式而表现出的行为。
- en: 'This first example uses two error boundaries around the `LikeCounter` component.
    If one of the `LikeCounter` components crashes, the other one will still be shown:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个例子在`LikeCounter`组件周围使用了两个错误边界。如果其中一个`LikeCounter`组件崩溃，另一个仍然会显示出来：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This second example uses one `ErrorBoundary` around two `LikeCounter` components.
    If one crashes, the other one will also be replaced by `ErrorBoundary`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二个例子在两个`LikeCounter`组件周围使用了一个`ErrorBoundary`。如果一个崩溃，另一个也将被`ErrorBoundary`替换：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When to use error boundaries
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用错误边界
- en: '`ErrorBoundary` is a great pattern for sure. It takes the `try-catch` concept
    into declarative JSX. The first time I saw it, I immediately came up with the
    idea to wrap the whole application into a boundary. This is fine, but it is not
    the only use case.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorBoundary`绝对是一个很好的模式。它将`try-catch`的概念转化为声明性的JSX。我第一次看到它时，立刻想到将整个应用程序包装在一个边界中。这没问题，但这不是唯一的用例。'
- en: 'Consider the following use cases for error boundaries:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑错误边界的以下用例：
- en: '**Widgets**: Given some incorrect data, your widget may run into problems.
    If, in the worst case scenario, it cannot handle the data, it may throw an error.
    You will want the rest of the app to be usable, given that this widget is not
    crucial for the rest of the application. Your analytics code should collect the
    error and save at least a stack trace so that the developers can fix it.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小部件**：如果给定一些不正确的数据，您的小部件可能会遇到问题。在最坏的情况下，如果它无法处理数据，它可能会抛出错误。鉴于这个小部件对于应用程序的其余部分并不是至关重要的，您希望其余的应用程序仍然可用。您的分析代码应该收集错误并保存至少一个堆栈跟踪，以便开发人员可以修复它。'
- en: '**Modals**: Preserve the rest of the application from the faulty modal. These
    are usually meant to display some data and short messages. You do not want a modal
    to blow up your application. Such errors should be considered very rare, but *better
    safe than sorry*.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模态框**：保护应用程序的其余部分免受错误模态框的影响。这些通常用于显示一些数据和简短的消息。您不希望模态框炸毁您的应用程序。这样的错误应该被认为是非常罕见的，但“宁愿安全也不要后悔”。'
- en: '**Boundaries on feature containers:** Let''s say that your app is divided into
    major features that are represented by container components. For example, let''s
    take a messaging app such as Facebook Messenger. You may add error boundaries
    to the sidebar, my story bar, footer, start new message button, and messages history
    list view. This will ensure that, if one feature breaks, the others have a chance
    to still work properly.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能容器的边界**：假设您的应用程序被划分为由容器组件表示的主要功能。例如，让我们以Facebook Messenger这样的消息应用为例。您可以向侧边栏、我的故事栏、页脚、开始新消息按钮和消息历史记录列表视图添加错误边界。这将确保，如果一个功能出现故障，其他功能仍有机会正常工作。'
- en: 'Now we know about all of the pros, let''s discuss the cons ones: Mixins.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了所有的优点，让我们讨论一下缺点：混合。
- en: Why Mixins are anti-patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么混合是反模式
- en: With a Mixin pattern, you mix in a certain behavior with your React components.
    You kind of inject a behavior for free, and you can reuse the same Mixin in different
    components. This all sounds great, but it isn't – and you will easily find articles
    on why. Here, I want to show you this anti-pattern by example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合模式，您可以将某种行为与您的React组件混合在一起。您可以免费注入一种行为，并且可以在不同的组件中重用相同的混合。这一切听起来都很棒，但实际上并不是这样——您很容易找到关于为什么的文章。在这里，我想通过示例向您展示这种反模式。
- en: Mixin example
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合示例
- en: 'Instead of shouting *Mixins are harmful,* let''s create a component that is
    using them and look at what the issues are. Mixins are deprecated, so the first
    step is finding a way to use them. It turns out that they still live in a legacy
    way of creating React class components. Previously, instead of ES6 classes, there
    was a special function called `createReactClass`. In one of the major releases,
    the function was removed from the React library and is now available in a separate
    library called `''create-react-class''`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与其大声喊叫*混合是有害的*，不如创建一个正在使用它们的组件，并查看问题所在。混合已经被弃用，因此第一步是找到一种使用它们的方法。事实证明，它们仍然以一种传统的方式创建React类组件。以前，除了ES6类之外，还有一个特殊的函数叫做`createReactClass`。在一个重大版本发布中，该函数从React库中删除，并且现在可以在一个名为`'create-react-class'`的单独库中使用：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we create `LoggerMixin`, which is taking care of logging the necessary
    information. In this simple example, it's just information regarding that component
    that has been rendered, but it could be easily extended further.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`LoggerMixin`，它负责记录必要的信息。在这个简单的例子中，它只是关于已呈现的组件的信息，但它可以很容易地进一步扩展。
- en: In this example, we used `componentDidMount`, which is one of the component
    life cycle hooks. These can be used in ES6 classes, too. Please check out the
    official documentation for insights about the other methods: [https://reactjs.org/docs/react-component.html#the-component-lifecycle](https://reactjs.org/docs/react-component.html#the-component-lifecycle).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`componentDidMount`，这是组件生命周期钩子之一。这些也可以在ES6类中使用。请查看官方文档以了解其他方法的见解：[https://reactjs.org/docs/react-component.html#the-component-lifecycle](https://reactjs.org/docs/react-component.html#the-component-lifecycle)。
- en: 'In case you need more loggers, you can mix them into a single component by
    using a comma:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多的记录器，可以使用逗号将它们混合到单个组件中：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a book on patterns, so it is crucial to stop here and look at the `createReactClass`
    function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于模式的书，因此在这里停下来看一下`createReactClass`函数。
- en: 'Why has it been deprecated? The answer is actually pretty simple. The React
    Team prefers explicit APIs over implicit APIs. The `CreateReactClass` function
    is another implicit abstraction that hides implementation details from you. Instead
    of adding a new function, it is better to use the standard way: ES6 classes. ES6
    classes have their own cons, but that is another topic entirely. Additionally,
    you may use classes in other languages that are built on top of ECMAScript, for
    instance, TypeScript. This is a huge advantage, especially nowadays, with TypeScript
    going mainstream.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它已经被弃用？答案实际上非常简单。React团队更喜欢显式API而不是隐式API。`CreateReactClass`函数是另一个隐式抽象，它会隐藏实现细节。与其添加一个新函数，不如使用标准方式：ES6类。ES6类也有自己的缺点，但这是另一个完全不同的话题。此外，您可以在其他基于ECMAScript构建的语言中使用类，例如TypeScript。这是一个巨大的优势，特别是在现今TypeScript变得流行的时代。
- en: To find out more on this thought process, I recommend that you watch a great
    talk from Sebastian Markbåge called **Minimal API Surface Area**. It was originally
    delivered at JSConf EU in 2014, and can be found at [https://www.youtube.com/watch?v=4anAwXYqLG8](https://www.youtube.com/watch?v=4anAwXYqLG8).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这种思维过程的信息，我建议您观看Sebastian Markbåge的一次精彩演讲，名为**Minimal API Surface Area**。它最初是在2014年的JSConf
    EU上发布的，可以在[https://www.youtube.com/watch?v=4anAwXYqLG8](https://www.youtube.com/watch?v=4anAwXYqLG8)找到。
- en: Using HOCs instead
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HOC代替
- en: 'I believe that you can easily translate the preceding use case into HOC. Let''s
    do this together, and then we will discuss why HOCs are better:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您可以轻松地将前面的用例转换为HOC。让我们一起做这个，然后我们将讨论为什么HOC更好：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first thing you will immediately spot is that HOCs stack on top of each
    other. HOCs literally compose with each other. This is much more flexible and
    protects you from name clashes that may happen when using Mixins. React developers
    mention the `handleChange` function as a problematic example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您立即注意到的第一件事是HOC可以堆叠在一起。HOC实际上是相互组合的。这样更加灵活，并且可以保护您免受在使用Mixins时可能发生的名称冲突。React开发人员提到`handleChange`函数是一个问题示例：
- en: '*"There is no guarantee that two particular mixins can be used together. For
    example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(),
    you can’t use them together. You also can’t define a method with this name on
    your own component.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*"不能保证两个特定的mixin可以一起使用。例如，如果`FluxListenerMixin`定义了`handleChange()`，而`WindowSizeMixin`也定义了`handleChange()`，那么您不能将它们一起使用。您也不能在自己的组件上定义一个具有这个名称的方法。*'
- en: '*It’s not a big deal if you control the mixin code. When you have a conflict,
    you can rename that method on one of the mixins. However, it’s tricky because
    some components or other mixins may already be calling this method directly, and
    you need to find and fix those calls as well."*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您控制mixin代码，这并不是什么大问题。当出现冲突时，您可以在其中一个mixin上重命名该方法。但是，这很棘手，因为一些组件或其他mixin可能已经直接调用了这个方法，您需要找到并修复这些调用。"*'
- en: '*- Official React blog post by Dan Abramov ([https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)).*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*- Dan Abramov的官方React博客文章（[https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)).*'
- en: Additionally, Mixins may lead to adding more and more state. Looking at the
    preceding examples, it may appear that HOCs do the same, but in fact, shouldn't.
    This is an issue that I struggle with in the React ecosystem. It gives you a lot
    of power and you may not realize that the patterns you begin to use are so-so.
    To me, stateful components should be rare, and so should stateful HOCs. In this
    book, I will teach you how to avoid using state objects in favor of a better solution
    that decouples state from your components as much as possible. We will learn about
    this further in [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store
    Patterns*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，混入可能会导致添加更多状态。从前面的例子来看，HOCs可能会做同样的事情，但实际上不应该。这是我在React生态系统中遇到的问题。它给您很大的权力，您可能没有意识到您开始使用的模式是如此一般。对我来说，有状态的组件应该很少，有状态的HOCs也应该很少。在本书中，我将教您如何避免使用状态对象，而是更倾向于一种更好的解决方案，尽可能地将状态与组件解耦。我们将在[第5章](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml)中进一步了解这一点，*存储模式*。
- en: Linters and code style guide
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查工具和代码样式指南
- en: 'In this section, we will take a look at quite a different set of patterns,
    namely, patterns on how to structure your code. Over the years, there have been
    tens of approaches to styling, and the general rule is this: the more people,
    the more preferred ways there are.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下完全不同的一组模式，即如何构建代码的模式。多年来，已经有数十种样式的方法，一般规则是：人越多，越多种偏好的方式。
- en: Hence, the **crucial point** of setting up the project is **selecting your style
    guide**, and your set of defined and precise rules. This will save enormous amounts
    of time for you as it removes any potential discussion.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设置项目的**关键点**是**选择您的样式指南**，以及您定义的一套明确的规则。这将为您节省大量时间，因为它消除了任何潜在的讨论。
- en: In an era of advanced IDEs, it is possible to quickly reformat a whole code
    base in seconds. This will come in handy in case you need to allow for small future
    changes to the style of your code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级集成开发环境的时代，可以在几秒钟内快速重新格式化整个代码库。如果您需要允许对代码样式进行小的未来更改，这将非常方便。
- en: Adding a linter to create a React Native app
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加代码检查工具以创建React Native应用
- en: 'Follow these steps to configure your own linter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您自己的代码检查工具：
- en: Open a terminal and navigate to the project directory. The `cd` command for
    changing the directory will come in handy.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到项目目录。`cd`命令用于更改目录将非常方便。
- en: List (`ls`) the files in the directory and make sure that you are in the root
    and that you can see the `package.json` file.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出目录中的文件，并确保您位于根目录，并且可以看到`package.json`文件。
- en: 'Add the following packages by using the `yarn add` command. The newly added
    packages will be automatically added to `package.json`. `--dev` installs it under
    the development dependencies within `package.json`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`yarn add`命令添加以下软件包。新添加的软件包将自动添加到`package.json`中。`--dev`将其安装在`package.json`的开发依赖项中：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ESLint is the linter that we will be using, and by running the preceding command,
    you will have installed it in the `node_modules` directory of your project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint是我们将使用的代码检查工具，通过运行上述命令，您将已经将其安装在项目的`node_modules`目录中。
- en: 'Now, we are ready to define a new script for your project. Please edit `package.json`
    and add the following line under the `scripts` section:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备为您的项目定义一个新的脚本。请编辑`package.json`，并在`scripts`部分下添加以下行：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding command runs ESLint and passes one argument to it. This argument
    is the name of the directory that will contain files to lint. If you aren't going
    to follow along with this book, we are using the `src` directory to store source
    JavaScript files.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令运行ESLint并向其传递一个参数。这个参数是将包含要进行代码检查的文件的目录的名称。如果你不打算跟着这本书一起学习，我们使用`src`目录来存储源JavaScript文件。
- en: The next step is specifying a code style—more precisely, a linter configuration
    that implements your code style. In this example, we will use a well-known Airbnb
    style guide. However, we will also tweak it to adhere to my preferred style.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是指定代码风格，更准确地说，是实现您的代码风格的代码检查器配置。在本例中，我们将使用一个众所周知的Airbnb样式指南。但是，我们还将对其进行调整，以符合我的首选风格。
- en: 'Firstly, create your linter configuration by running the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令创建您的代码检查器配置：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A special prompt will follow. Choose the following options:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来将出现一个特殊提示。选择以下选项：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A configuration file will be created for you called `.eslintrc.json`. Open
    the file and add the following rules. In the next section, I will explain these
    choices. For now, proceed with the given set of rules:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将为您创建一个名为`.eslintrc.json`的配置文件。打开文件并添加以下规则。在下一节中，我将解释这些选择。现在，请使用给定的一组规则：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, you can run the linter by using the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过使用以下命令运行代码检查器：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The complete setup is provided in `Example 14` under the `Chapter 2_View patterns`
    folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的设置在`第2章_视图模式`文件夹下的`示例14`中提供。
- en: Airbnb React style guide rules
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Airbnb React样式指南规则
- en: The Airbnb React style guide defines tens of well-thought-out rules. This is
    a great resource and a foundation for your next React project. I highly recommend
    looking into them. You can find the Airbnb React style guide at [https://github.com/airbnb/javascript/tree/master/react](https://github.com/airbnb/javascript/tree/master/react).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Airbnb React样式指南定义了数十个经过深思熟虑的规则。这是一个很好的资源，也是您下一个React项目的基础。我强烈建议您深入研究。您可以在[https://github.com/airbnb/javascript/tree/master/react](https://github.com/airbnb/javascript/tree/master/react)找到Airbnb
    React样式指南。
- en: 'However, everyone should find their own style. Mine just adapts a few things
    from the Airbnb:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，每个人都应该找到自己的风格。我的风格只是从Airbnb中调整了一些东西。
- en: '`comma-dangle`: Airbnb advises that you leave a trailing comma at the end of
    array multiline elements, lists, or object multiline key-value lists. This is
    not what I''m used to. I prefer the JSON style, which does not leave a trailing
    comma:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comma-dangle`：Airbnb建议您在数组多行元素、列表或对象多行键值列表的末尾留下一个逗号。这不是我习惯的。我更喜欢JSON样式，它不会留下尾随逗号：'
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`react/jsx-filename-extension`: In my opinion, this rule should be changed
    in the style guide. It tries to convince you to use the `.jsx` extension for files
    using JSX. I don''t agree with this. I would like to quote Dan Abramov''s comment
    on this matter:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react/jsx-filename-extension`：在我看来，这个规则应该在样式指南中进行更改。它试图说服您在使用JSX的文件中使用`.jsx`扩展名。我不同意这一点。我想引用Dan
    Abramov在这个问题上的评论：'
- en: '"The distinction between .js and .jsx files was useful before Babel, but it’s
    not that useful anymore.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “.js和.jsx文件之间的区别在Babel之前是有用的，但现在已经不那么有用了。
- en: There are other syntax extensions (for example, Flow). What would you call a
    JS file that uses Flow? .flow.js? What about a JSX file that uses Flow? .flow.jsx?
    What about some other experimental syntax? .flow.stage-1.jsx?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他语法扩展（例如Flow）。如果使用Flow的JS文件应该如何命名？.flow.js？那使用Flow的JSX文件呢？.flow.jsx？还有其他一些实验性语法呢？.flow.stage-1.jsx？
- en: Most editors are configurable, so you can tell them to use a JSX-capable syntax
    scheme for .js files. Since JSX (or Flow) are strict supersets of JS, I don’t
    see this as an issue."
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编辑器都是可配置的，因此您可以告诉它们在.js文件中使用JSX语法方案。由于JSX（或Flow）是JS的严格超集，我认为这不是问题。
- en: – Dan Abramov: [https://github.com/facebook/create-react-app/issues/87#issuecomment-234627904](https://github.com/facebook/create-react-app/issues/87#issuecomment-234627904).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '- Dan Abramov：[https://github.com/facebook/create-react-app/issues/87#issuecomment-234627904](https://github.com/facebook/create-react-app/issues/87#issuecomment-234627904)。'
- en: '`no-use-before-define`: This is a smart rule. It prevents you from using variables
    and functions that are defined later, besides the fact that the JavaScript hoisting
    mechanism lets you to do so. However, I like to put my StyleSheets in the bottom
    on every component file. Hence, I have relaxed this rule to allow usage of variables
    before their definition.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-use-before-define`：这是一个聪明的规则。它防止您使用稍后定义的变量和函数，尽管JavaScript的提升机制允许您这样做。但是，我喜欢将我的StyleSheets放在每个组件文件的底部。因此，我放宽了这个规则，允许在定义之前使用变量。'
- en: I also prefer an indentation of four spaces for clarity when I copy snippets
    into this book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将片段复制到这本书中时，我也更喜欢使用四个空格的缩进来提高清晰度。
- en: Fixing errors
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复错误
- en: As we have a linter set up, we can try it on one of the previous projects.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了linter，我们可以在以前的项目中尝试它。
- en: If you want to follow along with this example, just copy `Example 9_Controlled
    TextInput` from [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View
    Patterns*, and set up a linter in that copied project. After that, follow with
    the following command, which executes your linter script on the source directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟着这个例子，只需从[第2章](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml)中复制`Example 9_Controlled
    TextInput`，*View Patterns*，并在复制的项目中设置一个linter。之后，执行以下命令，该命令在源目录上执行您的linter脚本。
- en: 'I tried it on `LoginForm.js` from `Example 9_ Controlled TextInput`. Unfortunately,
    it listed a few errors:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`Example 9_ Controlled TextInput`的`LoginForm.js`上尝试了它。不幸的是，它列出了一些错误：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '13 problems! Luckily, ESLint may attempt to fix them automatically. Let''s
    try. Execute the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 13个问题！幸运的是，ESLint可以尝试自动修复它们。让我们试试。执行以下操作：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Lovely —we reduced the issues to just three:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 很好 - 我们将问题减少到了只有三个：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can skip the last two. Those warnings are relevant, but the console is handy
    for this book: it provides an easy way to print information. Do not use `console.log`
    in production. However, `''initLogin'' is missing in props validation react/prop-types`
    is a valid error, and we need to fix it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳过最后两个。这些警告是相关的，但控制台对于这本书来说很方便：它提供了一个打印信息的简单方法。在生产中不要使用`console.log`。然而，`'initLogin'在props验证react/prop-types中丢失`是一个有效的错误，我们需要修复它：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`LoginForm` now has its props validated. This will fix the linter error. To
    check this, rerun the linter. It looks like we have run into yet another issue!
    Correct:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginForm`现在已经验证了它的props。这将修复linter错误。要检查这一点，请重新运行linter。看起来我们又遇到了另一个问题！正确的链接是：'
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is true—we should have defined default props in case `initLogin` is not
    provided:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的 - 如果未提供`initLogin`，我们应该定义默认的props：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'From now on, if we do not explicitly provide `initLogin`, it will be assigned
    a default value, that is, an empty string. Rerun the linter. It will now show
    a new error:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果我们没有明确提供`initLogin`，它将被分配一个默认值，即一个空字符串。重新运行linter。它现在会显示一个新的错误：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At least it's an easy one. It correctly advises you to maintain `prop-types`
    dependencies explicitly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 至少这是一个简单的问题。它正确地建议您明确维护`prop-types`依赖关系。
- en: 'Add the `prop-types` dependency by running the following command in your console:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在控制台中运行以下命令添加`prop-types`依赖项：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Rerun the linter. Great! Finally, there are  no errors. Good job.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行linter。太好了！最终，没有错误了。干得好。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about view patterns that will be very useful later
    on in this book. Now we know how to write concise JSX and type check components.
    We can also compose common built-in components from the React Native library.
    When we need to, we can write the markup of a simple form and know how to handle
    the input. We compared controlled and uncontrolled inputs and dove deep into how
    `TextInput` works. If some errors occur, our error boundaries will handle the
    problem.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以后在本书中会非常有用的视图模式。现在我们知道如何编写简洁的JSX和类型检查组件。我们还可以组合来自React Native库的常见内置组件。当需要时，我们可以编写简单表单的标记并知道如何处理输入。我们比较了受控和不受控输入，并深入了解了`TextInput`的工作原理。如果出现错误，我们的错误边界将处理这个问题。
- en: Finally, we made sure that we have a strict style guide on how to write React
    Native code, and we enforced these rules by using ESLint.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保了我们有一个严格的风格指南，告诉我们如何编写React Native代码，并且我们通过使用ESLint来强制执行这些规则。
- en: In the next chapter, we will work on styling the components we have learned.
    Thanks to this, our application will look nice and professional.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将致力于为我们学到的组件进行样式设置。由此，我们的应用程序将看起来漂亮而专业。
