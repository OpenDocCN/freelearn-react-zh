- en: Styling Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式模式
- en: It's time to add some looks to our applications. In this chapter, we will explore
    unique styling solutions and mechanisms. React Native StyleSheet may resemble
    web **cascading style sheets** (**CSS**); however, Native application styling
    is different. Similarities in the syntax quickly end and you should spend some
    time with this chapter to learn the basics of styling. Later on in this book,
    we will use an external library that provides ready-made styles. It is crucial
    for you to understand how to make such components yourself, especially if you
    plan to work professionally in React Native in teams who deliver custom designs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是为我们的应用程序添加一些外观的时候了。在本章中，我们将探索独特的样式解决方案和机制。React Native StyleSheet可能类似于Web层叠样式表（CSS）；然而，原生应用程序的样式是不同的。语法上的相似之处很快就结束了，您应该花一些时间来学习样式的基础知识。在本书的后面，我们将使用一个提供现成样式的外部库。对于您来说，了解如何自己制作这样的组件至关重要，特别是如果您计划在React
    Native团队中专业工作，他们提供定制设计。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Styling components in the React Native environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React Native环境中为组件设置样式
- en: Dealing with limited style inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理有限的样式继承
- en: Using density-independent pixels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密度无关像素
- en: Positioning elements with Flexbox
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flexbox定位元素
- en: Handling long text issues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理长文本问题
- en: Making animations using the Animated library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Animated库制作动画
- en: Measuring your application's speed using the **Frames Per Second** (**FPS**)
    metric
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用每秒帧数（FPS）指标来测量应用程序的速度
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As in the previous chapters, I have separated every example into a standalone
    application that you can launch on your phone or simulator. To do the examples,
    you will need  the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我已经将每个示例分成一个独立的应用程序，您可以在手机或模拟器上启动。要做这些示例，您将需要以下内容：
- en: Simulator or Android/iOS smartphone
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟器或Android/iOS智能手机
- en: Git to pull the examples: [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native).
    Follow the installation instructions from the GitHub page.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git拉取示例：[https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native)。请按照GitHub页面上的安装说明进行操作。
- en: How React Native styles work
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native样式的工作原理”
- en: '"The core premise for React is that UIs are simply a projection of data into
    a different form of data. The same input gives the same output. A simple pure
    function."'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “React的核心前提是UI只是数据投影到不同形式的数据中。相同的输入产生相同的输出。一个简单的纯函数。”
- en: '- React library README ([https://github.com/reactjs/react-basic/blob/master/README.md](https://github.com/reactjs/react-basic/blob/master/README.md)).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '- React库自述文件（[https://github.com/reactjs/react-basic/blob/master/README.md](https://github.com/reactjs/react-basic/blob/master/README.md)）。'
- en: 'You will learn about pure functions later in this book. Check out the following
    example to understand the basics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书的后面学习纯函数。查看以下示例以了解基础知识：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Going back to more practical examples, let's see how the preceding premise is
    implemented in React Native.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回到更实际的例子，让我们看看在React Native中如何实现前提。
- en: '"With React Native, you don''t use a special language or syntax for defining
    styles. You just style your application using JavaScript. All of the core components
    accept a prop named `style`. The style names and values usually match how CSS
    works on the web, except names are written using camel casing, e.g backgroundColor
    rather than background-color.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “使用React Native，您不需要使用特殊的语言或语法来定义样式。您只需使用JavaScript为应用程序设置样式。所有核心组件都接受一个名为`style`的属性。样式名称和值通常与Web上的CSS工作方式相匹配，只是名称使用驼峰式命名，例如backgroundColor而不是background-color。
- en: The style prop can be a plain old JavaScript object. (...) You can also pass
    an array of styles - the last style in the array has precedence, so you can use
    this to inherit styles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 样式属性可以是一个普通的JavaScript对象。(...) 您还可以传递一个样式数组 - 数组中的最后一个样式具有优先权，因此您可以使用它来继承样式。
- en: As a component grows in complexity, it is often cleaner to use StyleSheet.create
    to define several styles in one place."
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组件复杂性的增加，通常更清晰的做法是使用StyleSheet.create在一个地方定义多个样式。
- en: '- React Native official documentation ([https://facebook.github.io/react-native/docs/style.html](https://facebook.github.io/react-native/docs/style.html)).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '- React Native官方文档([https://facebook.github.io/react-native/docs/style.html](https://facebook.github.io/react-native/docs/style.html)).'
- en: 'To sum up, we have three ways of defining the component style:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们有三种定义组件样式的方式：
- en: Using style props and passing an object with key-value pairs that represent
    styles.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式属性并传递一个包含键值对的对象，表示样式。
- en: Using style props and passing an array of objects. Each object should contain
    key-value pairs that represent styles. The last style in the array has precedence.
    Use this mechanism to inherit styles or shadow them as you would shadow functions
    and variables.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式属性并传递一个对象数组。每个对象应包含表示样式的键值对。数组中的最后一个样式具有优先权。可以使用这种机制来继承样式或像阴影函数和变量一样阴影它们。
- en: Using the StyleSheet component and its `create` function to create styles.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用StyleSheet组件及其create函数来创建样式。
- en: 'In the following example, you can find all three ways of defining styles:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，您可以找到定义样式的三种方式：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Pay attention to the use case with array of objects. You may combine previously-learned
    tricks to achieve conditional styles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用对象数组的用例。您可以结合先前学到的技巧来实现条件样式：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, let''s discuss why we use the `StyleSheet` component instead of inline
    styles:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，让我们讨论一下为什么我们使用`StyleSheet`组件而不是内联样式：
- en: 'Code quality:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码质量：
- en: By moving styles away from the render function, you're making the code easier
    to understand.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将样式从渲染函数中移出，可以使代码更容易理解。
- en: Naming the styles is a good way to add meaning to the low-level components in
    the render function.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给样式命名是向渲染函数中的低级组件添加含义的好方法。
- en: 'Performance:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：
- en: Making a `stylesheet` from a `style` object makes it possible to refer to it
    by ID instead of creating a new style object every time.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式对象转换为样式表，可以通过ID引用它，而不是每次都创建一个新的样式对象。
- en: It also allows you to send the style only once through the bridge. All subsequent
    uses are going to refer an ID (not implemented yet).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还允许您通过桥只发送样式一次。所有后续使用都将引用一个ID（尚未实现）。
- en: '- React Native official documentation'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '- React Native官方文档'
- en: '[https://facebook.github.io/react-native/docs/stylesheet.html](https://facebook.github.io/react-native/docs/stylesheet.html).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/stylesheet.html](https://facebook.github.io/react-native/docs/stylesheet.html).'
- en: When it comes to the quality and reusability, StyleSheet decouples styles and
    component markup. You could even extract these styles away to a separate file.
    Also, as mentioned in the documentation, it allows you to make your markup easier
    to understand. Instead of a huge styling object, you can see a meaningful name,
    such as **`styles.activeLink`**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在质量和可重用性方面，StyleSheet将样式和组件标记分离。甚至可以将这些样式提取到一个单独的文件中。此外，正如文档中所述，它可以使您的标记更容易理解。您可以看到一个有意义的名称，比如**`styles.activeLink`**，而不是一个庞大的样式对象。
- en: If you undervalue decoupling in your applications, then try to grow your code
    base beyond 5,000 lines. You will likely see that some tightly-coupled code will
    need hacks to be reusable. Bad practices will snowball, making the code base very
    hard to maintain. In backend systems, it usually goes hand-in-hand with monolithic
    structures. The amazing idea that comes to the rescue is Microservices. Learn
    more at [https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)[.](https://en.wikipedia.org/wiki/Microservices)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您低估了应用程序中的解耦性，那么请尝试将代码基础扩展到超过5,000行。您可能会发现一些紧密耦合的代码需要一些技巧才能重用。不良实践会滚雪球，使代码基础非常难以维护。在后端系统中，它通常与单片结构相辅相成。拯救的惊人主意是微服务。在[https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)了解更多。
- en: Surprising styles inheritance
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令人惊讶的样式继承
- en: As we start to use styles, it is vital to understand that React Native styles
    do not work as a website's CSS. Especially when it comes to inheritance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用样式时，理解React Native样式不像网站的CSS是至关重要的。特别是在继承方面。
- en: 'Styles of the parent component are not inherited unless it is a `Text` component.
    If it is a `Text` component, it will inherit from parent, only if parent is another
    `Text` component:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件的样式不会被继承，除非它是一个`Text`组件。如果是`Text`组件，它只会从父组件继承，只有父组件是另一个`Text`组件时才会继承：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run this code, you will see that the displayed text is green and that
    the later part is also big. `Text` with a big style inherited the green colour
    from the parent `Text` component. Please also note that the whole text is rendered
    inside of a `View` component that has a margin top of 40 dp that is density-independent
    pixels. Jump to the *Learning unitless dimensions* section to learn more.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，您会看到显示的文本是绿色的，后面的部分也很大。具有大样式的`Text`从父`Text`组件继承了绿色。还请注意，整个文本都呈现在具有40
    dp的顶部边距的`View`组件内，这是密度无关像素。跳转到*学习无单位尺寸*部分以了解更多。
- en: Workaround for limited inheritance
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限继承的解决方法
- en: Imagine a situation where you would like to reuse the same font across the whole
    application. Given the mentioned inheritance limitations, how would you do that?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情况，您希望在整个应用程序中重用相同的字体。鉴于前面提到的继承限制，您将如何做到这一点？
- en: 'The solution is a mechanism that we have learned already: component composition.
    Let''s create a component that satisfies our requirements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是我们已经学到的一个机制：组件组合。让我们创建一个满足我们要求的组件：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `AppText` component just wraps the `Text` component and specifies its styles.
    In this simple example, it's just `fontFamily`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppText`组件只是包装了`Text`组件并指定了它的样式。在这个简单的例子中，它只是`fontFamily`。'
- en: Please note that the `fontFamily` key in `style` object accepts String values
    and may differ between platforms (some are accepted on Android and some are accepted
    on iOS). For consistency, you may need to use a custom font. The setup is rather
    easy but takes a while and so exceeds the design patterns topic of this book.
    To learn more, visit [https://docs.expo.io/versions/latest/guides/using-custom-fonts](https://docs.expo.io/versions/latest/guides/using-custom-fonts).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`style`对象中的`fontFamily`键接受字符串值，并且在平台之间可能不同（在Android上接受一些，在iOS上接受一些）。为了保持一致性，您可能需要使用自定义字体。设置相当简单，但需要一些时间，因此超出了本书的设计模式主题。要了解更多，请访问[https://docs.expo.io/versions/latest/guides/using-custom-fonts](https://docs.expo.io/versions/latest/guides/using-custom-fonts)。
- en: Think about how to edit `AppText` to support custom styles so that it will be
    possible to override specified keys.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何编辑`AppText`以支持自定义样式，以便可以覆盖指定的键。
- en: 'Is the style object override the best solution in this case? Perhaps not; you
    have created this component to unify styles, not to allow overrides. But, you
    may say that it could be needed to create another component, such as `HeaderText`
    or something similar. You need a way to reuse existing styles and still enlarge
    the text. Luckily, you can still use `Text` inheritance here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，样式对象覆盖是最好的解决方案吗？也许不是；您创建此组件是为了统一样式，而不是允许覆盖。但是，您可能会说需要创建另一个组件，比如`HeaderText`或类似的东西。您需要一种重用现有样式并仍然放大文本的方法。幸运的是，您仍然可以在这里使用`Text`继承：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Hence, `HeaderText` would be very simple to implement. Check the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`HeaderText`将非常容易实现。请查看以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Learning unitless dimensions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习无单位的尺寸。
- en: In this section, we will learn the dimensions in which React Native applications
    are measured onscreen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习React Native应用程序在屏幕上的尺寸。
- en: '"The simplest way to set the dimensions of a component is by adding a fixed
    width and height to style. All dimensions in React Native are unitless, and represent
    density-independent pixels."'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"设置组件尺寸的最简单方法是在样式中添加固定的宽度和高度。在React Native中，所有尺寸都是无单位的，表示密度无关的像素。"'
- en: '- React Native official documentation'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '- React Native官方文档'
- en: '[https://facebook.github.io/react-native/docs/height-and-width.html](https://facebook.github.io/react-native/docs/height-and-width.html).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/height-and-width.html](https://facebook.github.io/react-native/docs/height-and-width.html)。'
- en: Unlike in CSS, for style properties such as `margin`, `bottom`, `top`, `left`, `right`, `height`,
    and `width`, you must provide values in dp or percentages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS不同，对于样式属性如`margin`、`bottom`、`top`、`left`、`right`、`height`和`width`，您必须以dp或百分比提供值。
- en: 'That''s it for the documentation. But you also need to understand the following
    keywords when it comes to working with screens:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文档到此结束。但是在处理屏幕时，您还需要了解以下关键字：
- en: '**Pixels**: These are the smallest single elements of the screen that can be
    controlled. Each pixel usually consists of three sub-pixels: red, green, and blue.
    These colors are usually referred to as RGB.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素**：这些是屏幕上可以控制的最小单元。每个像素通常由三个子像素组成：红色、绿色和蓝色。这些颜色通常被称为RGB。'
- en: '**Dimensions**: These are the width and height of the screen or window.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸**：这是屏幕或窗口的宽度和高度。'
- en: '**Resolution**: This is the number of pixels in each dimension that can be
    displayed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：这是每个维度上可以显示的像素数。'
- en: '**DPI**/**PPI**: This is the number of dots/pixels that can be placed per one
    inch.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DPI**/**PPI**：这是每英寸可以放置的点/像素数。'
- en: '**Points**: This is an abstract measurement for iOS.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点数**：这是iOS上的一个抽象度量。'
- en: '**Density-independent pixels**: This is an abstract measurement for Android.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度无关的像素**：这是Android上的一个抽象度量。'
- en: 'If you want to check how these concepts are implemented in Java, have a look
    at:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查这些概念在Java中是如何实现的，请查看：
- en: '[https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/uimanager/LayoutShadowNode.java](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/uimanager/LayoutShadowNode.java).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/uimanager/LayoutShadowNode.java](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/uimanager/LayoutShadowNode.java)。'
- en: 'To calculate the values, we will need `width`, `height`, and `scale`. You can
    get this information from the `Dimensions` object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算这些值，我们将需要`width`、`height`和`scale`。您可以从`Dimensions`对象中获取这些信息：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, this code is broken. Can you see why? It does not update if you rotate
    the device.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码有问题。你能看出来为什么吗？如果你旋转设备，它就不会更新。
- en: 'We need to force a re-render if the dimensions change. We can detect a dimension
    change by registering our own listener using `Dimensions.addEventListener`. Then
    we need to force a re-render in this listener. Usually people use `state` to do
    so. React checks `state` for changes and re-renders if that happens:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尺寸发生变化，我们需要强制重新渲染。我们可以通过注册自己的监听器使用`Dimensions.addEventListener`来检测尺寸变化。然后我们需要在这个监听器中强制重新渲染。通常人们使用`state`来这样做。React检查`state`的变化并在发生变化时重新渲染：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the result, we have one working `View` that adapts to a dimension change.
    It is done using the custom event listener that we registered using React lifecycle
    methods (`componentWillMount` and `componentWillUnmount`). However, the other,
    which uses `StyleSheet`, is not adapting. It has no access to `this.state`. StyleSheets
    are generally meant to be static to provide optimizations such as sending styles
    only once through the bridge to native.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，我们有一个适应尺寸变化的工作`View`。这是通过使用我们使用React生命周期方法(`componentWillMount`和`componentWillUnmount`)注册的自定义事件监听器完成的。然而，另一个使用`StyleSheet`的`View`没有适应。它无法访问`this.state`。StyleSheet通常是静态的，以提供优化，例如只通过桥一次发送样式到本机。
- en: 'What if we want our `StyleSheet` styles to adapt anyway? We can do one of the
    following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然希望我们的`StyleSheet`样式适应？我们可以做以下之一：
- en: 'Resign from StyleSheet and create a custom function that returns an object
    that represents styles and passes them as inline ones. It will provide similar
    decoupling if that is the goal:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放弃StyleSheet并创建一个返回表示样式的对象的自定义函数，并将它们作为内联样式传递。如果这是目标，它将提供类似的解耦：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use `styles` to override the syntax in the markup:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`styles`来覆盖标记中的语法：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use `StyleSheet.flatten` to override `styles` outside of the markup:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`StyleSheet.flatten`来覆盖标记外的`styles`：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As with inline styles, beware of the performance implications. You will lose
    the optimizations when it comes to style-caching. Most likely, on every re-render,
    `styles` will be recalculated and sent over the bridge again.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与内联样式一样，要注意性能影响。当涉及到样式缓存时，你将失去优化。很可能，在每次重新渲染时，`styles`将被重新计算并再次通过桥发送。
- en: Absolute and relative positioning
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绝对和相对定位
- en: 'This section is on the basics of positioning things. In React Native, everything
    is `relative` by default. This means that if I nest `View` into another `View`
    that has `marginTop: 40`,  this positioning will affect my nested `View` too.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '这一部分是关于定位事物的基础知识。在React Native中，默认情况下一切都是`relative`的。这意味着如果我把`View`嵌套到另一个具有`marginTop:
    40`的`View`中，这个定位也会影响我的嵌套`View`。'
- en: 'In React Native, we can also change positioning to `absolute`. Then the position
    will be calculated by a fixed number of pixels from our parent. Use the `top`/`bottom` *+*
    `left`/`right` keys in StyleSheet. Remember, other Views will not take this position
    into account. This is handy if you want to make Views overlap:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中，我们也可以将定位改为`absolute`。然后位置将根据父级的固定像素数计算。在StyleSheet中使用`top`/`bottom` *+*
    `left`/`right`键。记住，其他视图不会考虑这个位置。如果你想让视图重叠，这很方便：
- en: '![](Images/75fd11a3-1ba8-4161-8aa5-1f214776a315.png)Three boxes overlap other
    because they are absolute-positioned to do so'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 三个框重叠在一起，因为它们是绝对定位的。
- en: 'Check out the following code for the preceding example of three overlapping
    boxes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码，以查看前面三个重叠框的示例：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Components render according to their order in the markup, so `B3` draws over
    `B2`, and `B2` draws over `B1`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 组件根据它们在标记中的顺序进行渲染，所以`B3`覆盖`B2`，`B2`覆盖`B1`。
- en: If you need to put some of the components on top, use the `zIndex` prop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将一些组件放在顶部，请使用`zIndex`属性。
- en: Check out the documentation for a more detailed explanation: [https://facebook.github.io/react-native/docs/layout-props.html#zindex](https://facebook.github.io/react-native/docs/layout-props.html#zindex).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档以获取更详细的解释：[https://facebook.github.io/react-native/docs/layout-props.html#zindex](https://facebook.github.io/react-native/docs/layout-props.html#zindex)。
- en: 'As we have three `absolute` boxes, let''s see what happens if we change `B2`
    to `relative`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有三个`absolute`盒子，让我们看看如果将`B2`更改为`relative`会发生什么：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Suddenly **B1** disappears:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 突然**B1**消失了：
- en: '![](Images/d073afbb-0f85-40f7-990d-b2394d3c2f8f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d073afbb-0f85-40f7-990d-b2394d3c2f8f.png)'
- en: '**B2** box is now relative to its parent `View`. Hence, its position starts
    from the upper-left corner of the parent position (as we have no paddings or margins).
    The **B1** and **B2** boxes are of the same size; **B2** overlaps all of **B1**.
    If we shrink **B2** a little using `{ width: 50, height: 50 }`, we will see **B1**
    underneath. I have also changed the font size of the text of **B2** to `40` for
    clarity. Check out `App.js` in the `src/Chapter 3/Example 7` directory. The results
    are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**B2**盒子现在相对于其父`View`。因此，其位置从父位置的左上角开始（因为我们没有填充或边距）。**B1**和**B2**盒子大小相同；**B2**覆盖了**B1**的所有内容。如果我们使用`{
    width: 50, height: 50 }`稍微缩小**B2**，我们将看到**B1**在下面。我还将**B2**的文本字体大小更改为`40`以便清晰。查看`src/Chapter
    3/Example 7`目录中的`App.js`。结果如下：'
- en: '![](Images/7729cda8-eecf-455d-884f-8711d1fc1f63.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7729cda8-eecf-455d-884f-8711d1fc1f63.png)'
- en: Now that we have learned about absolute and relative positioning, it's time
    to learn about a great pattern called Flexbox.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了绝对定位和相对定位，是时候学习一个称为Flexbox的伟大模式了。
- en: Using the Flexible Box pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用弹性盒模型
- en: This is one of the greatest patterns that I have learned about when it comes
    to styling. **Flexible Box** (**Flexbox**) literally make your boxes flexible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在样式方面学到的最伟大的模式之一。**弹性盒模型**（**Flexbox**）可以使您的盒子变得灵活。
- en: 'Let''s see a small example. The goal is to flex your box to fill the whole
    width of the screen:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个小例子。目标是将您的盒子拉伸以填满屏幕的整个宽度：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the result of the preceding code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的结果：
- en: '![](Images/3c8780b5-14c9-448a-911a-647f47b0b498.png)Box stretches to the whole
    screen width because we used flex: 1 styles'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/3c8780b5-14c9-448a-911a-647f47b0b498.png)由于我们使用了flex: 1样式，框延伸到整个屏幕宽度'
- en: It's not too fancy, but you don't need to use `Dimensions`. It is obviously
    just a start.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太花哨，但您不需要使用`Dimensions`。显然这只是一个开始。
- en: 'You know already that Views are relative to each other by default, so if you
    want to make some stripes, it''s as easy as stacking three `div` on top of each
    other:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道默认情况下视图是相对于彼此的，因此如果要制作一些条纹，只需将三个`div`堆叠在一起即可：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check out the following screenshot to see three boxes stretched across the
    whole screen''s width:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图，看到三个盒子横跨整个屏幕的宽度：
- en: '![](Images/a80a3717-b9cf-425a-b20f-46789faa7d71.png)Three boxes in a sequence,
    each stretched with flex: 1 inherited from parent View component'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a80a3717-b9cf-425a-b20f-46789faa7d71.png)三个盒子依次排列，每个盒子都使用从父View组件继承的flex:
    1进行拉伸'
- en: 'Now, let''s use this fairly easy concept to create header, main content, and
    footer components. To achieve that, let''s flex the middle `View`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个相当简单的概念来创建头部、主要内容和页脚组件。为了实现这一点，让我们拉伸中间的`View`：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now the middle `View` stretches to fill all available space, leaving 50 dp for
    the header `View` and another 50 for the footer `View`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间的`View`延伸以填充所有可用空间，为头部`View`留下50 dp，为页脚`View`留下另外50 dp。
- en: It's time to add some useful content to our divided screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向我们分割的屏幕添加一些有用的内容了。
- en: In the next sections, I will try to explain Flexbox using examples. But please
    also check out the Flexbox Froggy game to learn flexbox in different scenarios.
    It provides an interactive editor and your goal is to move frogs onto the respective
    leaves [https://github.com/thomaspark/flexboxfroggy/](https://github.com/thomaspark/flexboxfroggy/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将尝试使用示例来解释Flexbox。但请也查看Flexbox Froggy游戏，以了解不同情景下的flexbox。它提供了一个交互式编辑器，你的目标是将青蛙移动到相应的叶子上[https://github.com/thomaspark/flexboxfroggy/](https://github.com/thomaspark/flexboxfroggy/)。
- en: Positioning items with Flexbox
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flexbox定位项目
- en: The first important key is `flexDirection`. We can set it to `row`, `row-reverse`,
    `column`, or `column-reverse`. Flex direction makes content flow in that direction.
    By default in React Native, flex direction is set to `column`. That's why the
    boxes in the previous examples are displayed in a column.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重要的关键是`flexDirection`。我们可以将其设置为`row`，`row-reverse`，`column`或`column-reverse`。Flex方向使内容沿着该方向流动。在React
    Native中，默认情况下，flex方向设置为`column`。这就是为什么在前面的示例中，框以列的形式显示的原因。
- en: 'Let''s use `flexDirection` to display three small sections in the footer: `Home`,
    `Search`, and `About`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`flexDirection`在页脚中显示三个小部分：`主页`，`搜索`和`关于`：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Okay, we have three separate texts within the footer now. We will learn how to
    make them switch screens in [Chapters 7](f5f1ab36-54de-49a6-b245-e0145fe78bf0.xhtml), *Navigation
    Patterns*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们的页脚中有三个单独的文本。我们将学习如何在[第7章](f5f1ab36-54de-49a6-b245-e0145fe78bf0.xhtml)中切换屏幕的方法，*导航模式*。
- en: 'Our footer looks almost okay:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页脚看起来几乎没问题：
- en: '![](Images/2f6cd514-de03-4dd3-b36e-648bb09d60ee.png)Three separate footer texts'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 三个单独的页脚文本
- en: 'It''s time to learn how to spread views evenly on the x axis. If `flexDirection`
    is set to `row` or `row-reverse`, we can use `justifyContent`. `justifyContent`
    accepts the `flex-start`, `flex-end`, `center`, `space-between`, `space-around`,
    and `space-evenly` values. We will play with them later. For now, let''s use `space-between`.
    It will stretch the `Home` view, the `Search` view, and the `About` view in such
    a fashion to leave even spaces between them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是学习如何在x轴上均匀分布视图的时候了。如果`flexDirection`设置为`row`或`row-reverse`，我们可以使用`justifyContent`。`justifyContent`接受`flex-start`，`flex-end`，`center`，`space-between`，`space-around`和`space-evenly`值。我们稍后会使用它们。现在，让我们使用`space-between`。它将拉伸`主页`视图，`搜索`视图和`关于`视图，以在它们之间留下均匀的空间：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](Images/8f7c1832-79d5-43b8-a0e9-4918154164e7.png)Three texts in the footer
    are now separated with even spaces'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚中的三个文本现在用均匀的空格分隔开来
- en: 'Although it has nothing to do with flexbox, we can add some padding to make
    it nicer:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与flexbox无关，但我们可以添加一些填充使其更美观：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It makes the text easier to read:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样文本更容易阅读：
- en: '![](Images/6c961754-9a94-459a-a3c0-c7d137fae2ea.png)Padding on the right and
    left adds space from the screen edge'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 右边和左边的填充从屏幕边缘添加空间
- en: What if we want to also position vertically? There is a key for that called
    `alignItems`. It accepts the `flex-start`, `flex-end`, `center`, `stretch`, and `baseline` values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想垂直定位怎么办？有一个叫做`alignItems`的关键。它接受`flex-start`，`flex-end`，`center`，`stretch`和`baseline`值。
- en: 'Let''s now make our footer higher: 100 density-independent pixels. In addition,
    we want text to be centered vertically:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把页脚的高度提高：100个密度无关像素。此外，我们希望文本在垂直方向上居中：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check out the result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查看结果：
- en: '![](Images/7cd4d0cf-2820-4120-97ad-b1c7155d4ebe.png)Text in the footer is now
    vertically centered'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚中的文本现在垂直居中
- en: Styling flex items
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化flex项
- en: 'As we build the application, you may quickly realize the styles are a little
    bit ugly. The color palette is a complete disaster. Unless you are a designer,
    I recommend Googling a color-palette generator. I have changed the colors to be
    more palatable: white, black, and blue.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建应用程序时，您可能很快意识到样式有点丑陋。调色板是一个完全的灾难。除非您是设计师，我建议您搜索调色板生成器。我已经将颜色更改为更可接受的：白色，黑色和蓝色。
- en: 'Additionally I have added margins and paddings. Everything is nicely separated
    by a border between the header and content. Let''s check out how it looks on the
    iPhone 8 and iPhone X:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我已经添加了边距和填充。标题和内容之间通过边框很好地分隔开来。让我们看看在iPhone 8和iPhone X上的效果如何：
- en: '![](Images/1261aefe-5759-4bea-859d-13c5edeef2da.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1261aefe-5759-4bea-859d-13c5edeef2da.png)'
- en: Full application look on iPhone 8 and iPhone X simulators after colour changes
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色更改后，iPhone 8和iPhone X模拟器上的完整应用程序外观
- en: 'Some of you may not know the basics of styling, so let''s quickly explain what
    margins and paddings are. The **margin** is used to create space around an element.
    This space is created from the border of the element. You may choose top, bottom,
    left, or right if you want to apply space only there. The **padding** is very
    similar, but instead of space outside, it creates space inside. Space is created
    inside from the border. Check out the element inspector to understand this visually.
    I have inspected our app header to see how the styles work:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能不了解样式的基础知识，所以让我们快速解释一下边距和填充是什么。**边距**用于在元素周围创建空间。这个空间是从元素的边框创建的。如果您只想在某个地方应用空间，您可以选择顶部、底部、左侧或右侧。**填充**非常类似，但它不是在外部创建空间，而是在内部创建空间。空间是从边框内部创建的。查看元素检查器以直观地理解这一点。我已经检查了我们应用程序的标题，以了解样式是如何工作的：
- en: '![](Images/93cf522c-04ba-4849-a804-9a41a4a5aed1.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/93cf522c-04ba-4849-a804-9a41a4a5aed1.png)'
- en: Margin and padding of the Header box
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Header box的边距和填充
- en: In the previous screenshot, padding is marked with green, and the margin is
    marked with orange. The component space is light blue. For the exact values specified
    in styles, please look at the right part of the image.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图中，填充用绿色标记，边距用橙色标记。组件空间是浅蓝色的。有关样式中指定的确切值，请查看图像的右侧部分。
- en: To open the element inspector, shake your device and, when the menu opens, choose
    Toggle element inspector. If you are using the simulator, you can simulate a shake
    by choosing the hardware/shake gesture from the simulator menu.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开元素检查器，请摇动您的设备，当菜单打开时，选择切换元素检查器。如果您正在使用模拟器，您可以通过从模拟器菜单中选择硬件/摇动手势来模拟摇动。
- en: 'Here are the styles that I used to create `header`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我用来创建`header`的样式：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, let's make the footer more reusable. What if, at some point, we don't
    need the About link but a Notifications link instead? This word is really long.
    It will not fit into our design. While this is a problem now, if we plan to add
    translations, we will run into this issue there too.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使页脚更具重复使用性。如果在某个时候，我们不需要“关于”链接，而是需要“通知”链接呢？这个词真的很长。它不适合我们的设计。虽然现在是一个问题，但如果我们计划添加翻译，我们也会在那里遇到这个问题。
- en: 'Most applications fix these issues using icons. Let''s try that:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序使用图标来解决这些问题。让我们试试：
- en: 'Install the icon package:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装图标包：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Change the footer markup:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改页脚标记：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The added icons can be observed on the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的图标可以在以下截图中观察到：
- en: '![](Images/10ec45dc-f0a2-4521-b2ac-7d8d8c4fd203.png)Application''s footer is
    now made of icons'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/10ec45dc-f0a2-4521-b2ac-7d8d8c4fd203.png)应用程序的页脚现在由图标组成'
- en: The footer is now reusable and supports any language. Check what icons mean
    in other countries if you support their language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚现在是可重复使用的，并支持任何语言。如果您支持他们的语言，请检查其他国家的图标含义。
- en: Styling content
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式内容
- en: We have the footer positioned using the direction row. It's time to position
    the main content and column. In the previous chapters, we created a task list.
    This is the time to integrate it with our design.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用方向行定位了页脚。现在是定位主要内容和列的时候了。在之前的章节中，我们创建了一个任务列表。现在是将其与我们的设计整合的时候了。
- en: 'Add the `TaskList` component into the content box. I also add the `ScrollView`
    component to make content scrollable in case tasks take up too much space to display
    all of them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将`TaskList`组件添加到内容框中。我还添加了`ScrollView`组件，以便在任务占用太多空间无法全部显示时使内容可滚动：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'My tasks mock in the JSON file is presented as follows. Later on in this book,
    we will learn how to fetch tasks from a backend server and how to separate such
    logic from the markup:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我的任务模拟在JSON文件中呈现如下。在本书的后面，我们将学习如何从后端服务器获取任务以及如何将这样的逻辑与标记分离：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Having the mock, we can implement the `TaskList` view:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了模拟，我们可以实现`TaskList`视图：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`LikeCounter` is copy-pasted from `Chapter 2 / Example 8 / src` and tweaked
    to accept likes as props (replaces the default zero). Please note that it uses
    Flexbox too, and that `flexDirection` there is set to row.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`LikeCounter`是从`Chapter 2 / Example 8 / src`复制并调整以接受点赞作为props（替换默认的零）。请注意，它也使用了Flexbox，并且`flexDirection`设置为行。'
- en: 'Now, we are ready to style the content. Here is our starting point:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备样式内容。这是我们的起点：
- en: '![](Images/ecb8b650-3477-4530-9dd7-5a4ed34dbc87.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ecb8b650-3477-4530-9dd7-5a4ed34dbc87.png)'
- en: Current look at iPhone 8 and iPhone X simulators
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 8和iPhone X模拟器的当前外观
- en: 'We want to reorganize the contents of each task. The **Like** and **Unlike**
    widget should be displayed on the right side of the task and should use icons.
    The task name should be slightly bigger than the description and should fit on
    70% of the task width. The right-hand side, with the like/dislike widget, should
    be separated by a thin grey border. The border should also separate tasks. Add
    nice paddings and margins where necessary:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想重新组织每个任务的内容。**点赞**和**取消点赞**小部件应该显示在任务的右侧，并且应该使用图标。任务名称应该比描述稍大，并且应该适合任务宽度的70%。右侧的点赞/取消点赞小部件应该用细灰色边框分隔。边框也应该分隔任务。在必要的地方添加漂亮的填充和边距：
- en: '![](Images/48d8384f-5440-4237-90ff-5a8ecb6ff8cb.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/48d8384f-5440-4237-90ff-5a8ecb6ff8cb.png)'
- en: Desired look of iPhone 8 and iPhone X simulators
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 8和iPhone X模拟器的期望外观
- en: 'Okay, how do we start? We need to break things up into small pieces that can
    be implemented separately. Create the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们如何开始？我们需要将事情分解成可以分别实现的小块。创建以下内容：
- en: A task `View` with the task-container styling and top-border styling.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有任务容器样式和顶部边框样式的任务`View`。
- en: The two inner `Views` – one for the name and description and another for the
    like counter. These should be displayed in a row.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个内部`Views` - 一个用于名称和描述，另一个用于点赞计数器。这些应该以行的形式显示。
- en: 'The name and description `View` should have two `Views` inside: one for the
    name and one for the description. Add styling to make `fontSize` bigger for name.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称和描述`View`内应该有两个`Views`：一个用于名称，一个用于描述。添加样式使名称的`fontSize`更大。
- en: 'The like counter `View` container should define the border on the left. The
    container should have two `Views` inside: one for the number of likes and another
    for the like/dislike icons. These `Views` should use column as the default direction.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点赞计数器`View`容器应该在左边定义边框。容器内应该有两个`Views`：一个用于点赞数量，另一个用于点赞/取消点赞图标。这些`Views`应该使用列作为默认方向。
- en: The View with the like/dislike icons should have row direction flexbox styling.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有点赞/取消点赞图标的`View`应该具有行方向的flexbox样式。
- en: 'As we have that, use `alignItems` and `justifyContent` to position elements
    vertically or horizontally. Please look at helper images from the inspector:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，使用`alignItems`和`justifyContent`来垂直或水平定位元素。请从检查器中查看辅助图像：
- en: '![](Images/d696a937-dffb-4a83-9bea-c81bc6f1374f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d696a937-dffb-4a83-9bea-c81bc6f1374f.png)'
- en: Inspector view of implemented components. Serves as a hint for implementation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 已实现组件的检查器视图。作为实现的提示。
- en: The orange highlight represents the `View` margin, and the green highlight represents
    the `View` padding.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 橙色高亮表示`View`边距，绿色高亮表示`View`填充。
- en: Try implementing this yourself. The full solution is available in the `src/
    Chapter_3/ Example_12/ src/` folder, in the `App.js`, `TaskList.js`, and `LikeCounter.js`
    files.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己实现这个。完整的解决方案可以在`src/ Chapter_3/ Example_12/ src/`文件夹中的`App.js`、`TaskList.js`和`LikeCounter.js`文件中找到。
- en: Solving the text overflow problem
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决文本溢出问题
- en: 'One of the most common problems is text overflow. The easiest trick to solve
    this is to wrap text, but sometimes it is not possible. Examples:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的问题之一是文本溢出。解决这个问题最简单的方法是换行，但有时不可能。例如：
- en: Button text
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮文本
- en: Large number that needs to be displayed (for instance, the  like count)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显示的大数字（例如，点赞数）
- en: Long word that should not be broken down
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应该被分解的长单词
- en: 'The question is: how can we approach this problem? There are many solutions.
    Let''s look at a few.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：我们如何解决这个问题？有很多解决方案。让我们看看其中一些。
- en: Scaling the font down
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小字体
- en: 'This is possible on iOS right now:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这在iOS上是可能的。
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But, the outcome is a complete disaster in our case. The layout feels very
    inconsistent, even if we put some work into this scaling solution:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们的情况下，结果是完全灾难性的。即使我们在这个缩放解决方案上付出了一些工作，布局仍然感觉非常不一致：
- en: '![](Images/d8571279-3fa0-4228-9325-f04d21172d7b.png)Automatic font adjustment
    using the adjustsFontSizeToFit prop for iOSAs shown earlier in the book, you could
    use `Dimensions` instead of relying on `adjustsFontSizeToFit`. Based on `Dimensions`,
    you can create a scaling function to compute `fontSize`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d8571279-3fa0-4228-9325-f04d21172d7b.png)使用iOS的adjustsFontSizeToFit属性进行自动字体调整正如本书前面所示，您可以使用`Dimensions`而不是依赖`adjustsFontSizeToFit`。基于`Dimensions`，您可以创建一个缩放函数来计算`fontSize`。'
- en: Truncating text
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截断文本
- en: 'Another approach is known as **truncating**. Based on the text length, you
    cut it at some point and add three dots instead, `...`. However, this approach
    is not good for our use case. We work with the likes count number and we want
    to know what the number is:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法被称为**截断**。根据文本长度，您可以在某个位置截断它，并用三个点`...`代替。然而，这种方法对我们的用例不好。我们处理的是点赞数，我们想知道数字是多少：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Observe the truncated number of likes in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下截断的点赞数：
- en: '![](Images/3e3f886e-8f39-412c-b1df-7164ab0c92da.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e3f886e-8f39-412c-b1df-7164ab0c92da.png)'
- en: Truncated numbers are meaningless, this solution works only for text
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 截断的数字是没有意义的，这个解决方案只适用于文本
- en: Using the Kilo social media notation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用千位分隔符社交媒体表示法
- en: You know that kilo means 1,000\. Social media designers pushed this idea to
    the web and mobiles. Whenever a number is greater than 1,000, they replace the
    last 3 digits with K. For instance 20Kmeans 20,000.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道kilo表示1,000。社交媒体设计师将这个想法推广到了网络和移动设备。每当一个数字大于1,000时，他们用K替换最后的3位数字。例如20K表示20,000。
- en: 'The trivial implementation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 微不足道的实现：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, a number such as *9,876,543,210* is going to overflow again. But 9,876,543K
    is still too long. Let''s solve this with a simple recursive function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个数字如*9,876,543,210*将再次溢出。但9,876,543K仍然太长。让我们用一个简单的递归函数来解决这个问题：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This algorithm works as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的工作原理如下：
- en: The function takes a number in a string format and an optional parameter that
    indicates how many thousands are already stripped of the original number.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个字符串格式的数字和一个可选参数，指示原始数字已经剥离了多少千。
- en: It checks whether it can strip another thousand, if so, it returns the outcome
    of itself with the number stripped by three numbers and the number of thousands
    increased by one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查是否可以再减去一千，如果可以，就返回自身的结果，其中数字减去三个数字，千位数增加一。
- en: 'If the number length is less than four, compute the text: take the number and
    attach the relevant number of Ks as the suffix. We compute Ks using a neat trick:
    create an array of size equal to the number of Ks, fill every element with the
    K string, and join all the elements into one long string.The JSX is now much simpler:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字长度小于四，计算文本：取数字并附加相应数量的K作为后缀。我们使用一个巧妙的技巧来计算K：创建一个大小等于K数量的数组，用K字符串填充每个元素，并将所有元素连接成一个长字符串。现在JSX简单多了：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Check the result is as follows. The long number is now shown using the kilo
    notation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果如下。长数字现在使用千位符号显示：
- en: '![](Images/548a9826-d600-4b6b-87c7-67037f2b3ef0.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/548a9826-d600-4b6b-87c7-67037f2b3ef0.png)'
- en: A big like count is now displayed using the kilo (K) notation
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用千（K）符号显示大的点赞数
- en: It is a safe bet that the number of likes will not exceed 9,000,000,000\. If
    you need to support larger numbers, try the **M** or **B** letters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，点赞数不会超过9,000,000,000。如果需要支持更大的数字，请尝试使用**M**或**B**字母。
- en: React Native animated
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native动画
- en: As we build our application, we need to focus on the **user experience** (**UX**).
    One part of it is animations that make our screens more vibrant and provide instant
    feedback on the actions. If you played with our application on your own, you could
    see that when you click the like/dislike icon, it makes a little blink. That effect
    comes out of the box with `TouchableOpacity`. It's time to learn how we can implement
    such features on our own.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建应用程序时，我们需要关注**用户体验**（**UX**）。其中一部分是使我们的屏幕更加生动并提供对操作的即时反馈的动画。如果你自己玩过我们的应用程序，你会发现当你点击喜欢/不喜欢图标时，它会有一个小闪烁效果。这种效果是由`TouchableOpacity`自带的。现在是时候学习如何在我们自己的应用程序中实现这样的功能了。
- en: What are animations?
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是动画？
- en: When I first read the Animated library documentation I freaked out. There are
    so many new words that you will need to get used to. Instead of diving right into
    them, let's understand what animations really are.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次阅读Animated库的文档时，我吓了一跳。有很多新词汇需要你适应。与其直接深入其中，不如先了解动画到底是什么。
- en: Animation is a change to a component style over time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是组件样式随时间的变化。
- en: 'Remember: you need a style attribute, its starting value, and its end value.
    Animation is what you see when this value goes from start to end over time. You
    can combine many attributes and possibly animate many components at the same time.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：你需要一个样式属性，它的起始值和结束值。动画是当这个值随着时间从起始值到结束值时所看到的。你可以组合许多属性，可能同时对许多组件进行动画处理。
- en: 'The common and recommended way to store variables that will change over time
    is the component state. React Native Animated provides a special class that implements
    this functionality in a very performant way: `Animated.Value`. For example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 存储随时间变化的变量的常见和推荐方法是组件状态。React Native Animated提供了一个特殊的类，以非常高效的方式实现了这个功能：`Animated.Value`。例如：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Changing attributes over time
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随时间改变属性
- en: 'In React Native, there are three main ways to create animations:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中，有三种主要的创建动画的方式：
- en: '`Animated.timing()`: Takes time in milliseconds and desired end value, and
    maps them to your `Animated.Value`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.timing()`: 以毫秒为单位的时间和期望的结束值，并将它们映射到你的`Animated.Value`。'
- en: '`Animated.decay()`: Starts with an initial velocity and slowly decays.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.decay()`: 从初始速度开始，然后慢慢衰减。'
- en: '`Animated.spring()`: Provides a simple spring physics model.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.spring()`: 提供了一个简单的弹簧物理模型。'
- en: 'Let''s see how it works in action. Our goal will be to fade in application
    on the app''s start. To achieve a fade-in effect, we will manipulate opacity from
    0 to 1\. The animation should take two seconds:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何运作的。我们的目标是在应用程序启动时淡入应用程序。为了实现淡入效果，我们将从0到1操纵不透明度。动画应该持续两秒：
- en: '![](Images/84ff6dee-ace8-495a-becb-45211ddbcf78.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/84ff6dee-ace8-495a-becb-45211ddbcf78.png)'
- en: Sequence of images showing the opacity animation progress over time
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 显示随时间推移不透明度动画进度的图像序列
- en: '`Animated.timing` expects two arguments: variable to be manipulated and config
    object. In a config object, you need to specify the `toValue` key to tell the
    function what should be the end value of your variable after the duration of milliseconds –
    in our case, 2,000\. I chose two seconds just for the animation to be a little
    easier to see. Play around with it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animated.timing`需要两个参数：要操作的变量和配置对象。在配置对象中，您需要指定`toValue`键，以告诉函数在毫秒的持续时间后您的变量应该是什么结束值
    - 在我们的情况下是2,000。我选择了两秒只是为了让动画更容易看到。随意尝试：'
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have also introduced a new component: `Animated.View`. It makes our usual
    `View` component support animations.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了一个新组件：`Animated.View`。它使我们通常的`View`组件支持动画。
- en: React Native Animated provides animatable components: `Animated.Image`, `Animated.ScrollView`,
    `Animated.Text`, and `Animated.View`, but you can also define your own using the `createAnimatedComponent()`
    function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Animated提供了可动画化的组件：`Animated.Image`、`Animated.ScrollView`、`Animated.Text`和`Animated.View`，但您也可以使用`createAnimatedComponent()`函数定义自己的组件。
- en: Additionally, in the config object, we specified **easing**. Easing is how the
    animation should go. If it should change the value linearly over time then use
    `Easing.linear`. Linear however is not natural. Check the next section to learn
    more about easing functions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在配置对象中，我们指定了**easing**。缓动是动画应该如何进行的方式。如果它应该随时间线性改变值，那么使用`Easing.linear`。然而线性并不自然。查看下一节以了解更多关于缓动函数的信息。
- en: Learning animations takes time. You can create countless different scenarios
    and you should play around with the API on your own. Especially when it comes
    to `Animated.decay` and `Animated.spring`. I'm not covering them in the book as
    it is not a very big pattern, it is just another API you need to learn. In the
    next sections, we will focus on ways to chain animations and then how to make
    them performant.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 学习动画需要时间。您可以创建无数不同的场景，应该自己尝试API。特别是当涉及到`Animated.decay`和`Animated.spring`时。我在书中没有涵盖它们，因为它不是一个非常大的模式，它只是您需要学习的另一个API。在接下来的章节中，我们将专注于如何链接动画，然后如何使它们性能良好。
- en: Think about how to create a draggable box using `Animated.decay`. You will also
    need a `PanResponder` component. On the release of a touch event, it should maintain
    its speed in the same direction and should slowly stop after flying some distance.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 想想如何使用`Animated.decay`创建一个可拖动的框。您还需要一个`PanResponder`组件。在触摸事件释放时，它应该保持在相同方向上的速度，并在飞行一段距离后慢慢停止。
- en: The second exercise could be implementing a red square box with a button underneath.
    On a button press, the square box should expand its width and height by another
    15 density-independent pixels. All should be done with a spring animation, thus
    width should go a little beyond 15 and then go back to 15\. Just like a spring
    does.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个练习可能是实现一个带有按钮的红色正方形框。在按下按钮时，正方形框应该通过另外15个独立像素来扩展其宽度和高度。所有这些都应该通过弹簧动画完成，因此宽度应该略微超过15，然后再回到15。就像弹簧一样。
- en: If these two exercises sound tough, please proceed to the next section. They
    should get easier once you learn about easing functions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个练习听起来很困难，请继续下一节。一旦您了解了缓动函数，它们应该会变得更容易。
- en: The easing function
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓动函数
- en: An animation is a change over time. This change can be applied in many ways.
    The function that determines the new value over time is known as an easing function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是随时间的变化。这种变化可以以多种方式应用。确定随时间变化的新值的函数称为缓动函数。
- en: Why do we use easing functions instead of linear easing? The common example
    I like is a drawer opening. When you open a drawer in the real world, is it a
    linear process? Perhaps not.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用缓动函数而不是线性缓动？我喜欢的常见例子是抽屉的打开。当您在现实世界中打开抽屉时，这是一个线性过程吗？也许不是。
- en: 'Now let''s look at the common easing functions. There are a few. Choose the
    one that fits your application:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看常见的缓动函数。有几种。选择适合您应用程序的那个：
- en: '![](Images/9a122705-48ef-44c2-ae7e-58b8c1162eb6.png)Many different easing functions
    with a visualization of each one changes value over time.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9a122705-48ef-44c2-ae7e-58b8c1162eb6.png)许多不同的缓动函数，以及每个函数随时间变化的可视化。'
- en: On the graphs, grey lines indicate the start and end value. The black line represents
    how the value changes over time. Eventually, the black line reaches the upper
    grey line. As you can see, some easing functions go below the start value or beyond
    the end value. Those may be useful for highlighting important actions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表上，灰色线表示起始值和结束值。黑线表示值随时间的变化。最终，黑线达到了上方的灰色线。正如您所见，一些缓动函数会低于起始值或超过结束值。这些可能对突出重要操作很有用。
- en: Want to see more easing functions? Check out [http://easings.net/](http://easings.net/).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 想看更多缓动函数？查看[http://easings.net/](http://easings.net/)。
- en: Most of these functions can be implemented using the RN Easing module.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些函数可以使用RN Easing模块实现。
- en: 'Back to React Native easings. I have prepared an application for you to play
    around with easing functions. You will find the source code at `src/ Chapter_3/
    Example_14/ App.js`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 回到React Native缓动。我为您准备了一个应用程序，让您玩转缓动函数。您可以在`src/ Chapter_3/ Example_14/ App.js`找到源代码：
- en: '![](Images/327c9d13-9568-4c15-8e64-778eb6f807af.png)Easing functions playground
    application'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/327c9d13-9568-4c15-8e64-778eb6f807af.png)缓动函数游乐场应用'
- en: When you click on a button, you will see a box moving from left to right with
    the respective easing function.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击按钮时，您将看到一个框从左到右移动，使用相应的缓动函数。
- en: 'As for the animation, I do it by manipulating `marginLeft` of the box. The
    animation starts with `marginLeft` set to 20 and applies the easing function to
    reach 300 over 2 seconds:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 至于动画，我是通过操纵框的`marginLeft`来实现的。动画从`marginLeft`设置为20开始，并应用缓动函数在2秒内达到300：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Scheduling events
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度事件
- en: As we know how to create animations, now let's talk about how to schedule them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建动画，现在让我们谈谈如何安排它们。
- en: 'The trivial approach is a delayed animation dispatch:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是延迟动画调度：
- en: '`Animated.delay()`: Starts an animation after a given delay. Good if you need
    to delay your response to a user action. But usually this is not a case.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.delay()`: 在给定的延迟后开始动画。如果您需要延迟对用户操作的响应，这很有用。但通常情况下并不需要。'
- en: 'Let''s talk about array of events that we want to schedule. More than one event
    should be dispatched. If we need all of the events to happen at the same time,
    it is also trivial:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈我们想要安排的事件数组。应该分派多个事件。如果我们需要所有事件同时发生，这也很简单：
- en: '`Animated.parallel()`: Starts a number of animations at the same time. But
    what if we need to time them one after another? Here comes sequence.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.parallel()`: 同时开始多个动画。但如果我们需要按顺序进行呢？这就是序列的用处。'
- en: '`Animated.sequence()`: Starts the animations in order, waiting for each one
    to complete before starting the next. There is also a variation of parallel. It
    is called stagger.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.sequence()`: 按顺序开始动画，等待每个动画完成后再开始下一个。还有一个并行的变体，称为stagger。'
- en: '`Animated.stagger()`: Starts animations in order and in parallel, but with
    successive delays.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.stagger()`: 按顺序和并行启动动画，但具有连续的延迟。'
- en: 'Exercise time: Fill the screen with rows of colored boxes. Rows should appear
    on the screen one after another in a staggered fashion:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 练习时间：用彩色框填满屏幕。行应该以交错的方式一个接一个地出现在屏幕上：
- en: '![](Images/91d74030-2f9b-485b-8548-65dd4c1049a9.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/91d74030-2f9b-485b-8548-65dd4c1049a9.png)'
- en: Images showing the stagger animation over time
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 显示随时间变化的交错动画的图像
- en: 'The full implementation is available at `src/ Chapter_3/ Example_15/ App.js`. Let''s
    look at a key fragment:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的实现可在`src/ Chapter_3/ Example_15/ App.js`中找到。让我们看一下关键片段：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first function is just a helper. It generates one timed animation. We use
    this helper function to generate all the animations and collect them in the `animations` variable.
    The helper function expects `animatedVal`, which will be eased to 1\. In my implementation,
    I have created a separate `Animated.Value` in the state for each of the boxes.
    In the end, I pass a generated array of animations to stagger and immediately
    start.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数只是一个辅助函数。它生成一个定时动画。我们使用这个辅助函数来生成所有的动画，并将它们收集在`animations`变量中。辅助函数期望`animatedVal`，它将被缓慢到
    1。在我的实现中，我为每个框创建了一个单独的`Animated.Value`。最后，我将生成的动画数组传递给`stagger`并立即开始。
- en: Pretty nice animation, right? Now, let's talk about performance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 很不错的动画，对吧？现在，让我们谈谈性能。
- en: Measuring FPS
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量 FPS
- en: Websites and mobile applications use animations pretty rarely. Most of the time,
    it's in response to user actions that tend to be slow. If you've ever played a
    dynamic computer game, you probably remember what a different world it is. Yes,
    as we dive into animations, there is one thing from computer games that you should
    remember: **FPS**.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 网站和移动应用程序很少使用动画。大多数情况下，这是对用户行为的响应，往往是缓慢的。如果您曾经玩过动态电脑游戏，您可能还记得这是一个不同的世界。是的，当我们深入研究动画时，有一件事来自电脑游戏，您应该记住：**FPS**。
- en: Frames per second – everything on the screen appears in motion thanks to the
    optical illusion created by quickly changing frames at a consistent speed. 60
    FPS means 60 frames per second, which means you see a new frame every 16.67ms.
    JavaScript needs to deliver that frame in this short period, otherwise the frame
    will be dropped. If so, your FPS metric will drop below 60.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒帧数 - 屏幕上的所有内容都以光学幻觉的形式出现在运动中，这是由于以一致的速度快速更改帧而创建的。60 FPS 意味着每秒 60 帧，这意味着您每
    16.67 毫秒看到一个新帧。JavaScript 需要在这么短的时间内传递该帧，否则帧将被丢弃。如果是这样，您的 FPS 指标将低于 60。
- en: 'React Native is known for its amazing performance in most of the applications:
    **60 FPS**. But, as we start using a lot of animations, we can quickly kill that
    performance. In this section, I want to show you how to measure FPS in your application.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 以其在大多数应用程序中的惊人性能而闻名：**60 FPS**。但是，当我们开始使用大量动画时，我们很快就会降低性能。在本节中，我想向您展示如何测量应用程序的
    FPS。
- en: 'Let''s check how well we do with our previous animation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们之前的动画表现如何：
- en: '![](Images/66b4e2d1-ae1f-4a0e-8d09-a64d1542b067.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/66b4e2d1-ae1f-4a0e-8d09-a64d1542b067.png)'
- en: Images showing the stagger animation over time
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 显示随时间变化的交错动画的图像
- en: We will measure this animation. On a simulator, I get **48** FPS with animations
    halfway started. Near the finish, FPS drops down to **18**. When all animations
    complete, FPS is back to its normal 60\. I have also checked on my real phone
    (iPhone 7 plus) and the results were similar.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测量这个动画。在模拟器上，我得到**48** FPS，动画已经进行了一半。接近完成时，FPS 降至**18**。当所有动画完成时，FPS 恢复到正常的
    60。我还在我的真实手机（iPhone 7 plus）上进行了检查，结果类似。
- en: This is just an example of the FPS drop in the development environment. However,
    you should test your application on real production builds instead. Learn more
    at [https://facebook.github.io/react-native/docs/performance.html](https://facebook.github.io/react-native/docs/performance.html).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是开发环境中FPS下降的一个例子。然而，您应该在真实的生产版本中测试您的应用程序。在[https://facebook.github.io/react-native/docs/performance.html](https://facebook.github.io/react-native/docs/performance.html)了解更多。
- en: How to measure FPS
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何测量FPS
- en: 'It''s time to learn how to check FPS. There are two main ways:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何检查FPS了。有两种主要方法：
- en: Use a tool, such as Perf Monitor. It provides this functionality out of the
    box. It allows you to also measure the native environment.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具，比如Perf Monitor。它提供了这个功能。它还允许您测量本机环境。
- en: Write custom JavaScript code to measure FPS. This will only measure the JS thread's
    performance.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义JavaScript代码来测量FPS。这只会测量JS线程的性能。
- en: 'Using a performance monitor with the *Create React Native* App is as easy as
    shaking your device and choosing the Show Perf Monitor option:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Create React Native* App的性能监视器就像摇动您的设备并选择“显示Perf Monitor”选项一样简单：
- en: '![](Images/e7dc8e56-7e84-4300-bd30-6c66f82cdb95.png)Show perf monitor. Numbers
    60 and 45 represent the latest value of the FPS measure'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e7dc8e56-7e84-4300-bd30-6c66f82cdb95.png)显示性能监视器。数字60和45代表FPS测量的最新值'
- en: 'Implementing your own solution in JavaScript should rely on the fact that a
    desired 60FPS mean a frame every 16.67ms (1000ms/60). I have created a simple
    example for you:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中实现自己的解决方案应该依赖于所需的60FPS意味着每16.67ms（1000ms/60）有一帧。我为您创建了一个简单的示例：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As this book strives to teach you design patterns, I hope you will also check
    whether your solutions are performant.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书致力于教授设计模式，我希望您也能检查您的解决方案是否具有高性能。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to style React Native applications. We introduced
    many different ways of positioning elements and you learned how our designs translate
    to real devices. In the end, we made a few animations and measured them in terms
    of FPS.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何为React Native应用程序设置样式。我们介绍了许多不同的元素定位方式，您还学会了我们的设计如何在真实设备上呈现。最后，我们制作了一些动画，并根据FPS进行了测量。
- en: So far, we know how to create reusable code using React components and how to
    style them. We worked with limited data stored in the local JSON file. It's time
    to make our application more complex and talk about different scenarios that impact
    big applications. In the next chapter, you will learn about Flux, which is an
    architectural pattern.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何使用React组件创建可重用的代码，以及如何对它们进行样式设置。我们使用本地JSON文件中存储的有限数据进行了工作。现在是时候让我们的应用程序变得更加复杂，并讨论影响大型应用程序的不同场景。在下一章中，您将学习Flux，这是一种架构模式。
