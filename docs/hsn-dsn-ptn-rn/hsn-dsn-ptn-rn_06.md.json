["```jsx\nyarn global add json-server\n```", "```jsx\n{\n  \"tasks\": [\n    // task objects separated by comma \n  ]\n}\n```", "```jsx\n// src / Chapter 6 / Example 1 / package.jsonn\n// ...\n\"scripts\": {\n  // ...   \"server\": \"json-server --watch ./src/data/tasks.json\" },\n// ...\n```", "```jsx\n[\n  {\n    \"name\": \"Task 1\",\n    \"description\": \"Task 1 description\",\n    \"likes\": 239\n  },\n  // ... other task objects\n]\n```", "```jsx\n(state = Immutable.List([...data.tasks]), action) => {\n    // ...\n}\n```", "```jsx\n(state = Immutable.List([]), action) => {\n    // ...\n}\n```", "```jsx\nimport { View, Text, StyleSheet, ActivityIndicator } from 'react-native';\n// ...\nconst TaskList = ({ tasks, isLoading }) => (\n    <View>\n  {isLoading\n            ? <ActivityIndicator size=\"large\" color=\"#0000ff\" />\n  : tasks.map((task, index) => (\n                // ...   ))\n        }\n    </View> ); \n```", "```jsx\n// src / Chapter 6 / Example 2 / src / views / TaskList.js\nconst TaskList = ({ tasks, isLoading }) => (\n    <View>\n  {isLoading && <ActivityIndicator size=\"large\" color=\"#0000ff\" />}\n {tasks.map((task, index) => (\n            // ...   ))}\n    </View> );\n```", "```jsx\nconst TaskList = ({\n    tasks, isLoading, hasError, errorMsg\n}) => (\n    <View>\n  {hasError &&\n            <View><Text>{errorMsg}</Text></View>}\n        {hasError && isLoading &&\n            <View><Text>Fetching again...</Text></View>}\n        {isLoading && <ActivityIndicator size=\"large\" color=\"#0000ff\" />}\n        {tasks.map((task, index) => (\n            // ...   ))}\n    </View> );\n// ... TaskList.defaultProps = {\n    errorMsg: 'Error has occurred while fetching tasks.' };\n```", "```jsx\n// src / Chapter 6 / Example 2 / src / App.js\nclass TasksFetchWrapper extends React.Component {\n    constructor(props) {\n        super(props);\n        // Default state of the component\n  this.state = {\n            isLoading: true,\n  hasError: false,\n  errorMsg: '',\n  tasks: props.tasks\n  };\n  }\n\n    componentDidMount() {\n        // Start fetch and on completion set state to either data or\n        // error\n        return fetch('http://localhost2:3000/tasks')\n            .then(response => response.json())\n            .then((responseJSON) => {\n                this.setState({\n                    isLoading: false,\n  tasks: Immutable.List(responseJSON)\n                });\n  })\n            .catch((error) => {\n                this.setState({\n                    isLoading: false,\n  hasError: true,\n  errorMsg: error.message\n  });\n  });\n  }\n\n    render = () => (\n        <AppView\n  tasks={this.state.tasks}\n            isLoading={this.state.isLoading}\n            hasError={this.state.hasError}\n            errorMsg={this.state.errorMsg}\n        />\n  ); }\n  // State from redux passed to wrapper. const mapStateToProps = state => ({ tasks: state.tasks }); const AppContainer = connect(mapStateToProps)(TasksFetchWrapper);\n```", "```jsx\n// src / Chapter 6 / Example 3 / src / reducers / taskReducer.js\n\nconst taskReducer = (state = Immutable.Map({\n    entities: Immutable.List([])**,**\n  isLoading: false,\n  hasError: false,\n  errorMsg: **''** }), action) => {\n    switch (action.type) {\n    case TasksActionTypes.ADD_TASK:\n        if (!action.task.name) {\n            return state;\n  }\n        return state.update('entities', entities => entities.push({\n            name: action.task.name,\n  description: action.task.description,\n  likes: 0\n  }));\n  default:\n        return state;\n  }\n}; \n```", "```jsx\n// src / Chapter 6 / Example 3 / src / App.js\nclass TasksFetchWrapper extends React.Component {\n    componentDidMount() {\n        TaskActions.fetchStart();\n  return fetch('http://localhost:3000/tasks')\n            .then(response => response.json())\n            .then((responseJSON) => {\n                TaskActions.fetchComplete(Immutable.List(responseJSON));\n  })\n            .catch((error) => TaskActions.fetchError(error));\n  }\n\n    render = () => <AppView tasks={this.props.tasks} />; }\n```", "```jsx\n// src / Chapter 6 / Example 3 / src / reducers / taskReducer.js\nconst taskReducer = (state = Immutable.Map({\n    // ...  }), action) => {\n    switch (action.type) {\n    case TasksActionTypes.ADD_TASK: {\n        // ...   }\n    case TasksActionTypes.TASK_FETCH_START: {\n        return state.update('isLoading', () => true);\n  }\n    case TasksActionTypes.TASK_FETCH_COMPLETE: {\n        const noLoading = state.update('isLoading', () => false);\n  return noLoading.update('entities', entities => (\n            // For every task we update the state\n            // Homework: do this in bulk\n            action.tasks.reduce((acc, task) => acc.push({\n                name: task.name,\n  description: task.description,\n  likes: 0\n  }), entities)\n        ));\n  }\n    case TasksActionTypes.TASK_FETCH_ERROR: {\n        const noLoading = state.update('isLoading', () => false);\n  const errorState = noLoading.update('hasError', () => true);\n  return errorState.update('errorMsg', () => action.error.message);\n  }\n    default: {\n        return state;\n  }\n    }\n};\n```", "```jsx\n// src / Chapter 6 / Example 3 / src / views / AppView.js\n// ...\n<TaskList\n  tasks={props.tasks.get('entities')}\n    isLoading={props.tasks.get('isLoading')}\n    hasError={props.tasks.get('hasError')}\n    errorMsg={props.tasks.get('errorMsg')}\n/>\n// ... \n```", "```jsx\nfunction incrementIfOdd() {\n  return (dispatch, getState) => {\n    const { counter } = getState();\n\n    if (counter % 2 === 0) {\n      return;\n    }\n\n    dispatch(increment());\n  };\n}\n\ndispatch(incrementIfOdd())\n```", "```jsx\nconst fetchTasks = () => {\n    TaskActions.fetchStart();\n  return fetch('http://localhost:3000/tasks')\n        .then(response => response.json())\n        .then((responseJSON) => {\n            TaskActions.fetchComplete(Immutable.List(responseJSON));\n  })\n        .catch(error => TaskActions.fetchError(error)); };   class TasksFetchWrapper extends React.Component {\n componentDidMount = () => this.props.fetchTasks();\n  render = () => <AppView tasks={this.props.tasks} />; }\n\nconst mapStateToProps = state => ({ tasks: state.tasks }); const mapDispatchToProps = dispatch => ({ fetchTasks }); const AppContainer = connect(mapStateToProps, mapDispatchToProps)(TasksFetchWrapper);\n```", "```jsx\n// Before  const Actions = {\naddTask(task) {\n        AppDispatcher.dispatch({\ntype: TasksActionTypes.ADD_TASK,\n  task\n        });\n  },\n  fetchStart() {\n        AppDispatcher.dispatch({\ntype: TasksActionTypes.TASK_FETCH_START\n  });\n  },\n // ...\n}; \n// After\nconst ActionCreators = {\n addTask: task => ({\ntype: TasksActionTypes.ADD_TASK,\n  task\n   }),\n  fetchStart: () => ({\ntype: TasksActionTypes.TASK_FETCH_START\n  }),\n // ...\n}; \n```", "```jsx\nconst ActionTriggers = {\n addTask: dispatch => task => dispatch(ActionCreators.addTask(task)),\n  fetchStart: dispatch => () => dispatch(ActionCreators.fetchStart()),\n  fetchComplete: dispatch =>\n        tasks => dispatch(ActionCreators.fetchComplete(tasks)),\n  fetchError: dispatch =>\n        error => dispatch(ActionCreators.fetchError(error))\n};\n```", "```jsx\n// src / Chapter 6 / Example 4 / src / App.js export const fetchTasks = (dispatch) => {\n    TaskActions.fetchStart(dispatch)();\n  return fetch('http://localhost:3000/tasks')\n        .then(response => response.json())\n        .then(responseJSON =>\n            TaskActions.fetchComplete(dispatch)(Immutable.List(responseJSON)))\n        .catch(TaskActions.fetchError(dispatch)); };\n// ... const mapDispatchToProps = dispatch => ({\nfetchTasks: () => fetchTasks(dispatch),\n  addTask: TaskActions.addTask(dispatch)\n});  \n```", "```jsx\nyarn add redux-thunk\n```", "```jsx\n// src / Chapter 6 / Example 4 / src / data / AppStore.js\nimport { combineReducers, createStore, applyMiddleware } from 'redux'; import thunk from 'redux-thunk';  // ... const store = createStore(rootReducer, applyMiddleware(thunk));  \n```", "```jsx\n// src / Chapter 6 / Example 5 / src / App.js\nexport const fetchTasks = (dispatch, getState) => {\n    if (!getState().tasks.isLoading) {\n        // ...   }\n    return null; };\n// ... const mapDispatchToProps = dispatch => ({\n    fetchTasks: () => dispatch(fetchTasks),\n // ...\n});\n```", "```jsx\n// immediate calculation, x equals 3\nlet x = 1 + 2;\n\n// delayed calculation until function call, x is a thunk\nlet x = () => 1 + 2;\n```", "```jsx\nfunction createArrayIterator(array) {\n    var nextIndex = 0;    return {\n        next: function() {\n            return nextIndex < array.length ?\n                {value: array[nextIndex++], done: false} :\n                {done: true};\n  }\n    }; }\n```", "```jsx\nfunction* numberGenerator(numMax) {\n    for (let i = 0; i < numMax; i += 1) {\n        yield console.log(i);\n  }\n}\nconst threeNumsIterator = numberGenerator(3); // logs 0 threeNumsIterator.next(); // logs 1 threeNumsIterator.next(); // logs 2 threeNumsIterator.next(); // logs nothing, the returned object contains a key 'done' set to true\nthreeNumsIterator.next(); \n```", "```jsx\n// src / Chapter 6 / Example 6 / src / sagas / fetchTasks.js\nfunction* fetchTasks() {\n    const tasks = yield call(ApiFetch, 'tasks');\n  if (tasks.error) {\n        yield put(ActionCreators.fetchError(tasks.error));\n  } else {\n        const json = yield call([tasks.response, 'json']);\n  yield put(ActionCreators.fetchComplete(Immutable.List(json)));\n  }\n}\n\n// whereas ApiFetch is our own util function\n// you will want to make a separate file for it\n// and take care of environmental variables to determine right endpoint\nconst ApiFetch = path => fetch(`http://localhost:3000/${path}`)\n    .then(response => ({ response }))\n    .catch(error => ({ error }));\n```", "```jsx\n// src / Chapter 6 / Example 6 / src / sagas / fetchTasks.js\nfunction* watchLastFetchTasks() {\n    yield throttle(2000, TasksActionTypes.TASK_FETCH_START, fetchTasks); }\n```"]