["```jsx\nreduce(callback, [initialValue])\n```", "```jsx\nconst sumArrayElements = arr => arr.reduce((acc, elem) => acc+elem, 0);\nconsole.log(sumArrayElements([5,15,20])); // 40\n```", "```jsx\nconst numbers = [1, 2, 5, 7, 13]; const average = numbers.reduce(\n    (accumulator, currNumber, indexOfElProcessed, arrayWeWorkOn) => {\n        // Sum all numbers so far\n        const newAcc = accumulator + currNumber;\n  if (indexOfElProcessed === arrayWeWorkOn.length - 1) {\n            // if this is the last item, return average\n            return newAcc / arrayWeWorkOn.length;\n  }\n        // if not the last item, pass sum\n        return newAcc;\n  },\n  0 ); // average equals 5.6\n```", "```jsx\nconst onlyType1 = task => task.type === 1\n```", "```jsx\ntasks.filter(onlyType1)\n```", "```jsx\ntasks.reduce((acc,t) => onlyType1(t) ? [...acc, t] :acc, [])\n```", "```jsx\nconst someFunc = x => x+1; const tab = [1, 5, 9, 13]; tab.reduce((acc, elem) => [...acc, someFunc(elem)], []);\n// result: [2, 6, 10, 14]\n```", "```jsx\nconst items = ['fork', 'laptop', 'fork', 'chair', 'bed', 'knife', 'chair']; items.reduce((acc, elem) => ({ ...acc, [elem]: (acc[elem] || 0) + 1 }), {});\n// {fork: 2, laptop: 1, chair: 2, bed: 1, knife: 1} \n```", "```jsx\nconst numCollections = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; numCollections.reduce((acc, collection) => [...acc, ...collection], []);\n// result:[1, 2, 3, 4, 5, 6, 7, 8, 9] \n```", "```jsx\nclass FibonacciIterator {\n    constructor() {\n        this.n1 = 1;\n  this.n2 = 1;\n  }\n    next() {\n        var current = this.n2;\n  this.n2 = this.n1;\n  this.n1 = this.n1 + current;\n  return current;\n  }\n}\n```", "```jsx\nconst fibNums = new FibonacciIterator(); fibNums.next(); // 1 fibNums.next(); // 1 fibNums.next(); // 2 fibNums.next(); // 3 fibNums.next(); // 5 \n```", "```jsx\n// Array is iterable by default,\n// we don't need to create a custom iterator,\n// just use the one that is present.\nconst alpha = ['a','b','c']; const it = alpha[Symbol.iterator]()**;**   it.next(); //{ value: 'a', done: false } it.next(); //{ value: 'b', done: false } it.next(); //{ value: 'c', done: false } it.next(); //{ value: undefined, done: true }\n```", "```jsx\nconst fib = {\n    [Symbol.iterator]() {\n        let n1 = 1;\n  let n2 = 1;    return {\n            next() {\n                const current = n2;\n  n2 = n1;\n  n1 += current;\n  return { value: current, done: false };\n  },    return(val) { // this part handles loop break\n                // Fibonacci sequence stopped.\n  return { value: val, done: true };\n  }\n        };\n  }\n};\n```", "```jsx\nfor (const num of fib) {\n    console.log(num);\n    if (num > 70) break; // We do not want to iterate forever\n}\n```", "```jsx\nconst a = function* gen() { yield \"a\"; }; console.log(a.prototype)\n// Generator {}\n```", "```jsx\nfunction* fib() {\n    let n1 = 1;\n  let n2 = 1;\n  while (true) {\n        const current = n2;\n  n2 = n1;\n  n1 += current;    yield current;   }\n}\n// Pay attention to invocation of fib to get Generator\nfor (const num of fib()) {\n    console.log(num);\n  if (num > 70) break; }\n```", "```jsx\n// src/Chapter 8/Example 1/src/features/tasks/sagas/fetchTask.js\n// ^ fully functional example with TaskDetails page\nexport **function*** fetchTask(action) {\n    const task = yield call(apiFetch, `tasks/${action.payload.taskId}`);\n  if (task.error) {\n        yield put(ActionCreators.fetchTaskError(task.error));\n  } else {\n        const json = yield call([task.response, 'json']);\n  yield put(ActionCreators.fetchTaskComplete(json));\n  }\n}\n```", "```jsx\nfunction* watchFirstThreeTasksCreation() {\n    for (let i = 0; i < 3; i++) {\n        const action = yield take(TasksActionTypes.ADD_TASK)\n    }\n    yield put({type: 'SHOW__THREE_TASKS_CONGRATULATION'})\n}\n```", "```jsx\nconst mapStateToProps = state => ({\n    tasks: state.tasks.get('entities'),\n  isLoading: state.tasks.get('isLoading'),\n  hasError: state.tasks.get('hasError'),\n  errorMsg: state.tasks.get('errorMsg')\n});\n```", "```jsx\n// On this page we don't know if tasks are already fetched\nconst mapStateToProps = (state, ownProps) => ({\n    task: state.tasks\n  ? state.tasks\n  .get('entities')\n            .find(task => task.id === ownProps.taskId)\n        : null }); \n```", "```jsx\n// src/Chapter 8/Example 1/src/features/\n//                         ./tasks/containers/TaskListContainer.js\nconst mapStateToProps = state => ({\n    tasks: tasksEntitiesSelector(state),\n  isLoading: tasksIsLoadingSelector(state),\n  hasError: tasksHasErrorSelector(state),\n  errorMsg: tasksErrorMsgSelector(state)\n}); \n```", "```jsx\n// src/Chapter 8/Example 2/src/features/\n//                      ./tasks/state/selectors/tasks.js  export const tasksSelector = state => state.tasks;   export const tasksEntitiesSelector = state =>\n (tasksSelector(state) ? tasksSelector(state).get('entities') : null);   export const tasksIsLoadingSelector = state =>\n (tasksSelector(state) ? tasksSelector(state).get('isLoading') : null);   export const tasksHasErrorSelector = state =>\n (tasksSelector(state) ? tasksSelector(state).get('hasError') : null);   export const tasksErrorMsgSelector = state =>\n (tasksSelector(state) ? tasksSelector(state).get('errorMsg') : null);\n\n// PS: I have refactored the rest of the app to selectors too. \n```", "```jsx\nyarn add reselect\n```", "```jsx\n// src/Chapter 8/Example 2/src/features/\n//                                ./tasks/state/selectors/tasks.js\nimport { createSelector } from 'reselect';   export const tasksSelector = state => state.tasks;   export const tasksEntitiesSelector = createSelector(\n    tasksSelector,\n  tasks => (tasks ? tasks.get('entities') : null)\n); \n// ... rest of the selectors in similar fashion\n```", "```jsx\n**withLogger**(**withAnalytics**(**withRouter**(SomeComponent))) \n```", "```jsx\nR.compose(withLogger,withAnalytics, withRouter)(SomeComponent)\n```", "```jsx\nconst myHoc = SomeComponent => R.compose(withLogger,withAnalytics, withRouter)(SomeComponent)\n```", "```jsx\nconst myHoc = R.compose(withLogger,withAnalytics, withRouter) \n```", "```jsx\nconst TaskNamesList  = tasks => tasks\n    .map({ name }) => (\n        <View><Text>{name}</Text></View>   ))\n```", "```jsx\nconst TaskComponent  = name => (<View><Text>{name}</Text></View>)\n\nconst TaskNamesList = compose(\n    map(TaskComponent),\n  map(prop('name')) // prop function maps object to title key\n);\n```", "```jsx\nconst oldFunc = (x, y) => { // something }\n\nconst expected = x => y => { // something }\n```", "```jsx\nconst expected = x => y => oldFunc(x, y)\n```", "```jsx\nconst notCurriedFunc = (x, y, z) => x + y + z;\n  const curriedFunc = R.curry(notCurriedFunc);\n\n// Usage: curriedFunc(a)(b)(c)\n// or shorter: R.curry(notCurriedFunc)(a)(b)(c)\n\n// So our case with partial application could be:\nconst first = R.curry(notCurriedFunc)(a)(b);\n// ... <pass it somewhere else where c will be present> ...\nconst final = first(c)\n```", "```jsx\nconst someFunc = x => y => z => x + y + z;\n\nconst someFuncYFirst = R.flip(someFunc);\n// equivalent to (y => x => z => x + y + z;)\n```", "```jsx\nconst someFuncReverseArgs = z => y => x => someFunc(x, y, z);\n```"]