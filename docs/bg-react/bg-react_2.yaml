- en: Creating Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: In this chapter, we are going to learn how to implement React components, how
    to assemble multiple components into one, and how to manage their internal states.
    We will explore React component implementation by building a simple application.
    This application will be implemented step-by-step, in order to put the outlined
    concepts into practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何实现 React 组件，如何将多个组件组合成一个，以及如何管理它们的内部状态。我们将通过构建一个简单的应用程序来探索 React
    组件的实现。这个应用程序将逐步实现，以便将概述的概念付诸实践。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Create basic React components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的 React 组件
- en: Use JSX to define a component's markup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSX 来定义组件的标记
- en: Combine multiple React components in order to create complex UI elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合多个 React 组件以创建复杂的 UI 元素
- en: Manage the internal state of React components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 React 组件的内部状态
- en: Definition of a Component
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件定义
- en: As defined in the previous chapter, components are the fundamental building
    blocks of React. Virtually any visual item in a user interface can be a component. From
    a formal point of view, we would say that a React component is a piece of JavaScript
    code defining a portion of a user interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所定义，组件是 React 的基本构建块。用户界面中的几乎任何视觉项都可以是一个组件。从正式的角度来看，我们会说一个 React 组件是一段定义用户界面一部分的
    JavaScript 代码。
- en: 'Consider the following code in a file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码文件：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an ECMAScript 2015 module, defining a basic React component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 ECMAScript 2015 模块，定义了一个基本的 React 组件。
- en: It imports the `React` namespace from the `react` module and defines the `Catalog` class
    by extending the `React.Component` class. The module exports the `Catalog` class
    as a default export.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它从 `react` 模块导入 `React` 命名空间，并通过扩展 `React.Component` 类来定义 `Catalog` 类。该模块将 `Catalog`
    类作为默认导出。
- en: The interesting part of this definition is the implementation of the `render()`
    method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义的有趣之处在于 `render()` 方法的实现。
- en: 'The `render()` method defines the visual part of the component. It may execute
    any JavaScript code, and it should return a markup expression defining its visual
    output. The presence of the `render()` method is mandatory for React components. In
    our example, the `render()` method returns the following markup:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 方法定义了组件的视觉部分。它可以执行任何 JavaScript 代码，并应返回一个定义其视觉输出的标记表达式。`render()`
    方法对于 React 组件是强制性的。在我们的示例中，`render()` 方法返回以下标记：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It looks like HTML; although it uses similar syntax, it defines plain objects
    called **elements**. React elements are similar to **Document Object Model** (**DOM**)
    elements, but are lighter and more efficient. So, React components generate a
    set of React elements that will be mapped to DOM elements by the library's engine.
    This set of React elements is called the **Virtual DOM**, a lightweight representation
    of the browser's DOM. React takes care of updating the DOM to match the Virtual
    DOM, only when it is strictly necessary. This approach allows React to have very
    high performance when rendering user interfaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像 HTML；尽管它使用类似的语法，但它定义了称为 **元素** 的普通对象。React 元素类似于 **文档对象模型** (**DOM**)
    元素，但更轻便且更高效。因此，React 组件生成一组将由库引擎映射到 DOM 元素的 React 元素。这组 React 元素称为 **虚拟 DOM**，是浏览器
    DOM 的轻量级表示。React 负责更新 DOM 以匹配虚拟 DOM，仅在严格必要时进行。这种方法使得 React 在渲染用户界面时具有非常高的性能。
- en: 'The `render()` method must comply with a few constraints:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 方法必须遵守一些约束：'
- en: It is mandatory; that is, every React component must implement it
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是强制性的；也就是说，每个 React 组件都必须实现它
- en: It must return one React element; that is, a single markup item with any nested
    elements
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须返回一个 React 元素；也就是说，一个带有任何嵌套元素的单个标记项
- en: It should be a pure function; that is, it should not change the internal state of
    the component (we will discuss this topic in further detail in the next section)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是纯函数；也就是说，它不应该改变组件的内部状态（我们将在下一节详细讨论这个话题）
- en: It should not directly interact with the browser; that is, it shouldn't contain statements
    that try to access the DOM
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不应该直接与浏览器交互；也就是说，它不应该包含试图访问 DOM 的语句
- en: A pure function is a function whose output result depends only on its input data,
    and its execution has no side effect, like, for example, updating a global variable.
    Given an input value, a pure function always returns the same result.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是指其输出结果仅依赖于输入数据，且执行过程中没有副作用，例如，不会更新全局变量。给定一个输入值，纯函数总是返回相同的结果。
- en: A pure component is a component that acts like a pure function. This means that,
    given the same initial conditions, it always renders the same output. It is very
    important to keep the `render()` method a pure function. This avoids weird bugs,
    as we will see in the next chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 纯组件是一种像纯函数一样工作的组件。这意味着，给定相同的初始条件，它总是渲染相同的输出。保持`render()`方法为纯函数非常重要。这样可以避免我们在下一章中看到的奇怪的错误。
- en: 'Once we have defined our component, we can use it as a React element inside
    any other React component. For example, we know that the React application itself
    is already a React component. Let''s recall the code generated by the `create-react-app` tool
    in the `App.js` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了组件，我们就可以在任何其他React组件中将其作为React元素使用。例如，我们知道React应用程序本身已经是一个React组件。让我们回顾一下`create-react-app`工具在`App.js`文件中生成的代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that this code has the same structure as the `Catalog` component
    that we defined. Let''s change this code in order to use our component inside
    of the `App` component:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这段代码与我们所定义的`Catalog`组件具有相同的结构。让我们更改这段代码，以便在`App`组件内部使用我们的组件：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We simplified the code by removing some of the automatically generated markup. We
    then imported the `Catalog` component, and put the `<Catalog />` element inside the
    `<div>` element returned by the app's `render()` method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过删除一些自动生成的标记简化了代码。然后导入`Catalog`组件，并将`<Catalog />`元素放入应用程序`render()`方法返回的`<div>`元素中。
- en: Building Our First React Component
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个React组件
- en: 'The following steps open the existing project, `my-shop-01`, in order to show
    the result of the previous code changes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有项目`my-shop-01`，以展示之前代码更改的结果：
- en: Open a console window
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口
- en: Move to the `my-shop-1` folder
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-1`文件夹
- en: Run `npm install`
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`
- en: Run `npm start`
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`
- en: 'The following is an example of what we will see in a browser window:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在浏览器窗口中将看到的一个示例：
- en: '![](Images/888b626e-0f78-4346-9515-29ba28498237.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/888b626e-0f78-4346-9515-29ba28498237.png)'
- en: We have built our first React component, and we can see it in action!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了我们的第一个React组件，并且可以看到它在运行！
- en: Managing Styles
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理样式
- en: 'Perhaps you have noticed that we have an `import` statement concerning a CSS
    file in the `App` component module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您已经注意到，在`App`组件模块中有一个关于CSS文件的`import`语句：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This may seem a bit strange, since `import` statements should only work for
    JavaScript code. However, thanks to the development environment provided by `create-react-app`, we
    can use the same syntax, even for CSS files. This allows us to use the classes and
    other CSS definitions defined in `App.css` in our component, keeping component-specific styles
    close to the component definition itself. For example, if we want our `Catalog`
    component to have the title in red, we can proceed as shown next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，因为`import`语句应该只适用于JavaScript代码。然而，由于`create-react-app`提供的开发环境，我们甚至可以使用相同的语法，即使对于CSS文件也是如此。这允许我们在组件中使用`App.css`中定义的类和其他CSS定义，将组件特定的样式保持在组件定义本身附近。例如，如果我们想让`Catalog`组件的标题为红色，我们可以按照以下步骤进行。
- en: Adding CSS
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加CSS
- en: 'We will now change the content of the existing project, `my-shop-01`, in order
    to add some CSS code and show the catalog title in red:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更改现有项目`my-shop-01`的内容，以便添加一些CSS代码并将目录标题显示为红色：
- en: Open a console window.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口。
- en: Move to the `my-shop-1/src` folder.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-1/src`文件夹。
- en: 'Create a file, `Catalog.css`, and add the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件，`Catalog.css`，并添加以下代码：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open the `Catalog.js` file and add the statement to import the `Catalog.css` module,
    as shown here:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Catalog.js`文件并添加以下语句以导入`Catalog.css`模块：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run `npm start` and look at the result.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`并查看结果。
- en: You can find a project ready in the `my-shop-02` folder at `Code/Chapter-2`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Chapter-2`中的`my-shop-02`文件夹中找到一个准备好的项目。
- en: 'The browser will show the Catalog title in red:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将显示红色Catalog标题：
- en: '![](Images/2e2fe10c-32de-4a03-8f13-3a1ebfa19cc5.png)The CSS import is not a
    React feature, and it is not required by React. It is a convenience provided by
    the development environment, built by `create-react-app`. In particular, this
    feature is provided by **webpack**, one of the most frequently used bundlers and
    module loaders.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/2e2fe10c-32de-4a03-8f13-3a1ebfa19cc5.png)CSS导入不是React的特性，也不是React所必需的。它是开发环境提供的一种便利，由`create-react-app`构建。特别是，这个特性是由**webpack**提供的，**webpack**是最常用的打包器和模块加载器之一。'
- en: You should take this aspect into account when you want to migrate the application
    into a development environment not based on webpack.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将应用程序迁移到一个不基于webpack的开发环境时，应该考虑这一点。
- en: 'Activity: Defining a Shopping Cart'
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：定义购物车
- en: '**Scenario**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We need a shopping cart for our e-shop.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电子商店需要一个购物车。
- en: '**Aim**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to start using React to define a component.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是开始使用React定义一个组件。
- en: '**Steps for Completion**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: We should define a React component that acts as the basis of a shopping cart
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该定义一个作为购物车基础的React组件
- en: It should be a component that simply shows the string `Cart`
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该是一个仅显示字符串`Cart`的组件。
- en: Create a new React application by using `create-react-app`, and change the application,
    as shown in the current section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`create-react-app`创建一个新的React应用程序，并按照当前章节所示进行更改。
- en: '**Solution**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-01` folder at `Code/Chapter-2/`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案包含在`Code/Chapter-2/`下的`my-cart-01`文件夹中。
- en: Using JSX
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSX
- en: 'In previous examples, we defined the visual output returned by the `render()` method
    of a component by using an HTML-like markup expression. Let''s see, for example,
    the definition of the `Catalog` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用类似HTML的标记表达式定义了组件的`render()`方法返回的视觉输出。例如，让我们看看`Catalog`组件的定义：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The markup expression is not using JavaScript syntax, but it is included inside
    of a JavaScript code snippet. Why do we mix HTML and JavaScript syntaxes? How
    is that possible?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 标记表达式并未使用JavaScript语法，但它被包含在一个JavaScript代码片段内。我们为什么要混合HTML和JavaScript语法？这是如何实现的？
- en: Let's start by saying that the HTML-like language describing the React component's visual
    output is called **JSX**. This language extends JavaScript with XML expressions in
    order to simplify the creation of HTML elements within JavaScript code. You may think
    of it as a sort of `document.write("...")`, but much more powerful. In fact, when
    building a React application, the JSX markup is pre-processed by a specific parser,
    in order to produce pure JavaScript code. So, we can exploit the simplicity of
    using a declarative markup language that will automatically be converted into optimized
    JavaScript code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要说的是，描述React组件视觉输出的类似HTML的语言被称为**JSX**。这种语言通过在JavaScript代码中添加XML表达式来简化HTML元素的创建。你可以将其视为一种`document.write("...")`，但功能更强大。实际上，在构建React应用程序时，JSX标记由特定的解析器预处理，以生成纯JavaScript代码。因此，我们可以利用使用声明性标记语言的简单性，该语言将自动转换为优化的JavaScript代码。
- en: 'As previously mentioned, a JSX expression creates a React element, which is
    the counterpart of an HTML element. From a syntactical point of view, a JSX expression
    is a single markup item with any nested elements. So, the following is a valid
    JSX expression:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JSX表达式创建了一个React元素，它是HTML元素的对应物。从语法角度来看，JSX表达式是一个带有任何嵌套元素的单个标记项。因此，以下是一个有效的JSX表达式：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is not a valid JSX expression, since it contains two markup items:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下不是一个有效的JSX表达式，因为它包含两个标记项：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JSX expressions are XML fragments, so they are compliant with XML syntax rules.
    This means that, among other things, the markup is case-sensitive, and all of
    the tags must be closed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JSX表达式是XML片段，因此它们遵循XML语法规则。这意味着，除其他事项外，标记是区分大小写的，并且所有标签都必须关闭。
- en: 'For example, the following JSX expression is not valid:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下JSX表达式是无效的：
- en: '`<img src="image.png">`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`<img src="image.png">`'
- en: 'Its valid version is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 其有效版本如下：
- en: '`<img src="image.png"/>`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`<img src="image.png"/>`'
- en: 'We can assign a JSX expression to a variable, as in the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将JSX表达式赋值给一个变量，如下例所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also embed any JavaScript expression inside of a JSX expression by wrapping it
    in curly braces, as shown in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在JSX表达式中嵌入任何JavaScript表达式，方法是将其用大括号包裹，如下例所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of course, the JavaScript expression can be as complex as we need it to be,
    like in the following component definition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，JavaScript表达式可以像我们需要的那样复杂，如下面的组件定义所示：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In addition to optimizing output rendering, JSX also provides support to prevent
    injection attacks. In fact, any value embedded in a JSX expression escapes before
    being rendered. This, for example, prevents malicious code from being inserted
    by a user's input.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优化输出渲染，JSX还提供支持以防止注入攻击。实际上，任何嵌入JSX表达式的值在被渲染之前都会被转义。例如，这可以防止用户输入的恶意代码被插入。
- en: 'A common use of a combination of JavaScript and JSX expressions is called **conditional
    rendering**; that is, a technique that allows you to generate a JSX expression
    based on some Boolean conditions. Consider the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结合JavaScript和JSX表达式的常见用法称为**条件渲染**；也就是说，一种根据某些布尔条件生成JSX表达式的技术。考虑以下示例：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, the `render()` method returns one message or another, according
    to the current day of the week. This causes the generation of a React element
    with a different message and CSS class, but we could even return a completely
    different markup.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`render()`方法根据当前星期几返回一条不同的消息，这导致生成具有不同消息和CSS类的React元素，但我们甚至可以返回完全不同的标记。
- en: 'You can put a JSX expression in multiple lines, as in the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将JSX表达式放在多行中，如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It is very important when returning a JSX expression to start it in the same
    line of the `return` statement, as in the previous example. If you want to start
    the JSX expression on a new line, you need to enclose it in round brackets and
    put the left bracket on the same line as the `return` statement, as in the following
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回JSX表达式时，在`return`语句的同一行开始它非常重要，如前一个示例所示。如果您想在新行开始JSX表达式，则需要将其括在圆括号中，并将左括号放在与`return`语句相同的行上，如下所示：
- en: '`return (`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`return (`'
- en: '`  <div>`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`  <div>`'
- en: '`    <h2>Catalog</h2>`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`    <h2>Catalog</h2>`'
- en: '`  </div>);`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`  </div>);`'
- en: 'You can put comments inside of a JSX expression by using the JavaScript syntax wrapped
    in curly brackets. The following is an example of a JSX expression with comments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用JavaScript语法将注释放在JSX表达式中，用大括号括起来。以下是带有注释的JSX表达式的示例：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'JSX tags match HTML tags, which is why we can use the whole HTML syntax to define
    JSX elements. However, there are a few restrictions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JSX标签匹配HTML标签，这就是为什么我们可以使用整个HTML语法来定义JSX元素。但是，有一些限制：
- en: All HTML tags are in lowercase
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有HTML标签均为小写
- en: You need to use `className` instead of the `class` attribute
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要使用`className`而不是`class`属性
- en: You need to use `htmlFor` instead of the `for` attribute
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要使用`htmlFor`而不是`for`属性
- en: 'The following example shows the use of the `className` attribute instead of
    `class`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用`className`属性而不是`class`：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: JSX uses the `className` and `htmlFor` attributes instead of `class` and `for`
    because as JSX expressions are inside JavaScript, `class` and `for` could clash
    with the corresponding reserved keywords.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JSX使用`className`和`htmlFor`属性而不是`class`和`for`，因为JSX表达式在JavaScript内部，`class`和`for`可能与相应的保留关键字冲突。
- en: 'Activity: Translating HTML into JSX'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：将HTML转换为JSX
- en: '**Scenario**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: The Graphics department has provided you with an HTML snippet, and you need
    to translate it into JSX in order to create a React component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图形部门已向您提供了一个HTML片段，您需要将其翻译为JSX以创建React组件。
- en: '**Aim**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to understand the difference between HTML and JSX.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是了解HTML和JSX之间的区别。
- en: '**Steps for Completion**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Open the `Code02.txt` file
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Code02.txt`文件
- en: Transform the HTML code it contains into JSX
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含的HTML代码转换为JSX
- en: '**Solution**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `activity-b.html` file at `Code/Chapter-2/`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的解决方案是包含在`Code/Chapter-2/`中的`activity-b.html`文件。
- en: Composing Components
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: When defining React components, we can use them as the children of another component
    by using that component as a React element. We already saw this when we included
    the `Catalog` component inside of the `App` component, but let's analyze this
    composition further.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义React组件时，我们可以将它们用作另一个组件的子组件，方法是将其作为React元素使用。当我们包含`Catalog`组件在`App`组件内部时，我们已经看到了这一点，但是让我们进一步分析这种组合。
- en: Combining Components
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: 'We will now see how to combine components in order to create new, complex components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何组合组件以创建新的、复杂的组件：
- en: Open the `src/ProductList.js` file in the `my-shop-03` folder
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-shop-03`文件夹中打开`src/ProductList.js`文件
- en: Follow the text until the end of the section
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照文本直到本节结束
- en: 'Let''s consider the following component:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下组件：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This component defines a list of wines, names, and descriptions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件定义了酒名和描述的列表。
- en: 'We want to integrate our `Catalog` component with the wine list. Since we have created
    the `ProductList` component, we can use it as a tag in the JSX markup of the `Catalog`
    component, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的`Catalog`组件与酒单集成。由于我们已经创建了`ProductList`组件，因此我们可以将其用作`Catalog`组件的JSX标记中的标签，如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we simply imported the `ProductList` component in order to make
    it available inside the `Catalog` component's module, and we used the `ProductList`
    tag where we wanted the wine list to appear.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只需导入`ProductList`组件，以便在`Catalog`组件的模块中使其可用，并在我们希望酒单出现的地方使用`ProductList`标签。
- en: 'Run `npm start` to launch the application. The resulting page will look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm start`以启动应用程序。生成的页面将如下所示：
- en: '![](Images/772ab3c7-0d0d-49dc-b8cf-08cb9a057d5e.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/772ab3c7-0d0d-49dc-b8cf-08cb9a057d5e.png)'
- en: We said that the HTML tags in JSX expressions should always be in lowercase.
    However, we used the `ProductList` tag in Pascal case.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，JSX表达式中的HTML标签应该始终是小写的。然而，我们在Pascal case中使用了`ProductList`标签。
- en: Tags corresponding to components must follow the case used in the class definition,
    and by convention, component class names use Pascal case, even though it is not
    required by React.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于组件的标签必须遵循类定义中使用的案例，并且按照惯例，组件类名使用Pascal case，尽管这不是React所要求的。
- en: The ease of composing React components makes it very simple to create user interfaces,
    following the guidelines provided in the previous chapter. We can decompose a
    page layout into a hierarchical set of components, each one consisting of other
    components. This approach allows us to focus on the behavior of a single component,
    and promotes its reusability.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的组合简便性使得创建用户界面变得非常简单，遵循上一章提供的指导原则。我们可以将页面布局分解为一系列层次化的组件，每个组件又由其他组件组成。这种方法使我们能够专注于单个组件的行为，并促进其可重用性。
- en: 'Activity: Defining a Composed Cart'
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：定义一个组合的购物车
- en: '**Scenario**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We want to create some content for our shopping cart.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要为我们的购物车创建一些内容。
- en: '**Aim**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的**'
- en: The aim of this activity is to compose React components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的目的是组合React组件。
- en: '**Step for Completion**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Integrate the previously created `Cart` component in order to contain a `CartList` component,
    showing two items.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前创建的`Cart`组件整合，以便包含一个显示两个项目的`CartList`组件。
- en: '**Solution**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-02` folder at `Code/Chapter-2/`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的解决方案是包含在`Code/Chapter-2/`下的`my-cart-02`文件夹中的方案。
- en: Data Propagation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据传播
- en: 'The `ProductList` component that we defined in the previous section is impractical. Let''s
    take a look at it again:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductList`组件，我们在上一节中定义的，是不切实际的。让我们再次看看它：'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The list items are all defined as JSX markup, so if you need to change the graphical appearance
    of the catalog's product, you need to change all of the occurrences of each `<li>`
    element.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项都是作为JSX标记定义的，因此，如果您需要更改目录产品的图形外观，则需要更改每个`<li>`元素的所有出现位置。
- en: 'We can make a better implementation by going further in the user interface decomposition.
    We can consider each list item as a component, and the `Product` component as
    the one defined by the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进一步分解用户界面来实现更好的实现。我们可以将每个列表项视为一个组件，并将`Product`组件视为以下代码定义的组件：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code acts as a template for each list item, so that we can build our product
    list dynamically, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码作为每个列表项的模板，以便我们可以动态构建我们的产品列表，如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see the definition of an array of objects, `products`, containing the
    relevant data for each product. The second array, `productComponents`, will contain
    the list of React components created by merging product data with the `Product`
    component's markup. The `for` loop is intended to perform such merging. Finally,
    the resulting `productComponents` array, surrounded by the `<ul>` element, will
    be returned.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个对象数组的定义，`products`，包含每个产品的相关数据。第二个数组，`productComponents`，将包含由合并产品数据与`Product`组件的标记创建的React组件列表。`for`循环旨在执行此类合并。最后，将返回包围在`<ul>`元素中的结果`productComponents`数组。
- en: Even if the code structure appears to be correct, the result will not be as
    expected. In fact, we will obtain a list of items with the fixed names and descriptions
    that we put in the `Product` component definition. In other words, the merge between
    data and component definition didn't happen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码结构看起来是正确的，结果也不会如预期。实际上，我们将得到一个具有固定名称和描述的项列表，这些名称和描述是我们放在`Product`组件定义中的。换句话说，数据与组件定义的合并没有发生。
- en: 'Actually, we need a way to pass the data of each product to the `Component`
    class. Let''s think of React components as plain JavaScript functions. They may
    be implemented as functions returning React elements, and, as with any function,
    components may have data input. Such data input is passed through JSX attributes,
    and is accessible inside of a component through a special object called `**props**`.
    Let''s change the `ProductList` component''s code in order to pass data through
    JSX attributes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们需要一种方法将每个产品的数据传递给`Component`类。让我们将React组件视为普通的JavaScript函数。它们可以实现为返回React元素的函数，并且，与任何函数一样，组件可以有数据输入。这种数据输入通过JSX属性传递，并且可以在组件内部通过一个特殊的对象`**props**`访问。让我们更改`ProductList`组件的代码，以便通过JSX属性传递数据：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We added an `item` attribute to the `<Product>` tag and assigned a single object
    from the `products` array to it. This allows us to pass the data of each product
    to the `Product` component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`<Product>`标签上添加了一个`item`属性，并将`products`数组中的单个对象分配给它。这允许我们将每个产品的数据传递给`Product`组件。
- en: 'On the other hand, we modify the `Product` component''s code in order to receive
    and manage the passed data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们修改了`Product`组件的代码，以便接收和管理传递的数据：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can find a project ready in the `my-shop-04` folder at `Code/Chapter-2/`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Code/Chapter-2/my-shop-04`文件夹中找到一个准备好的项目。
- en: Every React component has a `props` property. The purpose of this property is to
    collect data input passed to the component itself. Whenever a JSX attribute is attached
    to a React element, a property with the same name is attached to the `props` object.
    So, we can access the passed data by using the attached property. In our example,
    we found the product data passed via the `item` attribute mapped to the `this.props.item`
    property.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个React组件都有一个`props`属性。这个属性的目的是收集传递给组件本身的数据输入。每当将JSX属性附加到React元素时，具有相同名称的属性就会附加到`props`对象上。因此，我们可以通过使用附加的属性来访问传递的数据。在我们的例子中，我们找到了通过`item`属性传递的产品数据映射到`this.props.item`属性。
- en: '`props` are immutable; that is, they are read-only properties.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`props`是不可变的；也就是说，它们是只读属性。'
- en: This new implementation allows the catalog to be shown as before, but makes graphical
    markup independent from a product's data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的实现方式允许目录像以前一样显示，但使图形标记独立于产品的数据。
- en: In a component hierarchy, data propagation is very important. It allows us to think
    about components as functions with inputs and outputs. In addition, the immutability
    of `props` allows us to think of components as pure functions, which are functions
    that have no side effects (since they don't change their input data). We can think
    of data passing from one component to another as a **unidirectional data ****flow**,
    from the parent component toward the child components. This gives us a more controllable
    system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件层次结构中，数据传播非常重要。它允许我们将组件视为具有输入和输出的函数。此外，`props`的不变性允许我们将组件视为纯函数，这些函数是没有副作用的函数（因为它们不改变其输入数据）。我们可以将从一个组件到另一个组件的数据传递视为**单向数据流**，从父组件流向子组件。这为我们提供了一个更可控的系统。
- en: 'The following diagram shows how we would imagine the data propagation in a component
    hierarchy, ideally:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了我们如何理想地想象组件层次结构中的数据传播：
- en: '![](Images/4e8e2c52-6d4e-4ebc-969a-497971c28dfb.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4e8e2c52-6d4e-4ebc-969a-497971c28dfb.png)'
- en: A change in the state causes a data propagation toward the child components
    through the `props` property.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的变化会导致数据通过`props`属性向子组件传播。
- en: 'Activity: Creating a Cart Item Component'
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：创建购物车项组件
- en: '**Scenario**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We want to make the `CartList` component a dynamic component, so that it can adapt
    its content to received data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将`CartList`组件变为一个动态组件，以便它能够根据接收到的数据调整其内容。
- en: '**Aim**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to compose React components and pass data between them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的目的是组合React组件并在它们之间传递数据。
- en: '**Steps for Completion**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Create a `CartItem` component showing the name of an item.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示商品名称的`CartItem`组件。
- en: Change the previously created `CartList` component so that it is dynamically composed
    of `CartItem` instances, based on an `items` array.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改之前创建的`CartList`组件，使其根据`items`数组动态地由`CartItem`实例组成。
- en: '**Solution**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-03` folder at `Code/Chapter-2`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是包含在`Code/Chapter-2/my-cart-03`文件夹中的那个。
- en: Managing the Internal State
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理内部状态
- en: Components have the ability to store data that can change over time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 组件具有存储随时间变化的数据的能力。
- en: 'When a component shows data that can change over time, we want changes to be shown
    as soon as possible. For example, consider the `ProductList` component: it shows
    a list of products contained in the `products` array. If a new product is added to
    the array, we want it to be shown immediately. React provides a mechanism to support
    the automatic rendering of a component when data changes. Such a mechanism is
    based on the concept of **state**.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件显示随时间变化，的数据时，我们希望尽快显示更改。例如，考虑`ProductList`组件：它显示`products`数组中的产品列表。如果向数组添加新产品，我们希望它立即显示。React提供了一种机制来支持数据变化时组件的自动渲染。这种机制基于**状态**的概念。
- en: React `state` is a property that represents data that changes over time. Every component
    supports the `state` property, but it should be used carefully.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: React `state`是一个代表随时间变化的数据的属性。每个组件都支持`state`属性，但应谨慎使用。
- en: 'Again, consider the `ProductList` component:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑`ProductList`组件：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From a practical point of view, it is not so useful. It shows a hardcoded list
    of products. If we want to add a new product, we need to make changes to the component
    source code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从实用的角度来看，这并不那么有用。它显示了一个硬编码的产品列表。如果我们想添加新产品，我们需要修改组件源代码。
- en: 'In a real-world scenario, we want to keep the component''s code independent
    from the product data. For example, we would get product data by making an HTTP request
    to the web server. In this case, the `products` array would represent data that changes
    over time: initially an empty array, it would then be filled with product data received
    from the server, and it could be changed again by subsequent requests to the server.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界场景中，我们希望保持组件代码独立于产品数据。例如，我们会通过向Web服务器发出HTTP请求来获取产品数据。在这种情况下，`products`数组代表随时间变化，的数据：最初是一个空数组，然后会填充从服务器接收的产品数据，并且可以通过后续对服务器的请求再次更改。
- en: Components that store data that can change over time are said to be **stateful components**. A
    stateful component stores the state in the `this.state` property. To inform a component
    that the state has changed, you must use the `setState()` method. This method
    sets a new state for the component; it does not update it. Changes to the state trigger
    the component's rendering; that is, the automatic execution of the `render()` method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 存储随时间变化，的数据的组件被称为**有状态组件**。有状态组件将状态存储在`this.state`属性中。要通知组件状态已更改，必须使用`setState()`方法。此方法为组件设置新状态；它不更新它。状态的变化触发组件的渲染；即`render()`方法的自动执行。
- en: 'Let''s see how to manage the state by changing the `ProductList` component definition:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过更改`ProductList`组件定义来管理状态：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We added the constructor to the component. The constructor runs the superclass constructor
    and sets the initial state of the component to an object with the `products` property
    as an empty array.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向组件添加了构造函数。构造函数运行超类构造函数，并将组件的初始状态设置为具有`products`属性的空数组的对象。
- en: Then, send a GET HTTP request to the server via `fetch()`. Since the request
    is asynchronous, the initial rendering of the component will be an empty list
    of products.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过`fetch()`向服务器发送GET HTTP请求。由于请求是异步的，组件的初始渲染将是一个空的产品列表。
- en: State initialization is the only case where you can assign a value to the `this.state`
    property without using `setState()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 状态初始化是唯一可以不使用`setState()`而直接给`this.state`属性赋值的情况。
- en: When the HTTP response is received, it is used to change the component's state
    with `setState()`. This state change causes the automatic execution of `render()`,
    which will show the list of products received from the server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到HTTP响应时，它用于通过`setState()`更改组件的状态。这种状态变化导致`render()`的自动执行，这将显示从服务器接收的产品列表。
- en: 'Now that we know how to manage the component''s state, here are a couple of
    things to remember when using the `setState()` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何管理组件的状态，那么在使用`setState()`方法时，有几点需要记住：
- en: '`setState()` merges new data with old data already contained in the state, and
    overwrites the previous state'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setState()`将新数据与状态中已有的旧数据合并，并覆盖先前的状态。'
- en: '`setState()` triggers the execution of the `render()` method, so you should never
    call `render()` explicitly'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setState()`触发`render()`方法的执行，因此您永远不应该显式调用`render()`。'
- en: Component state management appears to be very simple. However, it is easy to
    get in trouble when deciding what should be considered state and which component
    should be stateful.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态管理看似非常简单。然而，在决定什么应该被视为状态以及哪个组件应该是有状态的时，很容易陷入困境。
- en: 'Here is some advice about state:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于状态的一些建议：
- en: State should contain the minimum data needed to represent data that can change
    over time in your UI; any information that can be derived from this minimal data
    should be computed inside the `render()` method
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态应包含UI中随时间变化，所需的最小数据；任何可以从这些最小数据中推导出的信息都应在`render()`方法内部计算。
- en: State should be avoided as much as possible, since it adds complexity to a component
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应尽可能避免使用状态，因为它会给组件增加复杂性。
- en: Stateful components should be located high up in the component hierarchy of
    a UI
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态的组件应该位于UI组件层次结构的高层。
- en: We can consider the last piece of advice a consequence of the second piece of advice.
    If we should restrict the usage of state, we should reduce the number of stateful
    components. So, it is a good rule to assign the role of stateful component to
    components that are the root of a component hierarchy in a user interface. Do you
    remember the classification of components into presentational and container components,
    which we discussed in the previous chapter? In general, container components are
    good candidates for stateful components.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将最后一条建议视为第二条建议的后果。如果我们应该限制使用状态，我们应该减少有状态组件的数量。因此，将状态组件的角色分配给用户界面中组件层次结构的根组件是一个很好的规则。你还记得我们在上一章中讨论的将组件分为展示组件和容器组件的分类吗？通常，容器组件是有状态组件的良好候选者。
- en: 'In our example application, we assigned the role of a stateful component to
    the `ProductList` component. Even if it is a container component, it is not the
    highest in the component hierarchy of the application. Maybe this role would be
    more appropriate for the `Catalog` component. In this case, we should move the
    logic of getting data inside of the `Catalog` component, as shown in the following
    code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们将有状态组件的角色分配给了`ProductList`组件。即使它是一个容器组件，它也不是应用程序组件层次结构中最高的。也许这个角色更适合`Catalog`组件。在这种情况下，我们应该将获取数据的逻辑移到`Catalog`组件内部，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can find a project ready in the `my-shop-05` folder at `Code/Chapter-2`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Code/Chapter-2`下的`my-shop-05`文件夹中找到一个准备好的项目。
- en: 'Activity: Adding State Management to the Cart Component'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：向购物车组件添加状态管理。
- en: '**Scenario**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: In order to make the `Cart` component production ready, we add state management and
    dynamic data loading.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Cart`组件准备好投入生产，我们添加了状态管理和动态数据加载。
- en: '**Aim**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to become familiar with component state management.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的目的是熟悉组件状态管理。
- en: '**Step for Completion**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Change the previously created `Cart` component to add state management, so that data
    is loaded via HTTP requests, and the contents of the cart is automatically updated.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前创建的`Cart`组件更改为添加状态管理，以便通过HTTP请求加载数据，并且购物车的内容会自动更新。
- en: '**Solution**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-04` folder at `Code/Chapter-2/`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案包含在`Code/Chapter-2/`下的`my-cart-04`文件夹中。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we started to create React components and explored their basic features.
    In particular, we:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始创建React组件并探索它们的基本功能。特别是，我们：
- en: Learned how to define a component as a class derived from `React.Component`,
    and how to import specific CSS styles
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了如何将组件定义为从`React.Component`派生的类，以及如何导入特定的CSS样式。
- en: Explored the syntax of JSX, which allows us to quickly define the graphical aspect
    of a component and use React components that were defined elsewhere
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了JSX语法，它允许我们快速定义组件的图形方面，并使用在其他地方定义的React组件。
- en: Combined React components in order to build other components
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合React组件以构建其他组件。
- en: Used state management features so that React components automatically update
    their visual representation when data changes
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态管理功能，以便React组件在数据变化时自动更新其视觉表示。
- en: In the next chapter, we will analyze how to manage user interaction with a React-based
    application; in other words, how to capture events and make a UI react to those events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将分析如何管理用户与基于React的应用程序的交互；换句话说，如何捕获事件并使UI对这些事件做出反应。
