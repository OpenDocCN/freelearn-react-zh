- en: Managing User Interactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to manage the events generated by
    a user's interaction with the components of a React-based user interface. We will
    explore the events that are triggered during the lifecycle of a React component,
    and will learn how to exploit them in order to create efficient components. Finally,
    we will use the React Router library to allow easy navigation between the different
    views implemented by components.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle events generated by user interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change a component's state on event triggering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a component's lifecycle events for a better user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure routing to allow navigation through components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing User Interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any web application requires interaction between the user and the **user interface** (**UI**).
    An application without interaction is not a true application; interactivity is
    a basic requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The application that we built in the previous chapter does not allow interaction.
    It simply shows data, and the user cannot do anything with it (apart from look
    at it).
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to introduce a little interaction into the catalog application
    that we started building in the previous chapter. For example, perhaps we want
    to show an alert with the price of the product when the user clicks on the product
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided that the product data includes the price, as in the following JSON
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement this behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the component's code and highlight the differences with respect
    to the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we added the `showPrice()` method, showing the price of the current product
    instance via an alert. This method is invoked inside of an arrow function assigned
    to the `onClick` attribute of the `<li>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: These simple changes allow the `Product` component to capture the `click` event
    and execute the `showPrice()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now open the existing project, `my-shop-01`, in order to show the result
    of the previous code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-01` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result of clicking on a product is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4f5a555a-4d0e-43e1-ad83-5f723cf29071.png)'
  prefs: []
  type: TYPE_IMG
- en: HTML Events versus React Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see, the React approach to handling events is very similar to classic
    event management within HTML. However, there are some subtle differences to take
    into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML events are named using lowercase, while JSX events use camelCase. For example,
    in HTML, you should use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But in JSX, you use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In HTML, you assign a string representing the invocation of a function, while
    in JSX, you assign a function, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can assign any JavaScript expression returning or representing
    a function, like the one shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can prevent the default behavior of most HTML events by returning
    `false`, while in JSX events, you need to explicitly call `preventDefault`. The
    following is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Event Handlers and the this Keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example of defining a `Product` component, we assigned an arrow function
    to the `onClick` attribute, instead of the simple `showPrice()` method. This was
    not simply a matter of preference. It was necessary because we used the `this` keyword
    inside the `showPrice()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when the event handler executes, the `this` keyword is no longer bound
    to the `Product` class, since it is asynchronously executed in a different context.
    This behavior does not depend on React, but on how JavaScript works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to bind the method to the current class, we have a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use an arrow function and invoke the method inside its body, as shown in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `bind()` method to bind the method to the current class context, as shown
    in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `bind()` in the class constructor instead of using it inline when assigning
    the method to the event attribute. The following is an example of this approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Changing the State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event management example that we looked at is very simple, but it only shows the
    basics of React event management. This example does not involve the state, and
    its management is straightforward. In many real-world cases, an event causes changes
    to the application's state, and that means changes to the component's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that, for example, you want to allow the selecting of products from
    the catalog. To do so, we add the `selected` property to each product object,
    as shown in the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on the product area, the value of the `selected` property
    is toggled and the background color of the area changes. The following code snippet shows
    the new version of the `Product` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `select()` method toggles the value of the `selected` property, while in
    the rendering method, we calculate the name of the class to apply according to
    the value of the `selected` property. The resulting class name is then assigned
    to the `className` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unexpectedly, this code is not working correctly. You can verify it by performing
    the following steps. We can open the existing project, `my-shop-02`, in order
    to see the results of the previous code. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-02` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code is not working as expected because the `select()` method does not change
    the component's state, so the `render()` method is not triggered. In addition,
    keep in mind that the `props` property is read-only, so any change to it has no
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: The `Product` component is a stateless component, so we have no state to change here.
    The product's data comes from the `Catalog` root component via `props`. So, how can
    we change the `Catalog` component's state, starting from an event triggered at
    the `Product` component instance?
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, how can a child component change the state of its parent component?
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the child component has no opportunity to change the parent component''s state,
    because in a React component hierarchy, data flows in a unidirectional way, from
    the parent towards the children. We illustrate this flow in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e619f805-e32d-446c-9b2b-f9bd1d036e19.png)'
  prefs: []
  type: TYPE_IMG
- en: We cannot push data from the child to the parent. In order for a child component to
    change the state of a parent component, we need to get a method to act on that state.
    Since a component state is accessible only by the component itself, the parent component
    must provide that method to its children via the `props` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds the `select()` method to the `Catalog` component. This method
    takes a product code as an input parameter, gets the product list from the component's
    state, and updates the `selected` property of the corresponding product. It then
    updates the component's state with the new product list.
  prefs: []
  type: TYPE_NORMAL
- en: The `select()` method is assigned to the new `selectHandler` attribute in the `ProductList`
    tag, so the corresponding component can access it through the `props` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how `this.props.selectHandler` is passed from the `ProductList`
    component to the `Product` component via the `selectHandler` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Product` component handles the `onClick` events by calling the
    `select()` method passed via the `this.props.selectHandler` property with the
    appropriate product code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now open the existing project, `my-shop-03`, in order to see the results
    of the previous code. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-03` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can conclude that an event on a child component triggers the execution of
    a parent component method passed via `props`. The method changes the parent''s
    state, and the effect of this change is once again propagated to the children
    via `props`. The following diagram illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c5f36cd8-28ca-4ccb-a05b-7fd69497a78e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Activity: Adding Items to the Shopping Cart'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to allow the user to add items to the shopping cart by picking them
    from the product catalog.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to become familiar with event management in React.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the existing project in the `my-cart-01` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the click event of the `Product` component's Add to cart button in order
    to add that product to the cart
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-02` folder at `Code/Chapter-3/`.
  prefs: []
  type: TYPE_NORMAL
- en: Component Lifecycle Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a React application, components are created dynamically, according to the evolution
    of the application at runtime. A user's interaction starts a component's creation,
    its visualization, its updates on the screen, and its destruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, components go through different phases during application execution: these
    phases represent their lifecycles.'
  prefs: []
  type: TYPE_NORMAL
- en: React allows us to intercept and manage the phases of a component's lifecycle
    in a customized way, thanks to a set of events that we can handle by implementing specific
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Before analyzing a component's lifecycle events, we should highlight that the
    first step in creating a component is the execution of its constructor. Although
    it is not one of React's lifecycle phases, it is the first step of a component's
    life. During the component's constructor execution, the DOM is not available,
    and it is not possible to access any child component. The constructor execution
    is the right time to perform the initializations that don't concern graphic rendering
    or child manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After component creation, React will trigger a few events corresponding to
    the respective phases of the component''s lifecycle. We can catch these events
    and handle them by implementing a few methods in our component. Consider the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is executed when the component is about to be inserted into the
    DOM. It is invoked once, just before the initial rendering occurs. Usually, this
    method is used to perform any initialization of the component not involving the
    DOM, such as initializing values for a component's properties or local variables.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `setState()` method within `componentWillMount()`, but it will
    not trigger a re-render of the component, so use it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillReceiveProps` is the method invoked before rendering when a component
    receives new values from the parent via `props`. This method receives the new
    values as a parameter, and we can access the old values through `this.props`.'
  prefs: []
  type: TYPE_NORMAL
- en: If we try to change the component state during the execution of this method,
    we will not trigger any additional rendering. Additionally, `componentWillReceiveProps()`
    is not to be invoked upon initial rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The `shouldComponentUpdate` method should return a Boolean that states whether the
    component should be rendered (`true`) or not (`false`). If the method returns `false`,
    the next methods will not be invoked, including `render()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has two parameters: `nextProps`, containing the new values for the `props`,
    and `nextState`, containing the new value of the component''s state.'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillUpdate` is invoked immediately before the `render()` method,
    so it is the last opportunity to perform some processing before updating the component.'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use `setState()` within an implementation of `shouldComponentUpdate()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`componentDidUpdate` is invoked immediately after rendering occurs, and during
    its execution, we can access the new version of the component in the DOM. The
    method has two parameters: the previous `props` and the previous state.'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentDidMount` is called after the component is inserted into the DOM,
    and is invoked just once.'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillUnmount` is called immediately before the component is removed from
    the DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use `setState()` during the execution of this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can group the component lifecycle events into three main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mounting**: This `props` group contains the events related to DOM manipulation:
    `componentWillMount`, `componentDidMount`, and `componentWillUnmount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating via props**: This group contains the events that are triggered when
    a component is updated via `props` passed by its parent, and it includes: `componentWillReceiveProps`,
    `shouldComponentUpdate`, `componentWillUpdate`, and `componentDidUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating via setState()**: In this group, we find the events triggered when a
    component is updated via `setState()`: `shouldComponentUpdate`, `componentWillUpdate`,
    and `componentDidUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the event flow and highlights, with different
    colors, the three areas we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/77905891-cf29-46ca-a169-f0453358e90b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Activity: Showing the Quantity of Items Added to the Cart'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to avoid multiple occurrences of the same product in the cart. Rather,
    we want the cart to have a single occurrence of a product and its quantity, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c60ffc2b-daab-4b7b-be17-7fd2b6b772b0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to exploit the lifecycle events of React components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Utilize the project that was changed in the previous activity (or the existing project
    in the `my-cart-02` folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Cart` component in order to show a list of non-duplicated products
    and their related number of occurrences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the `componentWillReceiveProps` event to prepare data for the internal
    state of the `Cart` component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-03` folder at `Code/Chapter-3`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications, based on the Single-Page Application model, can't do without
    the routing mechanism, a way to navigate among views while remaining on the same
    HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: We can consider a view as a placeholder in the UI where we can dynamically render one
    component or another in an exclusive way. Let's try to clarify this concept with an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to add a navigation bar to our *Wine Catalog* application.
    In its simplest implementation, we want to alternatively show the Catalog and
    an About section, providing some information about the application itself. The
    new UI will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/73e59b33-0f9c-4a43-9024-556c5bca4ea7.png)'
  prefs: []
  type: TYPE_IMG
- en: When clicking a menu item, we expect the main area to change, while the header remains
    the same. In this case, the main area will be the view in which we display the
    `Catalog` component or the `About` component, depending on the menu item we clicked
    on.
  prefs: []
  type: TYPE_NORMAL
- en: How can we implement the routing mechanism in React?
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can enable routing in a React-based application by using **React Router**,
    a package that provides us with specific React components that allow us to set
    up a complete routing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We install that package in our application by typing the following command
    inside of the application''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'React Router provides three packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`react-router`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-router-dom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-router-native`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first package provides the core routing components and functionalities.
    The second one provides specific components for the browser environment, and the
    third one supports `react-native`, an environment that maps React components to
    native mobile UI widgets. Both `react-router-dom` and `react-router-native` use `react-router`
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have installed the React Router package in our environment, we need
    to use the provided components in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is add routing capabilities to our application.
    We can do this by changing the code of the `index.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We highlighted the main differences, with respect to the previous version of
    the code. As you can see, we imported the `BrowserRouter` component from the `react-router-dom`
    module and wrapped the `App` component inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: By wrapping the `App` component, the `BrowserRouter` component enriches it with routing
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: This is a component composition hence we have called this as component wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to create a view to display the `Catalog` component or the About
    page, as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9aded227-73da-4ec8-9c1d-a9109033be9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can accomplish this by changing the `App.js` code, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We imported the `Switch` and `Route` components from the `react-router-dom` module,
    and used them in the JSX expression where the `Catalog` element once was.
  prefs: []
  type: TYPE_NORMAL
- en: The `Switch` component allows us to define a view, that is, the area inside
    of which we will toggle components. The `Route` components are used as child elements
    of `Switch`, and they allow us to map URLs to components. In our example, we are mapping
    the root URL (`/`) to the `Catalog` component and the `/about` URL to the `About`
    component. This means that when the `BrowserRouter` intercepts the request to
    move to one of these URLs, it will render the appropriate component inside of
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation bar that allows us to display the catalog or the information
    about the application is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added the import of a `Link` component and used it in the highlighted markup.
    The `Link` component allows us to create a hyperlink element that will be caught
    by the `BrowserRouter` component.
  prefs: []
  type: TYPE_NORMAL
- en: These changes add a working navigation bar to our application. You can see the result
    of these changes by performing the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will open the existing project, `my-shop-04`, in order to show the results
    of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-04` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some Notes About the Route Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice that the `Route` component has the `path` attribute (which allows us
    to specify the URL to map) and the `component` attribute (which allows us to assign
    the component to render in the current view):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `path` attribute is used by React Router to detect the component to render,
    as specified by the corresponding `component` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous route mapping, if we click on a `Link` component associated
    with the `/about` URL, the route with the root (`/`) path will match the starting
    part of `/about`, and the `Catalog` component will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: When the user requests a URL by clicking on the `Link` component, the list of
    routes is scanned in order to find a path value that matches the starting part
    of the URL. The first matching value determines the component to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want a strict comparison between the `path` attribute''s value and the
    URL, we need to specify the exact attribute, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This prevents any URL starting with `/` from being captured by the first route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `component` attribute of the `Route` component allows us to specify the
    component to render. Alternatively, we can use the `render` attribute to specify
    the invocation of a function returning a React element, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This approach is similar to using the `component` attribute, but it may be useful
    for inline rendering and when we need to pass values to the element.
  prefs: []
  type: TYPE_NORMAL
- en: The `Route` component also allows us to specify the `children` attribute. As
    with `render`, we can assign a function to this attribute, but the elements returned
    by that function will *always* be rendered, regardless of whether the path matches
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Footer` component will always be rendered, even if the path `/footer` doesn't match.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we implemented view navigation in the `App` component by
    using the `Switch`, `Route`, and `Link` components provided by React Router. We can
    use these routing components inside of any other component so that we can build
    nested views and nested routes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to illustrate this with an example. Suppose that we want to add a
    list of winemakers to our application. We can add a new item to the navigation
    bar that allows us to navigate to a page showing that list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the new layout will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/27b9a00c-cc5f-4cf9-9130-728896366abe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s change the `App` component''s JSX markup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We imported the `WineMakers` component, defined a route that maps the `/winemakers`
    path to the new component, and added a link to navigate to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the list of winemakers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `WineMakers` component has the `renderWineMakersList()` method that returns
    the React element implementing a list of links to each winemaker. This method
    is used as the value of the `render` attribute of the route matching the `/winemakers`
    path in the `render()` method of the component. The other routes get the path
    pointing to each specific winemaker and render the `WineMaker` component according
    to the identifier code.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we are implementing a view in the `WineMakers` component
    that is shown inside of the view implemented in the `App` component. In other
    words, we implement nested views by composing components that implement views.
  prefs: []
  type: TYPE_NORMAL
- en: Path Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `render()` method of the `WineMakers` component implements the resulting
    view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code is straightforward, and it works, but it forces us to add a new route whenever
    a new winemaker is added to our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid this by using `path` parameters, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can now use a single route pointing to a specific winemaker
    by specifying a `:code` parameter. The colon in the path expression indicates
    that the following portion of the URL is a variable value. You may also notice
    that we used the `component` attribute instead of the `render` attribute. In fact,
    in this case, we do not need to explicitly pass the winemaker's code to the `WineMaker`
    component. React Router does it for us, by providing a special object in the `props`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `WineMaker` component implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the component's constructor, we define the list of winemakers as an array
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the `render()` method, we look for the winemaker to display by comparing
    the `code` property of each `winemaker` object in the array with the `match.params.code` property
    provided by `this.props`.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented the `winemakers` list as a property of the `WineMaker` component,
    and not as a property of the `state` object because since the list is embedded
    into the code and shouldn't change, we do not need to implement it as a `state`
    property. Remember that we only identify data that changes over time as a state.
  prefs: []
  type: TYPE_NORMAL
- en: The object we find is used to appropriately render the data about the `WineMaker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, a React component reached via a route receives the `match` object
    in the `this.props` property. This object contains information about the matching
    path in the `Route` definition. In particular, the following properties of the
    `match` object are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`params`: This is an object whose properties match the parameters in the path; that
    is, the dynamic parts, preceded by colons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isExact`: This is a Boolean indicating that the URL matches the path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: This is the string assigned to the `path` attribute of the selected
    route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: This is the URL that matches the route''s path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the final result by performing the following steps. We open the
    existing project, `my-shop-05`, in order to show the results of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a console window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the `my-shop-05` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Activity: Adding a View About Shipping Methods'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to add a section to our catalog app containing information about the available
    shipping methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to explore the components provided by React Routing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the project that was changed in the previous activity (or the existing project
    in the `my-cart-03` folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ShippingMethods` component, showing a list of available shipping methods,
    and a `ShippingMethod` component, showing the details of each shipping method,
    according to a code passed via `props` (available shipping methods include **Economic
    delivery** (**ECO**), **Standard delivery** (**STD**), and **Express delivery**
    (**EXP**)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a navigation bar and a routing configuration that allow us to navigate through
    the `Catalog` and `Shipping` method views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is the one contained in the `my-cart-04` folder at `Code/Chapter-3`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to manage user interaction. In particular,
    we have covered the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Managed events that don't involve changes to a component's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handled events that involve changes to a component's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored the component lifecycle and learned how to customize each phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used React Router's components to configure navigation between components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter concludes the book. It provided the basics for understanding how
    React works and how to build React-based applications. We started with an introduction
    to React and then explored creating components in detail. We finished with a look
    at how to manage user interactivity with React.
  prefs: []
  type: TYPE_NORMAL
