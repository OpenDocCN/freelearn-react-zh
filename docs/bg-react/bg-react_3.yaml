- en: Managing User Interactivity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户交互性
- en: In this chapter, we are going to learn how to manage the events generated by
    a user's interaction with the components of a React-based user interface. We will
    explore the events that are triggered during the lifecycle of a React component,
    and will learn how to exploit them in order to create efficient components. Finally,
    we will use the React Router library to allow easy navigation between the different
    views implemented by components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何管理由用户与React基础用户界面的组件交互产生的事件。我们将探讨在React组件生命周期中触发的事件，并学习如何利用它们来创建高效的组件。最后，我们将使用React
    Router库来允许在由组件实现的不同的视图之间轻松导航。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够：
- en: Handle events generated by user interaction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理由用户交互产生的事件
- en: Change a component's state on event triggering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件触发时更改组件的状态
- en: Use a component's lifecycle events for a better user experience
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件的生命周期事件以获得更好的用户体验
- en: Configure routing to allow navigation through components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置路由以允许通过组件进行导航
- en: Managing User Interaction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户交互
- en: Any web application requires interaction between the user and the **user interface** (**UI**).
    An application without interaction is not a true application; interactivity is
    a basic requirement.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Web应用程序都需要用户与**用户界面**（**UI**）之间的交互。没有交互的应用程序不是真正的应用程序；交互性是一个基本要求。
- en: The application that we built in the previous chapter does not allow interaction.
    It simply shows data, and the user cannot do anything with it (apart from look
    at it).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章构建的应用程序不允许交互。它只是显示数据，用户无法对其进行任何操作（除了查看）。
- en: Suppose that we want to introduce a little interaction into the catalog application
    that we started building in the previous chapter. For example, perhaps we want
    to show an alert with the price of the product when the user clicks on the product
    area.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在上一章开始构建的目录应用程序中引入一点交互。例如，也许我们想在用户点击产品区域时显示一个带有产品价格的警告。
- en: 'Provided that the product data includes the price, as in the following JSON
    object:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设产品数据包括价格，如下面的JSON对象所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can implement this behavior as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下实现这种行为：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's analyze the component's code and highlight the differences with respect
    to the previous version.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析组件的代码，并强调与前一个版本的不同之处。
- en: First of all, we added the `showPrice()` method, showing the price of the current product
    instance via an alert. This method is invoked inside of an arrow function assigned
    to the `onClick` attribute of the `<li>` tag.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了`showPrice()`方法，通过一个警告框显示当前产品实例的价格。这个方法在箭头函数内部被调用，该箭头函数被分配给`<li>`标签的`onClick`属性。
- en: These simple changes allow the `Product` component to capture the `click` event
    and execute the `showPrice()` method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的更改允许`Product`组件捕获`click`事件并执行`showPrice()`方法。
- en: 'We''ll now open the existing project, `my-shop-01`, in order to show the result
    of the previous code changes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将打开现有的项目`my-shop-01`，以展示之前的代码更改的结果：
- en: Open a console window
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口
- en: Move to the `my-shop-01` folder
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-01`文件夹
- en: Run `npm install`
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`
- en: Run `npm start`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`
- en: 'The result of clicking on a product is shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 点击产品的结果显示在以下截图中：
- en: '![](Images/4f5a555a-4d0e-43e1-ad83-5f723cf29071.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4f5a555a-4d0e-43e1-ad83-5f723cf29071.png)'
- en: HTML Events versus React Events
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML事件与React事件
- en: As we can see, the React approach to handling events is very similar to classic
    event management within HTML. However, there are some subtle differences to take
    into account.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，React处理事件的方法与HTML中的经典事件管理非常相似。然而，有一些细微的差别需要注意。
- en: 'HTML events are named using lowercase, while JSX events use camelCase. For example,
    in HTML, you should use the following syntax:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTML事件使用小写字母命名，而JSX事件使用驼峰命名法。例如，在HTML中，你应该使用以下语法：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But in JSX, you use this syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但在JSX中，你使用这种语法：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In HTML, you assign a string representing the invocation of a function, while
    in JSX, you assign a function, which is shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，你分配一个代表函数调用的字符串，而在JSX中，你分配一个函数，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Of course, you can assign any JavaScript expression returning or representing
    a function, like the one shown in the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以分配任何返回或代表函数的JavaScript表达式，如下例所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you can prevent the default behavior of most HTML events by returning
    `false`, while in JSX events, you need to explicitly call `preventDefault`. The
    following is a typical example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过返回`false`来阻止大多数HTML事件的默认行为，而在JSX事件中，您需要显式调用`preventDefault`。以下是一个典型示例：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Event Handlers and the this Keyword
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Event Handlers 和 this 关键字
- en: In the preceding example of defining a `Product` component, we assigned an arrow function
    to the `onClick` attribute, instead of the simple `showPrice()` method. This was
    not simply a matter of preference. It was necessary because we used the `this` keyword
    inside the `showPrice()` method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的定义`Product`组件的示例中，我们将箭头函数分配给了`onClick`属性，而不是简单的`showPrice()`方法。这不仅仅是一个偏好问题。这是必要的，因为我们使用了`showPrice()`方法内部的`this`关键字。
- en: In fact, when the event handler executes, the `this` keyword is no longer bound
    to the `Product` class, since it is asynchronously executed in a different context.
    This behavior does not depend on React, but on how JavaScript works.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当事件处理程序执行时，`this`关键字不再绑定到`Product`类，因为它是在不同的上下文中异步执行的。这种行为不依赖于React，而是依赖于JavaScript的工作方式。
- en: 'In order to bind the method to the current class, we have a few options:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将方法绑定到当前类，我们有几个选项：
- en: 'Use an arrow function and invoke the method inside its body, as shown in the following
    example:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头函数并在其体内调用方法，如下例所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the `bind()` method to bind the method to the current class context, as shown
    in the following example:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`bind()`方法将方法绑定到当前类上下文，如下例所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use `bind()` in the class constructor instead of using it inline when assigning
    the method to the event attribute. The following is an example of this approach:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在类构造函数中使用`bind()`，而不是在将方法分配给事件属性时内联使用。以下是这种方法的示例：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Changing the State
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改状态
- en: The event management example that we looked at is very simple, but it only shows the
    basics of React event management. This example does not involve the state, and
    its management is straightforward. In many real-world cases, an event causes changes
    to the application's state, and that means changes to the component's state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看过的这个事件管理示例非常简单，但它只展示了React事件管理的基础。这个示例不涉及状态，其管理是直接的。在许多现实世界的情况下，一个事件导致应用程序状态的变化，这意味着组件状态的变化。
- en: 'Suppose that, for example, you want to allow the selecting of products from
    the catalog. To do so, we add the `selected` property to each product object,
    as shown in the following array:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，您想允许从目录中选择产品。为此，我们为每个产品对象添加`selected`属性，如下面的数组所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the user clicks on the product area, the value of the `selected` property
    is toggled and the background color of the area changes. The following code snippet shows
    the new version of the `Product` component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击产品区域时，`selected`属性的值会切换，并且区域背景颜色会改变。以下代码片段展示了`Product`组件的新版本：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `select()` method toggles the value of the `selected` property, while in
    the rendering method, we calculate the name of the class to apply according to
    the value of the `selected` property. The resulting class name is then assigned
    to the `className` attribute.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()`方法切换`selected`属性的值，而在渲染方法中，我们根据`selected`属性的值计算要应用的类的名称。然后，生成的类名被分配给`className`属性。'
- en: 'Unexpectedly, this code is not working correctly. You can verify it by performing
    the following steps. We can open the existing project, `my-shop-02`, in order
    to see the results of the previous code. Follow these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地，这段代码没有正确工作。您可以通过执行以下步骤来验证。我们可以打开现有项目`my-shop-02`，以便查看之前代码的结果。请按照以下步骤操作：
- en: Open a console window
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口
- en: Move to the `my-shop-02` folder
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-02`文件夹
- en: Run `npm install`
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`
- en: Run `npm start`
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`
- en: The code is not working as expected because the `select()` method does not change
    the component's state, so the `render()` method is not triggered. In addition,
    keep in mind that the `props` property is read-only, so any change to it has no
    effect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码没有按预期工作，因为`select()`方法没有改变组件的状态，所以`render()`方法没有被触发。此外，请记住`props`属性是只读的，因此对其的任何更改都不会产生影响。
- en: The `Product` component is a stateless component, so we have no state to change here.
    The product's data comes from the `Catalog` root component via `props`. So, how can
    we change the `Catalog` component's state, starting from an event triggered at
    the `Product` component instance?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`组件是一个无状态组件，因此我们没有状态需要改变。产品的数据来自通过`props`传递的`Catalog`根组件。那么，我们如何从`Product`组件实例触发的事件开始改变`Catalog`组件的状态呢？'
- en: Specifically, how can a child component change the state of its parent component?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，子组件如何改变其父组件的状态？
- en: 'Actually, the child component has no opportunity to change the parent component''s state,
    because in a React component hierarchy, data flows in a unidirectional way, from
    the parent towards the children. We illustrate this flow in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，子组件没有机会改变父组件的状态，因为在React组件层次结构中，数据以单向方式流动，从父组件流向子组件。我们在下面的图表中说明了这种流动：
- en: '![](Images/e619f805-e32d-446c-9b2b-f9bd1d036e19.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e619f805-e32d-446c-9b2b-f9bd1d036e19.png)'
- en: We cannot push data from the child to the parent. In order for a child component to
    change the state of a parent component, we need to get a method to act on that state.
    Since a component state is accessible only by the component itself, the parent component
    must provide that method to its children via the `props` property.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将数据从子组件推送到父组件。为了让子组件改变父组件的状态，我们需要获取一个方法来操作该状态。由于组件状态只能由组件本身访问，因此父组件必须通过`props`属性向其子组件提供该方法。
- en: 'Consider the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code adds the `select()` method to the `Catalog` component. This method
    takes a product code as an input parameter, gets the product list from the component's
    state, and updates the `selected` property of the corresponding product. It then
    updates the component's state with the new product list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将`select()`方法添加到`Catalog`组件中。该方法接受一个产品代码作为输入参数，从组件的状态中获取产品列表，并更新相应产品的`selected`属性。然后使用新的产品列表更新组件的状态。
- en: The `select()` method is assigned to the new `selectHandler` attribute in the `ProductList`
    tag, so the corresponding component can access it through the `props` property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()`方法被分配给`ProductList`标签中的新`selectHandler`属性，因此相应的组件可以通过`props`属性访问它。'
- en: 'The following code shows how `this.props.selectHandler` is passed from the `ProductList`
    component to the `Product` component via the `selectHandler` attribute:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何将`this.props.selectHandler`从`ProductList`组件传递到`Product`组件，通过`selectHandler`属性：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the `Product` component handles the `onClick` events by calling the
    `select()` method passed via the `this.props.selectHandler` property with the
    appropriate product code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Product`组件通过调用通过`this.props.selectHandler`属性传递的`select()`方法来处理`onClick`事件，并使用适当的产品代码：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll now open the existing project, `my-shop-03`, in order to see the results
    of the previous code. Follow these steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将打开现有的项目`my-shop-03`，以便查看之前代码的结果。请按照以下步骤操作：
- en: Open a console window
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口
- en: Move to the `my-shop-03` folder
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-03`文件夹
- en: Run `npm install`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`
- en: Run `npm start`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`
- en: 'We can conclude that an event on a child component triggers the execution of
    a parent component method passed via `props`. The method changes the parent''s
    state, and the effect of this change is once again propagated to the children
    via `props`. The following diagram illustrates this behavior:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，子组件上的事件触发了通过`props`传递的父组件方法的执行。该方法改变了父组件的状态，这种变化的效果再次通过`props`传播到子组件。以下图表说明了这种行为：
- en: '![](Images/c5f36cd8-28ca-4ccb-a05b-7fd69497a78e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5f36cd8-28ca-4ccb-a05b-7fd69497a78e.png)'
- en: 'Activity: Adding Items to the Shopping Cart'
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：将商品添加到购物车
- en: '**Scenario**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We want to allow the user to add items to the shopping cart by picking them
    from the product catalog.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许用户从产品目录中选择商品并将其添加到购物车中。
- en: '**Aim**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to become familiar with event management in React.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是熟悉React中的事件管理。
- en: '**Steps for Completion**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Consider the existing project in the `my-cart-01` folder
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑`my-cart-01`文件夹中的现有项目
- en: Handle the click event of the `Product` component's Add to cart button in order
    to add that product to the cart
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`Product`组件的“添加到购物车”按钮的点击事件，以便将该商品添加到购物车中
- en: '**Solution**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-02` folder at `Code/Chapter-3/`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案包含在`Code/Chapter-3/`下的`my-cart-02`文件夹中。
- en: Component Lifecycle Events
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期事件
- en: In a React application, components are created dynamically, according to the evolution
    of the application at runtime. A user's interaction starts a component's creation,
    its visualization, its updates on the screen, and its destruction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用程序中，组件根据应用程序运行时的演变动态创建。用户的交互启动了组件的创建、屏幕上的可视化、更新和销毁。
- en: 'So, components go through different phases during application execution: these
    phases represent their lifecycles.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，组件在应用程序执行期间经历不同的阶段：这些阶段代表了它们的生命周期。
- en: React allows us to intercept and manage the phases of a component's lifecycle
    in a customized way, thanks to a set of events that we can handle by implementing specific
    methods.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: React允许我们以自定义的方式拦截和管理组件生命周期的各个阶段，这得益于我们可以通过实现特定方法来处理的一组事件。
- en: Before analyzing a component's lifecycle events, we should highlight that the
    first step in creating a component is the execution of its constructor. Although
    it is not one of React's lifecycle phases, it is the first step of a component's
    life. During the component's constructor execution, the DOM is not available,
    and it is not possible to access any child component. The constructor execution
    is the right time to perform the initializations that don't concern graphic rendering
    or child manipulation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析组件的生命周期事件之前，我们应该强调，创建组件的第一步是执行其构造函数。虽然它不是React生命周期阶段的一部分，但它是组件生命的第一步。在组件构造函数执行期间，DOM不可用，也无法访问任何子组件。构造函数执行是执行不涉及图形渲染或子组件操作的初始化的正确时机。
- en: 'After component creation, React will trigger a few events corresponding to
    the respective phases of the component''s lifecycle. We can catch these events
    and handle them by implementing a few methods in our component. Consider the following
    method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 组件创建后，React将触发几个对应于组件生命周期相应阶段的事件。我们可以捕获这些事件并通过在我们的组件中实现一些方法来处理它们。考虑以下方法：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is executed when the component is about to be inserted into the
    DOM. It is invoked once, just before the initial rendering occurs. Usually, this
    method is used to perform any initialization of the component not involving the
    DOM, such as initializing values for a component's properties or local variables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在组件即将被插入到DOM中时执行。它只被调用一次，就在初始渲染发生之前。通常，这个方法用于执行与DOM无关的组件初始化，例如初始化组件的属性或本地变量。
- en: You can use the `setState()` method within `componentWillMount()`, but it will
    not trigger a re-render of the component, so use it carefully.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`componentWillMount()`中使用`setState()`方法，但它不会触发组件的重新渲染，所以要谨慎使用。
- en: '`componentWillReceiveProps` is the method invoked before rendering when a component
    receives new values from the parent via `props`. This method receives the new
    values as a parameter, and we can access the old values through `this.props`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`是在组件通过`props`从父组件接收到新值之前渲染时调用的方法。这个方法接收新值作为参数，我们可以通过`this.props`访问旧值。'
- en: If we try to change the component state during the execution of this method,
    we will not trigger any additional rendering. Additionally, `componentWillReceiveProps()`
    is not to be invoked upon initial rendering.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在这个方法执行期间改变组件状态，我们将不会触发任何额外的渲染。此外，`componentWillReceiveProps()`在初始渲染时不会被调用。
- en: The `shouldComponentUpdate` method should return a Boolean that states whether the
    component should be rendered (`true`) or not (`false`). If the method returns `false`,
    the next methods will not be invoked, including `render()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`方法应该返回一个布尔值，表示组件是否应该被渲染（`true`）或不渲染（`false`）。如果该方法返回`false`，则不会调用下一个方法，包括`render()`。'
- en: 'This has two parameters: `nextProps`, containing the new values for the `props`,
    and `nextState`, containing the new value of the component''s state.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个参数：`nextProps`，包含`props`的新值，以及`nextState`，包含组件状态的新值。
- en: '`componentWillUpdate` is invoked immediately before the `render()` method,
    so it is the last opportunity to perform some processing before updating the component.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`在`render()`方法之前立即被调用，因此它是更新组件之前执行某些处理的最后机会。'
- en: You cannot use `setState()` within an implementation of `shouldComponentUpdate()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shouldComponentUpdate()`的实现中不能使用`setState()`。
- en: '`componentDidUpdate` is invoked immediately after rendering occurs, and during
    its execution, we can access the new version of the component in the DOM. The
    method has two parameters: the previous `props` and the previous state.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidUpdate`在渲染发生后立即调用，在其执行期间，我们可以访问DOM中组件的新版本。该方法有两个参数：之前的`props`和之前的状态。'
- en: '`componentDidMount` is called after the component is inserted into the DOM,
    and is invoked just once.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount`在组件被插入到DOM后调用，并且只调用一次。'
- en: '`componentWillUnmount` is called immediately before the component is removed from
    the DOM.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`在组件从DOM中移除之前立即调用。'
- en: You cannot use `setState()` during the execution of this method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法执行期间，你不能使用`setState()`。
- en: 'We can group the component lifecycle events into three main areas:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将组件生命周期事件分为三个主要区域：
- en: '**Mounting**: This `props` group contains the events related to DOM manipulation:
    `componentWillMount`, `componentDidMount`, and `componentWillUnmount`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：这个`props`组包含与DOM操作相关的事件：`componentWillMount`、`componentDidMount`和`componentWillUnmount`'
- en: '**Updating via props**: This group contains the events that are triggered when
    a component is updated via `props` passed by its parent, and it includes: `componentWillReceiveProps`,
    `shouldComponentUpdate`, `componentWillUpdate`, and `componentDidUpdate`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过props更新**：这个组包含当组件通过其父组件传递的`props`更新时触发的事件，包括：`componentWillReceiveProps`、`shouldComponentUpdate`、`componentWillUpdate`和`componentDidUpdate`。'
- en: '**Updating via setState()**: In this group, we find the events triggered when a
    component is updated via `setState()`: `shouldComponentUpdate`, `componentWillUpdate`,
    and `componentDidUpdate`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过setState()更新**：在这个组中，我们找到当组件通过`setState()`更新时触发的事件：`shouldComponentUpdate`、`componentWillUpdate`和`componentDidUpdate`。'
- en: 'The following diagram illustrates the event flow and highlights, with different
    colors, the three areas we just discussed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了事件流，并使用不同的颜色突出了我们刚刚讨论的三个区域：
- en: '![](Images/77905891-cf29-46ca-a169-f0453358e90b.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/77905891-cf29-46ca-a169-f0453358e90b.png)'
- en: 'Activity: Showing the Quantity of Items Added to the Cart'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：显示添加到购物车的商品数量
- en: '**Scenario**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'We want to avoid multiple occurrences of the same product in the cart. Rather,
    we want the cart to have a single occurrence of a product and its quantity, as
    shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免购物车中出现同一产品的多个实例。相反，我们希望购物车中只有单一产品及其数量的出现，如下面的截图所示：
- en: '![](Images/c60ffc2b-daab-4b7b-be17-7fd2b6b772b0.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c60ffc2b-daab-4b7b-be17-7fd2b6b772b0.png)'
- en: '**Aim**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to exploit the lifecycle events of React components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是利用React组件的生命周期事件。
- en: '**Steps for Completion**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Utilize the project that was changed in the previous activity (or the existing project
    in the `my-cart-02` folder).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用在前一个活动中更改的项目（或在`my-cart-02`文件夹中的现有项目）。
- en: Change the `Cart` component in order to show a list of non-duplicated products
    and their related number of occurrences.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Cart`组件以显示一个无重复产品的列表及其相关出现次数。
- en: Handle the `componentWillReceiveProps` event to prepare data for the internal
    state of the `Cart` component.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`componentWillReceiveProps`事件，为`Cart`组件的内部状态准备数据。
- en: '**Solution**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-03` folder at `Code/Chapter-3`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是在`Code/Chapter-3`中的`my-cart-03`文件夹中包含的解决方案。
- en: Managing Routing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理路由
- en: Modern web applications, based on the Single-Page Application model, can't do without
    the routing mechanism, a way to navigate among views while remaining on the same
    HTML page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基于单页应用程序模型的现代Web应用程序，不能没有路由机制，这是一种在同一HTML页面上浏览视图的方式。
- en: We can consider a view as a placeholder in the UI where we can dynamically render one
    component or another in an exclusive way. Let's try to clarify this concept with an
    example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将视图视为UI中的一个占位符，在其中我们可以动态地渲染一个组件或另一个组件，以独占的方式。让我们尝试用一个例子来澄清这个概念。
- en: 'Suppose that we want to add a navigation bar to our *Wine Catalog* application.
    In its simplest implementation, we want to alternatively show the Catalog and
    an About section, providing some information about the application itself. The
    new UI will look like the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在我们的*葡萄酒目录*应用程序中添加一个导航栏。在最简单的实现中，我们想交替显示目录和一个关于部分，提供一些关于应用程序本身的信息。新的UI将如下面的截图所示：
- en: '![](Images/73e59b33-0f9c-4a43-9024-556c5bca4ea7.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/73e59b33-0f9c-4a43-9024-556c5bca4ea7.png)'
- en: When clicking a menu item, we expect the main area to change, while the header remains
    the same. In this case, the main area will be the view in which we display the
    `Catalog` component or the `About` component, depending on the menu item we clicked
    on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击菜单项时，我们希望主区域发生变化，而头部保持不变。在这种情况下，主区域将是我们显示`Catalog`组件或`About`组件的视图，具体取决于我们点击的菜单项。
- en: How can we implement the routing mechanism in React?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在React中实现路由机制？
- en: Installing React Router
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装React Router
- en: We can enable routing in a React-based application by using **React Router**,
    a package that provides us with specific React components that allow us to set
    up a complete routing system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**React Router**，一个为我们提供特定React组件的包，来启用基于React的应用程序的路由，这些组件允许我们设置一个完整的路由系统。
- en: 'We install that package in our application by typing the following command
    inside of the application''s folder:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序的文件夹中输入以下命令来安装该包：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'React Router provides three packages:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: React Router提供了三个包：
- en: '`react-router`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-router`'
- en: '`react-router-dom`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-router-dom`'
- en: '`react-router-native`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-router-native`'
- en: The first package provides the core routing components and functionalities.
    The second one provides specific components for the browser environment, and the
    third one supports `react-native`, an environment that maps React components to
    native mobile UI widgets. Both `react-router-dom` and `react-router-native` use `react-router`
    functionalities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包提供了核心路由组件和功能。第二个包为浏览器环境提供了特定组件，第三个包支持`react-native`，这是一个将React组件映射到原生移动UI小部件的环境。`react-router-dom`和`react-router-native`都使用`react-router`功能。
- en: Using the Router
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由器
- en: Once we have installed the React Router package in our environment, we need
    to use the provided components in our application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在环境中安装了React Router包，我们需要在应用程序中使用提供的组件。
- en: 'The first thing we need to do is add routing capabilities to our application.
    We can do this by changing the code of the `index.js` file, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为应用程序添加路由功能。我们可以通过更改`index.js`文件的代码来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We highlighted the main differences, with respect to the previous version of
    the code. As you can see, we imported the `BrowserRouter` component from the `react-router-dom`
    module and wrapped the `App` component inside of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调了与前一版本代码的主要区别。如您所见，我们从`react-router-dom`模块导入了`BrowserRouter`组件，并将其包裹在`App`组件内部。
- en: By wrapping the `App` component, the `BrowserRouter` component enriches it with routing
    capabilities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包装`App`组件，`BrowserRouter`组件为其赋予了路由功能。
- en: This is a component composition hence we have called this as component wrapping.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个组件组合，因此我们称之为组件包装。
- en: Defining Views
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义视图
- en: 'Now, we need to create a view to display the `Catalog` component or the About
    page, as depicted in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个视图来显示`Catalog`组件或关于页面，如下所示：
- en: '![](Images/9aded227-73da-4ec8-9c1d-a9109033be9b.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9aded227-73da-4ec8-9c1d-a9109033be9b.png)'
- en: 'We can accomplish this by changing the `App.js` code, which is shown as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改`App.js`代码来实现这一点，如下所示：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We imported the `Switch` and `Route` components from the `react-router-dom` module,
    and used them in the JSX expression where the `Catalog` element once was.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`react-router-dom`模块导入了`Switch`和`Route`组件，并在JSX表达式中使用了它们，该表达式曾经是`Catalog`元素所在的位置。
- en: The `Switch` component allows us to define a view, that is, the area inside
    of which we will toggle components. The `Route` components are used as child elements
    of `Switch`, and they allow us to map URLs to components. In our example, we are mapping
    the root URL (`/`) to the `Catalog` component and the `/about` URL to the `About`
    component. This means that when the `BrowserRouter` intercepts the request to
    move to one of these URLs, it will render the appropriate component inside of
    the view.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`组件允许我们定义一个视图，即我们将在其中切换组件的区域。`Route`组件用作`Switch`的子元素，它们允许我们将URL映射到组件。在我们的示例中，我们将根URL（`/`）映射到`Catalog`组件，将`/about`
    URL映射到`About`组件。这意味着当`BrowserRouter`拦截到移动到这些URL之一的请求时，它将在视图中渲染适当的组件。'
- en: 'The navigation bar that allows us to display the catalog or the information
    about the application is implemented as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们显示目录或应用程序信息的导航栏实现如下：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we added the import of a `Link` component and used it in the highlighted markup.
    The `Link` component allows us to create a hyperlink element that will be caught
    by the `BrowserRouter` component.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了对`Link`组件的导入，并在突出显示的标记中使用了它。`Link`组件允许我们创建一个超链接元素，该元素将被`BrowserRouter`组件捕获。
- en: These changes add a working navigation bar to our application. You can see the result
    of these changes by performing the following steps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改为我们的应用程序添加了一个可用的导航栏。您可以通过执行以下步骤来查看这些更改的结果。
- en: 'We will open the existing project, `my-shop-04`, in order to show the results
    of the previous code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开现有的项目`my-shop-04`，以展示前面代码的结果：
- en: Open a console window
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口
- en: Move to the `my-shop-04` folder
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-04`文件夹
- en: Run `npm install`
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`
- en: Run `npm start`
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`
- en: Some Notes About the Route Component
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于路由组件的一些注意事项
- en: 'Notice that the `Route` component has the `path` attribute (which allows us
    to specify the URL to map) and the `component` attribute (which allows us to assign
    the component to render in the current view):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Route`组件具有`path`属性（允许我们指定要映射的URL）和`component`属性（允许我们分配要在当前视图中渲染的组件）：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `path` attribute is used by React Router to detect the component to render,
    as specified by the corresponding `component` attribute.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`属性用于React Router来检测要渲染的组件，如相应的`component`属性所指定。'
- en: In the previous route mapping, if we click on a `Link` component associated
    with the `/about` URL, the route with the root (`/`) path will match the starting
    part of `/about`, and the `Catalog` component will be rendered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的路由映射中，如果我们点击与`/about` URL关联的`Link`组件，具有根路径（`/`）的路由将匹配`/about`的起始部分，并且`Catalog`组件将被渲染。
- en: When the user requests a URL by clicking on the `Link` component, the list of
    routes is scanned in order to find a path value that matches the starting part
    of the URL. The first matching value determines the component to render.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过点击`Link`组件请求URL时，路由列表会按顺序扫描以找到与URL起始部分匹配的路径值。第一个匹配的值决定了要渲染的组件。
- en: 'If we want a strict comparison between the `path` attribute''s value and the
    URL, we need to specify the exact attribute, which is shown as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在`path`属性的值和URL之间进行严格比较，我们需要指定`exact`属性，如下所示：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This prevents any URL starting with `/` from being captured by the first route.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止任何以`/`开头的URL被第一个路由捕获。
- en: 'The `component` attribute of the `Route` component allows us to specify the
    component to render. Alternatively, we can use the `render` attribute to specify
    the invocation of a function returning a React element, as shown in the following
    example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`组件的`component`属性允许我们指定要渲染的组件。或者，我们可以使用`render`属性来指定调用一个返回React元素的函数，如下例所示：'
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This approach is similar to using the `component` attribute, but it may be useful
    for inline rendering and when we need to pass values to the element.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于使用`component`属性，但它可能对于内联渲染和当我们需要向元素传递值时很有用。
- en: The `Route` component also allows us to specify the `children` attribute. As
    with `render`, we can assign a function to this attribute, but the elements returned
    by that function will *always* be rendered, regardless of whether the path matches
    or not.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组件还允许我们指定`children`属性。与`render`一样，我们可以将一个函数赋给这个属性，但该函数返回的元素将*始终*被渲染，无论路径是否匹配。
- en: 'Consider the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Footer` component will always be rendered, even if the path `/footer` doesn't match.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Footer`组件将始终被渲染，即使路径`/footer`不匹配。'
- en: Nested Views
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套视图
- en: In the preceding examples, we implemented view navigation in the `App` component by
    using the `Switch`, `Route`, and `Link` components provided by React Router. We can
    use these routing components inside of any other component so that we can build
    nested views and nested routes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过使用React Router提供的`Switch`、`Route`和`Link`组件，在`App`组件中实现了视图导航。我们可以在任何其他组件中使用这些路由组件，以便我们可以构建嵌套视图和嵌套路由。
- en: Let's try to illustrate this with an example. Suppose that we want to add a
    list of winemakers to our application. We can add a new item to the navigation
    bar that allows us to navigate to a page showing that list.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个例子来说明这一点。假设我们想在我们的应用程序中添加一个酿酒师列表。我们可以在导航栏中添加一个新项，允许我们导航到一个显示该列表的页面。
- en: 'The following screenshot shows how the new layout will appear:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了新布局的外观：
- en: '![](Images/27b9a00c-cc5f-4cf9-9130-728896366abe.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/27b9a00c-cc5f-4cf9-9130-728896366abe.png)'
- en: 'So, let''s change the `App` component''s JSX markup, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们更改`App`组件的JSX标记，如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We imported the `WineMakers` component, defined a route that maps the `/winemakers`
    path to the new component, and added a link to navigate to it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`WineMakers`组件，定义了一个将`/winemakers`路径映射到新组件的路由，并添加了一个链接以导航到它。
- en: 'We can implement the list of winemakers as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下实现酿酒师列表：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `WineMakers` component has the `renderWineMakersList()` method that returns
    the React element implementing a list of links to each winemaker. This method
    is used as the value of the `render` attribute of the route matching the `/winemakers`
    path in the `render()` method of the component. The other routes get the path
    pointing to each specific winemaker and render the `WineMaker` component according
    to the identifier code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`WineMakers`组件具有`renderWineMakersList()`方法，该方法返回实现每个酿酒师链接列表的React元素。此方法用作组件`render()`方法中与`/winemakers`路径匹配的路由的`render`属性的值。其他路由获取指向每个特定酿酒师的路径，并根据标识码渲染`WineMaker`组件。'
- en: You may notice that we are implementing a view in the `WineMakers` component
    that is shown inside of the view implemented in the `App` component. In other
    words, we implement nested views by composing components that implement views.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们正在`WineMakers`组件中实现一个视图，该视图显示在`App`组件中实现的视图内。换句话说，我们通过组合实现视图的组件来实现嵌套视图。
- en: Path Parameters
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径参数
- en: 'The `render()` method of the `WineMakers` component implements the resulting
    view as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`WineMakers`组件的`render()`方法如下实现最终视图：'
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code is straightforward, and it works, but it forces us to add a new route whenever
    a new winemaker is added to our list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单，而且有效，但它迫使我们每当在我们的列表中添加新的酿酒师时都要添加一个新的路由。
- en: 'We can avoid this by using `path` parameters, as in the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`path`参数来避免这种情况，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we can now use a single route pointing to a specific winemaker
    by specifying a `:code` parameter. The colon in the path expression indicates
    that the following portion of the URL is a variable value. You may also notice
    that we used the `component` attribute instead of the `render` attribute. In fact,
    in this case, we do not need to explicitly pass the winemaker's code to the `WineMaker`
    component. React Router does it for us, by providing a special object in the `props`
    property.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在可以通过指定`:code`参数来使用指向特定酿酒师的单个路由。路径表达式中的冒号表示URL的后续部分是变量值。您可能还会注意到，我们使用了`component`属性而不是`render`属性。实际上，在这种情况下，我们不需要将酿酒师的代码显式传递给`WineMaker`组件。React
    Router为我们做到了这一点，通过在`props`属性中提供一个特殊对象。
- en: 'Let''s take a look at the `WineMaker` component implementation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`WineMaker`组件的实现：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the component's constructor, we define the list of winemakers as an array
    of objects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的构造函数中，我们将酿酒师列表定义为对象数组。
- en: In the `render()` method, we look for the winemaker to display by comparing
    the `code` property of each `winemaker` object in the array with the `match.params.code` property
    provided by `this.props`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render()`方法中，我们通过将数组中每个`winemaker`对象的`code`属性与`match.params.code`属性（由`this.props`提供）进行比较来查找要显示的酿酒师。
- en: We have implemented the `winemakers` list as a property of the `WineMaker` component,
    and not as a property of the `state` object because since the list is embedded
    into the code and shouldn't change, we do not need to implement it as a `state`
    property. Remember that we only identify data that changes over time as a state.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`winemakers`列表实现为`WineMaker`组件的属性，而不是`state`对象的属性，因为由于列表嵌入到代码中并且不应该更改，我们不需要将其实现为`state`属性。请记住，我们只将随时间变化，我们只将随时间变化的数据标识为状态。
- en: The object we find is used to appropriately render the data about the `WineMaker`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到的对象用于适当地渲染有关`WineMaker`的数据。
- en: 'Generally, a React component reached via a route receives the `match` object
    in the `this.props` property. This object contains information about the matching
    path in the `Route` definition. In particular, the following properties of the
    `match` object are available:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过路由到达的React组件在`this.props`属性中接收`match`对象。该对象包含有关`Route`定义中匹配路径的信息。特别是，`match`对象的以下属性可用：
- en: '`params`: This is an object whose properties match the parameters in the path; that
    is, the dynamic parts, preceded by colons'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：这是一个对象，其属性与路径中的参数匹配；也就是说，动态部分，前面有冒号'
- en: '`isExact`: This is a Boolean indicating that the URL matches the path'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isExact`：这是一个布尔值，指示URL是否与路径匹配'
- en: '`path`: This is the string assigned to the `path` attribute of the selected
    route'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是分配给所选路由的`path`属性的字符串'
- en: '`url`: This is the URL that matches the route''s path'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：这是与路由路径匹配的URL'
- en: 'We can see the final result by performing the following steps. We open the
    existing project, `my-shop-05`, in order to show the results of the previous code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下步骤，我们可以看到最终结果。我们打开现有的项目`my-shop-05`，以展示之前代码的结果：
- en: Open a console window
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个控制台窗口
- en: Move to the `my-shop-05` folder
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`my-shop-05`文件夹
- en: Run `npm install`
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`
- en: Run `npm start`
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`
- en: 'Activity: Adding a View About Shipping Methods'
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：添加有关运输方法的视图
- en: '**Scenario**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We want to add a section to our catalog app containing information about the available
    shipping methods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在我们的目录应用中添加一个包含有关可用运输方法信息的章节。
- en: '**Aim**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The aim of this activity is to explore the components provided by React Routing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是探索React路由提供的组件。
- en: '**Steps for Completion**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Consider the project that was changed in the previous activity (or the existing project
    in the `my-cart-03` folder).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑在前一活动中更改的项目（或位于`my-cart-03`文件夹中的现有项目）。
- en: Create a `ShippingMethods` component, showing a list of available shipping methods,
    and a `ShippingMethod` component, showing the details of each shipping method,
    according to a code passed via `props` (available shipping methods include **Economic
    delivery** (**ECO**), **Standard delivery** (**STD**), and **Express delivery**
    (**EXP**)).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ShippingMethods`组件，显示可用运输方法的列表，以及一个`ShippingMethod`组件，根据通过`props`传递的代码显示每个运输方法的详细信息（可用的运输方法包括**经济配送**（**ECO**）、**标准配送**（**STD**）和**快递配送**（**EXP**））。
- en: Create a navigation bar and a routing configuration that allow us to navigate through
    the `Catalog` and `Shipping` method views.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个导航栏和一个路由配置，允许我们在`Catalog`和`Shipping`方法视图之间导航。
- en: '**Solution**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: A possible solution is the one contained in the `my-cart-04` folder at `Code/Chapter-3`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是位于`Code/Chapter-3`中的`my-cart-04`文件夹中的那个。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned how to manage user interaction. In particular,
    we have covered the following things:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何管理用户交互。特别是，我们涵盖了以下内容：
- en: Managed events that don't involve changes to a component's state
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不涉及组件状态变化的事件
- en: Handled events that involve changes to a component's state
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理涉及组件状态变化的事件
- en: Explored the component lifecycle and learned how to customize each phase
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了组件生命周期并学习了如何自定义每个阶段
- en: Used React Router's components to configure navigation between components
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router的组件来配置组件之间的导航
- en: This chapter concludes the book. It provided the basics for understanding how
    React works and how to build React-based applications. We started with an introduction
    to React and then explored creating components in detail. We finished with a look
    at how to manage user interactivity with React.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为本书的结尾。它提供了理解React工作原理以及如何构建基于React的应用程序的基础知识。我们从React的简介开始，然后详细探讨了创建组件的过程。最后，我们研究了如何使用React管理用户交互。
