- en: Integrate React App with Firebase
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将React应用程序与Firebase集成
- en: In [Chapter 1](71a1e418-0815-400e-a3fe-7b0a26fd447b.xhtml), *Getting Started
    with Firebase and React*, we saw how we can integrate Firebase with JavaScript
    and created our first sample application, which gave us a brief idea of how Firebase
    works. Now that you've completed your first web app using JavaScript and Firebase,
    we'll build the helpdesk application with React and Firebase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](71a1e418-0815-400e-a3fe-7b0a26fd447b.xhtml)中，*使用Firebase和React入门*，我们看到了如何将Firebase与JavaScript集成，并创建了我们的第一个示例应用程序，这给了我们一个关于Firebase如何工作的简要概念。现在您已经完成了使用JavaScript和Firebase创建您的第一个Web应用程序，我们将使用React和Firebase构建帮助台应用程序。
- en: We will start off by setting up the React environment, and then we will take
    a quick look at the JSX and React component methods. We'll also see how we can
    create form components in React using JSX and submit these form values in the
    Firebase Realtime Database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置React环境，然后快速查看JSX和React组件方法。我们还将看到如何在React中使用JSX创建表单组件，并将这些表单值提交到Firebase实时数据库中。
- en: 'Here''s a list of the points that we''ll focus on this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将关注的要点列表：
- en: React Environment Setup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React环境设置
- en: Introduction of JSX and React Bootstrap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX和React Bootstrap的介绍
- en: Creating a Form With JSX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX创建表单
- en: Firebase Integration With React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与React集成的Firebase
- en: Save and Read the data from Realtime Database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和读取实时数据库中的数据
- en: Setting up the environment
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'First, we need to create a folder structure similar to our Hello World app,
    which we made in [Chapter 1](71a1e418-0815-400e-a3fe-7b0a26fd447b.xhtml), *Getting
    Started with Firebase and React*. The following screenshot describes the folder
    structure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个类似于我们在[第1章](71a1e418-0815-400e-a3fe-7b0a26fd447b.xhtml)中制作的Hello
    World应用程序的文件夹结构。以下屏幕截图描述了文件夹结构：
- en: '![](Images/07f1cb0e-4dc0-4051-9e18-ee0d5db18194.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/07f1cb0e-4dc0-4051-9e18-ee0d5db18194.png)
- en: 'When we start making an application with ReactJS, we need to do some setup,
    which just involves an HTML page and the `reactjs` library. Once we have finished
    creating the folder structure, we need to install both our frameworks: ReactJS
    and Firebase. It''s as simple as including JavaScript and CSS files in your page.
    We can do this via a **Content Delivery Network** (**CDN**), such as Google or
    Microsoft, but we will fetch the files manually in our application so that we
    don''t have to be dependent on the internet and can work offline.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用ReactJS制作应用程序时，我们需要进行一些设置，这仅涉及HTML页面和`reactjs`库。一旦我们完成了文件夹结构的创建，我们需要安装我们的两个框架：ReactJS和Firebase。只需在页面中包含JavaScript和CSS文件即可。我们可以通过**内容交付网络**（**CDN**）（例如Google或Microsoft）来实现这一点，但我们将在我们的应用程序中手动获取文件，这样我们就不必依赖于互联网，可以脱机工作。
- en: Installing React
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装React
- en: 'First, we have to go to [https://reactjs.org/](https://reactjs.org/) and see
    the latest available version that we will use in our application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须转到[https://reactjs.org/](https://reactjs.org/)，查看我们将在应用程序中使用的最新可用版本：
- en: '![](Images/05b3a56e-23a1-4afb-baef-4d6cb7ee64d4.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/05b3a56e-23a1-4afb-baef-4d6cb7ee64d4.png)
- en: 'As of writing this book, the latest version available is v16.0.0\. We will
    use CDN React packages in this chapter to build our application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新可用版本是v16.0.0。我们将在本章中使用CDN React包来构建我们的应用程序：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding versions are only meant for development, and that is not suitable
    for production. To use minified and optimized production versions, we need to
    use these production packages:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前述版本仅用于开发，不适合生产。要使用经过缩小和优化的生产版本，我们需要使用这些生产包：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to use a different version, replace number `16` with the version
    that you want to use in your app. Let''s include development version CDN into
    your HTML:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用不同的版本，请将数字`16`替换为您在应用程序中要使用的版本。让我们在您的HTML中包含开发版本CDN：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using React
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React
- en: 'So now that we''ve got the ReactJS from where we''ve initialized our app, let''s
    start writing our first Hello World app using `ReactDOM.render()`. The first argument
    of the `ReactDOM.render` method is the component, which we want to render, and
    the second is the DOM node to which it should mount (append). Observe the following
    code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从ReactJS中初始化了我们的应用程序，让我们开始编写我们的第一个Hello World应用程序，使用`ReactDOM.render()`。`ReactDOM.render`方法的第一个参数是我们要渲染的组件，第二个参数是它应该挂载（附加）到的DOM节点。请观察以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to translate it to vanilla JavaScript because all browsers don''t support
    the JSX and ES6 features. For this, we need to use transpiler Babel, which will
    compile the JSX to vanilla JavaScript before the React code runs. Add the following
    library in the head section along with React libraries:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将它转换为原始JavaScript，因为并非所有浏览器都支持JSX和ES6功能。为此，我们需要使用转译器Babel，它将在React代码运行之前将JSX编译为原始JavaScript。在head部分与React库一起添加以下库：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add the script tag with React code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加带有React代码的脚本标签：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `<script type="text/babel">` tag is the one that actually performs the transformation
    in the browser.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script type="text/babel">`标签实际上是在浏览器中执行转换的标签。'
- en: 'The XML syntax for JavaScript is called **JSX**. We will explore this further
    in more detail. Let''s open the HTML page in our browser. If you see Hello, world!
    in your browser, then we are on track. Observe the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的XML语法称为**JSX**。我们将更详细地探讨这一点。让我们在浏览器中打开HTML页面。如果你在浏览器中看到Hello, world!，那么我们就在正确的轨道上。请观察以下截图：
- en: '![](Images/3c8f5f0c-ecfb-4e39-9dda-e508da724a13.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3c8f5f0c-ecfb-4e39-9dda-e508da724a13.png)'
- en: In the preceding screenshot, you can see that it shows Hello, world! in your
    browser. That looks nice. We have successfully completed our setup and built our
    first Hello World app with ReactJS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到它在你的浏览器中显示了Hello, world!。看起来不错。我们已经成功完成了我们的设置，并用ReactJS构建了我们的第一个Hello
    World应用程序。
- en: React components
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件
- en: React is based on a modular build with encapsulated components that manage their
    own state, so it will efficiently update and render your components when data
    changes. In React, a component's logic is written in JavaScript instead of templates,
    so you can easily pass rich data through your app and manage the state out of
    the DOM. Using the `render()` method, we are rendering a component in React that
    takes input data and returns what you want to display. It can either take HTML
    tags (strings) or React components (classes).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: React基于模块化构建，具有封装的组件，这些组件管理自己的状态，因此当数据发生变化时，它将高效地更新和渲染您的组件。在React中，组件的逻辑是用JavaScript编写的，而不是模板，因此您可以轻松地通过应用程序传递丰富的数据并在DOM之外管理状态。使用`render()`方法，我们在React中渲染一个组件，该组件接受输入数据并返回您想要显示的内容。它可以接受HTML标签（字符串）或React组件（类）。
- en: 'Let''s take a quick look at examples of both:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下这两种例子：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we are passing HTML as a string into the `render` method that
    we used before creating the `<Navbar>`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将HTML作为字符串传递给`render`方法，之前我们创建了`<Navbar>`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, we are rendering the component just to create a local
    variable that starts with an uppercase convention. Use the uppercase convention
    in JSX to avoid distinguishing between local component classes and HTML tags because
    JSX is an extension of JavaScript. In React, we can create our React elements
    or components in two ways: either we can use Plain JavaScript with `React.createElement`
    or React''s JSX. So, let''s create our first form component with JSX.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们渲染组件只是为了创建一个以大写约定开头的局部变量。在JSX中使用大写约定，以避免区分本地组件类和HTML标签，因为JSX是JavaScript的扩展。在React中，我们可以以两种方式创建我们的React元素或组件：要么使用`React.createElement`的纯JavaScript，要么使用React的JSX。因此，让我们用JSX创建我们的第一个表单组件。
- en: What is JSX in React?
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中JSX是什么？
- en: JSX is an extension of JavaScript syntax, and if you observe the syntax or structure
    of JSX, you will find it similar to XML coding. With JSX, you can carry out preprocessor
    footsteps that add XML syntax to JavaScript. Though you can certainly use React
    without JSX, JSX makes React very clean and manageable. Similar to XML, JSX tags
    have tag names, attributes, and children, and in that, if an attribute value is
    enclosed in quotes, that value becomes a string. XML works with balanced opening
    and closing tags. JSX works similarly, and it also helps read and understand a
    huge amount of structures easier than JavaScript functions and objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是JavaScript语法的扩展，如果你观察JSX的语法或结构，你会发现它类似于XML编码。使用JSX，你可以执行预处理步骤，将XML语法添加到JavaScript中。虽然你当然可以在不使用JSX的情况下使用React，但JSX使React变得非常干净和可管理。与XML类似，JSX标签具有标签名称、属性和子元素，如果属性值被引号括起来，那个值就成为一个字符串。XML使用平衡的开放和关闭标签。JSX类似地工作，它还有助于阅读和理解大量的结构，比JavaScript函数和对象更容易。
- en: Advantages of using JSX in React
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中使用JSX的优势
- en: 'Here''s a list of a few advantages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优势的列表：
- en: JSX is very simple to understand, compared to JavaScript functions
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与JavaScript函数相比，JSX非常简单易懂
- en: JSX code syntax is more familiar to non-programmers
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX代码语法对非程序员更加熟悉
- en: By using JSX, your markup becomes more semantic, organized, and significant
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用JSX，你的标记变得更有语义、有组织和有意义
- en: How to make your code neat and clean
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使你的代码整洁清晰
- en: As I said earlier, the structure/syntax is so easy to visualize/notice, which
    is intended for cleaner and more understandable code in JSX format when we compare
    it to JavaScript syntax.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，这种结构/语法非常容易可视化/注意到，旨在使JSX格式的代码更加清晰和易懂，与JavaScript语法相比。
- en: 'The following are sample code snippets that will give you a clear idea of React
    JavaScript syntax and JSX:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些代码片段的示例，它们将让你清楚地了解React JavaScript语法和JSX：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, observe the following JSX syntax:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察以下的JSX语法：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So here we are clear now that JSX is really so easy to understand for programmers
    who are generally not used to dealing with coding, and they can learn, execute,
    and write it as HTML language.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们清楚了，对于通常不习惯处理编码的程序员来说，JSX真的很容易理解，他们可以学习、执行和编写它，就像HTML语言一样。
- en: React Form with JSX
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSX的React表单
- en: Before starting on a creating form with JSX, we must be aware of JSX form libraries.
    Generally, HTML form element inputs take their value as display text/values, but
    in React JSX, they take property values of respective elements and display them.
    As we have already visually perceived that we can't change props' values directly,
    so the input value won't have that transmuted value as an exhibit value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用JSX创建表单之前，我们必须了解JSX表单库。通常，HTML表单元素输入将它们的值作为显示文本/值，但在React JSX中，它们取相应元素的属性值并显示它们。由于我们已经直观地感知到我们不能直接改变props的值，所以输入值不会有转变后的值作为展示值。
- en: Let's discuss this in detail. To change the value of a form input, you will
    use the value attribute and then you will see no change. This doesn't mean that
    we cannot change the form input value, but for that, we need to listen to the
    input events, and you will see that the value changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下。要改变表单输入的值，你将使用value属性，然后你会看到没有变化。这并不意味着我们不能改变表单输入的值，但为此，我们需要监听输入事件，然后你会看到值的变化。
- en: 'The following exceptions are self-explanatory, but very important:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的例外是不言自明的，但非常重要：
- en: Label content will be considered as a value prop in React. As **for** is a reserved
    keyword of JavaScript; the HTML for the attribute should be bounded like the HTML
    for a prop. You'll have a better understanding when you look at the next example.
    Now, it's time to learn that to have form elements in the output, we need to use
    the following script, and we also need to replace it with the previously written
    code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，标签内容将被视为值属性。由于 **for** 是 JavaScript 的保留关键字；HTML for 属性应该像 prop 一样被绑定。当您查看下一个示例时，您会更好地理解。现在，是时候学习了，为了在输出中有表单元素，我们需要使用以下脚本，并且还需要用先前编写的代码替换它。
- en: Now, let's start on building an `Add Ticket form` for our application. Create
    a `reactForm.html` file in the root and and `react-form.js` file in <strong>js
    folder. The following code snippet is just a base HTML page that includes Bootstrap
    CSS and React.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始为我们的应用程序构建一个 `Add Ticket form`。在根目录中创建一个 `reactForm.html` 文件和一个 <strong>js
    文件夹中的 `react-form.js` 文件。以下代码片段只是一个包含 Bootstrap CSS 和 React 的基本 HTML 页面。
- en: 'Here''s the markup of our HTML page:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的 HTML 页面的标记：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is always a good practice to load all your scripts at the bottom of the page
    before your `<body>` tag closes, which loads the component successfully in your
    DOM, because when the script is executed in the `<head>` section, the document
    element is not available as the script itself is in the `<head>` section. The
    best way to resolve this problem is to keep scripts at the bottom of your page
    before your `<body>` tag closes, and it will be executed after loading all your
    DOM elements, which will not throw any JavaScript errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面底部加载所有脚本是一个很好的做法，在 `<body>` 标签关闭之前，这样可以成功在 DOM 中加载组件，因为当脚本在 `<head>` 部分执行时，文档元素不可用，因为脚本本身在
    `<head>` 部分。解决这个问题的最佳方法是在页面底部保留脚本，在 `<body>` 标签关闭之前执行，这样在加载所有 DOM 元素后执行，不会抛出任何
    JavaScript 错误。
- en: Since JSX is similar to JavaScript, we can't use the `class` attribute in JSX
    because it's a reserved keyword in JavaScript. We should use `className` and `htmlFor`
    as property names in the ReactDOM component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSX 类似于 JavaScript，我们不能在 JSX 中使用 `class` 属性，因为它是 JavaScript 中的保留关键字。我们应该在
    ReactDOM 组件中使用 `className` 和 `htmlFor` 作为属性名称。
- en: Now, Let's create some HTML layout in this file with bootstrap
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在这个文件中使用 bootstrap 创建一些 HTML 布局
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the above code we have created the navigation and wrapped it into the bootstrap
    grid classes for responsive behavior of the component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了导航并将其包装到 bootstrap 网格类中，以实现组件的响应行为。
- en: '![](Images/c879b515-17b8-4954-9452-70a2bb02dfcc.png)This is how our HTML looks
    in the browser.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/c879b515-17b8-4954-9452-70a2bb02dfcc.png)这是我们在浏览器中的 HTML 外观。'
- en: 'For our `Add Ticket form`  component,  we need the following form fields along
    with the label:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `Add Ticket form` 组件，我们需要以下表单字段以及标签：
- en: 'Email: `<input>`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮箱：`<input>`
- en: Issue type: `<select>`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题类型：`<select>`
- en: Assign department: `<select>`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配部门：`<select>`
- en: Comments: `<textarea>`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释：`<textarea>`
- en: Button: `<button>`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮：`<button>`
- en: 'Also, here''s the list of supported events:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是支持的事件列表：
- en: '`onChange`, `onInput`, and `onSubmit`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChange`, `onInput`, 和 `onSubmit`'
- en: '`onClick`, `onContextMenu`, `onDoubleClick`, `onDrag`, and `onDragEnd`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`, `onContextMenu`, `onDoubleClick`, `onDrag`, 和 `onDragEnd`'
- en: '`onDragEnter` and `onDragExit`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDragEnter` 和 `onDragExit`'
- en: '`onDragLeave`, `onDragOver`, `onDragStart`, `onDrop`, and `onMouseDown`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDragLeave`, `onDragOver`, `onDragStart`, `onDrop`, 和 `onMouseDown`'
- en: '`onMouseEnter` and `onMouseLeave`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseEnter` 和 `onMouseLeave`'
- en: '`onMouseMove`, `onMouseOut`, `onMouseOver`, and `onMouseUp`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseMove`, `onMouseOut`, `onMouseOver`, 和 `onMouseUp`'
- en: 'Let''s take a quick look at our form''s component code in `react-form.js`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下我们表单组件的代码在 `react-form.js` 中：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To apply a style or call an `onSubmit()` function in the attribute value, rather
    than using quotes (`""`), we have to use a pair of curly braces (`{}`) in the
    JavaScript expression. It means that you can embed any JavaScript expression in
    JSX by wrapping it in curly braces, even a function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用样式或调用`onSubmit()`函数的属性值，而不是使用引号（`""`），我们必须在JavaScript表达式中使用一对花括号（`{}`）。这意味着你可以通过用花括号包裹任何JavaScript表达式在JSX中嵌入它，甚至是一个函数。
- en: Add this script tag at the bottom of the HTML page after the react libraries
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在react库之后，在HTML页面底部添加这个脚本标签
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, open your browser and let''s take a look at the output of our JSX code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的浏览器，让我们看看我们的JSX代码的输出：
- en: '![](Images/23a18add-ae14-4e93-9e6d-20eea16be3dc.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/23a18add-ae14-4e93-9e6d-20eea16be3dc.png)'
- en: That looks awesome. We can see our form as expected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒。我们可以看到我们的表单如预期的那样。
- en: The first character should always be capitalized when you create a component
    in React. For example, our `Add Ticket form` component is `<AddTicketForm></AddTicketForm>`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中创建组件时，第一个字符应该始终大写。例如，我们的`Add Ticket form`组件是`<AddTicketForm></AddTicketForm>`。
- en: For the large-scale application, this approach will not be recommended; we cannot
    put the whole JSX code at one place every time we create form elements. To make
    our code clean and manageable, we should create a reusable component and just
    give the reference of that component wherever we need to use it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，这种方法并不推荐；我们不能每次创建表单元素时都把整个JSX代码放在一个地方。为了使我们的代码清晰和易于管理，我们应该创建一个可重用的组件，只需在需要使用它的地方给出该组件的引用。
- en: 'So let''s see how we can achieve this in our existing code, and we will create
    one reusable text input component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们看看如何在我们现有的代码中实现这一点，我们将创建一个可重用的文本输入组件：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code snippet, we created one object that takes some arguments
    related to the input attribute and assigned those arguments'' values to attributes''
    value:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们创建了一个对象，它接受与输入属性相关的一些参数，并将这些参数的值分配给属性的值：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we just need to add the preceding `TextInput` component like this in our
    `render` method, as you can see in the preceding code, rather than adding the
    label and input every time in our application; that shows the power of ReactJS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在我们的`render`方法中像这样添加前面的`TextInput`组件，正如你在前面的代码中所看到的，而不是在我们的应用程序中每次都添加标签和输入；这展示了ReactJS的强大之处。
- en: Using React-Bootstrap
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React-Bootstrap
- en: React-Bootstrap is an open source JavaScript framework rebuilt for React. It's
    similar to Bootstrap where we have ready-to-use components to integrate with React.
    It's purely reimplementation of Bootstrap framework components to React. React-Bootstrap
    has no dependency on any other framework, as Bootstrap JS has a dependency on
    jQuery. By using React-Bootstrap, we can ensure that there won't be external JavaScript
    calls to render the component that might be incompatible or extra efforts with
    the `ReactDOM.render`. However, we can still achieve the same functionality and
    look and feel as
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: React-Bootstrap是一个为React重建的开源JavaScript框架。它类似于Bootstrap，我们有现成的组件可以与React集成。这是Bootstrap框架组件在React中的纯重新实现。React-Bootstrap不依赖于任何其他框架，因为Bootstrap
    JS依赖于jQuery。通过使用React-Bootstrap，我们可以确保不会有外部JavaScript调用来渲染组件，这可能与`ReactDOM.render`不兼容或需要额外的工作。然而，我们仍然可以实现相同的功能和外观
- en: Twitter Bootstrap, but with much cleaner and less code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter Bootstrap，但代码更清晰，更少。
- en: Let's see how we can create our `Add Ticket Form` component with React-Bootstrap.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用React-Bootstrap创建我们的`Add Ticket Form`组件。
- en: 'First, follow the steps mentioned here to configure React-Bootstrap in your
    project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照这里提到的步骤在你的项目中配置React-Bootstrap：
- en: Install the React bootstrap npm package by running this below command
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装React bootstrap npm包
- en: npm install --save react-bootstrap
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm install --save react-bootstrap
- en: If you are using the create-react-app CLI, we don't need to worry about bootstrap
    CSS; it's already there, we don't need to include.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用create-react-app CLI，我们不需要担心bootstrap CSS；它已经存在，我们不需要包含。
- en: Now by using import keyword we need to add the reference of react-bootstrap
    components in react application.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过使用import关键字，我们需要在React应用程序中添加对react-bootstrap组件的引用。
- en: 'For Example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: import Button from 'react-bootstrap/lib/Button';
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: import Button from 'react-bootstrap/lib/Button';
- en: // or
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: // 或者
- en: import { Button } from 'react-bootstrap';
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: import { Button } from 'react-bootstrap';
- en: Add Ticket Form with React-Bootstrap
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React-Bootstrap添加工单表单
- en: Now, you may be wondering that since we have installed the React-Bootstrap and
    we have added the reference of React-Bootstrap in our project by using `import`
    statement, won't they conflict with each other? No, they will not. React-Bootstrap
    is compatible with the existing Bootstrap styles, so we don't need to worry about
    any conflicts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会想知道，既然我们已经安装了React-Bootstrap，并且已经通过使用`import`语句在我们的项目中添加了React-Bootstrap的引用，它们不会互相冲突吗？不，它们不会。React-Bootstrap与现有的Bootstrap样式兼容，因此我们不需要担心任何冲突。
- en: 'Look at this code for the `Add Ticket` component render method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Add Ticket`组件渲染方法的代码：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see in the preceding code, it looks cleaner than the Twitter Bootstrap
    component, because we can import the individual component from React-Bootstrap
    rather than including the entire library, such as `import { Button } from 'react-bootstrap';`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上述代码中所见，它看起来比Twitter Bootstrap组件更清晰，因为我们可以从React-Bootstrap中导入单个组件，而不是包含整个库，例如`import
    { Button } from 'react-bootstrap';`。
- en: 'Here''s the list of Supported Form Controls:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是支持的表单控件列表：
- en: '`<FieldGroup>` for custom component'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<FieldGroup>`用于自定义组件'
- en: '`<FormControl>` for `<input>`, `<textarea>`, and `<select>`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<FormControl>`用于`<input>`，`<textarea>`和`<select>`'
- en: '`<Checkbox>` for checkbox'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Checkbox>`用于复选框'
- en: '`<Radio>` for radio'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Radio>`用于单选按钮'
- en: '`FormControl.Static` (For Static text)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl.Static`（用于静态文本）'
- en: '`HelpBlock`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelpBlock`'
- en: Now it's up to you whether you want use React-Bootstrap or normal JSX components
    with Bootstrap styling.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由您决定是使用React-Bootstrap还是带有Bootstrap样式的普通JSX组件。
- en: For more detail, check out [https://react-bootstrap.github.io/components/forms/](https://react-bootstrap.github.io/components/forms/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请查看[https://react-bootstrap.github.io/components/forms/](https://react-bootstrap.github.io/components/forms/)。
- en: Firebase with React
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React的Firebase
- en: We are done creating a React form where you can raise the ticket into Helpdesk
    and save to Firebase. For this, now we need to integrate and initialize the Firebase
    in our existing application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个React表单，您可以在其中提出Helpdesk的工单并保存到Firebase。为此，现在我们需要在现有应用程序中集成和初始化Firebase。
- en: 'Here''s how it looks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它的样子是这样的：
- en: 'Added script tag at the bottom of our HTML:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML底部添加了脚本标签：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Copy the existing Firebase config code from the previous chapter into `firebase-config.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有的Firebase配置代码从上一章复制到`firebase-config.js`中：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also, add `Reactjs Form` into `react-form.js` so that our code looks clean
    and manageable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还要将`Reactjs Form`添加到`react-form.js`中，以使我们的代码看起来干净和可管理：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Props and state
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和状态
- en: 'Before we go into the practical, we should know what is state and what is props
    in React. In ReactJs, components translate your raw data into Rich HTML with the
    help of JSX, the props and state together build with that raw data to keep your
    UI consistent. Okay, let''s identify what exactly it is:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行实际操作之前，我们应该知道在React中状态和属性是什么。在ReactJs中，组件使用JSX将您的原始数据转换为丰富的HTML，属性和状态一起构建这些原始数据，以保持您的UI一致。好的，让我们确定它到底是什么：
- en: Props and state are both plain JS objects.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和状态都是普通的JS对象。
- en: They are triggered by a render update.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们由渲染更新触发。
- en: React manages the component state by calling `setState` (data, callback). This
    method will merge data into this state and rerenders the component to keep our
    UI up to date. For example, the state of the drop-down menu (visible or hidden).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 通过调用 `setState`（数据，回调）来管理组件状态。这种方法将数据合并到此状态中，并重新渲染组件，以保持我们的 UI 最新。例如，下拉菜单的状态（可见或隐藏）。
- en: React component props (properties) that don't change over time, for example,
    drop-down menu items. Sometimes components only take some data with this props
    method and render it, which makes your component stateless.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 组件属性（属性）随时间不会改变，例如下拉菜单项。有时组件只使用此属性方法获取一些数据并呈现它，这使得您的组件无状态。
- en: Using props and state together helps you make an interactive app.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和状态一起可以帮助您创建一个交互式应用程序。
- en: Read and Write Form data to Firebase Realtime Database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将表单数据读取和写入 Firebase 实时数据库。
- en: As we know, ReactJS components have their own props and state-like forms that
    support a
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，ReactJS 组件有自己的属性和类似状态的表单，支持
- en: 'few props that are affected via user interaction:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些受用户交互影响的属性：
- en: '`<input>` and `<textarea>`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input>` 和 `<textarea>`：'
- en: '| **Components** | **Supported Props** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **支持的属性** |'
- en: '| `<input>` and `<textarea>` | Value, defaultValue |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `<input>` 和 `<textarea>` | Value, defaultValue |'
- en: '| `<input>` type of checkbox or radio | checked, defaultChecked |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `<input>` 复选框或单选框类型 | checked, defaultChecked |'
- en: '| `<select>` | selected, defaultValue |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `<select>` | selected, defaultValue |'
- en: In an HTML `<textarea>` component, the value is set via children, but it can
    be set by value in React. The `onChange` prop is supported by all native components,
    such as other DOM events, and can listen to all bubble change events.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML `<textarea>` 组件中，值是通过 children 设置的，但在 React 中也可以通过 value 设置。`onChange`
    属性被所有原生组件支持，例如其他 DOM 事件，并且可以监听所有冒泡变化事件。
- en: As we've seen, the state and prop will give you the control to alter the value
    of the component and handle the state for that component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，状态和属性将使您能够改变组件的值并处理该组件的状态。
- en: Okay, now let's add some advanced features in our `Add Ticket form`, which can
    help you get the value from user input, and with the help of Firebase, we will
    save those values in the database.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的“添加工单表单”中添加一些高级功能，这些功能可以帮助您获取用户输入的值，并借助 Firebase，我们将这些值保存在数据库中。
- en: The Ref attribute
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ref 属性
- en: React provides `ref` non-DOM attributes to access the component. The ref attribute
    can be a callback function, and it will execute immediately after the component
    is mounted. So we will attach the ref attribute in our form element to fetch the
    values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了 `ref` 非 DOM 属性来访问组件。ref 属性可以是回调函数，并且它将在组件挂载后立即执行。因此，我们将在我们的表单元素中附加
    ref 属性以获取这些值。
- en: 'Let''s take a quick look at our component after adding the ref attribute:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 ref 属性后，让我们快速查看一下我们的组件：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s open the browser and see how our component looks:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开浏览器，看看我们的组件是什么样子的：
- en: '![](Images/32fcc449-e14e-4b5c-a31e-c7332613ab06.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/32fcc449-e14e-4b5c-a31e-c7332613ab06.png)'
- en: Firebase is working perfectly in our application as you can see the message
    displayed at the bottom of title "Hello world! This is My First JavaScript Firebase
    App"; it's coming from Firebase Realtime Database
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 在我们的应用程序中完美运行，因为您可以看到标题底部显示的消息“Hello world! This is My First JavaScript
    Firebase App”; 这是来自 Firebase 实时数据库
- en: Also, in the console, you can see the values when we submit the form.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在控制台中，您可以在提交表单时看到这些值。
- en: 'Now we need to save those value into the database:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些值保存到数据库中：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We do this to `Write` the `Form` data object to Firebase Realtime Database;
    `firebase.database.Reference` is an asynchronous listener to retrieve the data
    from Firebase. This listener will be triggered once on the initial state of that
    and when data gets changed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了将“表单”数据对象写入Firebase实时数据库；`firebase.database.Reference`是一个异步监听器，用于从Firebase检索数据。一旦触发此监听器，它将在初始状态和数据发生更改时触发。
- en: We can `Read` and `Write` the data from Firebase Database if we have access
    for that, because, by default, the database is restricted and no one can access
    it without setting up the authentication.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有权限，我们可以从Firebase数据库中读取和写入数据，因为默认情况下，数据库是受限制的，没有人可以在没有设置身份验证的情况下访问它。
- en: '`firebaseDb.ref().child(''helpdesk'').child(''tickets'').push(data);`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`firebaseDb.ref().child(''helpdesk'').child(''tickets'').push(data);`'
- en: 'In the preceding code, we used the `push()` method to save the data into the
    Firebase Database. It generates a unique key every time a new child is added to
    the specified Firebase reference. We can also use the `set()` method to save the
    data for specified reference; it will replace the existing data at that node path:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`push()`方法将数据保存到Firebase数据库中。每当向指定的Firebase引用添加新子项时，它都会生成一个唯一键。我们还可以使用`set()`方法将数据保存到指定引用的数据；它将替换该节点路径上的现有数据：
- en: '`firebaseDb.ref().child(''helpdesk'').child(''tickets'').set(data);`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`firebaseDb.ref().child(''helpdesk'').child(''tickets'').set(data);`'
- en: 'To `Retrieve` the update results when data is added, we need to attach the
    listener using the `on()` method, or in any case, if we want to detach the listener
    on the specific node, then we can do that by calling the `off()` method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在添加数据时检索更新结果，我们需要使用`on()`方法附加监听器，或者在任何情况下，如果我们想要在特定节点上分离监听器，那么我们可以通过调用`off()`方法来实现：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, if we want to read them once without listening to the changes, we
    can use the `once()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要一次读取它们而不监听更改，我们可以使用`once()`方法：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is useful when we don't expect any changes in the data or any active listening.
    For example, loading the user profile data on the initial load when it gets successfully
    authenticated in our app.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们不期望数据发生任何变化或任何主动监听时非常有用。例如，在我们的应用程序中成功验证用户配置文件数据时，加载用户配置文件数据时。
- en: To update the data, we have the `update()` method and for deleting, we just
    need to call the `delete()` method at the location of that data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新数据，我们有`update()`方法，要删除数据，我们只需要调用该数据位置的`delete()`方法。
- en: Both the `update()` and `set()` methods return a Promise, so we can use that
    to know when the write is committed to the database.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`和`set()`方法都返回一个Promise，因此我们可以使用它来知道写入是否提交到数据库。'
- en: 'Now, let''s submit the form and see the output in the browser console:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提交表单并在浏览器控制台中查看输出：
- en: '![](Images/622b4050-3082-45e9-8003-dd4fc0510600.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/622b4050-3082-45e9-8003-dd4fc0510600.png)'
- en: 'That looks great; now, let''s take a look our Firebase database:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒；现在，让我们来看看我们的Firebase数据库：
- en: '![](Images/dc50aee5-ca2d-4d27-a179-6668239912f8.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dc50aee5-ca2d-4d27-a179-6668239912f8.png)'
- en: We are able to see the data that we have submitted from the ReactJS form.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够看到我们从ReactJS表单提交的数据。
- en: 'Now we''ll display this data in a table format; for this, we need to create
    another React component and set the initial state of our component:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将以表格格式显示这些数据；为此，我们需要创建另一个React组件并设置组件的初始状态：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, using the `componentDidMount()` method, we will call the database by `ref()`,
    iterate the object, and set the state of the component with `this.setState()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`componentDidMount()`方法，我们将通过`ref()`调用数据库，迭代对象，并使用`this.setState()`设置组件的状态：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we will iterate the state of tickets in a table inside the render method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在渲染方法内部迭代票务状态并在表格中显示：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, the user can view the tickets'' list on Realtime whenever a new ticket
    is added to the database:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以在实时上查看票据列表，每当数据库中添加新的票据时：
- en: '![](Images/872c1d5d-a530-40d8-9087-87092a62647b.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/872c1d5d-a530-40d8-9087-87092a62647b.png)'
- en: 'Here''s the markup of our HTML page: `viewTickets.html`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们HTML页面的标记：`viewTickets.html`：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is the list of tickets added in Firebase Realtime Database:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Firebase实时数据库中添加的票据列表：
- en: '![](Images/7c74b96e-598d-4ff0-9dc5-c3a8be9f1d3b.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7c74b96e-598d-4ff0-9dc5-c3a8be9f1d3b.png)'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how JSX plays an important role in making custom components
    in React as well as making them very simple to visualize, understand, and write.
    We also saw how props and state play an important role in making components interactive
    as well as in DOM interaction to get the value from form fields. With the help
    of `refs`, we can call any public method and send a message to our particular
    child instance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了JSX在React中制作自定义组件以及使它们非常简单可视化、理解和编写方面起着重要作用。我们还看到了props和state在使组件交互以及在DOM交互中获取表单字段的值方面起着重要作用。借助`refs`，我们可以调用任何公共方法并向特定的子实例发送消息。
- en: Also, we explored the React-Bootstrap components by creating an `Add Ticket
    form`, which works well on all expected devices as well as on desktop browsers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过创建一个`Add Ticket form`来探索了React-Bootstrap组件，该表单在所有预期的设备上以及桌面浏览器上都能很好地工作。
- en: In addition, we saw how easy it is to use Firebase Realtime Database with a
    ReactJS application. With just a few lines of code, we can save the data to the
    Realtime Database and retrieve the list of tickets from the database in Realtime
    to make our application Realtime.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还看到了在ReactJS应用程序中使用Firebase实时数据库有多么容易。只需几行代码，我们就可以将数据保存到实时数据库，并实时从数据库中检索票据列表，使我们的应用程序实时化。
- en: In the next chapter, we will do React and Firebase setup on node.js environment
    and how we can use the Firebase OAuth Providers to add authentication in our application. we'll
    also explore the react routing for navigation
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在node.js环境中进行React和Firebase设置，以及如何使用Firebase OAuth提供程序在我们的应用程序中添加身份验证。我们还将探索用于导航的React路由
