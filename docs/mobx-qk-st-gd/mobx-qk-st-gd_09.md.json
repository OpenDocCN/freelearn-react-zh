["```jsx\nclass Coupon {\n    @observable isValid = false;\n\n    /*...*/ }\n\nclass CouponManager {\n    @observable.ref coupons = [];\n\n    @computed\n  get validCoupons() {\n        return this.coupons.filter(coupon => coupon.isValid);\n    }\n\n    /*...*/ }\n\nclass ShoppingCart {\n    @observable.shallow items = [];\n\n    couponManager = new CouponManager();\n\n    @computed\n  get coupons() {\n        return this.couponManager.validCoupons;\n    }\n\n    @computed\n  get description() {\n        return `Cart has ${this.items.length} item(s) with ${\n            this.coupons.**length**\n  } coupon(s) applied.`;\n    }\n\n    /*...*/ }\n```", "```jsx\nclass Atom {\n    observers = [];\n\n reportObserved() {}\n reportChanged() {}\n\n    /* ... */ }\n```", "```jsx\nimport { autorun, **$mobx**, **getDependencyTree** } from 'mobx';\n\nconst cart = new ShoppingCart();\nconst disposer = autorun(() => {\n    console.log(cart.description);\n});\n\nconst descriptionAtom = cart[$mobx].values.get('description'); console.log(getDependencyTree(descriptionAtom));\n```", "```jsx\n{\n    name: 'ShoppingCart@16.description',\n    dependencies: [\n        { name: 'ShoppingCart@16.items' },\n        { name: 'ShoppingCart@16.items' },\n        {\n            name: 'ShoppingCart@16.coupons',\n            dependencies: [\n                {\n                    name: 'CouponManager@19.validCoupons',\n                    dependencies: [{ name: 'CouponManager@19.coupons' }],\n                },\n            ],\n        },\n    ],\n};\n```", "```jsx\nimport { createAtom, autorun } from 'mobx';\n\nclass Clock {\n\n    constructor() {\n this.atom = createAtom(\n 'Clock',\n () => {\n this.startTicking();\n },\n () => {\n this.stopTicking();\n },\n );\n\n        this.intervalId = null;\n    }\n\n    startTicking() {\n        console.log('Clock started');\n        this.tick();\n        this.intervalId = setInterval(() => this.tick(), 1000);\n    }\n\n    stopTicking() {\n        clearInterval(this.intervalId);\n        this.intervalId = null;\n\n        console.log('Clock stopped');\n    }\n\n    tick() {\n this.atom.reportChanged();\n    }\n\n    get() {\n this.atom.reportObserved();\n        return new Date();\n    }\n}\n\nconst clock = new Clock();\n\nconst disposer = autorun(() => {\n console.log(clock.get());\n});\n\nsetTimeout(disposer, 3000);\n```", "```jsx\nclass ObservableValue extends Atom {\n    value;\n\n    get() {\n        /* ... */\n this.reportObserved();\n    }\n\n    set(value) {\n\n        /* Pass through interceptor, which may modify the value (*newValue*) ... */\n\n        this.value = newValue;\n this.reportChanged();\n    }\n\n    intercept(handler) {}\n    observe(listener, fireImmediately) {}\n}\n```", "```jsx\nimport {observable} from 'mobx';\n\nconst count = observable.box(0);\n\ncount.intercept(change => {\n    console.log('Intercepted:', change);\n\n    return change; // No change\n // Prints // Intercepted: {object: ObservableValue$$1, type: \"update\", newValue: 1} // Intercepted: {object: ObservableValue$$1, type: \"update\", newValue: 2} });\n\ncount.observe(change => {\n    console.log('Observed:', change);\n    // Prints\n // Observed: {object: ObservableValue$$1, type: \"update\", newValue: 1} // Observed: {object: ObservableValue$$1, type: \"update\", newValue: 2, oldValue: 1} });\n\n// Increment count.set(count.get() + 1);\n\ncount.set(count.get() + 1);\n```", "```jsx\nclass ComputedValue {\n    get() {\n        /* ... */\n reportObserved(this);\n        /* ... */\n    }\n\n    set(value) { /* rarely applicable */ }\n\n    observe(listener, fireImmediately) {}\n}\n```", "```jsx\nclass Infinite {\n    @observable counter = 0;\n\n    constructor() {\n        reaction(\n () => this.counter,\n            counterValue => {\n                console.log(`Counter is ${counterValue}`);\n this.spinLoop();\n            },\n        );\n    }\n\n    @action\n  spinLoop() {\n        this.counter = this.counter + 1;\n    }\n}\n\nnew Infinite().spinLoop();\n\n/* Console log:\n*Reaction doesn't converge to a stable state after 100 iterations. Probably there is a cycle in the reactive function: Reaction[Reaction@14]* */\n```"]