- en: Exploring mobx-utils and mobx-state-tree
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索mobx-utils和mobx-state-tree
- en: As you start going deeper into the world of MobX, you will realize that certain
    types of use cases recur quite often. The first time you solve them, there is
    a definite sense of achievement. However, after the fifth time, you want to standardize
    the solution. `mobx-utils` is an NPM package that gives you several standard utilities
    to handle common use cases in MobX.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始深入了解MobX的世界时，你会意识到某些类型的用例经常重复出现。第一次解决它们时，会有一种明确的成就感。然而，第五次之后，你会想要标准化解决方案。`mobx-utils`是一个NPM包，为你提供了几个标准实用程序，用于处理MobX中的常见用例。
- en: To push the level of standardization even further, we can bring more structured
    opinions into our MobX solutions. These opinions have been formed out of several
    years of MobX usage, and carry a variety of ideas for rapid development. This
    is all possible with the `mobx-state-tree` NPM package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步推动标准化水平，我们可以将更多结构化的意见引入我们的MobX解决方案中。这些意见是在多年的MobX使用中形成的，并包含了快速开发的各种想法。这一切都可以通过`mobx-state-tree` NPM包实现。
- en: 'In this chapter, we will cover the following packages in greater detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地介绍以下包：
- en: '`mobx-utils` for a tool belt of utility functions'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mobx-utils`提供了一系列实用功能'
- en: '`mobx-state-tree` (**MST**) for an opinionated MobX'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mobx-state-tree`（**MST**）是一个有意见的MobX'
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在系统上安装Node.js。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter08](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter08)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter08](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter08)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际操作：
- en: '[http://bit.ly/2LiFSJO](http://bit.ly/2LiFSJO)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2LiFSJO](http://bit.ly/2LiFSJO)'
- en: The utility functions of mobx-utils
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mobx-utils的实用功能
- en: '`mobx-utils` provides a variety of utility functions that can simplify programming
    tasks in MobX. You can install `mobx-utils` using `npm` or `yarn`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-utils`提供了各种实用功能，可以简化MobX中的编程任务。你可以使用`npm`或`yarn`安装`mobx-utils`：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the rest of this section, we will focus on some utilities that are frequently
    used. These include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将重点介绍一些经常使用的实用程序。其中包括以下内容：
- en: '`fromPromise()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromPromise()`'
- en: '`lazyObservable()`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazyObservable()`'
- en: '`fromResource()`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromResource()`'
- en: '`now()`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now()`'
- en: '`createViewModel()`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createViewModel()`'
- en: Visualizing async-operations with fromPromise()
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fromPromise()可视化异步操作
- en: 'Promises, a way of life in JavaScript, are great for dealing with asynchronous
    operations. When representing the state of operations on the React UI, we have
    to ensure each of the three states of a promise is handled. This includes the
    state when the promise is `pending` (operation in progress), `fulfilled` (operation
    completed successfully), or `rejected` (in case of failures). `fromPromise()`
    is a convenient way to handle a promise, and gives a nice API to visually represent
    the three states:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，promise是处理异步操作的好方法。在表示React UI上的操作状态时，我们必须确保处理promise的三种状态中的每一种。这包括promise处于`pending`（操作进行中）状态时，`fulfilled`（操作成功完成）状态时，或者`rejected`（失败）状态时。`fromPromise()`是处理promise的一种便利方式，并提供了一个很好的API来直观地表示这三种状态：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`promiseLike`: instance of `Promise` or `(resolve, reject) => { }`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`promiseLike`：`Promise`的实例或`(resolve, reject) => { }`'
- en: '`fromPromise()` wraps the given promise and gives back a new, MobX-charged promise
    with some additional observable properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromPromise()`包装给定的promise，并返回一个新的、带有额外可观察属性的、MobX充电的promise：'
- en: '`state`: One of the three string values: `pending`, `fulfilled`, or `rejected`:
    These are also available as constants on the `mobx-utils` package: `mobxUtils.PENDING`,
    `mobxUtils.FULFILLED`, and `mobxUtils.REJECTED`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：三个字符串值之一：`pending`、`fulfilled`或`rejected`：这些也作为`mobx-utils`包的常量可用：`mobxUtils.PENDING`、`mobxUtils.FULFILLED`和`mobxUtils.REJECTED`。'
- en: '`value`: The resolved `value` or the `rejected` error. Use `state` to distinguish
    the value.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：已解析的`value`或`rejected`错误。使用`state`来区分值。'
- en: '`case({pending, fulfilled, rejected})`: This is used to provide the React components
    for the three states.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case({pending, fulfilled, rejected})`：这用于为三种状态提供React组件。'
- en: 'Let''s see all of this in action with an example. We will create a simple `Worker` class
    that performs some operation, which can randomly fail. Here is the `Worker` class
    that tracks the operation by calling `fromPromise()`. Notice that we are passing
    a `promise` as argument into `fromPromise()`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看所有这些。我们将创建一个简单的`Worker`类，执行一些操作，这些操作可能会随机失败。这是跟踪操作的`Worker`类，通过调用`fromPromise()`来调用操作。请注意，我们将一个`promise`作为参数传递给`fromPromise()`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To visualize this operation, we can leverage the `case()` API to show the corresponding
    React component for each state. This can be seen in the following code. As the
    operation progresses from `pending` to `fulfilled` or `rejected`, these states
    will be rendered with the correct React component. For the `fulfilled` and `rejected`
    states, the resolved `value` or the `rejected` `error` is passed in as the first
    argument:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这个操作，我们可以利用`case()` API来显示每个状态对应的React组件。这可以在以下代码中看到。随着操作从`pending`到`fulfilled`或`rejected`的进展，这些状态将以正确的React组件呈现。对于`fulfilled`和`rejected`状态，已解析的`value`或`rejected`
    `error`作为第一个参数传入：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead of the `case()` function, we could have also switched manually on the
    observable `state` property. In fact, `case()` does that internally.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以手动切换可观察的`state`属性，而不是使用`case()`函数。实际上，`case()`在内部执行这个操作。
- en: Using lazyObservable() for deferred updates
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`lazyObservable()`进行延迟更新
- en: 'For operations that are expensive to perform, it makes sense to defer them
    until needed. With `lazyObservable()`, you can track the result of these operations
    and update only when needed. It takes in a function that performs the computation
    and pushes values when ready:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行代价高昂的操作，将其推迟到需要时是有意义的。使用`lazyObservable()`，您可以跟踪这些操作的结果，并在需要时更新。它接受一个执行计算并在准备就绪时推送值的函数：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `sink` is the callback to be invoked to push the value onto `lazyObservable`.
    The lazy-observable can also start with some `initialValue`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sink`是要调用的回调函数，将值推送到`lazyObservable`上。延迟可观察对象也可以以一些`initialValue`开始。
- en: The current value of `lazyObservable()` can be retrieved using `result.current()`.
    Once a lazy-observable has been updated, `result.current()` will have some value. To
    update the lazy-observable again, you can use `result.refresh()`. This will re-invoke
    the computation and eventually push new values via the `sink` callback. Note that
    the `sink` callback can be invoked as many times as needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`result.current()`来检索`lazyObservable()`的当前值。一旦延迟可观察对象已更新，`result.current()`将有一些值。要再次更新延迟可观察对象，可以使用`result.refresh()`。这将重新调用计算，并最终通过`sink`回调推送新值。请注意，`sink`回调可以根据需要调用多次。
- en: 'In the following snippet, you can see the use of `lazyObservable()` to update
    the value of the operation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，您可以看到使用`lazyObservable()`来更新操作的值：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The call to the `current()` method is tracked by MobX, so make sure you only
    call it when needed. The use of this method inside `render()` causes MobX to re-render
    the component. After all, `render()` of a component translates to a reaction in
    MobX, which re-evaluates whenever any of its tracked observables change.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MobX跟踪对`current()`方法的调用，因此请确保仅在需要时调用它。在`render()`中使用此方法会导致MobX重新渲染组件。毕竟，组件的`render()`在MobX中转换为reaction，每当其跟踪的observable发生变化时重新评估。
- en: 'To use the lazy-observable inside a React component (an *observer*), we rely
    on the `current()` method to fetch its value. MobX will track this value and re-render
    the component whenever it changes. Notice in the `onClick` handler of the button,
    we are causing an update of the lazy-observable by calling its `refresh()` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在React组件（*observer*）中使用lazy-observable，我们依赖于`current()`方法来获取其值。MobX将跟踪此值，并在其更改时重新渲染组件。请注意，在按钮的`onClick`处理程序中，我们通过调用其`refresh()`方法来更新lazy-observable：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A generalized lazyObservable() with fromResource()
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fromResource()的通用lazyObservable()
- en: 'There is also a more generalized form of `lazyObservable()` called `fromResource()`.
    Similar to `lazyResource()`, it takes in a function with the `sink` callback.
    This acts as a *subscribing* function, which is invoked only when the resource
    is actually requested. Additionally, it takes a second argument, an *unsubscribing*
    function, which can be used to clean up when the resource is no longer needed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更一般化的`lazyObservable()`形式，称为`fromResource()`。类似于`lazyResource()`，它接受一个带有`sink`回调的函数。这充当*订阅*函数，仅在实际请求资源时调用。此外，它接受第二个参数，*取消订阅*函数，可用于在不再需要资源时进行清理：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`fromResource()` gives back an observable which will start fetching values
    when its `current()` method is invoked the first time. It gives back an observable
    that also has the `dispose()` method to stop updating values.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromResource()` 返回一个observable，当第一次调用它的`current()`方法时，它将开始获取值。它返回一个observable，还具有`dispose()`方法来停止更新值。'
- en: 'In the following snippet, you can see a `DataService` class relying on `fromResource()`
    to manage its WebSocket connection. The value of the data can be retrieved with
    `data.current()`. Here, *data* acts as the lazy-observable. In the *subscribing*
    function, we set up our WebSocket and subscribe to a specific channel. We unsubscribe
    from this channel in the *unsubscribing* function of `fromResource()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您可以看到一个`DataService`类依赖于`fromResource()`来管理其WebSocket连接。数据的值可以使用`data.current()`来检索。这里，*data*充当lazy-observable。在*订阅*函数中，我们设置了WebSocket并订阅了特定频道。我们在`fromResource()`的*取消订阅*函数中取消订阅此频道：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can explicitly dispose of the resource with the `dispose()` method. However,
    MobX is smart enough to know when there are no more observers of this resource
    and automatically calls the *unsubscribe *function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`dispose()`方法显式处理资源。但是，MobX足够聪明，知道没有更多观察者观察此资源时，会自动调用*取消订阅*函数。
- en: 'A special kind of lazy-observable provided by `mobx-utils` is `now(interval:
    number)`. It treats time as an observable and updates at the given interval. You
    can retrieve its value by simply calling `now()`, which, by default, updates every
    second. By the virtue of being an observable, it will also cause any reaction
    to execute every second. Internally, `now()` uses the `fromResource()` utility
    to manage the timer.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'mobx-utils提供的一种特殊类型的lazy-observable是`now(interval: number)`。它将时间视为observable，并以给定的间隔更新。您可以通过简单调用`now()`来检索其值，默认情况下每秒更新一次。作为observable，它还会导致任何reaction每秒执行一次。在内部，`now()`使用`fromResource()`实用程序来管理计时器。'
- en: A view model to manage edits
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理编辑的视图模型
- en: In a data-entry-based application, it is quite common to have forms to accept
    a variety of fields. In these forms, the original model is not mutated until the
    user submits the form. This allows the user to cancel out of the editing process
    and go back to the previous values. A scenario like this requires creating a clone
    of the original model and pushing the edits upon submit. Although this technique
    is not terribly complex, it does add some boilerplate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数据输入的应用程序中，通常会有表单来接受各种字段。在这些表单中，原始模型直到用户提交表单之前都不会发生变化。这允许用户取消编辑过程并返回到先前的值。这种情况需要创建原始模型的克隆，并在提交时推送编辑。尽管这种技术并不是非常复杂，但它确实增加了一些样板文件。
- en: '`mobx-utils` provides a handy utility called `createViewModel()` that is tailor-made
    for this scenario:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-utils`提供了一个方便的实用程序，名为`createViewModel()`，专门为这种情况量身定制：'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`model` is the original model containing observable properties. `createViewModel()`
    wraps this model and proxies all the reads and writes. This utility has some interesting
    characteristics, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`model`是包含可观察属性的原始模型。`createViewModel()`包装了这个模型并代理了所有的读取和写入。这个实用程序具有一些有趣的特性，如下：'
- en: As long as a property of `viewModel` is not changed, it will return the value
    from the original model. After a change, it will return the updated value and
    also treat `viewModel` as dirty.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要`viewModel`的属性没有更改，它将返回原始模型中的值。更改后，它将返回更新后的值，并将`viewModel`视为已修改。
- en: 'To finalize the updated values on the original model, you must call the `submit()`
    method of `viewModel`*.* To reverse any changes, you can invoke the `reset()`
    method. To revert a single property, use `resetProperty(propertyName: string)`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要最终确定原始模型上的更新值，必须调用`viewModel`的`submit()`方法。要撤消任何更改，可以调用`reset()`方法。要恢复单个属性，请使用`resetProperty(propertyName:
    string)`。'
- en: 'To check if `viewModel` is dirty, use the `isDirty` property. To check if a
    single property is dirty, use `isPropertyDirty(propertyName: string)`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要检查`viewModel`是否被修改，请使用`isDirty`属性。要检查单个属性是否被修改，请使用`isPropertyDirty(propertyName:
    string)`。'
- en: To get the original model, use the handy `model()` method.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取原始模型，请使用方便的`model()`方法。
- en: The advantage of using `createViewModel()` is that you can treat the whole editing
    process as a single transaction. It is final only when `submit()` is invoked.
    This allows you to cancel out prematurely and retain the original model in its
    previous state.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`createViewModel()`的优势在于，您可以将整个编辑过程视为单个事务。只有在调用`submit()`时才是最终的。这允许您过早取消并保留原始模型在其先前状态。
- en: 'In the following example, we are creating a `viewModel` that wraps the `FormData`
    instance and logs the `viewModel` and `model` properties. You will notice the
    proxying effect of `viewModel` and how values propagate back to the model upon
    `submit()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在创建一个包装`FormData`实例并记录`viewModel`和`model`属性的`viewModel`。您将注意到`viewModel`的代理效果以及值在`submit()`时如何传播回模型：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The log from `autorun()` is as follows. You can see the effect of `submit()`
    and `reset()` on the `viewModel.name` property:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`autorun()`的日志如下。您可以看到`submit()`和`reset()`对`viewModel.name`属性的影响：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is lot more to discover
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有很多可以发现的地方
- en: The handful of utilities described here is by no means exhaustive. `mobx-utils`
    provides many more utilities, and we strongly encourage you to take a look at
    the GitHub project ([https://github.com/mobxjs/mobx-utils](https://github.com/mobxjs/mobx-utils))
    to discover the remaining utility functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的一些实用程序绝不是详尽无遗的。`mobx-utils`提供了更多实用程序，我们强烈建议您查看GitHub项目（[https://github.com/mobxjs/mobx-utils](https://github.com/mobxjs/mobx-utils)）以发现其余的实用功能。
- en: There are functions to convert between RxJS streams and MobX Observables, *processor-functions*
    that can perform an operation anytime an observable-array is appended, a variant
    of the MobX `when()`, which automatically disposes after a timeout, and many more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些函数可以在RxJS流和MobX Observables之间进行转换，*processor-functions*可以在可观察数组附加时执行操作，MobX的变体`when()`，它在超时后自动释放，等等。
- en: An opinionated MobX with mobx-state-tree
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个有主见的MobX与mobx-state-tree
- en: 'MobX is very flexible in how you organize your state and apply the various
    actions and reactions. However, it does leave some questions for you to answer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MobX在组织状态和应用各种操作和反应方面非常灵活。然而，它确实留下了一些问题需要你来回答：
- en: Should classes be used or just plain objects with `extendObservable()`?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用类还是只是带有`extendObservable()`的普通对象？
- en: How should the data be normalized?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应该如何规范化？
- en: How to deal with circular references when serializing the state?
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在序列化状态时如何处理循环引用？
- en: And many more
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有很多
- en: '`mobx-state-tree` is a package that gives you prescriptive guidance for organizing
    and structuring your observable state. Adopting the MST style of thinking gives
    you several benefits out of the box. In this section, we will explore this package
    and its benefits.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-state-tree`是一个提供了组织和结构化可观察状态的指导性指导的包。采用MST的思维方式会让你从一开始就获得几个好处。在本节中，我们将探讨这个包及其好处。'
- en: Models – properties, views, and actions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型 - 属性、视图和操作
- en: '`mobx-state-tree` as the name suggests, organizes the state in a tree of models.
    It''s a model-first approach, where each model defines the state that needs to
    be captured. Defining the model adds the ability to type-check the model assignments
    at runtime and guard you against inadvertent changes. Combining the runtime checks
    with the use of a language like TypeScript also gets you compile-time (or rather,
    design-time) type-safety. With a strictly typed model, `mobx-state-tree` gives
    you safe guarantees and ensures the integrity and constraints of your typed-models.
    This in itself is a huge benefit, especially when dealing with a dynamic language
    like JavaScript.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-state-tree`正如其名称所示，将状态组织在模型树中。这是一种以模型为先的方法，其中每个模型定义了需要捕获的状态。定义模型添加了在运行时对模型分配进行类型检查的能力，并保护您免受无意的更改。将运行时检查与像TypeScript这样的语言的使用结合起来，还可以获得编译时（或者说是设计时）类型安全性。通过严格类型化的模型，`mobx-state-tree`为您提供了安全的保证，并确保了您的类型模型的完整性和约束。这本身就是一个巨大的好处，特别是在处理像JavaScript这样的动态语言时。'
- en: 'Let''s put MST into action with a simple model for `Todo`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的`Todo`模型来实现MST：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A model describes the shape of data it holds. In case of the `Todo` model, it
    only needs a `title` *string* and a *boolean* `done` property. Note that we assigned
    our model to a capitalized name (`Todo`). This is because MST really defines a
    type and not an instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模型描述了它所持有的数据的形状。在`Todo`模型的情况下，它只需要一个`title` *string*和一个*boolean* `done`属性。请注意，我们将我们的模型分配给了一个大写的名称（`Todo`）。这是因为MST实际上定义了一个类型，而不是一个实例。
- en: 'All of the built-in types in MST are part of the `types` namespace. The `types.model()`
    method takes two arguments: an optional string *name* (used for debugging and
    error reporting) and an *object* defining the various properties of the type.
    All of these properties will be qualified with strict types. Let''s try creating
    an instance of this model:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MST中的所有内置类型都是`types`命名空间的一部分。`types.model()`方法接受两个参数：一个可选的字符串*name*（用于调试和错误报告）和一个定义类型各种属性的*object*。所有这些属性都将被严格类型化。让我们尝试创建这个模型的一个实例：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how we have passed the same structure of data into `Todo.create()` as
    defined in the model. Passing any other kind of data will result in MST throwing
    type-errors. Creating an instance of the model has also made all its properties
    into observables. This means we can now use the full power of the MobX API.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将与模型中定义的相同的数据结构传递给了 `Todo.create()`。传递任何其他类型的数据将导致 MST 抛出类型错误。创建模型的实例也使其所有属性变成了可观察的。这意味着我们现在可以使用
    MobX API 的全部功能。
- en: 'Let''s create a simple reaction that will log the changes to the `todo` instance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的反应，记录对 `todo` 实例的更改：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you run this code, you will notice an exception being thrown, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，您会注意到一个异常被抛出，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This happens because we have modified the `todo.done` property outside of an
    action. You will recollect from earlier chapters that it''s a good practice to
    wrap all observable-mutations inside an action. In fact, there is even a MobX
    API: `configure({ enforceActions: ''strict'' })`, to ensure this happens. MST
    is very *protective* about the data in its state-tree and mandates the use of
    actions for all mutations.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '这是因为我们在动作之外修改了 `todo.done` 属性。您会回忆起前几章中的一个良好实践是将所有可观察的变化封装在一个动作内。事实上，甚至有一个
    MobX API：`configure({ enforceActions: ''strict'' })`，以确保这种情况发生。MST 对其状态树中的数据非常*保护*，并要求对所有变化使用动作。'
- en: This may sound very rigid, but it does come with added benefits. For example,
    the use of actions allows MST to provide first-class support for middleware. Middleware
    can *intercept* any changes happening to the state-tree and make it trivial to
    implement features such as *Logging, Time Traveling*, *Undo*/*Redo*, *Database
    Synchronization*, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来非常严格，但它确实带来了额外的好处。例如，使用动作允许 MST 提供对中间件的一流支持。中间件可以*拦截*发生在状态树上的任何更改，并使实现诸如*日志记录、时间旅行*、*撤销*/*重做*、*数据库同步*等功能变得微不足道。
- en: Defining actions on the model
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型上定义动作
- en: 'The model type `Todo` that we created earlier can be extended with a chained
    API. `actions()` is one such API that can be used to extend the model type with
    all the action definitions. Let''s do that for our `Todo` type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的模型类型 `Todo` 可以通过链接的 API 进行扩展。`actions()` 就是这样一个 API，可以用来扩展模型类型的所有动作定义。让我们为我们的
    `Todo` 类型做这件事：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `actions()` method takes in a function that receives the instance of the
    model as its argument. Here, we are calling it `self`. This function is supposed
    to return a key-value map that defines all the actions. In the preceding snippet,
    we are leveraging the object-literal syntax of ES2015 to make the actions object
    look more readable. There are some striking benefits of this style of accepting
    the actions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions()` 方法接受一个函数作为参数，该函数接收模型实例作为其参数。在这里，我们称之为 `self`。这个函数应该返回一个定义所有动作的键值映射。在前面的片段中，我们利用了
    ES2015 的对象字面量语法，使动作对象看起来更易读。接受动作的这种风格有一些显著的好处：'
- en: The use of a function allows you to create a closure that can be used to track
    the private state that is only used by the actions. For example, a WebSocket connection
    that is set up inside one of the actions that should never be exposed to the outside
    world.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数允许您创建一个闭包，用于跟踪只被动作使用的私有状态。例如，设置在其中一个动作内部的 WebSocket 连接，不应该暴露给外部世界。
- en: By passing an instance of the model to `actions()`, you can guarantee that the
    `this` pointer is always correct. You never have to worry about the context of
    the functions defined in `actions()` anymore. The `toggle()` action makes use
    of `self` to mutate the model instance.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将模型的实例传递给 `actions()`，您可以保证 `this` 指针始终是正确的。您再也不必担心在 `actions()` 中定义的函数的上下文了。`toggle()`
    动作利用 `self` 来改变模型实例。
- en: The actions defined can be invoked directly on the model instance, which is
    what we do with `todo.toggle()`. MST has no more complaints about direct mutation,
    and `autorun()` will also fire when `todo.done` changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的actions可以直接在模型实例上调用，这就是我们在`todo.toggle()`中所做的。MST不再对直接突变提出异议，当`todo.done`改变时，`autorun()`也会触发。
- en: Creating derived information with views
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图创建派生信息
- en: 'Similar to actions, we can also extend the model type with `views()`. Derived
    information in a model is defined using `views()` in MST. Just like the `actions()`
    method, it can be chained to the model type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与actions类似，我们还可以使用`views()`扩展模型类型。在MST中，模型中的派生信息是使用`views()`来定义的。就像`actions()`方法一样，它可以链接到模型类型上：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are two views introduced on the `Todo` type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Todo`类型上引入了两个视图：
- en: '`asMarkdown()` is a *getter* that translates to a MobX computed-property. Like
    every computed-property, its output is cached.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asMarkdown()`是一个*getter*，它转换为一个MobX计算属性。像每个计算属性一样，它的输出被缓存。'
- en: '`contains()` is a regular function whose output is not cached. However, it
    does have the ability to re-execute when used in a reactive context such as `reaction()`
    or `autorun()`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains()`是一个常规函数，其输出不被缓存。然而，它具有在响应式上下文中重新执行的能力，比如`reaction()`或`autorun()`。'
- en: '`mobx-state-tree` introduces a very strict concept of models with clearly defined
    *state*, *actions*, and *derivations*. If you feel uncertain about structuring
    your code in MobX, MST can help you apply the MobX philosophy with clear guidance.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-state-tree`引入了一个非常严格的模型概念，其中明确定义了*state*、*actions*和*derivations*。如果你对在MobX中构建代码感到不确定，MST可以帮助你应用MobX的理念并提供清晰的指导。'
- en: Fine-tuning primitive types
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微调原始类型
- en: 'The single model type that we have seen so far is just the beginning and can
    barely be called a tree. We can expand the domain-model to make it more realistic.
    Let''s add a `User` type, who will be creating the `todo` items:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的单一模型类型只是一个开始，几乎不能称为树。我们可以扩展领域模型使其更加真实。让我们添加一个`User`类型，他将创建`todo`项目：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are some interesting details in the preceding definition, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的定义中有一些有趣的细节，如下所示：
- en: 'The `age` property has been defined as the constant `42`, which translates
    to a default value for `age`. When no value is provided for a user, it will be
    set to this default value. Additionally, MST is smart enough to derive the type
    to be `number`. This works well for all the primitive types, where the type of
    the default value will be inferred as the type of the property. Also, by giving
    a default value, we are suggesting that the `age` property is optional. A more
    verbose form of declaring the property is: `types.optional(types.number, 42)`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`属性被定义为常量`42`，这对应于`age`的默认值。当没有为用户提供值时，它将被设置为这个默认值。此外，MST足够聪明，可以推断类型为`number`。这对于所有原始类型都适用，其中默认值的类型将被推断为属性的类型。此外，通过给出默认值，我们暗示`age`属性是可选的。声明属性的更详细形式是：`types.optional(types.number,
    42)`。'
- en: The `twitter` property has a more complicated definition but can be broken down
    easily. `types.maybe()` suggests that a `twitter` handle is optional, so it could
    be *undefined*. When a value is provided, it must be of type string. But not any
    string; only strings that match the provided regular-expression. This gives you
    runtime type-safety and rejects invalid Twitter handles such as `Calvin & Hobbes` or
    an empty string.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twitter`属性有一个更复杂的定义，但可以很容易地分解。`types.maybe()`表明`twitter`句柄是可选的，因此它可能是*undefined*。当提供值时，它必须是字符串类型。但不是任何字符串；只有与提供的正则表达式匹配的字符串。这为您提供了运行时类型安全性，并拒绝无效的Twitter句柄，如`Calvin
    & Hobbes`或空字符串。'
- en: The type system provided by MST is very powerful and can handle a variety of
    complex type specifications. It also composes well, and gives you a functional
    approach to combining many smaller types into a larger type definition. These
    type specifications give you runtime safety and ensure the integrity of your domain
    model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MST提供的类型系统非常强大，可以处理各种复杂的类型规范。它还很好地组合，并为您提供了一种将许多较小类型组合成较大类型定义的功能方法。这些类型规范为您提供了运行时安全性，并确保了您的领域模型的完整性。
- en: Composing trees
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合树
- en: 'Now that we have the `Todo` and `User` types, we can define the top-level `App`
    type that composes the types defined previously. The `App` type represents the
    state of the application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Todo`和`User`类型，我们可以定义顶层的`App`类型，它组合了先前定义的类型。`App`类型代表应用程序的状态。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have defined the `App` type by using *higher-order types* (types that take
    a type as input and create a new type). In the preceding snippet, `types.map()`
    and `types.array()` create these higher-order types.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用*高阶类型*（接受类型作为输入并创建新类型的类型）定义了`App`类型。在前面的片段中，`types.map()`和`types.array()`创建了这些高阶类型。
- en: Creating an instance of the `App` type is just a matter of providing the right
    JSON payload. As long as the structure matches the type-specification, MST will
    have no problem in constructing the model instances at runtime.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`App`类型的实例只是提供正确的JSON负载的问题。只要结构与类型规范匹配，MST在运行时构建模型实例时就不会有问题。
- en: 'Remember: The shape of the data will always be validated by MST. It will never
    allow data updates that don''t match the model''s type specification.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：数据的形状始终会被MST验证。它永远不会允许不符合模型类型规范的数据更新。
- en: Notice in the preceding snippet, we are able to call the `app.todos[0].toggle()`
    method seamlessly. This is because MST was able to build the `app` instance successfully
    and wrap the JSON nodes with proper types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的片段中，我们能够无缝调用`app.todos[0].toggle()`方法。这是因为MST能够成功构建`app`实例并用适当的类型包装JSON节点。
- en: '`mobx-state-tree` elevates the importance of modeling your application state.
    Defining the proper types for the various entities in your application is paramount
    for its structural and data integrity. A nice way to get started is to encode
    the JSON you receive from the server in MST models. The next step is to ***fatten*** the
    model by adding more rigid typing, and attaching actions and views.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-state-tree`提升了对建模应用程序状态的重要性。为应用程序中的各种实体定义适当的类型对于其结构和数据完整性至关重要。一个很好的开始方式是将从服务器接收到的JSON编码为MST模型。下一步是通过添加更严格的类型、附加操作和视图来***加强***模型。'
- en: References and identifiers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用和标识符
- en: So far, this chapter has been entirely about capturing the state of the application
    in a *tree*. Trees have many interesting properties and are easy to comprehend
    and explore. But often, when one starts to apply a new technology to real problem
    domains, it turns out that trees are conceptually not sufficient to describe problem
    domains. For example, *friendship-relationships* are bidirectional and don't fit
    unidirectional trees. Dealing with relationships that are not *compositional*
    in nature, but rather *associative*, often requires introducing new abstraction
    layers and techniques such as *data normalization*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章一直在完全讨论在*树*中捕获应用程序的状态。树具有许多有趣的属性，易于理解和探索。但通常，当一个人开始将新技术应用于实际问题领域时，往往会发现树在概念上不足以描述问题领域。例如，*友谊关系*是双向的，不适合单向树。处理不是*组合*性质的关系，而是*关联*性质的关系，通常需要引入新的抽象层和技术，如*数据规范化*。
- en: A quick example of such a relationship can be introduced in our application
    by giving `Todo` an `assignee` property. Now, it is clear that `Todo` does not *own* its `assignee`, and
    neither is the inverse true; *todos* are not owned by a single user, as they can
    be *reassigned* later. So when composition does not suffice to describe the relationship,
    we often fall back to using *foreign keys* to describe the relationships.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中可以通过为`Todo`添加一个`assignee`属性来快速介绍这种关系。现在，很明显`Todo`并不*拥有*它的`assignee`，反之亦然；*todos*不是由单个用户拥有的，因为它们可以稍后被*重新分配*。因此，当组合不足以描述关系时，我们经常会退回到使用*外键*来描述关系。
- en: 'In other words, the JSON of a `Todo` item could be like the following code,
    where the `assignee` field of `Todo` corresponds to the `userid` field of a `User` object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`Todo`项的JSON可以像下面的代码一样，其中`Todo`的`assignee`字段对应于`User`对象的`userid`字段：
- en: Using `name` to store the `assignee` relationship would be a bad idea, as the
    `name` of a person is not unique and it might change over time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`name`来存储`assignee`关系是一个坏主意，因为一个人的`name`并不是唯一的，而且它可能随时间改变。
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our initial take on this might be to type the `assignee` and `userid` attributes
    as `types.string` fields. Then, whenever we need it, we could look up the designated
    user in the `users` map, since the user is stored under its own `userid`. Since
    the user lookup could be a commonly needed operation, we could even introduce
    a *view* and *action* to read or write to that user. That will make our user model
    as seen in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的想法可能是将`assignee`和`userid`属性类型化为`types.string`字段。然后，每当我们需要时，我们可以在`users`映射中查找指定的用户，因为用户存储在其自己的`userid`下。由于用户查找可能是一个常见的操作，我们甚至可以引入一个*视图*和*操作*来读取或写入该用户。这将使我们的用户模型如下所示的代码所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `getAssignee()` view, we conveniently use the fact that every MST node
    knows its own location in the tree. By leveraging the `getRoot()` utility, we
    can navigate to the `users` map and grab the correct `User` object. By using the `getAssignee()` view,
    we obtain a real `User` object so that we can directly access and print its `name`
    property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getAssignee()`视图中，我们方便地利用了每个MST节点都知道自己在树中的位置这一事实。通过利用`getRoot()`实用程序，我们可以导航到`users`映射并获取正确的`User`对象。通过使用`getAssignee()`视图，我们获得了一个真正的`User`对象，以便我们可以直接访问和打印其`name`属性。
- en: There are several useful utilities that can be used to reflect on or work with
    the location in a tree, such as `getPath()`, `getParent()` , `getParentOfType()`,
    and so on. As an alternative, we could have expressed the `getAssignee()` view
    as `return resolvePath(self, "../../users/" + self.assignee)`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个有用的实用程序可以用来反映或处理树中的位置，例如`getPath()`、`getParent()`、`getParentOfType()`等。作为替代方案，我们可以将`getAssignee()`视图表示为`return
    resolvePath(self, "../../users/" + self.assignee)`。
- en: We can treat the MST tree as a filesystem for state! `getAssignee()` just translates
    to a symlink.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将MST树视为状态的文件系统！`getAssignee()`只是将其转换为符号链接。
- en: Additionally, an action to update the `assignee` property has been introduced.
    To make sure the `setAssignee()` action can be conveniently invoked by either
    providing `userid,` or an actual *user* object, we apply some *type-discrimination*.
    In MST, every type not only exposes the `create()` method, but also the `is` method,
    to check if a given value is of the respective type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们引入了一个更新`assignee`属性的操作。为了确保`setAssignee()`操作可以方便地通过提供`userid`或实际*用户*对象来调用，我们应用了一些*类型区分*。在MST中，每种类型不仅公开了`create()`方法，还公开了`is`方法，以检查给定值是否属于相应的类型。
- en: Referencing by types.identifier() and types.reference()
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过types.identifier()和types.reference()进行引用
- en: It is nice that we can neatly express these lookup/update utilities in MST,
    but if your problem domain is large, this becomes quite a repetitive pattern.
    Luckily, this pattern is built into MST. The first type we can leverage is `types.identifier()`,
    which indicates that a certain field uniquely identifies an instance of a certain
    model type. So, in our example, rather than typing `userid` as `types.string` we
    can type it as `types.identifier()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在MST中清晰地表达这些查找/更新实用程序，这很好，但是如果您的问题领域很大，这将变得相当重复。幸运的是，这种模式内置在MST中。我们可以利用的第一种类型是`types.identifier()`，它表示某个字段唯一标识某个模型类型的实例。因此，在我们的示例中，我们可以将`userid`的类型定义为`types.identifier()`，而不是`types.string`。
- en: 'Secondly, there is `types.reference()`. This type indicates that a certain
    field is serialized as a primitive value, but actually denotes a reference to
    another type in the tree. MST will automatically match `identifier` fields with `reference` fields
    for us, so we can simplify our previous state-tree model to the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，还有`types.reference()`。这种类型表示某个字段被序列化为原始值，但实际上表示对树中另一种类型的引用。MST将自动为我们匹配`identifier`字段和`reference`字段，因此我们可以简化我们之前的状态树模型如下：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Thanks to the reference type, reading the `assignee` attribute of `Todo` will
    actually resolve the stored identifier and return the correct `User` object. Thus,
    we can immediately print its name in the preceding example. Note that, behind
    the scenes, our state is still a tree. It is also important to notice that we
    don't have to specify where or how references to `User` instances should be resolved.
    MST will automatically maintain an internal *type + identifier* based lookup table
    for resolving references. By using *references* and *identifiers*, MST has enough
    type information to automatically handle the *data (de)normalization* for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用类型，读取`Todo`的`assignee`属性实际上将解析存储的标识符并返回正确的`User`对象。因此，我们可以立即在前面的示例中打印其名称。请注意，我们的状态仍然是一个树。还要注意的是，我们不必指定`User`实例的引用应该在何处或如何解析。MST将自动维护一个内部的基于*类型+标识符*的查找表来解析引用。通过使用*引用*和*标识符*，MST具有足够的类型信息来自动处理我们的*数据（去）规范化*。
- en: '`types.reference` is quite powerful and can be customized to, for example,
    resolve objects based on relative paths (like a real symlink!) instead of identifiers. In
    many cases, you will combine `types.reference` with `types.maybe` as above, to
    express that `Todo` does not necessarily have an `assignee`. Likewise, arrays
    and maps of references can be modeled in similar ways.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`types.reference`非常强大，并且可以自定义，例如根据相对路径（就像真正的符号链接！）而不是标识符解析对象。在许多情况下，您将与上述一样结合`types.maybe`，以表达`Todo`不一定有`assignee`。同样，引用的数组和映射可以以类似的方式建模。'
- en: Out-of-the-box benefits of declarative models
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明性模型的开箱即用的好处
- en: MST helps you organize and model complex problem domains in a declarative fashion.
    Because of a consistent approach to defining the types in your domain, we get
    the benefit of a clean and simple mental model. This consistency also gets us
    many *out-of-the-box* features, since MST has deep knowledge of the state-tree.
    One example we saw earlier was with automatic *data-normalization* with the use
    of *identifiers* and *references*. There are many more features built into MST.
    Of the lot, a few stand out as being most practical. We will briefly discuss them
    in the rest of this section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: MST帮助您以声明性方式组织和建模复杂的问题领域。由于在您的领域中定义类型的一致方法，我们得到了清晰简单的心智模型的好处。这种一致性还为我们带来了许多开箱即用的功能，因为MST深入了解状态树。我们之前看到的一个例子是使用标识符和引用进行自动数据规范化。MST内置了许多更多功能。其中，有一些功能在实际中最为实用。我们将在本节的其余部分简要讨论它们。
- en: Immutable snapshots
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变的快照
- en: MST always keeps an immutable version of the state-tree in memory, which can
    be retrieved using the `getSnapshot()` API. Essentially, `const snapshot = getSnapshot(tree)` is
    the inverse of `const tree = Type.create(snapshot)`. `getSnapshot()` makes it very
    convenient to quickly serialize the entire state of a tree. Since MST is powered
    by MobX, we can nicely track this as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: MST始终在内存中保留状态树的不可变版本，可以使用`getSnapshot()`API检索。基本上，`const snapshot = getSnapshot(tree)`是`const
    tree = Type.create(snapshot)`的反向操作。`getSnapshot()`使得快速序列化整个树的状态非常方便。由于MST由MobX支持，我们也可以很好地跟踪这一点。
- en: S*napshots* translate to *computed-properties* on the model instances.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 快照在模型实例上转换为计算属性。
- en: 'The following snippet automatically stores the state of the tree in *local-storage*
    upon each change, but no more than once per second:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段在每次更改时自动将树的状态存储在*local-storage*中，但每秒最多一次：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It should be pointed out that every node in an MST tree is an MST tree in itself.
    This means, any operation invoked on the root could also be invoked on any of
    its subtrees. For example, if we only want to store a part of the entire state,
    we could just get a snapshot of the subtree.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，MST树中的每个节点本身都是MST树。这意味着在根上调用的任何操作也可以在其任何子树上调用。例如，如果我们只想存储整个状态的一部分，我们可以只获取子树的快照。
- en: A corollary API that goes hand in hand with `getSnapshot()` is `applySnapshot()`.
    This can be used to update a tree with a snapshot in an efficient manner. By combining `getSnapshot()` and `applySnapshot()`, you
    can build a time traveler in just a few lines of code! This is left as an exercise
    for the reader.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与`getSnapshot()`搭配使用的相关API是`applySnapshot()`。这可以用来以高效的方式使用快照更新树。通过结合`getSnapshot()`和`applySnapshot()`，你可以只用几行代码就构建一个时间旅行者！这留给读者作为练习。
- en: JSON patches
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON补丁
- en: Although snapshots efficiently capture the state of the entire application,
    they are not suitable for frequent communication with a server or other clients.
    This is because the size of a snapshot grows linearly with the size of the state
    you want to serialize. Instead, for real-time changes, it is better to send incremental
    updates to the server. *JSON-patch* (RFC-6902) is an official standard on how
    these incremental updates should be serialized, and MST supports this standard
    out of the box.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管快照有效地捕获了整个应用程序的状态，但它们不适合与服务器或其他客户端频繁通信。这是因为快照的大小与要序列化的状态的大小成线性增长。相反，对于实时更改，最好向服务器发送增量更新。*JSON-patch*（RFC-6902）是关于如何序列化这些增量更新的官方标准，MST默认支持此标准。
- en: 'The `onPatch()` API can be used to listen to the `patches` being generated
    as a side effect of your changes. On the other hand, `applyPatch()` performs the
    inverse process: given a patch, it can update an existing tree. The `onPatch()` listener
    emits the `patches` generated as a result of the state changes made by actions.
    It also exposes the so-called *inverse-patches*: a set that can undo the changes
    made by the `patches`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`onPatch()`API可用于监听作为更改副作用生成的`patches`。另一方面，`applyPatch()`执行相反的过程：给定一个补丁，它可以更新现有树。`onPatch()`监听器会生成由操作所做的状态更改产生的`patches`。它还公开了所谓的*inverse-patches*：一个可以撤消`patches`所做更改的集合。'
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code, which toggles the `todo`, prints the following to the console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 切换`todo`的前面代码在控制台上打印如下内容：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Middlewares
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: 'We briefly mentioned middlewares in an earlier section, but let''s expand on
    it here. Middlewares act as interceptors of the actions invoked on the state-tree.
    Because MST mandates the use of actions, we are assured that every *action* will
    pass through the middleware. The presence of middleware makes it trivial to implement
    several cross-cutting features, such as the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分简要提到了中间件，但让我们在这里扩展一下。中间件充当对状态树上调用的操作的拦截器。因为 MST 要求使用操作，我们可以确保每个 *操作*
    都会通过中间件。中间件的存在使得实现几个横切面特性变得微不足道，例如以下内容：
- en: Logging
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Authentication
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Time travel
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间旅行
- en: Undo/Redo
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 撤销/重做
- en: In fact, the `mst-middlewares` NPM package contains some of the previously mentioned
    middlewares, as well as a few more. For more details about these middlewares,
    refer to: [https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`mst-middlewares` NPM 包包含了一些先前提到的中间件，以及一些其他中间件。有关这些中间件的更多详细信息，请参阅：[https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md)。
- en: Further reading
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We have hardly scratched the surface of MobX-State-Tree, but hopefully it has
    left an impression around organizing and structuring the observable state in MobX.
    It is a well-defined, community-driven approach that bakes in many of the best
    practices discussed throughout this book. For a deeper exploration of MST, you
    can refer to the official getting-started guide at: [https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎只是触及了 MobX-State-Tree 的表面，但希望它已经在组织和构建 MobX 中的可观察状态方面留下了印象。这是一个明确定义的、社区驱动的方法，它融入了本书中讨论的许多最佳实践。要深入探索
    MST，您可以参考官方入门指南：[https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started)。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the practical aspects of adopting MobX with packages
    such as `mobx-utils` and `mobx-state-tree`. These packages codify the community
    wisdom around using MobX for a variety of scenarios.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了使用 `mobx-utils` 和 `mobx-state-tree` 等包采用 MobX 的实际方面。这些包将社区对于在各种场景中使用
    MobX 的智慧编码化。
- en: '`mobx-utils` gives you a set of utilities for tackling asynchronous tasks,
    dealing with expensive updates, creating view models for transactional-editing,
    and much more.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-utils` 为您提供了一组用于处理异步任务、处理昂贵的更新、为事务编辑创建视图模型等的实用工具。'
- en: '`mobx-state-tree` is a comprehensive package that is meant to simplify application
    development with MobX. It takes a prescriptive approach to structuring and organizing
    the observable state in MobX. With such a declarative approach, MST is able to
    get a deeper understanding of the state-tree and offer a variety of features,
    such as runtime type-checking, snapshots, JSON-patches, middlewares, and so on.
    Overall, it helps in developing a crisp mental model of your MobX application
    and puts the typed-domain-model at the forefront.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-state-tree` 是一个全面的包，旨在简化使用 MobX 进行应用程序开发。它采用规范化的方法来构建和组织 MobX 中的可观察状态。通过这种声明性的方法，MST
    能够更深入地理解状态树，并提供各种功能，例如运行时类型检查、快照、JSON 补丁、中间件等。总的来说，它有助于开发对 MobX 应用程序的清晰的心智模型，并将类型域模型置于前沿。'
- en: In the next chapter, we will culminate the journey on MobX with a peek into
    its inner workings. If there are parts of MobX that seem like *black magic*, the
    next chapter will dispel all such myths.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一瞥了解 MobX 的内部工作，来完成 MobX 的旅程。如果 MobX 的某些部分看起来像*黑魔法*，下一章将驱散所有这些神话。
