["```jsx\nimport { computed, decorate, observable, autorun, action } from 'mobx';\n\nclass Todo {\n    @observable title = '';\n    @observable done = false;\n\n    constructor(title) {\n        this.title = title;\n    }\n}\n\nclass TodoList {\n    @observable.shallow todos = [];\n\n    **@computed**\n  get pendingTodos() {\n        return this.todos.filter(x => x.done === false);\n    }\n\n    **@computed**\n  get completedTodos() {\n        return this.todos.filter(x => x.done);\n    }\n\n @computed\n    get pendingTodosDescription() {\n        const count = this.pendingTodos.length; return `${count} ${count === 1 ? 'todo' : 'todos'} remaining`;\n    }\n\n @action  addTodo(title) {\n const todo = new Todo(title);\n this.todos.push(todo);\n    }\n}\n\nclass TodoManager {\n    list = null;\n\n    @observable filter = 'all'; // all, pending, completed\n  @observable title = ''; // user-editable title when creating a new \n    todo\n\n    constructor(list) {\n        this.list = list;\n\n        autorun(() => {\n            console.log(this.list.pendingTodos.length);\n        });\n    }\n\n    **@computed**\n  get visibleTodos() {\n        switch (this.filter) {\n            case 'pending':\n                return this.list.pendingTodos;\n            case 'completed':\n                return this.list.completedTodos;\n            default:\n                return this.list.todos;\n        }\n    }\n}\n```", "```jsx\nclass TodoList {\n    @observable.shallow todos = [];\n    get pendingTodos() {\n        return this.todos.filter(x => x.done === false);\n    }\n\n    get completedTodos() {\n        return this.todos.filter(x => x.done);\n    }\n\n    @action\n  addTodo(title) {\n        const todo = new Todo(title);\n        this.todos.push(todo);\n    }\n}\n\ndecorate(TodoList, {\n pendingTodos: computed({ name: 'pending-todos', /* other options */ }),\n});\n\n```", "```jsx\nclass Contact {\n    @observable firstName = '';\n    @observable lastName = '';\n\n get fullName() {\n return `${this.firstName} ${this.lastName}`;\n }\n\n}\n\ndecorate(Contact, {\n    fullName: computed({\n        // extract firstName and lastName\n set: function(value) {\n const [firstName, lastName] = value.split(' ');\n\n this.firstName = firstName;\n this.last = lastName;\n },\n    }),\n});\n```", "```jsx\nclass Contact {\n    @observable firstName = '';\n    @observable lastName = '';\n\n    @computed\n  get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n    }\n\n set fullName(value) {\n const [firstName, lastName] = value.split(' ');\n\n this.firstName = firstName;\n this.lastName = lastName;\n }\n}\n\nconst c = new Contact();\n\nc.firstName = 'Pavan';\nc.lastName = 'Podila';\n\nconsole.log(c.fullName); // Prints: Pavan Podila\n\nc.fullName = 'Michel Weststrate';\nconsole.log(c.firstName, c.lastName); // Prints: Michel Weststrate\n```", "```jsx\nimport { observable, computed, decorate, comparer } from 'mobx';\n\nclass Contact {\n    @observable firstName = '';\n    @observable lastName = '';\n\n  get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n    }\n\n}\n\ndecorate(Contact, {\n    fullName: computed({\n  set: function(value) {\n            const [firstName, lastName] = value.split(' ');\n\n            this.firstName = firstName;\n            this.last = lastName;\n        },\n equals: comparer.identity,\n    }),\n\n});\n```", "```jsx\nimport { observable, computed } from 'mobx';\n\nconst x = observable.box(3);\nconst y = observable.box(1);\n\nconst divided = computed(() => {\n    if (y.get() === 0) {\n        throw new Error('Division by zero');\n    }\n\n    return x.get() / y.get();\n});\n\ndivided.get(); // returns 3   y.set(0); **// OK**   try {\n    divided.get(); // Throws: Division by zero\n        } catch (ex) {\n    // Recover to a safe state\n y.set(2);\n}\n\ndivided.get(); // Recovered; Returns 1.5 \n```", "```jsx\nimport { configure } from 'mobx';\n\nconfigure({ enforceActions: true });\n```", "```jsx\nclass ShoppingCart {\n    @observable asyncState = '';\n\n    @observable.shallow items = [];\n\n    **@action**\n  async submit() {\n        this.asyncState = 'pending';\n        try {\n            const response = **await** this.purchaseItems(this.items);\n\n            this.asyncState = 'completed'; // modified outside of \n            action\n        } catch (ex) {\n            console.error(ex);\n            this.asyncState = 'failed'; // modified outside of action\n        }\n    }\n\n    purchaseItems(items) {\n        /* ... */\n  return Promise.resolve({});\n    }\n}\n```", "```jsx\nUnhandled Rejection (Error): [mobx] Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: **ShoppingCart@14.asyncState**\n```", "```jsx\nimport { action, observable, configure, runInAction } from 'mobx';\n\nconfigure({ enforceActions: 'strict' });\n\nclass ShoppingCart {\n    @observable asyncState = '';\n\n    @observable.shallow items = [];\n\n    @action\n  async submit() {\n        this.asyncState = 'pending';\n        try {\n            const response = await this.purchaseItems(this.items);\n\n runInAction(() => {\n this.asyncState = 'completed';\n });\n        } catch (ex) {\n            console.error(ex);\n\n runInAction(() => {\n this.asyncState = 'failed';\n });\n        }\n    }\n\n    purchaseItems(items) {\n        /* ... */\n  return Promise.resolve({});\n    }\n}\n\nconst cart = new ShoppingCart();\n\ncart.submit();\n```", "```jsx\nimport { observable, action } from 'mobx';\n\nclass AuthStore {\n    @observable loginState = '';\n\n    @action.bound\n  async login(username, password) {\n        this.loginState = 'pending';\n\n        **await** this.initializeEnvironment();\n\n        this.loginState = 'initialized';\n\n        **await** this.serverLogin(username, password);\n\n        this.loginState = 'completed';\n\n        **await** this.sendAnalytics();\n\n        this.loginState = 'reported';\n    }\n\n    async initializeEnvironment() {}\n\n    async serverLogin(username, password) {}\n\n    async sendAnalytics() {}\n}\n```", "```jsx\nimport { observable, action, flow, configure } from 'mobx';\n\nconfigure({ enforceActions: 'strict' });\n\nclass AuthStore {\n    @observable loginState = '';\n\n    login = flow(function*(username, password) {\n        this.loginState = 'pending';\n\n        **yield** this.initializeEnvironment();\n\n        this.loginState = 'initialized';\n\n        **yield** this.serverLogin(username, password);\n\n        this.loginState = 'completed';\n\n        **yield** this.sendAnalytics();\n\n        this.loginState = 'reported';\n\n        **yield** this.delay(3000);\n    });\n\n}\n\nnew AuthStore().login();\n```", "```jsx\nconst promise = new AuthStore().login2();\npromise.cancel(); // prematurely cancel the async code\n```", "```jsx\nimport { autorun, reaction, when } from 'mobx';\n\nconst disposer1 = autorun(() => {\n    /* effect function */ });\n\nconst disposer2 = reaction(\n    () => {\n        /* tracking function returning data */\n  },\n    data => {\n        /* effect function */\n  },\n);\n\nconst disposer3 = when(\n    () => {\n        /* predicate function */\n  },\n    predicate => {\n        /* effect function */\n  },\n);\n\n// Dispose pre-maturely\ndisposer1();\ndisposer2();\ndisposer3();\n```", "```jsx\nautorun(() => { /* side effects */}, options)\n```", "```jsx\nimport { autorun } from 'mobx';\n\nconst profile = observable({\n    name: 'Pavan Podila',\n    id: 123,\n    couponsUsed: 3,\n});\n\nfunction sendCouponTrackingAnalytics(id, couponsUsed) {\n    /* Make network request */ }\n\nautorun(\n    () => {\n        sendCouponTrackingAnalytics(profile.id, profile.couponsUsed);\n    },\n    { delay: 1000 },\n);\n```", "```jsx\nautorun(\n    () => {\n        if (profile.couponsUsed > 2) {\n            throw new Error('No more than 2 Coupons allowed');\n        }\n    },\n    {\n        onError(ex) {\n            console.error(ex);\n            removeExcessCoupons(profile.id);\n        },\n    },\n);\n\nfunction removeExcessCoupons(id) {}\n```", "```jsx\nconst item = observable({\n    name: 'Laptop',\n    price: 999,\n    quantity: 1,\n});\n\nautorun(() => {\n showInfo(item);\n});\n\nitem.price = 1050;\n```", "```jsx\nautorun(() => {\n    showInfo(item.price);\n});\n```", "```jsx\nautorun(() => {\n setTimeout(() => {\n        if (item.quantity > 10) {\n            item.price = 899;\n        }\n    }, 500);\n});\n\nitem.quantity = 24;\n```", "```jsx\nautorun(\n    () => {\n        if (item.quantity > 10) {\n            item.price = 899;\n        }\n    },\n { delay: 500 },\n);\n```", "```jsx\nautorun(() => {\n    console.log(`Item Description: ${item.description}`);\n});\n\nextendObservable(item, {\n    get description() {\n        return `Only ${item.quantity} left at $${item.price}`;\n    },\n});\n\nitem.quantity = 10;\n```", "```jsx\nextendObservable(item, {\n get description() {\n return `Only ${item.quantity} left at $${item.price}`;\n },\n});\n\nautorun(() => {\n    console.log(`Item Description: ${item.description}`);\n});\n\nitem.quantity = 10;\n```", "```jsx\nconst twitterUrls = observable.map({\n    John: 'twitter.com/johnny',\n});\n\nautorun(() => {\n    console.log(twitterUrls.get('Sara'));\n});\n\ntwitterUrls.set('Sara', 'twitter.com/horsejs');\n```"]