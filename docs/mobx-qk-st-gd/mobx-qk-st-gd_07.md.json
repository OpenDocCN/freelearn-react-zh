["```jsx\nimport {\n    autorun,\n    observable,\n set,\n get,\n has,\n    toJS,\n    runInAction,\n remove,\n values,\n entries,\n keys,\n} from 'mobx';\n\nclass Todo {\n    @observable description = '';\n    @observable done = false;\n\n    constructor(description) {\n        this.description = description;\n    }\n}\n\nconst firstTodo = new Todo('Write Chapter');\nconst todos = observable.array([firstTodo]);\nconst todosMap = observable.map({\n    'Write Chapter': firstTodo,\n});\n\n// Reactions to track changes autorun(() => {\n console.log(`metadata present: ${has(firstTodo, 'metadata')}`);\n console.log(get(firstTodo, 'metadata'), get(firstTodo, 'user'));\n console.log(keys(firstTodo));\n});\nautorun(() => {\n    // Arrays\n const secondTodo = get(todos, 1);\n console.log('Second Todo:', toJS(secondTodo));\n console.log(values(todos), entries(todos));\n});\n\n// Granular changes runInAction(() => {\n set(firstTodo, 'metadata', 'new Metadata');\n set(firstTodo, { metadata: 'meta update', user: 'Pavan Podila' });\n set(todos, 1, new Todo('Get it reviewed'));\n});\n\nrunInAction(() => {\n remove(firstTodo, 'metadata');\n remove(todos, 1);\n});\n```", "```jsx\nmetadata present: false undefined undefined (2) [\"description\", \"done\"] Second Todo: undefined  [Todo] [Array(2)]    metadata present: true meta update Pavan Podila (4) [\"description\", \"done\", \"metadata\", \"user\"] Second Todo: {description: \"Get it reviewed\", done: false}  (2) [Todo, Todo] (2) [Array(2), Array(2)]    metadata present: false undefined \"Pavan Podila\" (3) [\"description\", \"done\", \"user\"] Second Todo: undefined  [Todo] [Array(2)] \n```", "```jsx\nconst number = observable.box(10);\nconst cart = observable({\n    items: [{ title: 'milk', quantity: 2 }, { title: 'eggs', quantity: 3 }],\n});\n\nconsole.log(toJS(number));\n\nconsole.log('MobX type:', cart);\nconsole.log('JS type:', toJS(cart));\n```", "```jsx\n10 **MobX type: Proxy {Symbol(mobx administration): ObservableObjectAdministration$$1}** **JS type: {items: Array(2)}** \n```", "```jsx\nError: [mobx] Cannot obtain atom from 0 \n```", "```jsx\nimport {\n    onBecomeObserved,\n    onBecomeUnobserved,\n    observable,\n    autorun,\n} from 'mobx';\n\nconst obj = observable.box(10);\nconst cart = observable({\n    items: [],\n    totalPrice: 0,\n});\n\nonBecomeObserved(obj, () => {\n console.log('Started observing obj');\n});\n\nonBecomeUnobserved(obj, () => {\n console.log('Stopped observing obj');\n});\n\nonBecomeObserved(cart, 'totalPrice', () => {\n console.log('Started observing cart.totalPrice');\n});\nonBecomeUnobserved(cart, 'totalPrice', () => {\n console.log('Stopped observing cart.totalPrice');\n});\n\nconst disposer = autorun(() => {\n    console.log(obj.get(), `Cart total: ${cart.totalPrice}`);\n});\nsetTimeout(disposer);\n\nobj.set(20);\ncart.totalPrice = 100;\n```", "```jsx\nStarted observing obj Started observing cart.totalPrice 10 \"Cart total: 0\" 20 \"Cart total: 0\" 20 \"Cart total: 100\" Stopped observing cart.totalPrice Stopped observing obj \n```", "```jsx\n// A mock service to simulate a network call to a weather API const temperatureService = {\n    fetch(location) {\n        console.log('Invoked temperature-fetch');\n\n        return new Promise(resolve =>\n            setTimeout(resolve(Math.round(Math.random() * 35)), 200),\n        );\n    },\n};\n\nclass City {\n @observable temperature;\n    @observable location;\n\n    interval;\n    disposers;\n\n    constructor(location) {\n        this.location = location;\n const disposer1 = onBecomeObserved(\n this,\n 'temperature',\n this.onActivated,\n );\n const disposer2 = onBecomeUnobserved(\n this,\n 'temperature',\n this.onDeactivated,\n );\n\n        this.disposers = [disposer1, disposer2];\n    }\n\n    onActivated = () => {\n        this.interval = setInterval(() => this.fetchTemperature(), 5000);\n        console.log('Temperature activated');\n    };\n\n    onDeactivated = () => {\n        console.log('Temperature deactivated');\n        this.temperature = undefined;\n        clearInterval(this.interval);\n    };\n\n    fetchTemperature = flow(function*() {\n        this.temperature = yield temperatureService.fetch(this.location);\n    });\n\n    cleanup() {\n        this.disposers.forEach(disposer => disposer());\n        this.disposers = undefined;\n    }\n}\n\nconst city = new City('Bengaluru');\nconst disposer = autorun(() =>\n    console.log(`Temperature in ${city.location} is ${city.temperature}\u00baC`),\n);\n\nsetTimeout(disposer, 15000);  \n```", "```jsx\nTemperature activated Temperature in Bengaluru is undefined\u00baC   Invoked temperature-fetch Temperature in Bengaluru is 22\u00baC Invoked temperature-fetch Temperature in Bengaluru is 32\u00baC Invoked temperature-fetch Temperature in Bengaluru is 4\u00baC   Temperature deactivated\n```", "```jsx\nimport { intercept, observable } from 'mobx';\n\nconst theme = observable({\n    color: 'light',\n    shades: [],\n});\n\nconst disposer = intercept(theme, 'color', change => {\n    console.log('Intercepting:', change);\n\n    // Cannot unset value, so discard this change\n  if (!change.newValue) {\n        return **null**;\n    }\n\n    // Handle shorthand values\n  const newTheme = change.newValue.toLowerCase();\n    if (newTheme === 'l' || newTheme === 'd') {\n        change.newValue = newTheme === 'l' ? 'light' : 'dark'; // set \n         the correct value\n  return change;\n    }\n\n    // check for a valid theme\n  const allowedThemes = ['light', 'dark'];\n    const isAllowed = allowedThemes.includes(newTheme);\n    if (!isAllowed) {\n        **throw** new Error(`${change.newValue} is not a valid theme`);\n    }\n\n    return change; // Correct value so return as-is });\n```", "```jsx\nimport { observe, observable } from 'mobx';\n\nconst theme = observable({\n    color: 'light',\n    shades: [],\n});\n\nconst disposer = observe(theme, 'color', change => {\n    console.log(\n        `Observing ${change.type}`,\n        change.oldValue,\n        '-->',\n        change.newValue,\n        'on',\n        change.object,\n    );\n});\n\ntheme.color = 'dark';\n```", "```jsx\nimport { spy } from 'mobx';\n\nconst disposer = spy(event => console.log(event));\n\nsetTimeout(disposer, 5000);\n```", "```jsx\n// Console output\n{type: \"action\", name: \"<unnamed action>\", object: undefined, arguments: Array(0), **spyReportStart**: true} {type: \"update\", object: BookSearchStore, oldValue: 0, name: \"BookSearchStore@1\", newValue: 2179, \u2026} {**spyReportEnd**: true} {object: Proxy, type: \"splice\", index: 0, removed: Array(0), added: Array(20), \u2026} {spyReportEnd: true} {type: \"update\", object: BookSearchStore, oldValue: Proxy, name: \"BookSearchStore@1\", newValue: Proxy, \u2026} {spyReportEnd: true} {type: \"update\", object: BookSearchStore, oldValue: \"pending\", name: \"BookSearchStore@1\", newValue: \"completed\", \u2026} \n```", "```jsx\nimport { trace } from 'mobx';\n\n@inject('store')\n@observer export class SearchTextField extends React.Component {\n    render() {\n        trace(true);\n\n        /* ... */\n    }\n\n}\n```", "```jsx\nimport DevTools from 'mobx-react-devtools';\nimport React from 'react';\n\nexport class MobXBookApp extends React.Component {\n    render() {\n        return (\n            <Fragment>\n <DevTools />\n                <RootAppComponent />\n            </Fragment>\n        );\n    }\n}\n```"]