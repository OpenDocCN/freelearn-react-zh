- en: Handling Real-World Use Cases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理真实用例
- en: Applying the principles of MobX can seem daunting when you first start using
    it. To help you with this process, we are gong to tackle two non-trivial examples
    of using the MobX triad of *observables-actions-reactions*. We will cover the
    modeling of the observable state, and then identify the actions and the reactions
    that track the observables. Once you go through these examples, you should be
    able to make the mental shift in tackling state management with MobX.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用MobX时，应用MobX的原则可能会看起来令人生畏。为了帮助您完成这个过程，我们将解决两个非平凡的使用MobX三要素*可观察-操作-反应*的示例。我们将涵盖可观察状态的建模，然后确定跟踪可观察对象的操作和反应。一旦您完成这些示例，您应该能够在使用MobX处理状态管理时进行心智转变。
- en: 'The examples we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下示例：
- en: Form validation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单验证
- en: Page routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面路由
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备JavaScript编程语言。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter06](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter06)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter06](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter06)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的运行情况：
- en: '[http://bit.ly/2LDliA9](http://bit.ly/2LDliA9)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2LDliA9](http://bit.ly/2LDliA9)'
- en: Form validation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单验证
- en: Filling up forms and validating fields is the classic use-case of the web. So,
    it's fitting we start here and see how MobX can help us simplify it. For our example,
    we will consider a User Enrollment form that takes in some standard inputs like
    first name, last name, email, and password.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单和验证字段是Web的经典用例。因此，我们从这里开始，并看看MobX如何帮助我们简化它。在我们的示例中，我们将考虑一个用户注册表单，其中包含一些标准输入，如名字、姓氏、电子邮件和密码。
- en: 'The various states of enrollment are captured in the following figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的各种状态如下图所示：
- en: '![](../images/00028.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: The interactions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互
- en: 'Looking at the preceding screenshot, we can see some standard interactions
    going on, such as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到一些标准的交互，例如：
- en: Entering inputs for various fields
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入各种字段的输入
- en: Validation on those fields
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对这些字段进行验证
- en: Clicking the Enroll button to perform a network operation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击“注册”按钮执行网络操作
- en: 'There are few other interactions here that do not meet the eye immediately:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些其他交互，不会立即引起注意：
- en: Network-based validation for the email to ensure that we are not registering
    with an existing email address
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网络的电子邮件验证，以确保我们不会注册已存在的电子邮件地址
- en: Showing a progress indicator for the enroll operation
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示注册操作的进度指示器
- en: Many of these interactions will be modeled with actions and reactions in MobX.
    The state will, of course, be modeled with observables. Let's see how the O*bservables-Actions-Reactions*
    triad comes to life in this example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些交互将使用MobX中的操作和反应进行建模。状态当然将使用可观察对象进行建模。让我们看看在这个示例中O*bservables-Actions-Reactions*三要素是如何生动起来的。
- en: Modeling the observable state
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模可观察状态
- en: The visual design for the example already hints at the core state that we need.
    This includes the `firstName`, `lastName`, `email`, and `password` fields. We
    can model these as *observable properties* of the `UserEnrollmentData` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的视觉设计已经暗示了我们需要的核心状态。这包括`firstName`、`lastName`、`email`和`password`字段。我们可以将这些字段建模为`UserEnrollmentData`类的*可观察属性*。
- en: 'Additionally, we also need to track the async validation that will happen with
    email. We do that with the boolean `validating` property. Any errors that are
    found during the validation are tracked with `errors`. Finally, the `enrollmentStatus`
    tracks the network operation around enrollment. It is a string-enum that can have
    one of four values: `none`, `pending`, `completed`, or `failed`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要跟踪将发生在电子邮件上的异步验证。我们使用布尔值`validating`属性来实现这一点。在验证过程中发现的任何错误都将使用`errors`进行跟踪。最后，`enrollmentStatus`跟踪了围绕注册的网络操作。它是一个字符串枚举，可以有四个值之一：`none`、`pending`、`completed`或`failed`。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice that `errors` is marked with `@observable.ref`, as it only needs
    to track reference changes. This is because the validation output is an *opaque
    object*, which does not have anything observable besides a change in reference.
    Only when `errors` has a value do we know that there are validation errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`errors`标记为`@observable.ref`，因为它只需要跟踪引用更改。这是因为验证输出是一个*不透明对象*，除了引用更改之外没有任何可观察的东西。只有当`errors`有一个值时，我们才知道有验证错误。
- en: Onto the actions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入操作
- en: The actions here are quite straightforward. We need one to *set the field value*
    based on user changes. The other is do *enrollment* when the Enroll button is
    clicked. These two can be seen in the following code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的操作非常简单。我们需要一个操作来根据用户更改*设置字段值*。另一个是在单击Enroll按钮时进行*注册*。这两个可以在以下代码中看到。
- en: 'As a general practice, always start with a call to `configure({ enforceActions:
    ''strict'' })`. This ensures that your observables are only mutated inside an
    action, giving you all the benefits we discussed in [Chapter 5](part0083.html#2F4UM0-58c2559ca4304cecab9bc46f496bc070),
    *Derivations, Actions, and Reactions*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '作为一般惯例，始终从调用`configure({ enforceActions: ''strict'' })`开始。这确保您的可观察对象只在操作内部发生突变，为您提供了我们在[第5章](part0083.html#2F4UM0-58c2559ca4304cecab9bc46f496bc070)中讨论的所有好处，*派生、操作和反应*：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The use of `flow()` for the `enroll` action is deliberate. We are dealing with
    async operations internally, so the mutations that happen after the operation
    completes must be wrapped in `runInAction()` or an `action()`. Doing this manually
    can be cumbersome and also adds noise to the code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`enroll`操作使用`flow()`是故意的。我们在内部处理异步操作，因此在操作完成后发生的突变必须包装在`runInAction()`或`action()`中。手动执行这个操作可能很麻烦，也会给代码增加噪音。
- en: With `flow()`, you get clean looking code by using a generator function with
    `yield` statements for the `promises`. In the preceding code, we have two `yield`
    points, one for `validateFields()` and the other for `enroll()`, both of which
    return `promises`. Notice that we have no wrapper code after these statements,
    making it easier to follow the logic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flow()`，您可以通过使用带有`yield`语句的生成器函数来获得清晰的代码，用于`promises`。在前面的代码中，我们有两个`yield`点，一个用于`validateFields()`，另一个用于`enroll()`，两者都返回`promises`。请注意，在这些语句之后我们没有包装代码，这样更容易遵循逻辑。
- en: 'One other action that is implicit here is `validateFields()`. Validation is
    actually a side effect that is triggered any time the fields change, but can also
    be invoked directly as an action. Here, again, we use `flow()` to handle the mutations
    after running through the async validations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里隐含的另一个操作是`validateFields()`。验证实际上是一个副作用，每当字段更改时都会触发，但也可以直接作为一个操作调用。在这里，我们再次使用`flow()`来处理异步验证后的突变：
- en: We are using the `validate.js` ([https://validatejs.org](https://validatejs.org))
    NPM package to handle the field validations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`validate.js` ([https://validatejs.org](https://validatejs.org)) NPM包来处理字段验证。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the  `flow()` can take in arguments (eg: `fields`) just like regular
    functions. Since the validation for email involves an async operation, we are
    tracking the entire validation as an async operation. We do this with the `validating`
    property. When the operation completes, we set it back to `false` in the `finally`
    block.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`flow()`如何像常规函数一样接受参数（例如：`fields`）。由于电子邮件的验证涉及异步操作，我们将整个验证作为异步操作进行跟踪。我们使用`validating`属性来实现这一点。当操作完成时，我们在`finally`块中将其设置回`false`。
- en: Completing the triad with reactions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用反应完成三角形
- en: When the fields are changed, we need to ensure that the values that have been
    entered are valid. Thus, validation is a side effect of entering values for the
    various fields. We know that MobX offers three ways in which you can handle this
    side effect, and they are `autorun()`, `reaction()`, and `when()`. Since validation
    is an effect that should be performed every time a field changes, `when()`, a
    one-time only effect, can be ruled out. That leaves us with `reaction()` and `autorun()`.
    Typically, a form will only validate when a field has actually changed. This means
    the effect needs to trigger only after a change.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段发生变化时，我们需要确保输入的值是有效的。因此，验证是输入各个字段的值的副作用。我们知道MobX提供了三种处理这种副作用的方法，它们是`autorun()`、`reaction()`和`when()`。由于验证是应该在每次字段更改时执行的效果，一次性效果的`when()`可以被排除。这让我们只剩下了`reaction()`和`autorun()`。通常，表单只会在字段实际更改时进行验证。这意味着效果只需要在更改后触发。
- en: 'That narrows down our choice to `reaction(<tracking-function>, <effect-function>)`,
    as that''s the only type of reaction that ensures the `effect` function triggers
    after the `tracking` function returns a different value. `autorun()`, on the other
    hand, executes immediately, which is too soon to perform validation. With that,
    we can now introduce the *validation* side effect in the `UserEnrollmentData`
    class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的选择缩小到`reaction(<tracking-function>, <effect-function>)`，因为这是唯一一种确保`effect`函数在`tracking`函数返回不同值后触发的反应类型。另一方面，`autorun()`立即执行，这对于执行验证来说太早了。有了这个，我们现在可以在`UserEnrollmentData`类中引入*验证*副作用：
- en: Technically, this could also be achieved with an `autorun()`, but will require
    an additional boolean flag to ensure the validation is not performed the first
    time. Either solution would work well in this situation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这也可以通过`autorun()`实现，但需要一个额外的布尔标志来确保第一次不执行验证。任何一种解决方案在这种情况下都可以很好地工作。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `tracking` function in the preceding `reaction()` picks up the fields to
    monitor. When any of them change, the `tracking` function produces a new value,
    which then triggers the validation. We have already seen the `validateFields()`
    method, which is also an action that uses `flow()`. The `reaction()` is set up
    in the constructor of `UserEnrollmentData`, so the monitoring starts immediately.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述`reaction()`中的`tracking`函数选择要监视的字段。当它们中的任何一个发生变化时，`tracking`函数会产生一个新值，然后触发验证。我们已经看到了`validateFields()`方法，它也是使用`flow()`的动作。`reaction()`设置在`UserEnrollmentData`的构造函数中，因此监视立即开始。
- en: When `this.validateFields()` is called, it gives back a `promise`, which could
    be canceled prematurely using its `cancel()` method. If `validateFields()` gets
    called too frequently, a previous invocation of the method could still be in progress.
    In those cases, we could `cancel()` the previously returned promise to avoid unnecessary
    work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`this.validateFields()`时，它会返回一个`promise`，可以使用其`cancel()`方法提前取消。如果`validateFields()`被频繁调用，先前调用的方法可能仍在进行中。在这种情况下，我们可以`cancel()`先前返回的promise以避免不必要的工作。
- en: We will leave it as a reader exercise to tackle this interesting use-case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个有趣的用例留给读者来解决。
- en: We also keep track of the `disposer` function returned by the `reaction()`,
    which we call inside `cleanup()`. This is required to clean up and avoid potential
    memory leaks when `UserEnrollmentData` is no longer needed. It is always good
    to have an exit point for reactions where its *disposer* gets called. In our case,
    we call `cleanup()` from the root React component, in its `componentWillUnmount()`
    hook. We will see that in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还跟踪`reaction()`返回的`disposer`函数，我们在`cleanup()`中调用它。这是为了清理和避免潜在的内存泄漏，当不再需要`UserEnrollmentData`时。在反应中始终有一个退出点并调用其*disposer*总是很好的。在我们的情况下，我们从根React组件中调用`cleanup()`，在其`componentWillUnmount()`挂钩中。我们将在下一节中看到这一点。
- en: Now, validation is not the only side effect of our example. The more grandiose
    side effect is the UI in the form of React components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证不是我们示例的唯一副作用。更宏伟的副作用是React组件的UI。
- en: React components
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件
- en: The UI as we know is a side effect in MobX and is identified by the use of `observer()`
    decorators on the React components. These observers can read observables in the
    `render()` method, which sets up the tracking. Any time those observables change,
    MobX will re-render the component. This automatic behavior with minimal ceremony
    is very powerful and allows us to create granular components that react to fine-grained
    observable state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道的UI在MobX中是一个副作用，并且通过在React组件上使用`observer()`装饰器来识别。这些观察者可以在`render()`方法中读取可观察对象，从而设置跟踪。每当这些可观察对象发生变化时，MobX将重新渲染组件。这种自动行为与最小的仪式非常强大，使我们能够创建对细粒度可观察状态做出反应的细粒度组件。
- en: 'In our example, we do have some granular observer components, namely the input
    fields, the enroll button, and the app component. They are marked by orange boxes
    in the following component tree:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们确实有一些细粒度的观察者组件，即输入字段、注册按钮和应用程序组件。它们在以下组件树中用橙色框标记：
- en: '![](../images/00029.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'Each field input is separated out into an observer component: **InputField**.
    The email field has its own component, **EmailInputField**, since its visual feedback
    also involves showing a progress bar during validation and disabling it while
    it checks if the entered email is registered already. Similarly, the **EnrollButton**
    also has a spinner to show the progress during the enroll operation.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段输入都分离成一个观察者组件：**InputField**。电子邮件字段有自己的组件**EmailInputField**，因为它的视觉反馈还涉及在验证期间显示进度条并在检查输入的电子邮件是否已注册时禁用它。同样，**EnrollButton**也有一个旋转器来显示注册操作期间的进度。
- en: We are using **Material-UI** ([https://material-ui.com](https://material-ui.com))
    as the component library. This provides an excellent set of React components styled
    to the Material Design guidelines by Google.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用**Material-UI**（[https://material-ui.com](https://material-ui.com)）作为组件库。这提供了一组优秀的React组件，按照Google的Material
    Design指南进行了样式设置。
- en: 'The `InputField` observes just the field that it is rendering, identified by
    the `field` prop, which is dereferenced from the `store` prop (using `store[field]`).
    This serves as the `value` for the `InputField`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputField`只观察它正在渲染的字段，由`field`属性标识，该属性是从`store`属性（使用`store[field]`）解除引用的。这作为`InputField`的`value`：'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: User edits (`onChange` event) to this input are notified back to the store with
    the `store.setField()` action. The `InputField` is a *controlled component* in
    the React parlance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对此输入进行的编辑（`onChange`事件）将通过`store.setField()`操作通知回存储。`InputField`在React术语中是一个*受控组件*。
- en: The key idea of the `InputField` component is about passing the observable (`store`)
    instead of the value (`store[field]`). This ensures the dereferencing of the observable
    property happens inside the `render()` of the component. This is important for
    a granular observer optimized for rendering and tracking just what it needs. You
    can think of it as a *design pattern* when creating MobX observer components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputField`组件的关键思想是传递可观察对象（`store`）而不是值（`store[field]`）。这确保了可观察属性的解引用发生在组件的`render()`内部。这对于一个专门用于渲染和跟踪所需内容的细粒度观察者来说非常重要。在创建MobX观察者组件时，您可以将其视为*设计模式*。'
- en: The UserEnrollmentForm component
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserEnrollmentForm组件
- en: 'We use several of these `InputFields` in the `UserEnrollmentForm` component.
    Note that the `UserEnrollmentForm` component *is not an observer*. Its purpose
    is to get hold of the store via the `inject()` decorator and pass it down to some
    of its child *observer components*. The `inject()` here uses the *function-based*
    argument, which is more type-safe than the *string-based* argument of `inject(''store'')`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`UserEnrollmentForm`组件中使用了几个这些`InputFields`。请注意，`UserEnrollmentForm`组件*不是观察者*。它的目的是通过`inject()`装饰器获取存储并将其传递给一些子*观察者组件*。这里的`inject()`使用了*基于函数的*参数，比`inject('store')`的*基于字符串的*参数更安全。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `store`, an instance of `UserEnrollmentData`, is passed down via the `Provider`
    component setup at the root of the component tree. This is created in the `constructor`
    for the root component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`store`，即`UserEnrollmentData`的一个实例，通过在组件树的根部设置的`Provider`组件传递下来。这是在根组件的`constructor`中创建的。'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the `Provider`, any component can now `inject()` the `store` and get access
    to the observable state. Notice the use of the `componentWillUnmount()` hook to
    invoke `this.store.cleanup()`. This internally disposes the validation reaction,
    as described in the earlier section (*"Completing the triad with reactions"*).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Provider`，任何组件现在都可以`inject()` `store`并访问可观察状态。请注意使用`componentWillUnmount()`钩子来调用`this.store.cleanup()`。这在内部处理了验证反应，如前一部分所述（*“使用反应完成三角形”*）。
- en: Other observer components
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他观察者组件
- en: 'There are a few more granular observers in our component tree. One of the simplest
    ones is the `App` component, which provides a simple branching logic. If we are
    still in the process of enrolling, the `UserEnrollmentForm` is shown. Upon enrollment,
    the `App` shows the `EnrollmentComplete` component. The observable tracked here
    is `store.enrollmentStatus`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件树中还有一些更细粒度的观察者。其中最简单的之一是`App`组件，它提供了一个简单的分支逻辑。如果我们仍在注册过程中，将显示`UserEnrollmentForm`。注册后，`App`将显示`EnrollmentComplete`组件。这里跟踪的可观察对象是`store.enrollmentStatus`：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `EmailInputField` is fairly self-explanatory and reuses the `InputField`
    component. It also includes a progress bar to show the async validation operation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmailInputField`相当不言自明，并重用了`InputField`组件。它还包括一个进度条来显示异步验证操作：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And finally, the last observer component is the `EnrollButton`, which observes
    the `enrollmentStatus` and fires the `enroll()` action on the `store`. While the
    enrollment is in progress, it also shows the circular spinner:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个观察者组件是`EnrollButton`，它观察`enrollmentStatus`并在`store`上触发`enroll()`动作。在注册过程中，它还显示圆形旋转器：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The collection of these granular observers improves the efficiency of the UI
    by speeding up React's reconciliation process. As the changes are localized to
    a specific component, React only has to reconcile the virtual-DOM changes for
    that specific observer component. MobX encourages the use of such granular observers
    and sprinkling them throughout your component tree.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细粒度观察者的集合通过加速React的协调过程来提高UI的效率。由于更改局限于特定组件，React只需协调该特定观察者组件的虚拟DOM更改。MobX鼓励在组件树中使用这样的细粒度观察者并将它们分散其中。
- en: If you are looking for a library built specifically for form validation with
    MobX, look at *mobx-react-form* ([https://github.com/foxhound87/mobx-react-form](https://github.com/foxhound87/mobx-react-form)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找一个专门用于使用MobX进行表单验证的库，请查看*mobx-react-form*（[https://github.com/foxhound87/mobx-react-form](https://github.com/foxhound87/mobx-react-form)）。
- en: Page routing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面路由
- en: '**Single page apps** (**SPA**) have become commonplace in many of the web apps
    we see today. These apps are characterised by the use of logical, client-side
    routes within a single page. You can navigate to various parts (*routes*) of the
    application by modifying the URL without a full page load. This is handled by
    libraries such as `react-router-dom`, which works with the browser history to
    enable *URL* driven route changes.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）已经成为我们今天看到的许多Web应用程序中的常见现象。这些应用程序的特点是在单个页面内使用逻辑的客户端路由。您可以通过修改URL而无需完整加载页面来导航到应用程序的各个部分（*路由*）。这是由诸如`react-router-dom`之类的库处理的，它与浏览器历史记录一起工作，以实现*URL*驱动的路由更改。'
- en: Route change or navigation can be treated as a *side effect* in the MobX world.
    There is some state change happening to the observables, which results in navigation
    happening in the SPA. In this example, we will build this observable state, which
    tracks the current page shown in the browser. Using a combination of `react-router-dom`
    and the `history` package, we will show how routing becomes a side effect of the
    change in observable state.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在MobX世界中，路由更改或导航可以被视为*副作用*。可观察对象发生了一些状态变化，导致SPA中的导航发生。在这个例子中，我们将构建这个可观察状态，它跟踪浏览器中显示的当前页面。使用`react-router-dom`和`history`包的组合，我们将展示如何路由成为可观察状态变化的副作用。
- en: The Cart checkout workflow
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车结账工作流
- en: 'Let''s look at a use-case where we can see the route change (navigation) as
    a MobX-driven side effect. We will use the typical Cart checkout workflow as our
    example. As seen in the following screenshot, we start at the *home route*, which
    is the entry point of the workflow. From there, we go through the remaining steps:
    *viewing the cart*, *selecting a payment option*, *seeing the confirmation*, and
    then *tracking the order:*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个用例，我们可以看到路由更改（导航）作为MobX驱动的副作用。我们将使用典型的购物车结账工作流作为示例。如下截图所示，我们从*主页路由*开始，这是工作流的入口点。从那里，我们经历剩下的步骤：*查看购物车*，*选择付款选项*，*查看确认*，然后*跟踪订单*：
- en: '![](../images/00030.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: We have deliberately kept the various steps visually simple. This allows us
    to focus more on the navigation aspect rather than the details of what happens
    within each step. However, there are certain elements that are *common across
    all of these steps* of the workflow.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意保持各个步骤在视觉上简单。这样我们可以更多地关注导航方面，而不是每个步骤内部发生的细节。然而，工作流的这些步骤中有一些*共同的元素*。
- en: 'As seen in the following screenshot, each step has a load operation that fetches
    details for that step. Once loaded, you can click on the button to go to the next
    step. Before the navigation happens, there is an async operation that is performed.
    After it completes, we navigate to the next step in the workflow. Since every
    step follows this template, we will model it as such in the next section:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，每个步骤都有一个加载操作，用于获取该步骤的详细信息。加载完成后，您可以单击按钮转到下一步。在导航发生之前，会执行一个异步操作。完成后，我们将导航到工作流程的下一步。由于每个步骤都遵循这个模板，我们将在下一节中对其进行建模：
- en: '![](../images/00031.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: Modeling the observable state
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模可观察状态
- en: 'The essence of this SPA is the checkout workflow that takes you step by step,
    where each step is a route. Since a route is driven by a URL, we need a way to
    monitor the URL and also have the ability to change it as we move between steps.
    The navigation between steps is a side effect of some change in the observable
    state. We will model this workflow with a `CheckoutWorkflow` class that contains
    the core observable state:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SPA的本质是逐步进行结账工作流程，其中每个步骤都是一个路由。由于路由由URL驱动，我们需要一种监视URL并在步骤之间移动时有能力更改它的方法。步骤之间的导航是可观察状态的某种变化的副作用。我们将使用包含核心可观察状态的`CheckoutWorkflow`类来对这个工作流程进行建模：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As can be seen in the preceding code, we are representing each of the steps
    with a  `name` and a `stepClass`. The `name` is also how we identify the corresponding
    route for that step, stored in the singleton `routes` object. The ordered list
    of `steps` is stored as a static property of the `CheckoutWorkflow` class. We
    could have also loaded these steps from a separate JavaScript file (module), but
    for simplicity, we have kept it here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们用`name`和`stepClass`表示每个步骤。`name`也是我们用来识别该步骤对应路由的方式，存储在单例`routes`对象中。`steps`的有序列表存储为`CheckoutWorkflow`类的静态属性。我们也可以从单独的JavaScript文件（模块）中加载这些步骤，但为简单起见，我们将其保留在这里。
- en: 'The core observable state is quite simple here: a `currentStep` property that
    stores the string name of the current step and a `step` property, an instance
    of the `stepClass`, stored as an `observable.ref` property. As we navigate between
    steps, these two properties change to reflect the current step. We will see how
    these properties are used in handling the route change.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的可观察状态在这里非常简单：一个存储当前步骤的字符串名称的`currentStep`属性和一个`step`属性，作为`observable.ref`属性存储的`stepClass`的实例。当我们在步骤之间导航时，这两个属性会发生变化以反映当前步骤。我们将看到这些属性在处理路由更改时的使用方式。
- en: A route for a step, a step for a route
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一条路线对应一步，一步对应一条路线
- en: You may be wondering why we need two separate properties to track the current
    step. Yes, it may seem superfluous, but there is a reason for that. Since our
    workflow is going to be a set of url-routes, the change in route can also happen
    by using the back button of the browser or by directly typing a URL. One way to
    co-relate a route with a step is by using its *name*, which is exactly what we
    do with the `currentStep` property. Notice how the `name` of the step exactly
    matches the keys of the `routes` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们需要两个单独的属性来跟踪当前步骤。是的，这似乎多余，但有原因。由于我们的工作流将是一组url路由，路由的变化也可以通过浏览器的返回按钮或直接输入URL来发生。将路由与步骤相关联的一种方法是使用其*名称*，这正是我们在`currentStep`属性中所做的。请注意，步骤的`name`与`routes`对象的键完全匹配。
- en: 'When a route changes externally, we rely on the browser history to notify us
    of the URL change. The `tracker` property, which is an instance of `HistoryTracker`
    (a custom class we will create), contains the logic to listen to *browser history*
    and track the current URL in the browser. It exposes an observable property that
    is tracked by the `CheckoutWorkflow`. We will look at its implementation a little
    later in this chapter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由在外部发生变化时，我们依赖浏览器历史记录来通知我们URL的变化。`tracker`属性是`HistoryTracker`的一个实例（我们将创建一个自定义类），其中包含监听*浏览器历史记录*并跟踪浏览器中当前URL的逻辑。它公开了一个被`CheckoutWorkflow`跟踪的observable属性。我们稍后将在本章中查看它的实现：
- en: '![](../images/00032.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: 'Each step in the `CheckoutWorkflow` is a subtype of a `WorkflowStep` class.
    The `WorkflowStep` captures the details of a step and its async operations. The
    workflow simply orchestrates the flow of steps and transitions between them upon
    completion of the async operation in each step:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckoutWorkflow`中的每个步骤都是`WorkflowStep`类的子类型。`WorkflowStep`捕获了步骤及其异步操作的详细信息。工作流简单地编排步骤的流程，并在每个步骤的异步操作完成后在它们之间进行转换：'
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For most of the steps, we are extending the `MockWorkflowStep` that stamps out
    a template `WorkflowStep` with some baked in defaults. This keeps the steps really
    simple, so we can focus on the routing between steps. Notice in the following
    snippet, where we are simply simulating a network delay for the `load` and `main`
    operations. The `delay()` function is just a simple helper that returns a `Promise`
    that resolves after the given millisecond interval.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数步骤，我们正在扩展`MockWorkflowStep`，它使用一些内置的默认值来创建一个模板`WorkflowStep`。这使得步骤非常简单，因此我们可以专注于步骤之间的路由。请注意下面的代码片段，我们只是模拟了`load`和`main`操作的网络延迟。`delay()`函数只是一个简单的帮助函数，返回一个在给定毫秒间隔后解析的`Promise`。
- en: 'We will see how the `getLoadOperation()` and `getMainOperation()` methods are
    used in the next section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到`getLoadOperation()`和`getMainOperation()`方法是如何使用的：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The WorkflowStep
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WorkflowStep
- en: 'The `WorkflowStep` acts as a template for all the steps in the workflow. It
    contains some observable state to keep track of the two async operations it performs:
    *loading details* and *doing the main work*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkflowStep`充当了工作流中所有步骤的模板。它包含一些observable状态，用于跟踪它执行的两个异步操作：*加载详情*和*执行主要工作*。'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`load()` and `perform()` are the two async operations that a `WorkflowStep`
    does. Their status is tracked with the `loadState` and `operationState` observables,
    respectively. Each of these operations calls a delegate method that is overridden
    by the subclass to provide the actual promise. `load()` calls `getLoadOperation()`
    and `perform()` calls `getMainOperation()`, each of which produces a promise.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`和`perform()`是`WorkflowStep`执行的两个异步操作。它们的状态分别通过`loadState`和`operationState`
    observables进行跟踪。这两个操作中的每一个都调用一个委托方法，子类重写该方法以提供实际的promise。`load()`调用`getLoadOperation()`，`perform()`调用`getMainOperation()`，每个方法都会产生一个promise。'
- en: '`doAsync()` is a helper function that takes in a *promise function* and notifies
    the state using the passed-in callback (`setState`). Notice the use of `runInAction()`
    here to ensure all mutations happen inside an action.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAsync()`是一个帮助函数，它接受一个*promise函数*并使用传入的回调(`setState`)通知状态。请注意这里使用`runInAction()`来确保所有变化发生在一个action内部。'
- en: '`load()` and `perform()` use the `doAsync()` function to update the `loadState`
    and `operationState` observables appropriately:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`和`perform()`使用`doAsync()`函数适当地更新`loadState`和`operationState` observables：'
- en: 'There is a different way of writing the `doAsync()` function. **Hint**: We
    have seen it in an earlier chapter. We''ll leave that as an exercise for the reader.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种不同的编写`doAsync()`函数的方法。**提示**：我们在早期的章节中已经看到过。我们将把这留给读者作为一个练习。
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can now see that the observable state is carried by the `CheckoutWorkflow`
    and the `WorkflowStep` instances. One thing that may not be clear is how the orchestration
    is performed by the `CheckoutWorkflow`. For that, we have to look at the actions
    and reactions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到可观察状态由`CheckoutWorkflow`和`WorkflowStep`实例承载。可能不清楚的一点是`CheckoutWorkflow`如何执行协调。为此，我们必须看一下动作和反应。
- en: Actions and reactions of the workflow
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流的动作和反应
- en: 'We have already seen that the `WorkflowStep` has two ***action*** methods, `load()`
    and `perform()`, that handle the async operations of the step:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`WorkflowStep`有两个***action***方法，`load()`和`perform()`，处理步骤的异步操作：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `load()` action is invoked by `CheckoutWorkflow` as it loads each step
    of the workflow. `perform()` is a user invoked action that happens when the user
    clicks the button exposed on the React component for the step. Once `perform()`
    completes, the `operationState` will change to `completed`. The `CheckoutWorkflow`
    tracks this and automatically loads the next step in sequence. In other words,
    the workflow progresses as a reaction (or side effect) to the change in `operationState`
    of the current step. Let''s see all of this in the following set of code snippets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`操作由`CheckoutWorkflow`调用，因为它加载工作流的每个步骤。`perform()`是用户调用的操作，当用户点击暴露在React组件上的按钮时发生。一旦`perform()`完成，`operationState`将变为`completed`。`CheckoutWorkflow`跟踪这一点，并自动加载序列中的下一个步骤。换句话说，工作流作为对当前步骤的`operationState`变化的反应（或副作用）而进展。让我们在以下一组代码片段中看到所有这些：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The constructor of `CheckoutWorkflow` sets up the core side effects. The first
    thing we need to know is the current page served by the browser using `this.tracker.page`.
    Remember that we are co-relating the `currentStep` of the workflow with the current
    URL-based route using a shared name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckoutWorkflow`的构造函数设置了核心副作用。我们需要知道的第一件事是浏览器使用`this.tracker.page`提供的当前页面。请记住，我们正在将工作流的`currentStep`与使用共享名称的基于URL的路由相关联。'
- en: The first side effect is executed using `autorun()`, which as we know, runs
    immediately and then any time the tracked observables change. Inside the `autorun()`,
    we are loading the `currentStep` by first making sure it is a valid step. Since
    we are observing the `currentStep` inside the `autorun()`, we have to ensure that
    we are keeping `this.tracker.page` in sync. We do this after successfully loading
    the current step. Now, any time the `currentStep` changes, `tracker.page` is automatically
    brought in sync, which means that the URL and route update to reflect the current
    step. We will see a little later how the `tracker`, an instance of `HistoryTracker`,
    actually handles this internally.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个副作用使用`autorun()`执行，我们知道它立即运行，然后在跟踪的可观察对象发生变化时运行。在`autorun()`内部，我们首先确保加载`currentStep`是有效的步骤。由于我们在`autorun()`内部观察`currentStep`，我们必须确保我们保持`this.tracker.page`同步。成功加载当前步骤后，我们这样做。现在，每当`currentStep`发生变化时，`tracker.page`会自动同步，这意味着URL和路由会更新以反映当前步骤。稍后我们将看到，`tracker`，即`HistoryTracker`的实例，实际上是如何在内部处理这一点的。
- en: The next side effect is the `reaction()` to the change in `tracker.page`. This
    is a counter-part to the previous side effect. Any time the `tracker.page` changes,
    we have to change the `currentStep` as well. After all, these two observables
    have to work in tandem. Because we are already tracking the `currentStep` with
    a separate side effect (the `autorun()`), the current `step` is loaded with the
    instance of the `WorkflowStep`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个副作用是对`tracker.page`的变化的`reaction()`。这是对先前副作用的对应部分。每当`tracker.page`发生变化时，我们也必须改变`currentStep`。毕竟，这两个可观察对象必须协同工作。因为我们已经通过一个单独的副作用（`autorun()`）来跟踪`currentStep`，当前的`step`加载了`WorkflowStep`的实例。
- en: 'One thing striking over here is that, when `currentStep` changes, `tracker.page`
    is updated. Also, when `tracker.page` changes, `currentStep` is updated. So, it
    may appear that there is an infinite loop here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引人注目的一点是，当`currentStep`改变时，`tracker.page`会更新。同样，当`tracker.page`改变时，`currentStep`也会更新。因此，可能会出现一个无限循环：
- en: '![](../images/00033.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: However, MobX will see that once the change is propagated in one direction,
    there is no update happening from the other side, as both are in sync. This means
    the two inter-dependent values quickly reach stability and there is no infinite
    loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MobX会发现一旦变化在一个方向上传播，另一方向就不会发生更新，因为两者是同步的。这意味着这两个相互依赖的值很快就会达到稳定状态，不会出现无限循环。
- en: Loading a step
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载步骤
- en: 'The `WorkflowStep` is where a step comes to life and the only one that can
    create an instance is the `CheckoutWorkflow`. After all, it is the owner of the
    entire workflow. It does this in the `loadStep()` action method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkflowStep`是步骤变得活跃的地方，唯一能创建实例的是`CheckoutWorkflow`。毕竟，它是整个工作流的所有者。它在`loadStep()`动作方法中执行此操作：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The interesting parts of the preceding code are outlined as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的有趣部分概述如下：
- en: We get the `stepClass` of the current step index by retrieving it from the list
    of steps. We create an instance of this `stepClass`, which is assigned to the
    observable `step` property.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过从步骤列表中检索当前步骤索引的`stepClass`来获得当前步骤索引的`stepClass`。我们创建了这个`stepClass`的实例，并将其分配给可观察的`step`属性。
- en: We then trigger the `load()` of the `WorkflowStep`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后触发`WorkflowStep`的`load()`。
- en: Possibly the most interesting part is awaiting the change in `operationState`
    of the `step`. We know from earlier that the `operationState` tracks the status
    of the main async operation of the step. Once it becomes `completed`, we know
    it's time to move to the next step.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能最有趣的部分是等待`step`的`operationState`改变。我们从前面知道，`operationState`跟踪步骤的主要异步操作的状态。一旦它变为`completed`，我们就知道是时候转到下一步了。
- en: 'Notice the use of the `when()` with a promise. This gives us a nice way to
    demarcate code that needs to execute after the `when()` resolves. Also notice
    that we are keeping track of the promise in the `nextStepPromise` property. This
    is needed to ensure that we also `cancel` out the promise in case we move to a
    different step before the current step completes. It is worth pondering when this
    situation could arise. **Hint**: The flow of steps is not always linear. A step
    could be changed via a *route change* as well, such as by clicking the back button
    of the browser!'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意使用带有promise的`when()`。这为我们提供了一个很好的方法来标记需要在`when()`解析后执行的代码。还要注意，我们在`nextStepPromise`属性中跟踪promise。这是为了确保在当前步骤完成之前，我们也要`cancel`掉promise。值得思考这种情况可能会出现的时候。**提示**：步骤的流程并不总是线性的。步骤也可以通过*路由更改*来更改，比如通过单击浏览器的返回按钮！
- en: The HistoryTracker
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史跟踪器
- en: The last piece of the *observable state puzzle* is the `HistoryTracker`, a class
    dedicated to monitoring the browser's URL and history. It relies on the `history`
    NPM package ([https://github.com/ReactTraining/history](https://github.com/ReactTraining/history))
    to do most of the work. The *history* package also powers the `react-router-dom`
    library, which we will be using for our React components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*observable state puzzle*的最后一部分是`HistoryTracker`，这是一个专门用于监视浏览器URL和历史记录的类。它依赖于`history`
    NPM包（[https://github.com/ReactTraining/history](https://github.com/ReactTraining/history)）来完成大部分工作。*history*包还为我们的React组件提供动力，我们将使用`react-router-dom`库。'
- en: 'The core responsibility of `HistoryTracker` is to expose an observable called
    `page` that tracks the current URL (route) in the browser. It also does the reverse
    where it keeps the URL in sync with the current `page`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistoryTracker`的核心责任是公开一个名为`page`的observable，用于跟踪浏览器中的当前URL（路由）。它还会反向操作，使URL与当前`page`保持同步：'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the `reaction()` set up in the constructor, a route change (URL change)
    is effectively a side effect of a change in the `page` observable. This is achieved
    by pushing a route (URL) onto the browser history.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中设置了`reaction()`，路由更改（URL更改）实际上是`page` observable变化的副作用。这是通过将路由（URL）推送到浏览器历史记录中实现的。
- en: 'The other important aspect of `HistoryTracker`, as the name suggests, is tracking
    the browser history. This is done with the `startListening()` method, which can
    be invoked by the consumers of this class. The `CheckoutWorkflow` calls this in
    its constructor to set up the tracker. Note that `startListening()` is given a
    map of routes, with the `key` pointing to a URL path:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistoryTracker`的另一个重要方面，正如其名称所示，是跟踪浏览器历史记录。这是通过`startListening()`方法完成的，可以由此类的消费者调用。`CheckoutWorkflow`在其构造函数中调用此方法来设置跟踪器。请注意，`startListening()`接收一个路由映射，其中`key`指向URL路径：'
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the URL changes in the browser, the `page` observable is updated accordingly.
    This happens in the `identifyRoute()` method, which is called from the callback
    to `history.listen()`. We have decorated it with action since it *mutates* the
    `page` observable. Internally, MobX notifies all of the observers of `page`—for
    example, `CheckoutWorkflow`, which uses the `page` observable to update its `currentStep`.
    This keeps the whole routing in sync and ensures that the changes are bi-directional.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器中的URL更改时，`page` observable会相应地更新。这发生在`identifyRoute()`方法中，该方法从`history.listen()`的回调中调用。我们已经用action修饰它，因为它会*改变*`page`
    observable。在内部，MobX会通知所有`page`的观察者，例如`CheckoutWorkflow`，它使用`page` observable来更新其`currentStep`。这保持了整个路由同步，并确保更改是双向的。
- en: 'The following diagram shows the bi-directional syncing of the `currentStep`,
    `page`, and the *url-route*. Note that the interactions with the `history` package
    are shown in *grey* arrows, while the dependencies between observables are shown
    in orange arrows. This difference in color is intentional and suggests that *url-based-routing*
    is effectively a side effect of change in the observable state:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`currentStep`、`page`和*url-route*之间的双向同步。请注意，与`history`包的交互显示为*灰色*箭头，而observable之间的依赖关系显示为橙色箭头。这种颜色上的差异是有意的，并表明*基于url的路由*实际上是observable状态变化的副作用：
- en: '![](../images/00034.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: The React components
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件
- en: 'In this example, modeling of the observable state is more interesting than
    the React UI components. On the React side, we have the top level component that
    sets up the `Provider` with the instance of `CheckoutWorkflow` as the `store`.
    The `Provider` comes from the `mobx-react` package and helps in injecting the
    `store` to any React component decorated with `inject()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，observable状态的建模比React UI组件更有趣。在React方面，我们有设置`Provider`的顶层组件，其中`store`是`CheckoutWorkflow`的实例。`Provider`来自`mobx-react`包，并帮助将`store`注入到任何使用`inject()`装饰的React组件中：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `App` component simply sets up all the Routes using the `react-router-dom`
    package. The paths used in the `<Route />` components match the URLs we saw earlier
    on the `routes` object. Notice that the `history` from the `HistoryTracker` is
    used for the `Router`. This allows sharing of the browser history between *react-router*
    and *mobx*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件只是使用`react-router-dom`包设置所有路由。在`<Route />`组件中使用的路径与我们在`routes`对象中看到的URL匹配。请注意，`HistoryTracker`中的`history`用于`Router`。这允许在*react-router*和*mobx*之间共享浏览器历史记录：'
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned earlier, we have deliberately kept the individual steps of the
    workflow very simple. They all follow a fixed template, as described by the `WorkflowStep`.
    Its React counterpart is `TemplateStepComponent`, which renders the step and exposes
    the button for navigating to the next step.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们故意保持了工作流程的各个步骤非常简单。它们都遵循固定的模板，由`WorkflowStep`描述。它的React对应物是`TemplateStepComponent`，它呈现步骤并公开按钮，用于导航到下一步。
- en: The TemplateStepComponent
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TemplateStepComponent
- en: '`TemplateStepComponent` gives the visual representation to the `WorkflowStep`.
    It renders the feedback when the step is loading and also when the main operation
    is being performed. Additionally, it shows the details of the step once it is
    loaded. These details are shown via the `renderDetails` prop, which accepts a
    React component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateStepComponent`为`WorkflowStep`提供了可视化表示。当步骤正在加载时，它会呈现反馈，当主要操作正在执行时也是如此。此外，它会在加载后显示步骤的详细信息。这些细节通过`renderDetails`属性显示，该属性接受一个React组件：'
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Observer` component is something we have not seen before. This is a special
    component provided by the `mobx-react` package that simplifies the creation of
    granular observers. A typical MobX observer component will require you to create
    a separate component, decorate it with `observer()` and/or `inject()` it, and
    ensure that the proper observables are passed as props into that component. You
    can bypass all that ceremony by simply wrapping a section of the *virtual-dom*
    with `<Observer />`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`组件是我们以前没有见过的东西。这是由`mobx-react`包提供的一个特殊组件，简化了粒度观察者的创建。典型的MobX观察者组件将要求您创建一个单独的组件，用`observer()`和/或`inject()`装饰它，并确保适当的可观察对象作为props传递到该组件中。您可以通过简单地用`<Observer
    />`包装*虚拟DOM*的一部分来绕过所有这些仪式。'
- en: 'It accepts a function as its only child, wherein you can read observables from
    the surrounding scope. MobX will automatically track the observables being used
    in the *function-as-child component*. A closer look at the `Observer` reveals
    these details:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个函数作为它唯一的子元素，在其中您可以从周围范围读取可观察对象。MobX将自动跟踪*函数作为子组件*中使用的可观察对象。仔细观察`Observer`会揭示这些细节：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding snippet, we are passing a function as the child to `<Observer
    />`. Within that function, we use the `step.loadState` observable. MobX automatically
    renders the *function-as-child* component when the `step.loadState` changes. Notice
    that we are not passing any props into the `Observer` or to the child component.
    It reads it directly from the props of the outer component. This is the advantage
    of using `Observer`. You can create anonymous observers without much effort.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们将一个函数作为`<Observer />`的子元素传递。在该函数中，我们使用`step.loadState`可观察对象。当`step.loadState`发生变化时，MobX会自动呈现*函数作为子组件*。请注意，我们没有将任何props传递给`Observer`或子组件。它直接从外部组件的props中读取。这是使用`Observer`的优势。您可以轻松创建匿名观察者。
- en: A subtle point to note is that `TemplateStepComponent` is not an observer itself.
    It simply gets hold of the `store` with `inject()`, which is then used inside
    the `<Observer />` regions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微妙的要点是`TemplateStepComponent`本身不是一个观察者。它只是用`inject()`获取`store`，然后在`<Observer
    />`区域内使用它。
- en: The ShowCart component
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ShowCart组件
- en: '`ShowCart` is the component that shows the list of items in the cart. Here,
    we are reusing the `TemplateStepComponent` and plugin details of the cart with
    the `renderDetails` prop. This can be seen in the following code. We are not showing
    the `CartItem` and `TotalItem` components for simplicity. They are pure presentation
    components that render a single cart item:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowCart`是显示购物车中物品列表的组件。在这里，我们正在重用`TemplateStepComponent`和购物车的插件细节，使用`renderDetails`属性。这可以在以下代码中看到。为简单起见，我们不显示`CartItem`和`TotalItem`组件。它们是纯粹的呈现组件，用于呈现单个购物车项目：'
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A state-based router
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于状态的路由器
- en: You can now see how the routing between all the `WorkflowStep` instances is
    achieved purely via a state-based approach. All of the navigation logic lies inside
    the MobX store, which in this case is `CheckoutWorkflow`. By connecting the observables
    (`tracker.page`, `currentStep`, and `step`) via a set of reactions, we have created
    *side effects* that update the browser history as well as create instances of
    `WorkflowStep`, which are used by the `TemplateStepComponent`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到，所有`WorkflowStep`实例之间的路由纯粹是通过基于状态的方法实现的。所有导航逻辑都在MobX存储中，这种情况下是`CheckoutWorkflow`。通过连接可观察对象（`tracker.page`，`currentStep`和`step`）通过一系列反应，我们创建了更新浏览器历史的*副作用*，并创建了`WorkflowStep`的实例，这些实例由`TemplateStepComponent`使用。
- en: Because we are sharing the browser history (via `HistoryTracker`) between `react-router-dom`
    and MobX, we can keep the observables in sync with the URL changes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`react-router-dom`和MobX之间共享浏览器历史（通过`HistoryTracker`），我们可以使可观察对象与URL更改保持同步。
- en: This state-based approach to routing helps in keeping a crisp mental model of
    the workflow. All of the logic of your feature stays inside the MobX Store, improving
    the readability. Writing *unit tests* for such a state-based solution is also
    straightforward. In fact, it is not surprising to have most of the unit tests
    in a MobX app to be centered around *stores* and *reactions*. Many of the React
    components become pure observers of the observables and can be treated as plain
    *presentation components*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于状态的路由方法有助于保持清晰的工作流心智模型。您的功能的所有逻辑都留在MobX Store中，提高了可读性。为这种基于状态的解决方案编写单元测试也很简单。事实上，在MobX应用程序中，大多数单元测试都围绕存储和反应中心。许多React组件成为可观察对象的纯粹观察者，并且可以被视为普通的演示组件。
- en: With MobX, you have the flexibility to focus squarely on the domain logic and
    ensure that there is appropriate *observable state* that can be rendered on the
    UI. By encapsulating all of the domain logic and state inside the stores, and
    all presentation in the React components, there is clear separation of concerns.
    This greatly improves the **developer experience** (**DX**) and helps you scale
    better over time. That is the true promise of MobX.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MobX，您可以专注于领域逻辑，并确保UI上有适当的可观察状态。通过将所有领域逻辑和状态封装在存储中，并将所有演示内容放在React组件中，可以清晰地分离关注点。这极大地改善了开发者体验（DX），并有助于随着时间的推移更好地扩展。这是MobX的真正承诺。
- en: For a more feature-rich, state-based routing solution with MobX, look at` mobx-state-router` ([https://github.com/nareshbhatia/mobx-state-router](https://github.com/nareshbhatia/mobx-state-router)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更丰富功能的基于状态的路由解决方案，请查看`mobx-state-router`（[https://github.com/nareshbhatia/mobx-state-router](https://github.com/nareshbhatia/mobx-state-router)）。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we applied a variety of techniques and concepts that we have
    learned over the last few chapters. Each of the two examples, f*orm validation*
    and p*age routing*, presented a unique set of approaches for modeling the observable
    state. We also saw how to create granular observer components to enable efficient
    rendering of the React components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们应用了我们在过去几章中学到的各种技术和概念。两个示例，表单验证和页面路由，分别提出了一套建模可观察状态的独特方法。我们还看到了如何创建细粒度的观察者组件，以实现React组件的高效渲染。
- en: 'A practical application of MobX always starts with modeling the *observable
    state*. After all, that is the data that drives the UI. The next step is to identify
    the *actions* that mutate the observables. Finally, you need to call out the *side-effects*
    and see which observables these effects depend on. This is the side effect model
    that''s applied to real-world scenarios, manifesting in the form of the MobX triad:
    O*bservables-Actions-Reactions*.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的实际应用始终以建模*可观察状态*为起点。毕竟，这就是驱动UI的数据。下一步是确定改变可观察状态的*动作*。最后，您需要调用*副作用*，并查看这些效果依赖于哪些可观察状态。这就是应用于现实场景的副作用模型，以MobX三元组的形式呈现：*可观察状态-动作-反应*。
- en: With all of the knowledge we have accumulated so far, we are now ready to go
    deeper into MobX, starting with [Chapter 7](part0124.html#3M85O0-58c2559ca4304cecab9bc46f496bc070), *Special
    API for Special Cases*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今积累的所有知识，我们现在准备深入了解MobX，从[第7章](part0124.html#3M85O0-58c2559ca4304cecab9bc46f496bc070)开始，*特殊情况的特殊API*。
