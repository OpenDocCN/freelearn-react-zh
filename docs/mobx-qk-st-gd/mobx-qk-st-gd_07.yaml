- en: Special API for Special Cases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊情况的特殊API
- en: The MobX API surface is very lean and exposes the right abstractions for dealing
    with your state management logic. In most situations, the APIs we have seen thus
    far will suffice. However, there will always be those gnarly edge cases that demand
    a slight deviation from the well-trodden path. It is for these by-lanes for which
    MobX gives you some special APIs. We will look at some of these in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的API表面非常简洁，为处理状态管理逻辑提供了正确的抽象。在大多数情况下，我们已经看到的API将足够。然而，总会有一些棘手的边缘情况需要略微偏离常规。正是为了这些特殊情况，MobX为您提供了一些特殊的API。我们将在本章中看到其中一些。
- en: 'The topics we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Direct manipulation with the object API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象API进行直接操作
- en: Using `inject()` and `observe()` to hook into the internal MobX eventing system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`inject()`和`observe()`来连接到内部MobX事件系统。
- en: Special utility functions and tools that will help in debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有助于调试的特殊实用函数和工具
- en: Quick mention of some miscellaneous APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速提及一些杂项API
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备JavaScript编程语言。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter07](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter07)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter07](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter07)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的运行情况：
- en: '[http://bit.ly/2A1Or6V](http://bit.ly/2A1Or6V)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2A1Or6V](http://bit.ly/2A1Or6V)'
- en: Direct manipulation with the object API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象API进行直接操作
- en: When deciding on the data structures for your observable state, your natural
    choice should be to reach out for `observable.object()`, `observable.array()`,
    `observable.map()`, `observable.box()`, or to use the convenient `observable()`
    API. Manipulating these data structures is as simple as mutating the properties
    directly or adding and removing elements as needed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定可观察状态的数据结构时，您的自然选择应该是使用`observable.object()`、`observable.array()`、`observable.map()`、`observable.box()`，或者使用方便的`observable()`API。操作这些数据结构就像直接改变属性或根据需要添加和删除元素一样简单。
- en: MobX gives you yet another way to surgically make changes to your data structures.
    It exposes a granular object API that can mutate these data structures at runtime.
    In fact, it gives you some capabilities that are not even possible with the original
    data structures. For example, adding new properties to observable objects and
    also keeping it reactive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MobX为您提供了另一种对数据结构进行手术式更改的方法。它公开了一个细粒度的对象API，可以在运行时改变这些数据结构。事实上，它为您提供了一些原始数据结构甚至不可能的功能。例如，向可观察对象添加新属性，并保持其响应性。
- en: Granular reads and writes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细粒度读取和写入
- en: 'The object API is focused on giving you granular control over the observable
    properties of top-level data structures: objects, arrays, and maps. In doing so,
    they continue to play well with the MobX reactive system and ensure the granular
    changes you make are picked up by the *reactions*. The following APIs apply to
    observable objects/arrays/maps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对象API专注于对顶层数据结构（对象、数组和映射）的可观察属性进行细粒度控制。通过这样做，它们继续与MobX的响应式系统良好地配合，并确保您所做的细粒度更改被*reactions*捕获。以下API适用于可观察的对象/数组/映射：
- en: '`get(thing, key)`: Retrieves the value under the key. This key can even be
    non-existent. When used in a reaction, it will trigger a re-execution when that
    key becomes available.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(thing, key)`: 检索键下的值。这个键甚至可以不存在。当在反应中使用时，当该键变为可用时，它将触发重新执行。'
- en: '`set(thing, key, value)` or `set(thing, { key: value })`: sets a value for
    the key. The second form is better for setting multiple *key-value* pairs at once.
    Conceptually, it is very similar to `Object.assign()`, but with the addition of
    being reactive.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(thing, key, value)` 或 `set(thing, { key: value })`: 为键设置一个值。第二种形式更适合一次设置多个*键-值*对。在概念上，它与`Object.assign()`非常相似，但增加了响应性。'
- en: '`has(thing, key)`: Gives back a boolean indicating if the key is present.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has(thing, key)`: 返回一个布尔值，指示键是否存在。'
- en: '`remove(thing, key)`: Removes the given key and its value.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(thing, key)`: 删除给定的键及其值。'
- en: '`values(thing)`: Gives an array of values.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values(thing)`: 给出一个值数组。'
- en: '`keys(thing)`: Gives an array containing all the keys. Note that this only
    applies to observable objects and maps.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys(thing)`: 返回包含所有键的数组。请注意，这仅适用于可观察对象和映射。'
- en: '`entries(thing)`: Gives back an array of key-value pairs, where each pair is
    an array of two elements (`[key, value]`).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entries(thing)`: 返回一个键值对数组，其中每对是两个元素的数组（`[key, value]`）。'
- en: 'The following snippet exercises all of these APIs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段练习了所有这些API：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By using these APIs, you can target specific properties of the observables and
    update them as necessary. Reading and writing to keys that *don't exist* is considered
    valid with the object API. Notice how we read the `metadata` property of `firstTodo`
    in `autorun()`, which does not exist at the time of the call. However, MobX still
    tracks this key due to the use of the `get()` API. When we `set()` the `metadata`
    later in an action, `autorun()` is re-triggered to print it out on the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些API，您可以针对可观察对象的特定属性并根据需要进行更新。使用对象API读取和写入*不存在*的键被认为是有效的。请注意，我们在`autorun()`中读取`firstTodo`的`metadata`属性，这在调用时并不存在。然而，由于使用了`get()`API，MobX仍然跟踪这个键。当我们在操作中稍后`set()`了`metadata`时，`autorun()`会重新触发以在控制台上打印出它。
- en: 'This can be seen in the following console output. Notice how the `metadata`
    check goes from `false` to `true` and back to `false` when removed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '这可以在以下控制台输出中看到。请注意，当移除时，`metadata`检查从`false`变为`true`，然后再变回`false`： '
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From MobX to JavaScript
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MobX到JavaScript
- en: All of the observable types are special classes created by MobX that not only
    store data but also a bunch of housekeeping to track changes. We will explore
    this housekeeping in a later chapter, but for our discussion now, it suffices
    to say that these MobX types are not always compatible with other third-party
    APIs, especially when using MobX 4.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的可观察类型都是由MobX创建的特殊类，它们不仅存储数据，还有一堆用来跟踪变化的杂事。我们将在后面的章节中探讨这些杂事，但就我们现在的讨论而言，这些MobX类型并不总是与其他第三方API兼容，特别是在使用MobX
    4时。
- en: 'When interfacing with external libraries, you may need to send the raw JavaScript
    values instead of the MobX-typed values. This is where you need the `toJS()` function.
    It will convert the MobX observables to raw JavaScript values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当与外部库进行接口时，您可能需要发送原始的JavaScript值，而不是MobX类型的值。这就是您需要`toJS()`函数的地方。它将MobX可观察对象转换为原始的JavaScript值：
- en: '`toJS(source, options?)`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`toJS(source, options?)`'
- en: '`source`: Any observable box, object, array, map, or primitives.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`: 任何可观察的盒子、对象、数组、映射或基元。'
- en: '`options`: An optional argument to control behavior, such as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`: 一个可选参数，用于控制行为，例如：'
- en: '`exportMapsAsObject` (*boolean*): Whether to serialize the observable maps
    as objects (when `true`) or as JavaScript Maps (when `false`). Default is `true`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exportMapsAsObject` (*boolean*): 是否将可观察的映射序列化为对象（当为`true`时）或JavaScript映射（当为`false`时）。默认为`true`。'
- en: '`detectCycles` (*boolean*): This is set to `true` by default. It detects cyclic
    references during serialization and reuses the already serialized object. This
    is a good default in most cases, but for performance reasons this can be set to
    `false` when you are sure of no cyclic references.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectCycles` (*boolean*): 默认设置为`true`。它在序列化过程中检测循环引用，并重用已经序列化的对象。在大多数情况下，这是一个很好的默认设置，但出于性能原因，当你确定没有循环引用时，可以将其设置为`false`。'
- en: An important point to note with `toJS()` is that it does not serialize *computed
    properties*. This makes sense since it's purely derived information that can always
    be recomputed. The purpose of `toJS()` is to serialize the core observable state
    only. Similarly, any non-enumerable properties of the observable will not be serialized
    nor will they recurse into any non-observable data structures.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`toJS()`的一个重要注意点是它不会序列化*computed properties*。这是有道理的，因为它纯粹是可以随时重新计算的派生信息。`toJS()`的目的是仅序列化核心observable状态。同样，observable的任何不可枚举属性都不会被序列化，也不会递归到任何非observable的数据结构中。'
- en: 'In the following example, you can see how the `toJS()` API is applied to observables:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，你可以看到`toJS()` API是如何应用于observables的：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The console output shows you the `cart` observable before and after applying
    the `toJS()` API:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出显示了在应用`toJS()` API之前和之后的`cart` observable。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Watching the events flow by
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察事件流动
- en: The APIs we have seen in the previous chapters allow you to create observables
    and react to the changes via *reactions*. MobX also gives you a way to tap into
    the events that flow internally to make the reactive system work. By attaching
    listeners to these events, you can fine-tune the use of some expensive resources
    or control which updates are allowed to be applied to the observables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中看到的API允许你创建observables并通过*reactions*对变化做出反应。MobX还提供了一种方法来连接到内部流动的事件，使得响应式系统能够工作。通过将监听器附加到这些事件，你可以微调一些昂贵资源的使用或控制允许应用于observables的更新。
- en: Hooking into the observability
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到可观察性
- en: Normally, *reactions* are the place where we read *observables* and apply some
    side effects. This tells MobX to start tracking the observable and re-trigger
    the reaction on changes. However, if we look at this from the *perspe*ctive of
    the observable, how does it know when it is being used by a reaction? How can
    it do a one-time setup when it is read in a reaction and also clean up when it's
    no longer being used?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*reactions*是我们读取*observables*并应用一些副作用的地方。这告诉MobX开始跟踪observable并在变化时重新触发reaction。然而，如果我们从observable的*角度*来看，它如何知道它何时被reaction使用？它如何在被reaction读取时进行一次性设置，并在不再被使用时进行清理？
- en: 'What we need here is the ability to know when an observable becomes *observed*
    and when it becomes *unobserved*: the two points in time where it becomes active
    and inactive in the MobX reactive system. For that, we have the following aptly
    named APIs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是能够知道何时observable变为*observed*和何时变为*unobserved*：它在MobX响应式系统中变为活动和非活动的两个时间点。为此，我们有以下恰如其名的APIs：
- en: '`disposer = onBecomeObserved(observable, property?: string, listener: () =>
    void)`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disposer = onBecomeObserved(observable, property?: string, listener: () =>
    void)`'
- en: '`disposer = onBecomeUnobserved(observable, property?: string, listener: ()
    => void)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disposer = onBecomeUnobserved(observable, property?: string, listener: ()
    => void)`'
- en: '`observable`: Can be a boxed observable, an observable object/array/map.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable`：可以是一个包装的observable，一个observable对象/数组/映射。'
- en: '`property:` An optional property of the observable. Specifying a property is
    fundamentally different than referencing the property directly. For example, `onBecomeObserved(cart,
    ''totalPrice'', () => {})` is different compared to `onBecomeObserved(cart.totalPrice,
    () => {})`. In the first case, MobX will be able to track the observable property
    but in the second case it won''t, since it is only receiving the value rather
    than the property. In fact, MobX will throw an `Error`, indicating that there
    is nothing to track in the case of `cart.totalPrice`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`property:` 可观察对象的可选属性。指定属性与直接引用属性有根本的不同。例如，`onBecomeObserved(cart, ''totalPrice'',
    () => {})`与`onBecomeObserved(cart.totalPrice, () => {})`是不同的。在第一种情况下，MobX将能够跟踪可观察属性，但在第二种情况下，它不会，因为它只接收值而不是属性。事实上，MobX将抛出一个`Error`，指示在`cart.totalPrice`的情况下没有东西可跟踪：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding error may not make much sense now, especially the term atom. We
    will look atoms in more detail in [Chapter 9](part0165.html#4TBCQ0-58c2559ca4304cecab9bc46f496bc070),
    *Mobx Internals*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误现在可能没有太多意义，特别是原子一词。我们将在[第9章](part0165.html#4TBCQ0-58c2559ca4304cecab9bc46f496bc070)
    *Mobx Internals*中更详细地了解原子。
- en: '`disposer`: The return value of these handlers. This is a function that can
    be used to dispose these handlers and clean up the event wiring.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`disposer`: 这些处理程序的返回值。这是一个函数，可用于处理这些处理程序并清理事件连接。'
- en: 'The following snippet shows these APIs in action:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了这些API的使用：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding snippet, the `onBecomeObserved()` handlers will be called
    when `autorun()` executes for the first time. Upon calling the `disposer` function,
    the `onBecomeUnobserved()` handlers are invoked. This can be seen in the following
    console output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，当`autorun()`第一次执行时，`onBecomeObserved()`处理程序将被调用。调用`disposer`函数后，将调用`onBecomeUnobserved()`处理程序。这可以在以下控制台输出中看到：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`onBecomeObserved()` and `onBecomeUnobserved()` are great hooks to lazily set
    up (and tear down) an observable on its first use (and last use). This is useful
    in cases where there might be an expensive operation that is required to set the
    initial value of the observable. Such operations can be lazily performed by deferring
    until it is actually used somewhere.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBecomeObserved()`和`onBecomeUnobserved()`是延迟设置（和清除）可观察对象的绝佳钩子，可以在首次使用（和最后一次使用）时进行。这在某些情况下非常有用，例如可能需要执行昂贵的操作来设置可观察对象的初始值。此类操作可以通过推迟执行，直到实际上某处使用它时才执行。'
- en: Lazy loading the temperature
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载温度
- en: 'Let''s take an example where we will lazy load the *temperature* for a city,
    but only when it is accessed. This can be done by modeling the observable property
    with the hooks for `onBecomeObserved()` and `onBecomeUnobserved()`. The following
    snippet shows this in action:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们将延迟加载城市的*温度*，但只有在访问时才加载。这可以通过使用`onBecomeObserved()`和`onBecomeUnobserved()`的钩子对可观察属性进行建模来实现。以下代码片段展示了这一点：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding console output shows you the activation and deactivation for
    the `temperature` observable. It is activated in `autorun()` and after 15 seconds,
    it gets *deactivated*. We kick off the timer that keeps updating the *temperature*
    in the `onBecomeObserved()` handler and clear it in the `onBecomeUnobserved()` handler.
    The *timer* is the resource we manage that is created only when the `temperature`
    is accessed and not before:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的控制台输出显示了`temperature`可观察对象的激活和停用。它在`autorun()`中被激活，15秒后被*停用*。我们在`onBecomeObserved()`处理程序中启动定时器来不断更新*温度*，并在`onBecomeUnobserved()`处理程序中清除它。*定时器*是我们管理的资源，只有在访问`temperature`之后才会创建，而不是之前：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Gatekeeper of changes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化的守门人
- en: 'The changes you make to an observable are not applied immediately by MobX.
    Instead, they go through a layer of interceptors that have the ability to keep
    the change, modify it, or even discard it completely. This is all possible with
    the `intercept()` API. The signature is very similar to `onBecomeObserved` and
    `onBecomeUnobserved`, with the callback function (*interceptor*) giving you the
    change object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您对observable所做的更改不会立即应用于MobX。相反，它们经过一层拦截器，这些拦截器有能力保留变化、修改变化，甚至完全丢弃变化。这一切都可以通过`intercept()`API实现。签名与`onBecomeObserved`和`onBecomeUnobserved`非常相似，回调函数（*interceptor*）给出了change对象：
- en: '`disposer = intercept(observable, property?, interceptor: (change) => change
    | null )`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`disposer = intercept(observable, property?, interceptor: (change) => change
    | null )`'
- en: '`observable`: A boxed observable or an observable object/array/map.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable`：一个封装的observable或observable对象/数组/映射。'
- en: '`property`: The optional string name of the property you want to intercept
    on the observable. As we saw earlier for `onBecomeObserved` and `onBecomeUnobserved`,
    there is a difference between `intercept(cart, ''totalPrice'', (change) => {})`
    and `intercept(cart.totalPrice, () => {})`. For the latter (`cart.totalPrice`),
    you are intercepting a value instead of the observable property. MobX will throw
    an error, stating that you haven''t passed the correct type.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`：要拦截的observable的可选字符串名称。就像我们之前在`onBecomeObserved`和`onBecomeUnobserved`中看到的那样，对于`intercept(cart,
    ''totalPrice'', (change) => {})`和`intercept(cart.totalPrice, () => {})`有所不同。对于后者（`cart.totalPrice`），您拦截的是一个值而不是observable属性。MobX将抛出错误，指出您未传递正确的类型。'
- en: '`interceptor`: A callback that receives the change object and is expected to
    return the final change; apply as-is, modify, or discard (`null`). It is also
    valid to throw an error in the interceptor to notify exceptional updates.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`interceptor`：一个回调函数，接收change对象并期望返回最终的变化；原样应用、修改或丢弃（`null`）。在拦截器中抛出错误也是有效的，以通知异常更新。'
- en: '`disposer`: Gives back a function, which when called will cancel this interceptor.
    This is very similar to what we have seen with `onBecomeObserved()`, `onBecomeUnobserved()`,
    and even reactions like `autorun()`, `reaction()`, and `when()`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`disposer`：返回一个函数，当调用时将取消此拦截器。这与我们在`onBecomeObserved()`、`onBecomeUnobserved()`以及`autorun()`、`reaction()`和`when()`中看到的非常相似。'
- en: Intercepting the change
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截变化
- en: 'The change argument that is received has some known fields that give the details.
    The most important of these are the `type` field, which tells you the *type of
    change*, and `object`, which gives the *object on which the change happened*.
    Depending upon the `type`, a few other fields add more context to the change:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的change参数具有一些已知字段，提供了详细信息。其中最重要的是`type`字段，它告诉您*变化的类型*，以及`object`，它给出了*发生变化的对象*。根据`type`，一些其他字段为变化添加了更多的上下文：
- en: '`type`: Can be one of add, delete, or update'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：可以是add、delete或update之一'
- en: '`object`: A boxed observable or the observable object/array/map instance'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object`：一个封装的observable或observable对象/数组/映射实例'
- en: '`newValue`: When the type is add or update, this fields contains the new value'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newValue`：当类型为add或update时，此字段包含新值'
- en: '`oldValue`: When the type is delete or update, this field carries the previous
    value'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oldValue`：当类型为delete或update时，此字段携带先前的值'
- en: 'Inside the interceptor callback, you have the opportunity to finalize the type
    of change you actually want to apply. You can do one of the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在拦截器回调中，您有机会最终确定您实际想要应用的变化类型。您可以执行以下操作之一：
- en: Return null and discard the change
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回null并丢弃变化
- en: Update with a different value
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的值进行更新
- en: Throw an error indicating an exceptional value
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出指示异常值的错误
- en: Return as-is and apply the change
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原样返回并应用变化
- en: 'Let''s take an example of intercepting the theme changes and ensuring that
    only valid updates are applied. In the following snippet, you can see how we intercept
    the `color` property of the theme observable. The color can either be *light*
    or *dark*, or have a shorthand value of `l` or `d`. For any other value, we throw
    an error. We also guard against unsetting the color by returning `null` and discarding
    the change:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个拦截主题更改并确保只应用有效更新的示例。在下面的片段中，您可以看到我们如何拦截主题可观察对象的`color`属性。颜色可以是*light*或*dark*，也可以是`l`或`d`的简写值。对于任何其他值，我们会抛出错误。我们还防止取消颜色的设置，通过返回`null`并丢弃更改：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: observe() the changes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察()变化
- en: 'The utility that acts as the counterpart of `intercept()` is `observe()`. `observe()`,
    as the name suggests, allows you to make granular observations on observables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`intercept()`对应的实用程序是`observe()`。正如其名称所示，`observe()`允许您对可观察对象进行细粒度观察：
- en: '`observe(observable, property?, observer: (change) => {})`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`observe(observable, property?, observer: (change) => {})`'
- en: The signature is exactly like `intercept()`, but the behavior is quite different.
    `observe()` is invoked *after the change* has been applied to the observable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 签名与`intercept()`完全相同，但行为完全不同。`observe()`在可观察对象被应用更改后被调用。
- en: An interesting characteristic is that `observe()` is immune to *transactions*.
    What this means is that the *observer callback* is invoked immediately after a
    mutation and does not wait until the transaction completes. As you are aware,
    *actions* are the places where a mutation happens. MobX optimizes the notifications
    by firing them, but only after the top-most *action* completes. With `observe()`,
    you get an unfiltered view of the mutations as and when they happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的特点是`observe()`对*事务*是免疫的。这意味着*观察者回调*会在突变后立即被调用，而不是等到事务完成。正如您所知，*actions*是发生突变的地方。MobX通过触发它们来优化通知，但只有在顶层*action*完成后才会触发。使用`observe()`，您可以在突变发生时获得未经过滤的视图。
- en: It is recommended to use `autorun()` whenever you feel a need for `observe()`.
    Use it only when you think you need immediate notification for a mutation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在感觉需要`observe()`时使用`autorun()`。仅在您认为需要立即通知突变时使用它。
- en: 'The following example shows the various details you can observe on mutating
    an observable. As you can see, the `change` argument is exactly like `intercept()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在突变可观察对象时您可以观察到的各种细节。正如您所看到的，`change`参数与`intercept()`完全相同：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Development utilities
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: As you scale your applications with more features, it becomes mandatory to understand
    how and when the MobX reactive system is being used. MobX comes with a set of
    debugging utilities that help you monitor and trace the various activities happening
    inside it. These give you a real-time view of all the observable changes, actions,
    and reactions firing inside the system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序功能的增加，了解MobX反应系统的使用方式和时间变得必不可少。MobX配备了一组调试工具，帮助您监视和跟踪其中发生的各种活动。这些工具为您提供了系统内所有可观察变化、操作和反应的实时视图。
- en: Using spy() to track the reactivity
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用spy()跟踪反应性
- en: 'Earlier, we saw the `observe()` function, which allows you to *"observe"* the
    changes happening to a single observable. But what if you wanted to observe changes
    happening across all observables without having to individually set up the `observe()`
    handlers? That is where `spy()` comes in. It gives you insight into how the various
    observables in your system are changing over time:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了`observe()`函数，它允许您对单个可观察对象发生的变化进行*"观察"*。但是，如果您想观察跨所有可观察对象发生的变化，而不必单独设置`observe()`处理程序，该怎么办？这就是`spy()`发挥作用的地方。它让您了解系统中各种可观察对象随时间变化的情况：
- en: '`disposer = spy(listener: (event) => { })`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`disposer = spy(listener: (event) => { })`'
- en: 'It takes in a *listener function* that receives an event object carrying all
    the details. The *event* has properties very similar to the `observe()` handler.
    There is a `type` field that tells you about the type of the event. The type can
    be one of:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个*监听函数*，该函数接收携带所有细节的事件对象。*事件*具有与`observe()`处理程序非常相似的属性。有一个`type`字段告诉您事件的类型。类型可以是以下之一：
- en: '**update**: For object, array, map'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**update**：对于对象、数组、映射'
- en: '**add**: For object, array, map'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**add**：对于对象、数组、映射'
- en: '**delete**: For map'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**delete**：对于映射'
- en: '**create**: For boxed observables'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**create**：对于包装的可观察对象'
- en: '**action**: When an action fires'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**action**：当动作触发时'
- en: '**reaction**: Upon execution of `autorun()`, `reaction()`, or `when()`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reaction**：在执行`autorun()`、`reaction()`或`when()`时'
- en: '**compute**: For computed properties'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**compute**：对于计算属性'
- en: '**error**: In case of any caught exceptions inside actions or reactions'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：在操作或反应内捕获任何异常的情况下'
- en: 'Here is a snippet of code that sets up a `spy()` and prints the output to the
    console. We are also disposing this spy after five seconds:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一小段设置`spy()`并将输出打印到控制台的代码片段。我们还将在五秒后取消此间谍：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some of the spy events may be accompanied by `spyReportStart` or `spyReportEnd`
    properties. These mark a group of events that are related.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些间谍事件可能伴随着`spyReportStart`或`spyReportEnd`属性。这些标记了一组相关的事件。
- en: Using `spy()` directly is probably not your best option during development.
    It is better to rely on the visual debugger (discussed in the following section),
    which makes use of `spy()` to give you more readable logs. Note that the calls
    to `spy()` are a *no-op* for production builds when you set the `NODE_ENV` environment
    variable to *"production"*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中直接使用`spy()`可能不是最佳选择。最好依赖于可视化调试器（在下一节中讨论），它利用`spy()`来为您提供更可读的日志。请注意，当您将`NODE_ENV`环境变量设置为*"production"*时，对`spy()`的调用在生产构建中将是*无操作*。
- en: Tracing a reaction
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪反应
- en: 'While `spy()` gives you a lens to observe all changes happening in MobX, `trace()`
    is a utility that is specifically focused on computed properties, reactions, and
    component renders. You can find out why a *computed property*, *reaction,* or
    a *component render* is being invoked by simply placing a `trace()` statement
    inside it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`spy()`可以让您观察MobX中发生的所有更改，但`trace()`是一个专门针对计算属性、反应和组件渲染的实用程序。您可以通过简单地在其中放置一个`trace()`语句来找出为什么会调用*计算属性*、*反应*或*组件渲染*：
- en: '`trace(thing?, property?, enterDebugger?)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace(thing?, property?, enterDebugger?)`'
- en: 'It has three *optional* arguments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个*可选*参数：
- en: '`thing`: An observable'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thing`：一个可观察对象'
- en: '`property`: An observable property'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property`：一个可观察属性'
- en: '`enterDebugger`: A Boolean flag indicating whether you want to step into the
    debugger automatically'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enterDebugger`：一个布尔标志，指示您是否希望自动步入调试器'
- en: 'It is quite common to invoke a trace with: `trace(true)`, which will pause
    inside the debugger upon invocation. For the book search example (from [Chapter
    3](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070), *A React App with MobX*),
    we can place a trace statement right inside the `render()` of the `SearchTextField`
    component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会使用`trace(true)`来调用跟踪，这将在调用时暂停在调试器内。对于书搜索示例（来自[第3章](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070)，*使用MobX的React应用*），我们可以直接在`SearchTextField`组件的`render()`内放置一个跟踪语句：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the debugger is paused, you get a complete root-cause analysis of why
    this computed property, reaction, or render got executed. Inside the Chrome devtools,
    you can see these details like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器暂停时，您将获得为什么执行了此计算属性、反应或渲染的完整根本原因分析。在Chrome开发工具中，您可以看到这些细节如下：
- en: '![](../images/00035.jpeg)Details on the Chrome devtools'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00035.jpeg)Chrome开发工具上的详细信息'
- en: Visual debugging with mobx-react-devtools
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mobx-react-devtools进行可视化调试
- en: '`spy()` and `trace()` are great for getting a code-level insight into the MobX
    reactive system. However, when starting out your analysis of improving performance,
    visual debugging is quite handy. MobX has a sister NPM package called `mobx-react-devtools`,
    which gives you a simple `<DevTools />` component that can help you visualize
    how your component tree reacts to the observables. By including this component
    at the top of your app, you will see a toolbar at runtime:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`spy()`和`trace()`非常适合深入了解MobX响应式系统的代码级别。然而，在开始分析性能改进时，可视化调试非常方便。MobX有一个名为`mobx-react-devtools`的姊妹NPM包，它提供了一个简单的`<DevTools
    />`组件，可以帮助您可视化组件树如何对可观察对象做出反应。通过在应用程序顶部包含此组件，您将在运行时看到一个工具栏：'
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The screenshot below shows the MobX DevTools toolbar showing up in the *top-right*
    corner of the screen.![](../images/00036.jpeg)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了MobX DevTools工具栏出现在屏幕的*右上角*！[](../images/00036.jpeg)
- en: By enabling the buttons, you can see which components render upon changes in
    observables, see the dependency tree of observables connected to a DOM element,
    and print console logs whenever an *action*/*reaction* executes. Components will
    flash with a colored rectangle whenever they render. The color of the rectangle
    is an indication of how long it takes to render, *green* being the fastest and
    *red* being the slowest. You can observe the flashing rectangles to ensure that
    only the parts you intended to change are re-rendering. This is a great way to
    identify components that are rendering unnecessarily and possibly make more granular
    observers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用按钮，您可以看到哪些组件在可观察值发生变化时进行渲染，查看连接到DOM元素的可观察值的依赖树，并在*操作*/*反应*执行时打印控制台日志。组件在渲染时会闪烁一个彩色矩形。矩形的颜色表示渲染所需的时间，*绿色*表示最快，*红色*表示最慢。您可以观察闪烁的矩形，以确保只有您打算更改的部分重新渲染。这是识别不必要渲染的组件并可能创建更精细的观察者的好方法。
- en: The `mobx-react-devtools` package relies on `spy()` to print the console logs
    for executing actions and reactions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`mobx-react-devtools`包依赖于`spy()`来打印执行操作和反应的控制台日志。'
- en: A few other APIs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他一些API
- en: There are some miscellaneous APIs that are provided by MobX that are not that
    frequently used. It is still worth mentioning them here for the sake of completeness.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MobX提供了一些不太常用的杂项API。为了完整起见，这里还是值得一提的。
- en: Querying the reactive system
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询响应式系统
- en: 'When dealing with the various abstractions in MobX (observables, actions, reactions),
    it is sometimes useful to know if a certain object, function, or value is of a
    certain kind. MobX has a set of *isXXX* APIs that help you to determine the type
    of the value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理MobX中的各种抽象（可观察值、操作、反应）时，有时需要知道某个对象、函数或值是否属于某种类型。MobX有一组*isXXX* API，可以帮助您确定值的类型：
- en: '`isObservableObject(thing)`, `isObservableArray(thing)`, `isObservableMap(thing)`:
    Tells you whether the passed in value is an observable object, array, or map'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isObservableObject(thing)`, `isObservableArray(thing)`, `isObservableMap(thing)`:
    告诉你传入的值是否是可观察的对象、数组或映射'
- en: '`isObservable(thing)` and `isObservableProp(thing, property?)`: Similar to
    the preceding point but more generalized check for an observable value'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isObservable(thing)`和`isObservableProp(thing, property?)`：类似于前面的点，但更一般化地检查可观察值'
- en: '`isBoxedObservable(thing)`: Whether the value is a boxed observable'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isBoxedObservable(thing)`: 值是否是一个包装的可观察值'
- en: '`isAction(func)`: Returns `true` if the function is wrapped by an action'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAction(func)`: 如果函数被操作包装，则返回`true`'
- en: '`isComputed(thing)` and `isComputedProp(thing, property?)`: Checks whether
    the value is a computed property'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isComputed(thing)`和`isComputedProp(thing, property?)`：检查值是否是计算属性'
- en: Probing deeper into the reactive system
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解响应式系统
- en: 'MobX builds up a reactive fabric internally that keeps all of the observables
    and reactions connected. We will be exploring these internals in [Chapter 9](part0165.html#4TBCQ0-58c2559ca4304cecab9bc46f496bc070),
    *Mobx Internals*, where we will see the mention of certain terms like *atoms*.
    For now, let''s take a quick look at the APIs that give you the internal representation
    of the observables and reactions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: MobX在内部构建了一个反应性的结构，保持所有的可观察对象和反应都连接在一起。我们将在[第9章](part0165.html#4TBCQ0-58c2559ca4304cecab9bc46f496bc070)
    *Mobx Internals*中探索这些内部结构，那里我们将看到某些术语的提及，比如*atoms*。现在，让我们快速看一下这些API，它们为您提供了可观察对象和反应的内部表示。
- en: '`getAtom(thing, property?)`: At the heart of every observable is an `Atom`,
    which keeps track of the observers that depend on the observable value. Its purpose
    is to report whenever anyone reads or writes to the observable value. With this
    API, you get the instance of the `Atom` that backs the observable.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAtom(thing, property?)`：在每个可观察对象的核心是一个`Atom`，它跟踪依赖于可观察值的观察者。它的目的是在任何人读取或写入可观察值时报告。通过此API，您可以获取支持可观察对象的`Atom`的实例。'
- en: '`getDependencyTree(thing, property?)`: This gives you the tree of dependencies
    that the given thing depends on. It can be used to get the dependencies for a
    computed property or a reaction.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDependencyTree(thing, property?)`：这为您提供了给定对象依赖的依赖树。它可用于获取计算属性或反应的依赖关系。'
- en: '`getObserverTree(thing, property?)`: This is a counterpart of `getDependencyTree()`,
    which gives you the observers that depend on the given thing.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getObserverTree(thing, property?)`：这是`getDependencyTree()`的对应物，它为您提供了依赖于给定对象的观察者。'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Although there is a lean outer-level API for MobX, there is also a set of APIs
    for more fine-grained observation and mutation. We saw how the Object API can
    be used to make very surgical changes in your observable tree. With `observe()`
    and `intercept()`, you can track the changes happening in an observable and also
    intercept to modify the change.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MobX有一个精简的外层API，但也有一组API用于更精细的观察和变化。我们看到了如何使用Object API来对可观察树进行非常精确的更改。通过`observe()`和`intercept()`，您可以跟踪可观察对象中发生的更改，并拦截以修改更改。
- en: '`spy()` and `trace()` are your friends during debugging, and coupled with ***mobx-react-devtools***,
    you have a visual debugger for identifying and improving render performance. These
    tools and utilities give you a rich Developer eXperience (DX) when working with
    MobX.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`spy()`和`trace()`在调试期间是您的朋友，并与***mobx-react-devtools***配合使用，您可以获得一个用于识别和改进渲染性能的可视化调试器。这些工具和实用程序为您提供了丰富的开发人员体验（DX），在使用MobX时非常有用。'
- en: In [Chapter 8](part0143.html#48C0E0-58c2559ca4304cecab9bc46f496bc070), *Exploring
    mobx-utils and mobx-state-tree*, we will raise the bar on using MobX with the
    special packages `mobx-utils` and `mobx-state-tree`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](part0143.html#48C0E0-58c2559ca4304cecab9bc46f496bc070) *探索mobx-utils和mobx-state-tree*中，我们将提高使用MobX与特殊包`mobx-utils`和`mobx-state-tree`的水平。
