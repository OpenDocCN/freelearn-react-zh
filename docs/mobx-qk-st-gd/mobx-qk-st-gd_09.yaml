- en: Mobx Internals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mobx内部
- en: The MobX we have seen so far was from a consumer's standpoint, which focused
    on how it should be used, the best practices, and the APIs for tackling real-world
    use cases. This chapter takes it a level below and exposes the machinery behind
    the MobX reactive system. We will look at the underpinnings and the core abstractions
    that makes the triad of *Observables-Actions-Reactions* come to life.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的MobX是从消费者的角度出发的，重点是如何使用它，最佳实践以及处理真实用例的API。本章将向下一层，并揭示MobX响应式系统背后的机制。我们将看到支撑和构成*Observables-Actions-Reactions*三元组的核心抽象。
- en: 'The topics that will be covered in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题包括以下内容：
- en: The layered architecture of MobX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX的分层架构
- en: Atoms and ObservableValues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atoms和ObservableValues
- en: Derivations and reactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Derivations和reactions
- en: What is *Transparent Functional Reactive Programming*?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是*透明函数式响应式编程*？
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装Node.js。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter09](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter09)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter09](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter09)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2LvAouE](http://bit.ly/2LvAouE)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2LvAouE](http://bit.ly/2LvAouE)'
- en: A layered architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层架构
- en: 'Like any good system, MobX is built up of layers where each layer provides
    the services and behaviors for the higher layers. If you apply this lens on MobX,
    you can see these layers, bottom-up:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何良好的系统一样，MobX由各个层构建而成，每个层提供了更高层的服务和行为。如果你把这个视角应用到MobX上，你可以从下往上看到这些层：
- en: '![](../images/00037.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: '**Atoms**: Atoms are the foundation of MobX observables. As the name suggests,
    they are the atomic pieces of the observable dependency tree. It keeps track of
    its observers but does not actually store any value.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atoms**：Atoms是MobX observables的基础。顾名思义，它们是可观察依赖树的原子部分。它跟踪它的观察者，但实际上不存储任何值。'
- en: '**ObservableValue, ComputedValue, and Derivations**: `ObservableValue` extends `Atom`
    and provides the actual storage. It is also the core implementation of boxed Observables. In
    parallel, we have derivations and reactions, which are the *observers* of the
    atoms. They respond to changes in atoms and schedule reactions. `ComputedValue` builds
    upon the derivations and also acts as an observable.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ObservableValue，ComputedValue和Derivations**：`ObservableValue`扩展了`Atom`并提供了实际的存储。它也是包装Observables的核心实现。与此同时，我们有derivations和reactions，它们是原子的*观察者*。它们对原子的变化做出响应并安排反应。`ComputedValue`建立在derivations之上，也充当一个observable。'
- en: '**Observable{Object, Array, Map} and APIs**: These data structures build on
    top of `ObservableValue` and use it to represent their properties and values.
    This also acts as the API layer of MobX, the primary means of interfacing with
    the library from the consumer''s standpoint.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Observable{Object, Array, Map}和APIs**：这些数据结构建立在`ObservableValue`之上，并使用它来表示它们的属性和值。这也是MobX的API层，是与库从消费者角度交互的主要手段。'
- en: The separation of layers is also visible in the source code where there are
    separate folders for different abstraction layers of MobX. It is not a one-to-one
    match with what we have described here, but conceptually these layers have lot
    of parallels in code as well. All of the code in MobX has been written using TypeScript
    with first class support.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 层的分离也在源代码中可见，不同的抽象层有不同的文件夹。这与我们在这里描述的情况并不是一一对应的，但在概念上，这些层在代码中也有很多相似之处。MobX中的所有代码都是使用TypeScript编写的，并得到了一流的支持。
- en: The Atom
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子
- en: 'The reactive system of MobX is backed by a graph of dependencies that exist
    between the observables. One observable''s value could depend on a set of observables,
    which in turn could depend on other observables. For example, a shopping cart
    could have a *computed property* called `description` that depends on the array
    of `items` it holds and any `coupons` that were applied. Internally, `coupons` could
    depend on the `validCoupons` *computed property* of the `CouponManager` class.
    In code, this could look like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MobX的响应式系统由存在于可观察对象之间的依赖关系图支持。一个可观察对象的值可能依赖于一组可观察对象，而这些可观察对象又可能依赖于其他可观察对象。例如，一个购物车可以有一个名为`description`的*计算属性*，它依赖于它所持有的`items`数组和应用的任何`coupons`。在内部，`coupons`可能依赖于`CouponManager`类的`validCoupons`
    *计算属性*。在代码中，这可能看起来像这样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Visualizing this set of dependencies could give us a simple diagram like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化这组依赖关系可能会给我们一个简单的图表，如下所示：
- en: '![](../images/00038.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: At runtime, MobX will create a backing dependency tree. Each node in this tree
    will be represented by an instance of `Atom`, the core building block of MobX.
    Thus, we can expect five *atoms* for the nodes in the tree in the preceding diagram.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，MobX将创建一个支持依赖树。这棵树中的每个节点都将由`Atom`的一个实例表示，这是MobX的核心构建块。因此，我们可以期望在前面图表中的树中的节点有五个*原子*。
- en: 'An atom serves two purposes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 原子有两个目的：
- en: Notify when it is *read*. This is done by calling `reportObserved()`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它被*读取*时通知。这是通过调用`reportObserved()`来完成的。
- en: Notify when it is *changed*. This is done by calling `reportChanged()`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它被*改变*时通知。这是通过调用`reportChanged()`来完成的。
- en: As a node of the MobX reactivity fabric, an atom plays the important role of
    notifying the reads and writes happening on each node.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为MobX响应性结构的一个节点，原子扮演着通知每个节点上发生的读取和写入的重要角色。
- en: Internally, an atom keeps track of its observers and informs them of the changes.
    This will happen when `reportChanged()` is called. A glaring omission here is
    that the actual value of the atom is not stored in the `Atom` itself. For that,
    we have a subclass called `ObservableValue` that builds on top of the `Atom`.
    We will look at that in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，原子会跟踪其观察者并通知它们发生的变化。当调用`reportChanged()`时会发生这种情况。这里一个明显的遗漏是原子的实际值并没有存储在`Atom`本身。为此，我们有一个名为`ObservableValue`的子类，它是建立在`Atom`之上的。我们将在下一节中看到它。
- en: 'So, an atom''s core contract consists of the two methods we mentioned earlier.
    It also contains a few housekeeping properties like an array of `observers`, whether
    it is being observed, and so on. We can safely ignore them for our discussion:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原子的核心约定包括我们之前提到的两种方法。它还包含一些像`observers`数组、是否正在被观察等一些管理属性。我们可以在讨论中安全地忽略它们：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Reading atoms at runtime
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时读取原子
- en: 'MobX also gives you the ability to see the backing atoms at runtime. Going
    back to our previous example of the computed `description` property, let''s explore
    its dependency tree:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MobX还让你能够在运行时看到后台的原子。回到我们之前的计算`description`属性的例子，让我们探索它的依赖树：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are few details that stand out in the preceding snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中有一些细节值得注意：
- en: MobX gives you a special symbol, `$mobx`, that contains a reference to the internal
    housekeeping structure of the observable. The `cart` instance maintains a map
    of all of its observable properties using `cart[$mobx].values`. The backing atom
    for the `description` property is obtained by reading from this map: `cart[$mobx].values.get('description')`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX为您提供了一个特殊的符号`$mobx`，其中包含对可观察对象的内部维护结构的引用。`cart`实例使用`cart[$mobx].values`维护其所有可观察属性的映射。通过从此映射中读取，可以获得`description`属性的后备原子：`cart[$mobx].values.get('description')`。
- en: We can get hold of the dependency tree for this property using the `getDependencyTree()`
    function exposed by MobX. It takes in an `Atom` as its input and gives back an
    object describing the dependency tree.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用MobX公开的`getDependencyTree()`函数获取此属性的依赖树。它以`Atom`作为输入，并返回描述依赖树的对象。
- en: 'Here is the output of `getDependencyTree()` for the `description` property.
    A few extra details have been removed for clarity. The reason why you see `ShoppingCart@16.items`
    mentioned twice is because it points to the `items` (the reference) and `items.length`
    properties:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`description`属性的`getDependencyTree()`的输出。为了清晰起见，已经删除了一些额外的细节。您看到`ShoppingCart@16.items`被提到两次的原因是因为它指向`items`（引用）和`items.length`属性：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is also a convenient API, `getAtom(thing: any, property: string)`, to
    read atoms from observables and observers. For example, in our previous example,
    instead of using the special symbol `$mobx` and reading into its internal structure,
    we can get the *description* atom with `getAtom(cart, ''description'')`. `getAtom()`
    is exported from the `mobx` package.As an exercise, find out the dependency tree
    for `autorun()` in the previous code snippet. You can get hold of the instance
    of the reaction with `disposer[$mobx]` or `getAtom(disposer)`. Similarly, there
    is also the `getObserverTree()` utility that gives you the observers depending
    on the given observable. See if you can find the connection to `autorun()` from
    the atom backing the `description` property.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一个方便的API，`getAtom(thing: any, property: string)`，用于从可观察对象和观察者中读取原子。例如，在我们之前的示例中，我们可以使用`getAtom(cart,
    ''description'')`来获取*description*原子，而不是使用特殊符号`$mobx`并读取其内部结构。`getAtom()`是从`mobx`包中导出的。作为练习，找出前一个代码片段中`autorun()`的依赖树。您可以使用`disposer[$mobx]`或`getAtom(disposer)`来获取反应实例。类似地，还有`getObserverTree()`实用程序，它可以给出依赖于给定可观察对象的观察者。看看您是否可以从支持`description`属性的原子找到与`autorun()`的连接。'
- en: Creating an Atom
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个原子
- en: As a MobX user, you would rarely use an `Atom` directly. Instead, you would
    rely on other convenience APIs exposed by MobX or data structures like `ObservableObject`,
    `ObservableArray`, or `ObservableMap`. However, the real world always creates
    situations where you may have to dive a few levels deeper.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为MobX用户，您很少直接使用`Atom`。相反，您会依赖MobX公开的其他便利API或数据结构，如`ObservableObject`、`ObservableArray`或`ObservableMap`。然而，现实世界总是会出现一些情况，您可能需要深入了解一些更深层次的内容。
- en: 'MobX does give you a convenient factory function for creating atoms, aptly
    named `createAtom()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: MobX确实为您提供了一个方便的工厂函数来创建原子，恰当地命名为`createAtom()`：
- en: '**`createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler)`**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**`createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler)`**'
- en: '`name` (`string`): The name of the atom, which is utilized by the debugging
    and tracing facilities in MobX'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（`string`）：原子的名称，由MobX中的调试和跟踪工具使用'
- en: '`onBecomeObservedHandler` (`() => { }`): A callback function to get notified
    when an atom gets observed for the first time'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBecomeObservedHandler`（`（）=> {}`）：当原子首次被观察时通知的回调函数'
- en: '`onBecomeUnobservedHandler` (`() => { }`): A callback function to get notified
    when an atom is no longer being observed'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBecomeUnobservedHandler`（`（）=> {}`）：当原子不再被观察时通知的回调函数'
- en: '`onBecomeObserved` and `onBecomeUnobserved` are the two points in time when
    an atom becomes active and inactive in the reactivity system. These are normally
    meant for resource management, to set up and tear down, respectively.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBecomeObserved`和`onBecomeUnobserved`是原子在响应系统中变为活动和非活动的两个时间点。这些通常用于资源管理，分别用于设置和拆除。'
- en: The atomic clock example
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子钟示例
- en: 'Let''s look at an example of using `Atom` that also illustrates how an atom
    participates in the reactive system. We will create a *simple clock* that starts
    ticking when an atom gets observed and stops when it is no longer observed. In
    essence, our resource here is the timer (clock) that is being managed by the use
    of an `Atom`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`Atom`的例子，也说明了原子如何参与响应系统。我们将创建一个*简单的时钟*，当原子被观察时开始滴答，并在不再被观察时停止。实质上，我们这里的资源是由`Atom`管理的计时器（时钟）：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are many interesting details in the preceding snippet. Let''s list them
    out here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中有许多有趣的细节。让我们在这里列出它们：
- en: In the call to `createAtom()`, we are supplying the handler when the atom becomes
    observed and also when it is no longer being observed. It might seem a little
    mysterious when the ato*m actually becomes observed*. The secret here is the use
    of `autorun()`, which sets up a side effect to read the current value of the atomic
    clock. *S*ince an `autorun()` runs immediately, `clock.get()` is called, which
    in turn calls `this.atom.reportObserved()`. This is how the atom becomes active
    in the reactive system.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`createAtom()`时，我们提供了当原子被观察和不再被观察时的处理程序。当原子实际上变得被观察时，这可能看起来有点神秘。这里的秘密在于使用`autorun()`，它设置了一个副作用来读取原子钟的当前值。由于`autorun()`立即运行，调用了`clock.get()`，进而调用了`this.atom.reportObserved()`。这就是原子在响应系统中变为活动的方式。
- en: Once the atom becomes observed, we start the clock timer, which ticks every
    second. This is happening in the `onBecomeObserved` callback, where we call `this.startTicking()`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦原子被观察，我们就开始时钟计时器，每秒滴答一次。这发生在`onBecomeObserved`回调中，我们在其中调用`this.startTicking()`。
- en: Every second, we call `this.atom.reportChanged()`, which propagates the changed
    value to all observers. In our case, we only have one, `autorun()`, which re-executes
    and prints the console log.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒，我们调用`this.atom.reportChanged()`，将改变的值传播给所有观察者。在我们的例子中，我们只有一个`autorun()`，它重新执行并打印控制台日志。
- en: We don't have to store the current time since we return a new value in every
    call to `get()`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必存储当前时间，因为我们在每次调用`get()`时返回一个新值。
- en: The other mysterious detail is when the atom becomes *unobserved*. This happens
    when we dispose of `autorun()` after three seconds, causing the `onBecomeUnobserved`
    callback to be invoked on the atom. Inside the callback, we stop the timer and
    clean up the resource.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个神秘的细节是当原子变得*未被观察*时。这发生在我们在三秒后处理`autorun()`后，导致在原子上调用`onBecomeUnobserved`回调。在回调内部，我们停止计时器并清理资源。
- en: Since `Atoms` are just the nodes of the dependency tree, we need a construct
    that can store the value of the observable. That is where the `ObservableValue` class
    comes in. Think of it as an `Atom` with value. MobX internally distinguishes between
    two kinds of observable values, `ObservableValue` and `ComputedValue`. Let's see
    them in turn.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Atoms`只是依赖树的节点，我们需要一个可以存储可观察值的构造。这就是`ObservableValue`类的用处。将其视为带有值的`Atom`。MobX在内部区分两种可观察值，`ObservableValue`和`ComputedValue`。让我们依次看看它们。
- en: ObservableValue
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ObservableValue
- en: '`ObservableValue` is a subclass of `Atom` that adds the ability to store the
    value of the observable. It also adds a few more capabilities such as providing
    hooks for intercepting a value change and observing the value. This is also part
    of the definition for `ObservableValue`. Here is a simplified definition of `ObservableValue`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableValue`是`Atom`的子类，它增加了存储可观察值的能力。它还增加了一些功能，比如提供拦截值更改和观察值的钩子。这也是`ObservableValue`的定义的一部分。以下是`ObservableValue`的简化定义：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the calls to `reportObserved()` in the `get()` method and `reportChanged()`
    in the `set()` method. These are the places where the atom's value is read and
    written to. By invoking these methods, an `ObservableValue` participates in the
    reactivity system. Also note that `intercept()` and `observe()` are not really
    part of the reactivity system. They are more like *event emitters* that hook into
    the changes happening to the observable value. These events are not affected by
    transactions, which means that they are not queued up till the end of the batch
    and instead fire immediately.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`get()`方法中对`reportObserved()`的调用以及`set()`方法中对`reportChanged()`的调用。这些是原子值被读取和写入的地方。通过调用这些方法，`ObservableValue`参与了响应系统。还要注意，`intercept()`和`observe()`实际上并不是响应系统的一部分。它们更像是钩入到可观察值发生的更改的*事件发射器*。这些事件不受事务的影响，这意味着它们不会排队等到批处理结束，而是立即触发。
- en: An `ObservableValue` is also the foundation for all of the higher-level constructs
    in MobX. This includes Boxed Observables, Observable Objects, Observable Arrays,
    and Observable Maps. The values stored in these data structures are instances
    of an `ObservableValue`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableValue`也是MobX中所有高级构造的基础。这包括Boxed Observables、Observable Objects、Observable
    Arrays和Observable Maps。这些数据结构中存储的值都是`ObservableValue`的实例。'
- en: 'The thinnest wrapper around an `ObservableValue` is the boxed observable, which
    you create using `observable.box()`. This API literally gives you back an instance
    of the `ObservableValue`. You can use this to call any of the methods on `ObservableValue`,
    as you can see in the following snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包装在`ObservableValue`周围的最薄的包装器是箱式可观察值，您可以使用`observable.box()`创建它。这个API实际上会给您一个`ObservableValue`的实例。您可以使用它来调用`ObservableValue`的任何方法，就像在以下代码片段中看到的那样：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ComputedValue
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ComputedValue
- en: 'The other kind of *observable value* that you can have in an observable tree
    is the `ComputedValue`. This is different from an `ObservableValue` in many ways.
    An `ObservableValue` provides storage for the underlying atom and has its *own
    value*. All the data structures provided by MobX, such as Observable Object/Array/Map,
    rely on the `ObservableValue` to store the leaf-level values. `ComputedValue`
    is special in the sense that it does not have an intrinsic value of its own. Its
    *value*, as the name suggests, is computed from other observables, including other
    computed values:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观察树中，您可以拥有的另一种*可观察值*是`ComputedValue`。这与`ObservableValue`在许多方面都不同。`ObservableValue`为基础原子提供存储并具有*自己的值*。MobX提供的所有数据结构，如Observable
    Object/Array/Map，都依赖于`ObservableValue`来存储叶级别的值。`ComputedValue`在某种意义上是特殊的，它没有自己的内在值。其*值*是从其他可观察值（包括其他计算值）计算得出的。
- en: '![](../images/00039.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.jpeg)'
- en: 'This becomes evident in the definition of `ComputedValue`, where it does not
    subclass `Atom`. Instead, it has an interface that is similar to `ObservableValue`,
    except for the ability to intercept. The following is a simplified definition
    that highlights the interesting parts:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`ComputedValue`的定义中变得明显，它不是`Atom`的子类。相反，它具有与`ObservableValue`类似的接口，除了拦截的能力。以下是一个突出显示有趣部分的简化定义：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An important thing to notice in the preceding snippet is that since a `ComputedValue`
    does not rely on an `Atom`, it uses a different approach for `reportObserved()`.
    This is a lower-level implementation that establishes a link between the observable
    and the observer. This is also used by `Atom` internally so that the behavior
    is exactly the same. Additionally, there is no call to `reportChanged()` as the
    setter for a `ComputedValue` is not well-defined.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中需要注意的一件重要的事情是，由于`ComputedValue`不依赖于`Atom`，它对`reportObserved()`使用了不同的方法。这是一个更低级别的实现，它建立了可观察对象和观察者之间的链接。这也被`Atom`在内部使用，因此行为完全相同。此外，没有调用`reportChanged()`，因为`ComputedValue`的setter没有定义得很好。
- en: As you can see, a `ComputedValue` is mostly a read-only observable. Although
    MobX provides a way to *set* a computed value, in most cases, it doesn't really
    make much sense. A setter for a computed value has to apply the reverse computation
    of the getter. This is almost impossible in most cases. Consider the example from
    earlier in this chapter about the `description` of a cart. This is a computed
    value that produces a string from other observables, like `items` and `coupons`.
    What would the *setter* for this computed property look like? It has to parse
    the string and somehow arrive at the values for `items` and `coupons`. That is
    definitely not possible. Thus, in general, it is better to treat `ComputedValue`
    as a readonly observable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`ComputedValue`主要是一个只读的可观察对象。虽然 MobX 提供了一种*设置*计算值的方法，但在大多数情况下，这并没有太多意义。计算值的setter必须对getter进行相反的计算。在大多数情况下，这几乎是不可能的。考虑一下本章前面的关于购物车`description`的例子。这是一个从其他可观察对象（如`items`和`coupons`）产生字符串的计算值。这个计算属性的*setter*会是什么样子？它必须解析字符串，并以某种方式得到`items`和`coupons`的值。这显然是不可能的。因此，一般来说，最好将`ComputedValue`视为只读的可观察对象。
- en: Since a computed value depends on other observables, the actual *value computation*
    is more like a side effect. It is a side effect of a change in any of the depending
    observables. MobX refers to this computation as a derivation. A derivation, as
    we will see a little later, is synonymous with reactions, emphasizing the side
    effect aspect of computation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算值依赖于其他可观察对象，实际的*值计算*更像是一个副作用。它是依赖对象中任何一个变化的副作用。MobX 将这种计算称为派生。稍后我们将看到，派生与反应是同义词，强调了计算的副作用方面。
- en: A `ComputedValue` is the only kind of node in the dependency tree that is an
    observable as well as an observer. Its value is an observable and due to its dependency
    on other observables, it is also an observer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputedValue`是依赖树中唯一一种既是可观察的又是观察者的节点。它的值是可观察的，并且由于它依赖于其他可观察值，它也是观察者。'
- en: '`ObservableValue` = Observable only'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableValue` = 仅可观察'
- en: '`Reaction` = Observer only'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reaction` = 仅观察者'
- en: '`ComputedValue` = Both observable and observer'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputedValue` = 可观察和观察者'
- en: Efficient computation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的计算
- en: 'The derivation function of a `ComputedValue` could be an expensive operation.
    So, it is prudent to cache this value and compute as lazily as possible. That
    is the norm in MobX and it employs a bunch of optimizations to make this a lazy
    evaluation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputedValue`的派生函数可能是一个昂贵的操作。因此，最好缓存这个值，并尽可能懒惰地计算。这是 MobX 的规范，并且它采用了一堆优化来使这个计算变成懒惰评估：'
- en: To start with, a value is never computed unless explicitly requested or there
    is a reaction that depends on this `ComputedValue`. As expected, when there are
    no observers, it will not be computed at all.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，除非明确请求或者有一个依赖于这个`ComputedValue`的反应，否则值永远不会被计算。如预期的那样，当没有观察者时，它根本不会被计算。
- en: Once computed, its value is cached for future reads. It will stay that way until
    a depending observable signals a change (via its `reportChanged()`) and causes
    the derivation to re-evaluate.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦计算出来，它的值将被缓存以供将来读取。它会一直保持这种状态，直到依赖的可观察对象发出变化信号（通过其`reportChanged()`）并导致推导重新评估。
- en: A `ComputedValue` can depend on other computed values creating a dependency
    tree. It does not recompute unless the immediate children have changed. If there
    is a change deep in the dependency tree, it waits until the immediate dependencies
    have changed. This behavior improves efficiency and does not recompute unnecessarily.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComputedValue`可以依赖于其他计算值，从而创建依赖树。除非直接子级发生了变化，否则它不会重新计算。如果依赖树深处发生了变化，它将等待直接依赖项发生变化。这种行为提高了效率，不会进行不必要的重新计算。'
- en: As you can see, there are multiple levels of optimization baked into a `ComputedValue`.
    It is highly recommended to leverage the power of computed properties to represent
    the various nuances of domain logic and its UI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`ComputedValue`中嵌入了多个级别的优化。强烈建议利用计算属性的强大功能来表示领域逻辑及其UI的各种细微差别。
- en: Derivation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导
- en: So far, we have seen the building blocks of MobX, which represent the observable
    state with `Atoms`, `ObservableValue`, and `ComputedValue`. These are good to
    construct the reactive state graph of your application. But the true power of
    reactivity is unleashed with the use of derivations or reactions. Together, the
    observables and reactions form the yin-yang of MobX. Each relies on the other
    to fuel the reactive system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了MobX的构建模块，它用`Atoms`、`ObservableValue`和`ComputedValue`表示可观察状态。这些都是构建应用程序的反应状态图的良好选择。但是，反应性的真正力量是通过使用推导或反应来释放的。观察对象和反应一起形成了MobX的阴阳。它们彼此依赖，以推动反应系统。
- en: A derivation or a reaction is where the tracking happens. It keeps track of
    all the observables used in the context of a derivation or reaction. MobX will
    listen to their `reportObserved()` and add them to the list of tracked observables
    (`ObservableValue` or `ComputedValue`). Any time the observable calls `reportChanged()` (which
    will happen when it's mutated), MobX will schedule a run of all the connected
    observers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 推导或反应是跟踪发生的地方。它跟踪在推导或反应的上下文中使用的所有可观察对象。MobX将监听它们的`reportObserved()`并将它们添加到被跟踪的可观察对象列表（`ObservableValue`或`ComputedValue`）。每当可观察对象调用`reportChanged()`（当它被改变时会发生），MobX将安排运行所有连接的观察者。
- en: We will be using ***derivation*** and ***reaction*** interchangeably. Both are
    intended to convey the execution of a side effect that uses the observables to
    produce a new value (*derivation*) or a side effect (*reaction*). The tracking
    behavior is common between these two types and hence we will use them synonymously.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将交替使用***推导***和***反应***。两者都旨在传达使用可观察对象产生新值（*推导*）或副作用（*反应*）的副作用执行。这两种类型之间的跟踪行为是共同的，因此我们将它们视为同义词使用。
- en: The cycle of derivation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导的周期
- en: MobX uses a `globalState` to keep a reference to the currently executing *derivation*
    or *reaction*. Whenever a reaction is running, all observables that fire their
    `reportObserved()` will be tagged to this reaction. In fact, the relationship
    is bi-directional. An *observable* keeps track of all of its observers (reactions),
    while a *reaction* keeps track of all the observables it is currently observing.
    The currently executing reaction will be added as an *observer* for each of the
    observables. If the observer was already added, it will be ignored.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MobX使用`globalState`来保持对当前执行的*推导*或*反应*的引用。每当反应运行时，所有触发其`reportObserved()`的可观察对象都将被标记为该反应的一部分。事实上，这种关系是双向的。一个*可观察对象*跟踪其所有观察者（反应），而一个*反应*跟踪它当前正在观察的所有可观察对象。当前执行的反应将被添加为每个可观察对象的*观察者*。如果观察者已经被添加，它将被忽略。
- en: 'The observers all give back a disposer function when you set them up. We have
    already seen this with the return values of `autorun()`, `reaction()`, or `when()`,
    which are disposer functions. On calling this disposer, the observer will be removed
    from the connected observables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置观察者时，它们都会返回一个清理函数。我们已经在`autorun()`，`reaction()`或`when()`的返回值中看到了这一点，它们都是清理函数。调用此清理函数将从连接的可观察对象中删除观察者：
- en: '![](../images/00040.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: During the execution of a reaction, only the existing observables are considered
    for tracking. However, it is possible that in a different run of the same reaction,
    some new observables are referenced. This is possible when a piece of code executes
    that was originally skipped due to some branching logic. Since new observables
    can be discovered while tracking a reaction, MobX keeps a check on the observables.
    New ones are added to the list of observables, while ones that are not used anymore
    will be removed. Removal of an observable doesn't happen immediately; they are
    queued up for removal after completion of the current reaction.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行反应时，只有现有的可观察对象才会被考虑进行跟踪。然而，在同一反应的不同运行中，可能会引用一些新的可观察对象。当由于某些分支逻辑而原本被跳过的代码段执行时，这是可能的。由于在跟踪反应时可能会发现新的可观察对象，MobX会对可观察对象进行检查。新的可观察对象将被添加到可观察对象列表中，而不再使用的可观察对象将被移除。可观察对象的移除不会立即发生；它们将在当前反应完成后排队等待移除。
- en: In this interplay between observables and reactions, the **actions** seem to
    be missing sorely. Well, not entirely. They do have a role to play. As mentioned
    several times in this book, actions are the recommended way to mutate observables.
    An action creates a transaction boundary and ensures all change notifications
    are fired only after completion. These actions can also be nested, resulting in
    a nested transaction. It is only when the top most *action* (or transaction) completes
    that the notifications will be fired. This also means that none of the *reactions*
    run while a transaction (nested or not) is in progress. MobX treats this transaction
    boundary as a **batch** and keeps track of the nesting internally. During a batch,
    all reactions will be queued up and executed at the end of the top-most batch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观察对象和反应之间的相互作用中，**操作**似乎是非常缺失的。嗯，并非完全如此。它们确实有一定的作用要发挥。正如本书中多次提到的，操作是改变可观察对象的推荐方式。操作创建一个事务边界，并确保所有更改通知仅在完成后触发。这些操作也可以嵌套，导致嵌套事务。只有当最顶层的*操作*（或事务）完成时，通知才会被触发。这也意味着在事务（嵌套或非嵌套）进行时，*反应*都不会运行。MobX将此事务边界视为**批处理**，并在内部跟踪嵌套。在批处理期间，所有反应将被排队并在最顶层批处理结束时执行。
- en: When the queued up reactions execute, the cycle begins yet again. It will track
    observables, link them with the executing derivation, add any newly discovered
    observables, and queue up any reactions that are found during a batch. If there
    are no more batches, MobX deems itself to be stable and goes back to waiting for
    any observable mutations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当排队的反应执行时，循环再次开始。它将跟踪可观察对象，将它们与执行的派生链接起来，添加任何新发现的可观察对象，并在批处理期间排队任何发现的反应。如果没有更多的批处理，MobX将认为自己是稳定的，并回到等待任何可观察变化的状态。
- en: An interesting thing about reactions is that they could re-trigger themselves.
    Inside a reaction, you can read an observable and also fire an action that mutates
    that same *observable*. This may happen within the same block of code or indirectly
    via some function invoked from the reaction. The only requirement is that it should
    ***not*** lead to an infinite loop. MobX expects the reaction to become stable
    as quickly as possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于反应的一个有趣的事情是它们可以重新触发自己。在一个反应中，你可以读取一个可观察对象，并触发一个改变同一个*可观察对象*的动作。这可能发生在同一段代码中，也可能间接地通过从反应中调用的某个函数。唯一的要求是它不应该导致无限循环。MobX期望反应尽快变得稳定。
- en: If, for some reason, it takes more than **100** iterations and there is no stability,
    MobX will bail out with an exception.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，迭代超过100次并且没有稳定性，MobX将以异常退出。
- en: 'Reaction doesn''t converge to a stable state after 100 iterations. There is
    probably a cycle in the reactive function: `Reaction[Reaction@14]`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 反应在100次迭代后没有收敛到稳定状态。可能是反应函数中存在循环：`Reaction[Reaction@14]`
- en: Without the upper limit of 100 iterations, it would cause a stack overflow at
    runtime, making it much harder to track down its cause. MobX protects you from
    this predicament by guarding with the **100-iterations** limit. Note that it does
    not forbid you from cyclic dependencies but assists in identifying the code that
    is causing the instability (infinite loop).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有100次迭代的上限，它会在运行时导致堆栈溢出，使得更难追踪其原因。MobX通过**100次迭代**的限制来保护你免受这种困境的影响。请注意，它并不禁止你使用循环依赖，而是帮助识别导致不稳定（无限循环）的代码。
- en: A simple snippet that is unstable even after *100 iterations of the reaction*
    is shown as follows. This reaction observes the `counter` observable, and also
    modifies it by invoking the `spinLoop()` action. This causes the reaction to run
    again and again until it gives up after *100 iterations:*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在*100次反应*之后仍然不稳定的简单片段如下所示。这个反应观察`counter`可观察对象，并通过调用`spinLoop()`动作来修改它。这导致反应一遍又一遍地运行，直到在*100次迭代后放弃：*
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can tell, executing a derivation or reaction is crucial for establishing
    the link between *observables* and *observers*. Without a *reaction*, there is
    no life in the reactivity system. It would just be a collection of observables.
    You could still fire actions and mutate them, but it would still be very static
    and non-reactive. Reactions (Derivations) complete the triad of *Observables-Actions-Reactions*
    and pump life into this reactive system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，执行派生或反应对于建立*可观察对象*和*观察者*之间的联系至关重要。没有*反应*，反应性系统中就没有生命。它只会是一组可观察对象。你仍然可以触发动作和改变它们，但它仍然会非常静态和非反应性。反应（派生）完成了*可观察对象-动作-反应*的三元组，并为这个反应性系统注入了生命。
- en: Ultimately, **reactions** are the ones that *pull values* from your state and
    fire up the whole reactive process!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，**反应**是*从你的状态中提取值*并启动整个反应过程的关键！
- en: Exception handling
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Handling errors is considered an essential part of MobX reactions. In fact,
    it provides an option to supply an error handler (`onError`) for `autorun()`,
    `reaction()`, and `when()`, and in the case of `computed()`, it will throw the
    error back to you any time the computed value is read. In each of these cases,
    MobX continues to work as expected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误被认为是MobX反应的一个重要部分。事实上，它为`autorun()`、`reaction()`和`when()`提供了一个提供错误处理程序(`onError`)的选项，在`computed()`的情况下，每当读取计算值时都会将错误抛回给你。在这些情况下，MobX会像预期的那样继续工作。
- en: Internally, MobX puts additional `try-catch` blocks around the execution of
    reactions and derivations. It will catch the errors thrown inside these blocks
    and propagate them back to you via the `onError` handlers or when a computed value
    is read. This behavior ensures that you can continue running your reactions and
    take any recovery measures inside the `onError` handlers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，MobX在执行reactions和derivations时加入了额外的`try-catch`块。它会捕获这些块内部抛出的错误，并通过`onError`处理程序或在读取计算值时将它们传播回给你。这种行为确保你可以继续运行你的reactions，并在`onError`处理程序内采取任何恢复措施。
- en: 'If there is no `onError` handler specified for a reaction, MobX also has a
    global `onReactionError()` handler that will be called for any exception thrown
    in a reaction. You can register a listener for these global reaction errors to
    do things like error monitoring, reporting, and so on:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于一个reaction没有指定`onError`处理程序，MobX也有一个全局的`onReactionError()`处理程序，它将被调用来处理reaction中抛出的任何异常。你可以注册一个监听器来处理这些全局reaction错误，比如错误监控、报告等：
- en: '`onReactionError(handler-function: (error, reaction) => { })`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`onReactionError(handler-function: (error, reaction) => { })`'
- en: '**handler-function**: A function accepting the error and the instance of a
    reaction as its arguments.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**handler-function**：一个接受错误和reaction实例作为参数的函数。'
- en: Before a global `onReactionError` handler is called, MobX first checks for an
    `onError` handler for the reaction that is failing. It's only when that doesn't
    exist that the global handler is invoked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用全局`onReactionError`处理程序之前，MobX首先检查失败的reaction是否有一个`onError`处理程序。只有当不存在时，才会调用全局处理程序。
- en: 'Now, if for some reason you don''t want this behavior where MobX catches the
    exception and reports it on a global `onReactionError` handler, you have a way
    out. By configuring MobX with `configure({ disableErrorBoundaries: true })`, you
    will get a regular exception thrown at the *point of failure*. You will now be
    expected to handle it via a *try-catch* block right inside the reaction.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果出于某种原因，你不希望MobX捕获异常并在全局`onReactionError`处理程序上报告它，你有一个出路。通过配置MobX为`configure({
    disableErrorBoundaries: true })`，你将会在*失败点*得到一个常规异常。现在你需要通过*try-catch*块在reaction内部直接处理它。'
- en: '`configure({ disableErrorBoundaries: true })` shouldn''t be used in normal
    circumstances as leaving exceptions unchecked can corrupt the internal state of
    MobX. However, turning on this configuration can help you in debugging since it
    will make the exception uncaught. Youcan now pause your debugger on the exact
    statement that causes the exception.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '在正常情况下不应该使用`configure({ disableErrorBoundaries: true })`，因为不处理异常可能会破坏MobX的内部状态。然而，打开这个配置可以帮助你调试，因为它会使异常未被捕获。现在你可以在引起异常的确切语句上暂停调试器。'
- en: The API layer
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API层
- en: 'This is the consumer facing, outermost layer of MobX and builds on the foundations
    mentioned thus far. The prominent APIs that stand out in this layer include the
    ones seen throughout this book: `observable()`, `observable.box()`, `computed()`,
    `extendObservable()`, `action()`, `reaction()`, `autorun()`, `when()`, and others.
    Of course, we also have the decorators, such as `observable.ref`, `observable.deep`,
    `observable.shallow`, `action.bound`, `computed.struct`, and so on.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MobX面向消费者的最外层层，建立在前面提到的基础之上。在这一层中，突出的API包括本书中遍布的`observable()`、`observable.box()`、`computed()`、`extendObservable()`、`action()`、`reaction()`、`autorun()`、`when()`等。当然，我们还有装饰器，比如`observable.ref`、`observable.deep`、`observable.shallow`、`action.bound`、`computed.struct`等。
- en: The core data structures such as `ObservableObject`, `ObservableArray`, and
    `ObservableMap` rely on the `ObservableValue` to store all of their values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数据结构，如`ObservableObject`、`ObservableArray`和`ObservableMap`依赖于`ObservableValue`来存储它们的所有值。
- en: 'For an `ObservableObject...`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ObservableObject...`：
- en: A key-value pair has its value backed by an `ObservableValue`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值对的值由`ObservableValue`支持。
- en: Every computed property, as expected, is backed by a `ComputedValue`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个计算属性都由`ComputedValue`支持。
- en: The `keys()` method of an *ObservableObject* is also backed by an `Atom`. This
    is needed as you may be iterating on the `keys()` in one of your reactions. When
    a key gets added or removed, you want your reactions to execute again. This atom
    for `keys()` fires the `reportChanged()` for additions and removals and ensures
    that the connected reactions are re-executed.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservableObject`的`keys()`方法也由`Atom`支持。这是必要的，因为您可能会在其中一个反应中对`keys()`进行迭代。当添加或删除键时，您希望您的反应再次执行。`keys()`的这个原子会对添加和删除触发`reportChanged()`，并确保连接的反应被重新执行。'
- en: 'For an `ObservableArray...`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ObservableArray...`：
- en: Every indexed value is backed by `ObservableValue`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个索引值都由`ObservableValue`支持。
- en: The `length` property is explicitly backed by an `Atom`. Note that *ObservableArray*
    has the same interface as JavaScript arrays. In ***MobX 4***, it was an array-like
    data structure, which has become a real JS Array in ***MobX 5*** (backed by an
    ES6 *Proxy*). The reads and writes on `length` will result in `reportObserved()`
    and `reportChanged()` being called on the atom. In fact, when any of the methods
    like *map*, *reduce*, *filter*, and so on are used, the backing `Atom` is used
    to fire `reportObserved()`. For any mutating methods like *splice*, *push*, *pop*,
    *shift*, and so on, the `reportChanged()` is fired. This ensures the connected
    reactions fire as expected.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`属性明确由`Atom`支持。请注意，*ObservableArray*具有与JavaScript数组相同的接口。在***MobX 4***中，它是一个类似数组的数据结构，在***MobX
    5***中成为了真正的JS数组（由ES6的*Proxy*支持）。对`length`的读取和写入将导致在原子上调用`reportObserved()`和`reportChanged()`。实际上，当使用*map*、*reduce*、*filter*等方法时，将使用支持`Atom`来触发`reportObserved()`。对于任何类似*splice*、*push*、*pop*、*shift*等的变异方法，将触发`reportChanged()`。这确保了连接的反应按预期触发。'
- en: 'For an `ObservableMap...`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ObservableMap...`：
- en: A *key-value* pair has its value backed by an `ObservableValue`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*键-值*对的值由`ObservableValue`支持。'
- en: Just like *ObservableObject*, it too maintains an instance of `Atom` for the
    `keys()` method. Any addition or removal of keys is notified with a `reportChanged()`
    on the atom. Calling the `keys()` method itself will fire the `reportObserved()`
    on the atom.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像*ObservableObject*一样，它也为`keys()`方法维护了一个`Atom`的实例。任何添加或删除键的操作都会通过原子上的`reportChanged()`通知。调用`keys()`方法本身将在原子上触发`reportObserved()`。
- en: The collections in MobX, which are objects, arrays, and maps, are essentially
    collections of observable boxes (`ObservableValue`). They may be organized as
    a list or as a map, or combined to create complex structures.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MobX中的集合，包括对象、数组和映射，本质上是可观察盒子（`ObservableValue`）的集合。它们可以组织为列表或映射，或者组合在一起创建复杂的结构。
- en: All of these data structures also expose the `intercept()` and `observe()` methods
    that allows granular interception and observation of values. By building on the
    foundations of `Atom`, `ObservableValue`, and *derivations*, MobX gives you a
    powerful toolbox of APIs to build sophisticated state management solutions in
    your applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据结构还公开了`intercept()`和`observe()`方法，允许对值进行细粒度拦截和观察。通过构建在`Atom`、`ObservableValue`和*derivations*的基础上，MobX为您提供了一个强大的API工具箱，用于在应用程序中构建复杂的状态管理解决方案。
- en: Transparent functional reactive programming
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透明的函数式响应式编程
- en: MobX is considered a **Transparent functional reactive programming** (**TFRP**)
    system. Yes, too many adjectives in that line! Let's break it down word by word.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MobX被认为是**透明的函数式响应式编程**（**TFRP**）系统。是的，在那一行有太多的形容词！让我们逐字逐句地分解它。
- en: It is Transparent...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是透明的...
- en: Connecting the *observables* to the *observers*, it allows the observers to
    react to changes in observables. This is a basic expectation we have from MobX
    and the way we establish these connections feels very intuitive. There is no explicit
    wiring besides the use of decorators and dereferencing observables inside the
    observer. Because of the low overhead in wiring, MobX becomes very *declarative*,
    where you express your intent without worrying about the machinery. The automatic
    connections established between the *observables* and *observers* enables the
    *reactive system* to function autonomously. This makes MobX a *transparent* system
    as the work of connecting observables with observers is essentially lifted away.
    The usage of an observable inside a reaction is enough to wire the two.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将*可观察对象*连接到*观察者*，使观察者能够对可观察对象的变化做出反应。这是我们对MobX的基本期望，我们建立这些连接的方式非常直观。除了使用装饰器和在观察者内部取消引用可观察对象之外，没有明确的连接。由于连接的开销很低，MobX变得非常*声明式*，您可以表达您的意图，而不必担心机制。在*可观察对象*和*观察者*之间建立的自动连接使*反应系统*能够自主运行。这使MobX成为一个*透明*的系统，因为连接可观察对象和观察者的工作基本上被取消了。在反应中使用可观察对象就足以连接这两者。
- en: It is reactive...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是反应性的...
- en: This reactivity is also very fine-grained. The dependency tree of observables
    can be as simple as you need and also equally as deep. The interesting part is
    that you never worry about the complexity of wiring or the efficiency. MobX has
    a deep knowledge of your dependencies and ensures the efficiencies by reacting
    only when needed. There is no polling or excessive events being fired as the dependencies
    keep changing. Thus, MobX is also a very reactive system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反应性也非常细粒度。可观察对象的依赖树可以尽可能简单，也可以同样深入。有趣的是，您永远不必担心连接的复杂性或效率。MobX深知您的依赖关系，并通过仅在需要时做出反应来确保效率。没有轮询或过多的事件被触发，因为依赖关系不断变化。因此，MobX也是一个非常反应灵敏的系统。
- en: It is functional...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是功能性的...
- en: '**Functional** programming, as we know, is about leveraging the power of functions
    to perform data flow transformations. By using a variety of functional operators
    like map, reduce, filter, compose, and so on, we can apply transformations on
    *input data* and produce output values. The catch in the case of MobX is that
    the *input da*ta is an observable, a time *varying* value. MobX combines the qualities
    of a reactive system and ensures the functional -transformations are automatically
    applied when the input data (observable) changes. It does this in a transparent
    fashion, as discussed earlier, by establishing implicit connections between the
    observables and reactions.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，**功能**编程是利用函数的力量来执行数据流转换。通过使用各种功能操作符，如map、reduce、filter、compose等，我们可以对*输入数据*进行转换并产生输出值。在MobX的情况下，关键在于*输入数据*是可观察的，是一个随时间变化的值。MobX结合了反应系统的特性，并确保在输入数据（可观察对象）发生变化时自动应用功能-转换。正如前面讨论的那样，它以一种透明的方式通过建立可观察对象和反应之间的隐式连接来实现这一点。
- en: This combination of qualities makes MobX a TFRP system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特质的结合使MobX成为一个TFRP系统。
- en: From the author's point of view, the *origins* of the acronymn TFRP has come
    from the following article: [https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md](https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从作者的角度来看，TFRP的首字母缩略词的起源来自以下文章：[https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md](https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md)。
- en: Value Oriented Programming
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 价值导向编程
- en: MobX is also about **Value Oriented Programming** (**VOP**), where you focus
    on the change in values, its dependencies, and its propagation across the reactive
    system. With VOP*,* you focus on *What are the connected values? * rather than
    the  *How are the values connected? *Its counterpart is **Event Oriented Programming**
    (**EOP**), where you focus on a stream of events to notify changes. Events only
    report what has happened with no notion of dependencies. It's at a lower level
    conceptually, compared to Value-Oriented-Programming.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: MobX也涉及**价值导向编程**（VOP），在这里你关注值的变化、它的依赖关系以及在响应系统中的传播。通过VOP，你关注的是*连接的值是什么？*而不是*值是如何连接的？*它的对应物是**事件导向编程**（EOP），在这里你关注的是一系列事件来通知变化。事件只报告已发生的事情，没有依赖关系的概念。与价值导向编程相比，它在概念上处于较低级别。
- en: VOP relies on events to do its job internally. When a value changes, events
    are raised to notify the change. The handlers for these events will then propagate
    the value to all listeners (***observers***) of that ***observable value***. This
    usually results in a reaction/derivation being invoked. Thus, reactions and derivations,
    which are the side effects of the value change, are at the tail-end of the value
    propagation event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: VOP依赖事件在内部执行其工作。当一个值发生变化时，会触发事件来通知变化。这些事件的处理程序将把值传播给所有监听器（***观察者***）的***可观察值***。这通常会导致调用反应/派生。因此，反应和派生，即值变化的副作用，处于值传播事件的尾端。
- en: 'Thinking in VOP raises the level of abstraction, bringing you closer to the
    domain that you are dealing with. Rather than worrying about the mechanism of
    value propagation, you just focus on establishing connections via observables,
    computed properties, and observers (reactions/derivations). This, as we know,
    is the triad of MobX: *Observables-Actions-Reactions*. This style of thinking
    is very ***declarative*** in nature: the *What versus How* of value changes. As
    you get more steeped into this mindset, many of the scenarios in state management
    become much more tenable. You will be amazed at the *simplicity, power, and efficiency*
    that this paradigm offers.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以VOP的方式思考会提高抽象级别，使你更接近正在处理的领域。与其担心值传播的机制，你只需专注于通过可观察值、计算属性和观察者（反应/派生）建立连接。正如我们所知，这就是MobX的三位一体：*可观察值-动作-反应*。这种思维方式在本质上非常***声明式***：*值的变化是什么*而不是*如何*。当你更深入地沉浸在这种思维模式中时，许多状态管理中的场景会变得更加可行。你会对这种范式提供的*简单、强大和高效*感到惊讶。
- en: If you do need to dive deeper into the eventing layer, MobX has the `intercept()`
    and `observe()` APIs. They allow you to hook into the events that are raised when
    observables are *added, updated, or deleted*. There is also the `fromStream()`
    and `toStream()` APIs from the `mobx-utils` npm package, which gives you a stream
    of events that are compatible with RxJS. These events don't participate in the
    MobX transaction (batching), are never queued up, and always fire immediately.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要深入了解事件层，MobX有`intercept()`和`observe()`的API。它们允许你钩入当可观察值*添加、更新或删除*时触发的事件。还有来自`mobx-utils`
    npm包的`fromStream()`和`toStream()`的API，它们提供了与RxJS兼容的事件流。这些事件不参与MobX事务（批处理），永远不会排队，总是立即触发。
- en: It is rare to use the eventing APIs in consumer code; they are mostly used by
    tools and utility functions such as `spy()`, `trace()`, and so on to give insight
    into the event layer of MobX.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者代码中很少使用事件API；它们主要被工具和实用函数（如`spy()`、`trace()`等）使用，以便深入了解MobX的事件层。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this under-the-hood peek at MobX, you can appreciate the power of the TFRP
    system, exposed with a surprisingly simple API. The layers of functionality, starting
    with the `Atoms`, wrapped by `ObservableValue`, with APIs and higher-level data
    structures, offer a comprehensive solution to model your domains.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个深入了解 MobX 的窥视，您可以欣赏到 TFRP 系统的强大之处，它暴露了一个令人惊讶地简单的 API。从 `Atoms` 开始的功能层，由
    `ObservableValue` 包装，具有 API 和更高级的数据结构，为您的领域建模提供了全面的解决方案。
- en: Internally, MobX manages all the connections between the observables and observers
    (reactions/derivations). It is done automatically with minimal interference to
    your usual style of programming. As a developer, you write code that feels natural,
    with MobX lifting away the complexity of managing the reactive connections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，MobX 管理着可观察对象和观察者（反应/推导）之间的所有连接。它会自动完成，几乎不会干扰您通常的编程风格。作为开发者，您编写的代码会感觉很自然，而
    MobX 则消除了管理响应式连接的复杂性。
- en: MobX is an open source project that has been battle-tested for various domains,
    accepted contributions from developers all over the world, and has been constantly
    maturing over the years. With this inside look at MobX, we sure hope to reduce
    the barriers to contributing to this powerful state management library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: MobX 是一个经过各种领域的实战考验的开源项目，接受来自世界各地开发者的贡献，并在多年来不断成熟。通过这次对 MobX 的内部了解，我们希望能够降低对这个强大的状态管理库的贡献障碍。
