["```jsx\nconst item = observable({\n    name: 'Party Balloons',\n    itemId: '1234',\n    quantity: 2,\n    price: 10,\n    coupon: {\n        code: 'BIGPARTY',\n        discountPercent: 50\n  }\n});\n```", "```jsx\n// Set values\nitem.quantity += 3;\nitem.name = 'Small Balloons';\n\n// Get values\nconsole.log(`Buying ${item.quantity} of ${item.name}`);\n```", "```jsx\nError: [mobx] The provided value could not be converted into an observable. If you want just create an observable reference to the object use 'observable.box(value)'\n```", "```jsx\nconst count = observable.box(20);\n\n// Get the count console.log(`Count is ${count.get()}`);\n\n// Change count count.set(22);\n```", "```jsx\nconst items = observable.array(); // Start with empty array\n\nconsole.log(items.length); // Prints: 0\n items.push({\n    name: 'hats', quantity: 40,\n});\n\n// Add one in the front items.unshift({ name: 'Ribbons', quantity: 2 });\n\n// Add at the back items.push({ name: 'balloons', quantity: 1 });\n\nconsole.log(items.length); // Prints: 3\n```", "```jsx\nimport { observable, **toJS** } from 'mobx';\n\nconst items = observable.array();\n\n/* Add/remove items*/  const plainArray = toJS(items);\nconsole.log(plainArray);\n```", "```jsx\nimport { observable } from 'mobx';\n\n// Create an Observable Map const twitterUserMap = observable.map();\n\nconsole.log(twitterUserMap.size); // Prints: 0   // Add keys twitterUserMap.set('pavanpodila', 'Pavan Podila');\ntwitterUserMap.set('mweststrate', 'Michel Weststrate');\n\nconsole.log(twitterUserMap.get('pavanpodila')); // Prints: Pavan Podila console.log(twitterUserMap.has('mweststrate')); // Prints: Michel Weststrate   twitterUserMap.forEach((value, key) => console.log(`${key}: ${value}`));\n\n// Prints: // pavanpodila: Pavan Podila // mweststrate: Michel Weststrate \n```", "```jsx\nobservable.object(value, decorators, { deep: false });\nobservable.map(values, { deep: false });\nobservable.array(values, { deep: false });\n```", "```jsx\nimport { observable } from 'mobx';\n\nconst cart = observable.object({\n    items: [],\n    modified: new Date(),\n});\n```", "```jsx\nconst cart = observable.object({\n    items: [],\n    modified: new Date(),\n\n    get description() {\n        switch (this.items.length) {\n            case 0:\n                return 'There are no items in the cart';\n            case 1:\n                return 'There is one item in the cart';\n            default:\n                return `There are ${this.items.length} items in the \n                 cart`;\n        }\n    },\n});\n```", "```jsx\ncart.items.push({ name: 'Shoes', quantity: 1 });\nconsole.log(cart.description);\n```", "```jsx\nclass Cart {\n    @observable.shallow items = [];\n    @observable modified = new Date();\n\n    @computed get description() {\n        switch (this.items.length) {\n            case 0:\n                return 'There are no items in the cart';\n            case 1:\n                return 'There is one item in the cart';\n            default:\n                return `There are ${this.items.length} items in the \n                cart`;\n        }\n    }\n}\n```", "```jsx\nclass Cart {\n    // Using decorators\n    @observable.shallow items = [];\n    @observable.shallow metadata = {};\n}\n```", "```jsx\nimport { observable, action } from 'mobx';\n\nconst cart = observable({\n    items: [],\n    modified: new Date(),\n});\n\n// Create the actions const addItem = action((name, quantity) => {\n    const item = cart.items.find(x => x.name === name);\n    if (item) {\n        item.quantity += 1;\n    } else {\n        cart.items.push({ name, quantity });\n    }\n\n    cart.modified = new Date();\n});\n\nconst removeItem = action(name => {\n    const item = cart.items.find(x => x.name === name);\n    if (item) {\n        item.quantity -= 1;\n\n        if (item.quantity <= 0) {\n            cart.items.remove(item);\n        }\n\n        cart.modified = new Date();\n    }\n});\n\n// Invoke actions addItem('balloons', 2);\naddItem('paint', 2);\nremoveItem('paint');\n```", "```jsx\nimport { observable, configure } from 'mobx';\n\nconfigure({\n enforceActions: true,\n});\n\n// Modifying outside of an action\ncart.items.push({ name: 'test', quantity: 1 });\ncart.modified = new Date();\n\nError: [mobx] Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: ObservableObject@1.items\n```", "```jsx\nclass Cart {\n    @observable modified = new Date();\n    @observable.shallow items = [];\n\n @action  addItem(name, quantity) {\n        this.items.push({ name, quantity });\n        this.modified = new Date();\n    }\n\n    **@action.bound**\n  removeItem(name) {\n        const item = this.items.find(x => x.name === name);\n        if (item) {\n            item.quantity -= 1;\n\n            if (item.quantity <= 0) {\n                this.items.remove(item);\n            }\n        }\n    }\n}\n```", "```jsx\nclass Cart {\n    /* ... */\n    **@action** removeItem = (name) => {\n        const item = this.items.find(x => x.name === name);\n        if (item) {\n            item.quantity -= 1;\n\n            if (item.quantity <= 0) {\n                this.items.remove(item);\n            }\n        }\n    }\n}\n```", "```jsx\nimport { observable, action, autorun } from 'mobx';\n\nclass Cart {\n    @observable modified = new Date();\n    @observable.shallow items = [];\n\n    constructor() {\n        autorun(() => {\n            console.log(`Items in Cart: ${this.items.length}`);\n        });\n    }\n\n    @action\n  addItem(name, quantity) {\n        this.items.push({ name, quantity });\n        this.modified = new Date();\n    }\n}\n\nconst cart = new Cart();\ncart.addItem('Power Cable', 1);\ncart.addItem('Shoes', 1);\n\n// Prints:\n// Items in Cart: 0 // Items in Cart: 1 // Items in Cart: 2\n```", "```jsx\nimport { observable, action, autorun } from 'mobx';\n\nclass Cart {\n    /* ... */\n\n    cancelAutorun = null;\n\n    constructor() {\n        this.cancelAutorun = autorun(() => {\n            console.log(`Items in Cart: ${this.items.length}`);\n        });\n    }\n\n    /* ... */\n}\n\nconst cart = new Cart();\n// 1\\. Cancel the autorun side-effect\ncart.cancelAutorun();\n\n// 2\\. The following will not cause any logging to happen\ncart.addItem('Power Cable', 1);\ncart.addItem('Shoes', 1);\n\n// Prints:\n// Items in Cart: 0\n```", "```jsx\nreaction(tracker-function, effect-function): disposer-function\n\ntracker-function: () => data, effect-function: (data) => {}\n```", "```jsx\nimport { observable, action, reaction } from 'mobx';\n\nclass Cart {\n    @observable modified = new Date();\n    @observable items = [];\n\n    cancelPriceTracker = null;\n\n    trackPriceChangeForItem(name) {\n        if (this.cancelPriceTracker) {\n            this.cancelPriceTracker();\n        }\n\n // 1\\. Reaction to track price changes\n        this.cancelPriceTracker = reaction(\n            () => {\n                const item = this.items.find(x => x.name === name);\n                return item ? item.price : null;\n            },\n            price => {\n                console.log(`Price changed for ${name}: ${price !== \n                null ? price : 0}`);\n            },\n        );\n    }\n\n    @action\n  addItem(name, price) {\n        this.items.push({ name, price });\n        this.modified = new Date();\n    }\n\n    @action\n  changePrice(name, price) {\n        const item = this.items.find(x => x.name === name);\n        if (item) {\n            item.price = price;\n        }\n    }\n}\n\nconst cart = new Cart();\n\ncart.addItem('Shoes', 20);\n\n// 2\\. Now track price for \"Shoes\"\ncart.trackPriceChangeForItem('Shoes');\n\n// 3\\. Change the price\ncart.changePrice('Shoes', 100);\ncart.changePrice('Shoes', 50);\n\n// Prints:\n// Price changed for Shoes: 100\n// Price changed for Shoes: 50\n```", "```jsx\nimport { observer } from 'mobx-react';\nimport { observable } from 'mobx';\nimport ReactDOM from 'react-dom';\nimport React from 'react';\n\nconst item = observable.box(30);\n\n// 1\\. Create the component with observer\nconst ItemComponent = observer(() => {\n    // 2\\. Read an observable: item\n    return <h1>Current Item Value = {item.get()}</h1>;\n});\n\nReactDOM.render(<ItemComponent />, document.getElementById('root'));\n\n// 3\\. Update item\nsetTimeout(() => item.set(50), 2000);\n```", "```jsx\nwhen(predicate-function, effect-function): disposer-function\n\npredicate-function: () => boolean, effect-function: ()=>{}\n```", "```jsx\nimport { observable, action, when } from 'mobx';\n\nclass Inventory {\n    @observable items = [];\n\n    cancelTracker = null;\n\n    trackAvailability(name) {\n\n // 1\\. Establish the tracker with when\n        this.cancelTracker = when(\n            () => {\n                const item = this.items.find(x => x.name === name);\n                return item ? item.quantity > 0 : false;\n            },\n            () => {\n                console.log(`${name} is now available`);\n            },\n        );\n    }\n\n    @action\n  addItem(name, quantity) {\n        const item = this.items.find(x => x.name === name);\n        if (item) {\n            item.quantity += quantity;\n        } else {\n            this.items.push({ name, quantity });\n        }\n    }\n}\n\nconst inventory = new Inventory();\n\ninventory.addItem('Shoes', 0);\ninventory.trackAvailability('Shoes');\n\n// 2\\. Add two pairs\ninventory.addItem('Shoes', 2);\n\n// 3\\. Add one more pair\ninventory.addItem('Shoes', 1);\n\n// Prints:\n// Shoes is now available\n```", "```jsx\nclass Inventory {\n    /* ... */    async trackAvailability(name) {\n // 1\\. Wait for availability\n        await when(() => {\n            const item = this.items.find(x => x.name === name);\n            return item ? item.quantity > 0 : false;\n        });\n\n // 2\\. Execute side-effect\n        console.log(`${name} is now available`);\n    }\n\n    /* ... */ }\n```"]