["```jsx\n$ npm install mobx-utils\n```", "```jsx\nnewPromise = fromPromise(promiseLike)\n```", "```jsx\nimport { fromPromise, PENDING, FULFILLED, REJECTED } from 'mobx-utils';\nclass Worker {\n    operation = null;\n start() {\n this.operation = fromPromise(this.performOperation());\n    }\n    performOperation() {\n        return new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                clearTimeout(timeoutId);\n                Math.random() > 0.25 ? resolve('200 OK') \n                    : reject(new Error('500 FAIL'));\n            }, 1000);\n        });\n    }\n}\n\n```", "```jsx\nimport { fromPromise, PENDING, FULFILLED, REJECTED } from 'mobx-utils';\nimport { observer } from 'mobx-react';\n\nimport React, { Fragment } from 'react';\nimport { CircularProgress, Typography } from '@material-ui/core/es/index';\n\n@observer export class FromPromiseExample extends React.Component {\n    worker;\n\n    constructor(props) {\n        super(props);\n\n this.worker = new Worker();\n this.worker.start();\n    }\n\n    render() {\n        const { operation } = this.worker;\n return operation.case({\n            [PENDING]: () => (\n                <Fragment>\n                    <CircularProgress size={50}  color={'primary'} />\n                    <Typography variant={'title'}>\n                        Operation in Progress\n                    </Typography>\n                </Fragment>\n            ),\n            [FULFILLED]: value => (\n                <Typography variant={'title'}  color={'primary'}>\n                    Operation completed with result: {value}\n                </Typography>\n            ),\n            [REJECTED]: error => (\n                <Typography variant={'title'}  color={'error'}>\n                    Operation failed with error: {error.message}\n                </Typography>\n            ),\n        });\n    }\n}\n```", "```jsx\nresult = lazyObservable(sink => { }, initialValue)\n```", "```jsx\nimport { lazyObservable } from 'mobx-utils';\n\nclass ExpensiveWorker {\n    operation = null;\n\n    constructor() {\n this.operation = lazyObservable(async sink => {\n sink(null); // push an empty value before the update\n            const result = await this.performOperation();\n sink(result);\n        });\n    }\n\n    performOperation() {\n        return new Promise(resolve => {\n            const timeoutId = setTimeout(() => {\n                clearTimeout(timeoutId);\n                resolve('200 OK');\n            }, 1000);\n        });\n    }\n}\n```", "```jsx\nimport { observer } from 'mobx-react';\nimport React, { Fragment } from 'react';\nimport {\n    Button,\n    CircularProgress,\n    Typography,\n} from '@material-ui/core/es/index'; **@observer** export class LazyObservableExample extends React.Component {\n    worker;\n    constructor(props) {\n        super(props);\n\n this.worker = new ExpensiveWorker();\n    }\n   render() {\n const { operation } = this.worker;\n const result = operation.current();\n        if (!result) {\n            return (\n                <Fragment>\n                    <CircularProgress size={50}  color={'primary'} />\n                    <Typography variant={'title'}>\n                        Operation in Progress\n                    </Typography>\n                </Fragment>\n            );\n        }\n         return (\n            <Fragment>\n                <Typography variant={'title'}  color={'primary'}>\n                    Operation completed with result: {result}\n                </Typography>\n                <Button\n  variant={'raised'}   color={'primary'}  onClick={() => operation.refresh()} >\n                    Redo Operation\n                </Button>\n            </Fragment>\n        );\n    }\n}\n```", "```jsx\nresource = fromResource(subscriber: sink => {}, unsubscriber: () => {},    \n           initialValue)\n```", "```jsx\nimport { **fromResource** } from 'mobx-utils';\n\nclass DataService {\n    data = null;\n    socket = null;\n\n    constructor() {\n this.data = fromResource(\n            async sink => {\n                this.socket = new WebSocketConnection();\n                await this.socket.subscribe('data');\n\n                const result = await this.socket.get();\n\n                sink(result);\n            },\n            () => {\n                this.socket.unsubscribe('data');\n                this.socket = null;\n            },\n        );\n    }\n}\n\nconst service = new DataService(); console.log(service.data.current());\n\n// After some time, when no longer needed service.data.dispose();\n```", "```jsx\nviewModel = createViewModel(model)\n```", "```jsx\nclass FormData {\n    @observable name = '<Unnamed>';\n    @observable email = '';\n    @observable favoriteColor = '';\n}\n\nconst viewModel = createViewModel(new FormData());\n\nautorun(() => {\n    console.log(\n        `ViewModel: ${viewModel.name}, Model: ${\n            viewModel.model.name\n  }, Dirty: ${viewModel.isDirty}`,\n    );\n});\n\nviewModel.name = 'Pavan';\nviewModel.email = 'pavan@pixelingene.com';\nviewModel.favoriteColor = 'orange';\n\nconsole.log('About to reset');\nviewModel.reset();\n\nviewModel.name = 'MobX';\n\nconsole.log('About to submit');\nviewModel.submit();\n```", "```jsx\nViewModel: <Unnamed>, Model: <Unnamed>, Dirty: false ViewModel: Pavan, Model: <Unnamed>, Dirty: true About to reset... ViewModel: <Unnamed>, Model: <Unnamed>, Dirty: false ViewModel: MobX, Model: <Unnamed>, Dirty: true About to submit... ViewModel: MobX, Model: MobX, Dirty: false\n```", "```jsx\nimport { types } from 'mobx-state-tree';\n\nconst Todo = types.model('Todo', {\n    title: types.string,\n    done: false,\n});\n```", "```jsx\nconst todo = Todo.create({\n    title: 'Read a book',\n    done: false,\n});\n```", "```jsx\nimport { autorun } from 'mobx';\n\nautorun(() => {\n    console.log(`${todo.title}: ${todo.done}`);\n});\n\n// Toggle the done flag todo.done = !todo.done; \n```", "```jsx\nError: [mobx-state-tree] Cannot modify 'Todo@<root>', the object is protected and can only be modified by using an action.\n```", "```jsx\nconst Todo = types\n  .model('Todo', {\n        title: types.string,\n        done: false,\n    })\n .actions(self => ({\n toggle() {\n self.done = !self.done;\n },\n }));\n\nconst todo = Todo.create({\n    title: 'Read a book',\n    done: false,\n});\n\nautorun(() => {\n    console.log(`${todo.title}: ${todo.done}`);\n});\n\ntodo.toggle();\n```", "```jsx\nconst Todo = types\n  .model(/* ... */)\n    .actions(/* ... */)\n .views(self => ({\n get asMarkdown() {\n return self.done\n  ? `* [x] ~~${self.title}~~`\n  : `* [ ] ${self.title}`;\n },\n\n contains(text) {\n return self.title.indexOf(text) !== -1;\n },\n })); const todo = Todo.create({\n    title: 'Read a book',\n    done: false,\n});\n\nautorun(() => {\n    console.log(`Title contains \"book\"?: ${todo.contains('book')}`);\n});\n\nconsole.log(todo.asMarkdown);\n// * [ ] Read a book\n\nconsole.log(todo.contains('book')); // true\n```", "```jsx\nimport { types } from 'mobx-state-tree';\n\nconst User = types.model('User', {\n    name: types.string,\n    age: 42,\n    twitter: types.maybe(types.refinement(types.string, v => \n /^\\w+$/.test(v))),\n});\n```", "```jsx\nconst App = types.model('App', {\n todos: types.array(Todo),\n users: types.map(User),\n});\n\nconst app = App.create({\n    todos: [\n        { title: 'Write the chapter', done: false },\n        { title: 'Review the chapter', done: false },\n    ],\n    users: {\n        michel: {\n            name: 'Michel Westrate',\n            twitter: 'mwestrate',\n        },\n        pavan: {\n            name: 'Pavan Podila',\n            twitter: 'pavanpodila',\n        },\n    },\n});\n\napp.todos[0].toggle();\n```", "```jsx\n{\n    todos: [\n        {\n            title: 'Learn MST',\n            done: false,\n            assignee: '37',\n        },\n    ],\n    users: {\n        '37': {\n            userid: '37',\n            name: 'Michel Weststrate',\n            age: 33,\n            twitter: 'mweststrate',\n        },\n    },\n}\n```", "```jsx\nimport { types, getRoot } from 'mobx-state-tree';\n\nconst User = types.model('User', {\n userid: types.string, // uniquely identifies this User  name: types.string,\n    age: 42,\n    twitter: types.maybe(types.refinement(types.string, v => /^\\w+$/.test(v))),\n});\n\nconst Todo = types\n  .model('Todo', {\n assignee: types.string, // represents a User  title: types.string,\n        done: false,\n    })\n    .views(self => ({\n getAssignee() {\n            if (!this.assignee) return undefined;\n            return getRoot(self).users.get(this.assignee);\n        },\n    }))\n    .actions(self => ({\n setAssignee(user) {\n            if (typeof user === 'string') this.assignee = user;\n            else if (User.is(user)) this.assignee = user.userid;\n            else throw new Error('Not a valid user object or user id');\n        },\n    }));\n\nconst App = {\n    /* as is */ };\n\nconst app = App.create(/* ... */);\n\nconsole.log(app.todos[0].getAssignee().name); // Michel Weststrate \n```", "```jsx\nimport { types } from \"mobx-state-tree\"\n\nconst User = types.model(\"User\", {\n userid: types.identifier(), // uniquely identifies this User\n  name: types.string,\n  age: 42,\n  twitter: types.maybe(types.refinement(types.string, (v => /^\\w+$/.test(v))))\n})\n\nconst Todo = types.model(\"Todo\", {\n assignee: types.maybe(types.reference(User)), // a Todo can be assigned to a User\n  title: types.string,\n  done: false\n})\n\nconst App = /* as is */\n\nconst app = App.create(/* */)\nconsole.log(app.todos[0].assignee.name) // Michel Weststrate\n```", "```jsx\nimport { reaction } from 'mobx';\nimport { getSnapshot } from 'mobx-state-tree';\n\nconst app = App.create(/* as before */);\n\nreaction(\n    () => getSnapshot(app),\n    snapshot => {\n        window.localStorage.setItem('app', JSON.stringify(snapshot));\n    },\n    { delay: 1000 },\n);\n```", "```jsx\nimport { onPatch } from 'mobx-state-tree';\n\nconst app = App.create(/* see above */);\n\nonPatch(app, (patches, inversePatches) => {\n console.dir(patches, inversePatches);\n});\n\napp.todos[0].toggle();\n```", "```jsx\n// patches:   [{\n op: \"replace\", path: \"/todos/0/done\", value: true }]   // inverse-patches:   [{\n op: \"replace\", path: \"/todos/0/done\", value: false }]\n```"]