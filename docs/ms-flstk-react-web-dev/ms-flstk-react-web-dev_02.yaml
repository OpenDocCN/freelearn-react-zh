- en: Full-Stack Login and Registration for Our Publishing App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们发布应用的全栈登录和注册
- en: '**JSON Web Token** (**JWT** ) is a security tokens format, which is relatively
    new, but works very well. It''s an open standard (RFC 7519) that improves oAuth2
    and OpenID connection when dealing with the problem of passing claims between
    parties in a web application environment.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Token**（**JWT**）是一种相对较新但非常有效的安全令牌格式。它是一个开放标准（RFC 7519），在处理在Web应用程序环境中在各方之间传递声明的问题时，改进了oAuth2和OpenID连接。'
- en: 'In practice, the flow is as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，流程如下：
- en: The server assigns an encoded JSON object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器分配一个编码的JSON对象
- en: After client has been alerted, it sends that encoded token with every request
    to the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端收到警报后，将编码的令牌发送到服务器的每个请求
- en: Based on that token, the server knows who is sending a request
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于该令牌，服务器知道谁发送了请求
- en: 'It''s worth visiting the [http://jwt.io/](http://jwt.io/) website and playing
    with it before you start working with it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 值得在开始使用之前，先访问[http://jwt.io/](http://jwt.io/)网站并进行操作：
- en: '![](Image00019.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00019.jpg)'
- en: 'After successful login, the JWT''s solution provides an object to our frontend
    application that tells us about a current user''s authorization:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，JWT解决方案会向我们的前端应用程序提供一个关于当前用户授权的对象：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `iss` is an issuer property--in our case it will be our publishing app''s
    backend application. The name of the logged user is obvious--`John Doe` has logged
    in successfully. The `admin` property is just saying that an identified user (logged
    into our backend''s app with the correct login and password) is an admin `(''admin'':
    true flag)` . You will learn how to use it in this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`iss`是一个发布者属性--在我们的情况下，它将是我们发布应用的后端应用程序。已登录用户的名称是明显的--`John Doe`已成功登录。`admin`属性只是表示已识别用户（使用正确的登录名和密码登录到我们后端应用程序的用户）是管理员`(''admin'':
    true flag)`。您将在本章中学习如何使用它。'
- en: Besides what has been said in the preceding example, the JWT's response also
    contains information about subjects/claims, a signed SHA256's generated token,
    and an expiration date. The important rule here is that you must be sure about
    the issuer of your token. You need to trust the content provided along with the
    response. It may sound complicated, but it is very simple in real-life applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的例子中提到的内容，JWT的响应还包含有关主题/声明、签名的SHA256生成的令牌和到期日期的信息。这里的重要规则是您必须确信您令牌的发布者。您需要信任响应中提供的内容。这可能听起来复杂，但在实际应用中非常简单。
- en: The important thing is that you need to keep the token generated by JWT protected---this
    will be elaborated upon later in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您需要保护JWT生成的令牌--这将在本章后面详细说明。
- en: 'The flow is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: Our client's publishing app requests a token from our express's server.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的客户端发布应用从我们的express服务器请求令牌。
- en: The publishing backed app issues a token to the frontend Redux's app.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布后端应用程序向前端Redux应用程序发放令牌。
- en: After that, each time we fetch data from the backend, we check if a user has
    access to the requested resources on the backend--the resource consumes the token.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，每次从后端获取数据时，我们都会检查用户是否有权限访问后端请求的资源--资源消耗令牌。
- en: In our case, the resource is a falcor-router's route, which has a close relationship
    with the backend, but this may work as well in more distributed platforms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，资源是falcor-router的路由，它与后端有密切关系，但在更分布式的平台上也可以工作。
- en: Remember that the JWT tokens are similar to private keys--you must keep them
    secure!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JWT令牌类似于私钥--您必须保护它们！
- en: Structure of JWT token
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT令牌的结构
- en: 'The header has information that is required on the backend for recognizing
    what cryptographic operation to do based on that information (metadata, the algorithms,
    and keys being used):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 头部包含了后端需要的信息，用于识别基于该信息的加密操作（元数据、算法和使用的密钥）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In general, that part is done 100 percent out of the box for us, so we don't
    have to care about headers while implementing it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这部分完全是为我们准备好的，所以在实现时我们不必关心头部。
- en: 'The second part consists of claims provided in the JSON format, such as:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包括以JSON格式提供的声明，例如：
- en: '**Issuer** : This lets us know who has issued the token'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行人**：这让我们知道谁发行了令牌'
- en: '**Audience** : This lets us know that this token has to be consumed by our
    application'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受众**：这让我们知道这个令牌必须被我们的应用程序消耗'
- en: '**Issue date** : This lets us know when the token has been created'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布日期**：这让我们知道令牌何时被创建'
- en: '**Expiration date** : This lets us know when the token is expiring so we have
    to generate a new one'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期日期**：这让我们知道令牌何时将会过期，因此我们需要生成一个新的令牌'
- en: '**Subject** : This lets us know which part of the app can use the token (useful
    in bigger applications)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这让我们知道应用的哪个部分可以使用令牌（在更大的应用程序中很有用）'
- en: 'Besides these claims, we can create custom claims that are specifically defined
    by the app''s creator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些声明，我们还可以创建由应用程序的创建者专门定义的自定义声明：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: New MongoDB users collection
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的MongoDB用户集合
- en: 'We need to create a users'' collection in our database. The users will have
    privileges allowing them to:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在数据库中创建一个用户集合。用户将拥有允许他们执行以下操作的特权：
- en: Add new articles in our publishing application
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们发布应用中添加新文章
- en: Edit existing articles in our publishing application
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑我们发布应用中的现有文章
- en: Delete articles in our publishing application
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除我们发布应用中的文章
- en: The first step is that we need to create a collection. You can do this from
    the GUI in Robomongo (introduced at the beginning of the book), but we will use
    the command line.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是我们需要创建一个集合。您可以在Robomongo的GUI中执行此操作（在本书开头介绍），但我们将使用命令行。
- en: 'First of all we need to create a file called `initPubUsers.js` :'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个名为`initPubUsers.js`的文件：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then add the following content to `initPubUsers.js` :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下内容添加到`initPubUsers.js`中：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Explanation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: The SHA256 string, `c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852`
    , is the equivalent of a password, 123456, with a salt's string equal to `pubApp`
    .
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SHA256字符串`c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852`相当于一个密码123456，其盐的字符串等于`pubApp`。
- en: 'If you want to generate this salted password hash yourself, then go to [http://www.xorbin.com/tools/sha256-hash-calculator](http://www.xorbin.com/tools/sha256-hash-calculator)
    and type `123456pubApp` on their website. You will get the following screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己生成这个加盐密码哈希值，那么请访问[http://www.xorbin.com/tools/sha256-hash-calculator](http://www.xorbin.com/tools/sha256-hash-calculator)并在他们的网站上输入`123456pubApp`。您将会得到以下屏幕：
- en: '![](Image00020.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00020.jpg)'
- en: These steps are required only at the beginning. Later we need to program a registration
    form that is salting the password for our own.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤只在开始时需要。后来我们需要为自己编写一个注册表单，用于对密码进行加盐。
- en: Importing the initPubUsers.js file into MongoDB
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将initPubUsers.js文件导入到MongoDB
- en: 'After we have the correct content in our `initPubUsers.js` file, we can run
    a command line as follows in order to import the new `pubUsers` collection to
    our database:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`initPubUsers.js`文件中有了正确的内容之后，我们可以运行以下命令行来将新的`pubUsers`集合导入到我们的数据库中：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get the same terminal output as what we we got after importing the
    article in [Chapter 1](text00021.html) , *Configuring Full-Stack with Node.js,
    Express.js, MongoDB, Mongoose, Falcor, and Redux* , looking similar to this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得与我们在[第1章](text00021.html)中导入文章后获得的相同的终端输出，*使用Node.js、Express.js、MongoDB、Mongoose、Falcor和Redux配置全栈*
    ，看起来类似于这样：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Working on the login's falcor-route
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在处理登录的falcor-route
- en: Now we need to start working with the falcor-router in order to create a new
    endpoint that will use the JWT library to provide a unique token for the client-side
    app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要开始使用falcor-router来创建一个新的端点，该端点将使用JWT库为客户端应用程序提供唯一令牌。
- en: The first thing that we need to do is to provide `secret` on the backend.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在后端提供`secret`。
- en: 'Let''s create that `secret` endpoint''s config file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`secret`端点的配置文件：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we need to put in the content of this `secret` :'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要放入`secret`的内容：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In future, we will use environment variables on the production server, so the
    notation `process.env.JWT_SECRET || 'devSecretGoesHere'` means that the environment
    variable of `JWT_SECRET` doesn't exist so use default `secret` endpoint's `string,devSecretGoesHere`
    . At this point we don't need any development environment variables.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，我们将在生产服务器上使用环境变量，因此`process.env.JWT_SECRET || 'devSecretGoesHere'`的表示方式是环境变量`JWT_SECRET`不存在，因此使用默认的`secret`端点的`string,devSecretGoesHere`。在这一点上，我们不需要任何开发环境变量。
- en: Creating a falcor-router's login (backend)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个falcor-router的登录（后端）
- en: In order to make our codebase more organized, instead of adding one more route
    to our `server/routes.js` file, we will make a new file called `routesSession.js`
    and in that file we will keep all the endpoints related to the current logged
    user's session.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码库更有组织性，我们将创建一个名为`routesSession.js`的新文件，而不是将一个路由添加到我们的`server/routes.js`文件中，并在该文件中保存与当前登录用户会话相关的所有端点。
- en: 'Make sure you are in the `server` directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在`server`目录中：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First open the `server.js` file in order to add one line of code that will
    allow you to post usernames and passwords to the backend. Add this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开`server.js`文件，以添加一行代码，该代码将允许您将用户名和密码发布到后端。添加这个：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This has to be added under `app.use(bodyParser.json({extended: false}));` so
    you will end up with `server.js` code that begins as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '这必须添加在`app.use(bodyParser.json({extended: false}));`下，因此您将得到以下开头的`server.js`代码：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last line is a new line that has to be added in order to make it work.
    Then create a new file in the same directory with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是必须添加的新行，以使其正常工作。然后在同一目录中创建一个新文件：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And put this initial content into the `routesSession.js` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这个初始内容放入`routesSession.js`文件中：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How the call routes work
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用路由的工作原理
- en: 'We have just created an initial call login route in the `routesSession.js`
    file. Instead of using a GET method, we are going to use a `''call''(**call: async
    (callPath, args) => **)` . That is the equivalent to POST in the old RESTful approach.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '我们刚刚在`routesSession.js`文件中创建了一个初始调用登录路由。我们将使用`''call''(**call: async (callPath,
    args) => **)`而不是使用GET方法。这相当于旧的RESTful方法中的POST。'
- en: 'The difference between the call and get methods in Falcor''s routes is that
    we can provide arguments with `args` . That allows us to get from the client-side
    the username and the password:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor路由中调用和获取方法的区别在于我们可以使用`args`提供参数。这允许我们从客户端获取用户名和密码：
- en: 'The plan is that after we receive credentials with this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是在我们收到凭据后：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we will check them against our database with one user admin. A user will
    need to know that the real plaintext password is `123456` in order to get a correct
    login JWTtoken:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用一个用户管理员来检查它们是否与我们的数据库匹配。用户需要知道真实的明文密码是`123456`才能获得正确的登录JWT令牌：
- en: 'We also have prepared in this step a `userStatementQuery` ---this will be used
    later when querying a database:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们还准备了一个`userStatementQuery`，在以后查询数据库时将使用它：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 读累了记得休息一会哦~
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Separating the DB configs - configMongoose.js
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离DB配置 - configMongoose.js
- en: 'We need to separate DB configs from `routes.js` :'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将DB配置从`routes.js`中分离出来：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And its new content:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它的新内容：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Explanation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: 'We have just introduced the following new `env` variables: `MONGO_HOSTNAME`
    , `MONGO_PORT` , and `MONGO_ENV` . We will use them when preparing a production
    environment.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚引入了以下新的`env`变量：`MONGO_HOSTNAME`，`MONGO_PORT`和`MONGO_ENV`。我们将在准备生产环境时使用它们。
- en: The `mongodb://${conf.hostname}:${conf.port}/${conf.env}` expression is using
    a templating feature available since EcmaScript6.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongodb://${conf.hostname}:${conf.port}/${conf.env}` 表达式使用了自 EcmaScript6 起可用的模板特性。'
- en: The rest of `configMongoose.jsconfig` will be known to you, as we have introduced
    it in [Chapter 1](text00021.html) , *Configuring Full-Stack with Node.js, Express.js,
    MongoDB, Mongoose, Falcor, and Redux* .
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`configMongoose.jsconfig`的其余部分将为您所知，因为我们在[第1章](text00021.html)中介绍过它，*使用Node.js、Express.js、MongoDB、Mongoose、Falcor和Redux配置全栈*。'
- en: Improving the routes.js file
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进routes.js文件
- en: After we have created two new files, `configMongoose.js` and `routesSession.js`
    , we have to improve our `server/routes.js` file in order to make everything work
    together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了两个新文件`configMongoose.js`和`routesSession.js`之后，我们必须改进我们的`server/routes.js`文件，以使一切协同工作。
- en: 'The first step is to delete from `routes.js` the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从`routes.js`中删除以下代码：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Replace it with the following new code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下新代码替换它：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, we need to spread `sessionRoutes` into our current `PublishingAppRoutes`
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要将`sessionRoutes`扩展到我们当前的`PublishingAppRoutes`中，如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At the beginning of `PublishingAppRoutes` you need to spread `...sessionRoutes`
    , `routes` , so the login route will be available to use across the Falcor's routes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PublishingAppRoutes`的开头，您需要扩展`...sessionRoutes`，`routes`，以便登录路由可以在整个Falcor路由中使用。
- en: Explanation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: We got rid of the old code that was helping us to run the first Mongoose query
    that was fetching the articles, and we moved everything to `configMongoose` so
    that we can use it in different files around our project. We have also imported
    the session routes and later spread them with the `...` spread operation into
    the array called `PublishingAppRoutes` .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们摆脱了帮助我们运行第一个Mongoose查询的旧代码，该查询正在获取文章，并将一切移动到`configMongoose`中，以便我们可以在项目中的不同文件中使用它。我们还导入了会话路由，然后使用`...`扩展操作将它们扩展到名为`PublishingAppRoutes`的数组中。
- en: Checking to see if the app works before implementing JWT
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实现JWT之前检查应用程序是否正常工作
- en: 'At this point, when doing `npm start` , the app should be working and showing
    the list of articles:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，当执行`npm start`时，应用程序应该正常工作并显示文章列表：
- en: '![](Image00021.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00021.jpg)'
- en: 'When running with `npm start` you should get the following information, validating
    that everything works correctly:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`npm start`运行时，您应该获得以下信息，以验证一切是否正常工作：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a Mongoose users' model
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Mongoose用户模型
- en: 'In the file `configMongoose.js` we need to create and export a `User` model.
    Add the following code to that file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件`configMongoose.js`中，我们需要创建并导出一个`User`模型。将以下代码添加到该文件中：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Explanation
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: The `userSchema` describes our user's JSON model. The user is our Mongoose's
    model that is pointing to the `pubUsers` collection in our MongoDB. At the end,
    we are exporting the `User` model by adding it to the export default's object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`userSchema`描述了我们用户的JSON模型。用户是我们Mongoose模型，指向我们MongoDB中的`pubUsers`集合。最后，通过将其添加到默认导出对象中，我们导出了`User`模型。'
- en: Implementing JWT in the routesSession.js file
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`routesSession.js`文件中实现JWT
- en: 'The first step is to export our `User` model into `routesSession` scope by
    adding at the top of that file an `import` statement:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过在文件顶部添加一个`import`语句，将我们的`User`模型导出到`routesSession`范围内：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Install `jsonwebtoken` and `crypto` (for SHA256):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`jsonwebtoken`和`crypto`（用于SHA256）：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you have installed `jsonwebtoken` , we need to import it to `routesSession.js`
    :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`jsonwebtoken`之后，我们需要将其导入到`routesSession.js`中：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After you have imported everything in the `routesSession` , continue on working
    with the `route: [''login'']` .'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '在`routesSession`中导入了所有内容之后，继续处理`route: [''login'']`。'
- en: 'You need to improve `userStatementQuery` , so it will have the `saltedPassword`
    instead of plain text:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要改进`userStatementQuery`，使其具有`saltedPassword`而不是明文：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So instead of plain text, we will query a salted SHA256 password.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将查询盐化的SHA256密码，而不是明文。
- en: 'Under this `userStatementQuery` , return Promise, with the following details:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`userStatementQuery`下，返回Promise，并提供以下细节：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Explanation
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: 'The `User.find` is a Promise that comes from Mongoose user''s model (that we
    created in `configMongoose.js` )--this is a standard method. Then as a first argument
    we provide `userStatementQuery` which is that filter''s object with the username
    and password in it: `(*{ username, password } = args[0];)` .'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.find`是来自Mongoose用户模型的Promise（我们在`configMongoose.js`中创建的）--这是一个标准方法。然后，我们提供`userStatementQuery`作为第一个参数，它是带有用户名和密码的过滤对象：`(*{
    username, password } = args[0];)`。'
- en: 'Next, we provide a function that is a callback when the query is done: `(function(err,
    user) {)` . We count the amount of results with `if(result.length) {` .'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供一个在查询完成时的回调函数：`(function(err, user) {)`。我们使用`if(result.length) {`来计算结果的数量。
- en: 'If `result.length=== 0` then we have mocked `return` statement, and we are
    getting the `else` code running with the following return:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`result.length=== 0`，那么我们已经模拟了`return`语句，并且我们正在运行`else`代码，返回如下内容：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you will learn later, we will ask for that token's path on the frontend,
    `['login', 'token']` . In this case, we haven't found the correct username and
    the password provided so we return the `"INVALID"` string, instead of a JWT token.
    The path `['login', 'error']` is describing the error's type in more detail so
    that message can be shown to a user that has provided the invalid login credentials.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在后面了解到的，我们将在前端请求该令牌的路径，`['login', 'token']`。在这种情况下，我们没有找到正确的用户名和提供的密码，因此我们返回`"INVALID"`字符串，而不是JWT令牌。路径`['login',
    'error']`更详细地描述了错误的类型，以便可以向提供了无效登录凭据的用户显示消息。
- en: Successful login on falcor-route
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在falcor-route上成功登录
- en: 'We need to improve the successful login path. We have a case for handling an
    invalid login; we need to make a case that will handle a successful login, so
    replace this code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改进成功登录路径。我们已经处理了无效登录的情况；我们需要处理一个成功登录的情况，所以替换这段代码：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this code that is returning the successful login''s details:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码返回成功登录的详细信息：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Explanation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: As you can see, the only thing that we fetch from DB right now is the role `value
    === result[0].role` . We need to add this to hash, because we don't want our app
    to be vulnerable so a normal user can get an admin role with some hacking. The
    value of the token is calculated based on `userDetailsToHash = username+role`
    ---that's enough for now.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在从数据库中获取的唯一东西是角色`value === result[0].role`。我们需要将这个添加到哈希中，因为我们不希望我们的应用程序容易受到攻击，以至于普通用户可以通过一些黑客手段获得管理员角色。令牌的值是基于`userDetailsToHash
    = username+role`计算的---现在就够了。
- en: 'After we are fine with this, the only thing that needs to be done on the backend
    is returning the paths with values:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对此满意之后，后端需要做的唯一事情就是返回带有值的路径：
- en: The login token with `['login', 'token']`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`['login', 'token']`的登录令牌
- en: The username with `['login', 'username']`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名为`['login', 'username']`
- en: The logged user's role with `['login', 'role']`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已登录用户的角色为`['login', 'role']`
- en: Information that there were no errors at all with `['login', 'error']`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何错误的信息为`['login', 'error']`
- en: The next step is to use this route on the frontend. Run the app and if everything
    is working fine, we can start coding on the frontend side.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在前端使用这个路由。运行应用程序，如果一切正常，我们可以开始在前端编码。
- en: 读累了记得休息一会哦~
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Frontend side and Falcor
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端和Falcor
- en: 'Let''s create a new route for the login in our Redux application. In order
    to do that, we need to introduce the `react-router` :'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Redux应用程序中的登录创建一个新路由。为此，我们需要引入`react-router`：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's important to use the correct NPM's version otherwise things get broke!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的NPM版本很重要，否则会出现问题！
- en: 'After we have installed them, we need to add routes in `src` :'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完它们后，我们需要在`src`中添加路由：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then make the content of this `index.js` file as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`index.js`文件的内容设置如下：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: At this point, we are missing two components for our app called `CoreLayout`
    and `LoginView` (we will implement them in a minute).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的应用程序缺少两个组件，即`CoreLayout`和`LoginView`（我们将在一分钟内实现它们）。
- en: The CoreLayout component
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreLayout组件
- en: 'The `CoreLayout` component is the wrapper for our whole application. Create
    it by executing the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoreLayout`组件是整个应用程序的包装器。通过执行以下操作创建它：'
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, populate it with the following content:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下内容填充它：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you probably know, all the content of a current route will go into the `{this.props.children}`
    target (that is a `basicReact.JS` concept that you must know beforehand). We also
    created two links to our routes as a header.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当前路由的所有内容将进入`{this.props.children}`目标（这是一个你必须事先了解的`basicReact.JS`概念）。我们还创建了两个链接到我们路由的链接作为页眉。
- en: The LoginView component
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LoginView组件
- en: 'For the time being, we will create a mocked `LoginView` component. Let''s create
    the `views` directory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将创建一个模拟的`LoginView`组件。让我们创建`views`目录：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The content of the `LoginView.js` file is shown in the following code with
    the `FORM GOES HERE` placeholder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginView.js`文件的内容如下所示，其中包含`FORM GOES HERE`占位符：'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are done with all the missing pieces for the `routes/index.js` , but there
    is some other outstanding stuff to do before our app with the routing will start
    working.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`routes/index.js`中所有缺失的部分，但在我们的应用程序与路由开始工作之前，还有一些其他未完成的工作。
- en: A root's container for our app
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应用程序的根容器
- en: 'Because our app is getting more complicated, we need to create a container
    that it will live in. In order to do that, let''s do the following in the `src`
    location:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的应用程序变得更加复杂，我们需要创建一个容器来存放它。为此，让我们在`src`位置执行以下操作：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Root.js` is going to be our main root file. The content of this file is
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Root.js`将成为我们的主要根文件。该文件的内容如下：'
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For now it's only a simple container, but later we will implement into it more
    features for debugging, hot reloading, and so on. The `noQueryKeyHistory` is saying
    to the router, that we don't want to have any random strings in our URL so our
    routes will be looking nicer (not a big deal, you can change the false flag to
    true, to see what I am talking about).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它只是一个简单的容器，但以后我们将为其实现更多的调试功能、热重载等。`noQueryKeyHistory`告诉路由器，我们不希望在URL中有任何随机字符串，因此我们的路由看起来会更好看（这不是什么大问题，你可以将false标志更改为true，看看我在说什么）。
- en: Remaining configuration for configureStore and rootReducer
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: configureStore和rootReducer的其余配置
- en: 'Let''s create `rootReducer` first. Why do we need it? Because in bigger applications
    you always end up with many different reducers; for example, in our app we will
    have reducers such as:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建`rootReducer`。为什么我们需要它？因为在更大的应用程序中，您总是会有许多不同的reducer；例如，在我们的应用程序中，我们将有诸如以下的reducer：
- en: '**Article''s reducer** : Which keeps stuff related to articles (`RETURN_ALL_ARTICLES`
    and so on)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章的reducer：保留与文章相关的内容（`返回所有文章`等）
- en: '**Session''s reducer** : Which will be related to our users'' sessions (`LOGIN`
    , `REGISTER` , and so on)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话的reducer：与我们用户的会话相关（`登录`，`注册`等）
- en: '**Editor''s reducer** : Which will be related to the editor''s actions (`EDIT_ARTICLE`
    , `DELETE_ARTICLE` , `ADD_NEW_ARTICLE` , and so on)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器的reducer：与编辑器的操作相关（`编辑文章`，`删除文章`，`添加新文章`等）
- en: '**Routing''s reducer** : This will manage the state of our routes (out-of-the-box,
    because it is managed by the redux-simple-router''s external lib)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由的reducer：这将管理我们路由的状态（开箱即用，因为它由redux-simple-router的外部库管理）
- en: 'Let''s create an `index.js` file in our `reducers` directory:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`reducers`目录中创建一个`index.js`文件：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The content for the `index.js` is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js`的内容如下：'
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The new thing here is that we are introducing a `combineReducers` function from
    Redux. This is exactly what I've written before. We will have more than one reducer---in
    our case, we have also introduced the `routeReducer` from a redux-simple-router's
    library.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新事物是我们引入了Redux的`combineReducers`函数。这正是我之前写的。我们将有多个reducer---在我们的情况下，我们还引入了来自redux-simple-router库的`routeReducer`。
- en: 'The next step is to create the `configureStore` that will be managing our stores
    and also in order to implement a server rendering later in this book:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`configureStore`，它将管理我们的store，并且为了在本书后面实现服务器渲染：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The content for the `configureStore.js` file is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureStore.js`文件的内容如下：'
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we are importing the `rootReducer` that we've created
    recently. We also import the `redux-thunk` lib which is very useful for server-side
    rendering (described later in the book).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在导入我们最近创建的`rootReducer`。我们还导入了非常适用于服务器端渲染的`redux-thunk`库（稍后在本书中描述）。
- en: At the end, we export a store which is composed of many different reducers (currently
    routing and the article's reducer that you can find in `reducer/index.js` ) and
    is able to handle the server-rendering initial state.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导出一个由许多不同的reducer组成的store（当前包括路由和文章的reducer，您可以在`reducer/index.js`中找到），并且能够处理服务器渲染的初始状态。
- en: Last tweaks in layouts/PublishingApp.js before running the app
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，对layouts/PublishingApp.js进行最后的调整
- en: The last thing that changed in our app is that we have out-of-date code in our
    publishing app.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中最后改变的一件事是我们的发布应用程序中有过时的代码。
- en: 'Why is it outdated? Because we have introduced `rootReducer` and `combineReducers`
    . So if you check your code in the rendering of `PublishingApp` here, it won''t
    work:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它已经过时？因为我们引入了`rootReducer`和`combineReducers`。因此，如果您在这里渲染`PublishingApp`的代码，它将无法工作：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You need to change it to this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将其更改为这样：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Do you see the difference? The old `for(let articleKey in this.props)` has
    changed into `for(let articleKey in this.props.article)` and `this.props[articleKey]`
    has changed to `this.props.article[articleKey]` . Why? I will recall again: now
    every new reducer will be available in our app via its name created in `routes/index.js`
    . We have named our reducer article, so we now had to add this into `this.props.article`
    to make this stuff work together.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了区别吗？旧的`for(let articleKey in this.props)`已经改变成了`for(let articleKey in this.props.article)`，而`this.props[articleKey]`已经改变成了`this.props.article[articleKey]`。为什么？我再次提醒：现在每个新的reducer都将通过在`routes/index.js`中创建的名称在我们的应用程序中可用。我们将我们的reducer命名为article，所以我们现在必须将其添加到`this.props.article`中，以使这些内容一起工作。
- en: Last changes in src/app.js before running the app
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，在 src/app.js 中进行的最后更改
- en: 'The last thing is to improve the `src/app.js` so it will use the root''s container.
    We need to change the old code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事是改进 `src/app.js`，使其使用根容器。我们需要更改旧代码：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to change the preceding code to the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将前面的代码更改为以下内容：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We start using the `Root` instead of the `Provider` directly, and we need to
    send the store and history's props to the `Root` component. The `***export const
    store = configureStore(window.__INITIAL_STATE__)***` part is here for the server-side
    rendering which we will add in one of the following chapters. We also use the
    history's library to manage the browser's history with the JavaScript.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始使用 `Root` 而不是直接使用 `Provider`，我们需要将 store 和 history 的 props 发送到 `Root` 组件。`***export
    const store = configureStore(window.__INITIAL_STATE__)***` 部分是为了服务器端渲染，我们将在接下来的章节中添加。我们还使用
    history 库来管理浏览器的历史记录。
- en: Screenshots of our running app
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们运行应用程序的屏幕截图
- en: Currently when you do `npm start` then you will see the following two routes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，当您执行 `npm start` 时，您将看到以下两个路由。
- en: Home page
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首页
- en: '![](Image00022.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00022.jpg)'
- en: Login view
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录视图
- en: '![](Image00023.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00023.jpg)'
- en: Working on the login form that will call the backend in order to authenticate
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作在调用后端进行身份验证的登录表单上
- en: Okay, so we have done a lot of preparation in terms of having an extensible
    project structure (`routes` , `rootReducer` , `configStores` , and so on).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以在准备工作方面我们做了很多工作，拥有了一个可扩展的项目结构（`routes`，`rootReducer`，`configStores` 等等）。
- en: 'In order to make our app nicer from a user perspective, we will start using
    Material Design CSS. For making our work easier with forms, we will start using
    a `formsy-react` library. Let''s install it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序从用户角度更加友好，我们将开始使用 Material Design CSS。为了使我们在表单方面的工作更加轻松，我们将开始使用 `formsy-react`
    库。让我们安装它：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the time of writing this book, the version .20.14.4 of Material UI is the
    best choice; I used this version because the ecosystem is changing so quickly
    that it's better to mark the used version in here so you won't have any surprises
    when following the instructions in this book.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Material UI 的版本 .20.14.4 是最佳选择；我选择了这个版本，因为生态系统变化如此之快，最好在这里标记使用的版本，这样您在遵循本书中的说明时就不会有任何意外。
- en: The `formsy-react` library is a very handy library which will help us to validate
    our forms in the publishing app. We will use it on pages like login and registration
    as you will see on the next pages.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`formsy-react` 库是一个非常方便的库，它将帮助我们验证发布应用程序中的表单。我们将在登录和注册等页面上使用它，您将在接下来的页面上看到。'
- en: 读累了记得休息一会哦~
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Working on LoginForm and DefaultInput components
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作在 LoginForm 和 DefaultInput 组件上
- en: 'After we are done with installing our new dependencies, let''s create a folder
    that will keep files related to dumb components (the components that don''t have
    access to any stores; they communicate with the other parts of our application
    with the help of callbacks---you will learn more about this later):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装新依赖项后，让我们创建一个文件夹，用于保存与哑组件相关的文件（这些组件没有访问任何存储库；它们通过回调与我们应用程序的其他部分进行通信---您以后会更多了解这一点）：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then make the content of this file as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此文件的内容设置为如下：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Explanation
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: The `{HOC}` from `formsy-react` is another way of decorating the component (aka
    `mixin` in React's ECMAScript5) with export default `HOC(DefaultInput)` --you
    can find more information about this at [https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc](https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc)
    .
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`formsy-react`的`{HOC}`是另一种用于装饰组件的方式（在React的ECMAScript5中称为`mixin`）通过`export
    default HOC(DefaultInput)`--您可以在[https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc](https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc)找到更多关于此的信息。
- en: 'We are also using the `TextField` from the `material-ui` ; then it takes different
    properties. The following are the properties:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用来自`material-ui`的`TextField`；然后它接受不同的属性。以下是属性：
- en: '`ref` : We want `ref` for each input with its name (username and e-mail).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`：我们希望为每个输入与其名称（用户名和电子邮件）设置`ref`。'
- en: '`floatingLabelText` : This is a nice looking floating text (known as label).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floatingLabelText`：这是一个漂亮的浮动文本（称为标签）。'
- en: '`onChange` : This tells the function''s name that has to be called when someone
    is typing into the TextField.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChange`：这告诉函数的名称，在有人在TextField中输入时必须调用它。'
- en: '`required` : This helps us to manage the required inputs in our form.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`：这有助于我们管理表单中所需的输入。'
- en: '`value` : This is, of course, the current value of our TextField.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这当然是我们TextField的当前值。'
- en: '`defaultValue` : This is a value that is initial. It is very important to remember
    that it''s called just once when a component is calling a constructor of the component.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue`：这是一个初始值。非常重要的是要记住，当组件调用组件的构造函数时，它只调用一次。'
- en: The current text (`this.state.currentText` ) is the value of the `DefaultInput`
    component---it changes with the new value on every `changeValue` event called
    by the callback given in the `TextFieldonChange` prop.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文本（`this.state.currentText`）是`DefaultInput`组件的值---它会随着`TextFieldonChange`属性中给定的回调在每次`changeValue`事件中的新值而改变。
- en: LoginForm and making it work with LoginView
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LoginForm并使其与LoginView配合使用
- en: 'The next step is to create `LoginForm` . This will use the `DefaultInput` component
    with the following commands:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`LoginForm`。这将使用`DefaultInput`组件和以下命令：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then the content of our `src/components/LoginForm.js` file is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的`src/components/LoginForm.js`文件的内容如下：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, we have our `LoginForm` component that is using the `DefaultInput`
    's component. It's a simple `React.js` form that after being submit calls the
    `this.props.onSubmit` --this `onSubmit` function will be defined in `src/views/LoginView.js`
    smart component in a moment. I won't talk too much about attached styles on the
    component because it's up to you how you will style it--you will see a screenshot
    of applied styles of our app in a moment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有一个使用`DefaultInput`组件的`LoginForm`组件。这是一个简单的`React.js`表单，提交后调用`this.props.onSubmit`
    --这个`onSubmit`函数将在稍后在`src/views/LoginView.js`智能组件中定义。我不会过多讨论组件上的附加样式，因为如何样式化取决于您--您将在稍后看到我们应用程序的应用样式的屏幕截图。
- en: Improving the src/views/LoginView.js
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进 src/views/LoginView.js
- en: The last part at our development at this stage before running our application
    is to improve the `LoginView` component.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的应用程序之前，在这个阶段我们开发的最后一部分是改进`LoginView`组件。
- en: 'In `src/views/LoginView.js` make the following changes. Import our new `LoginForm`
    component:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/views/LoginView.js`中进行以下更改。导入我们的新`LoginForm`组件：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then after you are done with imports and constructors, you need a new function
    called `login` :'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在导入和构造函数完成后，您需要一个名为`login`的新函数：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At this point, the `login` function only prints our new JWT token to the console--it's
    enough for now; later we will build more on top of it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`login`函数只会将我们的新JWT令牌打印到控制台--现在足够了；稍后我们将在此基础上构建更多。
- en: 'The last step here is to improve our `render` function from:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一步是改进我们的`render`函数：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To the new one, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到新的函数中，如下所示：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Great! Now we are done! The following is what you will see after running `npm
    start` and running it in your browser:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们完成了！运行`npm start`并在浏览器中运行后，您将看到以下内容：
- en: '![](Image00024.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00024.jpg)'
- en: 'As you can see in the browser''s console, we can see the submitted credential''s
    object `(credentials Object {username: "admin", password: "123456"})` and also
    a token that has been fetched from the backend `(tokenRes eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA)`
    . All this tells us that we are on track in order to implement the login''s mechanism
    in our publishing application.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在浏览器控制台中所看到的，我们可以看到提交的凭据对象`(凭据对象{用户名："admin"，密码："123456"})`，还有从后端获取的令牌`(tokenRes
    eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA)`。所有这些告诉我们，我们正在按照顺序在我们的发布应用程序中实现登录机制。
- en: Important If you get an error, then make sure that you have used the `123456`
    password while creating the hash. Otherwise, type in the custom password that
    is valid to your case.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果出现错误，请确保在创建哈希时使用了`123456`密码。否则，请输入适合您情况的自定义密码。
- en: Making DashboardView's component
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作DashboardView组件
- en: 'At this point, we have a login feature that is not finished, but before continuing
    the work on it, let''s create a simple `src/views/DashboardView.js` component
    that will be shown after a successful login:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个尚未完成的登录功能，但在继续工作之前，让我们创建一个简单的`src/views/DashboardView.js`组件，它将在成功登录后显示：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add some simple content as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些简单的内容如下：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is a simple component, which is static at this point. Later, we will build
    more features into it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的组件，目前是静态的。稍后，我们将为其添加更多功能。
- en: 'The last thing regarding the dashboards that we need to create is a new route
    in the `src/routes/index.js` file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 关于仪表板的最后一件事是在`src/routes/index.js`文件中创建一个新的路由：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We've just added second route using the react-router's config. It uses `DashboardView`
    component located in `../views/DashboardView` file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了第二个路由，使用了react-router的配置。它使用位于`../views/DashboardView`文件中的`DashboardView`组件。
- en: Finishing the login's mechanism
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成登录机制
- en: 'The last improvements for login at this point of our publishing app remain
    at the `src/views/LoginView.js` location:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发布应用程序的这一点上，关于登录的最后改进仍在`src/views/LoginView.js`位置：
- en: 'First of all, let''s add handling an invalid login:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加处理无效登录：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have added this `if(tokenRes === ''INVALID'')` in order to update the error
    state with `this.setState({error: errorRes})` .'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了`if(tokenRes === ''INVALID'')`，以便使用`this.setState({error: errorRes})`更新错误状态。'
- en: 'The next step is to add into the `render` function `Snackbar` that will show
    to the user a type of error. At the top of the `LoginView` component add this
    import:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`render`函数中添加`Snackbar`，它将向用户显示一种错误类型。在`LoginView`组件的顶部添加此导入：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then you need to update the `render` function as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要按照以下方式更新`render`函数：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So after adding it, the `render` function will look like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在添加后，`render`函数将如下所示：
- en: '[PRE63]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `SnackBar onRequestClose` is required here otherwise you will get a warning
    in the developer's console from the Material UI. Okay, so we are handling login's
    error, now let's work on successful logins.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要`SnackBar onRequestClose`，否则您将从Material UI的开发者控制台中收到警告。好的，我们正在处理登录错误，现在让我们处理成功的登录。
- en: Handling successful logins in the LoginView's component
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在LoginView组件中处理成功的登录
- en: 'For handling a successful token''s backend responses add the login function:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 处理成功令牌的后端响应，添加登录功能：
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A new code for handling correct responses, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 处理正确响应的新代码如下：
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Explanation
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: 'After we know that the `tokenRes` is not `INVALID` and it''s not undefined
    (otherwise shows a fatal error to the user), then we follow certain steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们知道`tokenRes`不是`INVALID`并且不是未定义（否则向用户显示致命错误）之后，我们会按照一定的步骤进行：
- en: 'We are fetching the username from the Falcor''s model `(await falcorModel.getValue(''login.username''))`
    . We are fetching the user''s role `(await falcorModel.getValue(''login.role''))`
    . Then we save all the known variables from the backend into `localStoragewith`
    :'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Falcor的模型中获取用户名`(await falcorModel.getValue('login.username'))`。我们获取用户的角色`(await
    falcorModel.getValue('login.role'))`。然后我们将后端的所有已知变量保存到`localStoragewith`中：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At the same end we are sending our user to the `/dashboard` route with the use
    of `this.props.history.pushState(null, '/dashboard')` .
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们使用`this.props.history.pushState(null, '/dashboard')`将我们的用户发送到`/dashboard`路由。
- en: A few important notes about DashboardView and security
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于DashboardView和安全性的一些重要说明
- en: At this point, we won't secure `DashboardView` as there isn't any important
    stuff to secure---we will do it later when we put more assets/features into this
    route, which at the end of our book will be an editor's dashboard that will give
    control over all articles in the system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们不会保护`DashboardView`，因为没有重要的东西需要保护---当我们在这条路线上增加更多资产/功能时，我们会在以后做这个，这本书的最后将是一个编辑者的仪表板，可以控制系统中的所有文章。
- en: The only remaining step for us is to make it a `RegistrationView` component.
    This route will also be available for everyone at this point. Later in the book,
    we will make a mechanism so that only the main admin will be able to add new editors
    into the system (and manage them).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一剩下的步骤是将其变成一个`RegistrationView`组件。在这一点上，这条路线也将对所有人可用。在本书的后面，我们将制定一个机制，只有主管理员才能向系统中添加新的编辑者（并对其进行管理）。
- en: Starting work on the new editor's registration
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新编辑者的注册工作
- en: 'In order to wrap up the registration, let''s first make some changes in our
    user''s scheme from Mongoose''s config file at the location `server/configMongoose.js`
    :'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成注册，让我们首先在Mongoose的配置文件中对用户方案进行一些更改，位置在`server/configMongoose.js`：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To the new scheme as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到新方案如下：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, we have added unique indexes to the `username` and the `email`
    fields. Also, we have added a default value for a role, as any next user in our
    collection will be an editor (not an admin).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经为`username`和`email`字段添加了唯一索引。此外，我们为角色添加了默认值，因为我们集合中的下一个用户将是编辑者（而不是管理员）。
- en: Adding register's falcor-route
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加注册的falcor-route
- en: 'In the file located at `server/routesSession.js` , you need to add a new route
    (next to the login''s route):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在位于`server/routesSession.js`的文件中，您需要添加一个新的路由（在登录路由旁边）：
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: What this code is actually doing is simply receiving the new user's object from
    the frontend via `const newUserObj = args[0]` .
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上只是通过`const newUserObj = args[0]`从前端接收新用户的对象。
- en: 'Then we are salting the password that we will store in our database:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对密码进行加盐，我们将在数据库中存储：
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then we are creating a new user model from Mongoose via `const newUser = new
    User(newUserObj)` , because the `newUser` variable is a new model (not saved yet)
    of the user. Next we need to save it with this code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过`const newUser = new User(newUserObj)`从Mongoose创建一个新的用户模型，因为`newUser`变量是用户的新模型（尚未保存）。接下来我们需要用这段代码保存它：
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After it's saved into the db and the Promise has been resolved, we are managing
    an invalid entry to the db first by making the Mongoose result's object into a
    simple JSON structure with `const newUserDetail = newRes.toObject();` .
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存到数据库并且Promise已经解决后，我们首先通过将Mongoose结果对象转换为简单的JSON结构来管理数据库中的无效条目，使用`const newUserDetail
    = newRes.toObject();`。
- en: 'And after we are done with it, then we are returning an `INVALID` information
    to the Falcor''s model:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们向Falcor的模型返回一个`INVALID`信息：
- en: '[PRE72]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'So, we are done with handling an invalid user registration from Falcor. The
    next step is to replace this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经处理了来自Falcor的无效用户注册。下一步是替换这个：
- en: '[PRE73]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 读累了记得休息一会哦~
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Explanation
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: We need to cast our new user's ID into the string, `newUserId = newUserDetail._id.toString()`
    (otherwise it will break the code).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将新用户的ID转换为字符串，`newUserId = newUserDetail._id.toString()`（否则会破坏代码）。
- en: As you can see, we have a standard return statement that complements the model
    in Falcor.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个标准的返回语句，与Falcor中的模型相辅相成。
- en: 'To quickly recall, after it returns correctly on the backend, we will be able
    to request this value on the frontend as follows: `const newUserId = await falcorModel.getValue([''register'',
    ''newUserId'']);` (this is just an example of how to fetch this new `UserId` on
    the client-side--don''t write it into your code, we will do it in a minute).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回想一下，在后端正确返回后，我们将能够在前端请求这个值，如下所示：`const newUserId = await falcorModel.getValue(['register',
    'newUserId']);`（这只是一个在客户端获取新`UserId`的示例--不要在你的代码中写入它，我们马上就会做）。
- en: You will get used to it after few more examples.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 再多看几个例子，你就会习惯的。
- en: Frontend implementation (RegisterView and RegisterForm)
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端实现（RegisterView和RegisterForm）
- en: 'Let''s first create a component that will manage on the frontend, the register''s
    form with the following actions:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个组件，在前端管理注册表单，具有以下操作：
- en: '[PRE74]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The content of that file will be:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的内容将是：
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding registration component is creating a form exactly the same way
    as on `LoginForm` . After a user clicks the `Register` button, it sends a callback
    to the `src/views/RegisterView.js` component (we will create this in a moment).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注册组件创建了一个与`LoginForm`完全相同的表单。用户点击`Register`按钮后，它会发送一个回调到`src/views/RegisterView.js`组件（我们马上就会创建这个）。
- en: Remember that in the components' directory we keep only DUMB components so all
    the communication with the rest of the app must to be done via callbacks like
    in this example.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在组件目录中，我们只保留DUMB组件，因此与应用程序的其余部分的所有通信必须通过回调来完成，就像这个例子中一样。
- en: RegisterView
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RegisterView
- en: 'Let''s create a `RegisterView` file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`RegisterView`文件：
- en: '[PRE76]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Its content is:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它的内容是：
- en: '[PRE77]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: These are standard things that we use in our smart components (we need `falcorModel`
    in order to communicate with the backend and `mapStateToProps` and `mapDispatchToProps`
    in order to communicate with our Redux's store/reducer).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在智能组件中使用的标准内容（我们需要`falcorModel`来与后端通信，以及`mapStateToProps`和`mapDispatchToProps`来与我们的Redux存储/Reducer通信）。
- en: 'Okay, that''s not all for the register view; next let''s add a component:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，注册视图还没有结束，接下来让我们添加一个组件：
- en: '[PRE78]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As you can see in the preceding code snippet, we are missing the `register`
    function, so between the `constructor` and the `render` function add the function,
    as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们缺少`register`函数，所以在`constructor`和`render`函数之间添加函数，如下所示：
- en: '[PRE79]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see, the `async register (newUserModel)` function is asynchronous
    and friendly to the awaits. Next we are just logging into the console what a user
    has submitted with `console.info("newUserModel", newUserModel)` . After that,
    we query the falcor-router with a call:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`async register (newUserModel)`函数是异步的，并且对`await`友好。接下来，我们只是在控制台中记录用户提交的内容，`console.info("newUserModel",
    newUserModel)`。之后，我们使用调用查询falcor-router：
- en: '[PRE80]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'After we have called the router, we fetch the response with:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用路由器后，我们使用以下代码获取响应：
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Depending on the response from the backend, we do the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 根据后端的响应，我们执行以下操作：
- en: 'For `INVALID` we are fetching and setting error message into the component''s
    state (`this.setState({error: errorRes}))`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于`INVALID`，我们正在获取并将错误消息设置到组件的状态中（`this.setState({error: errorRes}))`）'
- en: If the user has registered correctly, then we have their new ID and we are asking
    the user to login with the history's push state `(this.props.history.pushState(null,
    '/login');)`
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已经正确注册，那么我们有他们的新ID，并且我们正在要求用户使用历史的push状态进行登录`（this.props.history.pushState(null,
    '/login');)`
- en: 'We didn''t create a route inside `routes/index.js` for `RegisterView` and there
    is no link in `CoreLayout` so our user is unable to use it. Add new imports in
    `routes/index.js` :'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在`routes/index.js`中为`RegisterView`创建路由，`CoreLayout`中也没有链接，因此我们的用户无法使用它。在`routes/index.js`中添加新的导入：
- en: '[PRE82]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then add a route, so the export default from `routes/index.js` will look like
    this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一个路由，所以`routes/index.js`中的默认导出将如下所示：
- en: '[PRE83]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And finally, add a link inside the `src/layoutsCoreLayout.js` file''s `render`
    method:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`src/layoutsCoreLayout.js`文件的`render`方法中添加一个链接：
- en: '[PRE84]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'At this point ,we should be able to register with this form:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该能够使用这个表格进行注册：
- en: '![](Image00025.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00025.jpg)'
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the next chapter, we will start working on the server-side rendering of our
    app. This means that on each request to our Express's server, we will generate
    the HTML markup based on the request from the client side. That feature is very
    useful for apps like ours where the speed of web loading is very important for
    such users as ours.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始处理应用程序的服务器端渲染。这意味着在每次对Express服务器的请求时，我们将根据客户端请求生成HTML标记。这个功能对于像我们这样的应用程序非常有用，其中网页加载速度对我们这样的用户非常重要。
- en: You can imagine that most of the news sites are for entertainment and that means
    a short attention span from our potential users. The speed of loading is important.
    There are also some opinions that the server-side rendering also helps for search
    engine optimization reasons.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象，大多数新闻网站都是为娱乐而设，这意味着我们潜在用户的注意力很短。加载速度很重要。也有一些观点认为，服务器端渲染也有助于搜索引擎优化的原因。
- en: The crawlers have easier ways to *read* the text from our article as they don't
    need to execute the JavaScript in order to fetch it from the server (in comparison
    to non-server-side rendering single-page apps).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 爬虫有更容易的方法来*读取*我们文章中的文本，因为它们不需要执行JavaScript来从服务器获取文本（与非服务器端渲染的单页面应用相比）。
- en: 'At least one thing is certain: if you have a server-side rendering on your
    articles'' publishing app then Google may see that you care about the fast loading
    of your app and so it will probably give you some disadvantage over full single-page
    websites that don''t care about server-side rendering.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一件事是肯定的：如果您在文章发布应用程序上有服务器端渲染，那么谷歌可能会认为您关心应用程序的快速加载，因此它可能会给您一些不利于不关心服务器端渲染的完整单页面网站。
