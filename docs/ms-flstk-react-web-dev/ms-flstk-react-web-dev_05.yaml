- en: Falcor Advanced Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor的高级概念
- en: Currently, our app has the ability to add, edit, and delete articles, but only
    on the frontend with the help of Redux's reducers. We need to add some full-stack
    mechanism to make this able to perform CRUD operations on the database. We will
    also need to add some security features on the backend so non-authenticated users
    won't be able to perform CRUD operations on the MongoDB collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序具有添加、编辑和删除文章的功能，但只能在前端借助Redux的reducers的帮助下进行。我们需要添加一些全栈机制，使其能够在数据库上执行CRUD操作。我们还需要在后端添加一些安全功能，以便非经过身份验证的用户无法对MongoDB集合执行CRUD操作。
- en: Let's pause coding for a moment. Before we start developing the full-stack Falcor
    mechanism, let's discuss our React, Node, and Falcor setup in more detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下编码。在开始开发全栈Falcor机制之前，让我们更详细地讨论一下我们的React、Node和Falcor设置。
- en: 'It''s important to understand why we have chosen Falcor in our technical stack.
    In general, at the custom software development company where I work (you can find
    more at [www.ReactPoland.com](http://www.ReactPoland.com) ), we use Falcor as
    it has many great advantages for our clients in terms of the productivity of developing
    full-stack mobile/web applications. Some of them are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解为什么我们选择在技术栈中使用Falcor很重要。总的来说，在我工作的定制软件开发公司（您可以在[www.ReactPoland.com](http://www.ReactPoland.com)找到更多信息），我们使用Falcor，因为它在开发全栈移动/
    web应用程序的生产力方面对我们的客户有很多优势。其中一些如下：
- en: The simplicity of the concept
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个概念的简单性
- en: A speedup of over by 30 percent in development in comparison to a RESTful approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与RESTful方法相比，开发速度提高了30％以上
- en: Shallow learning curve, so a developer who learns Falcor can become effective
    very quickly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习曲线较浅，因此学习Falcor的开发人员可以很快变得有效
- en: An effective way of fetching data (from backend to the client side) that is
    quite astounding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种相当惊人的从后端到客户端获取数据的有效方式
- en: I will keep these four points short and sweet, for now. Later in the chapter,
    you will learn more about problems that you may face when using Falcor and Node.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将暂时简短地介绍这四点。在本章的后面，您将了解在使用Falcor和Node时可能遇到的更多问题。
- en: 'Currently, we have assembled a kind of full-stack starter kit with React, Redux,
    Falcor, Node, Express, and MongoDB. It''s not perfect yet. We will make it our
    focus for this chapter, which will include the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经组装了一个包含React、Redux、Falcor、Node、Express和MongoDB的全栈起始工具包。它还不完美。我们将把它作为本章的重点，其中将包括以下主题：
- en: Better understanding the big picture of *RESTless data fetching* solutions and
    the similarities and differences between Falcor and Relay/GraphQL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地理解*无REST数据获取*解决方案的整体情况，以及Falcor与Relay/GraphQL之间的相似性和差异
- en: How to secure routes in order to authenticate users on the backend
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何保护路由以在后端对用户进行身份验证
- en: How to handle errors on the backend and send them seamlessly to the frontend
    with the help of errorSelectors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在后端处理错误，并借助errorSelectors将它们无缝地发送到前端
- en: A detailed look at Falcor's sentinels and how exactly `$ref` , `$atom` , and
    `$error` work in Falcor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细了解Falcor的sentinels以及`$ref`、`$atom`和`$error`在Falcor中的工作原理
- en: What a JSON graph is and how it works
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON图是什么以及它是如何工作的
- en: What the virtual JSON concept is in Falcor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Falcor中虚拟JSON概念是什么
- en: The problem that Falcor aims to solve
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor旨在解决的问题
- en: Before the era of single-page applications, there weren't problems with fetching
    data on the client, as all of the data was always fetched on the server, and even
    then, the server would send the HTML markup to the client. Each time someone clicked
    on a URL (`href` ), our browser requested totally new HTML markup from the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页面应用程序时代之前，客户端获取数据并没有问题，因为所有数据都是在服务器上获取的，即使是在那时，服务器也会将HTML标记发送到客户端。每当有人点击URL（`href`）时，我们的浏览器会从服务器请求全新的HTML标记。
- en: Based on the preceding principles of non-SPA applications, Ruby on Rails became
    the king of web development's technical stack, but later things changed. Since
    2009-2010, we've been creating more and more JavaScript client applications, which
    are more likely fetched once from the backend as, for example, a `bundle.js` file.
    They're called SPAs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于非SPA应用程序的前述原则，Ruby on Rails成为了Web开发技术栈的王者，但后来情况发生了变化。自2009-2010年以来，我们一直在创建越来越多的JavaScript客户端应用程序，这些应用程序更有可能从后端获取一次，例如一个`bundle.js`文件。它们被称为SPA。
- en: Because of this SP Apps trend, some new problems emerged that weren't known
    to non-SP Apps developers, such as fetching data from the API endpoint on the
    backend in order to consume that JSON data on the client side.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SP应用程序的趋势，出现了一些新问题，这些问题对于非SP应用程序的开发人员来说是未知的，比如从后端的API端点获取数据，以便在客户端消耗JSON数据。
- en: 'In general, the old-fashioned workflow for RESTful applications was as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，RESTful应用程序的老式工作流程如下：
- en: Create endpoints on the backend.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后端创建端点。
- en: Create the fetching mechanism on the frontend.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前端创建获取机制。
- en: Fetch data from the backend by coding POST/GET requests on the frontend based
    on the API's specification.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据API规范，在前端编写POST/GET请求来从后端获取数据。
- en: When you fetch the JSON from the backend to the frontend, you can consume the
    data and use it in order to create the UI view based on a certain use case.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你从后端获取JSON到前端时，你可以使用这些数据，并根据特定的用例创建UI视图。
- en: This process is kind of frustrating if someone such as a client or boss changes
    their mind, because you were implementing the entire code on the backend and frontend.
    Later the backend API endpoints become irrelevant, so you need to start working
    on them from scratch based on the changed requirements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人，比如客户或老板改变主意，这个过程有点令人沮丧，因为你正在后端和前端实现整个代码。后来，后端API端点变得无关紧要，所以你需要根据更改的要求从头开始工作。
- en: Virtual JSON - one model everywhere
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟JSON-一个模型到处都有
- en: For Falcor, one model everywhere is the main tagline of this great library.
    In general, the main purpose of using it is to create a single JSON model that
    is exactly the same on the frontend and backend. What does this mean for us? It
    means that if anything changes, we need to change the model, which is exactly
    the same on the backend and frontend--so in case of any changes, we need to tweak
    our model without worrying about how the data is provided on the backend and fetched
    on the frontend.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Falcor来说，一个模型到处都有是这个伟大库的主打标语。一般来说，使用它的主要目的是创建一个在前端和后端完全相同的单个JSON模型。这对我们意味着什么？这意味着如果有任何变化，我们需要改变模型，这个模型在后端和前端是完全相同的-所以在任何变化的情况下，我们需要调整我们的模型，而不用担心数据在后端是如何提供和在前端是如何获取的。
- en: 'Falcor''s innovation is to introduce a new concept called virtual JSON (analogical
    to virtual DOM for React). This lets you represent all your remote data sources
    (for example, MongoDB in our case) as a single domain model. The whole idea is
    that you code the same way without caring where your data is: is it on the client-side
    memory cache or on the server? You don''t need to care, as Falcor, with its innovative
    approach, does a lot of the job (for example, querying with `xhr` requests) for
    you.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor的创新是引入了一个称为虚拟JSON的新概念（类似于React的虚拟DOM）。这让你可以将所有远程数据源（例如我们的情况下的MongoDB）表示为一个单一的领域模型。整个想法是，你以相同的方式编码，而不用关心你的数据在哪里：它是在客户端内存缓存还是在服务器上？你不需要关心，因为Falcor以其创新的方法为你做了很多工作（例如，使用`xhr`请求进行查询）。
- en: Data fetching is a problem for developers. Falcor is here to help to make it
    simpler. You can fetch data from the backend to the frontend, writing fewer lines
    of code than ever!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取对开发人员来说是一个问题。Falcor在这里帮助简化了这个问题。你可以从后端获取数据到前端，写的代码比以往更少！
- en: It's May 2016, and the only viable competitors that I see on the horizon are
    the Facebook libraries called Relay (on the client side) and GraphQL (on the backend).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是2016年5月，我所看到的唯一可行的竞争对手是Facebook的Relay库（客户端）和GraphQL（后端）。
- en: Let's try to compare both.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着比较一下两者。
- en: 读累了记得休息一会哦~
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Falcor versus Relay/GraphQL
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor与Relay/GraphQL
- en: As with any tool, there are always pros and cons.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何工具一样，总会有利弊。
- en: For certain, Falcor is always better than Relay/GraphQL in small/mid-sized projects,
    at least unless you have master developers (or you are a master yourself) who
    know Relay/GraphQL very well. Why is that?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型/中型项目来说，Falcor总是比Relay/GraphQL更好，至少除非你有精通Relay/GraphQL的高级开发人员（或者你自己是高手）。为什么呢？
- en: In general, Relay (for the frontend) and GrapQL (for the backend) are two different
    tools and you must be efficient in order to use properly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Relay（用于前端）和GrapQL（用于后端）是两种不同的工具，你必须高效地使用才行。
- en: Very often in commercial environments, you don't have too much time to learn
    things from scratch. This is also a reason behind the success of React.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，你通常没有太多时间从零开始学习。这也是React成功的原因之一。
- en: Why has React succeeded? React is much easier to grasp in order to be an efficient
    frontend developer. A CTO or technical director hires a newbie developer who knows
    jQuery (for example), and then the CTO can easily project that this junior developer
    will be effective in React in 7 to 14 days; I was teaching junior frontend developers
    with basic knowledge of JavaScript/jQuery, and I found out that they quite quickly
    become efficient in creating client-side apps with React.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么React取得了成功？React更容易掌握，以便成为高效的前端开发人员。一个CTO或技术总监雇佣了一个懵懂的开发人员，他懂得jQuery（例如），然后CTO可以轻松预测这个初级开发人员在7到14天内能够有效地使用React；我曾经教授过一些基本了解JavaScript/jQuery的初级前端开发人员，我发现他们很快就能够有效地使用React创建客户端应用程序。
- en: We can find the same situation with Falcor. Falcor, in comparison to Relay +
    GraphQL, is like the simplicity of React compared to the monolithic framework
    of Angular.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Falcor中找到相同的情况。与Relay + GraphQL相比，Falcor就像React的简单性与Angular的庞大框架相比一样。
- en: This single factor described in the previous few paragraphs means that Falcor
    is better for small/mid-size projects with a limited budget.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面几段描述的这个单一因素意味着Falcor对于预算有限的小型/中型项目来说更好。
- en: You may find some opportunities to learn Relay/GraphQL in bigger companies with
    much bigger budgets, such as Facebook, when you have 6 months to master a technology.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有6个月的时间来掌握一项技术时，你可能会在像Facebook这样预算更大的大公司中找到学习Relay/GraphQL的机会。
- en: FalcorJS can be mastered effectively in two weeks, but GraphQL + Relay cannot.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FalcorJS可以在两周内有效掌握，但GraphQL + Relay不行。
- en: Big-picture similarities
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大局观的相似之处
- en: Both these tools are trying to solve the same problem. They are efficient by
    design for both developers and the network (trying to optimize the number of queries
    in comparison to a RESTful approach).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具都在努力解决同样的问题。它们在设计上对开发人员和网络都是高效的（试图优化查询数量，与RESTful方法相比）。
- en: They have the ability to query the backend server in order to fetch data and
    also have batching ability (so you can fetch more than two different sets of data
    with one network request). Both have some caching abilities.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有能力查询后端服务器以获取数据，并且具有批处理能力（因此您可以通过一次网络请求获取两个不同的数据集）。两者都具有一些缓存能力。
- en: Technical differences - overview
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术上的差异-概述
- en: With a technical overview, we can find out that in general, Relay allows you
    to query an undefined number of items from the GraphQL server. In Falcor, for
    comparison, you need to first ask the backend how many items it has before being
    able to query for the collection objects' details (such as articles, in our book's
    case).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过技术概述，我们可以发现，总的来说，Relay允许您从GraphQL服务器查询未定义数量的项目。而在Falcor中，相比之下，您需要首先询问后端有多少项目，然后才能查询集合对象的详细信息（例如，在我们书中的文章）。
- en: 'In general, the biggest difference here is that GraphQL/Relay is a query language
    tool and Falcor is not. What is a query language? It''s one with which you can
    make queries from the frontend similar to SQL, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这里最大的区别是GraphQL/Relay是一种查询语言工具，而Falcor不是。什么是查询语言？它是一种可以从前端进行类似于SQL的查询的语言，就像这样：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code can be made a query from the frontend via `Relay.QL` , and
    then GraphQL processes the query in the same way as SQL, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以通过`Relay.QL`从前端进行查询，然后GraphQL会以与SQL相同的方式处理查询，就像这样：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Things may get harder if there are, for example, a million articles in the DB
    and you didn't expect so many on the frontend.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果数据库中有一百万篇文章，而您没有预料到前端会有这么多，事情可能会变得更加困难。
- en: 'In Falcor, you do it differently, as you''ve already learned:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Falcor中，您会以不同的方式进行操作，就像您已经学到的那样：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding Falcor example, you must first know how many records there
    are in the MongoDB instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Falcor示例中，您必须首先知道MongoDB实例中有多少条记录。
- en: This is one of most important differences and creates some challenges for both
    sides.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的区别之一，并为双方都带来了一些挑战。
- en: For GraphQL and Relay, the question is whether the power of those query languages
    is worth the complexity created in the learning curve, because that complexity
    may not be worth it for small/mid-sized projects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GraphQL和Relay，问题是这些查询语言的强大是否值得在学习曲线上创建的复杂性，因为对于小型/中型项目来说，这种复杂性可能不值得。
- en: Now that the basic differences have been discussed, let's focus on Falcor and
    improving our current publishing app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本的差异已经讨论过了，让我们专注于Falcor和改进我们当前的发布应用程序。
- en: Improving our application and making it more reliable
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的应用程序，使其更可靠
- en: 'We need to improve things such as the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改进以下事项：
- en: After a login, we shall send user details in each request (the token, username,
    and a role; you can find a screenshot later in the section *Improving our Falcor
    code on the frontend* )
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录后，我们将在每个请求中发送用户详细信息（令牌、用户名和角色；您可以在*改进我们前端的Falcor代码*部分后找到截图）
- en: The backend needs to be secured so that authorization is checked before running
    add/edit/delete operations on the backend
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端需要受到保护，以便在运行后端的添加/编辑/删除操作之前检查授权
- en: We need to provide the ability to catch errors on the backend and give a notification
    to the user on the frontend about something not working correctly
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要提供在后端捕获错误并在前端向用户通知某些功能未正常工作的能力
- en: Securing the auth required routes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护所需的路由权限
- en: Currently, our app has the ability to add/edit/delete a route. The problem with
    our current implementation is that we don't check whether a client making a CRUD
    operation has the privileges to do so.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序具有添加/编辑/删除路由的能力。我们当前实现的问题是我们没有检查客户端进行CRUD操作是否具有权限。
- en: The solution of securing Falcor routes requires some changes to our current
    implementation, so for each request, before performing the operation, we will
    check whether we have got the correct token from the client and whether the user
    making the call has the ability to edit (in our case, it means that if anyone
    has an editor role and is authenticated correctly with his username and password,
    then he can add/edit/delete an article).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 保护Falcor路由的解决方案需要对我们当前的实现进行一些更改，因此对于每个请求，在执行操作之前，我们将检查我们是否从客户端获得了正确的令牌，以及发出调用的用户是否具有编辑的能力（在我们的情况下，这意味着如果任何人具有编辑角色并且已正确使用用户名和密码进行身份验证，则可以添加/编辑/删除文章）。
- en: JSON Graph and JSON envelopes in Falcor
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor中的JSON图和JSON信封
- en: As the Falcor documentation states, "JSON Graph is a convention for modeling
    graph information as a JSON object. Applications that use Falcor represent all
    their domain data as a single JSON Graph object."
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Falcor文档的说法，“JSON图是一种将图信息建模为JSON对象的约定。使用Falcor的应用程序将其所有领域数据表示为单个JSON图对象。”
- en: In general, JSON Graph in Falcor is valid JSON with some new features. To be
    more precise, JSON Graph introduces a new types of data besides strings, numbers,
    and Booleans. The new data type in Falcor is called a **sentinel** . I will try
    to explain it later in the chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Falcor中的JSON图是有效的JSON，具有一些新功能。更准确地说，JSON图除了字符串、数字和布尔值之外，还引入了一种新的数据类型。Falcor中的新数据类型称为**sentinel**。我将在本章稍后尝试解释它。
- en: Generally, the second most important thing to understand in Falcor are JSON
    envelopes. The great thing is that they work out of the box, so you don't have
    to worry too much about them. But if you want to know what the short and sweet
    answer is, JSON envelopes help send JSON's model via HTTP's protocol. It's a way
    of transferring data from frontend to backend (with the `.call` , `.set` , and
    `.get` methods). In the same way, before the backend (after processing a request's
    details), before sending the improved model's details to the client side, Falcor
    puts it into an *envelope* so that it can be easily transferred via a network.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在Falcor中理解的第二个最重要的事情是JSON信封。很棒的是它们可以直接使用，所以你不必太担心它们。但是如果你想知道简短而甜美的答案是什么，JSON信封帮助通过HTTP协议发送JSON的模型。这是一种从前端到后端传输数据的方式（使用`.call`、`.set`和`.get`方法）。同样，在后端（在处理请求的细节之后），在将改进的模型细节发送到客户端之前，Falcor将其放入一个*信封*中，以便可以通过网络轻松传输。
- en: A good (but not perfect) analogy for JSON envelopes is that you put a written
    list into an envelope because you don't want to send some valuable information
    over from point *A* to point *B* ; the network doesn't care what you send in that
    envelope. The most important thing is that the sender and the receiver know the
    context of the application model.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JSON信封的一个好（但不完美）类比是，你将一份书面清单放入一个信封中，因为你不想将一些有价值的信息从A点发送到B点；网络并不在乎你在信封中发送了什么。最重要的是发送方和接收方知道应用程序模型的上下文。
- en: You can find more information about the JSON Graph and envelopes at [http://netflix.github.io/falcor/documentation/jsongraph.html](http://netflix.github.io/falcor/documentation/jsongraph.html)
    .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://netflix.github.io/falcor/documentation/jsongraph.html](http://netflix.github.io/falcor/documentation/jsongraph.html)找到有关JSON图和信封的更多信息。
- en: Improving our Falcor code on the frontend
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们前端的Falcor代码
- en: Currently, after a user authorizes himself, all the data is saved into local
    storage. We need to close the loop by sending that data--token, username, and
    role--back to the backend with each request so we can check again whether a user
    is authenticated correctly. If not, then we need to send an authentication error
    with the request and show it back on the frontend.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，用户授权后，所有数据都保存在本地存储中。我们需要通过每个请求将这些数据（令牌、用户名和角色）发送回后端，以便我们可以再次检查用户是否被正确认证。如果没有，我们需要发送一个带有请求的认证错误，并在前端显示出来。
- en: 'The arrangement in the following screenshot is specifically important for security
    reasons so that no unauthorized user can add/edit/delete an article in our database:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图中的排列对于安全原因特别重要，以防止未经授权的用户在我们的数据库中添加/编辑/删除文章。
- en: '![](Image00046.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00046.jpg)'
- en: In the screenshot, you can find out where you can get information about the
    `localStorage` data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，你可以找到关于`localStorage`数据的信息。
- en: 'The following is our current code in `src/falcorModel.js` :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们当前在`src/falcorModel.js`中的代码：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to change this to a new, improved version:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其更改为一个新的、改进的版本：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What have we done in the previous code snippet? The `extends` keyword from ECMAScript6
    shows an example of where the simplicity of the class syntax shines. Extending
    the `FalcorDataSource` means that `PublishingAppDataSource` inherits everything
    that the `FalcorDataSource` has and it makes the `onBeforeRequest` method have
    our custom behavior (by mutating `config.headers` ). The `onBeforeRequest` method
    is checking the configuration mutated by us before our `xhr` instance is created.
    This helps us modify the `XMLHttpRequest` with a token, username, and role--in
    case our app's user logs out in the meantime, we can send that information to
    the backend.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码片段中我们做了什么？ECMAScript6中的`extends`关键字展示了类语法的简洁性的一个例子。扩展`FalcorDataSource`意味着`PublishingAppDataSource`继承了`FalcorDataSource`的所有内容，并且它使`onBeforeRequest`方法具有了我们自定义的行为（通过改变`config.headers`）。`onBeforeRequest`方法在我们创建`xhr`实例之前检查了我们改变的配置。这有助于我们通过令牌、用户名和角色修改`XMLHttpRequest`，以防我们应用的用户在此期间注销，我们可以将该信息发送到后端。
- en: 'After you implement the previous code in `falcorModel.js` and a user is logged,
    those variables will be added to each request:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你在`falcorModel.js`中实现了之前的代码并且用户已登录后，这些变量将被添加到每个请求中：
- en: '![](Image00047.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00047.jpg)'
- en: Improving server.js and routes.js
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进server.js和routes.js
- en: In general, we currently export an array of objects from the `server/routes.js`
    file. We need to improve it, so we will return a function that will modify our
    array of objects so we have control over which route is returned to which user,
    and in case a user does not have a valid token or enough privileges, we will return
    an error. This will improve the security of our whole app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们目前从`server/routes.js`文件中导出一个对象数组。我们需要改进它，所以我们将返回一个函数，该函数将修改我们的对象数组，以便我们可以控制哪个路由返回给哪个用户，并且如果用户没有有效的令牌或足够的权限，我们将返回一个错误。这将提高我们整个应用的安全性。
- en: 'In the `server/server.js` file, find this old code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/server.js`文件中，找到这段旧代码：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace it with this improved one:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个改进的版本替换它：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our new version, we assume that the `routes` variable is a function with
    the `req` and `res` variables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新版本中，我们假设`routes`变量是一个带有`req`和`res`变量的函数。
- en: Let's improve the routes itself so we won't return an array anymore, but a function
    that returns an array (so we end up with more flexibility).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进路由本身，这样我们就不再返回一个数组，而是返回一个返回数组的函数（这样我们就会有更多的灵活性）。
- en: 'The next step is to improve the `server/routes.js` file in order to make a
    function that receives the `currentSession` object, which stores all the information
    about a request. We need to change this in `routes.js` :'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进`server/routes.js`文件，以便创建一个接收`currentSession`对象的函数，该对象存储有关请求的所有信息。我们需要在`routes.js`中进行这些更改：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of exporting an array of routes, we need to export a function that will
    return routes based on a current request's header details.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再导出路由数组，而是需要导出一个根据当前请求头详情返回路由的函数。
- en: 'The top part of the `server/routes.js` file (with imports) is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/routes.js`文件的顶部部分（包括导入）如下所示：'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow this by exporting a new function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接着导出一个新的函数：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First of all, we receive the `req` (request details) and `res` (object that
    represents the HTTP response) variables into the arrow functions. Based on the
    information provided by `req` , we get the header details (`let { token, role,
    username } = req.headers;` ). Next, we have `userDetailsToHash` and then we check
    what will be the correct `authToken` with `let authSignToken = jwt.sign(userDetailsToHash,
    jwtSecret.secret)` . Afterward, we check whether the user is authorized with `let
    isAuthorized = authSign === token` . Then we create a `sessionObject` , which
    will be reused across all the Falcor routes later (`let sessionObject = {isAuthorized,
    role, username};` ).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`req`（请求详情）和`res`（代表HTTP响应的对象）变量传入箭头函数中。根据`req`提供的信息，我们获取头部详情（`let { token,
    role, username } = req.headers;`）。接下来，我们有`userDetailsToHash`，然后我们检查正确的`authToken`是什么，使用`let
    authSignToken = jwt.sign(userDetailsToHash, jwtSecret.secret)`。之后，我们检查用户是否经过授权，使用`let
    isAuthorized = authSign === token`。然后我们创建一个`sessionObject`，它将在以后的所有Falcor路由中重复使用（`let
    sessionObject = {isAuthorized, role, username};`）。
- en: Currently, we have one route (`articles.length` ), which was described in [Chapter
    2](text00058.html) , *Full-Stack Login and Registration for Our Publishing App*
    (so there's nothing new so far).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个路由（`articles.length`），在[第2章](text00058.html)中描述过，*我们发布应用的全栈登录和注册*（到目前为止没有什么新的）。
- en: As you can see in the previous code, instead of exporting `PublishingAppRoutes`
    directly, we are exporting with the arrow function `export default (req, res)`
    .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中所看到的，我们不再直接导出`PublishingAppRoutes`，而是使用箭头函数`export default (req, res)`导出。
- en: 'We need to re-add (under `articles.length` ) the second route, called `articles[{integers}]["_id","articleTitle","articleContent"]`
    , with the following code in the `server/routes` :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新添加（在`articles.length`下面）第二个路由，名为`articles[{integers}]["_id","articleTitle","articleContent"]`，在`server/routes`中加入以下代码：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the route that fetches articles from databases and returns `falcor-route`
    for it. It's exactly the same as introduced before; the only different is that
    now it's part of the function (`export default ( req, res ) => { ... }` ).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从数据库获取文章并返回`falcor-route`的路由。它与之前介绍的完全相同；唯一不同的是现在它是函数的一部分（`export default
    ( req, res ) => { ... }`）。
- en: Before we start to implement add/edit/delete on the backend with `falcor-router`
    , we need to introduce ourselves to the concept of sentinels, as it will be very
    important for the well-being of our full-stack application, the reason for which
    will be explained in a moment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`falcor-router`在后端实现添加/编辑/删除之前，我们需要介绍一下sentinels的概念，因为这对我们全栈应用的健康非常重要，稍后将会解释原因。
- en: Falcor's sentinel implementation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor的sentinel实现
- en: Let's understand what sentinels are. They are required to make Fullstack's Falcor
    application work. It's a set of tools you have to learn.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下sentinels是什么。它们是使Fullstack的Falcor应用程序工作所必需的。这是一套你必须学会的工具。
- en: 'They are new primitive value types created exclusively for making data transportation
    between the backend and client side much easier and out of the box (examples of
    new Falcor primitive values are `$error` and `$ref` ). Here''s an analogy: you
    have types in a regular JSON such as string, number, and object and. On the other
    hand, in Falcor''s virtual JSON, you can additionally use sentinels such as `$error`
    , `$ref` , or `$atom` alongside the standard JSON types listed previously.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是专门用于使后端和客户端之间的数据传输更加简单和开箱即用的新原始值类型（新的Falcor原始值的示例是`$error`和`$ref`）。这里有一个类比：在常规JSON中，你有字符串、数字和对象等类型。另一方面，在Falcor的虚拟JSON中，你还可以使用`$error`、`$ref`或`$atom`等sentinel，以及之前列出的标准JSON类型。
- en: Additional information about sentinels is available at [https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata](https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata)
    .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有关sentinels的更多信息，请参阅[https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata](https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata)。
- en: At this stage, it's important to understand how Falcor's sentinels are working.
    The different types of sentinel in Falcor are explained in the following sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，理解Falcor的sentinels是如何工作的很重要。Falcor中不同类型的sentinel在以下部分有解释。
- en: The $ref sentinel
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $ref sentinel
- en: According to the documentation, "a reference is a JSON object with a `$type`
    key that has a value of `ref` and a `value` key that has a `Path` array as its
    value."
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，“引用是一个具有`$type`键的JSON对象，其值为`ref`，以及一个`value`键，其值为`Path`数组。”
- en: '"A reference is like a symbolic link in the UNIX filesystem," as the documentation
    states, and this comparison is very good.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文档所述，“引用就像UNIX文件系统中的符号链接”，这个比喻非常好。
- en: 'An example of `$ref` is as a follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ref`的一个例子如下：'
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you use `$ref(['articlesById','STRING_ARTCILE_ID_HERE'])` , it's equal to
    the preceding example. The `$ref` sentinel is a function that changes the array's
    details into that `$type` and value's notation object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`，它等同于前面的例子。`$ref` sentinel是一个函数，它将数组的细节转换成`$type`和值的表示对象。
- en: You can find both approaches in order to deploy/use `$ref` in any Falcor-related
    project, but in our project, we will stick to the `$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`
    convention.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何与Falcor相关的项目中找到部署/使用`$ref`的两种方法，但在我们的项目中，我们将坚持使用`$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`的约定。
- en: 'Just to make it clear, this is how to import a `$ref` sentinel in our codebase:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，这是如何在我们的代码库中导入`$ref` sentinel的方法：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After you import `falcor-json-graph` , you can use the `$ref` sentinel. You
    will already have installed the `falcor-json-graph` library as the installation
    has been described in the previous chapter; if not, use this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`falcor-json-graph`之后，你可以使用`$ref` sentinel。你已经安装了`falcor-json-graph`库，因为安装已经在前一章中描述过；如果没有，请使用以下命令：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But what does `articlesById` mean in that whole `$ref` gig? And what does `STRING_ARTICLE_ID_HERE`
    mean in the preceding example? Let's look at an example from our project that
    might make it clearer for you.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在整个`$ref`中，`articlesById`是什么意思？在前面的例子中，`STRING_ARTICLE_ID_HERE`又是什么意思？让我们看一个来自我们项目的例子，这可能会让你更清楚。
- en: Detailed example of the $ref sentinel
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $ref sentinel的详细示例
- en: 'Let''s assume that we have two articles in our MongoDB instance:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的MongoDB实例中有两篇文章：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So based on our array''s example with mocked articles (IDs `987654` and `123456`
    ), the `$ref` will look as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以根据我们模拟文章的数组示例（ID为`987654`和`123456`），`$ref`将如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An even more detailed answer is this one:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的答案是这样的：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An important thing to note is that `articlesById` is a new route that hasn't
    been created yet (we will do so in a moment).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要注意的是`articlesById`是一个尚未创建的新路由（我们将在一会儿创建）。
- en: But why do we need those `$ref` in our articles?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么我们需要在文章中使用`$ref`呢？
- en: In general, you can keep a reference (like a symbolic link in Unix) in many
    places to one object in the database. In our case, it's an article with a certain`_id`
    in the article's collection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以在许多地方保留对数据库中一个对象的引用（就像在Unix中的符号链接）。在我们的情况下，它是文章集合中具有特定`_id`的文章。
- en: When do `$ref` sentinels come in handy? Imagine that in our publishing app's
    model, we add a *recently visited* articles feature and provide the ability to
    like an article (like on Facebook).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ref`哨兵什么时候派上用场？想象一下，在我们的发布应用程序模型中，我们添加了一个*最近访问*文章的功能，并提供了喜欢文章的能力（就像Facebook上的喜欢）。'
- en: 'Based on these two new features, our new model will look as follows (this is
    just an example; don''t code it):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这两个新功能，我们的新模型将如下所示（这只是一个例子；不要编码）：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Based on our preceding example's model, if someone likes an article with ID
    `123456` , we will need to update the model in two places. That's exactly where
    `$ref` comes in handy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的例子模型，如果有人喜欢ID为`123456`的文章，我们需要在两个地方更新模型。这正是`$ref`派上用场的地方。
- en: 读累了记得休息一会哦~
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Improving our articles' numberOfLikes with $ref
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用$ref改进我们文章的喜欢数量
- en: 'Let''s improve our example to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的例子改进为以下内容：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In our new improved `$ref` example, you can find the notation where you need
    to tell Falcor the ID of the article you want to have in `articles` or `recentlyVisitedArticles`
    . Falcor on its own will follow the `$ref` sentinel, knowing the route name (the
    `articlesById` route in this case) and ID of the object we are looking for (in
    our example, `123456` or `987654` ). We will use it in practice in a moment.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新改进的`$ref`示例中，你可以找到需要告诉Falcor你想要在`articles`或`recentlyVisitedArticles`中拥有的文章的ID的表示法。Falcor将自行遵循`$ref`哨兵，知道路由名称（在这种情况下是`articlesById`路由）和我们正在寻找的对象的ID（在我们的例子中是`123456`或`987654`）。我们将在实践中使用它。
- en: Understand that this is a simplified version of how it works, but the best analogy
    to use in order to understand `$ref` is UNIX's symbolic links.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解的是，这是它的简化版本的工作方式，但为了理解`$ref`，最好的类比是UNIX的符号链接。
- en: Practical use of $ref in our project
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们项目中实际使用$ref
- en: Okay, that was a lot of theory--let's start coding! We will improve our Mongoose
    model.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是很多理论--让我们开始编码吧！我们将改进我们的Mongoose模型。
- en: 'Then we''ll add the `$ref` sentinels described before into the `server/routes.js`
    file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将之前描述的`$ref`哨兵添加到`server/routes.js`文件中：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will also add two Falcor routes, `articlesById` and `articles.add` . On the
    frontend, we will make some improvements to `src/layouts/PublishingApp.js` and
    `src/views/articles/AddArticleView.js` .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加两个Falcor路由，`articlesById`和`articles.add`。在前端，我们将改进`src/layouts/PublishingApp.js`和`src/views/articles/AddArticleView.js`。
- en: Let's start the fun.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Mongoose config improvements
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose配置改进
- en: 'First thing we will do is open the Mongoose model at `server/configMongoose.js`
    :'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是打开`server/configMongoose.js`中的Mongoose模型：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll improve it to this version:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它改进为以下版本：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, you''ll find we import `new const Schema = mongoose.Schema`
    . Later, we improve our `articleSchema` with `articleContentJSON: Object` . This
    is required, because the state of draft-js will be kept in a JSON object. This
    will be useful if a user creates an article, saves it to the database, and later
    would like to edit the article. In such a case, we''ll use this `articleContentJSON`
    in order to restore the content state of the draft-js editor.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，你会发现我们导入了`new const Schema = mongoose.Schema`。稍后，我们用`articleContentJSON:
    Object`改进了我们的`articleSchema`。这是必需的，因为draft-js的状态将被保存在一个JSON对象中。如果用户创建一篇文章，将其保存到数据库，然后想要编辑这篇文章，这将非常有用。在这种情况下，我们将使用`articleContentJSON`来恢复draft-js编辑器的内容状态。'
- en: 'The second thing is providing options with `{ minimize: false }` . This is
    required because by default Mongoose gets rid of all empty objects, such as `{
    emptyObject: {}, nonEmptyObject: { test: true } }` , so if `minimize: false` isn''t
    set up then we would get incomplete objects in our database (it''s a very important
    step to have this flag here). There are some draft-js objects that are required,
    but by default are empty (specifically the `entityMap` property of a draft-js
    object).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '第二件事是使用`{ minimize: false }`提供选项。这是必需的，因为默认情况下，Mongoose会清除所有空对象，比如`{ emptyObject:
    {}, nonEmptyObject: { test: true } }`，所以如果没有设置`minimize: false`，我们在数据库中会得到不完整的对象（在这里设置这个标志是非常重要的一步）。有一些draft-js对象是必需的，但默认情况下是空的（特别是draft-js对象的`entityMap`属性）。'
- en: The server/routes.js improvements
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器/routes.js的改进
- en: 'In the `server/routes.js` file, we need to start using the `$ref` sentinel.
    Your import in that file should look as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/routes.js`文件中，我们需要开始使用`$ref`标志。你在那个文件中的导入应该如下所示：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code snippet, the only new thing is that we import `jsonGraph`
    from `'falcor-json-graph';` and then add `let $ref = jsonGraph.ref;` and `let`
    `$atom = jsonGraph.atom` .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，唯一新的东西是我们从`'falcor-json-graph';`导入`jsonGraph`，然后添加`let $ref = jsonGraph.ref;`和`let`
    `$atom = jsonGraph.atom`。
- en: 'We have added the `$ref` sentinel in our `routes.js` scope. We need to prepare
    a new route, `articlesById[{keys}]["_id","articleTitle","articleContent","articleContentJSON"]`
    , as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`routes.js`范围内添加了`$ref`标志。我们需要准备一个新的路由，`articlesById[{keys}]["_id","articleTitle","articleContent","articleContentJSON"]`，如下所示：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `articlesById[{keys}]` route is defined, and the keys are the IDs of the
    request URL that we need to return in the request, as you can see with `const
    articlesIDs = pathSet[1];` .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`articlesById[{keys}]`路由已经定义，键是我们需要在请求中返回的请求URL的ID，就像你在`const articlesIDs =
    pathSet[1];`中看到的那样。'
- en: 'To be more specific regarding `pathSet` , check out this example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要更具体地了解`pathSet`，请查看这个例子：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, the `falcor-router` will follow `articlesById` , and in the `pathSet`
    , you will get this (you can see the exact value of the `pathSet` ):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`falcor-router`将遵循`articlesById`，在`pathSet`中，你将得到这个（你可以看到`pathSet`的确切值）：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The value of the `articlesIDs` from `const articlesIDs = pathSet[1]` `;` you
    can find here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`const articlesIDs = pathSet[1]`中的`articlesIDs`的值可以在这里找到：'
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you will find later, we use this `articlesIDs` value next:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你稍后会发现的，我们接下来使用了这个`articlesIDs`值：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see in `''_id'': { $in: articlesIDs}` , we are passing an array
    of `articlesIDs` . Based on those IDs, we will receive an array of certain articles
    found by IDs (the SQL `WHERE` equivalent). The next step here is iterating over
    received articles:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你在`''_id'': { $in: articlesIDs}`中所看到的，我们正在传递一个`articlesIDs`数组。根据这些ID，我们将收到一组根据ID找到的特定文章的数组（相当于SQL的`WHERE`）。这里的下一步是遍历接收到的文章：'
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Push the object into the `results` array:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象推入`results`数组：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Almost nothing is new in the preceding code snippet. The only new thing is
    this statement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中几乎没有什么新的。唯一新的东西是这个声明：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are explicitly using the `$atom` sentinel from Falcor here: `$atom(articleResObj.articleContentJSON);`
    .'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里明确地使用了Falcor的`$atom`标记：`$atom(articleResObj.articleContentJSON);`。
- en: JSON Graph atoms
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON图原子
- en: The `$atom` sentinel is metadata attached to values, which has to be handled
    differently by the model. You can very simply return a value of a number type
    or a value of a string type with Falcor. It's more tricky for Falcor to return
    an object. Why?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`$atom`标记是附加到值的元数据，必须由模型以不同的方式处理。你可以很简单地返回一个数字类型的值或者一个字符串类型的值给Falcor。对于Falcor来说，返回一个对象就更棘手了。为什么呢？'
- en: Falcor is diffing with heavy usage of JavaScript's objects and arrays, and when
    we tell that an object/array is wrapped by an `$atom` sentinel (such as `$atom(articleResObj.articleContentJSON`
    ) in our example), then Falcor knows that it shouldn't go deeper into that array/object.
    It's made that way by design for performance reasons.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor在大量使用JavaScript的对象和数组进行差异比较，当我们告诉一个对象/数组被`$atom`标记包裹（例如在我们的例子中`$atom(articleResObj.articleContentJSON)`），那么Falcor就知道不应该深入到这个数组/对象中。出于性能原因，它是这样设计的。
- en: 'What performance reasons? For example, if you return an array of 10,000 very
    deep objects without wrapping the array, it may take a very, very long time to
    build and diff the model. Generally, for performance reasons, any objects and
    arrays that you want to return via `falcor-router` to the frontend have to be
    wrapped by an `$atom` before doing so; otherwise, you will get an error like this
    (if you don''t wrap by `$atom` this object):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 性能原因是什么？例如，如果你返回一个包含10,000个非常深的对象的数组而没有包裹这个数组，构建和比较模型可能需要非常非常长的时间。一般来说，出于性能原因，任何你想通过`falcor-router`返回给前端的对象和数组都必须在这样做之前被`$atom`包裹；否则，你会得到这样的错误（如果你没有用`$atom`包裹这个对象的话）：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This error will be shown on the client side while Falcor tries to fetch those
    deeper objects without being wrapped by an `$atom` sentinel beforehand on the
    backend.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误将在客户端显示，当Falcor尝试获取那些没有在后端之前被`$atom`标记包裹的更深层对象时。
- en: Improving the articles[{integers}] route
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`articles[{integers}]`路由
- en: 'We now need to return a `$ref` sentinel to `articlesById` instead of all of
    the articles'' details, so we need to change this old code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要返回一个`$ref`标记给`articlesById`，而不是所有文章的详细信息，所以我们需要改变这段旧代码：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll improve that to this new code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改进为这段新代码：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What has been changed? Look at the route in the old codebase: `articles[{integers}]["_id","articleTitle","articleContent"]`
    . Currently, our `articles[{integers}]` route doesn''t directly return (in the
    new version) the `for["_id","articleTitle","articleContent"]` data, so we had
    to delete it in order to get Falcor know about this fact (the `articlesById` is
    returning detailed information now).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么改变吗？看看旧代码库中的路由：`articles[{integers}]["_id","articleTitle","articleContent"]`。目前，我们的`articles[{integers}]`路由在新版本中并不直接返回`for["_id","articleTitle","articleContent"]`数据，所以我们必须删除它，以便让Falcor知道这个事实（`articlesById`现在返回详细信息）。
- en: 'The next thing that has been changed is that we create a new `$ref` sentinel
    with the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一件改变的事情是我们创建了一个新的`$ref`标记，如下所示：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you see, by doing this, we are informing (with `$ref` ) `falcor-router` that
    if the frontend requests any more information about `article[{integers}]` , then
    the `falcor-router` should follow the `articlesById` route in order to retrieve
    that data from the database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过这样做，我们正在通知（使用`$ref`）`falcor-router`，如果前端请求关于`article[{integers}]`的更多信息，那么`falcor-router`应该跟随`articlesById`路由来从数据库中检索数据。
- en: 'After this, look at this old path''s value:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，查看一下这个旧路径的值：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You''ll find that it has been replaced by the value of `articleRef` :'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现它已经被`articleRef`的值所替代：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can probably spot, in the old version we were returning all of the information
    about an article (the `singleArticleObject` variable), but in the new version
    we return only the `$ref` sentinel`(articleRef)` .
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在旧版本中，我们返回了有关文章的所有信息（`singleArticleObject` 变量），但在新版本中，我们只返回了 `$ref`
    哨兵（`articleRef`）。
- en: The `$ref` sentinels make `falcor-router` automatically follow on the backend,
    so if there are any refs in the first route, Falcor resolves all the `$ref` sentinels
    until it gets all the pending data; after that, it returns the data in a single
    request, which saves a lot of latency (instead of performing several HTTP requests,
    everything followed with `$refs` is fetched in one browser-to-backend call).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ref` 哨兵使 `falcor-router` 在后端自动跟随，因此如果在第一个路由中有任何引用，Falcor 将解析所有 `$ref` 哨兵，直到获取所有待定数据；之后，它以单个请求返回数据，这样可以节省大量的延迟（而不是执行多个
    HTTP 请求，所有跟随 `$refs` 的内容都在浏览器到后端的一次调用中获取）。'
- en: 'New route in server/routes.js: articles.add'
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 server/routes.js 中的新路由：articles.add
- en: 'The only thing left that we need to do is add into the router a new `articles.add`
    route:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要做的就是在路由器中添加一个新的 `articles.add` 路由：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see here, we receive from the frontend a new article''s details
    with `const newArticleObj = args[0];` , and later we create a new `Article` model
    with `var article = new Article(newArticleObj);` . After that, the `article` variable
    has a `.save` method, which is called in the following query. We perform two queries
    that return a promise from Mongoose. Here''s the first:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里所看到的，我们从前端接收了一个新文章的详细信息 `const newArticleObj = args[0];`，然后我们用 `var article
    = new Article(newArticleObj);` 创建了一个新的 `Article` 模型。之后，`article` 变量有一个 `.save`
    方法，在下一个查询中调用。我们执行两个从 Mongoose 返回的 promise 查询。这是第一个：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This `.save` method simply helps us insert the document into the database.
    After we have saved the article, we need to count how many there are in our database,
    so we run a second query:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `.save` 方法简单地帮助我们将文档插入数据库。保存文章后，我们需要计算数据库中有多少文章，因此我们运行第二个查询：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After we have saved the article and counted it, we return that information
    (`return { count, data };` ). The last thing is to return the new article ID and
    the count number from the backend to the frontend with the help of `falcor-router`
    , so we replace this comment:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文章并计数后，我们返回该信息（`return { count, data };`）。最后一件事是将新文章 ID 和计数数字从后端返回到前端，借助 `falcor-router`
    的帮助，因此我们替换这个注释：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In its place, we''ll have this new code that helps us make things happen:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在其位置，我们将有这段新代码，帮助我们实现这些事情：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see in the preceding code snippet, we get the `newArticleDetail`
    details here. Next, we take the new ID with `newArticleID` and make sure that
    it's a string. After all that, we define a new `$ref` sentinel with `let NewArticleRef
    = $ref(['articlesById', newArticleID]);` .
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码片段中所看到的，我们在这里获取了 `newArticleDetail` 的详细信息。接下来，我们用 `newArticleID` 获取新的
    ID，并确保它是一个字符串。在所有这些之后，我们用 `let NewArticleRef = $ref(['articlesById', newArticleID]);`
    定义了一个新的 `$ref` 哨兵。
- en: 'In the `results` variable, you can find three new paths:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `results` 变量中，您可以找到三条新路径：
- en: '`path: [''articles'', res.count-1]` : This path builds up the model, so we
    can have all the information in the Falcor model after we receive the response
    on the client side'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', res.count-1]`：此路径构建模型，因此在客户端接收响应后，我们可以在 Falcor 模型中获取所有信息'
- en: '`path: [''articles'', ''newArticleID'']` : This helps us quickly fetch the
    new ID on the frontend'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', ''newArticleID'']`：这有助于我们快速在前端获取新的 ID'
- en: '`path: [''articles'', ''length'']` : This, of course, updates the length of
    our articles'' collections, so the frontend''s Falcor model can have up-to-date
    information after we have added a new article'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', ''length'']`：当然，这会更新文章集合的长度，因此在添加新文章后，前端的 Falcor 模型可以获得最新的信息'
- en: We just have made a backend route for adding an article. Let's now start working
    on the frontend so that we will be able to push all our new articles into the
    database.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为添加文章创建了一个后端路由。现在让我们开始在前端工作，这样我们就能将所有新文章推送到数据库中。
- en: Frontend changes in order to add articles
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端更改以添加文章
- en: 'In the `src/layouts/PublishingApp.js` file, find this code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/layouts/PublishingApp.js`文件中，找到这段代码：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change it to an improved version with `articleContentJSON` :'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将其改为带有`articleContentJSON`的改进版本：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next step is to improve our `_submitArticle` function in `src/views/articles/AddArticleView.js`
    and add a `falcorModel` import:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进我们在`src/views/articles/AddArticleView.js`中的`_submitArticle`函数，并添加一个`falcorModel`导入：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace this code with the following improved version:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下改进版本替换此代码：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also, at the top of the `AddArticleView.js` file, add this import; otherwise,
    `async_articleSumbit` won''t work:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在`AddArticleView.js`文件的顶部添加此导入；否则，`async_articleSumbit`将无法工作：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we have added the `async` keyword before the function name
    (`async _articleSubmit()` ). The new thing is this request:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在函数名之前添加了`async`关键字（`async _articleSubmit()`）。新的东西是这个请求：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we wait for `falcorModel.call` . In the `.call` arguments, we add `newArticle`
    . Then, after the promise is resolved, we check what the `newArticleID` is with
    the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们等待`falcorModel.call`。在`.call`参数中，我们添加`newArticle`。然后，在承诺解决后，我们检查`newArticleID`是什么，如下所示：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Later, we simply use exactly the same stuff as in the old version:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们简单地使用与旧版本完全相同的东西：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This simply pushes the updated `newArticle` with a real ID from MongoDB via
    the `articleActions` into the article's reducer. We also use `setState` with the
    `newArticleID` so you can see that the new article has been created correctly
    with a real Mongo ID.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过`articleActions`将更新的`newArticle`与来自MongoDB的真实ID推送到文章的reducer中。我们还使用`setState`与`newArticleID`，这样你就可以看到新文章已经正确地使用真实的Mongo
    ID创建了。
- en: Important note about route returns
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于路由返回的重要说明
- en: 'You should be aware that in every route, we return an object or an array of
    an object; both approaches are fine even with one route to return. Take this,
    for example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，在每个路由中，我们返回一个对象或一个对象数组；即使只有一个路由返回，这两种方法都可以。例如：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This can also return an array with one object, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以返回一个包含一个对象的数组，如下所示：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, even with one `articles.length` , we are returning an array
    (instead of a single object), and this will also work.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使只有一个`articles.length`，我们也返回一个数组（而不是单个对象），这也可以工作。
- en: 'For the same reason as described previously, this is why, in `articlesById`
    , we have pushed multiple routes into the array:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 出于先前描述的同样原因，这就是为什么在`articlesById`中，我们将多个路由推送到数组中的原因：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is one thing that may be worth mentioning in the Falcor chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Falcor章节中值得一提的一件事。
- en: Full-stack - editing and deleting an article
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈 - 编辑和删除文章
- en: 'Let''s create a route in the `server/routes.js` file for updating an existing
    document (edit feature):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`server/routes.js`文件中创建一个用于更新现有文档（编辑功能）的路由：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see here, we still use the `article.save` approach similar to the
    `articles.add` route. The important thing to note is that Mongoose requires the
    `isNew` flag to be `false` (`article.isNew = false;` ). If you don''t give this
    flag, then you will get a Mongoose error similar to this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里所看到的，我们仍然使用`article.save`方法，类似于`articles.add`路由。需要注意的重要事情是，Mongoose要求`isNew`标志为`false`（`article.isNew
    = false;`）。如果你不给出这个标志，那么你将会得到一个类似于这样的Mongoose错误：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rest of the code is quite simple; we save the article''s model and then
    return the updated model via `falcor-router` with the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码非常简单；我们保存文章的模型，然后通过`falcor-router`返回更新后的模型，如下所示：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The new thing is the `invalidate` flag. As it states in the documentation, "invalidate
    method synchronously removes several Paths or PathSets from a Model cache." In
    other words, you need to tell the Falcor model on the frontend that something
    has been changed in the `["articlesById", articleID]` path so that you will have
    synced data on both backend and frontend.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 新的东西是`invalidate`标志。正如文档中所述，“invalidate方法同步从模型缓存中移除多个路径或路径集。”换句话说，您需要告诉前端的Falcor模型，在`["articlesById",
    articleID]`路径中有些东西已经改变，这样您就可以在后端和前端都有同步的数据。
- en: For more stuff about `invalidate` in Falcor, you can go to [https://netflix.github.io/falcor/doc/Model.html#invalidate](https://netflix.github.io/falcor/doc/Model.html#invalidate)
    .
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Falcor中的`invalidate`更多内容，您可以访问[https://netflix.github.io/falcor/doc/Model.html#invalidate](https://netflix.github.io/falcor/doc/Model.html#invalidate)。
- en: Deleting an article
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文章
- en: 'In order to implement the `delete` feature, we need to create a new route:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`delete`功能，我们需要创建一个新的路由：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This also uses `invalidate` , but this time, this is the only thing that we
    return here, as the document has been deleted, so the only thing we need to do
    is to inform the browser's cache that the old article has been invalidated and
    there is nothing to replace it as in the update example.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使用了`invalidate`，但这次，这是我们在这里返回的唯一内容，因为文档已被删除，所以我们需要做的唯一事情就是通知浏览器缓存旧文章已被作废，没有任何需要替换的内容，就像更新示例中一样。
- en: 读累了记得休息一会哦~
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Frontend - edit and delete
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端-编辑和删除
- en: 'We have implemented the `update` and `delete` routes on the backend. Next,
    in the `src/views/articles/EditArticleView.js` file, you need to find this code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在后端实现了`update`和`delete`路由。接下来，在`src/views/articles/EditArticleView.js`文件中，您需要找到这段代码：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace it with this `async _articleEditSubmit` function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为这个`async _articleEditSubmit`函数：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see here, the most important thing is that we implemented the `.call`
    function in the `_articleEditSubmit` function that sends details of an edited
    object with the `editedArticle` variable.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里所看到的，最重要的是我们在`_articleEditSubmit`函数中实现了`.call`函数，该函数使用`editedArticle`变量发送编辑对象的详细信息。
- en: 'In the same file, find the `_handleDeletion` method:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，找到`_handleDeletion`方法：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Change it to the new improved version:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为新的改进版本：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Similar to the deletion, the only difference is that we only send `articleID`
    of a deleted article with `.call` .
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与删除类似，唯一的区别是我们只用`.call`发送了被删除文章的`articleID`。
- en: Securing the CRUD routes
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护CRUD路由
- en: 'We need to implement a way to secure all add/edit/delete routes and also make
    a universal **DRY** (**don''t repeat yourself** ) way of informing the user of
    errors that occurred on the backend. For example, errors that may occur on the
    frontend, and we need to inform the user with an error message in our React instance''s
    client-side app:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一种方式来保护所有添加/编辑/删除路由，并且还要以一种通用的**DRY**（**不要重复自己**）的方式通知用户后端发生的错误。例如，在前端可能发生的错误，我们需要在React实例的客户端应用程序中用错误消息通知用户：
- en: '**Auth error** : You are not authorized to perform the action'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证错误**：您无权执行该操作'
- en: '**Timeout error** : For example, you use an external API''s service; we need
    to inform the user of any potential errors'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时错误**：例如，您使用外部API的服务；我们需要通知用户任何潜在的错误'
- en: '**Data doesn''t exist** : There may be a case where a user will call for the
    ID of an article that doesn''t exist in our DB, so let''s inform him'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不存在**：可能会有一种情况，用户会调用我们数据库中不存在的文章的ID，所以让我们通知他'
- en: In general, our goal for now is to create one universal way of moving all potential
    error messages on the backend to the client side so that we can improve the general
    experience of using our application.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们目前的目标是创建一种通用的方式，将后端的所有潜在错误消息传递到客户端，以便我们可以改善使用我们应用程序的一般体验。
- en: The $error sentinel basics
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $error 哨兵基础知识
- en: There is the `$error` sentinel (variable type related to Falcor), which is generally
    an approach to returning errors.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`$error`哨兵（与Falcor相关的变量类型），通常是返回错误的一种方法。
- en: 'Generally, as you should already know, Falcor batches requests. Thanks to them,
    you can fetch data from different falcor-routes in one HTTP request. The following
    example is what you can fetch in one go:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，正如你应该已经知道的那样，Falcor会批量处理请求。由于这些请求，你可以在一个HTTP请求中从不同的falcor-routes获取数据。以下示例是你可以一次性获取的内容：
- en: '**One dataset** : Complete and ready to retrieve'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个数据集**：完整且准备好检索'
- en: '**Second dataset** : Second dataset, may contain an error'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个数据集**：第二个数据集，可能包含错误'
- en: We don't want to influence the fetching process of one dataset when there is
    an error in the second dataset (you need to remember that the two datasets from
    our example are fetched in one request).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个数据集中存在错误时，我们不希望影响一个数据集的获取过程（需要记住，我们示例中的两个数据集是在一个请求中获取的）。
- en: 'Useful parts from the documentation that may help you understand error handling
    in Falcor are available here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中可能有助于您了解Falcor中错误处理的有用部分在这里：
- en: '[https://netflix.github.io/falcor/doc/Model.html#~errorSelector](https://netflix.github.io/falcor/doc/Model.html#~errorSelector)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://netflix.github.io/falcor/doc/Model.html#~errorSelector](https://netflix.github.io/falcor/doc/Model.html#~errorSelector)'
- en: '[https://netflix.github.io/falcor/documentation/model.html#error-handling](https://netflix.github.io/falcor/documentation/model.html#error-handling)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://netflix.github.io/falcor/documentation/model.html#error-handling](https://netflix.github.io/falcor/documentation/model.html#error-handling)'
- en: '[http://netflix.github.io/falcor/documentation/router.html](http://netflix.github.io/falcor/documentation/router.html)
    (search for `$error` on this page to find more examples from the documentation)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://netflix.github.io/falcor/documentation/router.html](http://netflix.github.io/falcor/documentation/router.html)（在此页面上搜索`$error`以查找文档中更多示例）'
- en: DRY error management on the client side
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端上实现DRY错误管理
- en: 'Let''s start with improvements to the CoreLayout (`src/layouts/CoreLayout.js`
    ). Under `AppBar` , import a new `snackbar` component with this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对CoreLayout（`src/layouts/CoreLayout.js`）的改进开始。在`AppBar`下，导入一个新的`snackbar`组件：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, under the imports, outside the CoreLayout, create a new function and
    export it:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在导入之外的CoreLayout下，创建一个新的函数并导出它：
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then find the `CoreLayout` constructor to change it to use the exported function
    called `errorFuncUtil` as a callback in the base in case of an error returned
    by the Falcor `$error` sentinel:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后找到`CoreLayout`构造函数，将其更改为在基本情况下使用导出的名为`errorFuncUtil`的函数作为回调，以处理Falcor`$error`哨兵返回的错误：
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here''s the new one:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的：
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can find here, we have introduced a new `errorValue` state (the default
    state is `null` ). Then, on the frontend only (because of `if(typeof window !==
    'undefined')` ), we assign `this.handleErrors.bind(this)` to our `errorFuncUtil`
    .
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里找到的那样，我们引入了一个新的`errorValue`状态（默认状态为`null`）。然后，仅在前端（因为`if(typeof window
    !== 'undefined'`），我们将`this.handleErrors.bind(this)`分配给我们的`errorFuncUtil`。
- en: As you will find in a moment, this is so because the exported `errorFuncUtil`
    will be imported in our `falcorModel.js` , where we will use the best possible
    DRY way to inform our CoreLayout about any error occurring on the backend with
    Falcor. The great thing about this is that we will implement it just once, but
    it will be a universal way of informing our client-side app users of any errors
    (and it will also save us development effort in the future, as any error will
    be handled by the approach that we are implementing now).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在一会儿发现的那样，这是因为导出的`errorFuncUtil`将在我们的`falcorModel.js`中导入，我们将以最佳的DRY方式通知我们的CoreLayout有关Falcor后端发生的任何错误。这样做的好处是我们只需实现一次，但它将是通知我们客户端应用用户任何错误的通用方式（并且还将节省我们将来的开发工作，因为任何错误都将由我们现在正在实现的方法处理）。
- en: 'We need to add a new function to our CoreLayout called `handleFalcorErrors`
    :'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的CoreLayout添加一个名为`handleFalcorErrors`的新函数：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `handleFalcorErrors` function is setting the new state of our error. We
    will compose our error for the user with an `errMsg` (we create this on the backend,
    as you will learn in a moment) and the `errPath` (optional, but this is the `falcor-route`
    path where the error has occurred).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleFalcorErrors`函数正在设置我们错误的新状态。我们将为用户组合我们的错误与`errMsg`（我们将在后端创建这个，您一会儿会了解）和`errPath`（可选的，但这是发生错误的`falcor-route`路径）。'
- en: 'Okay, we have everything in place; the only thing missing from the `CoreLayout`
    function is the improved render. The new render of the CoreLayout is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备就绪；`CoreLayout`函数唯一缺少的是改进后的渲染。CoreLayout的新渲染如下：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you can find here, the new parts are related to the Material-UI `snackbar`
    component. Take a look at this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里找到的那样，新部分与Material-UI的`snackbar`组件相关。看一下这个：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code snippet is preparing our `erroSnackbarJSX` and the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段正在准备我们的`erroSnackbarJSX`和以下内容：
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Make sure `{errorSnackbarJSX}` is placed exactly the same way as in this example.
    Otherwise, you may find some problems during the app's test run. You now have
    completed everything related to the CoreLayout improvements.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`{errorSnackbarJSX}`放置在与此示例完全相同的位置。否则，在应用程序的测试运行过程中可能会遇到一些问题。您现在已经完成了与CoreLayout改进相关的所有工作。
- en: Tweaks - FalcorModel.js on the frontend
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 - 前端的FalcorModel.js
- en: 'In the `src/falcorModel.js` file, identify the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/falcorModel.js`文件中，识别以下代码：
- en: '[PRE69]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This code has to be improved by adding a new option to the `falcor.Model` :'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码必须通过向`falcor.Model`添加一个新选项来改进：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first thing we added is an import of `errorFunc` to the top of that file:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一件事是将`errorFunc`导入到该文件的顶部：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Besides `errorFunc` , we have introduced the `falcorOptions` variable. The source
    stays the same as in the previous version. We have added `errorSelector` , which
    is run every time the client side calls the backend and the `falcor-router` on
    the backend returns an `$error` sentinel.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`errorFunc`，我们还引入了`falcorOptions`变量。源代码与上一个版本相同。我们添加了`errorSelector`，每当客户端调用后端并且后端的`falcor-router`返回`$error`
    sentinel时都会运行它。
- en: More details on the error selector can be found at [https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value](https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value)
    .
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有关错误选择器的更多详细信息，请访问[https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value](https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value)。
- en: Backend implementation of the $error sentinel
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $error sentinel的后端实现
- en: 'We will perform the backend implementation in two steps:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步执行后端实现：
- en: An error example, just to test our client-side code.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个错误示例，只是为了测试我们的客户端代码。
- en: After we are sure that the error handling is working correctly, we will secure
    the endpoints properly.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们确保错误处理工作正常之后，我们将适当地保护端点。
- en: Testing our $error-related code
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们与$error相关的代码
- en: 'Let''s start with imports in the `server/routes.js` file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`server/routes.js`文件中的导入开始：
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The only new thing is that you need to import the `$error` sentinel from `falcor-json-graph`
    .
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新内容是你需要从`falcor-json-graph`中导入`$error`标记。
- en: The goal of our `$error` test is to replace a working route that is responsible
    for fetching articles `(articles[{integers}])` . After we break this route, we
    will be able to test whether our frontend and backend setup is working. After
    we test the errors (refer to the next screenshot), we will delete this breaking
    `$error` code from `articles[{integers}]` . Read on for details.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`$error`测试的目标是替换一个负责获取文章的工作路由`(articles[{integers}])`。在我们破坏这个路由之后，我们将能够测试我们的前端和后端设置是否正常工作。在我们测试错误之后（参考下一个截图），我们将从`articles[{integers}]`中删除这个破坏性的`$error`代码。继续阅读以获取详细信息。
- en: 'Test it with the `article` route:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用`article`路由进行测试：
- en: '[PRE73]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, this is only a test. We will improve this code in a moment,
    but let's test whether the text in the `$error('auth error')` sentinel will be
    shown to the user.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这只是一个测试。我们将在稍后改进这段代码，但让我们测试一下`$error('auth error')`中的文本是否会显示给用户。
- en: 'Run MongoDB:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 运行MongoDB：
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, run the server in another terminal:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中运行服务器：
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After you run both these, point your browser to `http://localhost:3000` , and
    you will see for this error for 8 seconds:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这两个命令后，将你的浏览器指向`http://localhost:3000`，你将在8秒内看到这个错误：
- en: '![](Image00048.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00048.jpg)'
- en: 'As you can see, there is white text on a black background in the bottom of
    the window:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在窗口底部有黑色背景上的白色文本：
- en: '![](Image00049.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00049.jpg)'
- en: If you run the app, and on the main page you see the error message as on the
    screenshot, then it tells you that you are good!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用，在主页上看到与截图上相同的错误消息，那么它告诉你一切都很好！
- en: Cleaning up $error after a successful test
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在成功测试后清理$error
- en: 'After you are sure that the error handling is working for you, you can replace
    the old code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确信错误处理对你起作用时，你可以替换旧代码：
- en: '[PRE76]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Change it to the following, without error returning:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容，不返回错误：
- en: '[PRE77]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now, the app will start working normally without throwing an error when you
    try to fetch an article from the backend.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你尝试从后端获取文章时，应用将正常工作而不会抛出错误。
- en: Wrapping up the routes' security
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束路由的安全性
- en: 'We''ve already implemented some logic in `server/routes.js` that checks whether
    a user is authorized, with the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`server/routes.js`中实现了一些逻辑，用于检查用户是否被授权，具体如下：
- en: '[PRE78]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this code, you will find that we can create the following logic in the beginning
    of each role that requires authorization and the editor role:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你会发现我们可以在每个需要授权和编辑者角色的开头创建以下逻辑：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see here, this is only an example (don't change it yet; we will implement
    it in a moment), with `path['HERE_GOES_THE_REAL_FALCOR_PATH']` .
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里所看到的，这只是一个例子（暂时不要更改它；我们将在稍后实现它），使用`path['HERE_GOES_THE_REAL_FALCOR_PATH']`。
- en: 'First, we check whether a user is authorized at all with `isAuthorized ===
    false` ; if not authorized, he will see an error (with the universal error mechanism
    that we just implemented):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查用户是否被授权，使用`isAuthorized === false`；如果未被授权，他将看到一个错误（使用我们刚刚实现的通用错误机制）：
- en: '![](Image00050.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00050.jpg)'
- en: 'In future, we may have more roles in our publishing app, so in case someone
    isn''t an editor, then he will see the following in the error:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，我们的发布应用可能会有更多的角色，所以如果有人不是编辑者，那么他将在错误中看到以下内容：
- en: '![](Image00051.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00051.jpg)'
- en: What routes to secure
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要保护的路由
- en: 'For routes (`server/routes.js` ) that require authorization in our application''s
    articles, add the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要在我们应用的文章中进行授权的路由（`server/routes.js`），添加以下内容：
- en: '[PRE80]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the old code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是旧代码：
- en: '[PRE81]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The new code with `auth` checks is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`auth`检查的新代码如下：
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can find here, we have added two checks with `isAuthorized === false`
    and role `!== 'editor'` . The following routes content will be almost the same
    (just the path changes a little).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里找到的，我们已经添加了两个带有`isAuthorized === false`和`role !== 'editor'`的检查。以下路由内容几乎相同（只是路径有些变化）。
- en: 'Here is the `articles` update:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`articles`的更新：
- en: '[PRE83]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is the old code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是旧代码：
- en: '[PRE84]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The new code with the `auth` checks is as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`auth`检查的新代码如下：
- en: '[PRE85]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Find this old code:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这段旧代码：
- en: '[PRE86]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Replace it with this new code with the `auth` checks:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 用带有`auth`检查的新代码替换它：
- en: '[PRE87]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As you can see, the returns are almost the same--we can lower the code duplication.
    We can make a helper function for them so there will be less code, but you need
    to remember that you need to set a path similar to the one that you request when
    returning an error. For example, if you are on `articles.update` , then you need
    return an error in the article's path (or if you are on `XYZ.update` , then the
    error goes to the `XYZ` path).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，返回几乎相同--我们可以减少代码重复。我们可以为它们制作一个辅助函数，这样代码就会更少，但你需要记住，当返回错误时，你需要设置一个类似于你请求的路径。例如，如果你在`articles.update`上，那么你需要在文章路径上返回一个错误（或者如果你在`XYZ.update`上，那么错误就会到`XYZ`路径）。
- en: In the next chapter, we will implement AWS S3 in order to have the ability to
    upload articles' cover photos. Besides that, we will generally improve our publishing
    application with new features.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现AWS S3，以便能够上传文章封面照片。除此之外，我们还将通过新功能来一般改进我们的发布应用程序。
- en: 读累了记得休息一会哦~
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 公众号：古德猫宁李
- en: 电子书搜索下载
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 网站：沉金书屋 https://www.chenjin5.com
- en: 电子书搜索下载
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
