- en: Advanced Redux and Falcor on the Client Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端上的高级Redux和Falcor
- en: Redux is our app's state container which keeps the information about how the
    React view layer shall render in the browser. On the other hand, Falcor differs
    from Redux, because it is the full-stack toolset that replaces the outdated approach
    of API endpoints data communication. In the next pages, we will work with Falcor
    on the client side, but you need to remember that Factor is a full-stack library.
    That means, we need to use it on both sides (where on backend we use an additional
    library called Falcor-Router). Starting from [Chapter 5](text00140.html) , *Falcor
    Advanced Concepts* , we will work with full-stack Falcor. While in the current
    chapter, we will focus only on the client side.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是我们应用的状态容器，它保存了关于React视图层在浏览器中如何渲染的信息。另一方面，Falcor与Redux不同，因为它是替代了过时的API端点数据通信方法的全栈工具集。在接下来的页面中，我们将在客户端使用Falcor，但你需要记住Factor是一个全栈库。这意味着我们需要在两端使用它（在后端我们使用一个名为Falcor-Router的额外库）。从[第5章](text00140.html)，*Falcor高级概念*开始，我们将使用全栈Falcor。而在当前章节中，我们将只专注于客户端。
- en: Focusing on the app's frontend
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专注于应用的前端
- en: Currently, our app is a simple starter kit, which is a skeleton for its further
    development. We need to focus more on the customer-facing frontend because it's
    important to have a good-looking frontend in the current age. Thanks to Material
    UI, we can reuse many things to make our app look prettier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用是一个简单的起始套件，是其进一步开发的基础。我们需要更多地专注于面向客户的前端，因为在当前时代拥有一个外观良好的前端非常重要。由于Material
    UI，我们可以重用许多东西来使我们的应用看起来更漂亮。
- en: It's important to note that responsive web design is not in the scope of this
    book at this point (and overall), so you need to find out how all the styles can
    be improved for mobile. The app we are going to work on will look fine on tablets,
    but small mobile screens may not look so good.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，响应式网页设计在这本书中（以及总体上）并不在范围内，因此你需要找出如何改进所有样式以适应移动设备。我们将要处理的应用在平板上看起来很好，但小屏幕的手机可能看起来不太好。
- en: 'In this chapter, we will focus our efforts on the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于以下工作：
- en: Unmocking `fetchServerSide.js`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消对`fetchServerSide.js`的模拟
- en: Adding a new `ArticleCard` component, which will make our main page more professional
    for our users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的`ArticleCard`组件，这将使我们的主页对我们的用户更专业
- en: Improving the general look of our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善我们应用的整体外观
- en: Implementing the ability to logout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现注销的功能
- en: Adding a WYSIWYG editor in `Draft.js` which is a rich text-editor framework
    for React created by the Facebook team
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Draft.js`中添加所见即所得的编辑器，这是由Facebook团队为React创建的富文本编辑框架
- en: Adding the ability to create new articles in our Redux frontend application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Redux前端应用程序中添加创建新文章的功能
- en: Backend wrap-up before frontend improvement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端改进之前的后端总结
- en: In the previous chapter, we performed a server-side rendering that will affect
    our users such that they will see their articles quicker and will improve our
    website's SEO as the whole HTML markup is being rendered on the server side.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们进行了服务器端渲染，这将影响我们的用户，使他们能更快地看到他们的文章，并且将改善我们网站的SEO，因为整个HTML标记都是在服务器端渲染的。
- en: 'The last thing to make our server-side rendering work 100% is to unmock the
    server-side article fetching in `/server/fetchServerSide.js` . The new code for
    fetching is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的服务器端渲染百分之百生效的最后一件事是取消在`/server/fetchServerSide.js`中对服务器端文章获取的模拟。获取的新代码如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can find in the preceding code snippet, this function returns a promise
    with `Article.find` (the `find` function comes from Mongoose). You can also find
    that we are returning an array of articles that are fetched from our MongoDB.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码片段中找到的，这个函数返回一个带有`Article.find`的promise（`find`函数来自Mongoose）。你还可以发现我们正在返回从我们的MongoDB中获取的文章数组。
- en: Improving handleServerSideRender
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`handleServerSideRender`
- en: 'The next step is to tweak the `handleServerSideRender` function, which is currently
    kept in the `/server/server.js` file. The current function is as shown in the
    following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是调整`handleServerSideRender`函数，它目前保存在`/server/server.js`文件中。当前的函数如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to replace it with this improved one:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用这个改进后的替换它：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is new in our improved `handleServerSideRender` ? As you can see, we have
    added `async await` . Recall that it is helping us make our code less painful
    with asynchronous calls such as queries to the database (synchronous-looking generator-style
    code). This ES7 feature helps us write asynchronous calls as if they're synchronous
    ones--under the hood, `async await` is much more complicated (after it's transpiled
    into ES5 so that it can be run in any modern browser), but we won't get into details
    of how `async await` works because it's not in the scope of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改进的`handleServerSideRender`中有什么新东西？正如你所看到的，我们添加了`async await`。回想一下，它帮助我们使我们的代码在异步调用（如对数据库的查询）方面变得不那么痛苦（类似生成器风格的同步代码）。这个ES7特性帮助我们编写异步调用，就好像它们是同步调用一样——在幕后，`async
    await`要复杂得多（在转换为ES5后，它可以在任何现代浏览器中运行），但我们不会详细介绍`async await`的工作原理，因为它不在本章的范围内。
- en: Changing routes in Falcor (frontend and backend)
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Falcor中更改路由（前端和后端）
- en: You also need to change the two ID variable names to `_id` (`_id` is a default
    name for the ID of a document in a Mongo collection).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将两个ID变量名称更改为`_id`（`_id`是Mongo集合中文档的ID的默认名称）。
- en: 'Look in `server/routes.js` for this old code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/routes.js`中查找这段旧代码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Change it into the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only change is that we will return `_id` instead of `id` . We need to fetch
    the `_id` value in `src/layouts/PublishingApp.js` , so find the following code
    snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是我们将返回`_id`而不是`id`。我们需要在`src/layouts/PublishingApp.js`中获取`_id`的值，所以找到以下代码片段：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change it into the new one with `_id` :'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为新的带有`_id`的组件：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our website header and articles list need improvements
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的网站标题和文章列表需要改进
- en: Since we've finished wrapping up the server-side rendering and fetching articles
    from the DB, let's start with the frontend.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们完成了服务器端渲染和从数据库中获取文章的工作之后，让我们从前端开始。
- en: 'First, delete the following header from `server/server.js` ; we don''t need
    it anymore:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`server/server.js`中删除以下标题；我们不再需要它：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also delete this header in `src/layouts/PublishingApp.js` :'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以删除`src/layouts/PublishingApp.js`中的此标题：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Delete the `h1` markup in the registration and login view (`src/LoginView.js`
    ):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 删除注册和登录视图（`src/LoginView.js`）中的`h1`标记：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Delete registration in `src/RegisterView.js` :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`src/RegisterView.js`中的注册：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All these `h1` lines are not needed as we want to have a nice-looking design
    instead of an outdated one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`h1`行都不需要，因为我们希望拥有一个漂亮的设计，而不是一个过时的设计。
- en: 'After this, go to `src/CoreLayout.js` and import a new `AppBar` component and
    two button components from the Material UI:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`src/CoreLayout.js`，并从Material UI导入一个新的`AppBar`组件和两个按钮组件：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add this `AppBar` together with inline styles into `render` :'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将此`AppBar`与内联样式添加到`render`中：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have added the inline styles for `buttonStyle` and `homeIconStyle` . The
    `menuLinksJSX` and `homePageButtonJSX` ''s visual output will improve. This is
    how your app will be looking after those `AppBar` changes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`buttonStyle`和`homeIconStyle`添加了内联样式。`menuLinksJSX`和`homePageButtonJSX`的视觉输出将会改善。在这些`AppBar`更改之后，您的应用程序将如何看起来：
- en: '![](Image00029.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00029.jpg)'
- en: New ArticleCard component
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的ArticleCard组件
- en: 'The next step in order to improve the look of our home page is to make article
    cards based on the Material Design CSS as well. Let''s create a component''s file
    first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善我们主页的外观，下一步是基于Material Design CSS制作文章卡。让我们首先创建一个组件文件：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in the `ArticleCard.js` file, let''s initialize the `ArticleCard` component
    with the following content:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ArticleCard.js`文件中，让我们用以下内容初始化`ArticleCard`组件：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can find in the preceding code, we have imported the required components
    from material-ui/card that will help our home page''s articles list look nice.
    The next step is to improve our article card''s `render` function with the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所找到的，我们已经从material-ui/card中导入了所需的组件，这将帮助我们的主页文章列表看起来很好。下一步是改进我们文章卡的`render`函数如下：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can find in the preceding code, we have created an article card, and
    there are some inline styles for the `Paper` component and left and right `div`
    . Feel free to change the styles if you want.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所找到的，我们已经创建了一张文章卡，并为`Paper`组件和左右`div`添加了一些内联样式。如果您愿意，可以随意更改样式。
- en: 'In general, we are missing two static images in the previous `render` function,
    which are `src= ''/static/placeholder.png''` and `avatar=''/static/avatar.png''`
    . Let''s add them using the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在以前的`render`函数中，我们缺少两个静态图像，即`src='/static/placeholder.png'`和`avatar='/static/avatar.png'`。让我们按照以下步骤添加它们：
- en: 'Make a PNG file with the name `placeholder.png` in the `dist` directory. In
    my case, this is what my `placeholder.png` file looks like:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dist`目录中制作一个名为`placeholder.png`的PNG文件。在我的情况下，我的`placeholder.png`文件如下所示：
- en: '![](Image00030.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00030.jpg)'
- en: Also create an `avatar.png` file in the `dist` directory that will be exposed
    in `/static/avatar.png` . I am not providing the screenshot here, as it has my
    personal photo in it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在`dist`目录中创建一个`avatar.png`文件，将在`/static/avatar.png`中公开。我不会在这里提供截图，因为里面有我的个人照片。
- en: The `/static/` file in `express.js` is exposed in the `/server/server.js` file
    with `codeapp.use('/static', express.static('dist'));` (you will already have
    it in there as we have added this in the previous chapter).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.js`中的`/static/`文件在`/server/server.js`文件中通过`codeapp.use(''/static'',
    express.static(''dist''));`暴露出来（您已经在那里添加了这个，因为我们在上一章中已经添加了这个）。'
- en: The last thing is that you need to import `ArticleCard` and modify the render
    of `layouts/PublishingApp.js` from the old simple view to the new one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事是，您需要导入`ArticleCard`并将`layouts/PublishingApp.js`的渲染从旧的简单视图修改为新的视图。
- en: 'Add `import` to the top of the file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加`import`：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, replace the render with this new one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用这个新的渲染替换：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding new code only differs in this new `ArticleCard` component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的新代码只在这个新的`ArticleCard`组件中有所不同：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also have added some styles to `div style={{height: ''100%'', width: ''75%'',
    margin: ''auto''}}` .'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还为`div style={{height: ''100%'', width: ''75%'', margin: ''auto''}}`添加了一些样式。'
- en: 'On following all these steps exactly in terms of styles, this is what you will
    see:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照样式的确切步骤后，您将看到以下内容：
- en: '![](Image00031.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00031.jpg)'
- en: 'This is the register user view:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注册用户视图：
- en: '![](Image00032.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00032.jpg)'
- en: 'This is the login user view:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是登录用户视图：
- en: '![](Image00033.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00033.jpg)'
- en: Dashboard - adding an article button, logout, and header improvements
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板 - 添加文章按钮，注销和标题改进
- en: Our plan for now is to create a logout mechanism, make our header aware whether
    a user is logged in or not, and based on that information show different buttons
    in the header (Login /Register when a user is not logged in and Dashboard /Logout
    when a user is logged in) We will create an Add Article button in our dashboard
    and create a mocked view with a mocked WYSIWYG (we will unmock it later).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前的计划是创建注销机制，使我们的标题栏知道用户是否已登录，并根据该信息在标题栏中显示不同的按钮（当用户未登录时显示登录/注册，当用户已登录时显示仪表板/注销）。我们将在仪表板中创建一个添加文章按钮，并创建一个模拟视图和模拟WYSIWYG（稍后我们将取消模拟）。
- en: '**WYSIWYG** stands for **what you see is what you get** , of course.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**WYSIWYG**代表**所见即所得**，当然。'
- en: 'The WYSIWYG mockup will be located in `src/components/articles/WYSIWYGeditor.js`
    , so you need to create a new directory and file in `components` with the following
    commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: WYSIWYG模拟将位于`src/components/articles/WYSIWYGeditor.js`，因此您需要使用以下命令在`components`中创建一个新目录和文件：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then our `WYSIWYGeditor.js` mock content will be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的`WYSIWYGeditor.js`模拟内容将如下所示：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to create a logout view at `src/views/LogoutView.js` :'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`src/views/LogoutView.js`中创建一个注销视图。
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `src/views/LogoutView.js` file''s content is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/views/LogoutView.js`文件的内容如下：'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `logout` view mentioned here is a simple view without a connecting function
    to Redux (in comparison with `LoginView.js` ). We are using some styling to make
    it nice, with the `Paper` component from Material UI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此处提到的`logout`视图是一个简单的视图，没有与Redux连接的功能（与`LoginView.js`相比）。我们使用一些样式使其美观，使用了Material
    UI的`Paper`组件。
- en: The `componentWillMount` function is deleted from the `localStorage` information
    when the user lands on the logout page. As you can see, it also checks whether
    there is `localStorage` with `**if(typeof localStorage !== 'undefined' && localStorage.token)
    **` because, as you can imagine, when you perform server-side rendering, `localStorage`
    is undefined (the server side doesn't have `localStorage` and `window` like the
    client side).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登陆到注销页面时，`componentWillMount`函数会从`localStorage`信息中删除。正如您所看到的，它还检查是否有`localStorage`和`**if(typeof
    localStorage !== 'undefined' && localStorage.token)**`，因为您可以想象，当执行服务器端渲染时，`localStorage`是未定义的（服务器端没有`localStorage`和`window`，像客户端一样）。
- en: Important note before creating a frontend add article feature
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在创建前端添加文章功能之前的重要说明
- en: We've come to the point where you need to delete all documents from your articles
    collection, or you may have some trouble performing the next steps as we are going
    to use a draft-js library and some other stuff that will need a new schema on
    the backend. We will create that backend's schema in the next chapter as this
    chapter is focused on the frontend.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了需要从文章集合中删除所有文档的地步，否则在执行下一步时可能会遇到一些麻烦，因为我们将使用draft-js库和一些其他需要在后端创建新模式的东西。我们将在下一章中创建后端的模式，因为本章重点是前端。
- en: Delete all documents in your MongoDB articles collection right now, but keep
    the user collection as it was (don't delete users from the database).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 立即删除MongoDB文章集合中的所有文档，但保留用户集合（不要从数据库中删除用户）。
- en: The AddArticleView component
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddArticleView组件
- en: 'After creating the `LogoutView` and the `WYSIWYGeditor` components, let''s
    create the final missing component in our process: the `src/views/articles/AddArticleView.js`
    file. So let''s create a directory and file now:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`LogoutView`和`WYSIWYGeditor`组件后，让我们创建我们流程中缺失的最终组件：`src/views/articles/AddArticleView.js`文件。因此，让我们现在创建一个目录和文件：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As a result, you''ll have that file in your `views/articles` directory. We
    need to put content into it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将在`views/articles`目录中拥有该文件。我们需要将内容放入其中：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see here, it's a simple React view, and it imports the `WYSIWYGeditor`
    component that we created a moment ago (`import WYSIWYGeditor from '../../components/articles/WYSIWYGeditor.js'`
    ). We have some inline styles in order to make the view look nicer for our user.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，这是一个简单的React视图，并且导入了我们刚刚创建的`WYSIWYGeditor`组件（`import WYSIWYGeditor
    from '../../components/articles/WYSIWYGeditor.js'`）。我们有一些内联样式，以使视图对我们的用户看起来更好。
- en: 'Let''s create two new routes for a logout and for an add article feature by
    modifying the `routes` file at the `**src/routes/index.js*` location:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改`src/routes/index.js`位置的`routes`文件来创建注销和添加文章功能的两个新路由：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As explained in our `src/routes/index.js` file, we have added two routes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的`src/routes/index.js`文件中所解释的，我们添加了两个路由：
- en: '`<Route component={LogoutView} path=''logout'' name=''logout'' />`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Route component={LogoutView} path=''logout'' name=''logout'' />`'
- en: '`<Route component={AddArticleView} path=''add-article'' name=''add-article''
    />`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Route component={AddArticleView} path=''add-article'' name=''add-article''
    />`'
- en: 'Don''t forget to import those two views'' components with the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用以下方式导入这两个视图的组件：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we have created the views and created routes into that view. The last piece
    is to show links into those two routes in our app.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了视图并在该视图中创建了路由。最后一件事是在我们的应用程序中显示这两个路由的链接。
- en: 'First let''s create the `src/layouts/CoreLayout.js` component so it will have
    a login/logout-type login so that a logged-in user will see different buttons
    than a user who isn''t. Modify the `render` function in the `CoreLayout` component
    to this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们创建`src/layouts/CoreLayout.js`组件，这样它将具有登录/注销类型的登录，以便已登录用户将看到与未登录用户不同的按钮。将`CoreLayout`组件中的`render`函数修改为以下内容：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can see that the new part in the preceding code is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到前面代码中的新部分如下：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have added `let userIsLoggedIn = typeof localStorage !== 'undefined' && localStorage.token
    && this.props.routes[1].name !== 'logout';` . The `userIsLoggedIn` variable is
    found if we are not on the server side (then it doesn't have `localStorage` as
    mentioned earlier). Then, it checks whether `localStorage.token` is `yes` , and
    also checks whether a user didn't click on the logout button with the `this.props.routes[1].name
    !== 'logout'` expression. The `this.props.routes[1].name` value/information is
    provided by the `redux-simple-router` and `react-router` . This is always the
    name of our current route on the client side, so we can render the proper buttons
    based on that information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了`let userIsLoggedIn = typeof localStorage !== 'undefined' && localStorage.token
    && this.props.routes[1].name !== 'logout';`。如果我们不在服务器端（那么就没有`localStorage`，如前所述），则会找到`userIsLoggedIn`变量。然后，它检查`localStorage.token`是否为`yes`，还检查用户是否没有点击注销按钮，使用`this.props.routes[1].name
    !== 'logout'`表达式。`this.props.routes[1].name`的值/信息由`redux-simple-router`和`react-router`提供。这始终是我们当前路由的名称，因此我们可以根据该信息渲染适当的按钮。
- en: Modifying DashboardView
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改DashboardView
- en: As you will find, we have added the `if (userIsLoggedIn)` statement, and the
    new part is the dashboard and logout `RaisedButton` entities with links to the
    correct routes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你会发现的，我们添加了`if (userIsLoggedIn)`语句，新部分是仪表板和注销`RaisedButton`实体，链接到正确的路由。
- en: 'The last piece to finish at this stage is to modify the `src/views/DashboardView.js`
    component. Add link to the `/add-article` route using the `{Link}` component imported
    from react-router . Also, we need to import new Material UI components in order
    to make `DashboardView` nicer:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段完成的最后一件事是修改`src/views/DashboardView.js`组件。使用从react-router导入的`{Link}`组件添加到`/add-article`路由的链接。此外，我们需要导入新的Material
    UI组件，以使`DashboardView`更加美观：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After you have imported all this in your `src/views/DashboardView.js` file,
    then we need to start work on improving the `render` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`src/views/DashboardView.js`文件中导入了所有这些之后，我们需要开始改进`render`函数：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we have our new `render` function for `DashboardView` . We are using the
    `ListItem` component to make our nice lists. We have also added the link and button
    to the `/add-article` routes. There are some inline styles, but feel free to style
    this app on your own.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的`DashboardView`的新`render`函数。我们使用`ListItem`组件来制作我们漂亮的列表。我们还添加了链接和按钮到`/add-article`路由。有一些内联样式，但请随意自行设计此应用程序的样式。
- en: 'Let''s look at a few screenshots of how the app looks after all these changes
    after adding the CREATE AN ARTICLE button with a new view of articles:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在添加了创建文章按钮并具有新的文章视图后，应用程序经过所有这些更改后的一些屏幕截图：
- en: '![](Image00034.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00034.jpg)'
- en: 'After having mocked WYSIWYG on the `/add-article` view:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/add-article`视图上模拟了WYSIWYG之后：
- en: '![](Image00035.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00035.jpg)'
- en: 'Our new logout view page will look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新注销视图页面将是这样的：
- en: '![](Image00036.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00036.jpg)'
- en: 读累了记得休息一会哦~
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Starting work on our WYSIWYG
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始我们的WYSIWYG工作
- en: Let's install a draft-js library, which is "a framework for building rich text
    editors in React, powered by an immutable model and abstracting over cross-browser
    differences," as stated on their website.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装一个draft-js库，它是“一个在React中构建富文本编辑器的框架，由不可变模型驱动，并抽象了跨浏览器的差异”，正如他们网站上所述。
- en: In general, draft-js is made by friends from Facebook, and it helps us make
    powerful WYSIWYG tools. It will be useful in our publishing app as we want to
    provide good tools for our editors in order to create interesting articles on
    our platform.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，draft-js是由Facebook的朋友们制作的，它帮助我们制作强大的所见即所得工具。在我们的发布应用程序中，它将是有用的，因为我们希望为我们的编辑提供良好的工具，以便在我们的平台上创建有趣的文章。
- en: 'Let''s install it first:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装它：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will use version 0.5.0 of draft-js in our book. Before we start coding,
    let''s install one more dependency that will be helpful later in fetching the
    articles from the DB via Falcor. Execute the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的书中使用0.5.0版本的draft-js。在开始编码之前，让我们安装另一个有用的依赖项，以后在通过Falcor从数据库中获取文章时会有帮助。执行以下命令：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In general, the `falcor-json-graph@1.1.7` syntax provides us with the ability
    to use different sentinels provided via the Falcor helper library (which will
    be described in detail in the next chapter).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`falcor-json-graph@1.1.7`语法为我们提供了使用Falcor辅助库提供的不同sentinels的能力（这将在下一章节中详细描述）。
- en: Stylesheet for the draft-js WYSIWYG
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: draft-js所需的样式表
- en: 'In order to style draft-js editor, we need to create a new CSS file in the
    `dist` folder located at `dist/styles-draft-js.css` . It''s the only place where
    we will put a CSS stylesheet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给draft-js编辑器设置样式，我们需要在`dist`文件夹中创建一个新的CSS文件，位于`dist/styles-draft-js.css`。这是我们唯一会放置CSS样式表的地方：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After you have created this file at `dist/styles-draft-js.css` , we need to
    import it to `server/server.js` , where we have been creating the HTML header,
    so the following code is already present in the `server.js` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了位于`dist/styles-draft-js.css`的文件后，我们需要将其导入到`server/server.js`中，我们已经在`server.js`文件中创建了HTML头部，因此以下代码已经存在于`server.js`文件中：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then you need to include the link to the stylesheet with this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要包含以下链接到样式表：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Nothing fancy so far. After we are done with the styles for our rich text WYSIWYG
    editor, let's have some fun.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止还没有什么花里胡哨的。在为我们的富文本WYSIWYG编辑器设置样式之后，让我们来点乐趣。
- en: Coding a draft-js skeleton
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写draft-js骨架
- en: Let's get back to the `src/components/articles/WYSIWYGeditor.js` file. It's
    currently mocked, but we will improve it now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`src/components/articles/WYSIWYGeditor.js`文件。它目前是模拟的，但我们现在将对其进行改进。
- en: Just to make you aware, we will make a skeleton of the WYSIWYG right now. We
    will improve it later in the book. At this point, the WYSIWYG won't have any functionalities
    such as making text bold or creating lists with OL and UL elements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 只是让您知道，我们现在将制作所见即所得的骨架。我们稍后会在书中进行改进。在这一点上，所见即所得不会有任何功能，比如加粗文本或创建带有OL和UL元素的列表。
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have created only a constructor of our new draft-js file's WYSIWYG.
    The `let initialEditorFromProps = EditorState.createWithContent(ContentState.createFromText(''));`
    expression is simply creating an empty WYSIWYG container. Later, we will improve
    it so we are able to receive `ContentState` from the database when we would like
    to edit our WYSIWYG.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只创建了一个新的draft-js文件的所见即所得编辑器的构造函数。`let initialEditorFromProps = EditorState.createWithContent(ContentState.createFromText(''));`表达式只是创建了一个空的所见即所得容器。稍后，我们将改进它，以便在需要编辑所见即所得时能够从数据库接收`ContentState`。
- en: 'The `editorState: initialEditorFromProps` is our current state. Our `**this.onChange
    = (editorState) => { **` line is firing on each change, so our view component
    at `src/views/articles/AddArticleView.js` will know about any changes in the WYSIWYG.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`editorState: initialEditorFromProps`是我们当前的状态。我们的`**this.onChange = (editorState)
    => { **`行在每次更改时触发，因此我们的视图组件在`src/views/articles/AddArticleView.js`将了解所见即所得中的任何更改。'
- en: Anyway, you can check the documentation of draft-js at [https://facebook.github.io/draft-js/](https://facebook.github.io/draft-js/)
    .
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，您可以在[https://facebook.github.io/draft-js/](https://facebook.github.io/draft-js/)查看draft-js的文档。
- en: 'This is just the beginning; the next step is to add two new functions under
    `onChange` :'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个开始；下一步是在`onChange`下添加两个新函数：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And add a new function in our `WYSIWYGeditor` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的`WYSIWYGeditor`类中添加一个新函数：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After all these changes, this is how your construction of the `WYSIWYGeditor`
    class should look:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更改之后，`WYSIWYGeditor`类的构造应如下所示：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And the rest of this class is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的其余部分如下：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to improve the `render` function with the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下代码改进`render`函数：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, what we have done is simply use the draft-js API in order to make a simple
    rich editor; later, we will make it more functional, but for now, let's focus
    on something simple.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们所做的只是简单地使用draft-js API来制作一个简单的富文本编辑器；稍后，我们将使其更加功能强大，但现在，让我们专注于简单的东西。
- en: Improving the views/articles/AddArticleView component
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进views/articles/AddArticleView组件
- en: 'Before we move forward with adding all the WYSIWYG features, such as bolding,
    we need to improve the `views/articles/AddArticleView.js` component with a few
    things. Install a library that will convert the draft-js state into plain HTML
    with the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续添加所有所见即所得功能，比如加粗之前，我们需要改进`views/articles/AddArticleView.js`组件，添加一些东西。使用以下内容安装一个将draft-js状态转换为纯HTML的库：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will use this library to save read-only plain HTML for our regular readers.
    Next, import this into `src/views/articles/AddArticleView.js` :'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个库来保存只读的纯HTML，供我们的常规读者使用。接下来，将其导入到`src/views/articles/AddArticleView.js`中：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Improve `AddArticleView` by changing a constructor and adding a new function
    called `_onDraftJSChange` :'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改构造函数并添加一个名为`_onDraftJSChange`的新函数来改进`AddArticleView`：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to save on each change a state of `this.setState({contentJSON, htmlContent});`
    . This is because `contentJSON` will be saved into the database in order to have
    immutable information about our WYSIWYG and `htmlContent` will be the server for
    our readers. Both `htmlContent` and `contentJSON` variables will be kept in the
    articles collection. The last thing in the `AddArticleView` class is to modify
    `render` to new code, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次更改时保存`this.setState({contentJSON, htmlContent});`的状态。这是因为`contentJSON`将被保存到数据库中，以便对我们的WYSIWYG具有不可变的信息，而`htmlContent`将成为我们的读者的服务器。`htmlContent`和`contentJSON`变量将保存在文章集合中。`AddArticleView`类中的最后一件事是将`render`修改为以下新代码：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After all these changes, the new view that you will see is this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些变化，您将看到的新视图是这样的：
- en: '![](Image00037.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00037.jpg)'
- en: Adding more formatting features to our WYSIWYG
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的WYSIWYG添加更多格式功能
- en: 'Let''s start working on version two of our WYSIWYG, with more options, as in
    the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始着手开发我们的WYSIWYG的第二个版本，增加更多选项，如下例所示：
- en: '![](Image00038.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00038.jpg)'
- en: After you follow the steps mentioned here, you will be able to format your text
    as follows and extract the HTML markup from it as well so that we can save both
    the JSON state of our WYSIWYG and plain HTML in our MongoDB articles collection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在您按照这里提到的步骤后，您将能够格式化您的文本，并从中提取HTML标记，以便我们可以在我们的MongoDB文章集合中保存WYSIWYG的JSON状态和纯HTML。
- en: 'In the following new file, called `WYSIWYGbuttons.js` , we will export two
    different classes, and we will import them into `components/articles/WYSWIWYGeditor.js`
    using the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个名为`WYSIWYGbuttons.js`的新文件中，我们将导出两个不同的类，并将它们导入到`components/articles/WYSWIWYGeditor.js`中，使用以下内容：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In general, that new file will have three different React components, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，新文件将有三个不同的React组件，如下所示：
- en: '`StyleButton` : This will be a generic-style button that will be used in both
    `BlockStyleControls` and `InlineStyleControls` . Don''t get confused by the fact
    that in the `WYSIWYGbuttons` file, you are creating the `StyleButton` React component
    first.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StyleButton`：这将是一个通用样式的按钮，将用于`BlockStyleControls`和`InlineStyleControls`。不要被`WYSIWYGbuttons`文件中首先创建`StyleButton`
    React组件的事实所困惑。'
- en: '`BlockStyleControls` : This is an exported component, which will be used for
    block controls such as `H1` , `H2` , `Blockquote` , `UL` , and `OL` .'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockStyleControls`：这是一个导出的组件，将用于块控件，如`H1`、`H2`、`Blockquote`、`UL`和`OL`。'
- en: '`InlineStyleControls` : This component is used for bold, italics, and underline.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InlineStyleControls`：此组件用于粗体、斜体和下划线。'
- en: Now we are aware that in the new file, you will create three separate React
    components.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道在新文件中，您将创建三个单独的React组件。
- en: 'First, we need to create the WYSWIG buttons in the `src/components/articles/wysiwyg/WYSIWYGbuttons.js`
    location:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`src/components/articles/wysiwyg/WYSIWYGbuttons.js`位置创建WYSWIG按钮：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The content of this file will be the buttons component:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的内容将是按钮组件：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code is giving us a reusable button with a certain label at `this.props.label`
    . As mentioned before, don't get confused with `WYSIWYGbuttons` ; it's a generic
    button component that will be reused in the inline and block type button controls.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为我们提供了一个可重用的按钮，具有`this.props.label`中的特定标签。如前所述，不要与`WYSIWYGbuttons`混淆；它是一个通用按钮组件，将在内联和块类型按钮控件中重复使用。
- en: 'Next, under that component, you can put the following object:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在该组件下，您可以放置以下对象：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This object is block type, which we can create in our draft-js WYSIWYG. It
    is used in the following component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象是块类型的，我们可以在我们的draft-js WYSIWYG中创建它。它用在以下组件中：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding code is a whole bunch of buttons for block-style formatting. We
    will import them into `WYSIWYGeditor` in a while. As you can see, we are exporting
    it with `export const BlockStyleControls = (props) => {` .
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一大堆用于块级样式格式化的按钮。我们将很快将它们导入到`WYSIWYGeditor`中。正如您所看到的，我们使用`export const
    BlockStyleControls = (props) => {`导出它。
- en: 'Put the next object under the `BlockStyleControls` component, but this time,
    for inline styles such as `Bold` :'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将下一个对象放在`BlockStyleControls`组件下面，但这次是用于内联样式，比如`Bold`：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, in our WYSIWYG, an editor will be able to use bold, italics,
    and underline.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在我们的WYSIWYG中，编辑器将能够使用粗体、斜体和下划线。
- en: 'The last component for those inline styles that you can put under all this
    is the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用于放置所有这些内联样式的最后一个组件是以下内容：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, this is very simple. We are mapping the defined styles in the
    blocks and inline styles each time, and based on each iteration, we are creating
    `StyleButton` .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这非常简单。我们每次都在块和内联样式中映射定义的样式，并且根据每次迭代，我们都创建`StyleButton`。
- en: 'The next step is to import both `InlineStyleControls` and `BlockStyleControls`
    in our `WYSIWYGeditor` component (`src/components/articles/WYSIWYGeditor.js` ):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们的`WYSIWYGeditor`组件（`src/components/articles/WYSIWYGeditor.js`）中导入`InlineStyleControls`和`BlockStyleControls`：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, in the `WYSIWYGeditor` constructor, include the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`WYSIWYGeditor`构造函数中，包括以下代码：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Bind to `toggleInlineStyle` and `toggleBlockType` two arrow functions, which
    will be the callbacks when someone chooses the toggle in order to use inline or
    block type in our `WYSIWYGeditor` (we will create those functions in a moment).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将`toggleInlineStyle`和`toggleBlockType`绑定到两个箭头函数，当有人选择切换以在我们的`WYSIWYGeditor`中使用内联或块类型时，这些函数将成为回调（我们将在一会儿创建这些函数）。
- en: 'Create these two new functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这两个新函数：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, both functions are using the draft-js `RichUtils` in order to set flags
    inside our WYSIWYG. We are using certain formatting options from `BLOCK_TYPES`
    and `INLINE_STYLES` that we have defined in the `import { BlockStyleControls,
    InlineStyleControls }` from `'./wysiwg/WYSIWGbuttons';` .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这两个函数都使用draft-js`RichUtils`来在我们的WYSIWYG中设置标志。我们正在使用我们在`import { BlockStyleControls,
    InlineStyleControls }`中定义的`BLOCK_TYPES`和`INLINE_STYLES`中的某些格式选项，从`'./wysiwg/WYSIWGbuttons'`导入。
- en: 'After we are done improving our `WYSIWYGeditor` construction and the `_toggleBlockType`
    and `_toggleInlineStyle` functions, then we can start improving our `render` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们改进了`WYSIWYGeditor`的构造和`_toggleBlockType`和`_toggleInlineStyle`函数之后，我们可以开始改进我们的`render`函数：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you may notice, in the preceding code, we have only added the `BlockStyleControls`
    and `InlineStyleControls` component. Also notice that we are using callbacks with
    `onToggle={this.toggleBlockType}` and `onToggle={this.toggleInlineStyle}` ; this
    is for communicating between our `WYSIWYGbuttons` and the draft-js `RichUtils`
    about what a user has clicked on and in which mode they are currently using (such
    as bold, header1, and UL or OL).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能注意到的，在前面的代码中，我们只添加了`BlockStyleControls`和`InlineStyleControls`组件。还要注意我们在`onToggle={this.toggleBlockType}`和`onToggle={this.toggleInlineStyle}`中使用回调；这是为了在我们的`WYSIWYGbuttons`和draft-js`RichUtils`之间进行通信，告诉它用户点击了什么，以及他们当前使用的模式（如粗体、标题1、UL或OL）。
- en: Pushing a new article into article reducer
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新文章推送到文章reducer
- en: 'We need to create a new action called `pushNewArticle` in the `src/actions/article.js`
    location:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`src/actions/article.js`位置创建一个名为`pushNewArticle`的新操作：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next step is to improve the `src/components/ArticleCard.js` component by
    improving the `render` function in it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过改进`src/components/ArticleCard.js`组件中的`render`函数来改进它：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, we have replaced the old `{content}` variable (which was receiving a
    plain text value in the content''s variable) to a new one that shows all of the
    HTML using `dangerouslySetInnerHTML` in the article card:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将旧的`{content}`变量（它在content的变量中接收了一个纯文本值）替换为一个新的变量，它使用`dangerouslySetInnerHTML`在文章卡中显示所有的HTML：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will help us show our readers the HTML code generated by our WYSIWYG.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们展示由我们的所见即所得编辑器生成的HTML代码。
- en: MapHelpers for improving our reducers
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MapHelpers用于改进我们的reducers
- en: 'In general, all reducers *must* return a new reference to an object when it
    has changed. In our first example, we used `Object.assign` :'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，所有的reducers在改变时*必须*返回一个新的对象引用。在我们的第一个例子中，我们使用了`Object.assign`：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will replace this `Object.assign` approach with a new one, with ES6''s Maps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ES6的Map来替换这种`Object.assign`方法：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code, you can find a new `ARTICLES_LIST_ADD` with `mapHelpers.addMultipleItems(state,
    articlesList)` .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以找到一个新的`ARTICLES_LIST_ADD`，其中包括`mapHelpers.addMultipleItems(state,
    articlesList)`。
- en: 'In order to make our map helpers, we need to create a new directory called
    `utils` and a file called `mapHelpers.js(src/utils/mapHelpers.js)` :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作我们的地图助手，我们需要创建一个名为`utils`的新目录和一个名为`mapHelpers.js(src/utils/mapHelpers.js)`的文件：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And then, you can enter this first function into that `src/utils/mapHelpers.js`
    file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将这个第一个函数输入到`src/utils/mapHelpers.js`文件中：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The duplicate simply creates a new reference in memory in order to make our
    immutability a requirement in Redux applications. We also are checking, with `if(key
    === item['_id'])` , whether there is an edge case that the key is different from
    our object ID (the `_` in `_id` is intentional as this is how Mongoose marks the
    ID from our DB).The `addMultipleItems` function adds items to the new duplicated
    map (for example, after a successful fetch of articles).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重复只是在内存中创建一个新的引用，以使我们的不可变性成为Redux应用程序中的要求。我们还在检查`if(key === item['_id'])`时，是否存在一个特殊情况，即键与我们的对象ID不同（`_id`中的`_`是有意的，因为这是Mongoose如何标记我们的DB中的ID）。`addMultipleItems`函数将项目添加到新的重复地图中（例如，在成功获取文章后）。
- en: 'The next code change that we require is in the same file at `src/utils/mapHelpers.js`
    :'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个代码更改在相同的文件`src/utils/mapHelpers.js`中：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, we have added an `add` function and `delete` function for a
    single item. After that, we are exporting all that from `src/utils/mapHelpers.js`
    .
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们添加了一个`add`函数和一个`delete`函数用于单个项目。之后，我们从`src/utils/mapHelpers.js`中导出所有这些。
- en: 'The next step is that we need to improve the `src/reducers/article.js` reducer
    in order to use the map utilities in it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是，我们需要改进`src/reducers/article.js` reducer，以便在其中使用地图实用程序：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What's new in the `src/reducers/article.js` file? As you can see, we have improved
    `ARTICLES_LIST_ADD` (already discussed). We have added a new `PUSH_NEW_ARTICLE`
    ; case; this will push a new object into our reducer's state tree. It's similar
    to pushing an item to an array, but we use our reducer and maps instead.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/reducers/article.js`文件中有什么新内容？正如您所看到的，我们已经改进了`ARTICLES_LIST_ADD`（已经讨论过）。我们添加了一个新的`PUSH_NEW_ARTICLE`；情况；这将向我们的reducer状态树中推送一个新对象。这类似于将项目推送到数组中，但我们使用我们的reducer和maps。'
- en: The CoreLayout improvements
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreLayout的改进
- en: 'Because we are switching to the ES6''s Map in the frontend, we also need to
    make sure that after we receive an object with server-side rendering, it is also
    a Map (not a plain JS object). Check out the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在前端切换到了ES6的Map，所以我们还需要确保在接收到具有服务器端渲染的对象后，它也是一个Map（而不是一个普通的JS对象）。请查看以下代码：
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the following new code snippet, you can find all the imports required in
    the `CoreLayout` component:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下新的代码片段中，您可以找到`CoreLayout`组件中所需的所有导入：
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Above the `CoreLayout` component, we have added the Redux tools, so we will
    have a state tree and the actions available in the `CoreLayout` component.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CoreLayout`组件上面，我们已经添加了Redux工具，所以我们将在`CoreLayout`组件中拥有状态树和可用的操作。
- en: 'Also, in the `CoreLayout` component, add the `componentWillMount` function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`CoreLayout`组件中，添加`componentWillMount`函数：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This function is responsible for checking whether an article's properties are
    an ES6 Map or not. If not, then we send an action to `articlesList` that makes
    the job done, and after that, we have maps in `this.props.article` .
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责检查文章属性是否为ES6 Map。如果不是，那么我们发送一个操作到`articlesList`来完成工作，之后，我们在`this.props.article`中就有了Map。
- en: 'The last thing is to improve `export` in the `CoreLayout` component:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事是改进`CoreLayout`组件中的`export`：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code helps us connect to the Redux single-state tree and the actions
    it allows.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码帮助我们连接到Redux单状态树和它允许的操作。
- en: Why Maps over a JS object?
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Map而不是JS对象？
- en: In general, an ES6 Map has some features for easy data manipulation---functions
    such as `.get` and `.set` which make programming more pleasurable. It also helps
    to have a simpler code to be able to keep our immutability as required by Redux.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，ES6 Map具有一些易于数据操作的功能---诸如`.get`和`.set`等函数，使编程更加愉快。它还有助于拥有更简单的代码，以便保持Redux所需的不可变性。
- en: Map methods are much easier to use than `slice/c-oncat/Object.assign` . I am
    sure that there are always some cons/pros to each approach, but in our app, we
    will use an ES6 Map-wise approach in order to keep things simpler after we are
    completely set up with it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Map方法比`slice/c-oncat/Object.assign`要容易得多。我相信每种方法都有利弊，但在我们的应用中，我们将使用ES6 Map-wise方法来使事情变得更简单。
- en: Improving PublishingApp and DashboardView
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进PublishingApp和DashboardView
- en: 'In the `src/layouts/PublishingApp.js` file, we need to improve our `render`
    function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/layouts/PublishingApp.js`文件中，我们需要改进我们的`render`函数：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see in the preceding code, we switched the old `for(let articleKey
    in this.props.article) {` code into `this.props.article.forEach` because we have
    switched from objects to using Maps.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们将旧的`for(let articleKey in this.props.article) {`代码切换为`this.props.article.forEach`，因为我们已经从对象切换到使用Map。
- en: 'We need to do the same in the `src/views/DashboardView.js` file''s `render`
    function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`src/views/DashboardView.js`文件的`render`函数中做同样的事情：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For the same reason as in the `PublishingApp` component, we switched to using
    ES6''s new Map, and we will be also using the new ES6 `forEach` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 出于与`PublishingApp`组件相同的原因，我们切换到使用ES6的新Map，并且我们还将使用新的ES6 `forEach`方法：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Tweaks to AddArticleView
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对AddArticleView进行调整
- en: 'After we are finished preparing our app to save a new article into the article''s
    reducer, we need to tweak the `src/views/articles/AddArticleView.js` component.
    New imports in the `AddArticleView.js` are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备好将新文章保存到文章的reducer中之后，我们需要调整`src/views/articles/AddArticleView.js`组件。`AddArticleView.js`中的新导入如下：
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see in the preceding code, we are importing `RaisedButton` and `Link`
    , which will be useful for redirecting an editor to the dashboard's view after
    a successful article addition. Then, we import `articleActions` because we need
    to make the `this.props.articleActions.pushNewArticle(newArticle);` action on
    article submit. The `bindActionCreators` will already be imported in your `AddArticleView`
    if you followed instructions from previous chapters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们正在导入`RaisedButton`和`Link`，这对于在成功添加文章后将编辑器重定向到仪表板视图非常有用。然后，我们导入`articleActions`，因为我们需要在文章提交时执行`this.props.articleActions.pushNewArticle(newArticle);`操作。如果您遵循了前几章的说明，`bindActionCreators`将已经在您的`AddArticleView`中导入。
- en: 'Use `bindActionCreators` in order to have `articleActions` in the `AddArticleView`
    component by replacing this code snippet:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过替换这段代码，在`AddArticleView`组件中使用`bindActionCreators`来拥有`articleActions`：
- en: '[PRE74]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is the new `bindActionCreators` code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`bindActionCreators`代码：
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following is an updated constructor of the `AddArticleView` component:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AddArticleView`组件的更新构造函数：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `_articleSubmit` method will be required after an editor wants to add an
    article. We have also added some default states for our title, `contentJSON` (we
    will keep the draft-js article state there), `htmlContent` , and the `newArticleID`
    . The next step is to create the `_articleSubmit` function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑者想要添加文章之后，将需要`_articleSubmit`方法。我们还为我们的标题、`contentJSON`（我们将在那里保留draft-js文章状态）、`htmlContent`和`newArticleID`添加了一些默认状态。下一步是创建`_articleSubmit`函数：
- en: '[PRE77]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As you can see here, we get the state of our current writing with `this.state.title`
    , `this.state.htmlContent` , and `this.state.contentJSON` , and based on that,
    we then create a `newArticle` model:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们使用`this.state.title`、`this.state.htmlContent`和`this.state.contentJSON`获取我们当前写作的状态，然后基于此创建一个`newArticle`模型：
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then we mock the new article''s ID (later, we will save it to the DB) with
    `newArticle[''_id''] = newArticleID;` and push it into our article''s reducer
    with `this.props.articleActions.pushNewArticle(newArticle);` . The only thing
    is to set up `newarticleID` with `this.setState({ newArticleID: newArticleID});`
    . The last step is to update our `render` method in the `AddArticleView` component:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们用`newArticle[''_id''] = newArticleID;`模拟新文章的ID（稍后，我们将把它保存到数据库中），并用`this.props.articleActions.pushNewArticle(newArticle);`将其推入我们的文章reducer中。唯一的事情是用`this.setState({
    newArticleID: newArticleID});`设置`newarticleID`。最后一步是更新`AddArticleView`组件中的`render`方法：'
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here in the `render` method, we have one statement that checks whether an article's
    editor has already created an article (clicked on the Submit Article button) with
    `if(this.state.newArticleID)` . If yes, then the editor will see his new article's
    ID and a button that links to the dashboard (link is `to='/dashboard'` ).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们有一个语句来检查文章编辑者是否已经创建了一篇文章（点击了提交文章按钮）`if(this.state.newArticleID)`。如果是，编辑者将看到他的新文章ID和一个链接到仪表板的按钮（链接是`to='/dashboard'`）。
- en: The second return is in case an editor is in edit mode; if yes, then he can
    submit it by clicking on the `RaisedButton` component with the `onClick` method's
    called `_articleSubmit` .
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个返回是在编辑模式下；如果是，那么他可以通过点击`RaisedButton`组件并调用`onClick`方法的`_articleSubmit`来提交。
- en: 读累了记得休息一会哦~
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: The ability to edit an article (the EditArticleView component)
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑文章的能力（EditArticleView组件）
- en: We can add an article, but we can't edit it yet. Let's implement that feature.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加文章，但还不能编辑。让我们实现这个功能。
- en: 'The first thing to do is to create a route in `src/routes/index.js` :'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在`src/routes/index.js`中创建一个路由：
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then edit the routes:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编辑路由：
- en: '[PRE81]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As you can see, we have added the `EditArticleViews` route with `path='/edit-article/:articleID'`
    ; as you should know already, the `articleID` will be sent to us with props as
    `this.props.params.articleID` (this is a default feature of `redux-router` ).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，我们已经添加了`EditArticleViews`路由，路径为`path=''/edit-article/:articleID''`；正如你已经知道的，`articleID`将作为`this.props.params.articleID`的props发送给我们（这是`redux-router`的默认功能）。 '
- en: 'The next step is to create the `src/views/articles/EditArticleView.js` component,
    which is a new component (mocked for now):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`src/views/articles/EditArticleView.js`组件，这是一个新组件（目前是模拟的）：
- en: '[PRE82]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, you can find a standard view component with a `render` function that returns
    a mock (we will improve it later). We have already put all the required imports
    in place (we will use all of them in the next iteration of the `EditArticleView`
    component).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到一个带有`render`函数的标准视图组件，它返回一个模拟（我们稍后会对其进行改进）。我们已经放置了所有必需的导入（我们将在`EditArticleView`组件的下一个迭代中使用它们）。
- en: Let's add a dashboard link to an article's edition
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们在文章的版本中添加一个仪表板链接
- en: 'Make a small tweak in `src/views/DashboardView.js` :'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/views/DashboardView.js`中进行小的调整：
- en: '[PRE83]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, we have two things that need to be changed: adding a `Link` attribute
    to `to={/edit-article/${articleDetails[''_id'']}` . This will redirect a user
    to the article''s edition view after clicking on `ListItem` . We also need to
    give a `Link` element a unique key property.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两件事需要改变：向`to={/edit-article/${articleDetails['_id']}`添加一个`Link`属性。这将在点击`ListItem`后将用户重定向到文章的编辑视图。我们还需要给`Link`元素一个唯一的key属性。
- en: Creating a new action and reducer
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的操作和减速器
- en: 'Modify the `src/actions/article.js` file and add this new action called `EDIT_ARTICLE`
    :'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`src/actions/article.js`文件并添加名为`EDIT_ARTICLE`的新操作：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The next step is to improve our reducer at `src/reducers/article.js` :'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进我们在`src/reducers/article.js`中的减速器：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can find here, we have added a new `switch` case for `EDIT_ARTICLE` .
    We use our `mapHelpers.addItem` ; in general, if `_id` does exist in Map, then
    it replaces a value (this works great for editing actions).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里找到的那样，我们为`EDIT_ARTICLE`添加了一个新的`switch` case。我们使用我们的`mapHelpers.addItem`；一般来说，如果`_id`存在于Map中，那么它将替换一个值（这对编辑操作非常有效）。
- en: Edit mode in src/components/articles/WYSIWYGeditor.js
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在src/components/articles/WYSIWYGeditor.js中的编辑模式
- en: 'Let''s now implement the ability to use the edit mode in our `WYSIWYGeditor`
    components by improving our construction in the `WYSIWYGeditor.js` file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过改进`WYSIWYGeditor.js`文件中的构造来实现在我们的`WYSIWYGeditor`组件中使用编辑模式的能力：
- en: '[PRE86]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here you can find out how your constructor will look after making changes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找出在进行更改后您的构造函数将是什么样子。
- en: As you already know, draft-js is required to be an object, so we check in the
    first `if` statement whether it is one. Then, if not, we put an empty WYSIWYG
    as default (check `if(typeof props.initialValue === 'undefined' || typeof props.initialValue
    !== 'object'))` .
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，draft-js需要是一个对象，所以我们在第一个`if`语句中检查它是否是一个对象。然后，如果不是，我们将空的所见即所得作为默认值（检查`if(typeof
    props.initialValue === 'undefined' || typeof props.initialValue !== 'object'))`。
- en: 'In the `else` statement, we put the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`语句中，我们放置了以下内容：
- en: '[PRE87]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here we check whether we have a valid draft-js JSON object; if not, we need
    to throw a critical error and return, because otherwise, the error can crash the
    whole browser (we need to handle that edge case with `withif(isInvalidObject))`
    .
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查是否有一个有效的draft-js JSON对象；如果没有，我们需要抛出一个严重的错误并返回，因为否则，错误可能会导致整个浏览器崩溃（我们需要用`withif(isInvalidObject)`处理这种边缘情况）。
- en: After we have a valid object, we recover the state of our WYSIWYG editor with
    the use of the `convertFromRaw` , `ContentState.createFromBlockArray` , and `EditorState.createWithContent`
    functions provided by the draft-js library.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有一个有效的对象之后，我们使用draft-js库提供的`convertFromRaw`，`ContentState.createFromBlockArray`和`EditorState.createWithContent`函数来恢复我们的所见即所得编辑器的状态。
- en: Improvements in EditArticleView
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在EditArticleView中的改进
- en: 'The last improvement before finishing the article edit mode is improving `src/views/articles/EditArticleView.js`
    :'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成文章编辑模式之前的最后一个改进是改进`src/views/articles/EditArticleView.js`：
- en: '[PRE88]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is our constructor; we will have some states variables such as `articleFetchError`
    , `articleEditSuccess` , `editedArticleID` , `articleDetails` , `title` , `contentJSON`
    , and `htmlContent` .
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的构造函数；我们将有一些状态变量，如`articleFetchError`，`articleEditSuccess`，`editedArticleID`，`articleDetails`，`title`，`contentJSON`和`htmlContent`。
- en: In general, all these variables are self-explanatory. Regarding the `articleDetails`
    variable here, we will keep the whole object fetched from a `reducer/mongoDB`
    . Things such as `title` , `contentHTML` , and `contentJSON` are kept in the `articleDetails`
    state (as you will find in a moment).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有这些变量都是不言自明的。关于这里的 `articleDetails` 变量，我们将保留从 `reducer/mongoDB` 获取的整个对象。诸如
    `title`、`contentHTML` 和 `contentJSON` 等内容都保存在 `articleDetails` 状态中（您一会儿会发现）。
- en: 'After you are done with the `EditArticleView` constructor, add some new functions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 `EditArticleView` 构造函数后，添加一些新函数：
- en: '[PRE89]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'On `componentWillMount` , we will fetch data about the article with `_fetchArticleData`
    . The `_fetchArticleData` is getting the article''s ID from props via `react-redux`
    (`let articleID = this.props.params.articleID;` ). Then, we check whether we are
    not on the server side with `if(typeof window !== ''undefined'' && articleID)`
    . After this, we use the `.get` Map function in order to get details from a reducer
    (`let articleDetails = this.props.article.get(articleID);` ), and based on the
    case, we set the state of our component with the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `componentWillMount` 中，我们将使用 `_fetchArticleData` 获取有关文章的数据。`_fetchArticleData`
    通过 `react-redux` 从 props 中获取文章的 ID（`let articleID = this.props.params.articleID;`）。然后，我们检查是否不在服务器端（`if(typeof
    window !== 'undefined' && articleID)`）。之后，我们使用 `.get` Map 函数来从 reducer 中获取详细信息（`let
    articleDetails = this.props.article.get(articleID);`），并根据情况设置组件的状态如下：
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here you can find that in the `articleDetails` variable, we keep all data fetched
    from reducer/DB. In general, now we only have the frontend side because a backend
    side fetching an edited article will be introduced later in this book.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以发现在 `articleDetails` 变量中，我们保留了从 reducer/DB 中获取的所有数据。总的来说，现在我们只有前端部分，因为后端部分获取编辑后的文章将在本书的后面介绍。
- en: The `_onDraftJSChange` function is similar to the one in the `AddArticleView`
    component.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`_onDraftJSChange` 函数与 `AddArticleView` 组件中的函数类似。'
- en: 'The `_articleEditSubmit` is quite standard, so I will leave it to you to read
    the code. I will only mention that `_id: currentArticleID` is very important,
    because it''s used later in our `reducer/mapUtils` in order to update the article
    correctly in the article''s reducer.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`_articleEditSubmit` 是非常标准的，所以我会让你自己阅读代码。我只想提到 `_id: currentArticleID` 非常重要，因为它稍后在我们的
    `reducer/mapUtils` 中用于正确更新文章的 reducer 中的文章。'
- en: EditArticleView's render improvements
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EditArticleView 的渲染改进
- en: 'The last part is to improve our `render` function in the `EditArticleView`
    component:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是改进 `EditArticleView` 组件中的 `render` 函数：
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We are managing different states of our component with `if(this.state.articleFetchError)`
    , `else if(!this.state.editedArticleID)` , and `else if(this.state.articleEditSuccess)`
    , as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `if(this.state.articleFetchError)`，`else if(!this.state.editedArticleID)`
    和 `else if(this.state.articleEditSuccess)` 来管理组件的不同状态，如下所示：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this part, the major change is adding a new property called `initialValue`
    , which is passed down to the `WYSIWYGeditor` , the draft-js JSON object.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，主要的变化是添加了一个名为 `initialValue` 的新属性，它被传递给 `WYSIWYGeditor`，即 draft-js 的 JSON
    对象。
- en: Deleting an article's feature implementation
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文章的功能实现
- en: 'Let''s create a new action for deletion at `src/actions/article.js` :'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src/actions/article.js` 中为删除创建一个新的动作：
- en: '[PRE93]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Next, let''s add a `DELETE_ARTICLE` switch case into `src/reducers/article.js`
    :'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `src/reducers/article.js` 中添加一个 `DELETE_ARTICLE` 开关：
- en: '[PRE94]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The last step in implementing a delete button is to modify `src/views/articles/EditArticleView.js
    component.Import PopOver` (it will ask a second time whether you are sure about
    deleting an article):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 实现删除按钮的最后一步是修改 `src/views/articles/EditArticleView.js` 组件中的 `Import PopOver`（它会再次询问您是否确定要删除文章）：
- en: '[PRE95]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The new things here are `_handleDeleteTap` , `_handleDeletion` , `_handleClosePopover`
    , and `state (htmlContent, openDelete, deleteAnchorEl)` . Then, add three new
    functions to `EditArticleView` :'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新东西是`_handleDeleteTap`，`_handleDeletion`，`_handleClosePopover`和`state（htmlContent，openDelete，deleteAnchorEl）`。然后，在`EditArticleView`中添加三个新函数：
- en: '[PRE96]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Improve the return in the `render` function:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 改进`render`函数中的返回：
- en: '[PRE97]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Regarding `render` , new things are all under the new `hr` tag: `<h1>: Delete
    permanently this article<h1>` . `RaisedButton: DeletePopover` is a component from
    Material-UI. You can find more documentation of this component at [http://www.material-ui.com/v0.15.0-alpha.1/#/components/popover](http://www.material-ui.com/v0.15.0-alpha.1/#/components/popover)
    . You can find in the following screenshots how it should look in the `browserRaisedButton:
    Permanent delete, click here` label. The `AddArticleView` component:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '关于`render`，新的东西都在新的`hr`标签下：`<h1>:永久删除此文章<h1>`。`RaisedButton: DeletePopover`是Material-UI中的一个组件。您可以在[http://www.material-ui.com/v0.15.0-alpha.1/#/components/popover](http://www.material-ui.com/v0.15.0-alpha.1/#/components/popover)找到有关此组件的更多文档。您可以在以下截图中找到它在`browserRaisedButton:永久删除，点击这里`标签中应该是什么样子。`AddArticleView`组件：'
- en: '![](Image00039.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00039.jpg)'
- en: 'The `AddArticleView` component after a `SUBMIT ARTICLE` button has been hit:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击`提交文章`按钮后的`AddArticleView`组件：
- en: '![](Image00040.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00040.jpg)'
- en: 'The dashboard component:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板组件：
- en: '![](Image00041.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00041.jpg)'
- en: 'The `EditArticleView` component:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditArticleView`组件：'
- en: '![](Image00042.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00042.jpg)'
- en: 'A DELETE button on the `EditArticleView` component:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditArticleView`组件上的DELETE按钮：'
- en: '![](Image00043.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00043.jpg)'
- en: 'A DELETE button on the `EditArticleView` component after first click (popover
    component):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次点击后的`EditArticleView`组件上的DELETE按钮（弹出组件）：
- en: '![](Image00044.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00044.jpg)'
- en: 'A `PublishingApp` component (main page):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublishingApp`组件（主页）：'
- en: '![](Image00045.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00045.jpg)'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Currently, we have made a lot of progress on the frontend using Redux to store
    the state of our application in its single-state tree. The important drawback
    is that after you hit refresh, all the data disappears.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经在前端使用Redux取得了很大的进展，将应用程序的状态存储在其单一状态树中。重要的缺点是，刷新后所有数据都会消失。
- en: In the next chapter, we will start implementing the backend in order to store
    the articles in our database.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始实现后端，以便将文章存储在我们的数据库中。
- en: As you already know, Falcor is our glue that replaces the old popular RESTful
    approach; you will master stuff related to Falcor very soon. You will also learn
    what the differences between Relay/GraphQL and Falcor are. Both are trying to
    solve similar problems, but in very different ways.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的那样，Falcor是我们的胶水，取代了旧的流行的RESTful方法；您很快就会掌握与Falcor相关的东西。您还将了解Relay/GraphQL和Falcor之间的区别。它们都试图以非常不同的方式解决类似的问题。
- en: Let's go even more in depth into our full-stack Falcor application. We will
    make it even more awesome for our end users.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解我们的全栈Falcor应用程序。我们将使它对我们的最终用户更加强大。
