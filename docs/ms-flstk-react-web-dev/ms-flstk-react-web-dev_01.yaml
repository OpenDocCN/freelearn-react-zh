- en: Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor,
    and Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js，Express.js，MongoDB，Mongoose，Falcor和Redux配置全栈
- en: 'Welcome to *Mastering Full-Stack React Web Development* . In this book, you
    will create a universal full-stack application in JavaScript. The application
    that we are going to build is a publishing platform similar to those that are
    currently popular on the market, for example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*掌握全栈React Web开发*。在这本书中，你将使用JavaScript创建一个通用的全栈应用程序。我们将要构建的应用程序是一个类似于目前市场上流行的发布平台，例如：
- en: Medium ( [https://medium.com/](https://medium.com/) )
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Medium ( [https://medium.com/](https://medium.com/) )
- en: WordPress ( [https://wordpress.com/](https://wordpress.com/) )
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress ( [https://wordpress.com/](https://wordpress.com/) )
- en: issuu ( [https://issuu.com/](https://issuu.com/) )
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: issuu ( [https://issuu.com/](https://issuu.com/) )
- en: There are many smaller publishing platforms, and, of course, our application
    will have fewer features than the ones listed in the aforementioned list because
    we will only focus on the main features, such as publishing an article, editing
    an article, or deleting an article (the core features that you can use to implement
    your own ideas). Besides that, we will focus on building a robust application
    that can be built on because one of the most important things about these kinds
    of applications is scalability. Sometimes, a single article gets much more web
    traffic than the whole site put together (10,000 percent times more traffic is
    normal in the industry because, for instance, a single article could gain insane
    traction through social media).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多较小的发布平台，当然，我们的应用程序将比上述列表中列出的应用程序功能更少，因为我们只关注主要功能，比如发布文章、编辑文章或删除文章（这些核心功能可以用来实现你自己的想法）。除此之外，我们将专注于构建一个健壮的应用程序，因为这类应用程序最重要的一点就是可扩展性。有时，一篇文章的网络流量远远超过整个网站的流量（在行业中，例如，一篇文章可能通过社交媒体获得疯狂的关注，流量增加了10000%是正常的）。
- en: The first chapter of this book is all about setting up the project's main dependencies.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第一章是关于设置项目的主要依赖项。
- en: 'Our focus for this chapter will include the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们的重点将包括以下主题：
- en: Installation of **Node Version Manager** (**NVM** ) for easier Node management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装**Node Version Manager**（**NVM**）以便更轻松地管理Node
- en: Installation of Node and NPM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node和NPM
- en: Preparing MongoDB in our local environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的本地环境中准备MongoDB
- en: Robomongo for Mongo's GUI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robomongo用于Mongo的GUI
- en: Express.js setup
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express.js设置
- en: Mongoose installation and configuration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose的安装和配置
- en: Initial React Redux structure for our client-side app
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们客户端应用程序的初始React Redux结构
- en: Netflix Falcor on the backend and frontend as a glue and replacement for the
    old RESTful approach
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Falcor作为后端和前端的粘合剂和旧的RESTful方法的替代品
- en: We will use very modern app stacks that gained a lot of traction in 2015 and
    2016--I am sure that the stack that you are going to learn throughout the book
    will be even more popular in years to come, as we in our company, *MobileWebPro.pl*
    , see huge spikes of interest in the technologies that are listed in the previous
    bullets. You will gain a lot from this book, and will catch up with the newest
    approaches to building robust, full-stack applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在2015年和2016年获得了很多关注的非常现代的应用程序堆栈-我相信你将在整本书中学到的堆栈在未来几年会更受欢迎，因为我们公司*MobileWebPro.pl*看到了在之前列出的技术中出现了巨大的兴趣激增。你将从这本书中获益良多，并且会掌握构建强大的全栈应用程序的最新方法。
- en: 读累了记得休息一会哦~
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: More about our technical stack
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于我们的技术堆栈更多信息
- en: In this book, we assume that you are familiar with JavaScript (ES5 and ES6)
    and we will also introduce you to some mechanisms from ES7 and ES8.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们假设您熟悉JavaScript（ES5和ES6），我们还将向您介绍一些来自ES7和ES8的机制。
- en: For the client side, you will use React.js, which you must already be familiar
    with, so we won't discuss React's API in detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，您将使用React.js，这是您必须已经熟悉的，因此我们不会详细讨论React的API。
- en: For data management on the client side, we will use Redux. We will also show
    you how to set up the server-side rendering with Redux.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端的数据管理方面，我们将使用Redux。我们还将向您展示如何使用Redux进行服务器端渲染。
- en: For the database, you will learn how to use MongoDB alongside Mongoose. The
    second one is an object data modeling library that provides a rigorous modeling
    environment for your data. It enforces a structure, and at the same time it also
    allows you to keep the flexibility that makes MongoDB so powerful.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库，您将学习如何在MongoDB中使用Mongoose。Mongoose是一个对象数据建模库，为您的数据提供了严格的建模环境。它强制实施结构，同时也允许您保持MongoDB强大的灵活性。
- en: Node.js and Express.js are standard choices for a frontend developer to start
    a full-stack development. Express's framework has the best support for the innovative
    client backend data fetching mechanism created by **Netflix** -**Falcor.js** .
    We believe you will love Falcor because of its simplicity and the fact that it
    will save you so much time when doing full-stack development. We will explain
    in detail later in the book why it is so efficient to use this data fetching library
    instead of the standard process of building a RESTful API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和Express.js是前端开发人员开始全栈开发的标准选择。Express的框架对**Netflix**创建的创新客户端后端数据获取机制**Falcor.js**提供了最好的支持。我们相信您会喜欢Falcor，因为它的简单性以及在进行全栈开发时能节省大量时间。我们将在本书后面详细解释为什么使用这个数据获取库比构建RESTful
    API的标准流程更有效率。
- en: Generally, we will use an object notation (JSON) pretty much everywhere--with
    React as the library, JSON is heavily used for diffing the Virtual DOM (under
    the hood). Redux uses a JSON tree for its single state tree container as well.
    Netflix Falcor's library also uses an advanced concept called a virtual JSON graph
    (we will describe it in detail later). Finally, MongoDB is also a document-based
    database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们几乎在任何地方都会使用对象表示法（JSON）--在React作为库的情况下，JSON被广泛用于虚拟DOM的差异处理（在幕后）。Redux还使用JSON树作为其单一状态树容器。Netflix
    Falcor库还使用了一个称为虚拟JSON图的高级概念（我们稍后会详细描述）。最后，MongoDB也是一个基于文档的数据库。
- en: JSON everywhere--this setup will improve our productivity drastically, mainly
    because of Falcor, which is binding everything together.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JSON随处可见--这种设置将极大地提高我们的生产力，主要是因为Falcor将所有内容绑定在一起。
- en: Environment preparation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境准备
- en: 'For starting up, you''re going to need the following tools installed on your
    operating system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动，您需要在操作系统上安装以下工具：
- en: MongoDB
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Node.js
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: NPM--installed automatically with Node.js
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM--随Node.js自动安装
- en: We strongly recommend using either Linux or OS X for development. For Windows
    users, we'd recommend setting up a virtual machine and doing the development part
    within it. For doing so, you can either use **Vagrant** ( [https://www.vagrantup.com/](https://www.vagrantup.com/)
    ), which creates a virtual env process in the background with development taking
    place almost natively on Windows, or you can use Oracle's **VirtualBox** ( [https://www.virtualbox.org/](https://www.virtualbox.org/)
    ) directly, and work within a virtual desktop, however the performance here is
    significantly lower than working native.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议开发时使用Linux或OS X。对于Windows用户，我们建议设置一个虚拟机，并在其中进行开发。为此，您可以使用Vagrant（[https://www.vagrantup.com/](https://www.vagrantup.com/)），它在后台创建一个虚拟环境进程，使开发几乎可以在Windows上本地进行，或者您可以直接使用Oracle的VirtualBox（[https://www.virtualbox.org/](https://www.virtualbox.org/)），并在虚拟桌面中工作，但性能显著低于本地工作。
- en: NVM and Node installation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NVM和Node安装
- en: NVM is a very handy tool for keeping different Node versions on your machine
    during development. Go to [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    for instructions if you don't have NVM installed on your system yet.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: NVM是一个非常方便的工具，可以在开发过程中在您的机器上保留不同的Node版本。如果您的系统尚未安装NVM，请前往[https://github.com/creationix/nvm](https://github.com/creationix/nvm)获取说明。
- en: 'After you have NVM on your system, you can type the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上安装了NVM后，您可以输入以下内容：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command lists all possible Node versions that are available. We will use
    Node v4.0.0 in our case, so you need to type the following in your terminal:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出所有可用的Node版本。在我们的情况下，我们将使用Node v4.0.0，因此您需要在终端中输入以下内容：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These commands will install Node version 4.0.0\. and set it as default. We
    use NPM 2.14.23 during the book so you can check your version with the following
    command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将安装Node版本4.0.0，并将其设置为默认版本。我们在本书中使用NPM 2.14.23，您可以使用以下命令检查您的版本：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After you have the same versions of Node and NPM on your local machine, then
    we can start to set up the rest of the tools that we are going to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地机器上安装相同版本的Node和NPM后，我们可以开始设置其余的工具。
- en: MongoDB installation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB安装
- en: You can find all the MongoDB instructions at [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)
    under the Tutorials section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Tutorials](https://docs.mongodb.org/manual/installation/)部分找到所有MongoDB的安装说明。
- en: 'The following is a screenshot from the MongoDB website:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自MongoDB网站的截图：
- en: '![](Image00004.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00004.jpg)'
- en: The instructions and prepared packages for installing Node.js can be found at
    [https://nodejs.org](https://nodejs.org) .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js的说明和准备的软件包可以在[https://nodejs.org](https://nodejs.org)找到。
- en: Robomongo GUI for MongoDB
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Robomongo用于MongoDB的GUI
- en: '**Robomongo** is a cross-platform desktop client that may be compared to MySQL
    or PostgreSQL for SQL databases.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Robomongo是一个跨平台的桌面客户端，可用于SQL数据库，类似于MySQL或PostgreSQL。
- en: When developing an app, it's good to have a GUI and be able to quickly review
    collections in our database. This is an optional step if you feel familiar with
    using shell for DB management, but it's helpful if it's your first step in working
    with databases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，拥有一个图形用户界面并能够快速查看数据库中的集合是很好的。如果您熟悉使用shell进行数据库管理，则这是一个可选步骤，但如果这是您在处理数据库方面的第一步，这将很有帮助。
- en: To obtain Robomongo (for all operating systems), visit [https://robomongo.org/](https://robomongo.org/)
    and install one on your machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Robomongo（适用于所有操作系统），请访问[https://robomongo.org/](https://robomongo.org/)并在您的机器上安装一个。
- en: In our case, we will use version 0.9.0 RC4 of Robomongo.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用Robomongo的0.9.0 RC4版本。
- en: Running MongoDB and viewing our collections in the Robomongo GUI
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行MongoDB并在Robomongo GUI中查看我们的集合
- en: 'After you have installed MongoDB and Robomongo on your machine, you need to
    run its daemon process, which listens to connections and delegates them to the
    database. To run the Mongo daemon process in your terminal, use the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上安装了MongoDB和Robomongo之后，您需要运行守护进程，该进程监听连接并将它们委派给数据库。要在终端中运行Mongo守护进程，请使用以下命令：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then perform the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行以下步骤：
- en: 'Open Robomongo''s client--the following screen will appear:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Robomongo的客户端--将出现以下屏幕：
- en: '![](Image00005.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00005.jpg)'
- en: 'Create a connection with defaults by clicking the Create link:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击“创建”链接使用默认值创建连接：
- en: '![](Image00006.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00006.jpg)'
- en: Pick a name for your connection and use port `27017` , which is the default
    for databases, and click on Save .
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的连接选择一个名称，并使用端口`27017`，这是数据库的默认端口，然后单击“保存”。
- en: At this point, you have a localhost database setup finished, and you can preview
    its content using the GUI client.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经完成了本地主机数据库的设置，并且可以使用GUI客户端预览其内容。
- en: Importing the first example collection into the database
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将第一个示例集合导入数据库
- en: 'In the project''s directory, create a file called `initData.js` :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录中，创建一个名为`initData.js`的文件：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our case, we are building the publishing app so it will be a list of articles.
    In the following code, we have an example collection of two articles in a JSON
    format:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们正在构建发布应用程序，因此它将是一系列文章。在以下代码中，我们有一个JSON格式的两篇文章的示例集合：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In general, we start from a mocked collection of articles--later we will add
    a feature to add more articles into MongoDB's collection, but for now we will
    stick with only two articles for the sake of brevity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们从一组模拟的文章开始--稍后我们将添加一个功能来将更多文章添加到MongoDB的集合中，但现在为了简洁起见，我们将只使用两篇文章。
- en: 'To list your localhost databases, open the Mongo shell by typing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出您的本地主机数据库，请输入以下命令打开Mongo shell：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While in the Mongo shell, type:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mongo shell中，输入：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'See the following for a full example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下完整示例：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our example, it shows that we have one database in the localhost called `local`
    .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，它显示我们在本地主机上有一个名为`local`的数据库。
- en: Importing the articles to MongoDB
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文章导入MongoDB
- en: 'In the following, we will use Terminal (the command prompt) in order to import
    the articles into the database. Alternatively, you can use Robomongo to do it
    via the GUI as well:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用终端（命令提示符）来导入文章到数据库。或者，您也可以使用Robomongo通过GUI来完成：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that you need a new tab in your Terminal and `mongo import` will work
    while you are in the Mongo shell (Don't confuse it with the `mongod` process).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要在终端中打开一个新标签，并且在Mongo shell中使用`mongo import`（不要将其与`mongod`进程混淆）。
- en: 'Then you shall see the following information in your terminal:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将在终端中看到以下信息：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In case you get the error `Failed: error connecting to db server: no reachable
    servers` , then make sure you have `mongod` running on the given host IP (`127.0.0.1`
    ).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您收到错误消息`Failed: error connecting to db server: no reachable servers`，请确保您在给定的主机IP（`127.0.0.1`）上运行`mongod`。'
- en: 'After importing those articles via the command line, you will also see this
    reflected in Robomongo:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行导入这些文章后，您还将在Robomongo中看到这一点：
- en: '![](Image00007.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00007.jpg)'
- en: Server setup with Node.js and Express.js
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js和Express.js设置服务器
- en: Once we have our article collection in MongoDB, we can start working on our
    Express.js server in order to work on the collection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在MongoDB中有了我们的文章集合，我们就可以开始在Express.js服务器上工作，以便处理这个集合。
- en: 'First, we need an NPM project in our directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的目录中需要一个NPM项目：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `--yes` flag means that we will use the default settings for `package.json`
    .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`--yes`标志表示我们将使用`package.json`的默认设置。'
- en: 'Next, let''s create an `index.js` file in the `server` directory:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`server`目录中创建一个`index.js`文件：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In `index.js` , we need to add a Babel/register in order to get better coverage
    of the ECMAScript 2015 and 2016 specification. This will enable us to support
    such structures as `async` and `generator` functions, which are not available
    in the current version of Node.js by default.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`中，我们需要添加一个Babel/register，以便更好地支持ECMAScript 2015和2016规范。这将使我们能够支持诸如`async`和`generator`函数之类的结构，这些在当前版本的Node.js中默认情况下是不可用的。
- en: 'See the following for the `index.js` file content (we will install Babel''s
    `dev` dependencies later):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`index.js`文件内容（我们稍后将安装Babel的`dev`依赖项）：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Installing `express` and other initial dependencies:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`express`和其他初始依赖项：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the command, you can see `@4.13.4` after `express` and others. These are
    the versions of the libraries we're going to install, and we've picked it intentionally
    to make sure that it works well along side Falcor, but most probably you can skip
    these, and newer versions should work just as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令中，您可以在`express`和其他之后看到`@4.13.4`。这些是我们要安装的库的版本，我们故意选择它们以确保它们能够很好地与Falcor一起工作，但很可能您可以跳过这些，更新的版本应该同样有效。
- en: 'We also need to install `dev` dependencies (we have spilled all `npm install`
    commands into separate for better readability):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装`dev`依赖项（我们已经将所有`npm install`命令分开以提高可读性）：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We need the `babel-preset-stage-0` is for ES7 features. The `babel-preset-es2015`
    and `babel-preset-react` are required for JSX and ES6 support.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`babel-preset-stage-0`来支持ES7功能。`babel-preset-es2015`和`babel-preset-react`是为了支持JSX和ES6。
- en: 'Also, note that we install Babel to give our Node''s server the ability to
    use ES6 features. We need to add the `.babelrc` file, so create the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们安装Babel是为了让我们的Node服务器能够使用ES6功能。我们需要添加`.babelrc`文件，因此创建以下内容：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then open the `.babelrc` file and fill it with the following content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开`.babelrc`文件，并填写以下内容：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that the `.babelrc` is a hidden file. Probably the best way to edit
    the `.babelrc` is to open the whole project in a text editor such as Sublime Text.
    Then you should be able to see all hidden files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`.babelrc` 是一个隐藏文件。最好的编辑`.babelrc` 的方法可能是在诸如Sublime Text之类的文本编辑器中打开整个项目。然后您应该能够看到所有隐藏文件。
- en: 'We also need the following libraries:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下库：
- en: '`babel` and `babel-core/register` : This is the library for transpiling new
    ECMAScript functions into the existing version'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel`和`babel-core/register`：这是将新的ECMAScript函数转译为现有版本的库'
- en: '`cors` : This module is responsible for creating cross-origin requests to our
    domain in an easy way'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`：这个模块负责以一种简单的方式创建跨域请求到我们域的请求'
- en: '`body-parser` : This is the middleware for parsing the request''s body'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser`：这是用于解析请求体的中间件'
- en: 'After this, your project''s file structure should look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您的项目文件结构应该如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `***` is a wildcard, which means that there are files required for our project,
    but we don't list them here as it would be too long.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`***`是一个通配符，意味着我们的项目需要这些文件，但我们没有在这里列出，因为列表会太长。'
- en: Working on our server (server.js)
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的服务器（server.js）
- en: 'We will start working on the `server/server.js` file, which is new to our project,
    so we need to create it first with the following commands, in the `server` directory
    of your project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始处理`server/server.js`文件，这是我们项目中的新文件，所以我们首先需要使用以下命令在项目的`server`目录中创建它：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The content for the `server/server.js` file is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/server.js`文件的内容如下：'
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These files use the `babel/register` library so that we can use ES6 syntax in
    our code. In the `index.js` file, we have an `http` module which comes from Node.js
    ( [https://nodejs.org/api/http.html#http_http](https://nodejs.org/api/http.html#http_http)
    ). Next, we have `express` , `cors` , and `body-parser` .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件使用`babel/register`库，以便我们可以在代码中使用ES6语法。在`index.js`文件中，我们有一个来自Node.js的`http`模块（[https://nodejs.org/api/http.html#http_http](https://nodejs.org/api/http.html#http_http)）。接下来，我们有`express`，`cors`和`body-parser`。
- en: Cors is middleware for dynamically or statically enabling **cross-origin resource
    sharing** (**CORS** ) in Express applications--it will be useful in our development
    environment (we will delete it later for our production server).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Cors是Express应用程序中用于动态或静态启用**跨源资源共享**（**CORS**）的中间件--在我们的开发环境中它将很有用（我们将在生产服务器中删除它）。
- en: Body-parser is middleware for HTTP's body parsing. It has some fancy settings
    that help us build the app faster.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Body-parser是用于HTTP请求体解析的中间件。它有一些花哨的设置，可以帮助我们更快地构建应用程序。
- en: 'This how our app looks at this stage of our development:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应用程序在开发的这个阶段的样子：
- en: '![](Image00008.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00008.jpg)'
- en: Mongoose and Express.js
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose和Express.js
- en: 'At the moment, we have a simple working Express.js server. Now we have to add
    Mongoose to our project:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个简单的工作Express.js服务器。现在我们需要将Mongoose添加到我们的项目中：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have installed Mongoose and a running MongoDB database in the background,
    we can import it to our `server.js` file and do the coding:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Mongoose并在后台运行了MongoDB数据库，我们就可以将其导入到我们的`server.js`文件中并进行编码：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 读累了记得休息一会哦~
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: A summary of how to run the project
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运行项目的摘要
- en: 'Make sure that you have MongoDB running in the background on your machine using
    the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在计算机上使用以下命令在后台运行MongoDB：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After you run the `mongod` command in your terminal (or PowerShell on Windows),
    then you should see something like the following in your console:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端（或Windows上的PowerShell）中运行`mongod`命令后，您应该在控制台中看到以下内容：
- en: '![](Image00009.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00009.jpg)'
- en: 'Before you run the server, make sure the `devDependencies` in your `package.json`
    file look like the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行服务器之前，请确保您的`package.json`文件中的`devDependencies`如下所示：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before you run the server, make sure that the dependencies in your `package.json`
    look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行服务器之前，请确保您的`package.json`中的依赖项如下所示：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the main directory, run Node with the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在主目录中，使用以下命令运行Node：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that, your terminal should show something like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您的终端应该显示以下内容：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](Image00010.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00010.jpg)'
- en: Redux basic concepts
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux基本概念
- en: In this section, we will cover only the most basic concepts of Redux that will
    help us make our simple publishing app. The app will only be in *read-only* mode
    for this chapter; later in the book we will add more functionality such as adding/editing
    an article. You will discover all the important rules and principles about Redux
    in the later chapters.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仅涵盖Redux的最基本概念，这将帮助我们制作我们的简单发布应用程序。本章中的应用程序将仅处于*只读*模式；在本书的后面，我们将添加更多功能，如添加/编辑文章。您将在后面的章节中发现有关Redux的所有重要规则和原则。
- en: 'Basic topics covered are:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖的基本主题包括：
- en: What is a state tree?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是状态树？
- en: How immutability works in Redux
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性在Redux中是如何工作的
- en: The concept and basic use of reducers
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减速器的概念和基本用法
- en: Let's start with the basics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。
- en: The single immutable state tree
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一的不可变状态树
- en: The most important principle of Redux is that you are going to represent the
    whole state of your application as a single JavaScript object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Redux最重要的原则是，您将把应用程序的整个状态表示为一个单一的JavaScript对象。
- en: All changes (actions) in Redux are explicit, so you can track a history of all
    your actions through the application with a dev tool.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的所有变化（action）都是显式的，因此你可以通过开发工具跟踪应用程序中所有操作的历史记录。
- en: '![](Image00011.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00011.jpg)'
- en: The preceding screenshot is a simple, example dev tool use case that you will
    use in your development environment. It will help you to track the changes of
    state in your app. The example shows how we have incremented the counter value
    in our state by *+1* , three times. Of course, our publishing app structure will
    be much more complicated than this example. You will learn more about that dev
    tool later in the book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图是一个简单的开发工具使用案例，你将在开发环境中使用它。它将帮助你跟踪应用程序中状态的变化。这个例子展示了我们如何通过*+1*三次增加了我们状态中的计数器值。当然，我们的发布应用结构会比这个例子复杂得多。你将在本书的后面学到更多关于那个开发工具的知识。
- en: Immutability - actions and state tree are read-only
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性- action和状态树都是只读的
- en: As Redux bases its concepts on functional programming paradigms, you cannot
    modify/mutate the values in your state tree in the same way that you can for Facebook's
    (and other) FLUX implementations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Redux基于函数式编程范式，你不能以与Facebook（和其他）FLUX实现相同的方式修改/改变状态树中的值。
- en: 'As with other FLUX implementations, an action is a plain object that describes
    the change--like adding an article (in the following code we mock the payload
    for the sake of brevity):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他FLUX实现一样，action是一个描述变化的普通对象--比如添加一篇文章（在下面的代码中，我们为了简洁起见模拟了payload）：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An action is a minimal representation of the change for our app state tree.
    Let's prepare actions for our publishing app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: action是我们应用状态树变化的最小表示。让我们为我们的发布应用准备一些action。
- en: Pure and impure functions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和不纯函数
- en: A **pure function** is a function that doesn't have any side effects, such as
    for example, I/O (reading a file or an HTTP request). **Impure functions** have
    side effects so, for example, if you make a call to the HTTP request, it can return
    different values for exactly the same arguments *Y,Z (function(X,Y))* because
    an endpoint is returning us a random value, or could be down because of a server
    error.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是指没有任何副作用的函数，比如，I/O（读取文件或HTTP请求）。不纯的函数会产生副作用，比如，如果你发起一个HTTP请求，它可能会针对完全相同的参数*Y,Z（function(X,Y)*返回不同的值，因为端点会返回一个随机值，或者因为服务器错误而宕机。
- en: Pure functions are always predictable for the same *X,Y* arguments. In Redux,
    we use only pure functions in reducers and actions (otherwise Redux's `lib` won't
    work properly).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相同的*X,Y*参数，纯函数总是可预测的。在Redux中，我们只在reducer和action中使用纯函数（否则Redux的`lib`将无法正常工作）。
- en: In this book, you will learn the whole structure and where to make API calls.
    So if you follow the book, then you won't have to worry too much about that principle
    in Redux.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将学习整个结构以及何时进行API调用。因此，如果你遵循本书，那么你就不必太担心Redux中的这个原则。
- en: The reducer function
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reducer函数
- en: Reducers from Redux can be compared to a single store from Facebook's Flux.
    What is important is that a reducer always takes a previous state and returns
    a new reference to a new object (with the use of `Object.assign` and others like
    that), so we can have immutable JS helping us to build a more predictable state
    of our application in comparison to older Flux implementations that mutate variables
    in the store.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的reducer可以与Facebook的Flux中的单个store进行比较。重要的是，reducer始终接受先前的状态并返回一个新对象的新引用（使用`Object.assign`等方法），因此我们可以使用不可变的JS来帮助我们构建一个更可预测的应用程序状态，与旧的Flux实现相比，它们会改变存储中的变量。
- en: Thus, creating a new reference is optimal because Redux uses old references
    to values from reducers that didn't change. This means that even if each action
    creates a whole new object via a reducer then the values that don't change have
    a previous reference in the memory so we don't overuse the computation power of
    the machine. Everything is fast.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个新的引用是最佳的，因为Redux使用来自未更改的reducer值的旧引用。这意味着即使每个操作通过reducer创建一个全新的对象，那些不变的值在内存中仍具有先前的引用，因此我们不会过度使用计算机的计算能力。一切都很快。
- en: In our app, we will have an article reducer that will help us to list, add,
    edit, and delete our articles from the view layer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将有一个文章reducer，它将帮助我们从视图层列出、添加、编辑和删除文章。
- en: First reducer and webpack config
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首个reducer和webpack配置
- en: 'First, let''s create a reducer for our publication app:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的发布应用程序创建一个reducer：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, our first reducer''s location is `src/reducers/article.js` and the content
    of our `reducers/article.js` is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们第一个reducer的位置是`src/reducers/article.js`，我们的`reducers/article.js`的内容如下：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we have our `articleMock` kept in the browser memory
    (it's the same as in `initData.js` )--later, we will fetch this data from our
    backend database.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将我们的`articleMock`保存在浏览器内存中（与`initData.js`中的内容相同）-稍后，我们将从后端数据库中获取这些数据。
- en: The arrow function, `const article` is getting `action.type` which will come
    from constants (we will create them later) in the same way that Facebook's FLUX
    implementation works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数`const article`正在获取`action.type`，它将以与Facebook的FLUX实现相同的方式来自常量（我们稍后将创建它们）。
- en: For the default `return` in the `switch` statement, we provide the state from
    `state = articleMock` (return state; part above). This will return the initial
    state of our publishing app at first startup before any other action occurs. To
    be exact, the default in our case will do exactly the same as the `RETURN_ALL_ARTICLES`
    action before we start fetching data from the backend (after the articles' fetching
    mechanism from backend is implemented; then the default will return an empty object).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`switch`语句中的默认`return`，我们从`state = articleMock`（上面的return state;部分）提供状态。这将在任何其他操作发生之前，在首次启动我们的发布应用程序时返回初始状态。确切地说，在我们的情况下，默认情况将与`RETURN_ALL_ARTICLES`操作完全相同，然后我们开始从后端获取数据（在实现了从后端获取文章的机制之后，然后默认情况将返回一个空对象）。
- en: 'Because of our webpack configuration (described here), we need `index.html`
    in `dist` . Let''s create a `dist/index.html` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的webpack配置（在此处描述），我们需要`dist`中的`index.html`。让我们创建一个`dist/index.html`文件：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `dist/index.html` file''s content is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist/index.html`文件的内容如下：'
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have an article `reducer` and `dist/index.html` , but before we start building
    our Redux's publishing app, we need to configure webpack for our built automation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个文章`reducer`和`dist/index.html`，但在开始构建Redux发布应用程序之前，我们需要为我们的构建自动化配置webpack。
- en: 'Install webpack first (you may need `sudo` root access for it):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装webpack（您可能需要`sudo`根访问权限）：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, in the main directory next to the `package.json` and `initData.js` files,
    input the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`package.json`和`initData.js`文件旁的主目录中，输入以下内容：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then create webpack configs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建webpack配置：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Simply, webpack config says that the entry of the CommonJS module is at entry
    `''./src/app.js''` . webpack builds a whole app following all imports from the
    `app.js` and the final output is located at path `''./dist''` . Our app that is
    located at `contentBase: ''./dist''` will live at port `3000` . We also configure
    the use of ES2015 and React so that webpack will compile ES2015 into ES5 and React''s
    JSX into JavaScript for us. If you are interested in webpack''s configuration
    options, then read its documentation.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '简单地说，webpack配置表示CommonJS模块的入口在`''./src/app.js''`。webpack构建整个应用程序，遵循从`app.js`导入的所有内容，最终输出位于路径`''./dist''`。我们的应用程序位于`contentBase:
    ''./dist''`，将位于端口`3000`。我们还配置了ES2015和React的使用，以便webpack将ES2015编译为ES5，并将React的JSX编译为JavaScript。如果您对webpack的配置选项感兴趣，请阅读其文档。'
- en: The rest of the important dependencies installation and npm dev script
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其余重要依赖项的安装和npm dev脚本
- en: 'Install the Babel tools that are used by webpack (check the config file):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 安装webpack使用的Babel工具（检查配置文件）：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also need to update our `package.json` file (add `scripts` ):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的`package.json`文件（添加`scripts`）：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our complete `package.json` should look like the following, with all frontend
    dependencies:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完整的`package.json`应该如下所示，包括所有前端依赖项：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may realize, the mentioned `package.json` doesn''t have the `^` signs
    as we want to use the exact versions of each package in order to make sure that
    all our packages are installed with the correct and exact version given in the
    package. Otherwise, you may have some difficulties, for example, if you add `"mongoose":
    "4.4.5"` , with the `^` then it will install a newer version that causes some
    additional warnings in the console. Let''s stick to the versions mentioned in
    the book in order to avoid unnecessary problems with the app that we are building.
    We want to avoid NPM dependencies hell at all cost.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您可能意识到的，上述`package.json`没有`^`符号，因为我们希望使用每个软件包的确切版本，以确保所有软件包都安装了包中给出的正确和确切的版本。否则，您可能会遇到一些困难，例如，如果您添加`"mongoose":
    "4.4.5"`，然后它将安装一个新版本，导致控制台中出现一些额外的警告。让我们坚持书中提到的版本，以避免我们正在构建的应用程序出现不必要的问题。我们要尽一切努力避免NPM依赖地狱。'
- en: Working on src/app.js and src/layouts/PublishingApp.js
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在src/app.js和src/layouts/PublishingApp.js上工作
- en: 'Let''s create our `app.js` file, where the main part of our app will live at
    `src/app.js` :'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的`app.js`文件，我们的应用程序的主要部分将位于`src/app.js`：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The content of our new `src/app.js` file is the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`src/app.js`文件的内容如下：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The new part is the `store = createStore(article)` part--this utility from Redux
    lets you keep an application state object, dispatch an action, and allows you
    to give a reducer as an argument that tells you how the app is updated with actions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 新的部分是`store = createStore(article)`部分--Redux中的这个实用程序允许您保持应用程序状态对象，分派动作，并允许您将一个减速器作为参数，告诉您应用程序如何通过动作进行更新。
- en: 'The `react-redux` is a useful binding of Redux into React (so we will write
    less code and be more productive):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-redux`是Redux与React的有用绑定（这样我们将编写更少的代码并且更加高效）：'
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Provider store` helps us to make the Redux store available to the `connect()`
    calls in the child components (as shown here):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Provider store`帮助我们使Redux存储可用于子组件中的`connect()`调用（如下所示）：'
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`connect` will be used in any component that has to listen to the reducer''s
    changes in our app. You will see how to use it later in this chapter.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`将在任何需要监听我们应用程序中减速器变化的组件中使用。您将在本章后面看到如何使用它。'
- en: 'For the store, we use `const store = createStore(article)` --just for the sake
    of brevity, I will mention that there are several methods in the store that we
    will use in the next steps of building our app from scratch:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于商店，我们使用`const store = createStore(article)`-- 仅仅为了简洁起见，我将提到商店中有几种方法，我们将在接下来的构建应用程序的步骤中使用。
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `getState` function gives you the current state of the application:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`getState` 函数会给你当前应用程序的状态：'
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `dispatch` function can help you change the state of your app:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数可以帮助你改变应用程序的状态：'
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Subscribe allows you register a callback that Redux will call each time an action
    has been dispatched, so the view layer can learn about the change in the application
    state and refresh its view.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅允许你注册一个回调，Redux 每次分发动作时都会调用它，这样视图层就可以了解应用程序状态的变化并刷新其视图。
- en: Wrapping up React-Redux application
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装 React-Redux 应用程序
- en: 'Let''s finish our first React-Redux app. For a summary, let''s see our current
    directory structure:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成我们的第一个 React-Redux 应用程序。总结一下，让我们看看我们当前的目录结构：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we need to create the main view of our app. We will put this into the layout
    directory in our first version:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建应用程序的主视图。我们将把这放在我们第一个版本的布局目录中：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The content of `PublishingApp.js` is:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublishingApp.js` 的内容是：'
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding introduces the ES7 syntax `...` next to `...` :'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上面介绍了 ES7 语法 `...` 旁边的 `...`：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`...` is a spread operator that is well described in Mozilla''s documentation
    as; *an expression to be expanded in places where multiple arguments (for function
    calls) or multiple elements (for array literals) are expected* . In our case,
    this `...` operator spreads one object state into a second one (in our case, empty
    object `{ }` ). It''s written like this here because, in future, we will specify
    multiple reducers that have to be mapped from our app''s state into the `this.props`
    component.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` 是一个展开运算符，在 Mozilla 的文档中有很好的描述；*一个表达式，在期望多个参数（用于函数调用）或多个元素（用于数组文字）的地方进行展开*。在我们的情况下，这个
    `...` 运算符将一个对象状态扩展到第二个对象中（在我们的情况下，空对象 `{ }` ）。它写在这里是因为将来我们将指定多个必须从我们应用程序状态映射到
    `this.props` 组件的 reducer。'
- en: Finishing our first static publishing app
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的第一个静态发布应用程序
- en: The last thing to do in our static app is to render the articles that come from
    `this.props` .
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的静态应用程序中要做的最后一件事是渲染来自 `this.props` 的文章。
- en: 'Thanks to Redux, the object mocked in the reducer is available, so if you check
    `console.log(this.props)` in the render function of `PublishingApp.js` , then
    you will be able to access our `articles` object:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Redux 的存在，可以在 reducer 中模拟的对象是可用的，所以如果你在 `PublishingApp.js` 的渲染函数中检查 `console.log(this.props)`
    ，那么你将能够访问我们的 `articles` 对象：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In our case, we need to change the React''s render function, as follows (in
    `src/layouts/PublishingApp.js` ):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要更改 React 的渲染函数，如下所示（在 `src/layouts/PublishingApp.js` 中）：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code snippet, we are iterating `for(let articleKey in this.props)`
    over the article `Mock` object (passed from the reducer''s state in `this.props`
    ) and creating an array of articles (in JSX) with `articlesJSX.push(currentArticleJSX);`
    . After it is created, then we will have added the `articlesJSX` into the `return`
    statement:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们正在遍历文章 `Mock` 对象（从 reducer 的状态中传递给 `this.props` ）并使用 `articlesJSX.push(currentArticleJSX);`
    创建文章的数组（在 JSX 中）。创建完成后，我们将把 `articlesJSX` 添加到 `return` 语句中：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This comment will start your project on port `3000` :'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注释将在端口 `3000` 上启动你的项目：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After you check `localhost:3000` , the new static Redux app should look as
    shown in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 `localhost:3000` 后，新的静态 Redux 应用程序应该如下截图所示：
- en: '![](Image00012.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00012.jpg)'
- en: Great, so we have a static app in Redux! It's time to fetch data from our MongoDB
    database using Falcor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们在 Redux 中有一个静态应用程序！现在是时候使用 Falcor 从我们的 MongoDB 数据库中获取数据了。
- en: 读累了记得休息一会哦~
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Falcor's basic concepts
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor 的基本概念
- en: 'Falcor is like a glue between:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor 就像是连接器：
- en: Backend and its database structure (remember importing `initData.js` into MongoDB)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端及其数据库结构（记得将`initData.js`导入到MongoDB中）
- en: Frontend Redux single state tree container
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端Redux单状态树容器
- en: It glues the pieces in a way that is much more effective than building an old-fashioned
    REST API for a single-page application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它以比为单页面应用构建老式REST API更有效的方式将这些部分粘合在一起。
- en: Like the *Redux basic concepts* section, in this one we will learn only the
    most basic concepts of Falcor and they will help us build a simple full-stack
    application in *read-only* mode. Later in the book, you will learn how to make
    an add/edit article with Falcor.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就像*Redux基本概念*部分一样，在这一部分中，我们将只学习Falcor的最基本概念，它们将帮助我们在*只读*模式下构建一个简单的全栈应用程序。在本书的后面，你将学习如何使用Falcor添加/编辑文章。
- en: 'We will focus on the most important aspects:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于最重要的方面：
- en: What is Falcor's model?
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Falcor的模型是什么？
- en: Retrieving values from Falcor (frontend and backend)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Falcor中检索值（前端和后端）
- en: Concepts and basic use of JSON graphs
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON图的概念和基本用法
- en: Concepts and basic use of sentinels
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哨兵的概念和基本用法
- en: How to retrieve data from the backend
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从后端检索数据
- en: How to configure our first route with middleware for Express.js called
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为Express.js配置我们的第一个路由中间件
- en: '`falcor-router`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcor-router`'
- en: What is Falcor and why do we need it in our full-stack publishing app?
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor是什么，为什么我们需要在我们的全栈发布应用程序中使用它？
- en: 'Let''s first consider what the difference is between web pages and web applications:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑一下网页和Web应用程序之间的区别是什么：
- en: When the **World Wide Web** (**WWW** ) was invented, web pages served small
    amounts of large resources (such as HTML, PDF, and PNG files). For example, you
    could request a PDF, video, or text file from a server.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**万维网**（**WWW**）被发明时，网页提供了大量的大资源（如HTML、PDF和PNG文件）。例如，你可以从服务器请求PDF、视频或文本文件。
- en: Since *circa 2008* , the development of web apps has been getting more and more
    popular. Web applications serve large amounts of small resources. What does it
    mean for us? You have a lot of small REST API calls to the server using AJAX calls.
    The old approach of many API requests creates latency, which slows down the mobile/web
    app.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自*大约2008年*以来，Web应用程序的开发越来越受欢迎。Web应用程序提供大量的小资源。这对我们意味着什么？你需要使用AJAX调用向服务器发出大量小的REST
    API调用。许多API请求的旧方法会导致延迟，从而减慢移动/Web应用程序的速度。
- en: Why do we use old REST API requests (as we did in 2005) in apps written in 2016
    and later? This is where Falcor shines; it solves the problem of latency and tight
    coupling of backend to frontend.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在2016年及以后编写的应用程序中使用旧的REST API请求（就像我们在2005年所做的那样）？这就是Falcor的闪光之处；它解决了后端与前端的耦合和延迟问题。
- en: Tight coupling and latency versus one model everywhere
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧耦合和延迟与到处都是一个模型
- en: 'If you are familiar with frontend development, you know how to make requests
    to an API. This old way of doing things always forces you to tight-couple the
    backend API with frontend API utilities. It''s always like that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉前端开发，你就知道如何向API发出请求。这种老式的做法总是迫使你将后端API与前端API工具紧密耦合。它总是这样的：
- en: You make an API endpoint like [https://applicationDomain.com/api/recordDetails?id=92](https://applicationDomain.com/api/recordDetails?id=92)
    .
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建一个API端点，比如[https://applicationDomain.com/api/recordDetails?id=92](https://applicationDomain.com/api/recordDetails?id=92)。
- en: 'You consume the data with HTTP API requests on the frontend:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在前端使用HTTP API请求来消耗数据：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In large applications, it's hard to maintain real DRY RESTful APIs, and this
    problem causes plenty of endpoints that are not optimized, so the frontend sometimes
    has to do many round trips in order to fetch the data required for a certain view
    (and sometimes it fetches much more than it needs, which causes even more latency
    for the end user of our application).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，很难维护真正DRY的RESTful API，这个问题导致了许多未经优化的端点，因此前端有时必须进行多次往返，以获取某个视图所需的数据（有时它获取的数据甚至比它需要的更多，这会导致应用程序的最终用户遇到更多的延迟）。
- en: Imagine that you have a large application with over 50 different API endpoints.
    After the first version of your application is finished, your client or boss finds
    a better way to structure the user flow in the app. What does this mean? That
    you have to work on changing both frontend and backend endpoints in order to satisfy
    the changes in the user interface layer. This is called tight coupling between
    frontend and backend.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个包含50多个不同API端点的大型应用程序。在第一个版本的应用程序完成后，你的客户或老板发现了一种更好的方式来构建应用程序中的用户流程。这意味着什么？这意味着你必须修改前端和后端端点，以满足用户界面层的变化。这就是前端和后端之间的紧耦合。
- en: What does Falcor bring to this situation to improve on those two areas that
    cause the inefficiency in working with RESTful APIs? The answer is one model everywhere.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor在这种情况下带来了什么，以改进使用RESTful API时的这两个引起低效的领域？答案是一个模型在任何地方。
- en: It would be super easy to build your web applications if all your data was accessible
    in memory, on the client.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数据都可以在客户端内存中访问，构建Web应用程序将会非常容易。
- en: Falcor provides utilities that help you feel that all your data is at your fingertips
    without coding backend API endpoints and client-side consuming utilities.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor提供了一些实用工具，帮助你感觉所有的数据都近在咫尺，而无需编写后端API端点和客户端消费工具。
- en: No more tight coupling on client and server side
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不再有客户端和服务器端的紧耦合
- en: Falcor helps you represent all of your app's data as one virtual JSON model
    on the server.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor帮助你将应用程序的所有数据表示为服务器上的一个虚拟JSON模型。
- en: When programming client side, Falcor makes you feel as if the whole JSON model
    of your application is reachable locally, and allows you to read data the same
    way as you would from an in-memory JSON--you will learn it very soon!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端编程时，Falcor让你感觉好像整个应用程序的JSON模型都可以在本地访问，并且允许你以与从内存中的JSON读取数据相同的方式读取数据--你很快就会学会的！
- en: Because of Falcor's library for browsers and the `falcor-express` middleware,
    you can retrieve your data from the model on-demand, from the cloud.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Falcor为浏览器提供了库和`falcor-express`中间件，你可以按需从云端检索模型上的数据。
- en: Falcor transparently handles all the network communication and keeps your client-side
    app in sync with the server and databases.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor透明地处理所有网络通信，并使你的客户端应用程序与服务器和数据库保持同步。
- en: In this chapter, we will also learn how to use `falcor-router` .
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将学习如何使用`falcor-router`。
- en: Client-side Falcor
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端Falcor
- en: 'Let''s install Falcor from NPM first:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从NPM安装Falcor：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `falcor-http-datasource` helps us to retrieve data from server to client
    side, out-of-the-box (without worrying about HTTP API requests)--we will use this
    later when moving the client-side model to the backend.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcor-http-datasource`帮助我们从服务器端到客户端检索数据，开箱即用（无需担心HTTP API请求）--当将客户端模型移至后端时，我们将使用这个。'
- en: 'Let''s create our app''s Falcor model on the client side:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在客户端创建我们应用的Falcor模型：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then the content of the `falcorModel.js` will be as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`falcorModel.js`的内容将如下所示：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this code, you can find a well-known, brief, and readable model of our publishing
    application with two articles in it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你可以找到我们发布应用程序的一个众所周知、简洁、可读的模型，其中包含两篇文章。
- en: Now we will fetch that data from the frontend Falcor's model in our `src/layouts/PublishingApp.js`
    React component, we will add a new function called `_fetch()` which will be responsible
    for fetching all articles on our application start.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从前端Falcor的模型中获取这些数据，在我们的`src/layouts/PublishingApp.js` React组件中，我们将添加一个名为`_fetch()`的新函数，它将负责在应用启动时获取所有文章。
- en: 'We need to import our Falcor model first, so at the top of the `PublishingApp.js`
    file, we need to add the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要先导入我们的Falcor模型，因此在`PublishingApp.js`文件的顶部，我们需要添加以下内容：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In our `PublishingApp` class, we need to add the following two functions; `componentWillMount`
    and `_fetch` (more explanation follows):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`PublishingApp`类中，我们需要添加以下两个函数；`componentWillMount`和`_fetch`（更多解释如下）：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, you see the asynchronous function called `_fetch` . This is a special
    syntax that allows you to use the `await` keyword like we do when using `let articlesLength
    = await falcorModel` and `let articles = await falcorModel` .
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到名为`_fetch`的异步函数。这是一种特殊的语法，允许您像在使用`let articlesLength = await falcorModel`和`let
    articles = await falcorModel`时一样使用`await`关键字。
- en: Using `async await` over Promises means our code is more readable and avoids
    callback hell situations where nesting multiple callbacks one after the other
    makes code very hard to read and extend.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async await`覆盖Promises意味着我们的代码更易读，并避免了回调地狱的情况，其中嵌套多个回调使代码非常难以阅读和扩展。
- en: The `async` /`await` feature is taken from ECMAScript 7 inspired by C#. It allows
    you to write functions that appear to be blocked at each asynchronous operation
    that is waiting for the result before continuing to the next operation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await`功能取自ECMAScript 7，受C#启发。它允许您编写函数，这些函数在等待结果之前似乎被阻塞在每个异步操作上，然后才继续进行下一个操作。'
- en: 'In our example, the code will execute as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，代码将执行如下：
- en: 'First it will call Falcor''s mode for an article count with the following:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将调用Falcor的模式来获取文章计数，如下所示：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the article's `Length` variable, we will have a count of `articles.length`
    from our model (in our case it will be number two).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文章的`Length`变量中，我们将从我们的模型中获得`articles.length`的计数（在我们的情况下将是数字二）。
- en: 'After we know that we have two articles in our model, then the next block of
    code executes the following:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们知道我们的模型中有两篇文章之后，下一块代码执行如下：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `get` method on `falcorModel.get([''articles'', {from: 0, to: articlesLength-1},
    [''id'',''articleTitle'', ''articleContent'']]).` is also an asynchronous operation
    (in the same way as `http request` ). In the `get` method''s parameter, we provide
    the location of our articles in our model (in `src/falcorModel.js` ), so we are
    providing the following path:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcorModel.get([''articles'', {from: 0, to: articlesLength-1}, [''id'',''articleTitle'',
    ''articleContent'']]).`上的`get`方法也是一个异步操作（与`http请求`一样）。在`get`方法的参数中，我们提供了我们模型中文章的位置（在`src/falcorModel.js`中），因此我们提供了以下路径：'
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The explanation of the preceding Falcor path is based on our model. Let''s
    call it again:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面Falcor路径的解释是基于我们的模型。让我们再次调用它：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What we are saying to Falcor:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Falcor说：
- en: 'First we want to get data from `articles` within our object using:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想使用以下内容从我们的对象中获取`articles`的数据：
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next from `articles` collection select subset of all the articles it has with
    a range `{from: 0, to: articlesLength-1}` (the `articlesLength` we have fetched
    earlier) with the following path:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，从`articles`集合中选择所有文章的子集，范围为`{from: 0, to: articlesLength-1}`（我们之前获取的`articlesLength`），路径如下：'
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last step explains to Falcor, which properties from the object you want
    to fetch from our model. So the complete path in that `falcorModel.get` query
    is the following:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是告诉Falcor，你想从我们的模型中获取对象的哪些属性。因此，在`falcorModel.get`查询中的完整路径如下：
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The array of `['id','articleTitle', 'articleContent']` says that you want those
    three properties out of every article.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[''id'',''articleTitle'', ''articleContent'']`数组表示你想要从每篇文章中获取这三个属性。'
- en: 'In the end, we receive an array of article objects from Falcor:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从Falcor中接收到一组文章对象的数组：
- en: '![](Image00013.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00013.jpg)'
- en: After we have fetched the data from our Falcor model, we need to dispatch an
    action that will change the article's reducer accordingly and ultimately re-render
    our list of articles from our Falcor model from the `const articleMock` (in `src/reducers/article.js`
    ) instead.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在从我们的Falcor模型中获取数据之后，我们需要dispatch一个action，该action将相应地改变文章的reducer，并最终重新渲染我们的文章列表，从`const
    articleMock`（在`src/reducers/article.js`中）中获取。
- en: 'But before we will be able to dispatch an action, we need to do the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够dispatch一个action之前，我们需要做以下事情：
- en: 'Create the `actions` directory with `article.js` :'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`actions`目录，并在其中创建`article.js`：
- en: '[PRE67]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the content for our `src/actions/article.js` file as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的`src/actions/article.js`文件的内容如下：
- en: '[PRE68]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There isn't too much in that `actions/article.js` file `.` If you are familiar
    with FLUX already then it's very similar. One important rule for actions in Redux
    is that it has to be a pure function. For now, we will hardcode a constant called
    `ARTICLES_LIST_ADD` into `actions/article.js` .
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`actions/article.js`文件中并没有太多内容。如果你已经熟悉了FLUX，那么它非常相似。Redux中一个重要的规则是actions必须是纯函数。现在，我们将在`actions/article.js`中硬编码一个名为`ARTICLES_LIST_ADD`的常量。
- en: 'In the `src/layouts/PublishingApp.js` file we need to add a new import code
    at the top of the file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/layouts/PublishingApp.js`文件中，我们需要在文件顶部添加一个新的import代码：
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you have added the preceding two in our `PublishingApp` , then modify
    our existing function in the same file from the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在我们的`PublishingApp`中添加了上述两个之后，然后修改同一文件中现有的函数如下：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add `articleActions: bindActionCreators(articleActions, dispatch)` so that
    we are able to bind the articles'' actions into our `this.props` component:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '添加`articleActions: bindActionCreators(articleActions, dispatch)`，这样我们就能将文章的actions绑定到我们的`this.props`组件中：'
- en: '[PRE71]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Thanks to the mentioned changes `(articleActions: bindActionCreators(articleActions,
    dispatch))` in our component, we will be able to dispatch an action from props
    because now, when you use `this.props.articleActions.articlesList(articles)` then
    the `articles` object fetched from Falcor will be available in our reducer (and
    from there, there is only one step to make our app fetch data work).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '由于在我们的组件中进行了上述更改（`articleActions: bindActionCreators(articleActions, dispatch)`），我们现在能够从props中dispatch一个action，因为现在当你使用`this.props.articleActions.articlesList(articles)`时，从Falcor获取的`articles`对象将在我们的reducer中可用（从那里，我们只需一步就能让我们的应用程序获取数据工作）。'
- en: 'Now, after you are done with these changes, add an action into our component
    in the `_fetch` function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在完成这些更改后，在`_fetch`函数中为我们的组件添加一个action：
- en: '[PRE72]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Our whole function for fetching will look as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整个获取函数将如下所示：
- en: '[PRE73]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Also, don''t forget about calling `_fetch` from `ComponentWillMount` :'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，不要忘记从`ComponentWillMount`中调用`_fetch`：
- en: '[PRE74]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'At this point, we shall be able to receive an action in our Redux''s reducer.
    Let''s improve our `src/reducers/article.js` file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该能够在Redux的reducer中接收一个action。让我们改进我们的`src/reducers/article.js`文件：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, we don't need `articleMock` anymore, so we have deleted it from
    the `src/reducers/article.js` .
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们不再需要`articleMock`，所以我们已经从`src/reducers/article.js`中删除了它。
- en: 'We have added a new case, `ARTICLES_LIST_ADD` :'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的case，`ARTICLES_LIST_ADD`：
- en: '[PRE76]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It returns a new `articlesList` object (with a new reference in the memory,
    thanks to `Object.assign` ).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个新的`articlesList`对象（通过`Object.assign`得到一个新的内存引用）。
- en: 'Don''t confuse the two files with the same name and other locations, such as:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆两个具有相同名称和其他位置的文件，比如：
- en: '`reducers/article.js`'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers/article.js`'
- en: '`actions/article.js`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions/article.js`'
- en: You need to make sure that you are editing the correct file, otherwise the app
    won't work.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保您正在编辑正确的文件，否则应用程序将无法正常工作。
- en: A summary of client-side Falcor + Redux
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端Falcor + Redux的摘要
- en: 'If you run `http://localhost:3000/index.html` , you will see that, currently
    we have two separate applications:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行`http://localhost:3000/index.html`，您将看到，目前我们有两个单独的应用程序：
- en: One at the frontend using Redux and client-side Falcor
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在前端使用Redux和客户端Falcor
- en: One at the backend using MongoDB, Mongoose, and Express
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在后端使用MongoDB，Mongoose和Express
- en: We need to stick both together so we have one source of state for our applications
    (that comes from MongoDB).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将它们合并在一起，这样我们就有了一个应用程序的状态来源（来自MongoDB）。
- en: Moving Falcor's model to the backend
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Falcor的模型移至后端
- en: 'We also need to update our `package.json` file:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的`package.json`文件：
- en: '[PRE77]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Because we are starting the full-stack development part, we need to add `npm
    start` to our scripts in `package.json` --this will help compile client side,
    put them into the `dist` folder (generated via webpack), and create static files
    in `dist` , and then use this folder as the source of static files (check `server/server.js`
    for `app.use(express.static('dist'));` ).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在开始全栈开发部分，我们需要在`package.json`的脚本中添加`npm start` --这将帮助编译客户端代码，将它们放入`dist`文件夹（通过webpack生成），并在`dist`中创建静态文件，然后使用此文件夹作为静态文件的来源（检查`server/server.js`中的`app.use(express.static('dist'));`）。
- en: 'The next important thing is to install new dependencies that are required for
    Falcor on the backend:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的事情是安装后端所需的新依赖项：
- en: '[PRE78]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When you have finally installed new dependencies and configured the basic scripts
    for running the backend and frontend on the same port, then edit the `server/server.js`
    as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当您最终安装了新的依赖项并配置了在同一端口上运行后端和前端的基本脚本后，然后编辑`server/server.js`如下：
- en: 'On top of our file, import new libraries in the `server/server.js` :'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的文件顶部，在`server/server.js`中导入新的库：
- en: '[PRE79]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then between the following two:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在以下两者之间：
- en: '[PRE80]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add new code for managing Falcor at the backend:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后端添加管理Falcor的新代码：
- en: '[PRE81]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The preceding code is almost the same as the one in the `src/falcorModel.js`
    file. The only difference is that now Falcor will fetch data from the backend's
    mocked object, called `cache` in `server.js` .
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码几乎与`src/falcorModel.js`文件中的代码相同。唯一的区别是现在Falcor将从后端的模拟对象`server.js`中的`cache`中获取数据。
- en: 'The second part is to change our data source on the frontend, so in the `src/falcorModel.js`
    file, you change the following old code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二部分是在前端更改我们的数据来源，所以在`src/falcorModel.js`文件中，更改以下旧代码：
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Change it to the following updated code:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其更改为以下更新后的代码：
- en: '[PRE83]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run your app with the following:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行您的应用程序：
- en: '[PRE84]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You will see in your browser''s dev tools a new HTTP request made by Falcor--for
    example, in our case:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在浏览器的开发工具中看到Falcor发出的新的HTTP请求--例如，在我们的情况下：
- en: '![](Image00014.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00014.jpg)'
- en: 'If you follow all the instructions correctly, then you can also make a request
    to your server directly from your browser by executing this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地遇到所有指示，那么您也可以通过执行以下操作直接从浏览器向服务器发出请求：
- en: '[PRE85]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then you shall see a `jsonGraph` in the response:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将在响应中看到`jsonGraph`：
- en: '![](Image00015.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00015.jpg)'
- en: You don't have to worry about those preceding two screenshots. They are just
    an example of how Falcor is communicating between the backend and frontend in
    Falcor's language. You don't have to worry anymore about exposing API endpoints
    and programming frontend to understand what data the backend is providing. Falcor
    is doing all of this out-of-the-box and you will learn more details while making
    this publishing application.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心前两个屏幕截图。它们只是展示了Falcor在后端和前端之间如何使用Falcor语言进行通信的示例。您不必再担心暴露API端点并编程前端以了解后端提供的数据。Falcor已经在开箱即用中完成了所有这些工作，您将在制作此发布应用程序时了解更多细节。
- en: Configuring Falcor's router (Express.js)
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Falcor的路由器（Express.js）
- en: Currently, our model on the backend is hardcoded, so that it stays in the RAM
    memory of a server. We need to add the ability to read the data from our MongoDB's
    articles collection--this is where the `falcor-router` comes in handy.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们后端的模型是硬编码的，因此它保留在服务器的RAM内存中。我们需要添加从我们的MongoDB文章集合中读取数据的能力--这就是`falcor-router`派上用场的地方。
- en: 'We need to create our routes definition files that will be consumed by `falcor-router`
    lib:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建将被`falcor-router`库使用的路由定义文件：
- en: '[PRE86]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have created the `server/routes.js` file; the content for that router will
    be as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`server/routes.js`文件；该路由器的内容将如下所示：
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, we have created our first route that will match the `articles.length`
    from our `_fetch` function (in `layouts/PublishingApp.js` ).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经创建了我们的第一个路线，它将匹配我们在`layouts/PublishingApp.js`中的`_fetch`函数中的`articles.length`。
- en: We have hardcoded the number two in `articlesCountInDB` , later we will make
    a query to our database there.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`articlesCountInDB`中硬编码了数字2，稍后我们将向数据库发出查询。
- en: 'The new stuff here is `route: ''articles.length''` , this is simply a route
    for matching by Falcor.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的新东西是`route: ''articles.length''`，这只是Falcor匹配的一个路线。'
- en: 'To be more precise, the Falcor routes'' paths are exactly the same stuff that
    you have provided in your `src/layouts/PublishingApp.js (_fetch function)` for
    example, to match this frontend call:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，Falcor路由的路径与您在`src/layouts/PublishingApp.js（_fetch函数）`中提供的内容完全相同，例如，为了匹配此前端调用：
- en: '[PRE88]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`path: [''articles'', ''length'']` : This property tells us Falcor''s path
    (it''s consumed by Falcor at the backend and frontend). We need to provide that
    because sometimes, one route can return many different objects as server articles
    (you will see it in the next route we create).'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', ''length'']`：此属性告诉我们Falcor的路径（它在后端和前端被Falcor使用）。我们需要提供这个，因为有时，一个路线可以返回许多不同的对象作为服务器文章（您将在我们创建的下一个路线中看到）。'
- en: '`value: articlesCountInDB` : This is a return value. In this case, it is an
    integer number, but it can also be an object with several properties, as you will
    learn later.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value: articlesCountInDB`：这是一个返回值。在这种情况下，它是一个整数，但稍后您还将了解它也可以是一个具有多个属性的对象。'
- en: Second route for returning our two articles from the backend
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回我们两篇文章的第二条路线
- en: 'Our second route (and last one in this chapter) will be the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二条路线（也是本章的最后一条）将是以下内容：
- en: '[PRE89]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The new thing in the second route is `pathSet` , if you log that into the console,
    then you will see, in our case (when trying to run our full-stack app) the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条路线中的新东西是`pathSet`，如果将其记录到控制台中，那么您将看到，在我们的情况下（尝试运行我们的全栈应用程序时）：
- en: '[PRE90]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`pathSet` tells us what indexes are requested from the client side (`[ 0, 1
    ]` , in our example).'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathSet`告诉我们客户端请求的索引是什么（在我们的示例中是`[0, 1]`）。'
- en: 'Because, in this case, we are returning an array of articles (multiple articles),
    we need to create a result variable:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这种情况下，我们返回的是一组文章（多篇文章），我们需要创建一个结果变量：
- en: '[PRE91]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Iterate over the requested indexes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历请求的索引：
- en: '[PRE92]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the preceding code snippet, we iterate over an array of requested indexes
    (do you remember `{from: 0, to: articlesLength-1}` in `PublishingApp.js` ?). Based
    on the indexes `([0, 1])` we fetch mocked data via `const singleArticleObject
    = articlesArrayFromDB[index];` . Later we put into the `path` and `index` (`path:
    [''articles'', index],` ) so Falcor knows to what path in our JSON graph object,
    the value `singleArticleObject` belongs to.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码片段中，我们遍历了请求的索引数组（您还记得`{from: 0, to: articlesLength-1}`在`PublishingApp.js`中吗？）。基于索引`([0,
    1])`，我们通过`const singleArticleObject = articlesArrayFromDB[index];`获取了模拟数据。稍后，我们将其放入`path`和`index`（`path:
    [''articles'', index]`），这样Falcor就知道`singleArticleObject`的值属于我们的JSON图对象中的哪个路径。'
- en: 'Return that array of articles:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文章数组：
- en: '[PRE93]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`console.info` will show us what has been returned by that path:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.info`将向我们显示该路径返回了什么：'
- en: '[PRE94]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Final touch to make full-stack Falcor run
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一步是使全栈Falcor运行
- en: Currently, we still have mocked data in our routes, but before we start making
    calls to MongoDB, we need to wrap up the current setup so you will be able to
    see it running in your browser.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的路由中仍然有模拟数据，但在我们开始调用MongoDB之前，我们需要完成当前的设置，这样您就可以在浏览器中看到它运行。
- en: 'Open your `server/server.js` and make sure you import the following two things:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`server/server.js`，确保您导入了以下两个内容：
- en: '[PRE95]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now that we have imported our `falcor-router` and `routes.js` --we need to
    use them, so modify this old code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了我们的`falcor-router`和`routes.js`，我们需要使用它们，所以修改这段旧代码：
- en: '[PRE96]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Replace the preceding code with:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码替换为：
- en: '[PRE97]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This will work only when the `falcor-router` has been already installed and
    imported in the `server.js` file. This is a library for `DataSource` that creates
    a virtual JSON graph document on your app server. As you can see in `server.js`
    so far we have `DataSource` provided by our hardcoded model, `return model.asDataSource();`
    . The router here will make the same, but now you will be able to match routes
    based on your app requirements.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅在`falcor-router`已经安装并在`server.js`文件中导入时起作用。这是一个用于在应用服务器上创建虚拟JSON图文档的`DataSource`库。正如您在`server.js`中所看到的，到目前为止，我们已经通过我们的硬编码模型提供了`DataSource`，`return
    model.asDataSource();`。这里的路由器将做同样的事情，但现在您将能够根据应用程序的要求匹配路由。
- en: Also, as you can see, the new `falcorRouter` takes an argument of our routes
    `return new falcorRouter(routes);` .
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如您所看到的，新的`falcorRouter`接受我们的路由作为参数`return new falcorRouter(routes);`。
- en: 'If you have followed the instructions correctly, you will be able to run the
    project:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地按照说明操作，您将能够运行该项目：
- en: '[PRE98]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'On port `3000` , you will see the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口`3000`上，您将看到以下内容：
- en: '![](Image00016.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00016.jpg)'
- en: Adding MongoDB/Mongoose calls based on Falcor's routes
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Falcor路由的MongoDB/Mongoose调用
- en: 'Let''s get back to our `server/routes.js` file. We need to move over (delete
    from `server.js` and move into `routes.js` ) this following code:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`server/routes.js`文件。我们需要将以下代码移动（从`server.js`中删除并移动到`routes.js`）：
- en: '[PRE99]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the first route `articles.length` , you need to replace the mocked number
    two (the articles count) into Mongoose''s `count` method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个路由`articles.length`中，您需要将模拟的数字2（文章计数）替换为Mongoose的`count`方法：
- en: '[PRE100]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We are returning a Promise in `get` (Mongoose, by its asynchronous nature, always
    returns a Promise while making any database's request, as in the example, `Article.count`
    ).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get`中返回一个Promise（Mongoose，由于其异步性质，在进行任何数据库请求时总是返回一个Promise，就像在示例中的`Article.count`一样）。
- en: The method `Article.count` simply retrieves the integer number of articles'
    count from our *Article* model (that was prepared at the beginning of this book
    in `MongoDB/Mongoose sub-chapter` ).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`Article.count`方法只是从我们的*Article*模型中检索文章计数的整数数字（这是在`MongoDB/Mongoose子章节`的开始处准备的）。'
- en: 'The second route `route: ''articles[{integers}]["id","articleTitle","articleContent"]''`
    , has to be changed as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个路由`route: ''articles[{integers}]["id","articleTitle","articleContent"]''`，必须更改如下：'
- en: '[PRE101]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We return a Promise again with `Article.find` . Also, we have deleted the mocked
    response from the database and instead we are using the `Article.find` method.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次返回一个Promise，使用`Article.find`。此外，我们已经从数据库中删除了模拟响应，而是使用`Article.find`方法。
- en: The array of articles is returned in `}).then ((articlesArrayFromDB) => {` and
    next we simply iterate and create a results array.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 文章数组在`}).then((articlesArrayFromDB) => {`中返回，然后我们简单地迭代并创建一个结果数组。
- en: Note that on `const singleArticleObject = articlesArrayFromDB[index].toObject();`
    we use a method `.toObject` . This is very important for making this work.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`const singleArticleObject = articlesArrayFromDB[index].toObject();`中，我们使用了`.toObject`方法。这对于使其工作非常重要。
- en: 读累了记得休息一会哦~
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Double-check with the server/routes.js and package.json
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务器/routes.js和package.json双重检查
- en: 'In order to save you time in case the app doesn''t run, we can double-check
    that the backend''s Falcor routes are prepared correctly:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省您的时间，以防应用程序无法运行，我们可以再次检查后端的Falcor路由是否准备正确：
- en: '[PRE102]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Check that your `server/routes.js` file looks similar to the preceding code
    and the other code elements that you have used.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的`server/routes.js`文件是否与前面的代码和您使用的其他代码元素类似。
- en: 'Also, check that your `package.json` look likes the following one:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 还要检查您的`package.json`是否与以下内容相似：
- en: '[PRE103]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The important thing to notice about `package.json` is that we have removed
    the `^` from `"mongoose": "4.4.5"` . We did this because if NPM installs any higher
    version than `4.4.5` , then we get a warning in the bash/command line.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '关于`package.json`的重要事情是，我们已经从`"mongoose": "4.4.5"`中删除了`^`。我们这样做是因为如果NPM安装的版本高于`4.4.5`，那么我们会在bash/命令行中收到警告。'
- en: Our first working full-stack app
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个工作的全栈应用程序
- en: 'After that, you should have a complete full-stack version of the app working:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该有一个完整的全栈应用程序版本运行：
- en: '![](Image00017.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00017.jpg)'
- en: 'At almost every step, the UI part of our app is identical. The preceding screenshot
    is the publishing app, which does the following:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在每一步，我们应用程序的UI部分都是相同的。前面的截图是发布应用程序，它执行以下操作：
- en: Fetches data from the DB using `Falcor-Express` and `Falcor-Router` .
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Falcor-Express`和`Falcor-Router`从数据库中获取数据。
- en: The data moves from the backend (the source is MongoDB) to the frontend. We
    populate Redux's `src/reducers/article.js` state tree.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据从后端（源是MongoDB）传输到前端。我们填充Redux的`src/reducers/article.js`状态树。
- en: We render the DOM elements based on our single state tree.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据我们的单一状态树渲染DOM元素。
- en: All these steps allow us to take all of the full-stack app's data from the database,
    to the user's browser (so a user can see an article).
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些步骤都允许我们从数据库中获取所有全栈应用程序的数据，传输到用户的浏览器（用户可以看到一篇文章）。
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We haven't started to work on the app design, but in our book, we will use the
    Material Design CSS for React ( [http://material-ui.com](http://material-ui.com)
    ). In the next chapter, we will start using it for user registration and login.
    After that, we will re-style the main page of our application using Material Design's
    components.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有开始设计应用程序，但在我们的书中，我们将使用Material Design CSS for React（[http://material-ui.com](http://material-ui.com)）。在下一章中，我们将开始使用它进行用户注册和登录。之后，我们将使用Material
    Design的组件重新设计应用程序的主页面。
- en: 'In order to give you a teaser of the goal (while working through the book),
    here is a screenshot of the app and how the publishing app will improve in the
    following chapters:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个目标的提示（在阅读本书的过程中），这里有一个应用程序的截图，以及在接下来的章节中发布应用程序将如何改进：
- en: '![](Image00018.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00018.jpg)'
- en: In the preceding screenshot, there is an example article from our application.
    We are using several Material Design components in order to make our work easier
    and the publishing app look more professional. You will learn it later.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，有一个来自我们应用程序的示例文章。我们正在使用几个Material Design组件，以使我们的工作更轻松，使发布应用程序看起来更专业。你以后会学到的。
- en: Are you ready to work on the full-stack login and registration for our publishing
    app in the next chapter? Let's continue the fun.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好在下一章为我们的发布应用程序开发全栈登录和注册功能了吗？让我们继续乐趣吧。
