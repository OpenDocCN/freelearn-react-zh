- en: Understanding GraphQL with a Real Project
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个真实项目了解GraphQL
- en: '**GraphQL** is a query language for APIs that helps them work with your existing
    data. It provides a complete description of the data in your API, and you can
    only request the exact data you need and nothing more. It also makes it easier
    to improve APIs if they need it and has very powerful developer tools.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL**是用于API的查询语言，可以帮助它们与您现有的数据进行交互。它提供了API中数据的完整描述，您只能请求确切需要的数据，而不会多余。它还使得改进API变得更容易，并且具有非常强大的开发人员工具。'
- en: In this chapter, we are going to learn how to use GraphQL in a real project
    by creating a basic login and user registration system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在一个真实项目中使用GraphQL，通过创建一个基本的登录和用户注册系统。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing PostgreSQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: Creating environment variables with a `.env` file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.env`文件创建环境变量
- en: Configuring Apollo Server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Apollo Server
- en: Defining GraphQL queries and mutations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义GraphQL查询和变更
- en: Working with resolvers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与解析器一起工作
- en: Creating Sequelize models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Sequelize模型
- en: Implementing JWTs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施JWT
- en: Using GraphQL Playground
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL Playground
- en: Performing authentication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行身份验证
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: PostgreSQL
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Homebrew  ([https://brew.sh](https://brew.sh))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homebrew ([https://brew.sh](https://brew.sh))
- en: pgAdmin 4 ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pgAdmin 4 ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))
- en: OmniDB ([https://omnidb.org](https://omnidb.org))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OmniDB ([https://omnidb.org](https://omnidb.org))
- en: 'You can find the code for this chapter in this book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中找到本章的代码：[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05)。
- en: Installing PostgreSQL
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: For this example, we will use a PostgreSQL database, so you'll need to install
    PostgreSQL to be able to run this project on your machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用PostgreSQL数据库，因此您需要安装PostgreSQL才能在您的机器上运行此项目。
- en: 'If you have a macOS machine, the easiest way to install PostgreSQL is by doing
    so with Homebrew. You just need to run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一台macOS机器，安装PostgreSQL的最简单方法是使用Homebrew。您只需要运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you''ve installed it, you need to run the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您需要运行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you can create two new aliases to start and stop your PostgreSQL server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建两个新的别名来启动和停止您的PostgreSQL服务器：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, you should be able to start your PostgreSQL server by using `pg_start`
    or stop it with `pg_stop`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够使用`pg_start`启动您的PostgreSQL服务器，或者使用`pg_stop`停止它。
- en: 'After this, you need to create your first database, like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要创建您的第一个数据库，就像这样：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you can connect to PostgreSQL using the `psql` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`psql`命令连接到PostgreSQL。
- en: 'If you get an error stating `role "postgresql" does not exist`, you can fix
    it by running the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到“角色"postgresql"不存在”的错误，请通过运行以下命令来修复它：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you did everything correctly, you should see something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一切都做对了，您应该能看到类似于这样的东西：
- en: '![](assets/34a756a4-ec9b-4a38-8d90-6eb502669329.png)If you use Windows, you
    can download PostgreSQL at [https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)
    and for those that use Linux (Ubuntu), you can download it from [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Windows，你可以在[https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)下载PostgreSQL，而对于使用Linux（Ubuntu）的用户，你可以从[https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/)下载。
- en: Best tools for PostgreSQL database management
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL数据库管理的最佳工具
- en: One of the bests tools for PostgreSQL database management is **pgAdmin 4** ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)).
    I like this tool as it can be used to create new servers, users, and databases.
    The other tool I like to use to perform SQL queries and work with data is **OmniDB**
    ([https://omnidb.org](https://omnidb.org)). I highly recommend that you install
    both tools.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL数据库管理中最好的工具之一是**pgAdmin 4**（[https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)）。我喜欢这个工具，因为它可以用来创建新的服务器、用户和数据库。我喜欢使用的另一个工具是**OmniDB**（[https://omnidb.org](https://omnidb.org)）。我强烈建议你安装这两个工具。
- en: Remember to create a database in order to use it in this example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记得创建一个数据库以便在这个示例中使用。
- en: Sometimes, you may get an error when you start your PostgreSQL server that could
    say something like
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你启动你的PostgreSQL服务器时，你可能会遇到一个错误，它可能会说
- en: '`FATAL: lock file "postmaster.pid" already exists`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`FATAL: lock file "postmaster.pid" already exists`.'
- en: If you get this error, you can easily fix it by running the `rm /usr/local/var/postgres/postmaster.pid`
    command. Then, you will be able to start your PostgreSQL server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到这个错误，你可以通过运行`rm /usr/local/var/postgres/postmaster.pid`命令来轻松修复它。然后，你就可以启动你的PostgreSQL服务器了。
- en: Creating our .env file and configuration files
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的.env文件和配置文件
- en: 'First, you need to create a backend directory in your GraphQL project (`graphql/backend`),
    after that let''s review the huge list of NPM packages you will need to install
    (the most relevant):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在你的GraphQL项目中创建一个后端目录（`graphql/backend`），之后让我们来审查你需要安装的大量NPM包的列表（最相关的）。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The scripts you should have in your `package.json` file should be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`package.json`文件中应该有以下脚本：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the next section, we are going to configure our environment variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将配置我们的环境变量。
- en: Configuring our .env file
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的.env文件
- en: 'A `.env` file (also known as `dotenv`) is a configuration file to specify your
    application''s environment variables. Normally your application won''t change
    from development, staging, or production environments but they normally need a
    different configuration: the most common variables to change are the base URL,
    API URL, or even your API keys.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env`文件（也称为`dotenv`）是一个配置文件，用于指定应用程序的环境变量。通常情况下，你的应用程序不会从开发、暂存或生产环境中改变，但它们通常需要不同的配置：最常见的变量更改是基本URL、API
    URL，甚至是你的API密钥。'
- en: 'Before we jump into the actual login code, we need to create a file called
    `.env` (normally, this file is ignored by `.gitignore`), which will allow us to
    use private data, such as the database connection and security secrets. A file
    already exists in the repository called `.env.example`; you just need to rename
    it and put your connection data inside it. This will look something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际的登录代码之前，我们需要创建一个名为`.env`的文件（通常，这个文件被`.gitignore`忽略），这将允许我们使用私人数据，比如数据库连接和安全秘钥。存储库中已经存在一个名为`.env.example`的文件；你只需要将其重命名并将你的连接数据放入其中。这将看起来像这样：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating a basic config file
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本的配置文件
- en: 'For this project, we need to create a config file, which should be created
    at `/backend/config/config.json`. Here, we will define some basic configurations,
    such as our server''s port and some security information:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要创建一个配置文件，应该创建在`/backend/config/config.json`。在这里，我们将定义一些基本配置，比如我们服务器的端口和一些安全信息：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you need to create an `index.ts` file. This will bring in all the database
    connection information we defined in the `.env` file using the `dotenv` package
    and then export three configuration variables called `$db`, `$security`, and `$server`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要创建一个`index.ts`文件。这将使用`dotenv`包将我们在`.env`文件中定义的所有数据库连接信息导入，并导出三个配置变量，称为`$db`，`$security`和`$server`：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If your `.env` file is not at the root or does not exist, all your variables
    are going to be `undefined`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`.env`文件不在根目录中或不存在，那么所有变量都将是`undefined`。
- en: Configuring Apollo Server
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Apollo Server
- en: Apollo Server is the most popular open source library that works with GraphQL
    (server and client). It has a lot of documentation and is really easy to implement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server是最流行的开源库，可以与GraphQL（服务器和客户端）一起使用。它有很多文档，非常容易实现。
- en: 'The following diagram explains how Apollo Server works in the client and the
    server:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解释了Apollo Server在客户端和服务器中的工作原理：
- en: '![](assets/f53621c2-5f75-4fa9-b8fd-a38cee633d22.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f53621c2-5f75-4fa9-b8fd-a38cee633d22.png)'
- en: 'We are going to use Express to set up our Apollo Server and Sequelize ORM to
    handle our PostgreSQL database. So, initially, we need to do some imports. The
    required file can be found at `/backend/src/index.ts`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Express来设置我们的Apollo Server和Sequelize ORM来处理我们的PostgreSQL数据库。因此，最初，我们需要进行一些导入。所需的文件可以在`/backend/src/index.ts`找到：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, we need to create our schema using `makeExecutableSchema` by passing
    `typeDefs` and `resolvers`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`makeExecutableSchema`创建我们的模式，通过传递`typeDefs`和`resolvers`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we need to create an instance of `ApolloServer`, where we need to pass
    the schema and the models in the context:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个`ApolloServer`的实例，在这里我们需要传递模式和上下文中的模型：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we need to synchronize Sequelize. Here, we are passing some optional
    variables (`alter` and `force`). If `force` is `true` and you change your Sequelize
    models, **this will delete your tables, including their values**, and force you
    to create the tables again, while if `force` is `false` and `alter` is `true`,
    **then you will only update the table fields, without this affecting your values**.
    So, you need to be careful with this option as you can lose all your data by accident.
    Then, after the sync, we must run our Apollo Server, which is listening to port
    `5000` (`$server.port`):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要同步Sequelize。在这里，我们传递了一些可选变量（`alter`和`force`）。如果`force`为`true`并且更改了Sequelize模型，**这将删除您的表，包括它们的值**，并强制您重新创建表，而如果`force`为`false`并且`alter`为`true`，**那么您只会更新表字段，而不会影响您的值**。因此，您需要小心使用此选项，因为您可能会意外丢失所有数据。然后，在同步之后，我们必须运行我们的Apollo
    Server，它正在监听端口`5000`（`$server.port`）：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will help us synchronize our database with our models so that any time
    we make a change to the models, the tables are going to be updated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们将数据库与我们的模型同步，以便每当我们对模型进行更改时，表都将被更新。
- en: Defining our GraphQL types, queries, and mutations
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的GraphQL类型，查询和变异
- en: Now that you've created your Apollo Server instance, you need to create your
    GraphQL types. In this case, we will create some types, queries, and mutations
    for users.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了Apollo Server实例，您需要创建您的GraphQL类型。在这种情况下，我们将为用户创建一些类型，查询和变异。
- en: 'The first thing you need to do is define your scalar types at `/backend/src/graphql/types/Scalar.graphql`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是在`/backend/src/graphql/types/Scalar.graphql`中定义您的标量类型：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s create our `User.graphql` file with our initial `User` type:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`User.graphql`文件，其中包含我们的初始`User`类型：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we are using some scalar types such as `UUID` and `Datetime`
    to define some fields in our `User` type. In this case, when you define a type
    in GraphQL, you need to do so with the `type` keyword, followed by the type's
    name capitalized. Then, you can define your fields inside the curly braces, `{}`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用一些标量类型，如`UUID`和`Datetime`，来定义我们`User`类型中的一些字段。在这种情况下，当您在GraphQL中定义类型时，您需要使用`type`关键字，后跟类型的大写名称。然后，您可以在大括号`{}`中定义您的字段。
- en: There are some primitive data types in GraphQL such as `String`, `Boolean`,
    `Float`, and `Int`. You can define custom scalar types as we did with `UUID`,
    `Datetime`, and `JSON`, and you can also define custom types such as the `User`
    type and specify whether we want an array of that type; for example, `[User]`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中有一些原始数据类型，如`String`、`Boolean`、`Float`和`Int`。您可以像我们使用`UUID`、`Datetime`和`JSON`一样定义自定义标量类型，还可以定义自定义类型，如`User`类型，并指定我们是否需要该类型的数组；例如，`[User]`。
- en: The `!` character after the types means the field is **non-nullable**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型后面的`!`字符表示该字段是**非空**的。
- en: Queries
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: GraphQL queries are used to read or fetch values from a data store.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL查询用于从数据存储中读取或获取值。
- en: 'Now that you know how to define custom types, let''s define our `Query` type.
    Here, we are going to define `getUsers` and `getUserData`. The first will retrieve
    a list of users, while the second will bring us the data of the specific user:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何定义自定义类型了，让我们定义我们的`Query`类型。在这里，我们将定义`getUsers`和`getUserData`。第一个将检索用户列表，而第二个将为我们带来特定用户的数据：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, our `getUsers` query is going to return an array of users (`[User!]`),
    while our `getUserData` query, which requires the `at` (**access token**) attribute,
    will return a single `User!`. Remember that with any query you add here, you will
    need to define it under your resolvers later (we will do that in the next section).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的`getUsers`查询将返回一个用户数组（`[User!]`），而我们的`getUserData`查询，需要`at`（**访问令牌**）属性，将返回一个单一的`User!`。请记住，您在此添加的任何查询，稍后都需要在解析器下定义（我们将在下一节中进行）。
- en: Mutations
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异
- en: 'Mutations are used to write or post values – that is, to modify data in the
    data store – and return a value if you want to do some comparisons with REST,
    such as perform any POST, PUT, or DELETE actions. The `Mutation` type works exactly
    the same as the `Query` type in there you need to define your mutations and specify
    what arguments you will receive and what data you will return:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 变异用于编写或发布值-即修改数据存储中的数据-并在需要执行任何POST、PUT或DELETE操作的情况下返回一个值，如果您想进行一些与REST的比较。`Mutation`类型与`Query`类型完全相同，您需要在其中定义您的变异，并指定您将接收的参数和您将返回的数据：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, we have defined two mutations. The first is `createUser`, to
    register or create a new user in our data store, while the second one is to perform
    a `login`. As you may have noticed, both are receiving the `input` argument with
    some different values (`CreateUserInput` and `LoginInput`), called **input types**,
    which are used as query or mutation parameters. Finally, they will return the
    `User!` type and `AuthPayload!`, respectively. Let''s learn how to define those
    inputs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经定义了两个变异。第一个是`createUser`，用于在我们的数据存储中注册或创建新用户，而第二个是执行`login`。正如您可能已经注意到的，两者都接收了`input`参数，并带有一些不同的值（`CreateUserInput`和`LoginInput`），称为**输入类型**，这些类型用作查询或变异参数。最后，它们将分别返回`User!`类型和`AuthPayload!`。让我们学习如何定义这些输入：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The inputs are normally used with mutations, but you can also use them with
    queries.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输入通常与变异一起使用，但您也可以将其与查询一起使用。
- en: Merging our type definitions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并我们的类型定义
- en: Now that we've defined all our types, queries, and mutations, we need to merge
    all our GraphQL files to create our GraphQL schema, which is basically one big
    file containing all our GraphQL definitions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有的类型、查询和变异，我们需要合并所有的GraphQL文件来创建我们的GraphQL模式，这基本上是一个包含所有我们的GraphQL定义的大文件。
- en: 'For this, you need to create a file called `/backend/src/graphql/types/index.ts`
    that contains the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您需要创建一个名为`/backend/src/graphql/types/index.ts`的文件，其中包含以下代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are using `@graphql-tools` packages to load our GraphQL files and merging
    them into `typesArray` using the `mergeTypesDefs` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`@graphql-tools`包来加载我们的GraphQL文件，并使用`mergeTypesDefs`方法将它们合并到`typesArray`中。
- en: Creating our resolvers
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的解析器
- en: A resolver is a function that's responsible for generating data for a field
    in your GraphQL schema. It can normally generate the data in any way you want,
    in that it can fetch data from a database or by using a third-party API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器是负责为GraphQL模式中的字段生成数据的函数。它通常可以以任何想要的方式生成数据，可以从数据库中获取数据，也可以使用第三方API。
- en: 'To create our user resolvers, you need to create a file called `/backend/src/graphql/resolvers/user.ts`.
    Let''s create a skeleton of what our resolver should look like. Here, we need
    to specify the functions that are defined under `Query` and `Mutation` in our
    GraphQL schema. So, your resolver should look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的用户解析器，您需要创建一个名为`/backend/src/graphql/resolvers/user.ts`的文件。让我们创建一个解析器应该是什么样子的框架。在这里，我们需要指定在我们的GraphQL模式下定义的`Query`和`Mutation`下定义的函数。因此，您的解析器应该如下所示：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we are returning an object with two main nodes called `Query`
    and `Mutation`, and we are mapping the queries and the mutations we defined in
    our GraphQL schema (the `User.graphql` file). Of course, we need to make some
    changes to receive some parameters and return some data, but I wanted to show
    you the basic skeleton of a resolver file first.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们返回了一个具有两个名为`Query`和`Mutation`的主节点的对象，并且我们正在映射我们在GraphQL模式中定义的查询和变异（`User.graphql`文件）。当然，我们需要做一些更改来接收一些参数并返回一些数据，但我想先向您展示解析器文件的基本框架。
- en: 'The first thing you need to do is add some imports to the file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是向文件添加一些导入：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will create the `doLogin` and `getUserBy` functions in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中创建`doLogin`和`getUserBy`函数。
- en: Creating the getUsers query
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建getUsers查询
- en: 'Our first method will be the `getUsers` query. Let''s see how we need to define
    it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个方法将是`getUsers`查询。让我们看看我们需要如何定义它：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In any query or mutation method, we always receive four parameters: the parent
    (defined as **_**), arguments (defined as `args`), the context (defined as `ctx`),
    and `info` (which is optional).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何查询或变异方法中，我们总是接收四个参数：父级（定义为**_**），参数（定义为`args`），上下文（定义为`ctx`）和`info`（可选）。
- en: 'If you want to simplify the code a little bit, you can destructure the context,
    like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想简化代码，可以像这样解构上下文：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our next resolver function, we are going to destructure our arguments as
    well. Just as a reminder, the context is being passed in our Apollo Server setup
    (we did this previously):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一个解析器函数中，我们也将解构我们的参数。作为提醒，上下文是在我们的Apollo Server设置中传递的（我们之前做过这个）：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The context is very important when we need to share something globally in our
    resolvers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在解析器中全局共享一些东西时，上下文非常重要。
- en: Creating the getUserData query
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建getUserData查询
- en: 'This function needs to be async because we need to perform some asynchronous
    operations, such as getting the connected user via an `at` (access token) if a
    user already has a valid session. Then, we can validate whether this is a real
    user by looking at our database. This helps stop people from modifying the cookies
    or trying to do some form of injection. If we don''t find a connected user, then
    we return an object of the user that contains empty data:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要是异步的，因为我们需要执行一些异步操作，比如通过`at`（访问令牌）获取已连接的用户，如果用户已经有一个有效的会话。然后，我们可以通过查看我们的数据库来验证这是否是一个真实的用户。这有助于阻止人们修改cookie或尝试进行某种形式的注入。如果我们找不到已连接的用户，那么我们将返回一个包含空数据的用户对象：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating the mutations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建变异
- en: 'Our mutations are very simple – we just need to execute some functions and
    pass all our arguments by spreading the input value (this is coming from our GraphQL
    schema). Let''s see what our `Mutation` node should look like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变异非常简单-我们只需要执行一些函数并通过扩展输入值传递所有参数（这是来自我们的GraphQL模式）。让我们看看我们的`Mutation`节点应该是什么样子的：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You need to pass the email, password, and models to the `doLogin` function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将电子邮件、密码和模型传递给`doLogin`函数。
- en: Merging our resolvers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并我们的解析器
- en: 'As we did with our types definitions, we need to merge all our resolvers using
    the `@graphql-tools` packages. You need to create the following file at `/backend/src/graphql/resolvers/index.ts`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对类型定义所做的那样，我们需要使用`@graphql-tools`包合并所有我们的解析器。您需要在`/backend/src/graphql/resolvers/index.ts`创建以下文件：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will combine all your resolvers into an array of resolvers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把所有你的解析器合并成一个解析器数组。
- en: Creating Sequelize models
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Sequelize模型
- en: 'Before we jump into the authentication functions, we need to create our `User`
    model in Sequelize. For this, we need to create a file at `/backend/src/models/User.ts`.
    Our model will have the following fields:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入身份验证功能之前，我们需要在Sequelize中创建我们的`User`模型。为此，我们需要在`/backend/src/models/User.ts`创建一个文件。我们的模型将具有以下字段：
- en: '`id`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`'
- en: '`username`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`'
- en: '`password`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`'
- en: '`email`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: '`privilege`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privilege`'
- en: '`active`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`'
- en: 'Let''s see the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we are defining a Sequelize Hook called `beforeCreate`, which
    helps us encrypt (using `sha1`) the user password right before the data is saved.
    Finally, we return the `User` model.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在定义一个名为`beforeCreate`的Sequelize Hook，它在数据保存之前帮助我们加密（使用`sha1`）用户密码。最后，我们返回`User`模型。
- en: Connecting Sequelize to a PostgreSQL database
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Sequelize连接到PostgreSQL数据库
- en: 'Now that we''ve created the user model, we need to connect Sequelize to our
    PostgreSQL database and put all our models together. You need to add the following
    code to the `/backend/src/models/index.ts` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户模型，我们需要将Sequelize连接到我们的PostgreSQL数据库并将所有模型放在一起。您需要将以下代码添加到`/backend/src/models/index.ts`文件中：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Authentication functions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证功能
- en: Step by step, we are putting all the puzzle pieces together. Now, let's look
    at the authentication functions we are using to validate whether a user is connected
    or not and get the user's data. For this, we need to use **JSON Web Tokens** (**JWTs**).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在一步一步地把所有的拼图拼在一起。现在，让我们来看看我们正在使用的身份验证功能，以验证用户是否已连接并获取用户的数据。为此，我们需要使用JSON
    Web Tokens（JWTs）。
- en: What is JSON Web Token?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是JSON Web Token？
- en: '**JWT** is an open standard – RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    – which is useful for transmitting information between parties as a JSON object.
    The advantage of JWTs is that they are digitally signed, which is why they can
    be verified and trusted. It uses the HMAC algorithm to sign the token by using
    a secret or a public key pair using RSA or ECDSA.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT**是一个开放标准 - RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    - 用于在各方之间传输信息作为JSON对象。JWT的优势在于它们是数字签名的，这就是为什么它们可以被验证和信任的原因。它使用HMAC算法通过使用秘密或RSA或ECDSA的公钥对令牌进行签名。'
- en: JWT functions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT功能
- en: 'Let''s create some functions that will help verify a JWT and get the user data.
    For this, we need to create the `jwtVerify`, `getUserData`, and `createToken`
    functions. This file should be created at `/backend/src/lib/jwt.ts`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些函数来帮助验证JWT并获取用户数据。为此，我们需要创建`jwtVerify`，`getUserData`和`createToken`函数。该文件应该在`/backend/src/lib/jwt.ts`中创建：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, `jwt.sign` is used to create a new JWT, while `jwt.verify` is
    used to validate our JWT.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`jwt.sign`用于创建新的JWT，而`jwt.verify`用于验证我们的JWT。
- en: Creating authentication functions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建身份验证功能
- en: 'Now that we''ve created the JWT functions, we need to create some functions
    that will help us log in at `/backend/src/lib/auth.ts`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了JWT功能，我们需要创建一些函数来帮助我们在`/backend/src/lib/auth.ts`登录：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are validating whether the user exists by email, whether the password
    is correct, and whether the account is active in order to create the JWT.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在验证用户是否存在通过电子邮件，密码是否正确，以及账户是否处于活动状态以创建JWT。
- en: Types and interfaces
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型和接口
- en: 'Finally, we need to define our types and interfaces for all our Sequelize models
    and GraphQL inputs. For this, you need to create a file at `/backend/src/types/types.ts`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为所有Sequelize模型和GraphQL输入定义我们的类型和接口。为此，您需要在`/backend/src/types/types.ts`创建一个文件：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s create our interfaces at `/backend/src/types/interfaces.ts`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`/backend/src/types/interfaces.ts`创建我们的接口：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we need to export both files in `/backend/src/types/index.ts`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`/backend/src/types/index.ts`中导出这两个文件：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you need to add more models, remember to always add your types and interfaces
    to those files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要添加更多模型时，请记住始终将您的类型和接口添加到这些文件中。
- en: 'Finally, you need to create your `tsconfig.json` file at the root directory:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在根目录创建您的`tsconfig.json`文件：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we are going to run our project and create our tables.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将运行我们的项目并创建我们的表。
- en: Running our project for the first time
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次运行我们的项目
- en: 'If you followed the previous sections correctly and run the `npm run dev` command,
    you should be able to see that the `Users` table is being created and that Apollo
    Server is running on port `5000`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照前面的部分正确操作并运行`npm run dev`命令，您应该能够看到`Users`表正在被创建，并且Apollo Server正在端口`5000`上运行：
- en: '![](assets/5f430c43-93a6-4a50-ba6f-edeeb9be19f8.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f430c43-93a6-4a50-ba6f-edeeb9be19f8.png)'
- en: 'Now, let''s say that you want to modify your user model and change the `"username"`
    field to `"username2"`. Let''s see what will happen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想修改用户模型并将`"username"`字段更改为`"username2"`。让我们看看会发生什么：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will execute the following SQL query:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行以下SQL查询：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s suppose you changed the `force` constant in your `index.ts` file
    to `true`. The following will happen:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您将`index.ts`文件中的`force`常量更改为`true`。将会发生以下情况：
- en: '![](assets/8beddecf-b8ea-45e8-a30a-de8695d88145.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8beddecf-b8ea-45e8-a30a-de8695d88145.png)'
- en: As you can see, if `force` is `true`, it will execute `DROP TABLE IF EXISTS
    "Users" CASCADE;`. This will completely remove your table and values and then
    recreate your table from scratch. That's why you need to be careful when you use
    the `force` option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果 `force` 是 `true`，它将执行 `DROP TABLE IF EXISTS "Users" CASCADE;`。这将完全删除你的表和值，然后从头开始重新创建你的表。这就是为什么当你使用
    `force` 选项时需要小心。
- en: 'At this point, if you open `http://localhost:5000`, you should be able to see
    your GraphQL Playground:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果你打开 `http://localhost:5000`，你应该能够看到你的GraphQL Playground：
- en: '![](assets/3ff9f5e1-fda9-49ee-8b39-21dcd31a3593.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ff9f5e1-fda9-49ee-8b39-21dcd31a3593.png)'
- en: Now, we are ready to test our queries and mutations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备测试我们的查询和变更。
- en: Testing our GraphQL queries and mutations
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的GraphQL查询和变更
- en: 'Great! At this point, you''re very close to executing your first GraphQL query
    and mutation. The first query we will execute is going to be `getUsers`. The following
    is the correct syntax for running a query:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！此时，你非常接近执行你的第一个GraphQL查询和变更。我们将执行的第一个查询是 `getUsers`。以下是运行查询的正确语法：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you don't have any attribute to pass to the query, you just need to specify
    the name of the query under the `query {...}` block and then specify the fields
    you want to retrieve once you've executed your query. In this case, we want to
    fetch the `id`, `username`, `email`, and `privilege` fields.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有任何属性要传递给查询时，你只需要在 `query {...}` 块下指定查询的名称，然后在执行查询后指定要检索的字段。在这种情况下，我们想要获取
    `id`、`username`、`email` 和 `privilege` 字段。
- en: 'If you run this query, you will probably get an empty array of data. This is
    because we don''t have any users registered yet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个查询，你可能会得到一个空数组的数据。这是因为我们还没有注册任何用户：
- en: '![](assets/ebde4ff2-1a7a-4738-af50-6d465f34a1c7.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ebde4ff2-1a7a-4738-af50-6d465f34a1c7.png)'
- en: 'This means we need to execute our `createUser` mutation in order to register
    our first user. One thing I like about GraphQL Playground is that you have all
    the schema documentation in the DOCS tab on the right-hand side. If you click
    on the DOCS tab, you will see all your queries and mutations listed. Let''s click
    there and select our `createUser` mutation to see what needs to be called and
    what data may be returned:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要执行我们的 `createUser` 变更以注册我们的第一个用户。我喜欢GraphQL Playground的一件事是你可以在右侧的DOCS选项卡中找到所有的模式文档。如果你点击DOCS选项卡，你会看到所有的查询和变更列出来。让我们点击那里并选择我们的
    `createUser` 变更，看看需要调用什么以及可能返回什么数据：
- en: '![](assets/7cc48a8b-a914-4078-9c57-6b96520abc21.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7cc48a8b-a914-4078-9c57-6b96520abc21.png)'
- en: 'As you can see, the `createUser` mutation needs an input argument, which is
    `CreateUserInput`. Let''s click on that input:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`createUser` 变更需要一个输入参数，即 `CreateUserInput`。让我们点击这个输入：
- en: '![](assets/c1ec6778-c671-409b-aad8-d7337661de61.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1ec6778-c671-409b-aad8-d7337661de61.png)'
- en: Awesome! Now, we know that we need to pass the `username`, `password`, `email`,
    `privilege`, and `active` fields in order to create a new user and that we will
    receive the same fields, plus the generated ID, for the user. Let's do this!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们知道我们需要传递 `username`、`password`、`email`、`privilege` 和 `active` 字段以创建一个新用户，并且我们将收到相同的字段，以及用户的生成ID。让我们来做这个！
- en: 'Create a new tab so that you don''t lose the code of your first query and then
    write the mutation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的选项卡，这样你就不会丢失你的第一个查询的代码，然后写下变更：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, your mutation needs to be written under the `mutation {...}`
    block, and you must pass the input argument as an object. Finally, you must specify
    the fields you want to retrieve once the mutation has been executed correctly.
    If everything is OK, you should see something like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你的变更需要写在 `mutation {...}` 块下，并且你必须将输入参数作为对象传递。最后，你必须指定在变更正确执行后要检索的字段。如果一切正常，你应该会看到类似这样的东西：
- en: '![](assets/06124e63-8eaf-4ba4-b5c6-692ca2f79ef8.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/06124e63-8eaf-4ba4-b5c6-692ca2f79ef8.png)'
- en: 'If you''re curious and wish to take a look at the terminal where you''re running
    your Apollo Server, you will see the SQL query that was performed for this user:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇并希望看一下你运行Apollo Server的终端，你会看到为这个用户执行的SQL查询：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `VALUES` variables are handled by Apollo Server, so you won't see the actual
    values in there, but you can find out which operation is being executed in the
    database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`VALUES`变量由Apollo Server处理，所以你在那里看不到实际的值，但你可以找出在数据库中执行的操作。'
- en: Now, go back to your first query (`getUsers`) and run it again!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的第一个查询（`getUsers`）并再次运行它！
- en: '![](assets/1f0832dd-8995-4248-baf9-fb6d4565b703.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f0832dd-8995-4248-baf9-fb6d4565b703.png)'
- en: 'Nice – this is your first query and mutation that have been executed correctly
    in GraphQL. If you want to see this data in your database, you can use OmniDB
    to view your `Users` table in your PostgreSQL database:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不错 - 这是你在GraphQL中第一次正确执行的查询和变异。如果你想在数据库中看到这些数据，你可以使用OmniDB来查看你的PostgreSQL数据库中的`Users`表：
- en: '![](assets/cdb74ae3-3a5f-4d96-b7f4-2b20fa8890d3.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cdb74ae3-3a5f-4d96-b7f4-2b20fa8890d3.png)'
- en: As you can see, our first record has its own `id` field (UUID) and also has
    an encrypted `password` field (do you remember our `beforeCreate` Hook in the
    user model?). By default, Sequelize will create the `createdAt` and `updatedAt`
    fields.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的第一条记录有它自己的`id`字段（UUID），并且还有一个加密的`password`字段（你还记得我们在用户模型中的`beforeCreate`
    Hook吗？）。默认情况下，Sequelize会创建`createdAt`和`updatedAt`字段。
- en: Validations
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: 'As you may recall, regarding our user model, you will want to make sure all
    the validations we did are working fine, such as whether the user is unique or
    whether their email is valid and unique. You just need to execute the exact same
    mutation again:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，关于我们的用户模型，你会想确保我们所做的所有验证都能正常工作，比如用户是否唯一，以及他们的电子邮件是否有效和唯一。你只需要再次执行完全相同的变异：
- en: '![](assets/a9f45ac1-2c20-422e-9aa0-f27175f9dd65.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a9f45ac1-2c20-422e-9aa0-f27175f9dd65.png)'
- en: 'As you can see, we will get a `"username must be unique"` error message because
    we''ve already registered the `"admin"` username. Now, let''s try to change the
    username to `"admin2"` but leave the email as is (`admin@js.education`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们会收到一个“用户名必顺是唯一的”错误消息，因为我们已经注册了“admin”用户名。现在，让我们尝试将用户名更改为“admin2”，但保持电子邮件不变（`admin@js.education`）：
- en: '![](assets/8d918236-1d29-4074-80c2-bcd31fadbcd8.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8d918236-1d29-4074-80c2-bcd31fadbcd8.png)'
- en: 'We will also get an `"email must be unique"` error for the email. Now, try
    to change the email to something invalid, such as `admin@myfakedomain`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会收到一个“电子邮件必须是唯一的”错误。现在，尝试将电子邮件更改为一些无效的内容，比如`admin@myfakedomain`：
- en: '![](assets/c4ae35ab-dd85-4b0e-b04b-7e8e727ec89d.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c4ae35ab-dd85-4b0e-b04b-7e8e727ec89d.png)'
- en: 'Now, we''re getting an `"Invalid email"` error message. This is just amazing,
    don''t you think? Now, let''s stop playing with the validations and add a new
    valid user (`username: admin2`, `email: admin2@js.education`). Once you''ve created
    your second user, run our `getUsers` query once more. However, this time, add
    the `"active"` field to the list of fields we want to return:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们收到了一个“无效的电子邮件”错误消息。这真是太棒了，你不觉得吗？现在，让我们停止玩验证，并添加一个新的有效用户（`username: admin2`，`email:
    admin2@js.education`）。一旦你创建了第二个用户，再次运行我们的`getUsers`查询。然而，这一次，将“active”字段添加到我们想要返回的字段列表中：'
- en: '![](assets/e884bf63-a32e-4c8f-b0c6-7adea767f4aa.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e884bf63-a32e-4c8f-b0c6-7adea767f4aa.png)'
- en: Now, we have two registered users, and both are inactive accounts (`active =
    false`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个注册用户，都是非活跃账户（`active = false`）。
- en: 'One thing I love about GraphQL is that when you''re writing your queries or
    mutations and you don''t remember a certain field, GraphQL will always show you
    the list of available fields for that query or mutation. For example, if you just
    write the letter `p` for the password, you will see something like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢GraphQL的一件事是，当你编写你的查询或突变时，如果你不记得某个字段，GraphQL总是会显示该查询或突变的可用字段列表。例如，如果你只是写了字母`p`作为密码，你会看到类似这样的东西：
- en: '![](assets/44ce1fd2-0f38-44ea-8072-0607a3647109.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/44ce1fd2-0f38-44ea-8072-0607a3647109.png)'
- en: Now, we are ready to try and log in!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备尝试登录！
- en: Performing a login
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行登录
- en: I want to congratulate you for getting to this point in this book – I know we
    have covered a lot, but we are almost there! Now, we are going to try and log
    in with GraphQL (how crazy is that?).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我想祝贺你在这本书中达到了这一点 - 我知道我们已经涵盖了很多内容，但我们几乎到了！现在，我们将尝试使用GraphQL登录（这有多疯狂？）。
- en: 'First, we need to write our login mutation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编写我们的登录突变：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we need to log our user in by using `"fake@email.com"` as our email and
    `"123456"` as our password. These do not exist in our database:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用`"fake@email.com"`作为我们的电子邮件和`"123456"`作为我们的密码来登录我们的用户。这些在我们的数据库中不存在：
- en: '![](assets/2ac6af0e-81ca-4bb4-9c62-74e7c9714aac.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2ac6af0e-81ca-4bb4-9c62-74e7c9714aac.png)'
- en: 'Because the email does not exist in our database, an `"Invalid Login"` error
    message will be returned. Now, let''s add the correct email but use a fake password:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为电子邮件在我们的数据库中不存在，将返回一个`"无效登录"`错误消息。现在，让我们添加正确的电子邮件，但使用一个虚假的密码：
- en: '![](assets/d1e1b450-ddbb-4f87-b953-17c830ef667d.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d1e1b450-ddbb-4f87-b953-17c830ef667d.png)'
- en: As you can see, we are receiving the exact same error (`"Invalid Login"`). This
    is because we don't want to provide too much information about what's wrong with
    the login as someone may be trying to hack another user. If we say something such
    as `"Invalid password"` or `"Your email does not exist in our system"`, we are
    giving the attackers extra information that they may find useful.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们收到了完全相同的错误（`"无效登录"`）。这是因为我们不希望提供关于登录出了什么问题的太多信息，因为有人可能正在尝试黑入另一个用户。如果我们说诸如`"无效密码"`或`"您的电子邮件在我们的系统中不存在"`之类的话，我们就给了攻击者额外的信息，他们可能会发现有用。
- en: 'Now, let''s try to connect with the correct user and password (`admin@js.education
    / 123456`) and see what happens:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用正确的用户和密码（`admin@js.education / 123456`）进行连接，看看会发生什么：
- en: '![](assets/3184a87d-55d9-472d-a074-6694f4d8686e.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3184a87d-55d9-472d-a074-6694f4d8686e.png)'
- en: 'Now, we are receiving an error stating `"Your account is not activated yet"`.
    This is OK because our user has not been activated yet. Normally, when a user
    is registered in a system, you need to send a link to their email so that they
    can activate their account. We don''t have this feature at the moment, but let''s
    suppose we sent that email and the user has already activated their account. We
    can simulate this by manually changing the value in our database using OnmiDB.
    We can do this by performing an `UPDATE` SQL query:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们收到了一个错误，指出`"您的帐户尚未激活"`。这没关系，因为我们的用户还没有被激活。通常，当用户在系统中注册时，您需要发送一个链接到他们的电子邮件，以便他们可以激活他们的帐户。我们目前没有这个功能，但假设我们发送了那封电子邮件，并且用户已经激活了他们的帐户。我们可以通过手动更改我们的数据库中的值来模拟这一点。我们可以通过执行`UPDATE`
    SQL查询来做到这一点：
- en: '![](assets/4592d78c-f4e9-4d76-aa46-fc85a1394287.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4592d78c-f4e9-4d76-aa46-fc85a1394287.png)'
- en: Now, let's try to log in again!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试登录！
- en: '![](assets/111759ec-1952-4aa5-a3c0-0992240a5e26.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/111759ec-1952-4aa5-a3c0-0992240a5e26.png)'
- en: 'Nice – we are in baby! **You at this point**:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 不错 - 我们成功了！**你现在**：
- en: '![](assets/c1670e9c-4548-440a-80a0-9e9baab11647.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1670e9c-4548-440a-80a0-9e9baab11647.jpeg)'
- en: '*We are anonymous, we are legion, we do not forgive, we do not forget, expect
    us!*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们是匿名的，我们是一体的，我们不会原谅，我们不会忘记，期待我们！*'
- en: 'Now that we''ve logged in and retrieved our JWT, let''s copy that huge string
    and use it in our `getUserData` query to see whether we can get the user''s data:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录并检索到了我们的JWT，让我们复制那个巨大的字符串，并在我们的`getUserData`查询中使用它，看看我们是否可以获取用户的数据：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If everything went well, then you should get the user''s data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，那么你应该得到用户的数据：
- en: '![](assets/0b4f0c18-ec40-4914-bca5-119771e37789.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b4f0c18-ec40-4914-bca5-119771e37789.png)'
- en: 'If you change or remove any letter from the string (meaning the token is invalid),
    then you should get empty user data:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你改变或删除字符串中的任何字母（意味着令牌无效），那么你应该得到空的用户数据：
- en: '![](assets/519b4e1e-6271-4d4d-be9a-71ff7e72fcc7.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/519b4e1e-6271-4d4d-be9a-71ff7e72fcc7.png)'
- en: Now that our login system works perfectly in the backend, it is time to implement
    this in the frontend application. We'll do this in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的后端登录系统完美运行，是时候在前端应用程序中实现了。我们将在下一节中进行此操作。
- en: Building a frontend login system with Apollo Client
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo Client构建前端登录系统
- en: In the previous section, we learned how to build the backend for a login system
    using Apollo Server to create our GraphQL queries and mutations. You are probably
    thinking, *Great, I have the backend working, but how can I use this on the frontend?*
    And you're right – I always like to explain things with full examples and not
    just show basic things, even if this will take longer to do, so let's get started!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用Apollo Server构建登录系统的后端，以创建我们的GraphQL查询和变异。你可能会想，“太好了，我已经让后端工作了，但我怎么在前端使用呢？”你是对的
    - 我总是喜欢用完整的例子来解释事情，而不仅仅是展示基本的东西，即使这样做会花费更长的时间，所以让我们开始吧！
- en: You can find the code for the example in this section at [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05/graphql/frontend](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05/graphql/frontend).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本节的示例代码中找到[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05/graphql/frontend](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05/graphql/frontend)。
- en: Configuring Webpack 5
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Webpack 5
- en: Instead of using a `create-react-app`  project, we will configure a React project
    from scratch using Webpack 5 and Node.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再使用`create-react-app`项目，而是使用Webpack 5和Node从头开始配置一个React项目。
- en: 'The first thing we need to do is install all the packages we are going to use:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装我们将要使用的所有软件包：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The buffer,  `crypto-browserify`, and  `stream-browserify`  are polyfills that
    were included by default in Webpack <= 4\. However, in the latest version (Webpack
    5), these are not included anymore, so you will get the following error:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区`crypto-browserify`和`stream-browserify`是Webpack <= 4中默认包含的polyfill。然而，在最新版本（Webpack
    5）中，这些不再包含在内，所以你会得到以下错误：
- en: '![](assets/b89f72fb-3f13-4d52-919d-20fef237f684.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b89f72fb-3f13-4d52-919d-20fef237f684.png)'
- en: 'You need to have those scripts in your `package.json`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的`package.json`中有这些脚本：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s check our Webpack 5 configuration file (`/frontend/webpack.config.ts`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的Webpack 5配置文件（`/frontend/webpack.config.ts`）：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At this point, you need to create the  `index.html`  file, which should be
    at  `/frontend/src/index.html`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您需要创建`index.html`文件，应该在`/frontend/src/index.html`：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the next section, we will configure our TypeScript.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将配置我们的TypeScript。
- en: Configuring our TypeScript
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的TypeScript
- en: 'Our  `tsconfig.json` file should look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`tsconfig.json`文件应该是这样的：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, let's learn how to configure the Express server.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何配置Express服务器。
- en: Configuring the Express server
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Express服务器
- en: 'Our application requires the Express server so that we can perform validations.
    These will help us find out whether the user is connected (using a custom middleware,
    which I''ll explain later) and can also configure our Express sessions. We have
    four main routes on our site:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要Express服务器，以便我们可以进行验证。这将帮助我们找出用户是否已连接（使用自定义中间件，稍后我会解释），还可以配置我们的Express会话。我们网站上有四个主要路由：
- en: '`/`: Our home page  **(handled by React)**.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：我们的主页**(由React处理)**。'
- en: '`/dashboard`: Our dashboard, which is protected. Only connected users with
    god or admin permissions are allowed  **(handled by Express first then by React)**.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dashboard`：我们的仪表板，受保护。只有具有god或admin权限的连接用户被允许**(首先由Express处理，然后由React处理)**。'
- en: '`/login`: Our login page  **(handled by React)**.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/login`：我们的登录页面**(由React处理)**。'
- en: '`/logout`: This will delete our existing session  **(handled by Express)**.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/logout`：这将删除我们现有的会话**(由Express处理)**。'
- en: 'Let''s look at our server code. The following file should exist at  `/frontend/src/server.ts`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的服务器代码。以下文件应存在于`/frontend/src/server.ts`：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, we are protecting our dashboard route with the  `isConnected`  middleware.
    Here, we are validating that we only accept users that are not connected in the
    `login` route.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在使用`isConnected`中间件保护我们的仪表板路由。在这里，我们正在验证我们只接受在`login`路由中未连接的用户。
- en: Creating our frontend configuration
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的前端配置
- en: 'Now, we need to create our frontend configuration. So, let''s create the  `common.json`  configuration
    at  `/frontend/src/config/common.json`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的前端配置。因此，让我们在`/frontend/src/config/common.json`创建`common.json`配置：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s create our  `local.json` file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`local.json`文件：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we need to create our  `production.json` file; for now since we don''t
    have an actual production environment we will use the same localhost URL, but
    once you put this project in a production environment then you will need to change
    it for the actual domain name:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的`production.json`文件；目前，由于我们没有实际的生产环境，我们将使用相同的本地主机URL，但是一旦将此项目放入生产环境中，您将需要更改为实际的域名：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we''ve defined our configuration files, we need to create an  `index.ts`  file
    so that we can merge and export our configuration as an object:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的配置文件，我们需要创建一个`index.ts`文件，以便我们可以将我们的配置合并并导出为一个对象：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we need to create a user called `middleware`  and the  `jwt`  functions
    to validate whether the user is connected and has the correct privileges.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为`middleware`的用户和`jwt`函数，以验证用户是否已连接并具有正确的权限。
- en: Creating the user middleware
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户中间件
- en: 'A middleware is a function that has access to the request object (req), the
    response object (res), and the next function in the application''s request-response
    cycle. The next function is a function in the Express router that, when invoked,
    executes the middleware succeeding the current middleware. The following diagram
    describes the middleware flow:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一个函数，可以访问请求对象（req）、响应对象（res）和应用程序请求-响应周期中的下一个函数。当调用时，next函数是Express路由中的一个函数，执行当前中间件后继的中间件。以下图表描述了中间件流程：
- en: '![](assets/f353071c-3986-4906-ab1d-43ad4fa4c0db.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f353071c-3986-4906-ab1d-43ad4fa4c0db.png)'
- en: In our  case, we will create the  `isConnected`  middleware to validate if a
    user is connected and has the correct privileges. If not, then we will break the
    flow and redirect them to the login page. If the user is valid, we will execute
    the next piece of middleware, which will render our React application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将创建`isConnected`中间件，以验证用户是否已连接并具有正确的权限。如果没有，我们将中断流程并将其重定向到登录页面。如果用户有效，我们将执行下一个中间件，这将呈现我们的React应用程序。
- en: 'The following diagram describes this process:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了这个过程：
- en: '![](assets/941997a7-1499-45cc-b9a3-45511468fce2.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/941997a7-1499-45cc-b9a3-45511468fce2.png)'
- en: 'Let''s apply the theoretical part to our code. The required file should exist
    at  `/frontend/src/lib/middlewares/user.ts`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将理论部分应用到我们的代码中。所需的文件应该存在于`/frontend/src/lib/middlewares/user.ts`中：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Basically, with this middleware, we can control whether we want to validate
    whether the user is connected (`isLogged = true`). Then, we can validate specific
    privileges (`privileges = ['god', 'admin']`) and redirect the user if they are
    not connected or do not have the correct privileges (`redirectTo = '/'`).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，通过这个中间件，我们可以控制是否要验证用户是否连接（`isLogged = true`）。然后，我们可以验证特定的特权（`privileges
    = ['god', 'admin']`）并重定向用户，如果他们没有连接或没有正确的特权（`redirectTo = '/'`）。
- en: As you can see, we are using the `getUserData` function from  `jwt`. We'll create
    our  `jwt`  functions in the next section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在使用`jwt`中的`getUserData`函数。我们将在下一节中创建我们的`jwt`函数。
- en: Creating JWT functions
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建JWT函数
- en: 'In the previous section, when I explained the backend code, I talked about
    JWTs. In the frontend, we need those functions to validate our token and get the
    user''s data. Let''s create a file containing the following code at  `/frontend/src/lib/jwt.ts`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，当我解释后端代码时，我谈到了JWT。在前端，我们需要这些函数来验证我们的令牌并获取用户的数据。让我们在`/frontend/src/lib/jwt.ts`中创建一个包含以下代码的文件：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, our `getUserData` function will retrieve the user data using
    `accessToken`, which we grabbed from the cookies. It is important that the JWT
    is valid.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`getUserData`函数将使用从cookies中获取的`accessToken`来检索用户数据。JWT的有效性非常重要。
- en: Creating our GraphQL queries and mutations
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的GraphQL查询和变异
- en: We've already created the required queries and mutations in our backend project.
    At this point, we need to create some files that will execute them in our frontend
    project. For now, we just need to define our  `getUserData`  query and our login
    mutation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在后端项目中创建了所需的查询和变异。在这一点上，我们需要创建一些文件来在前端项目中执行它们。现在，我们只需要定义我们的`getUserData`查询和我们的登录变异。
- en: 'Let''s create our  `getUserData`  query at  `/frontend/src/graphql/user/getUserData.query.ts`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/frontend/src/graphql/user/getUserData.query.ts`中创建我们的`getUserData`查询：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our login mutation should be at  `/frontend/src/graphql/user/login.mutation.ts`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录变异应该在`/frontend/src/graphql/user/login.mutation.ts`中。
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we have defined our query and mutation, let's create the user context
    so that we can use them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的查询和变异，让我们创建用户上下文，以便我们可以使用它们。
- en: Creating our user context to handle the login and the connected user
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的用户上下文来处理登录和连接的用户
- en: In our user context, we are going to have a login method that will execute our
    mutation and validate whether the email and password are correct. We are also
    going to export the user data.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用户上下文中，我们将有一个登录方法，将执行我们的变异，并验证电子邮件和密码是否正确。我们还将导出用户数据。
- en: 'Let''s create this context at  `/frontend/src/contexts/user.tsx`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/frontend/src/contexts/user.tsx`中创建这个上下文：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, we are handling the login and got the  `connectedUser`  data
    in our context. Here, we are executing `GET_USER_DATA_QUERY` all the time to verify
    whether the user is connected (validating against the database and not just with
    the cookies).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在处理登录并在我们的上下文中获取`connectedUser`数据。在这里，我们一直执行`GET_USER_DATA_QUERY`来验证用户是否连接（验证数据库而不仅仅是使用cookies）。
- en: Configuring our Apollo Client
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的Apollo客户端
- en: 'So far, we have created a lot of code, but none of it is going to work if we
    don''t configure our Apollo Client. To configure it, we need to add it to our
    index file at  `/frontend/src/index.tsx`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了很多代码，但如果我们不配置我们的Apollo客户端，它们中的任何一个都不会起作用。要配置它，我们需要将它添加到我们的索引文件中`/frontend/src/index.tsx`：
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Basically, we are passing `config.apiUrl`, which is where GraphQL Playground
    is running (`http://localhost:5000/graphql`), and then wrapping our  `AppRoutes`  component
    with the  `ApolloProvider`  component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在传递`config.apiUrl`，这是GraphQL Playground正在运行的地方（`http://localhost:5000/graphql`），然后用`ApolloProvider`组件包装我们的`AppRoutes`组件。
- en: Creating our app routes
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的应用程序路由
- en: 'We are going to use  `react-router-dom`  to create our application routes.
    Let''s create the required code at  `/frontend/src/AppRoutes.tsx`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`react-router-dom`来创建我们的应用程序路由。让我们在`/frontend/src/AppRoutes.tsx`中创建所需的代码：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, we are adding some pages to our routes, such as `HomePage`,  `DashboardPage`  (protected),
    and  `LoginPage`. If the user tries to access a different URL, then we will display
    an  `Error404`  component. We'll create these pages in the next section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在为我们的路由添加一些页面，比如`HomePage`，`DashboardPage`（受保护），和`LoginPage`。如果用户尝试访问不同的URL，那么我们将显示一个`Error404`组件。我们将在下一节创建这些页面。
- en: Creating our pages
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的页面
- en: 'The  Home  page should be at  `/frontend/src/pages/home.tsx`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home`页面应该位于`/frontend/src/pages/home.tsx`：'
- en: '[PRE60]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The  Dashboard  page should be at  `/frontend/src/pages/dashboard.tsx`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dashboard`页面应该位于`/frontend/src/pages/dashboard.tsx`：'
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The  Login  page should be at  `/frontend/src/pages/login.tsx`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login`页面应该位于`/frontend/src/pages/login.tsx`：'
- en: '[PRE62]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we need to create our  `Error404`  page (`/frontend/src/pages/error404.tsx`):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建我们的`Error404`页面（`/frontend/src/pages/error404.tsx`）：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We are almost done. The last piece of this puzzle is to create the  `Login`  and
    `Dashboard`  components. We'll do that in the next section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了。这个谜题的最后一块是创建`Login`和`Dashboard`组件。我们将在下一节完成。
- en: Creating our Login components
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的登录组件
- en: I created some basic components for our login and our dashboard. Of course,
    their styles can be improved, but let's see how they work and how our login system
    is going to look.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我们的登录和仪表板创建了一些基本组件。当然，它们的样式可以改进，但让我们看看它们是如何工作的，以及我们的登录系统将会是什么样子。
- en: 'The first file you need to create is called `LoginLayout.tsx`  at `/frontend/src/components/users/LoginLayout.tsx`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建的第一个文件是`LoginLayout.tsx`，位于`/frontend/src/components/users/LoginLayout.tsx`：
- en: '[PRE64]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The layout file is good when we want to add a specific layout to our components.
    It is also good for consuming data from a context and passing the data or functions
    as props.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件很好，当我们想要为我们的组件添加特定的布局时。它也很适合从上下文中消费数据并将数据或函数作为props传递。
- en: 'Our  `Login`  component should look like this (`/frontend/src/components/users/Login.tsx`):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Login`组件应该像这样（`/frontend/src/components/users/Login.tsx`）：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We'll create the `Dashboard` components in the next section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节创建`Dashboard`组件。
- en: Creating our Dashboard components
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的仪表板组件
- en: 'Now, let''s create our  `Dashboard`  components. The first one should be the  `DashboardLayout.tsx`
    file at `/frontend/src/components/dashboard/DashboardLayout.tsx`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`Dashboard`组件。第一个应该是`DashboardLayout.tsx`文件，位于`/frontend/src/components/dashboard/DashboardLayout.tsx`：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is how we protect our  Dashboard  page to allow only connected users.
    Now, let''s create our  `Dashboard`  component at `/frontend/src/components/dashboard/Dashboard.tsx`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何保护我们的`Dashboard`页面，只允许连接的用户。现在，让我们在`/frontend/src/components/dashboard/Dashboard.tsx`中创建我们的`Dashboard`组件：
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: And with that, we're done! We'll test the login system in the next section.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了！我们将在下一节测试登录系统。
- en: Testing our login system
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的登录系统
- en: 'If you followed the previous sections correctly, then you should be able to
    run the login system successfully. To do this, we need to open three terminals:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地按照前面的部分进行了操作，那么您应该能够成功运行登录系统。为此，我们需要打开三个终端：
- en: In the first one, you need to run your backend project (`npm run dev`).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个终端中，您需要运行您的后端项目（`npm run dev`）。
- en: In the second one in your frontend project, you need to build your project (`npm
    run build`).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的前端项目中的第二个中，你需要构建你的项目 (`npm run build`)。
- en: In the last one, you need to run the node server in the frontend project (`npm
    run dev`).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一个中，你需要在前端项目中运行节点服务器 (`npm run dev`)。
- en: 'When you open `http://localhost:3000` for the first time, you should be able
    to see the Home page:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开 `http://localhost:3000` 时，你应该能够看到主页：
- en: '![](assets/300b98ca-c7dc-4116-9b17-2417f87a0e27.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/300b98ca-c7dc-4116-9b17-2417f87a0e27.png)'
- en: 'Then, if you click on the  Go to Dashboard  (`http://localhost:3000/dashboard`)  link,
    you will be redirected to `http://localhost:3000/login?redirectTo=/dashboard`,
    as shown in the following screenshot:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你点击  转到仪表板  (`http://localhost:3000/dashboard`) 链接，你将被重定向到 `http://localhost:3000/login?redirectTo=/dashboard`，如下面的截图所示：
- en: '![](assets/215eb66b-b6f9-4eaa-9070-f49f202e3b27.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/215eb66b-b6f9-4eaa-9070-f49f202e3b27.png)'
- en: 'This is our login form. If you try to log in with some fake credentials, you
    should get an error:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的登录表单。如果你尝试用一些虚假的凭据登录，你应该会收到一个错误：
- en: '![](assets/44a235c3-665c-4d3c-92a5-11de5afec9bc.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/44a235c3-665c-4d3c-92a5-11de5afec9bc.png)'
- en: 'If you want to see the GraphQL request, you can do so on the Chrome Network
    tab:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看 GraphQL 请求，你可以在 Chrome 网络选项卡上这样做：
- en: '![](assets/edf13895-ebe2-4975-8585-97dd94bb7752.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edf13895-ebe2-4975-8585-97dd94bb7752.png)'
- en: 'Here, you can see the query you''re executing and the variables you''re sending
    (email and password). You can see the response on the  Preview  tab:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到你正在执行的查询以及你正在发送的变量（电子邮件和密码）。你可以在  预览  选项卡上看到响应：
- en: '![](assets/b9ef4f2e-65f3-47ae-9746-822ac1ac45cf.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b9ef4f2e-65f3-47ae-9746-822ac1ac45cf.png)'
- en: As you can see, we are getting an `"Invalid Login"` error message, and that's
    why we are rendering it in our  `Login`  component. Now, let's try to connect
    with the correct account (`admin@js.education / 123456`).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，我们收到了一个 "无效登录" 的错误消息，这就是为什么我们在我们的  `Login`  组件中呈现它。现在，让我们尝试用正确的帐户连接
    (`admin@js.education / 123456`)。 '
- en: 'If your login is correct, then you should be redirected to the dashboard, where
    you will see the following page:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的登录是正确的，那么你应该被重定向到仪表板，你将看到以下页面：
- en: '![](assets/a99ef623-b988-4ca3-a9db-4dc8011b4ad7.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a99ef623-b988-4ca3-a9db-4dc8011b4ad7.png)'
- en: 'Also, you can take a look at the query that is being executed to retrieve the
    user data (`getUserData`):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以看一下正在执行以检索用户数据的查询 (`getUserData`)：
- en: '![](assets/c65ff951-c095-4049-9389-0a603375be0e.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c65ff951-c095-4049-9389-0a603375be0e.png)'
- en: 'Here, you will see that the payload is being returned:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将看到返回的有效负载：
- en: '![](assets/fb078044-e451-4e0e-9d62-c0f539471caa.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb078044-e451-4e0e-9d62-c0f539471caa.png)'
- en: 'We are getting the user information from the access token (`at`). Now, if you
    refresh the page, you should remain connected to the page. This is because we
    saved a cookie containing our token:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从访问令牌 (`at`) 中获取用户信息。现在，如果你刷新页面，你应该保持连接到页面。这是因为我们保存了一个包含我们令牌的 cookie：
- en: '![](assets/c7d2fe96-af44-479f-a81b-5b0587730ea0.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c7d2fe96-af44-479f-a81b-5b0587730ea0.png)'
- en: 'Now, let''s try to modify the cookie by changing any letter of the token. For
    example, let''s change the first two letters (`ey`) to  `XX`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过改变令牌的任意字母来修改 cookie。例如，让我们把前两个字母 (`ey`) 改成 `XX`：
- en: '![](assets/27a38ecb-0983-426c-82fe-450799d78762.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/27a38ecb-0983-426c-82fe-450799d78762.png)'
- en: 'Here, you will receive empty data for the user. This is going to invalidate
    the session and redirect you to the login page again:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将收到用户的空数据。这将使会话失效并再次将你重定向到登录页面：
- en: '![](assets/5733fbfd-0098-458b-9861-e814f0eca71b.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5733fbfd-0098-458b-9861-e814f0eca71b.png)'
- en: At this point, you have learned how to implement GraphQL in a backend and how
    to consume queries and mutations in the frontend.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何在后端实现 GraphQL 以及如何在前端消耗查询和变异。
- en: This login system is part of a course I'm doing on YouTube where I'm teaching
    viewers how to develop a headless CMS from scratch, so if you're eager to learn
    more, you can check out the course at [https://www.youtube.com/watch?v=4n1AfD6aV4M](https://www.youtube.com/watch?v=4n1AfD6aV4M).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个登录系统是我在YouTube上做的一个课程的一部分，我在课程中教观众如何从头开始开发一个无头CMS，所以如果你渴望学到更多，可以在[https://www.youtube.com/watch?v=4n1AfD6aV4M](https://www.youtube.com/watch?v=4n1AfD6aV4M)上查看课程。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I really hope you enjoyed reading this chapter, which contained a lot of information
    about GraphQL and how to create JWTs, perform a login, and create models with
    Sequelize.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的希望你喜欢阅读这一章，其中包含了关于GraphQL以及如何创建JWT、执行登录和使用Sequelize创建模型的大量信息。
- en: It is now time to talk about data fetching and one-way data flow, which is what
    we will look at in the next chapter.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候谈谈数据获取和单向数据流了，这是我们将在下一章中讨论的内容。
