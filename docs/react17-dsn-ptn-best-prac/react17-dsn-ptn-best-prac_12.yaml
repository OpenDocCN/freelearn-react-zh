- en: Server-Side Rendering for Fun and Profit
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 为了乐趣和利润进行服务器端渲染
- en: The next step in building React applications is learning how server-side rendering
    works and what benefits it can give us. The **u****niversal applications**  are
    better for SEO, and they enable knowledge-sharing between the frontend and the
    backend. They can also improve the perceived speed of a web application, which
    usually leads to increased conversions. However, applying server-side rendering
    to a React application comes at a cost, and we should think carefully about whether
    we need it or not.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建React应用程序的下一步是学习服务器端渲染的工作原理以及它可以给我们带来的好处。**通用应用程序**对于SEO更好，并且它们可以在前端和后端之间实现知识共享。它们还可以提高Web应用程序的感知速度，通常会导致转化率的提高。然而，将服务器端渲染应用于React应用程序是有成本的，我们应该仔细考虑是否需要它。
- en: In this chapter, you will see how to set up a server-side rendered application,
    and by the end of the relevant sections, you will be able to build a universal
    application and understand the pros and the cons of the technique.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到如何设置服务器端渲染应用程序，并在相关部分结束时，您将能够构建一个通用应用程序，并了解该技术的利弊。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding what a universal application is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解通用应用程序是什么
- en: Figuring out the reasons why we may want to enable server-side rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚为什么我们可能希望启用服务器端渲染
- en: Creating a simple static server-side rendered application with React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React创建一个简单的静态服务器端渲染应用程序
- en: Adding data fetching to server-side rendering and understanding concepts such
    as dehydration/hydration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据获取添加到服务器端渲染，并理解脱水/水合等概念
- en: Using  **Next.js**  by Zeith to easily create a React application that runs
    on both the server and the client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zeith的**Next.js**轻松创建在服务器端和客户端上运行的React应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You can find the code for this chapter in the book's GitHub repository at [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter09).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍的GitHub存储库中找到本章的代码，网址为[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter09)。
- en: Understanding universal applications
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通用应用程序
- en: A universal application is an application that can run both on the server side
    and client side with the same code. In this section, we will look at the reasons
    why we should consider making our applications universal, and we will learn how
    React components can be easily rendered on the server side.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用程序是一种可以在服务器端和客户端上运行相同代码的应用程序。在本节中，我们将看看为什么要考虑使我们的应用程序通用，并学习如何在服务器端轻松渲染React组件。
- en: When we talk about JavaScript web applications, we usually think of client-side
    code that lives in the browser. The way they usually work is that the server returns
    an empty HTML page with a `script` tag to load the application. When the application
    is ready, it manipulates the DOM inside the browser to show the UI and to interact
    with users. This has been the case for the last few years, and it is still the
    way to go for a huge number of applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论JavaScript Web应用程序时，通常会想到存在于浏览器中的客户端代码。它们通常的工作方式是，服务器返回一个空的HTML页面，其中包含一个`script`标签来加载应用程序。当应用程序准备就绪时，它会在浏览器内部操作DOM以显示UI并与用户交互。这已经是过去几年的情况了，对于大量应用程序来说，这仍然是一种行之有效的方式。
- en: In this book, we have seen how easy it is to create applications using React
    components and how they work within the browser. What we have not seen yet is
    how React can render the same components on the server, giving us a powerful feature
    called **Server-Side Rendering** (**SSR**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经看到使用React组件创建应用程序是多么容易，以及它们在浏览器中的工作原理。我们还没有看到的是React如何在服务器上渲染相同的组件，为我们提供了一个称为**服务器端渲染**（**SSR**）的强大功能。
- en: 'Before going into the details, let''s try to understand what it means to create
    applications that render both on the server and the client. For years, we used
    to have completely different applications for the server and client: for example,
    a Django application to render the views on the server, and some JavaScript frameworks,
    such as Backbone or jQuery, on the client. Those separate apps usually had to
    be maintained by two teams of developers with different skill sets. If you needed
    to share data between the server-side rendered pages and the client-side application,
    you could inject some variables inside a script tag. Using two different languages
    and platforms, there was no way to share common information, such as models or
    views, between the different sides of the application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们试着理解在服务器和客户端上都渲染应用程序意味着什么。多年来，我们习惯于为服务器和客户端拥有完全不同的应用程序：例如，使用Django应用程序在服务器上渲染视图，以及一些JavaScript框架，如Backbone或jQuery，在客户端上。这些独立的应用程序通常需要由具有不同技能的两个开发团队进行维护。如果需要在服务器端渲染的页面和客户端应用程序之间共享数据，可以在脚本标签中注入一些变量。使用两种不同的语言和平台，没有办法在应用程序的不同方面共享通用信息，如模型或视图。
- en: Since Node.js was released in 2009, JavaScript has gained a lot of attention  and
    popularity on the server side as well, thanks to web application frameworks, such
    as  **Express**. Using the same language on both sides not only makes it easy
    for developers to reuse their knowledge, but also enables different ways of sharing
    code between the server and the client.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Node.js在2009年发布以来，JavaScript在服务器端也因为诸如**Express**等Web应用程序框架而受到了很多关注和流行。在两端使用相同的语言不仅使开发人员可以轻松重用他们的知识，还可以在服务器和客户端之间实现不同的代码共享方式。
- en: With React in particular, the concept of isomorphic web applications became
    very popular within the JavaScript community. Writing an  **isomorphic application**  means
    building an application  that looks the same on the server and the client. The
    fact that the same language is used to write the two applications means that a
    big part of the logic can be shared, which opens many possibilities. This makes
    the code base easier to reason about and avoids unnecessary duplication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在React中，同构Web应用程序的概念在JavaScript社区内非常流行。编写一个**同构应用程序**意味着构建一个在服务器和客户端上看起来相同的应用程序。使用相同的语言编写两个应用程序意味着可以共享大部分逻辑，这开启了许多可能性。这使得代码库更容易理解，并避免不必要的重复。
- en: React brings the concept a step forward, giving us a simple API to render our
    components on the server and transparently applying all the logic needed to make
    the page interactive (for example, event handlers) on the browser.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React将这个概念推进了一步，为我们提供了一个简单的API，在服务器上渲染我们的组件，并透明地应用所有必要的逻辑，使页面在浏览器上变得交互（例如，事件处理程序）。
- en: 'The term *isomorphic* does not fit in this scenario because, in the case of
    React, the applications are the same, and that is why one of the creators of React
    Router, Michael Jackson, proposed a more meaningful name for this pattern: **Universal**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*同构*在这种情况下并不适用，因为在React的情况下，应用程序是相同的，这就是为什么React Router的创始人之一Michael Jackson提出了这种模式更有意义的名称：**Universal**。
- en: Reasons for implementing SSR
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施SSR的原因
- en: SSR is a great feature, but we should not jump into it just for the sake of
    it. We should have a real and solid reason to start using it. In this section,
    we will look at how SSR can help our application and what problems it can solve
    for us. In our next sections, we are going to learn about SEO and how to improve
    the performance of our application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SSR是一个很棒的功能，但我们不应该只是为了它而盲目使用。我们应该有一个真正坚实的理由开始使用它。在本节中，我们将看看SSR如何帮助我们的应用程序以及它可以为我们解决什么问题。在接下来的部分中，我们将学习关于SEO以及如何提高我们应用程序的性能。
- en: Implementing search engine optimization
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施搜索引擎优化
- en: One of the main reasons why we may want to render our applications  on the server
    side is **S****earch Engine Optimization** (**SEO**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在服务器端渲染我们的应用程序的一个主要原因是搜索引擎优化（SEO）。
- en: If we serve an empty HTML skeleton to the crawlers of the main search engines,
    they are not able to extract any meaningful information from it. Nowadays, Google
    seems to be able to run JavaScript, but there are some limitations, and SEO is
    often a critical aspect of our businesses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向主要搜索引擎的网络爬虫提供一个空的HTML骨架，它们将无法从中提取任何有意义的信息。如今，Google似乎能够运行JavaScript，但存在一些限制，而SEO通常是我们业务的关键方面。
- en: 'For years, we used to write two applications: an SSR one for the crawlers,
    and another one to be used on the client side by users. We used to do that because
    SSR applications could not give us the level of interactivity users expect, while
    client-side applications  did not get indexed by search engines.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们习惯于编写两个应用程序：一个用于网络爬虫的SSR应用程序，另一个供用户在客户端使用。我们过去这样做是因为SSR应用程序无法给我们提供用户期望的交互水平，而客户端应用程序无法被搜索引擎索引。
- en: Maintaining and supporting two applications is difficult, and makes the code
    base less flexible and less prone to changes. Luckily, with React, we can render
    our components on the server side and serve the content of our applications to
    the crawlers in such a way that it is easy for them to understand and index the
    content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 维护和支持两个应用程序是困难的，使代码库不够灵活，也不够容易更改。幸运的是，有了React，我们可以在服务器端渲染我们的组件，并以一种易于理解和索引内容的方式为网络爬虫提供我们应用程序的内容。
- en: This is great, not only for  SEO,  but also for social sharing services. Platforms
    such as Facebook or Twitter give us a way of defining the content of the snippets
    that are shown when our pages are shared.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅对SEO有好处，也对社交分享服务有好处。Facebook或Twitter等平台为我们提供了一种定义在页面被分享时显示的片段内容的方式。
- en: For example, using Open Graph, we can tell Facebook that, for a particular page,
    we want a certain image to be shown and a particular title to be used as the title
    of the post. It is almost impossible to do that using client-side-only  applications  because
    the engine that extracts the information from the pages uses the markup returned
    by the server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用Open Graph，我们可以告诉Facebook，对于特定页面，我们希望显示特定的图片，并使用特定的标题作为帖子的标题。使用仅客户端的应用程序几乎不可能做到这一点，因为从页面中提取信息的引擎使用服务器返回的标记。
- en: If our server returns an empty HTML structure for all the URLs, the result is
    that when the pages are shared on the social networks, the snippets of our web
    application are empty as well, which affects their virality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务器对所有URL返回一个空的HTML结构，那么当页面在社交网络上分享时，我们的Web应用程序的片段也会是空的，这会影响它们的传播。
- en: A common code base
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共同的代码库
- en: We do not have many options on the client side; our applications have to be
    written in JavaScript. There are some languages that can be converted into JavaScript
    at build time, but the concept does not change. The ability to use the same language
    on the server represents a significant win regarding maintainability and knowledge-sharing
    across the company.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在客户端没有太多选择；我们的应用程序必须用JavaScript编写。有一些语言可以在构建时转换为JavaScript，但概念并未改变。在服务器端使用相同的语言的能力在维护性和公司内部知识共享方面具有重大优势。
- en: Being able to share the logic between the client and the server makes it easy
    to apply any changes on both sides without doing the work twice, which, most of
    the time, leads to fewer errors and fewer problems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在客户端和服务器之间共享逻辑使得在两侧应用任何更改变得容易，而不必做两次工作，这在大多数情况下会导致更少的错误和问题。
- en: The effort of maintaining a single code  base  is less than the work required
    to keep two different applications up to date. Another reason why you might consider
    introducing JavaScript on the server side in your team is sharing knowledge between
    frontend and backend developers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 维护单一代码库的工作量要少于保持两个不同应用程序最新所需的工作量。你可能考虑在团队中引入服务器端JavaScript的另一个原因是前端和后端开发人员之间的知识共享。
- en: The ability to reuse the code on both sides makes collaboration easier, and
    the teams speak a common language, which helps with making faster decisions and
    changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在两侧重用代码的能力使得协作更容易，团队使用共同的语言，这有助于更快地做出决策和更改。
- en: Better performance
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的性能
- en: Last, but not least, we all love client-side applications, because they are
    fast and responsive, but there is a problem—the bundle has to be loaded and run
    before users can take any action on the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们都喜欢客户端应用程序，因为它们快速且响应迅速，但存在一个问题——必须在用户可以在应用程序上采取任何操作之前加载和运行捆绑包。
- en: This might not be a problem using a modern laptop or a desktop computer on a
    fast internet connection. However, if we load a huge JavaScript bundle using a
    mobile device with a 3G connection, users have to wait for a little while before
    interacting with the application. This is not only bad for the UX in general,
    but it also affects conversions. It has been proven by the major e-commerce websites
    that a few milliseconds added to the page load can have an enormous  impact on
    revenues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代笔记本电脑或桌面计算机上使用快速互联网连接可能不是问题。然而，如果我们在使用3G连接的移动设备上加载一个巨大的JavaScript捆绑包，用户必须等待一小段时间才能与应用程序进行交互。这不仅对用户体验不利，而且还会影响转化率。大型电子商务网站已经证明，页面加载时间增加几毫秒可能会对收入产生巨大影响。
- en: For example, if we serve our application with an empty HTML page and a  `script`  tag
    on the server and we show a spinner to our users until they can click on anything,
    the perception of the speed of the website is significantly affected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在服务器上用一个空的HTML页面和一个`script`标签提供我们的应用程序，并在用户点击任何内容之前向他们显示一个旋转器，那么网站速度的感知性会受到显着影响。
- en: If we render our website on the server side instead and users start seeing some
    of the content as soon as they hit the page, they are more likely to stay, even
    if they have to wait the same amount of time before doing anything for real, because
    the client-side bundle has to be loaded regardless of the SSR.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在服务器端呈现我们的网站，用户在点击页面后立即开始看到一些内容，即使他们在真正做任何事情之前必须等待同样长的时间，他们也更有可能留下来，因为无论如何都必须加载客户端捆绑包。
- en: This perceived performance is something we can improve greatly using SSR because
    we can output our components on the server and return some information to users
    straight away.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种感知性能是我们可以通过使用SSR大大改善的，因为我们可以在服务器上输出我们的组件并立即向用户返回一些信息。
- en: Don't underestimate the complexity
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要低估复杂性
- en: Even if React provides  an easy API to render components on the server, creating
    a universal application has a cost. So, we should consider carefully before enabling
    it for one of the preceding reasons and check whether our team is ready to support
    and maintain a universal application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使React提供了一个简单的API来在服务器上渲染组件，创建一个通用应用程序是有成本的。因此，我们应该在启用之前仔细考虑上述原因之一，并检查我们的团队是否准备好支持和维护通用应用程序。
- en: As we will see in the coming sections, rendering components is not the only
    task that needs to be done to create server-side rendered applications. We have
    to set up and maintain a server with its routes and its logic, manage the server
    data flow, and so on. Potentially, we want to cache the content to serve the pages
    faster and carry out many other tasks that are required to maintain a fully functional
    universal application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在接下来的章节中看到的，渲染组件并不是创建服务器端渲染应用程序所需完成的唯一任务。我们必须设置和维护一个带有其路由和逻辑的服务器，管理服务器数据流等等。潜在地，我们希望缓存内容以更快地提供页面，并执行许多其他任务，这些任务是维护一个完全功能的通用应用程序所必需的。
- en: For this reason, my suggestion is to build the client-side version first, and
    only when the web application is fully working on the server should you think
    about improving the experience by enabling SSR. SSR should only be enabled when
    strictly necessary. For example, if you need SEO or if you need to customize the
    social sharing information, you should start thinking about it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的建议是首先构建客户端版本，只有在Web应用程序在服务器上完全工作时，您才应该考虑通过启用SSR来改善体验。只有在严格必要时才应启用SSR。例如，如果您需要SEO或者需要自定义社交分享信息，您应该开始考虑它。
- en: If you realize that your application takes a lot of time to load fully and you
    have already done all the optimization (refer to the following *Chapter 10*, *Improving
    the Performance of Your Applications*, for more on this topic), you can consider
    using SSR to offer a better experience to your users and improve the perceived
    speed. Now that we have learned what SSR is and the benefits of universal applications,
    let's jump into some basic examples of SSR in our next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您意识到您的应用程序需要很长时间才能完全加载，并且您已经进行了所有的优化（有关此主题的更多信息，请参阅*第10章*，*改进您的应用程序的性能*），您可以考虑使用SSR来为用户提供更好的体验并提高感知速度。现在我们已经了解了什么是SSR以及通用应用程序的好处，让我们在下一节中跳入一些SSR的基本示例。
- en: Creating a basic example of SSR
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SSR的基本示例
- en: We will now create a very simple server-side application to look at the steps
    that are needed to build a basic universal setup. It is going to be a minimal
    and simple setup on purpose because the goal here is to show how SSR works rather
    than providing a comprehensive solution or a boilerplate, even though you could
    use the example application as a starting point for a real-world application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个非常简单的服务器端应用程序，以查看构建基本通用设置所需的步骤。这是一个故意简化的设置，因为这里的目标是展示SSR的工作原理，而不是提供全面的解决方案或样板，尽管您可以将示例应用程序用作真实应用程序的起点。
- en: This section assumes that all the concepts regarding JavaScript build tools,
    such as webpack and its loaders, are clear, and it requires a little bit of knowledge
    of Node.js. As a JavaScript developer, it should be easy for you to follow this
    section, even if you have never seen a Node.js application before.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设所有关于JavaScript构建工具（如webpack及其加载程序）的概念都是清楚的，并且需要一点Node.js的知识。作为JavaScript开发人员，即使您以前从未见过Node.js应用程序，也应该很容易跟上本节。
- en: 'The application will consist of two parts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将由两部分组成：
- en: On the server side, where we will use  **Express**  to create a basic web  server
    and serve an HTML page with the server-side rendered React application
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端，我们将使用**Express**创建一个基本的Web服务器，并为服务器端渲染的React应用程序提供一个HTML页面
- en: On the client side, where we will render the application, as  usual, using  `react-dom`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端，我们将像往常一样使用`react-dom`渲染应用程序。
- en: Both sides of the application will be transpiled with Babel and bundled with
    webpack before being run, which will let us use the full power of ES6 and the
    modules both on Node.js and on the browser.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，应用程序的两侧都将使用Babel进行转译，并在运行之前使用webpack进行捆绑，这将让我们在Node.js和浏览器上都可以使用ES6和模块的全部功能。
- en: 'Let''s start by creating a new project folder (you can call it `ssr-project`)
    and running the following command to create a new package:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的项目文件夹开始（您可以称之为`ssr-project`），并运行以下命令来创建一个新的包：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once `package.json` is created, it is time to install the dependencies. We
    can start with `webpack`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`package.json`后，是时候安装依赖项了。我们可以从`webpack`开始：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this is done, it is time to install `ts-loader` and the presets that
    we need to write an ES6 application using React and TSX:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，是时候安装`ts-loader`和我们需要使用React和TSX编写ES6应用程序的预设了：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also have to install a dependency, which we will need in order to create
    the server bundle. `webpack` lets us define a set of externals, which are dependencies
    that we do not want to add to the bundle. When creating a build for the server,
    in fact, we do not want to add to the bundle of all the node packages that we
    use; we just want to bundle our server code. There''s a package that helps with
    that, and we can simply apply it to the external entry in our `webpack` configuration
    to exclude all the modules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须安装一个依赖项，这样我们才能创建服务器捆绑包。`webpack`让我们定义一组外部依赖项，这些依赖项我们不想添加到捆绑包中。实际上，在为服务器创建构建时，我们不想将我们使用的所有节点包添加到捆绑包中；我们只想捆绑我们的服务器代码。有一个包可以帮助我们做到这一点，我们可以简单地将其应用到我们的`webpack`配置中的外部条目，以排除所有模块：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great. It is now time to create an entry in the npm `scripts` section of `package.json`
    so that we can easily run the `build` command from the terminal:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在是时候在`package.json`的npm`scripts`部分创建一个条目，这样我们就可以轻松地从终端运行`build`命令了：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, you need to create a `.babelrc` file in your root path:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在根路径下创建一个`.babelrc`文件：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have to create the configuration file, called  `webpack.config.js`, to
    tell `webpack` how we want our files to be bundled.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须创建配置文件，名为`webpack.config.js`，以告诉`webpack`我们希望如何捆绑我们的文件。
- en: 'Let''s start importing the library we will use to set our node externals. We
    will also define the configuration for `ts-loader`, which we will use for both
    the client and the server:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始导入我们将用来设置我们的节点外部的库。我们还将为`ts-loader`定义配置，我们将在客户端和服务器端都使用它：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In  *Chapter 8*,  *Making Your Components Look Beautiful*, we looked at how
    we had to export a configuration object from the configuration file. There is
    one cool feature in `webpack` that lets us export an array of configurations as
    well so that we can define both client and server configurations in the same place
    and use both in one go.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*使您的组件看起来漂亮*中，我们看到我们必须从配置文件中导出一个配置对象。`webpack`中有一个很酷的功能，它让我们也可以导出一个配置数组，这样我们就可以在同一个地方定义客户端和服务器配置，并同时使用两者。
- en: 'The client configuration shown in the following block should be very familiar:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示的客户端配置应该非常熟悉：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are telling `webpack` that the source code of the client application is inside
    the  `src`  folder, and we want the output bundle to be generated in the  `dist`  folder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉`webpack`客户端应用程序的源代码位于`src`文件夹中，并且我们希望生成的输出捆绑包位于`dist`文件夹中。
- en: 'We also set the module loaders using the previous object we created with `ts-loader`.
    The server configuration is slightly different; we need to define a different
    `entry`, `output`, and add some new nodes, such as `target`, `externals`, and
    `resolve`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用之前使用`ts-loader`创建的对象设置模块加载程序。服务器配置略有不同；我们需要定义不同的`entry`，`output`，并添加一些新的节点，例如`target`，`externals`和`resolve`：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `entry`, `output`, and `module` are the same, except for the
    filenames.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`entry`，`output`和`module`是相同的，只是文件名不同。
- en: The new parameters are the `target`, where we specify the  node  to tell `webpac``k`
    to ignore all the built-in system packages of Node.js, such as  `fs`  and  `externals`,
    where we use the library we imported earlier to tell webpack to ignore the dependencies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 新的参数是`target`，在其中我们指定`node`以告诉`webpack`忽略Node.js的所有内置系统包，例如`fs`和`externals`，在其中我们使用我们之前导入的库告诉webpack忽略依赖项。
- en: 'Last, but not least, we have to export the configurations as an array:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但并非最不重要的，我们必须将配置导出为数组：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The configuration is done. We are now ready to write some code, and we will
    start with the React application, which we are more familiar with.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 配置已经完成。我们现在准备写一些代码，我们将从我们更熟悉的React应用程序开始。
- en: Let's create an  `src`  folder and an  `app.ts`  file inside it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`src`文件夹，并在其中创建一个`app.ts`文件。
- en: 'The  `app.ts` file should have the following content:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.ts`文件应该有以下内容：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nothing complex here; we import React, create an  `App`  component, which renders
    the  `Hello React`  message, and export it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么复杂的；我们导入React，创建一个`App`组件，它呈现`Hello React`消息，并导出它。
- en: 'Let''s now create  `client.tsx`, which is responsible for rendering the  `App`
    component inside the DOM:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`client.tsx`，它负责在DOM中渲染`App`组件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, this should sound familiar, since we import React,  ReactDOM, and the  `App`
    component we created earlier, and we use  `ReactDOM`  to render it in a DOM element
    with the  `app` ID.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这应该听起来很熟悉，因为我们导入了React，ReactDOM和我们之前创建的`App`组件，并且我们使用`ReactDOM`将其呈现在具有`app`ID的DOM元素中。
- en: Let's now move to the server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转移到服务器。
- en: 'The first thing to do is to create a `template.ts` file, which exports a function
    that we will use to return the markup of the page that our server will give back
    to the browser:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是创建一个`template.ts`文件，它导出一个我们将用来返回服务器将返回给浏览器的页面标记的函数：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It should be pretty straightforward. The function accepts  `body`, which we
    will later see contains the React app, and it returns the skeleton of the page.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很简单。该函数接受`body`，我们稍后将看到它包含React应用程序，并返回页面的骨架。
- en: It is worth noting that we load the bundle on the client side even if the app
    is rendered on the server side. SSR is only half of the job that  React  does
    to render our application. We still want our application to be a client-side application,
    with all the features we can use in the browser, such as event handlers, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使应用程序在服务器端呈现，我们也会在客户端加载捆绑包。 SSR只是React用来呈现我们应用程序的工作的一半。我们仍然希望我们的应用程序是一个客户端应用程序，具有在浏览器中可以使用的所有功能，例如事件处理程序。
- en: 'After this, you need to install `express`, `react`, and `react-dom`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要安装`express`，`react`和`react-dom`：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it is time to create  `server.tsx`, which has more dependencies and is
    worth exploring in detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建`server.tsx`了，它有更多的依赖项，值得详细探讨：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing that we import is  `express`, the library that allows us to
    create a web server with some routes easily, and which is also able to serve static
    files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的第一件事是`express`，这个库允许我们轻松创建具有一些路由的Web服务器，并且还能够提供静态文件。
- en: Secondly, we import `React` and  `ReactDOM`  to render  `App`, which we import
    as well. Notice the  `/server` path in the `import` statement of  `ReactDOM`.
    The last thing we import is the template we defined earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们导入 `React` 和 `ReactDOM` 来渲染 `App`，我们也导入了。请注意 `import` 语句中的 `/server` 路径。我们导入的最后一件事是我们之前定义的模板。
- en: 'Now we create an Express application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个Express应用程序：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We tell the application where our static assets are stored:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉应用程序我们的静态资产存储在哪里：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you may have noticed, the path is the same that we used in the client configuration
    of webpack as the output destination of the client bundle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，路径与我们在webpack的客户端配置中用作客户端捆绑输出目的地的路径相同。
- en: 'Then, here comes the logic of SSR with React:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这里是使用React进行SSR的逻辑：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are telling Express that we  want  to listen to the `/` route,  and when
    it gets hit by a client, we render  `App`  to a string using the  `ReactDOM`  library.
    Here  comes  the magic and simplicity of the SSR of React.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Express我们想要监听 `/` 路由，当客户端命中时，我们使用 `ReactDOM` 库将 `App` 渲染为字符串。这就是React的SSR的魔力和简单之处。
- en: What  `renderToString`  does is return a string representation of the DOM elements
    generated by our  `App`  component; the same tree that it would render in the
    DOM if we were using the  `ReactDOM`  render method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString` 的作用是返回由我们的 `App` 组件生成的DOM元素的字符串表示形式；如果我们使用 `ReactDOM` 渲染方法，它将在DOM中呈现相同的树。'
- en: 'The value of the body variable is something like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: body变量的值类似于以下内容：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, it represents what we defined in the  `render`  method of `App`,
    except for a couple of data attributes that React uses on the client to attach
    the client-side application to the server-side rendered string.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它代表了我们在 `App` 的 `render` 方法中定义的内容，除了一些数据属性，React在客户端使用这些属性将客户端应用程序附加到服务器端呈现的字符串上。
- en: Now that we have the SSR representation of our app, we can use the `template`
    function to apply it to the HTML template and send it back to the browser within
    the Express response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们应用程序的SSR表示，我们可以使用 `template` 函数将其应用到HTML模板中，并在Express响应中将其发送回浏览器。
- en: 'Last, but not least, we have to start the Express application:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们必须启动Express应用程序：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are now ready to go; there are only a few operations left. The first one
    is to define the `start` script of  `npm`  and set it to run the node server:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了；只剩下几个操作。第一个是定义 `npm` 的 `start` 脚本并将其设置为运行节点服务器：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The scripts are ready, so we can first build the application with the following
    command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已经准备好了，所以我们可以首先使用以下命令构建应用程序：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the bundles are created, we can run the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当捆绑包创建完成后，我们可以运行以下命令：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Point the browser to  `http://localhost:3000`  and see the result.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器指向 `http://localhost:3000` 并查看结果。
- en: There are two important things to note here. First, when we use the View Page
    Source feature of the browser, we can see the source code of the application being
    rendered and returned from the server, which we would not see if SSR was not enabled.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件重要的事情需要注意。首先，当我们使用浏览器的查看页面源代码功能时，我们可以看到从服务器返回的应用程序的源代码，如果没有启用SSR，我们是看不到的。
- en: Second, if we open DevTools and we have the React extension installed, we can
    see that the  `App`  component has been booted on the client as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果我们打开DevTools并安装了React扩展，我们可以看到 `App` 组件也在客户端上启动了。
- en: 'The following screenshot shows the source of the page:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了页面的源代码：
- en: '![](assets/4dc6378f-f5e6-42d8-beb2-b015b7bfb582.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4dc6378f-f5e6-42d8-beb2-b015b7bfb582.png)'
- en: Great! Now that you have created your first React application using SSR, let's
    learn how to fetch data in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您已经使用SSR创建了您的第一个React应用程序，让我们在下一节中学习如何获取数据。
- en: '**Implementing data fetching**'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**实现数据获取**'
- en: The example in the previous section should explain clearly how to set up a universal
    application  in  React. It is pretty straightforward, and the main focus is on
    getting things done.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的示例应该清楚地解释了如何在React中设置通用应用程序。这很简单，主要集中在完成任务上。
- en: However, in a real-world application, we will likely want to load some data
    instead of a static React component, such as  `App`  in the example. Suppose we
    want to load  Dan Abramov's `gists` on the server and return the list of items
    from the Express app we just created.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实世界的应用程序中，我们可能希望加载一些数据，而不是一个静态的React组件，例如示例中的`App`。假设我们想在服务器上加载Dan Abramov的`gists`并从我们刚刚创建的Express应用程序返回项目列表。
- en: In the data fetching examples in *Chapter 6*,  *Managing Data*, we looked at
    how we can use  `useEffect`  to fire the data loading. That wouldn't work on the
    server because components do not get mounted on the DOM and the life cycle Hook
    never gets fired.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*的数据获取示例中，我们看到了如何使用`useEffect`来触发数据加载。这在服务器上不起作用，因为组件不会挂载在DOM上，生命周期钩子也不会被触发。
- en: Using Hooks that were executed earlier will not work either because the data
    fetching operation is `async`, while `renderToString` is not. For that reason,
    we have to find a way to load the data beforehand and pass it to the component
    as props.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前执行的Hooks也不起作用，因为数据获取操作是`async`的，而`renderToString`不是。因此，我们必须找到一种方法在之前加载数据并将其作为props传递给组件。
- en: Let's look at how we can take the application from the previous section and
    change it a bit to make it load `gists` during the SSR phase.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将上一节的应用程序稍作修改，以便在SSR阶段加载`gists`。
- en: 'The first thing to do is to change  `App.tsx`  to accept a list of `gists`
    as `prop`, and loop through it in the render method to display their descriptions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是更改`App.tsx`以接受`gists`的列表作为`prop`，并在渲染方法中循环遍历它们以显示它们的描述：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Applying the concept that we learned in the previous chapter, we define a stateless
    functional component, which receives  `gists` as a prop and loops through the
    elements to render a list of items. Now, we have to change the server to retrieve  `gists`  and
    pass them to the component.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们在上一章学到的概念，我们定义了一个无状态的函数组件，它接收`gists`作为prop并循环遍历元素以渲染项目列表。现在，我们必须更改服务器以检索`gists`并将它们传递给组件。
- en: 'To use the  **fetch**  API on the server side, we  have  to install a library
    called  `isomorphic-fetch`, which implements the fetch standards. It can be used
    in Node.js and the browser:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器端使用**fetch** API，我们必须安装一个名为`isomorphic-fetch`的库，它实现了fetch标准。它可以在Node.js和浏览器中使用：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We first import the library into `server.tsx`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将库导入到`server.tsx`中：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The API call that we want to make looks as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要进行的API调用如下：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `gists`  are available to be used inside the last `then` function. In
    our case, we want to pass them down to  `App`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`gists`可以在最后的`then`函数中使用。在我们的情况下，我们希望将它们传递给`App`。
- en: 'Therefore, we can change the  `/`  route as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将`/`路由更改如下：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we first fetch `gists,`  and then we render  `App`  to a string, passing
    the property.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取`gists`，然后将`App`渲染为字符串，传递属性。
- en: Once  `App`  is rendered, and we have its markup, we use the template we used
    in the  previous  section and return it to the browser.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`App`被渲染，并且我们有了它的标记，我们就使用了上一节中使用的模板，并将其返回给浏览器。
- en: 'Run the following command in the console and point the browser to  `http://localhost:3000`.
    You should be able to see a server-side render list of  `gists`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中运行以下命令，并将浏览器指向`http://localhost:3000`。您应该能够看到一个服务器端渲染的`gists`列表：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To make sure that the list is rendered from the Express app, you can navigate
    to `view-source:http://localhost:3000` and you will see the markup and the descriptions
    of  `gists`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 确保列表是从Express应用程序呈现的，您可以导航到`view-source:http://localhost:3000`，您将看到`gists`的标记和描述。
- en: That is great, and it looks easy, but if we check the DevTools console, we can
    see the Cannot read property 'map' of undefined error. The reason we see the error
    is that, on the client, we are rendering  `App`  again, but without passing `gists`  to
    it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，看起来很容易，但如果我们检查DevTools控制台，我们会看到Cannot read property 'map' of undefined错误。我们看到错误的原因是，在客户端，我们再次渲染`App`，但没有将`gists`传递给它。
- en: This could sound counter-intuitive in the beginning because we  might  think
    that React is smart enough to use `gists` rendered within the server-side string
    on the client. But that is not what happens, so we have to find a way to make
    `gists` available on the client side as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能听起来有些反直觉，因为我们可能认为React足够聪明，可以在客户端使用服务器端字符串中呈现的`gists`。但事实并非如此，因此我们必须找到一种方法在客户端也使`gists`可用。
- en: You may consider that you can execute the fetch again on the client. That would
    work, but it is not optimal because you would end up firing two HTTP calls, one
    on the Express server and one in the browser. If we think about it, we already
    made the call on the server, and we have all the data we need. A typical solution
    to sharing data between the server and the client is dehydrating the data in the
    HTML markup and hydrating it back in the browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑在客户端再次执行fetch。这样可以工作，但并不是最佳的，因为您最终会触发两个HTTP调用，一个在Express服务器上，一个在浏览器上。如果我们考虑一下，我们已经在服务器上进行了调用，并且我们拥有所有所需的数据。在服务器和客户端之间共享数据的典型解决方案是在HTML标记中脱水数据，并在浏览器中重新水化数据。
- en: This seems like a complex concept, but it is not. We will now look at how easy
    it is to implement. The first thing we must do is to inject `gists` in the template
    after we have fetched them on the client.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个复杂的概念，但实际上并不是。我们现在将看看实现起来有多容易。我们必须做的第一件事是在客户端获取`gists`后将其注入模板中。
- en: 'To do this, we have to change the template slightly as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须稍微更改模板，如下所示：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `template` function now accepts two parameters—`body`  of the app and the
    collection of  `gists`. The first one is inserted inside the app element, while
    the second is used to define a global `gists` variable attached to  the `window`
    object  so that we can use it in the client.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`函数现在接受两个参数——应用程序的`body`和`gists`的集合。第一个插入到应用程序元素中，而第二个用于定义一个附加到`window`对象的全局`gists`变量，以便我们可以在客户端中使用它。'
- en: 'Inside the  `Express`  route (`server.js`), we just have to change the line
    where we generate the template passing the body, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Express`路由（`server.js`）中，我们只需要更改生成模板的行，传递body，如下所示：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Last, but not least, we have to use `gists` attached to a window inside `client.tsx`,
    which is pretty easy:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们必须在`client.tsx`中使用附加到窗口的`gists`，这非常容易：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Hydrate** was introduced in React 16 and works similar to render on the client
    side, irrespective of whether the HTML has server-rendered markup or not. If there
    is no markup previously using SSR, then the `hydrate` method will fire a warning
    that you can silence it by using the new `suppressHydrationWarning` attribute.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**水化**是在React 16中引入的，它在客户端的渲染上类似于渲染，无论HTML是否具有服务器呈现的标记。如果以前没有使用SSR的标记，那么`hydrate`方法将触发一个警告，您可以使用新的`suppressHydrationWarning`属性来消除它。'
- en: We read `gists` directly, and we pass them to the  `App`  component that gets
    rendered on the client.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接读取`gists`，并将它们传递给在客户端呈现的`App`组件。
- en: 'Now, run the following command again:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行以下命令：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we point the browser window to `http://localhost:3000`, the error is gone,
    and if we inspect the `App` component using React DevTools, we can see how the
    client-side `App` component receives the collection of `gists`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器窗口指向`http://localhost:3000`，错误就消失了，如果我们使用React DevTools检查`App`组件，我们可以看到客户端的`App`组件是如何接收`gists`集合的。
- en: As we have created our first SSR application, let's now see how we can do this
    more easily by using an SSR framework called Next.js in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了我们的第一个SSR应用程序，现在让我们在下一节中看看如何通过使用名为Next.js的SSR框架更轻松地完成这项工作。
- en: '**Using Next.js to create a React application**'
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**使用Next.js创建React应用**'
- en: You have looked at the basics of SSR with React, and you  can use the project
    we created as a starting point for a real app. However, you may think that there
    is too much boilerplate and that you are required to know too many different tools
    to run a simple universal application  with React. This is a common feeling called  **JavaScript
    fatigue**, as described in the introduction to this book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了使用React进行SSR的基础知识，并且可以将我们创建的项目作为真实应用程序的起点。但是，您可能认为有太多样板代码，并且需要了解太多不同的工具才能运行一个简单的通用应用程序。这是一种常见的感觉，称为**JavaScript疲劳**，正如本书介绍中所述。
- en: Luckily, Facebook developers and other companies in the React community are
    working very hard to improve the DX and make the life of developers easier. You
    might have used  `create-react-app`  at this point to try out the examples in
    the previous chapters, and you should understand how it makes it very simple to
    create React applications without requiring developers to learn many technologies
    and tools.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Facebook开发人员和React社区中的其他公司正在努力改进DX，并使开发人员的生活更轻松。到目前为止，您可能已经使用`create-react-app`来尝试前几章的示例，并且应该了解它是如何简化创建React应用程序的，而不需要开发人员学习许多技术和工具。
- en: Now,  `create-react-app`  does not support SSR yet, but there's a company called
    **Vercel** that has created a tool called **Next.js**, which makes it incredibly
    easy to generate universal applications without worrying about configuration files.
    It also reduces the boilerplate a lot.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`create-react-app`还不支持SSR，但有一家名为**Vercel**的公司创建了一个名为**Next.js**的工具，它使得生成通用应用变得非常简单，而不用担心配置文件。它还大大减少了样板代码。
- en: It is important to say that using abstractions is always  very good for building
    applications quickly. However, it is crucial to know how the internals  work  before
    adding too many layers, and that is why we started with the manual process before
    learning Next.js. We have looked at how SSR works and how we can pass the state
    from the server to the client. Now that the base concepts are clear, we can move
    to a tool that hides a little bit of complexity and makes us write less code to
    achieve the same results.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象化构建应用程序总是非常好的。然而，在添加太多层之前，了解内部工作原理是至关重要的，这就是为什么我们在学习Next.js之前先从手动过程开始的原因。我们已经看过了SSR的工作原理以及如何将状态从服务器传递到客户端。现在基本概念清楚了，我们可以转向一个隐藏了一些复杂性并使我们编写更少代码来实现相同结果的工具。
- en: We will create the same app where all `gists` from  Dan Abramov are loaded,
    and you will see how clean and simple the code is, thanks to Next.js.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建相同的应用程序，加载Dan Abramov的所有`gists`，您将看到由于Next.js的原因，代码是多么干净和简单。
- en: 'First of all, create a new project folder (you can call it `next-project`)
    and run the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的项目文件夹（您可以称之为`next-project`）并运行以下命令：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When this is done, we can install the Next.js library and React:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以安装Next.js库和React：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that the project is created, we have to add an `npm` script to run the
    binary:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已创建，我们必须添加一个`npm`脚本来运行二进制文件：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Perfect! It is now time to generate our  `App`  component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在是时候生成我们的`App`组件了。
- en: Next.js is based on conventions, with the most important one being that you
    can create pages to match the browser URLs. The default page is  `index`, so we
    can create a folder called `pages` and put an  `index.js`  file inside it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js基于约定，其中最重要的约定之一是您可以创建与浏览器URL匹配的页面。默认页面是`index`，所以我们可以创建一个名为`pages`的文件夹，并在其中放置一个`index.js`文件。
- en: 'We start importing the dependencies:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始导入依赖项：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, we import  `isomorphic-fetch`  because we want to be able to use the
    `fetch` function on the server side.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次导入`isomorphic-fetch`，因为我们希望能够在服务器端使用`fetch`函数。
- en: 'We then define a component called `App`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个名为`App`的组件：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then we define a  `static async`  function, called  `getInitialProps`, which
    is where we tell Next.js which data we want to load, both on the server side and
    on the client side. The library will make the object returned from the function
    available as props inside the component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个名为`getInitialProps`的`static async`函数，这是我们告诉Next.js我们想要在服务器端和客户端加载哪些数据的地方。该库将使函数返回的对象在组件内部作为props可用。
- en: The  `static`  and  `async` keywords applied to a class method mean that the
    function can be accessed outside the instance of the class and that the function
    yields the execution of the `wait` instructions inside its body.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于类方法的`static`和`async`关键字意味着该函数可以在类的实例外部访问，并且该函数会在其主体内部执行`wait`指令。
- en: These concepts are pretty advanced, and they are not part of the scope of this
    chapter, but if you are interested in them, you should check out the ECMAScript
    proposals ([https://github.com/tc39/proposals](https://github.com/tc39/proposals)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念非常先进，不属于本章的范围，但如果您对它们感兴趣，可以查看ECMAScript提案（[https://github.com/tc39/proposals](https://github.com/tc39/proposals)）。
- en: 'The implementation of the method we just described is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述的方法的实现如下：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are telling the function to fire the fetch and wait for the response; then
    we are transforming the response into JSON, which returns a promise. When the
    promise is resolved, we can return the `props` object with `gists`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉函数触发fetch并等待响应；然后我们将响应转换为JSON，这将返回一个promise。当promise解析时，我们可以返回带有`gists`的`props`对象。
- en: '`render` of the component looks pretty similar to the preceding one:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的`render`看起来与前面的非常相似：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before you run the project, you need to configure `tsconfig.json`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目之前，您需要配置`tsconfig.json`：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, open the console and run the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开控制台并运行以下命令：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will see the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we point the browser to that URL, we can see the universal application in
    action. It is really impressive how easy it is to set up a universal application
    with a few lines of code and zero-configuration, thanks to Next.js.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器指向该URL，我们可以看到通用应用程序正在运行。通过Next.js，设置通用应用程序非常容易，只需几行代码和零配置。
- en: You may also notice that if you edit the application inside your editor, you
    will be able to see the results within the browser instantly without needing to
    refresh the page. That is another feature of Next.js, which enables hot module
    replacement. It is incredibly useful in development mode.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到，如果您在编辑器中编辑应用程序，您将能够立即在浏览器中看到结果，而无需刷新页面。这是Next.js的另一个功能，它实现了热模块替换。在开发模式下非常有用。
- en: 'If you liked this chapter, go and  give a star on GitHub: [https://github.com/zeit/next.js](https://github.com/zeit/next.js).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢本章，请在GitHub上给一个星星：[https://github.com/zeit/next.js](https://github.com/zeit/next.js)。
- en: '**Summary**'
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: The journey through SSR has come to an end. You are now able to create a server-side
    rendered application with React, and it should be clear why it can be useful for
    you. SEO is certainly one of the main reasons, but social sharing and performance
    are important factors as well. You learned how it is possible to load the data
    on the server and dehydrate it in the HTML template to make it available for the
    client-side application when it boots on the browser.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SSR之旅已经结束。您现在可以使用React创建一个服务器端渲染的应用程序，而且您应该清楚为什么它对您有用。SEO显然是主要原因之一，但社交分享和性能也是重要因素。您学会了如何在服务器上加载数据并在HTML模板中去除水分，以便在浏览器上启动客户端应用程序时使其可用。
- en: Finally, you have looked at how tools such as Next.js can help you reduce the
    boilerplate and hide some of the complexity that setting up a server-side render
    React application usually brings to the code base.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您已经了解到像Next.js这样的工具如何帮助您减少样板代码，并隐藏一些通常会给代码库带来的服务器端渲染React应用程序设置复杂性。
- en: In the next chapter, we will talk about how to improve the performance of our
    React applications.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何提高React应用程序的性能。
