- en: Writing Code for the Browser
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 为浏览器编写代码
- en: There are some specific operations we can do when we work with React and the
    browser. For example, we can ask our users to enter some information using forms,
    and in this chapter, we will look at how we can apply different techniques to
    deal with forms. We can implement  **uncontrolled  components**  and let the fields
    keep their internal states, or we can use  controlled  ones, where we have full
    control over the state of the fields.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React和浏览器时，我们可以进行一些特定的操作。例如，我们可以要求用户使用表单输入一些信息，在本章中，我们将看看如何应用不同的技术来处理表单。我们可以实现**不受控制的组件**，让字段保持其内部状态，或者我们可以使用**受控组件**，在这种情况下，我们完全控制字段的状态。
- en: In this chapter, we will also look at  how  events in React work and how the
    library implements some advanced techniques to give us a consistent interface
    across different browsers. We will look at some interesting solutions that the
    React team has implemented to make the event system very performant.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将看看React中的事件是如何工作的，以及该库如何实现一些高级技术，为我们提供一个在不同浏览器中具有一致接口的解决方案。我们将看看React团队实现的一些有趣的解决方案，使事件系统非常高效。
- en: After events, we will jump into  refs  to look at how we can access the underlying
    DOM nodes in our React components. This represents a powerful feature, but it
    should be used carefully because it breaks some of the conventions that make React
    easy to work with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件之后，我们将跳转到 refs，看看我们如何在React组件中访问底层DOM节点。这代表了一个强大的功能，但应该谨慎使用，因为它会破坏一些使React易于使用的约定。
- en: After refs, we will look at  how  we can implement animations easily  with the
    React add-ons and third-party libraries such as  `react-motion`. Finally, we will
    learn how easy it is to work with **Scalable Vector Graphics** (**SVG**) in React,
    and how we can create dynamically configurable icons for our applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 refs 之后，我们将看看如何使用React附加组件和第三方库（如`react-motion`）轻松实现动画。最后，我们将学习在React中使用**可伸缩矢量图形**（**SVG**）有多么容易，以及如何为我们的应用程序创建动态可配置的图标。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Using different techniques to create forms with React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的技术在React中创建表单
- en: Listening to DOM events and implementing custom handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听DOM事件并实现自定义处理程序
- en: A way of performing imperative operations on DOM nodes using refs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 refs 在DOM节点上执行命令式操作的一种方式
- en: Creating simple animations that work across different browsers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在不同浏览器中都有效的简单动画
- en: The React way of generating SVG
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成SVG的React方式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书的GitHub存储库中找到本章的代码：[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07)。
- en: Understanding and implementing forms
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并实现表单
- en: In this chapter, we are going to learn how to implement forms with React. As
    soon as we start building a real application with React, we need to interact with
    the users. If we want to ask for information from our users within the browser,
    forms are the most common solution. Due to the way the library works and its declarative
    nature, dealing with input fields and other form elements is non-trivial with
    React, but as soon as we understand its logic, it will become clear. In the next
    sections, we are going to learn how to use uncontrolled and controlled components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用React实现表单。一旦我们开始用React构建一个真正的应用程序，我们就需要与用户进行交互。如果我们想在浏览器中向用户询问信息，表单是最常见的解决方案。由于库的工作方式和其声明性的特性，使用React处理输入字段和其他表单元素是非常复杂的，但一旦我们理解了它的逻辑，就会变得清晰。在接下来的章节中，我们将学习如何使用不受控制和受控组件。
- en: Uncontrolled components
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不受控制的组件
- en: Uncontrolled components are like regular HTML form inputs for which you will
    not be able to manage the value yourself but instead, the DOM will take care of
    handling the value and you can get this value by using a React ref. Let's start
    with a basic example—displaying a  form  with an input field and a Submit button.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不受控制的组件就像常规的HTML表单输入，你将无法自己管理值，而是DOM会处理值，并且你可以使用React ref来获取这个值。让我们从一个基本的例子开始——显示一个带有输入字段和提交按钮的表单。
- en: 'The code is pretty straightforward:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we run the preceding snippet in the browser, we will see exactly what we
    expect—an input field in which we can write  something  and a clickable button.
    This is an example of an uncontrolled component, where we do not set the value
    of the input field, but we let the component manage its own internal state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行前面的片段，我们将看到完全符合预期的结果——一个输入字段，我们可以在其中输入一些内容，以及一个可点击的按钮。这是一个不受控制的组件的例子，我们不设置输入字段的值，而是让组件管理自己的内部状态。
- en: Most likely, we want to do something with the value of the element when the
    Submit button is clicked. For example, we may want to send the data to an API
    endpoint.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，我们希望在单击提交按钮时对元素的值做一些操作。例如，我们可能希望将数据发送到API端点。
- en: We can do this easily by adding an  `onChange`  listener (we will talk more
    about event listeners later in this chapter). Let's look at what it means to add
    a listener.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个`onChange`监听器来轻松实现这一点（我们将在本章后面更多地讨论事件监听器）。让我们看看添加监听器意味着什么。
- en: 'We need to create the `handleChange` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建`handleChange`函数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The event listener is receiving an event object, where the  target  represents
    the field that generated the event, and we are interested in its value. We start
    by just logging it because it is important to proceed with small steps, but we
    will store the value into the state soon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器接收到一个事件对象，其中`target`表示生成事件的字段，我们对其值感兴趣。我们首先只是记录它，因为逐步进行很重要，但很快我们将把值存储到状态中。
- en: 'Finally, we render the form:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染表单：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we render the component inside the browser and type the word `React` into
    the form field, we will see something like the following inside the console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中渲染组件并在表单字段中输入`React`这个词，我们将在控制台中看到类似以下的内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `handleChange` listener is fired every time the value of the input changes.
    Therefore, our function is called once for each typed character. The next step
    is to store the value that's entered by the user and make it available when the
    user clicks the Submit button.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleChange`监听器在输入值改变时被触发。因此，我们的函数每输入一个字符就会被调用一次。下一步是存储用户输入的值，并在用户单击提交按钮时使其可用。'
- en: 'We just have to change the implementation of the handler to store it in the
    state instead of logging it, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要改变处理程序的实现方式，将其存储在状态中而不是记录下来，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting notified of when the form is submitted is very similar to listening
    to the change event of the input field; they are both events that are called by
    the browser when something happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 得知表单何时提交与监听输入字段的更改事件非常相似；它们都是在发生某些事件时由浏览器调用的。
- en: 'Let''s define the  `handleSubmit`  function, where we just log the value. In
    a real-world scenario, you could send the data to an API endpoint or pass it to
    another component:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义`handleSubmit`函数，我们只是记录这个值。在现实世界的场景中，你可以将数据发送到API端点或将其传递给另一个组件：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This handler is pretty straightforward; we just log the value currently stored
    in the state. We also want to overcome the default behavior of the browser when
    the form is submitted, to perform a custom action. This seems reasonable, and
    it works very well for a single field. The question now is, what if we have multiple
    fields? Suppose we have tens of different fields?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序非常简单；我们只是记录当前存储在状态中的值。我们还希望克服浏览器在提交表单时的默认行为，以执行自定义操作。这似乎是合理的，并且对于单个字段来说效果很好。现在的问题是，如果我们有多个字段怎么办？假设我们有数十个不同的字段？
- en: Let's start with a basic example, where we create each field and  handler  manually  and
    look at how we can improve it by applying different levels of optimization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本的例子开始，手动创建每个字段和处理程序，并看看如何通过应用不同级别的优化来改进它。
- en: 'Let''s create a new form with first and last name fields. We can reuse the
    `Uncontrolled` component and add some new states:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的表单，包括名字和姓氏字段。我们可以重用`Uncontrolled`组件并添加一些新的状态：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We initialize the two fields inside the state and we define an event handler
    for each one of the fields as well. As you may have noticed, this does not scale
    very well when there are lots of fields, but it is important to understand the
    problem clearly  before moving to a more flexible solution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在状态中初始化了两个字段，并为每个字段定义了一个事件处理程序。正如你可能已经注意到的，当有很多字段时，这种方法并不很好扩展，但在转向更灵活的解决方案之前，清楚地理解问题是很重要的。
- en: 'Now, we implement the new handlers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现新的处理程序：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also have to change the submit handler a little bit so that it displays
    the first and the last name when it gets clicked:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须稍微改变提交处理程序，以便在点击时显示名字和姓氏：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we render the form:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染表单：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are ready to go: if we run the preceding component in the browser, we will
    see two fields, and if we type  `Carlos`  into the first one and  `Santana`  into
    the second one, we will see the full name displayed in the browser console when
    the form is submitted.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了：如果我们在浏览器中运行前面的组件，我们将看到两个字段，如果我们在第一个字段中输入`Carlos`，在第二个字段中输入`Santana`，当表单提交时，我们将在浏览器控制台中看到全名显示出来。
- en: Again, this works fine, and we can do some interesting things this way, but
    it does not handle complex scenarios without requiring us to write a lot of boilerplate
    code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这样做是可以的，我们可以以这种方式做一些有趣的事情，但它不能处理复杂的场景，而不需要我们编写大量的样板代码。
- en: Let's look at how we can optimize it a little bit. Our goal is to use a single
    change  handler  so that we can add an arbitrary number of fields without creating
    new listeners.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何优化一下。我们的目标是使用一个单一的change处理程序，这样我们就可以添加任意数量的字段而不需要创建新的监听器。
- en: 'Let''s go back to the component and let''s change our states:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到组件，让我们改变我们的状态：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We may still want to initialize the values, and later in this section, we will
    look at how to provide prefilled values for the form.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能仍然希望初始化这些值，在本节的后面，我们将看看如何为表单提供预填充的值。
- en: 'Now, the interesting bit is the way in which we can modify the  `onChange`  handler
    implementation to make it work  in different fields:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有趣的部分是我们如何修改`onChange`处理程序的实现方式，使其在不同字段中工作：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we have seen previously, the `target` property of the event we receive represents
    the input field that has fired the event, so we can use the name of the field
    and its value as variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们接收到的事件的`target`属性代表了触发事件的输入字段，因此我们可以使用字段的名称和其值作为变量。
- en: 'We then have to set the name for each field:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须为每个字段设置名称：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's it! We can now add as many fields as we want without creating additional
    handlers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们可以添加任意多个字段而不需要创建额外的处理程序。
- en: Controlled components
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件
- en: A controlled component is a React component that controls the values of input
    elements in a form by using the component state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 受控组件是一个通过使用组件状态来控制表单中输入元素的值的React组件。
- en: Here we are going to  look  at how we can prefill the form fields with some
    values, which we may receive from the server or as props from the parent. To understand
    this concept  fully, we will start again from a very simple stateless function
    component, and we will improve it step by step.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看看如何使用一些值预填充表单字段，这些值可以来自服务器或作为父级传递的props。为了充分理解这个概念，我们将从一个非常简单的无状态函数组件开始，然后逐步改进它。
- en: 'The first example shows a predefined value inside the input field:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子显示了输入字段中的预定义值：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run this component inside the browser, we realize that it shows the default
    value as expected, but it does not let us change the value or type anything else
    inside it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行此组件，我们会意识到它按预期显示默认值，但不允许我们更改值或在其中输入其他任何内容。
- en: The reason it does this is  that  in React, we declare what we want to see on
    the screen, and setting a fixed-value attribute always results in rendering that
    value, no matter what other actions are taken. This is unlikely to be a behavior
    we want in a real-world application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它这样做的原因是，在React中，我们声明了我们想要在屏幕上看到的内容，并且设置一个固定值属性总是导致渲染该值，无论采取了什么其他操作。这不太可能是我们在现实世界应用程序中想要的行为。
- en: 'If we open the console, we get the following error message. React itself is
    telling us that we are doing something wrong:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开控制台，会得到以下错误消息。React本身告诉我们我们在做一些错误的事情：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if we just want the input field to have a  default  value and we want
    to be able to change it by typing, we can use the  `defaultValue`  property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只想让输入字段具有默认值，并且希望能够通过输入更改它，我们可以使用`defaultValue`属性：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this way, the field is going to show `Hello React` when it is rendered,
    but then the user can type anything inside it and change its value. Now let''s
    add some states:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当渲染时，该字段将显示`Hello React`，但用户可以在其中输入任何内容并更改其值。现在让我们添加一些状态：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The handlers are the same as the previous ones:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序与之前的相同：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In fact, we will use the `value` attributes of the input fields to set their
    initial values, as well as the updated one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将使用输入字段的`value`属性来设置它们的初始值，以及更新后的值：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first time the form is rendered, React uses the initial values from the
    state as the value of the input fields. When the user types something into the
    field, the `handleChange` function is called and the new value for the field is
    stored  in  the state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次渲染表单时，React使用状态中的初始值作为输入字段的值。当用户在字段中输入内容时，将调用`handleChange`函数，并将字段的新值存储在状态中。
- en: When the state changes, React re-renders the component and uses it again to
    reflect the current values of the input fields. We now have full control over
    the values of the fields, and  we  call this pattern  **controlled components**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态改变时，React会重新渲染组件并再次使用它来反映输入字段的当前值。现在我们完全控制字段的值，并且我们称这种模式为**受控组件**。
- en: In the next section, we are going to work with events, which are a fundamental
    part of React to handle data coming from forms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将处理事件，这是React处理来自表单的数据的基本部分。
- en: Handling events
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: '**Events**  work in a slightly different  way  across various browsers. React
    tries to abstract the way events work and give developers a consistent interface
    to deal with. This is a great feature of React because we can forget about the
    browsers we are targeting and write event handlers and functions that are vendor-agnostic.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**在不同的浏览器中有稍微不同的工作方式。React试图抽象事件的工作方式，并为开发人员提供一致的接口来处理。这是React的一个很棒的特性，因为我们可以忘记我们要针对的浏览器，编写与供应商无关的事件处理程序和函数。'
- en: To offer this feature, React introduced the concept of the **synthetic event**.
    A synthetic event is an object that wraps the original event object provided by
    the browser, and it has the same properties, no matter where it is created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这个功能，React引入了**合成事件**的概念。合成事件是一个包装了浏览器提供的原始事件对象的对象，它具有相同的属性，无论在何处创建。
- en: To attach an event listener to a node and get the event object when the event
    is fired, we can use a simple convention that recalls the way events are attached
    to the DOM nodes. In fact, we can use the word  `on`  plus the camelCased event
    name (for example,  `onKeyDown`) to define the callback to be fired when the events
    happen. A popular convention is to name the event handler functions after the
    event name and prefix them using  `handle`  (for example,  `handleKeyDown`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事件监听器附加到节点并在事件触发时获取事件对象，我们可以使用一个简单的约定，回忆起事件附加到DOM节点的方式。事实上，我们可以使用单词 `on` 加上驼峰命名的事件名称（例如
    `onKeyDown`）来定义在事件发生时要触发的回调。一个常用的约定是将事件处理程序函数命名为事件名称，并使用 `handle` 作为前缀（例如 `handleKeyDown`）。
- en: 'We have seen this pattern in action in the previous examples, where we were
    listening to the  `onChange`  event of the form fields. Let''s reiterate a basic
    event listener example to see how we can organize multiple events inside the same
    component in a nicer way. We are going to implement a simple button, and we start,
    as usual, by creating a component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的例子中看到了这种模式的运作，我们在那里监听了表单字段的 `onChange` 事件。让我们重申一个基本的事件监听器示例，看看我们如何以更好的方式在同一个组件中组织多个事件。我们将实现一个简单的按钮，并且像往常一样，首先创建一个组件：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we define the event handler:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义事件处理程序：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see here, we are doing a very simple thing: we just check the type
    of the event object we receive from React and the type of native event attached
    to it. We expect the first to return  `false`  and the second to return  `true`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们只是做了一件非常简单的事情：我们只是检查我们从React接收到的事件对象的类型和附加到它的原生事件的类型。我们期望第一个返回 `false`，第二个返回
    `true`。
- en: 'You should never need to access the  original  native event, but it is good
    to know you can do it if you need to. Finally, we define the button with the  `onClick`  attribute
    to which we attach our event listener:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该需要访问原始的原生事件，但知道如果需要的话你可以这样做是很好的。最后，我们使用 `onClick` 属性定义按钮，并附加我们的事件监听器：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, suppose we want to attach a second handler to the button that listens
    to the double-click event. One solution would be to create a new separate handler
    and attach it to the button using the `onDoubleClick` attribute, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将第二个处理程序附加到按钮，监听双击事件。一个解决方案是创建一个新的独立处理程序，并使用 `onDoubleClick` 属性将其附加到按钮，如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that we always aim to write less boilerplate and avoid duplicating
    code. For that reason, a common practice is to write a  **single event handler**  for
    each component, which can  trigger  different actions according to the event type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们总是希望写更少的样板代码并避免重复代码。因此，一个常见的做法是为每个组件编写一个**单个事件处理程序**，根据事件类型触发不同的操作。
- en: 'This technique is described in a collection of  patterns  by Michael Chan:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在Michael Chan的一本模式集合中有所描述：
- en: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch)。'
- en: 'Let''s implement the generic event handler:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现通用事件处理程序：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The generic event handler receives the event object and switches on the event
    type to fire the right action. This is particularly useful if we want to call
    a function on each event (for example, analytics) or if some events share the
    same logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通用事件处理程序接收事件对象并根据事件类型触发正确的操作。如果我们想在每个事件上调用一个函数（例如，分析），或者如果一些事件共享相同的逻辑，这将特别有用。
- en: 'Finally, we attach the new event listener to the `onClick` and `onDoubleClick`
    attributes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新的事件监听器附加到`onClick`和`onDoubleClick`属性上：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From this point on, whenever we need to create a new event handler for the same
    component, instead of creating a new method and binding it, we can just add a
    new case to the switch.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，每当我们需要为同一组件创建一个新的事件处理程序时，我们可以只需添加一个新的情况到switch，而不是创建一个新的方法并绑定它。
- en: A couple more interesting things to know about events in  React  are that synthetic
    events are reused and that there is a  **single global handler**. The first concept
    means that we cannot store a synthetic event and reuse it later because it becomes
    null right after the action. This technique is very good in terms of performance,
    but it can be problematic if we want to store the event inside the state of the
    component for some reason. To solve this problem, React gives us a  `persist`  method
    on the synthetic events, which we can call to make the event persistent so that
    we can store it and retrieve it later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于React中事件的另外一些有趣的事情是，合成事件是可重用的，并且存在**单个全局处理程序**。第一个概念意味着我们不能存储合成事件并在以后重用它，因为它在操作后立即变为null。这种技术在性能方面非常好，但如果我们想出于某种原因将事件存储在组件状态中，可能会有问题。为了解决这个问题，React在合成事件上给了我们一个`persist`方法，我们可以调用它使事件持久化，这样我们就可以存储并在以后检索它。
- en: The second very interesting implementation detail is again about performance,
    and it is to do with the way React attaches the event handlers to the DOM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个非常有趣的实现细节再次涉及性能，它与React将事件处理程序附加到DOM的方式有关。
- en: Whenever we use the `on` attribute, we are describing to  React  the behavior
    we want to achieve, but the library does not attach the actual event handler to
    the underlying DOM nodes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用`on`属性时，我们正在描述我们想要实现的行为，但是库并没有将实际的事件处理程序附加到底层DOM节点上。
- en: What it does instead attaches a single event handler to the  root  element,
    which listens to all the events, thanks to  **event bubbling**. When an event
    we are interested in is fired by the browser, React calls the handler on the specific
    components on its behalf. This technique is called  **event delegation**  and
    is used for  memory  and speed optimization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的是将单个事件处理程序附加到根元素，通过**事件冒泡**监听所有事件。当我们感兴趣的事件被浏览器触发时，React代表其调用特定组件上的处理程序。这种技术称为**事件委托**，用于内存和速度优化。
- en: In our next section, we are going to explore React refs and see how we can take
    advantage of them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一节中，我们将探索React引用并看看我们如何利用它们。
- en: Exploring refs
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索引用
- en: One of the reasons people love  React  is that it is declarative. Being declarative
    means that you just describe what you want to be displayed on the screen at any
    point in time and React takes care of the communications with the browser. This
    feature makes React very easy to reason about and very powerful at the same time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 人们喜欢 React 的一个原因是它是声明式的。声明式意味着你只需描述你想在屏幕上显示的内容，React 就会处理与浏览器的通信。这个特性使得 React
    非常容易理解，同时也非常强大。
- en: However, there might be some cases where you need to access the underlying DOM
    nodes to perform some imperative operations. This should be avoided because, in
    most cases, there is a more React-compliant solution to achieve the same result,
    but it is important to know that we have the option to do it and to know how it
    works so that we can make the right decision.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能会有一些情况需要访问底层的 DOM 节点来执行一些命令式操作。这应该被避免，因为在大多数情况下，有更符合 React 的解决方案来实现相同的结果，但重要的是要知道我们有这个选项，并知道它是如何工作的，以便我们能做出正确的决定。
- en: Suppose we want to create a simple form with an input element and a button,
    and we want it to behave in such a way that when the button is clicked, the input
    field gets focused. What we want to do is call the  `focus`  method on the input
    node, the actual DOM instance of the input, inside the browser's window.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个简单的表单，其中包含一个输入元素和一个按钮，当点击按钮时，输入字段获得焦点。我们想要做的是在浏览器窗口内调用输入节点的 `focus`
    方法，即输入的实际 DOM 实例。
- en: 'Let''s create a component called `Focus`; you need to import `useRef` and create
    an `inputRef` constant:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Focus` 的组件；你需要导入 `useRef` 并创建一个 `inputRef` 常量：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we implement the `handleClick` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现 `handleClick` 方法：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we are referencing the `current` attribute of `inputRef` and
    calling the `focus` method on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在引用 `inputRef` 的 `current` 属性，并调用它的 `focus` 方法。
- en: 'To understand where it comes from, you just have to check the implementation
    of `render`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解它来自哪里，你只需检查 `render` 的实现。
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here comes the core of the logic. We create a form with an input element inside
    it and we define a function on its `ref` attribute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是逻辑的核心。我们创建了一个带有输入元素的表单，并在其 `ref` 属性上定义了一个函数。
- en: The callback we defined is called when the component gets mounted, and the element
    parameter represents the DOM instance of the input. It is important to know that,
    when the component gets unmounted, the same callback is called with a `null` parameter
    to free the memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的回调函数在组件挂载时被调用，元素参数表示输入的 DOM 实例。重要的是要知道，当组件被卸载时，相同的回调会以 `null` 参数被调用以释放内存。
- en: What we are doing in the callback is storing the reference of the element to
    be able to use it in the future (for example, when the `handleClick` method is
    fired). Then, we have the button with its event handler. Running the preceding
    code in a browser will show the form with the field and the button, and clicking
    on the button will focus the input field, as expected.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中我们所做的是存储元素的引用，以便将来使用（例如，当触发 `handleClick` 方法时）。然后，我们有一个带有事件处理程序的按钮。在浏览器中运行上述代码将显示带有字段和按钮的表单，并且点击按钮将聚焦输入字段，如预期的那样。
- en: As we mentioned previously, in general, we should try to avoid using refs because
    they force the code to be more imperative, and they become harder to read and
    maintain.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，一般来说，我们应该尽量避免使用 refs，因为它们会使代码更加命令式，变得更难阅读和维护。
- en: Implementing animations
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现动画
- en: When  we  think about UIs and the browser, we must surely think about animations
    as well. Animated UIs are more pleasant for users, and they are a very important
    tool to show users that something has happened or is about to occur.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑 UI 和浏览器时，我们一定也要考虑动画。动画化的 UI 对用户更加愉悦，它们是向用户展示发生了或即将发生的事情的非常重要的工具。
- en: This section does not aim to be an exhaustive guide to creating animations and
    beautiful UIs; the goal here is to provide you with some basic information about
    the common solutions we can put in place to animate our React components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不旨在成为创建动画和美观 UI 的详尽指南；这里的目标是为您提供一些关于我们可以采用的常见解决方案的基本信息，以便为我们的 React 组件添加动画。
- en: For a UI library such as React, it is crucial to provide an easy way for developers
    to create and manage animations. React comes with an add-on, called  `react-addons-css-transition-group`,
    which is a component that helps us build animations in a declarative way. Again,
    being able to perform operations declaratively is incredibly powerful, and it
    makes the code much easier to reason about and share with the team.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 React 这样的 UI 库，提供一种简单的方式让开发人员创建和管理动画是至关重要的。React 自带一个名为 `react-addons-css-transition-group`
    的附加组件，它是一个帮助我们以声明方式构建动画的组件。再次，能够以声明方式执行操作是非常强大的，它使代码更容易理解并与团队共享。
- en: Let's look at how to apply a simple fade-in effect to text with the React add-on,
    and then  we  will perform the same operation using  `react-motion`, a third-party
    library that makes creating complex animations even easier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 React 附加组件对文本应用简单的淡入效果，然后我们将使用 `react-motion` 执行相同的操作，这是一个使创建复杂动画更容易的第三方库。
- en: 'The first thing we need to do to start building an animated component is to
    install the add-on:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建一个动画组件，我们需要做的第一件事是安装这个附加组件：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have done that, we can import the component:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个操作，我们就可以导入该组件：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we just wrap the component to which we want to apply the animation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需包装我们想要应用动画的组件：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, there are some props that need explaining.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有一些需要解释的属性。
- en: First, we are declaring the `transitionName` prop. `ReactCSSTransitionGroup`  applies
    a class with the name of that property to the child element so that we can then
    use CSS transitions to create our animations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了 `transitionName` 属性。`ReactCSSTransitionGroup` 将该属性的名称应用到子元素的类中，以便我们可以使用
    CSS 过渡来创建我们的动画。
- en: With a single class, we cannot easily create a proper animation, and that is
    why the transition group applies multiple classes according to the state of the
    animation. In this case, with the  `transitionAppear`  prop, we are telling the
    component that we want to animate the children when they appear on the screen.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个类，我们无法轻松创建适当的动画，这就是为什么过渡组件根据动画状态应用多个类。在这种情况下，使用 `transitionAppear` 属性，我们告诉组件我们希望在屏幕上出现时对子元素进行动画处理。
- en: So, what the library does is apply the  `fade-appear`  class (where  `fade`  is
    the value of the  `transitionName`  prop) to the component as soon as it gets
    rendered. On the next tick, the  `fade-appear-active` class is applied so that  we  can
    fire our animation from the initial state to the new one, using CSS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，图书馆所做的是在组件被渲染时立即应用 `fade-appear` 类（其中 `fade` 是 `transitionName` 属性的值）。在下一个时刻，`fade-appear-active`
    类被应用，以便我们可以从初始状态到新状态触发我们的动画，使用CSS。
- en: We also have to set the  `transitionAppearTimeout`  property to tell  React  the
    length of the animation so that it doesn't remove elements from the DOM before
    animations are completed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须设置 `transitionAppearTimeout` 属性，告诉 React 动画的长度，以便在动画完成之前不要从 DOM 中移除元素。
- en: The CSS to make an element fade-in is as follows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使元素淡入的 CSS 如下。
- en: 'First, we define the opacity of the element in the initial state:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义元素在初始状态下的不透明度：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we define our transition using the second class, which starts as soon
    as it gets applied to the element:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用第二个类来定义我们的过渡，一旦它被应用到元素上就会开始：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are transitioning the opacity from  `0.01`  to  `1`  in  `500ms`  using the
    `ease-in` function. This is pretty easy, but we can create more complex animations,
    and we can also animate different states of the component. For example, the  `*-enter`  and  `*-enter-active`  classes
    are applied when a new element is added as a child of the transition group. A
    similar thing applies to  remove  elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`ease-in`函数在`500ms`内将不透明度从`0.01`过渡到`1`。这很容易，但我们可以创建更复杂的动画，我们也可以动画化组件的不同状态。例如，当新元素作为过渡组的子元素添加时，`*-enter`和`*-enter-active`类会被应用。类似的情况也适用于删除元素。
- en: 'In our next section, we are going to check out the most popular library to
    create animations in React:  `react-motion`, which is maintained by Cheng Lou.
    It provides a very clean and easy-to-use API that gives us a very powerful tool
    to create any animations.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一节中，我们将查看在React中创建动画最流行的库：`react-motion`，这个库由Cheng Lou维护。它提供了一个非常干净和易于使用的API，为我们提供了一个非常强大的工具来创建任何动画。
- en: React Motion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Motion
- en: '**React Motion** is an animation library for React applications that make it
    easy to create and implement realistic animations. As soon as the complexity of
    the animations grows, or when  we  need animations that depend on other animations,
    or when we need to apply some physics-based behavior to our components (which
    is a bit more advanced), we will realize that the transition group is not helping
    us enough, so we may consider using a third-party library.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Motion**是一个用于React应用程序的动画库，它使得创建和实现逼真动画变得容易。一旦动画的复杂性增加，或者当我们需要依赖其他动画的动画，或者当我们需要将一些基于物理的行为应用到我们的组件上（这是一个更高级的技术），我们会意识到过渡组并不能帮助我们足够，所以我们可能会考虑使用第三方库。'
- en: 'To use it, we first have to install it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们首先必须安装它：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the installation is successfully completed, we need to import the `Motion`
    component and the `spring` function. `Motion` is the component we will use to
    wrap the elements we want to animate, while the function is a utility that can
    interpolate a value from its initial state to the final one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，我们需要导入`Motion`组件和`spring`函数。`Motion`是我们将用来包装我们想要动画的元素的组件，而函数是一个实用工具，可以将一个值从其初始状态插值到最终状态：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s look at the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are a lot of interesting things here. First, you may have noticed that
    this component uses the function as a child pattern (see  *Chapter 4,* *Exploring
    Popular Composition Patterns*), which is a pretty powerful technique to define
    children that receive values at runtime.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多有趣的东西。首先，您可能已经注意到这个组件使用了函数作为子模式（参见*第4章，探索流行的组合模式*），这是一种非常强大的技术，用于定义在运行时接收值的子元素。
- en: 'Then, we can see that the  `Motion`  component has two attributes: the first
    one is  `defaultStyle`, which represents the initial `style` attribute. Again,
    we set the opacity to  `0.0.1`  to hide the element and start the fade.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到`Motion`组件有两个属性：第一个是`defaultStyle`，它表示初始的`style`属性。同样，我们将不透明度设置为`0.01`来隐藏元素并开始淡入。
- en: The `style` attribute represents the final style instead, but we do not set
    the value directly; instead, we use the `spring` function so that the value is
    interpolated from the initial state to the final one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`属性代表最终的样式，但我们不直接设置值；相反，我们使用`spring`函数，使得值从初始状态插值到最终状态。'
- en: On each iteration of the `spring` function, the child function receives the
    interpolated style for the given point in time and, just by applying the received
    object to the `style` attribute of the component, we can see the transition of
    the opacity.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spring`函数的每次迭代中，子函数接收给定时间点的插值样式，只需将接收到的对象应用到组件的`style`属性，我们就可以看到不透明度的过渡。
- en: This library can do some more cool stuff, but the first things to learn about
    are the basic concepts, and this example should clarify them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库可以做一些更酷的事情，但首先要了解的是基本概念，这个例子应该能澄清它们。
- en: It is also interesting to compare the two different approaches of the transition
    group and `react-motion` to be able to choose the right one for the project you
    are working on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 比较过渡组和`react-motion`的两种不同方法也很有趣，以便能够选择适合你正在工作的项目的正确方法。
- en: Finally, in our next section, we are going to see how we can work with SVG in
    React.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下一节中，我们将看到如何在React中使用SVG。
- en: Exploring SVG
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SVG
- en: Last but not least, one of the most interesting techniques we can  apply  in
    the browser to draw icons and graphs is  **Scalable Vector Graphics**  (**SVG**).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们可以在浏览器中应用一种最有趣的技术来绘制图标和图形，那就是**可缩放矢量图形**（**SVG**）。
- en: SVG is  great  because it is a declarative way of describing vectors and it
    fits perfectly with the purposes of React. We used to use icon fonts to create
    icons, but they have well-known problems, with the first being that they are not
    accessible. It is also pretty hard to position icon fonts with CSS, and they do
    not always look beautiful in all browsers. These are the reasons we should prefer
    SVG for our web applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: SVG很棒，因为它是一种描述矢量的声明性方式，它与React的目的完全契合。我们过去常常使用图标字体来创建图标，但它们有众所周知的问题，首先是它们不可访问。用CSS定位图标字体也相当困难，它们在所有浏览器中并不总是看起来美观。这就是我们应该为我们的Web应用程序更喜欢SVG的原因。
- en: From a React point of view, it does not make any difference if we output a  `div`  or
    an SVG element from the `render` method, and this is what makes it so powerful.
    We also tend to choose SVG because we can easily modify them at runtime using
    CSS and JavaScript, which makes them an excellent candidate for the functional
    approach of React.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从React的角度来看，无论我们从`render`方法中输出`div`还是SVG元素，都没有任何区别，这就是它如此强大的原因。我们也倾向于选择SVG，因为我们可以很容易地使用CSS和JavaScript在运行时修改它们，这使它们成为React功能方法的绝佳选择。
- en: So, if we think about our components as a function of their props, we can easily
    imagine how we can create self-contained SVG icons that we can manipulate by passing
    different props to them. A common way to create SVG in a web app with React is
    to wrap our vectors into a React component and use the props to define their dynamic
    values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将组件视为其props的函数，我们可以很容易地想象如何创建可以通过传递不同props来操作的自包含SVG图标。在React中创建SVG的常见方法是将我们的矢量图包装到一个React组件中，并使用props来定义它们的动态值。
- en: 'Let''s look at a simple example where we draw a blue circle, thus creating
    a React component that wraps an SVG element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，我们画一个蓝色的圆，从而创建一个包装SVG元素的React组件：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we can easily use a stateless functional component that wraps
    the SVG markup, and it accepts the same props as SVG does.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以很容易地使用一个无状态的函数组件来包装SVG标记，它接受与SVG相同的props。
- en: 'An example usage is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例用法如下：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can obviously use the full power of React and set some default parameters
    so that, if the circle icon is rendered without props, we still show something.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以充分利用React的功能，并设置一些默认参数，以便如果圆形图标在没有props的情况下呈现，我们仍然可以显示一些东西。
- en: 'For example, we can define the default color:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义默认颜色：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is pretty powerful when we build UIs, especially in a team where we share
    our icon set and we want to have some default values in it, but we also want to
    let other teams decide their settings without having to recreate the same SVG
    shapes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建UI时，这非常强大，特别是在一个团队中，我们共享我们的图标集，并且希望在其中有一些默认值，但我们也希望让其他团队决定他们的设置，而不必重新创建相同的SVG形状。
- en: However, in some cases, we prefer to be more strict and fix some values to keep
    consistency. With React, this is a super simple task.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们更倾向于更严格地固定一些值以保持一致性。使用React，这是一个非常简单的任务。
- en: 'For example, we can wrap the base circle component into `RedCircle`, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将基本圆形组件包装成`RedCircle`，如下所示：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the color is set by default and it cannot be changed, while the other
    props are transparently passed to the original circle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，颜色是默认设置的，不能更改，而其他props会透明地传递给原始圆。
- en: 'The following screenshot shows two circles, blue and red, that are generated
    by React using SVG:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由React使用SVG生成的两个圆，蓝色和红色：
- en: '![](assets/024940fd-bb15-47bd-8457-f738b7cd573a.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/024940fd-bb15-47bd-8457-f738b7cd573a.png)'
- en: We can apply this technique and create different variations of the circle, such
    as `SmallCircle` and `RightCircle`, and everything else we need to build our UIs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用这种技术，并创建圆的不同变体，比如`SmallCircle`和`RightCircle`，以及构建UI所需的其他一切。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the different things we can do when we target
    the browser with React, from form creation to events, and animations to SVG. Also,
    we learned how to use the new `useRef` Hook. React gives us a declarative way
    to manage all the aspects we need to deal with when we create a web application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一下当我们用React来针对浏览器时可以做的不同事情，从表单创建到事件，从动画到SVG。此外，我们学会了如何使用新的`useRef`
    Hook。React为我们提供了一种声明性的方式来管理我们在创建Web应用程序时需要处理的所有方面。
- en: In case we need it, React gives us access to the actual DOM nodes in a way that
    means we can perform imperative operations with them, which is useful if we need
    to integrate React with an existing imperative library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，React会以一种方式为我们提供对实际DOM节点的访问，这意味着我们可以对它们执行命令式操作，这在我们需要将React与现有的命令式库集成时非常有用。
- en: The next chapter will be about CSS and inline styles, and it will clarify what
    it means to write CSS in JavaScript.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论CSS和内联样式，它将阐明在JavaScript中编写CSS意味着什么。
