- en: React Hooks
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks
- en: React is evolving really quickly and since React 16.8, the new React Hooks have
    been introduced, which are a game-changer as regards React development in that
    they will boost the speed of coding and improve the performance of our applications.
    React enables us to write React applications using only functional components,
    meaning there is no longer any need to use class components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React发展非常迅速，自React 16.8以来，引入了新的React Hooks，这是React开发的一个改变者，因为它们将提高编码速度并改善应用程序的性能。React使我们能够仅使用功能组件编写React应用程序，这意味着不再需要使用类组件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: The new React Hooks and how to use them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的React Hooks以及如何使用它们
- en: The rules of the Hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks的规则
- en: How to migrate a class component to React Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将类组件迁移到React Hooks
- en: Understanding the component life cycle with Hooks and effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks和效果理解组件生命周期
- en: How to fetch data with Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Hooks获取数据
- en: How to memorize components, values, and functions with `memo`, `useMemo`, and
    `useCallback`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`memo`、`useMemo`和`useCallback`来记忆组件、值和函数
- en: How to implement `useReducer`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现`useReducer`
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You can find the code for this chapter in the book's GitHub repository at [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter03).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书的GitHub存储库中找到本章的代码[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter03)。
- en: Introducing React Hooks
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React Hooks
- en: React Hooks are a new addition in React 16.8\. They let you use state and other
    React features without writing a React class component. React Hooks are also backward-compatible,
    which means it does not contain any breaking change and it does not replace your
    knowledge of React concepts. Over the course of this chapter, we will see an overview
    of Hooks for experienced React users, and we are also going to learn some of the
    most common React Hooks such as `useState`, `useEffect`, `useMemo`, `useCallback`
    and `memo`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks是React 16.8中的新添加。它们让您在不编写React类组件的情况下使用状态和其他React功能。React Hooks也是向后兼容的，这意味着它不包含任何破坏性更改，也不会取代您对React概念的了解。在本章的过程中，我们将看到有关经验丰富的React用户的Hooks概述，并且我们还将学习一些最常见的React
    Hooks，如`useState`、`useEffect`、`useMemo`、`useCallback`和`memo`。
- en: No breaking changes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有破坏性更改
- en: Many people think that with the new React Hooks, class components are now obsolete
    in React, but this statement is incorrect. There are no plans to remove classes
    from React. The Hooks don't replace your knowledge of React concepts. Instead,
    Hooks provide a more direct API to the React concepts, such as props, state, context,
    refs, and life cycle, which you already know.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为，使用新的React Hooks，类组件在React中已经过时，但这种说法是不正确的。没有计划从React中删除类。Hooks不会取代您对React概念的了解。相反，Hooks为React概念提供了更直接的API，如props、state、context、refs和生命周期，这些您已经了解。
- en: Using the State Hook
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用State Hook
- en: You probably know how to use the component state by using it in a class with
    `this.setState`. Now you can use the component state by using the new React `useState`
    Hook.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道如何在类中使用`this.setState`来使用组件状态。现在您可以使用新的React `useState` Hook来使用组件状态。
- en: 'First, you need to extract the `useState` Hook from React:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要从React中提取`useState` Hook：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since React 17, the React object is no longer required to render JSX code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自React 17以来，不再需要React对象来渲染JSX代码。
- en: 'Then you need to declare the state you want to use by defining the state and
    the setter for this specific state:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要通过定义状态和特定状态的setter来声明要使用的状态：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we are declaring the counter state with the `setCounter` setter
    and we are specifying that we will only accept numbers, and finally, we set the
    initial value with zero.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们使用`setCounter` setter声明了计数器状态，并且我们指定只接受数字，最后，我们将初始值设置为零。
- en: 'In order to test our state, we need to create a method that will be triggered
    by the `onClick` event:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的状态，我们需要创建一个将由`onClick`事件触发的方法：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we can render the `counter` state and some buttons to increase or
    decrease the `counter` state:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以渲染`counter`状态和一些按钮来增加或减少`counter`状态：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you click on the + Add button one time, you should see 1 for Counter:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击+添加按钮一次，您应该在计数器中看到1：
- en: '![](assets/266d444a-ec32-44c6-bff3-29f4d5ab4d4b.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/266d444a-ec32-44c6-bff3-29f4d5ab4d4b.png)
- en: 'And if you click the - Subtract button twice, then you should see -1 for Counter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您连续点击减号按钮两次，那么您应该在计数器中看到-1：
- en: '![](assets/56a2e476-d287-46d0-80b9-7956e95c8c4c.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/56a2e476-d287-46d0-80b9-7956e95c8c4c.png)
- en: As you can see, the `useState` Hook is a game-changer in React and makes it
    very easy to handle the state in a functional component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`useState` Hook在React中是一个改变游戏规则的东西，并且使得在功能组件中处理状态变得非常容易。
- en: Rules of Hooks
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hooks的规则
- en: 'React Hooks are basically JavaScript functions, but there are two rules that
    you need to follow in order to use them. React provides a linter plugin to enforce
    those rules for you, which you can install by running the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks基本上是JavaScript函数，但是您需要遵循两条规则才能使用它们。React提供了一个lint插件来强制执行这些规则，您可以通过运行以下命令来安装它：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's look at these two rules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两条规则。
- en: 'Rule 1: Only call Hooks at the top level'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则1：只在顶层调用Hooks
- en: 'From the official React documentation ([https://reactjs.org/docs/hooks-rules.html](https://reactjs.org/docs/hooks-rules.html)):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方React文档（[https://reactjs.org/docs/hooks-rules.html](https://reactjs.org/docs/hooks-rules.html)）：
- en: '"**Don’t call Hooks inside loops, conditions, or nested functions**. Instead,
    always use Hooks at the top level of your React function. By following this rule,
    you ensure that Hooks are called in the same order each time a component renders.
    That''s what allows React to correctly preserve the state of Hooks between multiple
    useState and useEffect calls."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “**不要在循环、条件或嵌套函数中调用Hooks**。相反，始终在React函数的顶层使用Hooks。遵循此规则，您确保每次组件渲染时以相同的顺序调用Hooks。这就是允许React在多次useState和useEffect调用之间正确保存Hooks状态的原因。”
- en: 'Rule 2: Only call Hooks from React Functions'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则2：只从React函数调用Hooks
- en: 'From the official React documentation ([https://reactjs.org/docs/hooks-rules.html](https://reactjs.org/docs/hooks-rules.html)):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方React文档（[https://reactjs.org/docs/hooks-rules.html](https://reactjs.org/docs/hooks-rules.html)）：
- en: '"Don''t call Hooks from regular JavaScript functions. Instead, you can:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “不要从常规JavaScript函数调用Hooks。相反，您可以：
- en: Call Hooks from React function components.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从React函数组件调用Hooks。
- en: Call Hooks from custom Hooks (we'll learn about them on the next page).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从自定义Hooks调用Hooks（我们将在下一页学习它们）。
- en: By following this rule, you ensure that all stateful logic in a component is
    clearly visible from its source code."
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此规则，您确保组件中的所有有状态逻辑在其源代码中清晰可见。”
- en: In the next section, we will learn how to migrate a class component to use the
    new React Hooks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将类组件迁移到使用新的React Hooks。
- en: Migrating a class component to React Hooks
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类组件迁移到React Hooks
- en: Let's transform a code that is currently using class components and is also
    using some life cycle methods. In this example, we are fetching the issues from
    a GitHub repository and listing them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换一个当前正在使用类组件和一些生命周期方法的代码。在这个例子中，我们正在从GitHub仓库中获取问题并列出它们。
- en: 'For this example, you will need to install `axios` to perform the fetch:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，您需要安装`axios`来执行获取操作：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the class component version:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类组件版本：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you render this component, you should see something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您渲染此组件，应该会看到类似于这样的东西：
- en: '![](assets/b0280137-c6aa-43cb-aae0-b6f5fd070592.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0280137-c6aa-43cb-aae0-b6f5fd070592.png)'
- en: 'Now, let''s transform our code to be a functional component using React Hooks.
    The first thing we need to do is to import some React functions and types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的代码转换为使用React Hooks的函数组件。我们需要做的第一件事是导入一些React函数和类型：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can remove the `Props` and `State` types we created previously and just
    leave the `Issue` type:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以删除之前创建的`Props`和`State`类型，只留下`Issue`类型：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this, you can change the class definition to use a functional component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以更改类定义以使用函数组件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `FC` type is used to define a **Functional Component** in React. If you
    need to pass some props to the component, you can pass them like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`FC`类型用于在React中定义**函数组件**。如果您需要将一些props传递给组件，可以这样传递：'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next thing we need to do is to replace our constructor and our state definition
    by using the `useState` Hook:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要做的是使用`useState` Hook来替换我们的构造函数和状态定义：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have used the life cycle method called `componentDidMount` before, which
    is executed when the component is mounted and is going to run just once. The new
    React Hook, called `useEffect`, will now handle all the life cycle methods using
    different syntax for each one, but for now, let''s see how we can get the same
    *effect* of `componentDidMount` into our new functional component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前使用了名为`componentDidMount`的生命周期方法，它在组件挂载时执行，并且只会运行一次。新的React Hook，称为`useEffect`，现在将使用不同的语法处理所有生命周期方法，但现在，让我们看看如何在我们的新函数组件中获得与`componentDidMount`相同的*效果*：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, we just render our JSX code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需渲染我们的JSX代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the new Hooks help us to simplify our code a lot and makes more
    sense. Also, we reduced our code by 10 lines (the class component code has 53
    lines and the functional component has 43 lines).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，新的Hooks帮助我们大大简化了我们的代码，并且更有意义。此外，我们通过10行减少了我们的代码（类组件代码有53行，函数组件有43行）。
- en: Understanding React effects
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React效果
- en: In this section, we will learn the difference between the component life cycle
    methods that we used on class components and the new React effects. Even if you
    have read in other places that they are the same, just with a different syntax,
    this is not correct.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在类组件上使用的组件生命周期方法和新的React效果之间的区别。即使您在其他地方读到它们是相同的，只是语法不同，这是不正确的。
- en: Understanding useEffect
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解useEffect
- en: 'When you work with `useEffect`, you need to *think in effects*. If you want
    to perform the equivalent method of `componentDidMount` using `useEffect`, you
    can do the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`useEffect`时，您需要*思考效果*。如果您想使用`useEffect`执行`componentDidMount`的等效方法，可以这样做：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first parameter is the callback of the effect that you want to execute,
    and the second parameter is the dependencies array. If you pass an empty array
    (`[]`) on the dependencies, the state and props will have their original initial
    values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是您想要执行的效果的回调函数，第二个参数是依赖项数组。如果在依赖项中传递一个空数组(`[]`)，状态和props将具有它们的原始初始值。
- en: However, it is important to mention that even though this is the closest equivalent
    for `componentDidMount`, it does not have the same behavior. Unlike `componentDidMount`
    and `componentDidUpdate`, the function that we pass to `useEffect` fires after
    layout and paint, during a deferred event. This normally works for many common
    side effects, such as setting up subscriptions and event handlers, because most
    types of work shouldn't block the browser from updating the screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要提到，即使这是`componentDidMount`的最接近等价物，它并不具有相同的行为。与`componentDidMount`和`componentDidUpdate`不同，我们传递给`useEffect`的函数在布局和绘制之后，在延迟事件期间触发。这通常适用于许多常见的副作用，比如设置订阅和事件处理程序，因为大多数类型的工作不应该阻止浏览器更新屏幕。
- en: However, not all effects can be deferred. For example, you would get a blink
    if you need to mutate the **Document Object Model** (**DOM**). This is the reason
    why you must fire the event synchronously before the next paint. React provides
    one Hook called `useLayoutEffect`, which works in the exact same way as `useEffect`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有的效果都可以延迟。例如，如果你需要改变**文档对象模型**（**DOM**），你会看到一个闪烁。这就是为什么你必须在下一次绘制之前同步触发事件的原因。React提供了一个叫做`useLayoutEffect`的Hook，它的工作方式与`useEffect`完全相同。
- en: Firing an effect conditionally
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有条件地触发效果
- en: 'If you need to fire an effect conditionally, then you should add a dependency
    to the array of dependencies, otherwise, you will execute the effect multiple
    times and this may cause an infinite loop. If you pass an array of dependencies,
    the `useEffect` Hook will only run if one of those dependencies changes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要有条件地触发一个效果，那么你应该向依赖数组中添加一个依赖项，否则，你将多次执行效果，这可能会导致无限循环。如果你传递一个依赖项数组，`useEffect`
    Hook将只在其中一个依赖项发生变化时运行：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you understand how the React class life cycle methods works, basically, `useEffect`
    behaves in the same way as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
    combined.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解React类生命周期方法的工作原理，基本上，`useEffect`的行为与`componentDidMount`，`componentDidUpdate`和`componentWillUnmount`的行为相同。
- en: The effects are very important, but let's also explore some other important
    new Hooks, including `useCallback`, `useMemo`, and `memo`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 效果非常重要，但让我们也探索一些其他重要的新Hook，包括`useCallback`，`useMemo`和`memo`。
- en: Understanding useCallback, useMemo, and memo
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解useCallback，useMemo和memo
- en: 'In order to understand the difference between `useCallback`, `useMemo` and
    `memo`, we will do a to-do list example. You can create a basic application by
    using `create-react-app` and typescript as a template:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`useCallback`，`useMemo`和`memo`之间的区别，我们将做一个待办事项清单的例子。你可以使用`create-react-app`和typescript作为模板创建一个基本的应用程序：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Right after that, you can remove all the extra files (`App.css`, `App.test.ts`,
    `index.css`, `logo.svg`, `reportWebVitals.ts`, and `setupTests.ts`). You just
    need to keep the `App.tsx` file, which will contain the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，你可以移除所有额外的文件（`App.css`，`App.test.ts`，`index.css`，`logo.svg`，`reportWebVitals.ts`和`setupTests.ts`）。你只需要保留`App.tsx`文件，其中包含以下代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Basically, we are defining some initial tasks and creating the `todoList` state,
    which we will pass to the list component. Then you need to create the `List.tsx`
    file with the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在定义一些初始任务并创建`todoList`状态，我们将把它传递给列表组件。然后你需要创建`List.tsx`文件，其中包含以下代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we are rendering each task of the `todoList` array by using
    the `Task` component and we pass `task` as a prop. I also added a `useEffect`
    Hook to see how many renders we are performing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们通过使用`Task`组件渲染`todoList`数组的每个任务，并将`task`作为prop传递。我还添加了一个`useEffect`
    Hook来查看我们执行了多少次渲染。
- en: 'Finally, we create our `Task.tsx` file with the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`Task.tsx`文件，其中包含以下代码：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how we should see the to-do list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们应该看待待办事项清单的方式：
- en: '![](assets/aebfa2b0-1b3f-4145-b7f3-366ce9252c7f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aebfa2b0-1b3f-4145-b7f3-366ce9252c7f.png)'
- en: As you can see, when we render our to-do list, by default, we are performing
    two renders of the `Task` component, one render for `List`, and the other for
    the `App` component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当我们渲染我们的待办事项列表时，默认情况下，我们会对`Task`组件执行两次渲染，对`List`执行一次渲染，对`App`组件执行一次渲染。
- en: 'Now, if we try to write a new task in the input, we can see that for each letter
    we write, we will again see all of those renders:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在输入框中写一个新的任务，我们会发现，每写一个字母，我们都会再次看到所有这些渲染：
- en: '![](assets/32dd8a44-a55b-4886-b827-2ab09b1a1a41.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32dd8a44-a55b-4886-b827-2ab09b1a1a41.png)'
- en: As you can see, by just writing `Go`, we have two new batches of renders, so
    we can determine that this component does not have good performance, and this
    is where `memo` can help us to improve performance. In the next sections, we are
    going to learn how to implement `memo`, `useMemo`, and `useCallback` to memoize
    a component, a value, and a function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，只需写`Go`，我们就有了两批新的渲染，所以我们可以确定这个组件的性能不好，这就是`memo`可以帮助我们提高性能的地方。在接下来的部分，我们将学习如何实现`memo`，`useMemo`和`useCallback`来对组件，值和函数进行记忆化。
- en: Memoizing a component with memo
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用memo对组件进行记忆化
- en: The `memo` **High Order Component (HOC)** is similar to `PureComponent` of a
    React class because it performs a shallow comparison of the props (meaning a superficial
    check), so if we try to render a component with the same props all the time, the
    component will render just once and will memorize. The only way to re-render the
    component is when a prop changes its value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo` **高阶组件（HOC）**类似于React类的`PureComponent`，因为它对props进行浅比较（意思是表面检查），所以如果我们一直尝试使用相同的props渲染组件，组件将只渲染一次并进行记忆。唯一重新渲染组件的方法是当一个prop改变其值时。'
- en: In order to fix our components to avoid the multiple renders when we write in
    the input, we need to wrap our components on the `memo` HOC.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复我们的组件，避免在输入时多次渲染，我们需要将我们的组件包装在`memo` HOC中。
- en: 'The first component we will fix is our `List` component, and you just need
    to effect `import memo` and wrap the component on `export default`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要修复的第一个组件是我们的`List`组件，你只需要引入`memo`并将组件包装在`export default`中：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then you need to do the same with the `Task` component:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要对`Task`组件做同样的操作：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when we try to write `Go` again in the input, let''s see how many renders
    we get this time:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次尝试在输入框中写`Go`时，让我们看看这一次我们得到了多少次渲染：
- en: '![](assets/a758059b-3561-4a90-9927-55f4b2ad7a61.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a758059b-3561-4a90-9927-55f4b2ad7a61.png)'
- en: Now, we just get the first batch of renders the first time, and then, when we
    write `Go`, we just get two more renders of the `App` component, which is totally
    fine because the task state (input value) that we are changing is actually part
    of the `App` component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只在第一次得到第一批渲染，然后，当我们写`Go`时，我们只得到`App`组件的另外两个渲染，这是完全可以接受的，因为我们正在改变的任务状态（输入值）实际上是`App`组件的一部分。
- en: 'Also, we can see how many renders we are performing when we create a new task
    by clicking on the Create button:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以看到当我们点击“创建”按钮创建一个新任务时，我们执行了多少次渲染：
- en: '![](assets/128157ac-ed62-472c-b399-63287304f2f3.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/128157ac-ed62-472c-b399-63287304f2f3.png)'
- en: If you see, the first 16 renders are the word counting of the Go to the doctor
    string, and then, when you click on the Create button, you should see one render
    of the `Task` component, one render of `List`, and one render of the `App` component.
    As you can see, we have improved performance a lot, and we are just performing
    the exact need that it renders.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到，前16次渲染是对“去看医生”字符串的字数统计，然后，当你点击“创建”按钮时，你应该看到`Task`组件的一次渲染，`List`的一次渲染，以及`App`组件的一次渲染。正如你所看到的，我们大大提高了性能，并且我们只执行了确实需要渲染的内容。
- en: At this point, you're probably thinking that the correct way is to always add
    memo to our components, or maybe you're thinking why React doesn't do this by
    default for us?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能在想正确的方法是始终向我们的组件添加备忘录，或者你在想为什么React不会默认为我们这样做呢？
- en: The reason is **performance**, which means **it** **is not a good idea to add**
    `memo` **to all our components unless it is totally necessary**, otherwise, the
    process of shallow comparisons and memorization will have inferior performance
    than if we don't use it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是**性能**，这意味着**除非完全必要，否则不要向所有组件添加`memo`**，否则，浅比较和记忆的过程将比不使用它的性能差。
- en: 'I have a rule when it comes to establishing whether it is a good idea to use
    `memo`, and this rule is straightforward: **just don''t use it.** Normally, when
    we have small components or basic logic, we don''t need this unless you''re working
    with **large data from some API or your component needs to perform a lot of renders
    (normally huge lists), or when you notice that your app is going slow**. Only
    in that case would I recommend using `memo`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及确定是否使用`memo`时，我有一个规则，这个规则很简单：**就是不要使用它。**通常，当我们有小组件或基本逻辑时，除非你正在处理**来自某个API的大量数据或者你的组件需要执行大量渲染（通常是巨大的列表），或者当你注意到你的应用程序运行缓慢**，我们不需要这个。只有在这种情况下，我才建议使用`memo`。
- en: Memoizing a value with useMemo
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`useMemo`进行值的备忘录
- en: 'Let''s suppose that we now want to implement a search feature in our to-do
    list. The first thing we need to do is to add a new state called `term` to the
    `App` component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在想在待办事项列表中实现搜索功能。我们需要做的第一件事是向`App`组件添加一个名为`term`的新状态：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we need to create a function called `handleSearch`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要创建一个名为`handleSearch`的函数：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Right before the return, we will create `filterTodoList`, which will filter
    the to-dos based on the task, and we will add a console there to see how many
    times it is being rendered:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前，我们将创建`filterTodoList`，它将根据任务筛选待办事项，并在那里添加一个控制台，以查看它被渲染了多少次：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we need to add a new button next to the Create button that already
    exists:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在已经存在的创建按钮旁边添加一个新按钮：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components so that we can focus on the performance of filtering:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我建议你删除或注释`List`和`Task`组件中的`console.log`，这样我们可以专注于过滤的性能：
- en: '![](assets/61331e13-ded8-4eab-add0-1704e4d178be.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/61331e13-ded8-4eab-add0-1704e4d178be.png)'
- en: 'When you run the application again, you will see that filtering is being executed
    twice, and then the `App` component as well, and everything looks good here, but
    what''s the problem with this? Try to write `Go to the doctor` again in the input
    and let''s see how many Rendering and Filtering you get:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行应用程序时，你会看到过滤被执行了两次，然后`App`组件也是，一切看起来都很好，但是这有什么问题吗？尝试在输入框中再次输入“去看医生”，让我们看看你会得到多少次渲染和过滤：
- en: '![](assets/130012da-d053-4f2b-b2b5-1b83bdadc05e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/130012da-d053-4f2b-b2b5-1b83bdadc05e.png)'
- en: As you can see, for each letter you write, you will get two filtering calls
    and one `App` render and you don't need to be a genius to see that this is bad
    performance; and not to mention that if you are working with a large data array,
    this will be worse, so how can we fix this issue?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每输入一个字母，你会得到两次过滤调用和一次`App`渲染，你不需要是天才就能看出这是糟糕的性能；更不用说如果你正在处理一个大数据数组，情况会更糟，那么我们该如何解决这个问题呢？
- en: 'The `useMemo` Hook is our hero in this situation, and basically, we need to
    move our filter inside `useMemo`, but first let''s see the syntax:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook在这种情况下是我们的英雄，基本上，我们需要将我们的过滤器放在`useMemo`中，但首先让我们看一下语法：'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `useMemo` Hook will memorize the result (value) of a function and will
    have some dependencies to listen to. Let''s see how we can implement it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook将记忆函数的结果（值），并且将有一些依赖项来监听。让我们看看如何实现它：'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if you write something again in the input, you will see that filtering
    won''t be executed all the time, as was the case previously:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您再次在输入框中输入内容，您会发现过滤不会一直执行，就像以前的情况一样：
- en: '![](assets/1f273372-2b54-4147-b084-8818284276e8.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f273372-2b54-4147-b084-8818284276e8.png)'
- en: 'This is great, but there is still one small problem. If you try to click on
    the Search button, it won''t filter, and this is because we missed the dependencies.
    Actually, if you see the console warnings, you will see this warning:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但仍然有一个小问题。如果您尝试单击搜索按钮，它不会进行过滤，这是因为我们错过了依赖项。实际上，如果您查看控制台警告，您将看到此警告：
- en: '![](assets/67075e04-e4cf-4722-8849-9b64fedcf868.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67075e04-e4cf-4722-8849-9b64fedcf868.png)'
- en: 'You need to add the `term` and `todoList` dependencies to the array:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将`term`和`todoList`依赖项添加到数组中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It should now work if you write `Go` and click on the Search button:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在写`Go`并单击搜索按钮，它应该可以工作：
- en: '![](assets/34c00dec-2193-44f3-bbb0-05ed84679c9c.png)Here, we have to use the
    same rule that we used for memo; **just don''t use it until absolutely necessary.**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/34c00dec-2193-44f3-bbb0-05ed84679c9c.png)在这里，我们必须使用与记忆相同的规则；**直到绝对必要时才使用它。**'
- en: Memoizing a function definition with useCallback
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`useCallback`来记忆函数定义
- en: 'Now we will add a delete task feature to learn how `useCallback` works. The
    first thing we need to do is to create a new function called `handleDelete` in
    our `App` component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一个删除任务的功能，以了解`useCallback`的工作原理。我们需要做的第一件事是在我们的`App`组件中创建一个名为`handleDelete`的新函数：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then you need to pass this function to the `List` component as a prop:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将此函数作为属性传递给`List`组件：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in our `List` component, you need to add the prop to the `Props` interface:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`List`组件中，您需要将该属性添加到`Props`接口中：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you need to pull it from the props and pass it down to the `Task` component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要从属性中提取它并将其传递给`Task`组件：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `Task` component, you need to create a button that will execute `handleDelete
    onClick`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Task`组件中，您需要创建一个按钮，该按钮将执行`handleDelete onClick`：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components, so we can focus on the performance of filtering.
    Now you should see the X button next to the task:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我建议您删除或注释`List`和`Task`组件中的`console.log`，这样我们就可以专注于过滤的性能。现在您应该看到任务旁边的X按钮：
- en: '![](assets/0cb5eb97-875e-49f4-9a91-7c0c381cb587.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0cb5eb97-875e-49f4-9a91-7c0c381cb587.png)'
- en: 'If you click on the X for Go shopping, you should be able to remove it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击`去购物`的X，应该可以将其删除：
- en: '![](assets/aabf1a76-e3c6-410d-bf21-a58a7b1a10fd.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aabf1a76-e3c6-410d-bf21-a58a7b1a10fd.png)'
- en: 'So far, so good, right? But again we have a little issue with this implementation.
    If you now try to write something in the input, such as `Go to the doctor`, let''s
    see what happens:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还好，对吧？但是我们在这个实现中又遇到了一个小问题。如果您现在尝试在输入框中写一些内容，比如`去看医生`，让我们看看会发生什么：
- en: '![](assets/7acf5bb0-bb7c-4f70-88a4-dc0398c62fe3.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7acf5bb0-bb7c-4f70-88a4-dc0398c62fe3.png)'
- en: If you see, we are performing **71** renders of all the components again. At
    this point, you are probably thinking about, *what is going on if we have already
    implemented the memo HOC to memorize the components*? But the problem now is that
    our `handleDelete` function is being passed in two components, from `App` to `List`
    and to `Task`, and the issue is that this function is regenerated every time we
    have a new re-render, in this case, every time we write something. So how do we
    fix this problem?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到，我们再次执行了所有组件的**71**次渲染。此时，您可能会想，*如果我们已经实现了memo HOC来记住组件，那么现在发生了什么*？但现在的问题是，我们的`handleDelete`函数被传递给了两个组件，从`App`到`List`，再到`Task`，问题在于每次重新渲染时，这个函数都会被重新生成，也就是说，每次我们写东西时都会重新生成。那么我们如何解决这个问题呢？
- en: 'The `useCallback` Hook is the hero in this case and is very similar to `useMemo`
    in the syntax, but the main difference is that instead of memorizing the result
    value of a function, as `useMemo` does, it is memorizing the **function definition**
    instead:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` Hook在这种情况下是英雄，并且在语法上与`useMemo`非常相似，但主要区别在于，它不是像`useMemo`那样记住函数的结果值，而是记住**函数定义**：'
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our `handleDelete` function should be like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`handleDelete`函数应该像这样：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, it should work just fine if we write `Go to the doctor` again:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次写`去看医生`，它应该可以正常工作：
- en: '![](assets/04e9608a-b0b5-425a-9826-ddfd424785e3.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04e9608a-b0b5-425a-9826-ddfd424785e3.png)'
- en: 'Now, instead of 71 renders, we just have 23, which is normal, and we are also
    able to delete tasks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有23个渲染，而不是71个，这是正常的，我们也能够删除任务：
- en: '![](assets/3910a623-ff9b-4198-947c-24f7574e0a9e.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3910a623-ff9b-4198-947c-24f7574e0a9e.png)'
- en: As you can see, the `useCallback` Hook helps us to improve performance significantly.
    In the next section, you will learn how to memorize a function passed as an argument
    in the `useEffect` Hook.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`useCallback` Hook帮助我们显着提高了性能。在下一节中，您将学习如何在`useEffect` Hook中记忆作为参数传递的函数。
- en: Memoizing function passed as an argument in effect
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为参数传递给effect的记忆函数
- en: 'There is a special case where we will need to use the `useCallback` Hook, and
    this is when we pass a function as an argument in a `useEffect` Hook, for example,
    in our `App` component. Let''s create a new `useEffect` block:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况，我们需要使用`useCallback` Hook，这是当我们将一个函数作为参数传递给`useEffect` Hook时，例如，在我们的`App`组件中。让我们创建一个新的`useEffect`块：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, we are listening for changes on the `todoList` state. If you
    run this code and you create or remove a task, it will work just fine (remember
    to remove all the other consoles first):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在监听`todoList`状态的变化。如果您运行此代码并创建或删除任务，它将正常工作（请记得首先删除所有其他控制台）：
- en: '![](assets/88a3b7ff-a819-4871-86c5-f2e7c2989aba.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88a3b7ff-a819-4871-86c5-f2e7c2989aba.png)'
- en: 'Everything works fine, but let''s add `todoList` to the console:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都运行正常，但让我们将`todoList`添加到控制台中：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you''re using Visual Studio Code, you will get the following warning:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Visual Studio Code，您将收到以下警告：
- en: '![](assets/47c343cd-00bc-4851-b52c-547a6ceeec9a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47c343cd-00bc-4851-b52c-547a6ceeec9a.png)'
- en: 'Basically, it is asking us to add the `printTodoList` function to the dependencies:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它要求我们将`printTodoList`函数添加到依赖项中：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But now, after we do that, we get another warning:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，在我们这样做之后，我们收到了另一个警告：
- en: '![](assets/7a3abf84-d180-43d3-acd6-c4bfe17fd267.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a3abf84-d180-43d3-acd6-c4bfe17fd267.png)'
- en: 'The reason why we get this warning is that we are now manipulating a state
    (consoling the state), which is why we need to add a `useCallback` Hook to this
    function to fix this issue:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到此警告的原因是我们现在正在操作一个状态（控制状态），这就是为什么我们需要在这个函数中添加`useCallback` Hook来解决这个问题：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, when we delete a task, we can see that `todoList` updated correctly:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们删除一个任务时，我们可以看到`todoList`已经正确更新了：
- en: '![](assets/333a4b5d-6f08-4e91-83ad-7fe0a24a8679.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/333a4b5d-6f08-4e91-83ad-7fe0a24a8679.png)'
- en: 'At this point, this may be information overload for you, so let''s have a quick
    recap:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这可能对您来说是信息过载，所以让我们快速回顾一下：
- en: '`memo`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo`：'
- en: Memorizes a **component**
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆**组件**
- en: Re-memorizes when props change
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当道具改变时重新记忆
- en: Avoids re-renders
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重新渲染
- en: '`useMemo`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo`：'
- en: Memorizes a **calculated value**
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆**计算值**
- en: For computed properties
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算属性
- en: For heavy processes
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于繁重的过程
- en: '`useCallback`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`：'
- en: Memorizes a **function definition** to avoid redefining it on each render.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆**函数定义**以避免在每次渲染时重新定义它。
- en: Use it whenever a function is passed as an effect argument.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当将函数作为效果参数传递时使用它。
- en: Use it whenever a function is passed by props to a memorized component.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当将函数作为道具传递给记忆组件时使用它。
- en: 'And finally, do not forget the golden rule: **Do not use them until absolutely
    necessary.**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记黄金法则：**除非绝对必要，否则不要使用它们。**
- en: In the next section, we are going to learn how to use the new `useReducer` Hook.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用新的`useReducer` Hook。
- en: Understanding the useReducer Hook
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解useReducer Hook
- en: 'You probably have some experience of using Redux (`react-redux`) with class
    components, and if that is the case, then you will understand how `useReducer`
    works. The concepts are basically the same: actions, reducers, dispatch, store,
    and state. Even if, in general, it seems very similar to `react-redux`, they have
    some differences. The main difference is that `react-redux` provides middleware
    and wrappers such as thunk, sagas, and many more besides, while `useReducer` just
    gives you a `dispatch` method that you can use to dispatch plain objects as actions.
    Also, `useReducer` does not have a store by default; instead, you can create one
    using `useContext`, but this is just reinventing the wheel.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有一些使用Redux（`react-redux`）与类组件的经验，如果是这样，那么您将了解`useReducer`的工作原理。基本概念基本相同：动作、减速器、分发、存储和状态。即使在一般情况下，它似乎与`react-redux`非常相似，它们也有一些不同之处。主要区别在于`react-redux`提供了中间件和包装器，如thunk、sagas等等，而`useReducer`只是提供了一个您可以使用来分发纯对象作为动作的`dispatch`方法。此外，`useReducer`默认没有存储；相反，您可以使用`useContext`创建一个，但这只是重复造轮子。
- en: 'Let''s create a basic application to understand how `useReducer` works. You
    can start by creating a new React app:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的应用程序来理解`useReducer`的工作原理。您可以通过创建一个新的React应用程序开始：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then, as always, you can delete all files in your `src` folder except `App.tsx`
    and `index.tsx` to start a brand-new application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像往常一样，您可以删除`src`文件夹中的所有文件，除了`App.tsx`和`index.tsx`，以启动全新的应用程序。
- en: 'We will create a basic `Notes` application where we can list, delete, create,
    or update our notes using `useReducer`. The first thing you need to do is import
    the `Notes` component, which we will create later, into your `App` component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的`Notes`应用程序，我们可以使用`useReducer`列出、删除、创建或更新我们的笔记。您需要做的第一件事是将我们稍后将创建的`Notes`组件导入到您的`App`组件中：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, in our `Notes` component, you first need to import `useReducer` and `useState`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`Notes`组件中，您首先需要导入`useReducer`和`useState`：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we need to define some TypeScript types that we need to use for our `Note`
    object, the Redux action, and the action types:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义一些我们需要用于`Note`对象、Redux动作和动作类型的TypeScript类型：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After this, we need to create `initialNotes` (also known as `initialState`)
    with some dummy notes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要创建`initialNotes`（也称为`initialState`）并添加一些虚拟笔记：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you remember how the reducers work, then this will seem very similar to
    how we handle the reducer using a `switch` statement, so as to perform basic operations
    such as `ADD`, `DELETE`, and `UPDATE`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得减速器的工作原理，那么这将与我们使用`switch`语句处理减速器的方式非常相似，以执行`ADD`、`DELETE`和`UPDATE`等基本操作：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, the component is very straightforward. Basically, you get the notes
    and the `dispatch` method from the `useReducer` Hook (similar to `useState`),
    and you need to pass the `reducer` function and `initialNotes` (`initialState`):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个组件非常简单。基本上，你从`useReducer` Hook中获取笔记和`dispatch`方法（类似于`useState`），你需要传递`reducer`函数和`initialNotes`（`initialState`）：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then, we have a `handleSubmit` function to create a new note when we write something
    in the input. Then, we press *Enter:*
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`handleSubmit`函数，当我们在输入框中写东西时，可以创建一个新的笔记。然后，我们按下*Enter*键：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we render our `Notes` list with `map`, and we also create two buttons,
    one for delete and one for update, and then the input should be wrapped into a
    `<form>` tag:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`map`渲染我们的`Notes`列表，并创建两个按钮，一个用于删除，一个用于更新，然后输入框应该包装在`<form>`标签中：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run the application, you should see the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你应该看到以下输出：
- en: '![](assets/bf608854-dd2c-45c9-b79f-62980c4fa16e.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf608854-dd2c-45c9-b79f-62980c4fa16e.png)'
- en: 'As you can see in the React DevTools, the `Reducer` object contains the two
    notes that we have defined as our initial state. Now, if you write something in
    the input and you press *Enter*, you should be able to create a new note:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在React DevTools中所看到的，`Reducer`对象包含了我们定义的两个笔记作为初始状态。现在，如果你在输入框中写点东西，然后按下*Enter*，你应该能够创建一个新的笔记：
- en: '![](assets/12c45050-34b0-48da-9360-078d81bac8ac.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12c45050-34b0-48da-9360-078d81bac8ac.png)'
- en: 'Then, if you want to delete a note, you just need to click on the X button.
    Let''s remove Note 2:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你想删除一个笔记，你只需要点击X按钮。让我们删除笔记2：
- en: '![](assets/b59b6e27-19c5-4086-be3d-8b298b5ae25d.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b59b6e27-19c5-4086-be3d-8b298b5ae25d.png)'
- en: 'Finally, you can write anything you want in the input, and if you click on
    the Update button, you will change the note value:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在输入框中写任何你想要的东西，如果你点击更新按钮，你将改变笔记的值：
- en: '![](assets/dd7d6d51-28c4-43ab-8223-35ee015dde78.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd7d6d51-28c4-43ab-8223-35ee015dde78.png)'
- en: Nice, huh? As you can see the `useReducer` Hook is pretty much the same as redux
    in terms of the dispatch method, actions, and reducers, but the main difference
    is that this is limited just to the context of your component and its child, so
    if you need a global store to be accessible from your entire application then
    you should use `react-redux` instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，对吧？正如你所看到的，`useReducer` Hook在`dispatch`方法、动作和reducers方面与redux基本相同，但主要区别在于这仅限于你的组件及其子组件的上下文，因此，如果你需要一个全局存储来自你整个应用程序，那么你应该使用`react-redux`。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you enjoyed reading this chapter, which is full of very good information
    pertaining to the new React Hooks. So far, you have learned how the new React
    Hooks work, how to fetch data with Hooks, how to migrate a class component to
    React Hooks, how the effects work, the difference between `memo`, `useMemo`, and
    `useCallback`, and finally, you learned how the `useReducer` Hook works and the
    main difference compared with `react-redux`. This will help you to improve the
    performance of your React components.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢阅读这一章，其中包含了有关新的React Hooks的非常好的信息。到目前为止，你已经学会了新的React Hooks是如何工作的，如何使用Hooks获取数据，如何将类组件迁移到React
    Hooks，效果是如何工作的，`memo`、`useMemo`和`useCallback`之间的区别，最后，你学会了`useReducer` Hook的工作原理，以及与`react-redux`相比的主要区别。这将帮助你提高React组件的性能。
- en: In the next chapter, we will go through some of the most popular composition
    patterns and tools.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些最流行的组合模式和工具。
