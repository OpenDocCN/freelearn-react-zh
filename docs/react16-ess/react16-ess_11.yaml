- en: Chapter 11. Preparing Your React Application for Painless Maintenance with Flux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。为Flux轻松维护准备您的React应用程序
- en: 'The reason why we decided to implement the Flux architecture in our React application
    is that we want to have a data flow that is easier to maintain. In the previous
    chapter, we implemented `AppDispatcher`, `TweetActionCreators`, and `TweetStore`.
    Let’s quickly remember what they are used for:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定在React应用程序中实现Flux架构的原因是我们希望拥有更容易维护的数据流。在上一章中，我们实现了`AppDispatcher`、`TweetActionCreators`和`TweetStore`。让我们快速回想一下它们的用途：
- en: '`TweetActionCreators`: This creates and dispatches the actions'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TweetActionCreators：这创建并分发动作
- en: '`AppDispatcher`: This dispatches all the actions to all stores'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDispatcher`：这将所有动作分发到所有存储'
- en: '`TweetStore`: This stores and manages the application data'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TweetStore`：这存储和管理应用程序数据'
- en: 'The only missing parts in our data flow are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据流中唯一缺失的部分如下：
- en: Using `TweetActionCreators` to create the actions and start the data flowing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TweetActionCreators`创建动作并启动数据流
- en: Using `TweetStore` to get data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TweetStore`获取数据
- en: 'Here are a couple of important questions to ask: where in our application does
    the data flow start? What is our data? If we answer these questions, we will understand
    where to start refactoring our application to adapt the Flux architecture.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的问题要问：我们的应用程序中数据流从哪里开始？我们的数据是什么？如果我们回答了这些问题，我们将了解从哪里开始重构我们的应用程序以适应Flux架构。
- en: 'Snapterest allows users to receive and collect the latest tweets. The only
    data that our application is concerned with is tweets. So our data flow begins
    with receiving new tweets. What part of our application is responsible for receiving
    new tweets at the moment? You might remember that our `Stream` component has the
    following `componentDidMount()` method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Snapterest允许用户接收和收集最新的推文。我们的应用程序关心的唯一数据是推文。因此，我们的数据流始于接收新推文。目前，我们的应用程序的哪个部分负责接收新推文？您可能还记得我们的`Stream`组件具有以下`componentDidMount()`方法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yes, currently, we initiate a stream of new tweets after we render the `Stream`
    component. Wait, you might ask, "Didn’t we learn that React components should
    only be concerned with rendering the user interface?" You’re correct. Unfortunately,
    at the moment, the `Stream` component is responsible for two different things:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，目前，在渲染`Stream`组件后，我们启动了一系列新推文。等等，你可能会问，“我们不是学过React组件应该只关注渲染用户界面吗？”你是对的。不幸的是，目前，`Stream`组件负责两件不同的事情：
- en: Rendering the `StreamTweet` component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染`StreamTweet`组件
- en: Initiating the data flow
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动数据流
- en: Clearly, it’s a potential maintenance issue in the future. Let’s decouple these
    two different concerns with the help of Flux.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是未来潜在的维护问题。让我们借助Flux来解耦这两个不同的关注点。
- en: Decoupling concerns with Flux
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flux解耦关注点
- en: 'First, we’ll create a new utility module called `WebAPIUtils`. Create the `WebAPIUtils.js`
    file in the `~/snapterest/source/utils/` directory:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`WebAPIUtils`的新实用程序模块。在`~/snapterest/source/utils/`目录中创建`WebAPIUtils.js`文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this utility module, we first import the `SnapkiteStreamClient` library
    and `TweetActionCreators`. Then, we create the `initializeStreamOfTweets()` function
    that initializes a stream of new tweets, just like in the `componentDidMount()`
    method of the `Stream` component. Except with one key difference: whenever `SnapkiteStreamClient`
    receives a new tweet, it calls the `TweetActionCreators.receiveTweet` method that
    passes a new tweet to it as an argument:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实用程序模块中，我们首先导入`SnapkiteStreamClient`库和`TweetActionCreators`。然后，我们创建`initializeStreamOfTweets()`函数，该函数初始化一系列新推文，就像`Stream`组件的`componentDidMount()`方法一样。除了一个关键的区别：每当`SnapkiteStreamClient`接收到新推文时，它调用`TweetActionCreators.receiveTweet`方法，并将新推文作为参数传递给它：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remember that the `receiveTweet` function expects to receive a `tweet` argument:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`receiveTweet`函数期望接收一个`tweet`参数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tweet will then be dispatched as a property of a new action object that
    the `receiveTweet()` function creates.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推文将作为一个新动作对象的属性被分发。`receiveTweet()`函数创建。
- en: Then, the `WebAPIUtils` module exports our `initializeStreamOfTweets()` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`WebAPIUtils`模块导出我们的`initializeStreamOfTweets()`函数。
- en: 'Now we have a module with a method that initiates the data flow in our Flux
    architecture. Where should we import and call it? Since it’s decoupled from the
    `Stream` component, and in fact, it doesn’t depend on any React component at all,
    we can use it even before React renders anything. Let’s use it in our `app.js`
    file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模块，其中有一个方法来启动我们的Flux架构中的数据流。我们应该在哪里导入并调用它？由于它与`Stream`组件解耦，实际上，它根本不依赖于任何React组件，我们甚至可以在React渲染任何内容之前使用它。让我们在我们的`app.js`文件中使用它：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, all that we need to do is to import and call the `initializeStreamOfTweets()`
    method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们所需要做的就是导入并调用`initializeStreamOfTweets()`方法：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We do this before calling React’s `render()` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用React的`render()`方法之前我们这样做：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In fact, as an experiment, you can remove the `ReactDOM.render()` line of code
    altogether, and put a log statement in the `TweetActionCreators.receiveTweet`
    function. For example, run the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，作为一个实验，你可以完全删除`ReactDOM.render()`这行代码，并在`TweetActionCreators.receiveTweet`函数中放一个日志声明。例如，运行以下代码：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now run the `npm start` command. Then, open `~/snapterest/build/index.html`
    in a web browser—you’ll see the following text rendered on the page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`npm start`命令。然后，在Web浏览器中打开`~/snapterest/build/index.html`，你会看到以下文本呈现在页面上：
- en: '**I am about to learn the essentials of React.js.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**我即将学习React.js的基本知识。**'
- en: 'Now open JavaScript Console and you’ll see this output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开JavaScript控制台，你会看到这个输出：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This log message will be printed out for each new tweet that our application
    receives. Even though we didn’t render any React component, our Flux architecture
    is still there:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日志消息将被打印出来，每当我们的应用程序接收到一个新的推文时。即使我们没有渲染任何React组件，我们的Flux架构仍然存在：
- en: Our application receives a new tweet.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序接收到一个新的推文。
- en: It creates and dispatches a new action.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建并分发一个新的动作。
- en: No stores have registered with the dispatcher, so there is no one to receive
    the new action; hence, nothing is happening.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有任何存储器已经向分发器注册，因此没有人可以接收新的动作；因此，什么也没有发生。
- en: Now you can clearly see how React and Flux are two separate things that don’t
    depend on each other at all.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以清楚地看到React和Flux是两个完全不相互依赖的东西。
- en: 'However, we do want to render our React components. After all, we’ve put so
    much effort into creating them in the previous ten chapters! To do this, we need
    to put our `TweetStore` store into action. Can you guess where we should use it?
    Here’s a hint: in a React component that needs a tweet to render itself—our good
    old `Stream` component.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实希望渲染我们的React组件。毕竟，在前面的十章中，我们已经付出了很多努力来创建它们！为了做到这一点，我们需要让我们的`TweetStore`存储器发挥作用。你能猜到我们应该在哪里使用它吗？这里有一个提示：在一个需要推文来呈现自己的React组件中——我们的老朋友`Stream`组件。
- en: Refactoring the Stream component
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构Stream组件
- en: 'Now with the Flux architecture in place, we will rethink how our React components
    get data that they need to render. As you know, there are usually two sources
    of data for a React component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了Flux架构，我们将重新思考我们的React组件如何获取它们需要呈现的数据。如你所知，React组件通常有两个数据来源：
- en: Calling another library, for example, calling the `jQuery.ajax()` method, or
    in our case, `SnapkiteStreamClient.initializeStream()`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用另一个库，例如调用`jQuery.ajax()`方法，或者在我们的情况下，`SnapkiteStreamClient.initializeStream()`
- en: Receiving data from a parent React component via the `props` object
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`props`对象从父React组件接收数据
- en: We want our React components to not use any external libraries to receive data.
    Instead, from now on, they will get that same data from stores. Keeping this plan
    in mind, let’s refactor our `Stream` component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的React组件不使用任何外部库来接收数据。从现在开始，它们将从商店获取相同的数据。牢记这个计划，让我们重构我们的`Stream`组件。
- en: 'Here is how it looks now:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它看起来是这样的：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, let’s get rid of the `componentDidMount()`, `componentWillUnmount()`,
    and `handleNewTweet()` methods and import the `TweetStore` store:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们摆脱`componentDidMount()`、`componentWillUnmount()`和`handleNewTweet()`方法，并导入`TweetStore`商店：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is also no need to import the `snapkite-stream-client` module anymore.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 也不再需要导入`snapkite-stream-client`模块。
- en: 'Next, we need to change how the `Stream` component gets its initial tweet.
    Let’s update its initial state:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要改变`Stream`组件如何获取其初始推文。让我们更新它的初始状态：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Code-wise, this might look like a small change, but it’s a significant architectural
    improvement. We are now using the `getTweet()` method to get data from the `TweetStore`
    store. In the previous chapter, we discussed how stores expose the public methods
    in Flux in order to allow other parts of our application to get data from them.
    The `getTweet()` method is an example of one of these public methods, which are
    called *getters*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码上看，这可能看起来是一个小改变，但这是一个重大的架构改进。我们现在使用`getTweet()`方法从`TweetStore`商店获取数据。在上一章中，我们讨论了Flux中商店如何公开方法，以允许我们应用程序的其他部分从中获取数据。`getTweet()`方法是这些公共方法的一个例子，被称为*getters*。
- en: You can get data from a store, but you can’t set data on a store directly just
    like that. Stores have no public *setter* methods. They are purposely designed
    with this limitation in mind so that when you write your application with Flux,
    your data can only flow in one direction. This will benefit you hugely down the
    road when you’ll need to maintain your Flux application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从商店获取数据，但不能直接在商店上设置数据。商店没有公共的*setter*方法。它们是有意设计成这样的限制，这样当你用Flux编写应用程序时，你的数据只能单向流动。当你需要维护Flux应用程序时，这将极大地使你受益。
- en: Now we know how to get our initial tweet, but how do we get all the other new
    tweets that will arrive later? We can create a timer and call `TweetStore.getTweet()`
    repeatedly; however, this is not the best solution because it assumes that we
    don’t know when `TweetStore` updates its tweet with a new one. However, we do
    know that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何获取我们的初始推文，但是我们如何获取以后到达的所有其他新推文呢？我们可以创建一个定时器并重复调用`TweetStore.getTweet()`；然而，这不是最好的解决方案，因为它假设我们不知道`TweetStore`何时更新其推文。然而，我们知道。
- en: 'How? Remember that in the previous chapter, we implemented the following public
    methods on the `TweetStore` object, that is, the `addChangeListener()` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如何？记得在上一章中，我们在`TweetStore`对象上实现了以下公共方法，即`addChangeListener()`方法：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We implemented the `removeChangeListener()` method as well:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`removeChangeListener()`方法：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That’s right. We can ask `TweetStore` to tell us when it changes its data. For
    this, we need to call its `addChangeListener()` method and pass it a callback
    function that `TweetStore` will call for each new tweet. The question is that
    in our `Stream` component, where do we call the `TweetStore.addChangeListener()`
    method?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。我们可以要求`TweetStore`告诉我们它何时更改其数据。为此，我们需要调用它的`addChangeListener()`方法，并传递一个回调函数，`TweetStore`将为每个新推文调用它。问题是，在我们的`Stream`组件中，我们在哪里调用`TweetStore.addChangeListener()`方法？
- en: 'Since we need to add the `change` event listener to `TweetStore` only once
    per component’s lifecycle, it makes `componentDidMount()` a perfect candidate.
    Add the following `componentDidMount()` method to the `Stream` component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在组件的生命周期中只一次向`TweetStore`添加`change`事件监听器，所以`componentDidMount()`是一个完美的选择。在`Stream`组件中添加以下`componentDidMount()`方法：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we add our own `change` event listener, `this.onTweetChange`, to `TweetStore`.
    Now when `TweetStore` changes its data, it will trigger our `this.onTweetChange`
    method. We will create this method shortly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`TweetStore`添加了我们自己的`change`事件监听器`this.onTweetChange`。现在当`TweetStore`改变其数据时，它将触发我们的`this.onTweetChange`方法。我们将很快创建这个方法。
- en: 'Don’t forget that we need to remove any event listeners before we unmount our
    React component. To do this, add the following `componentWillUnmount()` method
    to the `Stream` component:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在卸载React组件之前删除任何事件侦听器。为此，将以下`componentWillUnmount()`方法添加到`Stream`组件中：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Removing an event listener is very similar to adding it. We call the `TweetStore.removeChangeListener()`
    method and pass our `this.onTweetChange` method as an argument.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 删除事件侦听器与添加事件侦听器非常相似。我们调用`TweetStore.removeChangeListener()`方法，并将我们的`this.onTweetChange`方法作为参数传递。
- en: 'Now, it’s time to create the `onTweetChange` method in our `Stream` component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在我们的`Stream`组件中创建`onTweetChange`方法了：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, it updates the component’s state with a new tweet stored in
    `TweetStore` using the `TweetStore.getTweet()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它使用`TweetStore.getTweet()`方法将新的推文存储在`TweetStore`中，并更新组件的状态。
- en: 'There is one final change that we need to make in our `Stream` component. Later
    in this chapter, you’ll learn that our `StreamTweet` component doesn’t need the
    `handleAddTweetToCollection()` callback function anymore; therefore, in this component,
    we’re going to change the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`Stream`组件中进行最后一个更改。在本章的后面，您将了解到我们的`StreamTweet`组件不再需要`handleAddTweetToCollection()`回调函数；因此，在这个组件中，我们将更改以下代码片段：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace it with the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let’s take a look at our newly refactored `Stream` component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们新重构的`Stream`组件：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s recap to see how our `Stream` component always has the latest tweet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，看看我们的`Stream`组件如何始终具有最新的推文：
- en: We set the component’s initial tweet to the latest tweet that we get from `TweetStore`
    using the `getTweet()` method.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`getTweet()`方法将组件的初始推文设置为从`TweetStore`获取的最新推文。
- en: Then, we listen to changes in `TweetStore`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们监听`TweetStore`的变化。
- en: When `TweetStore` changes its tweet, we update the component’s state to the
    latest tweet that we get from `TweetStore` using the `getTweet()` method.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TweetStore`改变其推文时，我们使用`getTweet()`方法从`TweetStore`获取最新的推文，并更新组件的状态。
- en: When the component is about to unmount, we stop listening to the changes in
    `TweetStore`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件即将卸载时，我们停止监听`TweetStore`的变化。
- en: This is how a React component interacts with a Flux store.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是React组件与Flux存储区交互的方式。
- en: 'Before we move on to make the rest of our application Flux-strong, let’s take
    a look at our current data flow:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使我们的应用程序其余部分变得更加Flux强大之前，让我们来看看我们当前的数据流：
- en: '`app.js`: This receives the new tweets and calls `TweetActionCreators` for
    each tweet'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`：这接收新推文并为每个推文调用`TweetActionCreators`'
- en: '`TweetActionCreators`: This creates and dispatches a new action with a new
    tweet'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TweetActionCreators`：这将创建并分发一个带有新推文的新操作'
- en: '`AppDispatcher`: This dispatches all the actions to all stores'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDispatcher`：这将所有操作分发到所有存储区'
- en: '`TweetStore`: This registers with a dispatcher and emits the change event on
    every new action received from a dispatcher'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TweetStore`：这将向调度程序注册，并在从调度程序接收到新操作时发出更改事件'
- en: '`Stream`: This listens to changes in `TweetStore`, gets a new tweet from `TweetStore`,
    updates the state with a new tweet, and re-renders'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`：这监听`TweetStore`的变化，从`TweetStore`获取新的推文，更新状态并重新渲染'
- en: Can you see how we can now scale the number of React components, action creators,
    and stores, and still be able to maintain Snapterest? With Flux, it will always
    be a one-way data flow. It will be the same mental model regardless of how many
    new features we’ll implement. We will hugely benefit in the long run, when we’ll
    need to maintain our app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到我们如何现在可以扩展React组件、动作创建者和存储的数量，仍然能够维护Snapterest吗？使用Flux，它将始终是单向数据流。无论我们实现多少新功能，它都将是相同的思维模式。在长期来看，当我们需要维护我们的应用程序时，我们将获得巨大的好处。
- en: Did I mention that we’re going to adapt Flux in our application even more? Next,
    let’s do exactly that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否提到我们将在我们的应用程序中更多地使用Flux？接下来，让我们确实这样做。
- en: Creating CollectionStore
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CollectionStore
- en: Not only does Snapterest store the latest tweet, but it also stores a collection
    of tweets that users create. Let’s refactor this feature with Flux.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Snapterest不仅存储最新的推文，还存储用户创建的推文集合。让我们用Flux重构这个功能。
- en: 'First, let’s create a collection store. Navigate to the `~/snapterest/source/stores/`
    directory and create the `CollectionStore.js` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个集合存储。导航到`~/snapterest/source/stores/`目录并创建`CollectionStore.js`文件：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `CollectionStore` is a bigger store, but it has the same structure as `TweetStore`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: CollectionStore是一个更大的存储，但它具有与TweetStore相同的结构。
- en: 'First, we import the dependencies and assign a `change` event name to the `CHANGE_EVENT`
    variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入依赖项并将`CHANGE_EVENT`变量分配给`change`事件名称：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we define our data and the four private methods that mutate this data:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的数据和四个私有方法来改变这些数据：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, we store a collection of tweets in an object that is initially
    empty, and we also store the collection name that is initially set to `new`. Then,
    we create three private functions that mutate `collectionTweets`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在一个最初为空的对象中存储了一系列推文，并且我们还存储了最初设置为`new`的集合名称。然后，我们创建了三个私有函数来改变`collectionTweets`：
- en: '`addTweetToCollection()`: As the name suggests, it adds the `tweet` object
    to the `collectionTweets` object'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`tweet`对象添加到`collectionTweets`对象
- en: '`removeTweetFromCollection()`: This removes the `tweet` object from the `collectionTweets`
    object'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`collectionTweets`对象中删除`tweet`对象
- en: '`removeAllTweetsFromCollection()`: This removes all the `tweet` objects from
    `collectionTweets` by setting it to an empty object'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`collectionTweets`中删除所有`tweet`对象，将其设置为空对象
- en: Then, we define one private function that mutates `collectionName` called `setCollectionName`,
    which changes the existing collection name to a new one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个私有函数来改变`collectionName`，名为`setCollectionName`，它将现有的集合名称更改为新的名称。
- en: 'These functions are regarded as private because they are not accessible outside
    the `CollectionStore` module; for example, you *can’t* access them like that in
    any other module:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数被视为私有，因为它们在CollectionStore模块之外是不可访问的；例如，你*不能*像在任何其他模块中那样访问它们：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we discussed earlier, this is done on purpose to enforce a one-way data flow
    in your application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，这是有意为之的，以强制在应用程序中实现单向数据流。
- en: We create the `emitChange()` method that emits the `change` event.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`emitChange()`方法来发出`change`事件。
- en: 'Then, we create the `CollectionStore` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建CollectionStore对象：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is very similar to the `TweetStore` object, except for two methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这与TweetStore对象非常相似，只有两种方法不同：
- en: '`getCollectionTweets()`: This returns a collection of tweets'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取推文集合
- en: '`getCollectionName()`: This returns the collection name'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取集合名称
- en: These methods are accessible outside the `CollectionStore.js` file and should
    be used in React components to get data from `CollectionStore`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以在CollectionStore.js文件之外访问，并且应该在React组件中用于从CollectionStore获取数据。
- en: 'Then, we create the `handleAction()` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建handleAction（）函数：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function handles the actions that are dispatched by `AppDispatcher`, but
    unlike `TweetStore` in our `CollectionStore` module, we can handle more than one
    action. In fact, we can handle the four actions that are related to the collection
    of tweets:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数处理由AppDispatcher分发的操作，但与我们CollectionStore模块中的TweetStore不同，我们可以处理多个操作。实际上，我们可以处理与Tweet集合相关的四个操作：
- en: '`add_tweet_to_collection`: This adds a tweet to a collection'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: add_tweet_to_collection：这将向集合中添加一条Tweet
- en: '`remove_tweet_from_collection`: This removes a tweet from a collection'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: remove_tweet_from_collection：这将从集合中删除一条Tweet
- en: '`remove_all_tweets_from_collection`: This removes all the tweets from a collection'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: remove_all_tweets_from_collection：这将从集合中删除所有Tweet
- en: '`set_collection_name`: This sets a collection name'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: set_collection_name：这将设置集合名称
- en: Remember that all the stores receive all the actions, so `CollectionStore` will
    receive the `receive_tweet` action as well, but we simply ignore it in this store,
    just like `TweetStore` ignores `add_tweet_to_collection`, `remove_tweet_from_collection`,
    `remove_all_tweets_from_collection`, and `set_collection_name`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有存储都会接收所有操作，因此CollectionStore也将接收receive_tweet操作，但是在这个存储中我们只是简单地忽略它，就像TweetStore忽略add_tweet_to_collection，remove_tweet_from_collection，remove_all_tweets_from_collection和set_collection_name一样。
- en: 'Then, we register the `handleAction` callback with `AppDispatcher`, and save
    `dispatchToken` in the `CollectionStore` object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用AppDispatcher注册handleAction回调，并将dispatchToken保存在CollectionStore对象中：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we export `CollectionStore` as a module:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将CollectionStore作为一个模块导出：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now since we have the collection store ready, let’s create action creator functions
    next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们已经准备好了集合存储，让我们创建动作创建函数。
- en: Creating CollectionActionCreators
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CollectionActionCreators
- en: 'Navigate to `~/snapterest/source/actions/` and create the `CollectionActionCreators.js`
    file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到~/snapterest/source/actions/并创建CollectionActionCreators.js文件：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For each action that we handle in `CollectionStore`, we have an action creator
    function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在CollectionStore中处理的每个操作，我们都有一个操作创建函数：
- en: '`addTweetToCollection()`: This creates and dispatches the `add_tweet_to_collection`
    action with a new tweet'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Tweet添加到Collection中（）：这将创建并分发带有新Tweet的add_tweet_to_collection动作
- en: '`removeTweetFromCollection()`: This creates and dispatches the `remove_tweet_from_collection`
    action with the ID of the tweet that must be removed from the collection'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: removeTweetFromCollection（）：这将创建并分发带有必须从集合中删除的Tweet的ID的remove_tweet_from_collection动作
- en: '`removeAllTweetsFromCollection()`: This creates and dispatches the `remove_all_tweets_from_collection`
    action'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: removeAllTweetsFromCollection（）：这将创建并分发remove_all_tweets_from_collection动作
- en: '`setCollectionName()`: This creates and dispatches the `set_collection_name`
    action with a new collection name'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setCollectionName（）：这将创建并分发带有新集合名称的set_collection_name动作
- en: Now when we’ve created both the `CollectionStore` and `CollectionActionCreators`
    modules, we can start refactoring our React components to adopt the Flux architecture.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建了CollectionStore和CollectionActionCreators模块时，我们可以开始重构我们的React组件以采用Flux架构。
- en: Refactoring the Application component
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构Application组件
- en: Where do we start refactoring our React components? Let’s start with our topmost
    React component in our components hierarchy, `Application`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从哪里开始重构我们的React组件？让我们从组件层次结构中的顶层React组件Application开始。
- en: At the moment, our `Application` component stores and manages the collection
    of tweets. Let’s remove this functionality as it’s now managed by the collection
    store.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的Application组件存储和管理Tweet的集合。让我们删除这个功能，因为现在它由集合存储管理。
- en: 'Remove the `constructor()`, `addTweetToCollection()`, `removeTweetFromCollection()`,
    and `removeAllTweetsFromCollection()` methods from the `Application` component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Application`组件中删除`constructor()`、`addTweetToCollection()`、`removeTweetFromCollection()`和`removeAllTweetsFromCollection()`方法：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now the `Application` component has only the `render()` method that renders
    the `Stream` and `Collection` components. Since it doesn’t manage the collection
    of tweets anymore, we don’t need to pass any properties to the `Stream` and `Collection`
    components as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Application`组件只有`render()`方法来渲染`Stream`和`Collection`组件。由于它不再管理推文集合，我们也不需要向`Stream`和`Collection`组件传递任何属性。
- en: 'Update the `Application` component’s `render()` function, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Application`组件的`render()`函数如下：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The adoption of the Flux architecture allows the `Stream` component to manage
    the latest tweet and the `Collection` component to manage the collection of tweets,
    whereas the `Application` component doesn’t need to manage anything anymore, so
    it becomes a container component that wraps the `Stream` and `Collection` components
    in the additional HTML markup.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构的采用允许`Stream`组件管理最新的推文，`Collection`组件管理推文集合，而`Application`组件不再需要管理任何东西，因此它成为一个容器组件，用额外的HTML标记包装`Stream`和`Collection`组件。
- en: 'In fact, you might have noticed that our current version of `Application` component
    is a good candidate to become a functional React component:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可能已经注意到我们当前版本的`Application`组件是成为一个功能性React组件的一个很好的候选：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our `Application` component is now much simpler and its markup looks much cleaner.
    This improves the component’s maintainability. Well done!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Application`组件现在更简单，其标记看起来更清洁。这提高了组件的可维护性。干得好！
- en: Refactoring the Collection component
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构集合组件
- en: 'Next, let’s refactor our `Collection` component. Replace the existing `Collection`
    component with the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重构我们的`Collection`组件。用以下内容替换现有的`Collection`组件：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What did we change here? A few things. First, we imported the two new modules:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里改变了什么？有几件事。首先，我们导入了两个新模块：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We created the `CollectionUtils` module in [Chapter 9](ch09.html "Chapter 9. Testing
    Your React Application with Jest"), *Testing Your React Application with Jest*,
    and in this chapter, we’re using it. `CollectionStore` is where we get our data
    from.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第9章](ch09.html "第9章。使用Jest测试您的React应用程序")中创建了`CollectionUtils`模块，*使用Jest测试您的React应用程序*，在本章中，我们正在使用它。`CollectionStore`是我们获取数据的地方。
- en: 'Next, you should be able to spot the familiar pattern of the four methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该能够发现这四种方法的熟悉模式：
- en: In the initial state, we set the collection of tweets to what is stored in `CollectionStore`
    at that moment. As you may recall that `CollectionStore` provides the `getCollectionTweets()`
    method to get the data from it.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始状态下，我们将推文集合设置为`CollectionStore`中存储的内容。您可能还记得`CollectionStore`提供了`getCollectionTweets()`方法来获取其中的数据。
- en: In the `componentDidMount()` method, we add the `change` event listener, `this.onCollectionChange`
    to `CollectionStore`. Whenever the collection of tweets is updated, `CollectionStore`
    will call our `this.onCollectionChange` callback function to notify the `Collection`
    component of that change.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`componentDidMount()`方法中，我们向`CollectionStore`添加`change`事件监听器`this.onCollectionChange`。每当推文集合更新时，`CollectionStore`将调用我们的`this.onCollectionChange`回调函数来通知`Collection`组件该变化。
- en: In the `componentWillUnmount()` method, we remove the `change` event listener
    that we added to the `componentDidMount()` method.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`componentWillUnmount()`方法中，我们移除了在`componentDidMount()`方法中添加的`change`事件监听器。
- en: In the `onCollectionChange()` method, we set the component’s state to whatever
    is stored in `CollectionStore` at that moment in time. Updating the component’s
    state triggers a re-render.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onCollectionChange()`方法中，我们将组件的状态设置为当前存储在`CollectionStore`中的内容。更新组件的状态会触发重新渲染。
- en: 'The `Collection` component’s `render()` method is now simpler and cleaner:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`组件的`render()`方法现在更简单、更清晰：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We use the `CollectionUtils` module to get a number of tweets in the collection,
    and we pass fewer properties to the child components: `CollectionControls` and
    `TweetList`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CollectionUtils`模块来获取集合中的推文数量，并向子组件`CollectionControls`和`TweetList`传递更少的属性。
- en: Refactoring the CollectionControls component
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`CollectionControls`组件
- en: 'The `CollectionControls` component gets some major improvements as well. Let’s
    take a look at the refactored version first and then discuss what was updated
    and why:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionControls`组件也有一些重大改进。让我们先看一下重构后的版本，然后讨论更新了什么以及为什么更新：'
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First, we import the two additional modules:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入另外两个模块：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that we don’t manage the collection name in this component anymore.
    Instead, we get it from our `CollectionStore` module:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再在这个组件中管理集合名称。相反，我们从`CollectionStore`模块中获取它：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we make one of the key changes. We replace the `setCollectionName()`
    method with a new one, `removeAllTweetsFromCollection()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进行了一个关键的改变。我们用一个新的`removeAllTweetsFromCollection()`方法替换了`setCollectionName()`方法：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `removeAllTweetsFromCollection()` method is called when a user clicks on
    the `Empty Collection` button. This user action triggers the `removeAllTweetsFromCollection()`
    action creator function that creates and dispatches the action to stores. In turn,
    `CollectionStore` removes all the tweets from the collection and emits the `change`
    event.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“清空集合”按钮时，将调用`removeAllTweetsFromCollection()`方法。这个用户操作会触发`removeAllTweetsFromCollection()`动作创建函数，它创建并分发动作到存储中。然后，`CollectionStore`会从集合中删除所有推文并发出`change`事件。
- en: Next, let’s refactor our `CollectionRenameForm` component.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重构我们的`CollectionRenameForm`组件。
- en: Refactoring the CollectionRenameForm component
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`CollectionRenameForm`组件
- en: '`CollectionRenameForm` is a controlled form component. This means that its
    input value is stored in the component’s state, and the only way to update that
    value is to update the component’s state. It has the initial value that it should
    get from `CollectionStore`, so let’s make that happen.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionRenameForm`是一个受控表单组件。这意味着它的输入值存储在组件的状态中，更新该值的唯一方法是更新组件的状态。它具有应该从`CollectionStore`获取的初始值，所以让我们实现这一点。'
- en: 'First, import the `CollectionActionCreators` and `CollectionStore` modules:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入`CollectionActionCreators`和`CollectionStore`模块：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to remove its existing `constructor()` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要删除它现有的`constructor()`方法：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Replace the preceding code with the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换前面的代码：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, the only difference is that now we get the initial `inputValue`
    from `CollectionStore`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，唯一的区别是现在我们从`CollectionStore`获取初始的`inputValue`。
- en: 'Next, let’s update the `handleFormSubmit()` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`handleFormSubmit()`方法：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update the preceding code with the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码更新前面的代码：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The important difference here is that when a user submits a form, we will create
    a new action that sets a new name in our collection store:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要区别在于，当用户提交表单时，我们将创建一个新的操作，在我们的集合存储中设置一个新的名称：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we need to change the source of the collection name in the `handleFormCancel()`
    method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`handleFormCancel()`方法中更改集合名称的来源：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Change the preceding code with the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换前面的代码：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once again, we get the collection name from a collection store:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从集合存储中获取集合名称：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is all that we need to change in the `CollectionRenameForm` component.
    Let’s refactor the `TweetList` component next.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要在`CollectionRenameForm`组件中更改的全部内容。让我们接下来重构`TweetList`组件。
- en: Refactoring the TweetList component
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`TweetList`组件
- en: The `TweetList` component renders a list of tweets. Each tweet is a `Tweet`
    component that a user can click on to remove it from a collection. Does it sound
    to you like it could make use of `CollectionActionCreators`?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`TweetList`组件渲染了一系列推文。每个推文都是一个`Tweet`组件，用户可以点击以将其从集合中移除。听起来好像它可以利用`CollectionActionCreators`吗？'
- en: 'That’s right. Let’s add the `CollectionActionCreators` module to it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。让我们将`CollectionActionCreators`模块添加到其中：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we’ll create the `removeTweetFromCollection()` callback function that
    will be called when a user clicks on a tweet image:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建`removeTweetFromCollection()`回调函数，当用户点击推文图片时将被调用：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, it creates a new action using the `removeTweetFromCollection()`
    function by passing the tweet ID as an argument to it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它使用`removeTweetFromCollection()`函数创建了一个新的动作，并将推文ID作为参数传递给它。
- en: 'Finally, we need to make sure that `removeTweetFromCollection()` is actually
    called. In the `getTweetElement()` method, find the following line:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保实际调用了`removeTweetFromCollection()`。在`getTweetElement()`方法中，找到以下行：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now replace it with the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用以下代码替换它：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’re all done with this component. `StreamTweet` is next in our refactoring
    journey.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这个组件。接下来是我们重构之旅中的`StreamTweet`。
- en: Refactoring the StreamTweet component
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`StreamTweet`组件
- en: '`StreamTweet` renders a tweet image that a user can click on to add it to a
    collection of tweets. You might have already guessed that we’re going to create
    and dispatch a new action when a user clicks on that tweet image.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamTweet`渲染了用户可以点击以将其添加到推文集合中的推文图片。您可能已经猜到，当用户点击该推文图片时，我们将创建并分发一个新的动作。'
- en: 'First, import the `CollectionActionCreators` module to the `StreamTweet` component:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`CollectionActionCreators`模块导入`StreamTweet`组件：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, add a new `addTweetToCollection()` method to it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在其中添加一个新的`addTweetToCollection()`方法：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `addTweetToCollection()` callback function should be invoked when a user
    clicks on a tweet image. Let’s take a look at this line in the `render()` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击推文图片时，应调用`addTweetToCollection()`回调函数。让我们看看`render()`方法中的这行代码：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Replace the preceding code with the following line of code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下行代码替换前面的代码：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we need to replace the following line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要替换以下行：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use this one instead:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个代替：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `StreamTweet` component is now done.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamTweet`组件现在已经完成。'
- en: Building and going beyond
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和超越
- en: That’s all the effort that is needed to integrate the Flux architecture into
    our React application. If you compare your React application without Flux and
    with Flux, you’ll quickly see how much easier it is to understand how your application
    works when Flux is part of it. You can learn more about Flux at [https://facebook.github.io/flux/](https://facebook.github.io/flux/).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将Flux架构集成到我们的React应用程序中所需的所有工作。如果您比较一下没有Flux的React应用程序和有Flux的React应用程序，您很快就会发现当Flux成为其中的一部分时，更容易理解应用程序的工作原理。您可以在[https://facebook.github.io/flux/](https://facebook.github.io/flux/)了解更多关于Flux的信息。
- en: I think it’s a good time to check that everything is in perfect working order.
    Let’s build and run Snapterest!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在是检查一切是否正常运行的好时机。让我们构建并运行Snapterest！
- en: 'Navigate to `~/snapterest` and run the following command in your Terminal window:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`~/snapterest`并在您的终端窗口中运行以下命令：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Make sure that you’re running the Snapkite Engine application that we have installed
    and configured in [Chapter 2](ch02.html "Chapter 2. Installing Powerful Tools
    for Your Project"), *Installing Powerful Tools for Your Project*. Now open the
    `~/snapterest/build/index.html` file in your web browser. You should see new tweets
    appearing on the left-hand side, one at a time. Click on a tweet to add it to
    a collection that appears on the right-hand side.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您正在运行我们在[第2章](ch02.html "第2章。为您的项目安装强大的工具")中安装和配置的Snapkite Engine应用程序，*为您的项目安装强大的工具*。现在在您的网络浏览器中打开`~/snapterest/build/index.html`文件。您应该会看到新的推文逐个出现在左侧。单击推文将其添加到右侧出现的收藏中。
- en: Does it work? Check JavaScript Console for any errors. No errors?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否有效？检查JavaScript控制台是否有任何错误。没有错误？
- en: Congratulations on integrating the Flux architecture into our React application!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺您将Flux架构整合到我们的React应用程序中！
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we completed refactoring our application to use the Flux architecture.
    You learned what it takes to combine React with Flux and what advantages Flux
    has to offer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们完成了重构我们的应用程序，以使用Flux架构。您了解了将React与Flux结合使用的要求，以及Flux所提供的优势。
- en: In the next chapter, we’ll simplify our application’s architecture further with
    the Redux library.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Redux库进一步简化我们应用程序的架构。
