- en: Chapter 9. Testing Your React Application with Jest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用Jest测试您的React应用程序
- en: By now, you have created a number of React components. Some of them are quite
    straightforward, but some are sophisticated enough. Having built both, you might
    have gained a certain confidence, which makes you believe that no matter how complex
    the user interface is, you can build it with React, without any major pitfalls.
    This is a good confidence to have. After all, this is why we're investing time
    in learning React. However, there is a trap that many confident React developers
    fall into—the act of not writing unit tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了许多React组件。其中一些非常简单，但有些足够复杂。建立了这两种组件后，你可能已经获得了一定的信心，让你相信无论用户界面有多复杂，你都可以用React构建它，而不会遇到任何重大问题。这是一个很好的信心。毕竟，这就是我们投入时间学习React的原因。然而，许多有信心的React开发人员陷入的陷阱是不写单元测试。
- en: What is a **unit test**? As the name suggests, it's a test for a single unit
    of your application. A single unit in your application is often a function, which
    suggests that writing unit tests means writing tests for your functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**单元测试**？顾名思义，它是对应用程序的单个单元进行测试。应用程序中的单个单元通常是一个函数，这意味着编写单元测试意味着为您的函数编写测试。
- en: Why write unit tests?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要写单元测试？
- en: You might be wondering why you should write unit tests. Let me tell you a story
    from my personal experience. I released a website that I built recently. A few
    days later, my colleague who was using the website sent me an email with two files
    that the website kept rejecting. I closely examined the files, and the requirement
    of having the IDs matched was met in both of them. However, the files were still
    rejected and the error message said that the IDs didn't match. Can you guess what
    the problem was?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么要写单元测试。让我给你讲一个我个人经历的故事。我最近发布了一个我建立的网站。几天后，使用该网站的同事给我发了一封电子邮件，附带了两个网站一直拒绝的文件。我仔细检查了这些文件，确保了它们的ID匹配的要求都得到满足。然而，文件仍然被拒绝，并且错误消息显示ID不匹配。你能猜到问题是什么吗？
- en: I wrote a function that checked whether the IDs from the two files matched.
    The function checked both the value and the type of the IDs, so if the values
    were the same and the types were different, it would return no match; it turned
    out that this was exactly the case with the files from my colleague.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我写了一个函数来检查这两个文件的ID是否匹配。该函数检查了ID的值和类型，因此如果值相同但类型不同，它将返回不匹配；结果证明这正是我同事的文件的情况。
- en: The important question is, how can I prevent this from happening? The answer
    is a number of unit tests for my function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的问题是，我如何防止这种情况发生？答案是为我的函数编写一些单元测试。
- en: Creating test suites, specs, and expectations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试套件、规范和期望
- en: How does one write a test for JavaScript functions? You need a testing framework,
    and luckily, Facebook has built its own unit test framework for JavaScript, called
    **Jest**. It is inspired by **Jasmine**—another well-known JavaScript test framework.
    Those who are familiar with Jasmine will find Jest's approach to testing very
    similar. However, I'll make no assumptions about your prior experience with testing
    frameworks and discuss the basics first.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如何为JavaScript函数编写测试？你需要一个测试框架，幸运的是，Facebook为JavaScript构建了自己的单元测试框架，称为**Jest**。它受**Jasmine**的启发，这是另一个著名的JavaScript测试框架。熟悉Jasmine的人会发现Jest的测试方法非常相似。然而，我不会假设你之前有测试框架的经验，首先讨论基础知识。
- en: The fundamental idea of unit testing is that you test only one piece of functionality
    in your application that usually is implemented by one function. You test it in
    isolation, which means that all the other parts of your application that the function
    depends on are not used by your tests. Instead, they are imitated by your tests.
    To imitate a JavaScript object is to create a fake one that simulates the behavior
    of the real object. In unit testing, the fake object is called **mock** and the
    process of creating it is called **mocking**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的基本思想是，你只测试应用程序中的一个功能片段，通常由一个函数实现。你在隔离环境中测试它，这意味着函数依赖的应用程序的其他部分不会被测试使用。相反，它们会被测试模拟。模拟JavaScript对象是创建一个模拟真实对象行为的虚假对象。在单元测试中，虚假对象称为**mock**，创建它的过程称为**mocking**。
- en: Jest automatically mocks the dependencies when you're running your tests. It
    automatically finds tests to be executed in your repository. Let's take a look
    at the following example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，Jest会自动模拟依赖项。它会自动找到要在存储库中执行的测试。让我们看下面的例子。
- en: 'First, create the `~/snapterest/source/utils/` directory. Then, create a new
    `TweetUtils.js` file in it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`~/snapterest/source/utils/`目录中创建一个新的`TweetUtils.js`文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `TweetUtils.js` file is a module with the `getListOfTweetIds()` utility
    function for our application to use. Given an object with tweets, `getListOfTweetIds()`
    returns an array of tweet IDs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`TweetUtils.js`文件是一个模块，包含我们的应用程序使用的`getListOfTweetIds()`实用函数。给定一个带有推文的对象，`getListOfTweetIds()`返回一个推文ID数组。'
- en: Now let's write our first unit test with Jest. We'll test our `getListOfTweetIds()`
    function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用Jest编写我们的第一个单元测试。我们将测试我们的`getListOfTweetIds()`函数。
- en: 'Create a `TweetUtils.test.js` file inside `~/snapterest/source/utils/`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`~/snapterest/source/utils/`目录中创建一个`TweetUtils.test.js`文件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we require the `TweetUtils` module:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要引入`TweetUtils`模块：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we call a global `describe()` Jest function. It's important to understand
    the concept behind it. In our `TweetUtils.test.js` file, we're not just creating
    a single test, instead we're creating a suite of tests. A suite is a collection
    of tests that collectively tests a bigger unit of functionality. For example,
    a suite can have multiple tests, which tests all the individual parts of a larger
    module. In our example, we have a `TweetUtils` module with potentially a number
    of utility functions. In this situation, we would create a suite for the `TweetUtils`
    module, and then create tests for each individual utility function, such as `getListOfTweetIds()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用全局的`describe()` Jest函数。理解其背后的概念很重要。在我们的`TweetUtils.test.js`文件中，我们不只是创建一个单一的测试，而是创建了一组测试。一组测试是对一个更大的功能单元进行集体测试的集合。例如，一组测试可以包含多个测试，测试更大模块的所有单独部分。在我们的示例中，我们有一个`TweetUtils`模块，可能有多个实用函数。在这种情况下，我们会为`TweetUtils`模块创建一组测试，然后为每个单独的实用函数创建测试，比如`getListOfTweetIds()`。
- en: 'The `describe()` function defines a suite and takes these two parameters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()`函数定义了一个测试套件，并接受这两个参数：'
- en: '**Suite name**: This is the title that describes what is being tested by this
    test suite'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套件名称**：这是描述此测试套件正在测试的标题'
- en: '**Suite implementation**: This is the function that implements this suite'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套件实现**：这是实现此套件的函数'
- en: 'In our example, the suite is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，套件如下：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How do you create an individual test? In Jest, you create individual tests
    by calling another global Jest function—`test()`. Just like `describe()`, the
    `test()` function takes two parameters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建单独的测试？在Jest中，通过调用另一个全局的Jest函数`test()`来创建单独的测试。就像`describe()`一样，`test()`函数接受两个参数：
- en: '**Test name**: This is the title that describes what is being tested by this
    test, for example: `''getListOfTweetIds returns an array of tweet ids''`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试名称**：这是描述此测试正在测试的标题，例如：`''getListOfTweetIds返回推文ID数组''`'
- en: '**Test implementation**: This is the function that implements this test'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试实现**：这是实现此测试的函数'
- en: 'In our example, the test is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，测试如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s take a closer look at the implementation of our test:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下我们测试的实现：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We test whether the `getListOfTweetIds()` method of our `TweetUtils` module
    returns an array of tweet IDs, when given an object with tweet objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试`TweetUtils`模块的`getListOfTweetIds()`方法是否在给定带有推文对象的对象时返回推文ID数组。
- en: 'First, we will create a mock object that simulates the real tweets object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个模拟真实推文对象的模拟对象：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only requirement for this mock object is to have tweet IDs as object keys.
    The values are not important, so we choose empty objects. The key names are not
    important as well, so we choose to name them `tweet1`, `tweet2`, and `tweet3`.
    This mock object doesn't fully simulate the real tweet object—its sole purpose
    is to simulate the fact that its keys are tweet IDs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟对象的唯一要求是将推文ID作为对象键。值并不重要，所以我们选择空对象。键名也不重要，所以我们选择将它们命名为`tweet1`、`tweet2`和`tweet3`。这个模拟对象并不能完全模拟真实的推文对象——它的唯一目的是模拟其键是推文ID的事实。
- en: 'The next step is to create an expected list of tweet IDs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建预期的推文ID列表：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We know what tweet IDs to expect because we've mocked the tweets object with
    the same IDs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道要期望什么推文ID，因为我们用相同的ID模拟了推文对象。
- en: 'The next step is to extract the actual tweet IDs from our mocked tweets object.
    For this, we use the `getListOfTweetIds()` method that takes the tweets object
    and returns an array of tweet IDs:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从我们模拟的推文对象中提取实际的推文ID。为此，我们使用`getListOfTweetIds()`方法，该方法接受推文对象并返回推文ID数组：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We pass the `tweetsMock` object to that method and store the results in the
    `actualListOfTweetIds` constant. The reason it's named `actualListOfTweetIds`
    is that this list of tweet IDs is produced by the actual `getListOfTweetIds()`
    function that we're testing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`tweetsMock`对象传递给该方法，并将结果存储在`actualListOfTweetIds`常量中。它被命名为`actualListOfTweetIds`的原因是这个推文ID列表是由我们正在测试的`getListOfTweetIds()`函数产生的。
- en: 'The final step will introduce us to a new important concept:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将向我们介绍一个新的重要概念：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's think about the process of testing. We need to take an actual value produced
    by the method that we're testing, that is, `getListOfTweetIds()`, and match it
    to the expected value that we know in advance. The result of that match will determine
    whether our test has passed or failed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下测试的过程。我们需要取得一个由我们正在测试的方法产生的实际值，即`getListOfTweetIds()`，并将其与我们预先知道的预期值进行匹配。匹配的结果将决定我们的测试是否通过或失败。
- en: 'The reason why we can guess what `getListOfTweetIds()` will return in advance
    is because we''ve prepared the input for it; this is our mock object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能预先猜测`getListOfTweetIds()`将会返回什么是因为我们已经为它准备了输入；这就是我们的模拟对象：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, we can expect the following output by calling `TweetUtils.getListOfTweetIds(tweetsMock)`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过调用`TweetUtils.getListOfTweetIds(tweetsMock)`来期望以下输出：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because something can go wrong inside `getListOfTweetIds()`, we cannot guarantee
    this result; we can only *expect* it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在`getListOfTweetIds()`内部可能出现问题，我们无法保证这个结果；我们只能*期望*它。
- en: 'This is why we need to create an expectation. In Jest, an **expectation** is
    built using the `expect()` function, which takes an actual value; for example,
    the `actualListOfTweetIds` object: `expect(actualListOfTweetIds)`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要创建一个期望。在Jest中，**期望**是使用`expect()`函数构建的，该函数接受一个实际值；例如，`actualListOfTweetIds`对象：`expect(actualListOfTweetIds)`。
- en: 'Then, we chain it with a **matcher** function that compares the actual value
    with the expected value and tells Jest whether the expectation was met or not:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将它与一个**匹配器**函数链接起来，该函数比较实际值与期望值，并告诉Jest期望是否得到满足：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our example, we use the `toEqual()` matcher function to compare the two arrays.
    You can find a list of all the built-in matcher functions in Jest at [https://facebook.github.io/jest/docs/expect.html](https://facebook.github.io/jest/docs/expect.html)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`toEqual()`匹配器函数来比较两个数组。您可以在Jest的[https://facebook.github.io/jest/docs/expect.html](https://facebook.github.io/jest/docs/expect.html)中找到所有内置匹配器函数的列表
- en: This is how you write a test. A test contains one or more expectations. Each
    expectation tests the state of your code. A test can be either a **passing test**
    or a **failing test**. A test is a passing test only when all the expectations
    are met; otherwise, it's a failing test.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你编写测试的方式。一个测试包含一个或多个期望。每个期望测试您代码的状态。一个测试可以是**通过的测试**或**失败的测试**。只有当所有期望都得到满足时，测试才是通过的测试；否则，它就是失败的测试。
- en: Well done, you've written your first test suite with a single test that has
    one expectation! How can you run it?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，您已经编写了您的第一个测试套件，其中包含一个期望的单个测试！您如何运行它？
- en: Installing and running Jest
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行Jest
- en: 'First, let''s install the **Jest command-line interface** (**Jest CLI**) module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装**Jest命令行界面**（**Jest CLI**）模块：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command installs and adds the Jest module as a development dependency to
    our `~/snapterest/package.json` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会将Jest模块安装并添加为`~/snapterest/package.json`文件的开发依赖项。
- en: 'In [Chapter 2](ch02.html "Chapter 2. Installing Powerful Tools for Your Project"),
    *Installing Powerful Tools for Your Project*, we installed and discussed Babel.
    We use Babel to transpile our newer JavaScript syntax into the older JavaScript
    syntax, as well as compile JSX syntax into plain JavaScript syntax. In our tests,
    we''ll be testing React components written in JSX syntax, but Jest doesn''t understand
    JSX syntax out of the box. We need to tell Jest to automatically compile our tests
    with Babel. To do this, we need to install the `babel-jest` module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。为您的项目安装强大的工具")中，*为您的项目安装强大的工具*，我们安装并讨论了Babel。我们使用Babel将我们的新JavaScript语法转译为旧的JavaScript语法，并将JSX语法编译为普通的JavaScript语法。在我们的测试中，我们将测试用JSX语法编写的React组件，但是Jest默认不理解JSX语法。我们需要告诉Jest自动使用Babel编译我们的测试。为此，我们需要安装`babel-jest`模块：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to configure Babel. To do this, create the following `.babelrc`
    file in the `~/snapterest/` directory:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要配置Babel。为此，在`~/snapterest/`目录中创建以下`.babelrc`文件：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, let''s edit the `package.json` file. We''ll replace the existing `"scripts"`
    object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编辑`package.json`文件。我们将替换现有的`"scripts"`对象：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Replace the preceding object with the following one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下对象替换前面的对象：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we''re ready to run our test suite. Navigate to the `~/snapterest/` directory,
    and run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备运行我们的测试套件。转到`~/snapterest/`目录，并运行以下命令：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see the following message in your Terminal window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端窗口中看到以下消息：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This output message tells you the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出消息告诉您以下内容：
- en: '`PASS`: Your test has passed'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASS`：您的测试已通过'
- en: '`source/utils/TweetUtils.test.js`: Jest ran tests from this file'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source/utils/TweetUtils.test.js`：Jest从这个文件运行测试'
- en: That's all it takes to write and test a tiny unit test. Now, let's create another
    one!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编写和测试一个微小单元测试所需的全部。现在，让我们创建另一个！
- en: Creating multiple tests and expectations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多个测试和期望
- en: 'This time, we''ll create and test the collection utility module. Create the
    `CollectionUtils.js` file in the `~/snapterest/source/utils/` directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将创建并测试集合实用程序模块。在`~/snapterest/source/utils/`目录中创建`CollectionUtils.js`文件：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `CollectionUtils` module has two functions: `getNumberOfTweetsInCollection()`
    and `isEmptyCollection()`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionUtils`模块有两个函数：`getNumberOfTweetsInCollection()`和`isEmptyCollection()`。'
- en: 'First, let''s discuss `getNumberOfTweetsInCollection()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论`getNumberOfTweetsInCollection()`：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this function calls the `getListOfTweetIds()` method from the
    `TweetUtils` module and passes the `collection` object as a parameter. The result
    returned by `getListOfTweetIds()` is stored in the `listOfCollectionTweetIds`
    constant, and since it's an array, `getNumberOfTweetsInCollection()` returns a
    `length` property of that array.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个函数调用`TweetUtils`模块的`getListOfTweetIds()`方法，并将`collection`对象作为参数传递。`getListOfTweetIds()`返回的结果存储在`listOfCollectionTweetIds`常量中，由于它是一个数组，`getNumberOfTweetsInCollection()`返回该数组的`length`属性。
- en: 'Now, let''s take a look at the `isEmptyCollection()` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`isEmptyCollection()`方法：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method reuses the `getNumberOfTweetsInCollection()` method that we just
    discussed. It checks whether the result returned by a call to `getNumberOfTweetsInCollection()`
    is equal to zero. Then, it returns the result of that check, which is either `true`
    or `false`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法重用了我们刚刚讨论的`getNumberOfTweetsInCollection()`方法。它检查调用`getNumberOfTweetsInCollection()`返回的结果是否等于零。然后，它返回该检查的结果，即`true`或`false`。
- en: 'Notice that we export both methods from this module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从这个模块导出了这两个方法：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We just created our `CollectionUtils` module. Our next task is to test it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了我们的`CollectionUtils`模块。我们的下一个任务是测试它。
- en: 'Inside the `~/snapterest/source/utils/` directory, create the following `CollectionUtils.test.js`
    file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`~/snapterest/source/utils/`目录中，创建以下`CollectionUtils.test.js`文件：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First we define our test suite:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义我们的测试套件：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We give our test suite the name of the module that we're testing—`CollectionUtils`.
    Now let's take a look at the implementation of this test suite. Instead of immediately
    defining test specs like we did in our previous test suite, we're creating the
    `collectionTweetsMock` object. So, are we allowed to do this? Absolutely. The
    test suite implementation function is just another JavaScript function, where
    we can do some work before we define our test specs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给我们的测试套件命名为我们正在测试的模块的名称—`CollectionUtils`。现在让我们来看一下这个测试套件的实现。与我们之前的测试套件不同，我们不是立即定义测试规范，而是创建了`collectionTweetsMock`对象。那么，我们允许这样做吗？当然可以。测试套件实现函数只是另一个JavaScript函数，在定义测试规范之前我们可以做一些工作。
- en: This test suite will implement more than one test. All of our tests will use
    the `collectionTweetsMock` object, so it makes sense to define it outside the
    specs' scope and reuse it inside the specs. As you might have already guessed,
    the `collectionTweetsMock` object imitates a collection of tweets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件将实现多个测试。我们所有的测试都将使用`collectionTweetsMock`对象，所以在规范范围之外定义它并在规范内重用它是有意义的。你可能已经猜到，`collectionTweetsMock`对象模拟了一组推文。
- en: Now let's implement the individual test specs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现单独的测试规范。
- en: 'Our first spec tests whether the `CollectionUtils` module returns a number
    of tweets in the collection:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个规范测试了`CollectionUtils`模块是否返回了集合中的推文数量：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We first get the actual number of tweets in our mock collection:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取我们模拟集合中的实际推文数量：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For this, we call the `getNumberOfTweetsInCollection()` method and pass the
    `collectionTweetsMock` object to it. Then, we define the number of expected tweets
    in our mock collection:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们调用`getNumberOfTweetsInCollection()`方法，并将`collectionTweetsMock`对象传递给它。然后，我们定义我们模拟集合中期望的推文数量：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we call the `expect()` global function to create an expectation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`expect()`全局函数来创建一个期望：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We use the `toBe()` matcher function to match the actual value and the expected
    one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`toBe()`匹配器函数来匹配实际值和期望值。
- en: 'If you now run the `npm test` command, you will see that both the test suites
    pass:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行`npm test`命令，你会看到两个测试套件都通过了：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember that for a test suite to pass, it must have only the passing specs.
    For a spec to pass, it must have all its expectations to be met. This is the case
    so far.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，要使测试套件通过，它必须只有通过的规范。要使规范通过，它必须满足所有的期望。到目前为止情况就是这样。
- en: How about running a little evil experiment?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样进行一个小小的邪恶实验？
- en: 'Open your `~/snapterest/source/utils/CollectionUtils.js` file, and inside the
    `getNumberOfTweetsInCollection()` function, go to the following line of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`~/snapterest/source/utils/CollectionUtils.js`文件，并在`getNumberOfTweetsInCollection()`函数内，找到以下代码行：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now change it to this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其更改为这样：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What this tiny update will do is return an incorrect number of tweets in any
    given collection. Now run `npm test` once more. You should see that all your specs
    in `CollectionUtils.test.js` have failed. Here is the one we''re interested in:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微小的更新将返回任何给定集合中错误的推文数量。现在再次运行`npm test`。你应该看到`CollectionUtils.test.js`中的所有规范都失败了。这是我们感兴趣的一个：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We haven't seen a failing test before, so let's take a closer look at what it's
    trying to tell us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前没有看到过失败的测试，所以让我们仔细看看它试图告诉我们什么。
- en: 'First, it gives us the bad news that the `CollectionUtils.test.js` test has
    failed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它告诉我们`CollectionUtils.test.js`测试失败了：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, it tells us in a human-friendly manner which test has failed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以一种人性化的方式告诉我们哪个测试失败了：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, what went wrong—the unexpected test result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，出了什么问题-意外的测试结果：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, Jest prints a stack trace that should give us enough technical details
    to quickly identify which part of our code has produced the unexpected result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Jest打印出一个堆栈跟踪，这应该给我们足够的技术细节，快速确定我们的代码的哪一部分产生了意外的结果：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alright! Enough of failing our tests on purpose. Let''s revert our `~/snapterest/source/utils/CollectionUtils.js`
    file to this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！不要再故意让我们的测试失败了。让我们把`~/snapterest/source/utils/CollectionUtils.js`文件恢复到这个状态：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A test suite in Jest can have many specs that test different methods from a
    single module. Our `CollectionUtils` module has two methods. Now let's discuss
    the second one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jest中，一个测试套件可以有许多规范，测试来自单个模块的不同方法。我们的`CollectionUtils`模块有两种方法。现在让我们讨论第二种方法。
- en: 'Our next spec in `CollectionUtils.test.js` checks whether the collection is
    not empty:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`CollectionUtils.test.js`中的下一个规范检查集合是否不为空：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we call the `isEmptyCollection()` method and pass the `collectionTweetsMock`
    object to it. We store the result in the `actualIsEmptyCollectionValue` constant.
    Notice how we're reusing the same `collectionTweetsMock` object, as in our previous
    spec.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`isEmptyCollection()`方法，并将`collectionTweetsMock`对象传递给它。我们将结果存储在`actualIsEmptyCollectionValue`常量中。注意我们如何重复使用相同的`collectionTweetsMock`对象，就像在我们之前的规范中一样。
- en: 'Next, we create not one but three expectations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了不止一个期望：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You might have already guessed what we're expecting from our `actualIsEmptyCollectionValue`
    constant.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到我们对`actualIsEmptyCollectionValue`常量的期望。
- en: 'First of all, we expect our collection to be defined:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们期望我们的集合被定义：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This means that the `isEmptyCollection()` function must return something other
    than `undefined`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`isEmptyCollection()`函数必须返回除`undefined`之外的其他东西。
- en: 'Next, we expect its value to be `false`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们期望它的值是`false`：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Earlier, we used the `toEqual()` matcher function to compare the arrays. The
    `toEqual()` method does a deep comparison, which is perfect for comparing arrays,
    but it is an overkill for primitive values such as `false`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们使用`toEqual()`匹配器函数来比较数组。`toEqual()`方法进行深度比较，非常适合比较数组，但对于`false`等原始值来说有些过度。
- en: 'Finally, we expect `actualIsEmptyCollectionValue` not to be `true`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们期望`actualIsEmptyCollectionValue`不是`true`：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The next comparison is inversed by `.not`. It matches the expectation with the
    inverse of `toBe(true)` with `false`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个比较是通过`.not`进行反转的。它将期望与`toBe(true)`的相反值`false`进行匹配。
- en: Notice that `toBe(false)` and `not.toBe(true)` produce the same result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`toBe(false)`和`not.toBe(true)`产生相同的结果。
- en: Only when all the three expectations are met, does this spec pass.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有三个期望都得到满足时，这个规范才会通过。
- en: So far, we've tested the utility modules, but how do you test the React components
    with Jest?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经测试了实用模块，但是如何使用Jest测试React组件呢？
- en: We'll find out next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来会发现。
- en: Testing React components
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试React组件
- en: Let's step back from writing code for a minute and talk about what it means
    to test the user interface. What exactly are we testing? We're testing the fact
    that our user interface renders as expected. In other words, if we tell React
    to render a button, we expect it to render a button—not more, not less.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时停下来不写代码，谈谈测试用户界面意味着什么。我们究竟在测试什么？我们测试的是我们的用户界面是否按预期呈现。换句话说，如果我们告诉React去呈现一个按钮，我们期望它呈现一个按钮，不多，也不少。
- en: Now how can we check that this is the case? One way of doing this is to write
    a React component, bundle our application, run it in a web browser, and see with
    our own eyes that it displays what we want it to display. This is manual testing
    and we do it at least once. But it is time consuming and unreliable in the long
    term.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们如何检查这一点呢？做到这一点的一种方法是编写一个React组件，捆绑我们的应用程序，在Web浏览器中运行它，并亲眼看到它显示我们想要显示的内容。这是手动测试，我们至少要做一次。但是这在长期内是耗时且不可靠的。
- en: How can we automate this process? Jest can do most of the work for us, but Jest
    doesn't have it's own eyes, so it will need to borrow our eyes at least once for
    each component. If Jest "can't see" the result of rendering a React component,
    then how can it even test a React component?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何自动化这个过程呢？Jest可以为我们做大部分工作，但是Jest没有自己的眼睛，所以它至少需要借用我们的眼睛来测试每个组件一次。如果Jest“看不到”呈现React组件的结果，那么它如何甚至测试React组件呢？
- en: In [Chapter 3](ch03.html "Chapter 3. Creating Your First React Element"), *Creating
    Your First React Element*, we discussed React elements. They are plain JavaScript
    objects that describe what we want to see on the screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。创建您的第一个React元素")中，*创建您的第一个React元素*，我们讨论了React元素。它们是描述我们想在屏幕上看到的内容的简单的JavaScript对象。
- en: 'For example, consider this HTML markup:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个HTML标记：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This can be represented by the following plain JavaScript object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用以下简单的JavaScript对象表示：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Having plain and simple JavaScript objects that represent the output that our
    components produce when we render them allows us to describe certain expectations
    about our components and their behavior. Let's see this in action.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们呈现组件时，拥有代表我们组件产生的输出的简单的JavaScript对象，使我们能够描述关于我们组件及其行为的某些期望。让我们看看它的实际效果。
- en: 'The first React component that we''ll test will be our `Header` component.
    Create the `Header.test.js` file in the `~/snapterest/source/components/` directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试的第一个React组件将是我们的`Header`组件。在`~/snapterest/source/components/`目录中创建`Header.test.js`文件：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By now, you can recognize the structure of our test files. First, we define
    our test suite, and we give it the name `Header`. Our test suite has two test
    specs named `renders default header text` and `renders provided header text`.
    As their names suggest, they test that our `Header` component can render both
    the default and provided text. Let's take a closer look at this test suite.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以认识到我们测试文件的结构。首先，我们定义了测试套件，并给它命名为`Header`。我们的测试套件有两个测试规范，分别命名为`renders
    default header text`和`renders provided header text`。正如它们的名称所示，它们测试我们的`Header`组件能够呈现默认文本和提供的文本。让我们更仔细地看看这个测试套件。
- en: 'First, we import the React module:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入React模块：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we import the `react-test-renderer` module:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入`react-test-renderer`模块：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A React renderer renders React components to pure JavaScript objects. It doesn''t
    require the DOM, so we can use it to render React components outside of a web
    browser. It works great with Jest. Let''s install it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: React渲染器将React组件渲染为纯JavaScript对象。它不需要DOM，因此我们可以使用它在web浏览器之外渲染React组件。它与Jest配合使用效果很好。让我们安装它：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, in order to test our `Header` component, we need to import it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了测试我们的`Header`组件，我们需要导入它：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We're also importing `DEFAULT_HEADER_TEXT` from our `Header` module. We do this
    because we don't want to hardcode the actual string value that is the default
    header text. It would add extra work for maintaining this value. Instead, since
    out `Header` component knows what this value is, we're going to import and reuse
    it in our test.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从我们的`Header`模块中导入`DEFAULT_HEADER_TEXT`。我们这样做是因为我们不想硬编码实际的字符串值，即默认的标题文本。这会增加维护这个值的额外工作。相反，由于我们的`Header`组件知道这个值是什么，我们将在测试中导入并重用它。
- en: 'Let''s take a look at our first test named `renders default header text`. Our
    first task in this test is to render the `Header` component to the plain JavaScript
    object. The `react-test-renderer` module has the `create` method that does exactly
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的第一个名为`renders default header text`的测试。我们在这个测试中的第一个任务是将`Header`组件渲染为普通的JavaScript对象。`react-test-renderer`模块有一个`create`方法可以做到这一点：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We pass the `<Header/>` element to the `create()` function as an argument and
    we get back a JavaScript object that represents an instance of our `Header` component.
    It''s not a simple representation of our component yet, so our next step is to
    convert that object into a simple tree representation of our component using the
    `toJSON` method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`<Header/>`元素作为参数传递给`create()`函数，然后我们得到一个代表我们的`Header`组件实例的JavaScript对象。它还不是我们组件的简单表示，所以我们的下一步是使用`toJSON`方法将该对象转换为我们组件的简单树形表示：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, `tree` is a JavaScript object as well, but it''s also a simple representation
    of our `Header` component that we can easily read and understand:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`tree`也是一个JavaScript对象，但它也是我们`Header`组件的简单表示，我们可以轻松阅读和理解：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'I recommend that you log both the `component` and `tree` objects and see how
    different they are:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你记录`component`和`tree`对象，并看看它们有多不同：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You'll quickly see that the `component` object is for React's internal use—it's
    hard to read and tell what it represents. On the other hand, the `tree` object
    is very easy to read and it's clear what it represents.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很快发现`component`对象是为了React的内部使用而设计的-很难阅读并且难以判断它代表什么。另一方面，`tree`对象非常容易阅读，并且清楚它代表什么。
- en: 'As you can see, our approach for testing React components so far is to convert
    `<Header/>` to `{ type: ''h2'', props: {}, children: [ ''Default header'' ] }`.
    Now that we have a simple JavaScript object that represents our component, we
    can check that this object has the expected values. If it does, we can conclude
    that our component will render in a web browser as expected. If it doesn''t, then
    we might have introduced a bug.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，我们目前测试React组件的方法是将`<Header/>`转换为`{ type: ''h2'', props: {}, children:
    [ ''Default header'' ] }`。现在我们有了一个简单的JavaScript对象来代表我们的组件，我们可以检查这个对象是否具有预期的值。如果是，我们可以得出结论，我们的组件将如预期般在web浏览器中渲染。如果不是，那么我们可能引入了一个bug。'
- en: 'When we render our `Header` component without any properties, `<Header/>`,
    we expect it to render a default text: `''Default header''`. To check that this
    is indeed the case, we need to access the `children` property from a tree representation
    of our `Header` component:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们渲染我们的`Header`组件没有任何属性时，`<Header/>`，我们期望它渲染出一个默认文本：`'Default header'`。为了检查这是否确实如此，我们需要从我们`Header`组件的树形表示中访问`children`属性：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We expect our `Header` component to only have one child, so the text element
    will be the first child.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望我们的`Header`组件只有一个子元素，所以文本元素将是第一个子元素。
- en: 'Now it''s time to write our expectation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候写我们的期望了：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we expect `firstChild` to have the same value as `DEFAULT_HEADER_TEXT`.
    Behind the scenes, `toBe` matcher uses `===` to do the comparison.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们期望`firstChild`具有与`DEFAULT_HEADER_TEXT`相同的值。在幕后，`toBe`匹配器使用`===`进行比较。
- en: This is it for our first test!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个测试！
- en: 'In our second test named `''renders provided header text''`, we''re testing
    that our `Header` component has the custom test that we provide via the `text`
    property:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们名为“渲染提供的标题文本”的第二个测试中，我们正在测试我们的`Header`组件是否具有我们通过`text`属性提供的自定义测试：
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now you understand the core idea behind testing React components:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您理解了测试React组件的核心思想：
- en: Render your component to the JavaScript object representation.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的组件呈现为JavaScript对象表示。
- en: Find some value on that object and check that this value is what you expect.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该对象上找到一些值，并检查该值是否符合您的期望。
- en: As you can see, this is quite straightforward when your components are simple.
    But what if you need to test components that are composed of other components
    and so on? Imagine how complex the JavaScript object that represents that component
    will be. It will have many properties that are deeply nested. You might end up
    writing and maintaining a lot of code for accessing and comparing deeply nested
    values. This is when writing unit tests becomes too expensive and some developers
    might choose to give up on testing their components altogether.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当您的组件很简单时，这是非常直接的。但是，如果您需要测试由其他组件组成的组件等等，会怎样呢？想象一下代表该组件的JavaScript对象将会有多复杂。它将具有许多深度嵌套的属性。您可能最终会编写和维护大量用于访问和比较深度嵌套值的代码。这就是写单元测试变得太昂贵的时候，一些开发人员可能选择放弃对其组件进行测试的原因。
- en: Luckily there're two solutions available for us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有两种解决方案可供选择。
- en: Here's one of them. Remember, when traversing and mutating DOM directly was
    too much work, so jQuery library was created to simplify that process? Well, for
    React components we have **Enzyme**—a JavaScript testing utility library from
    AirBnB that simplifies the process of traversing and manipulating the output produced
    from rendering React components.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其中之一。记住，当直接遍历和修改DOM太麻烦时，jQuery库被创建出来简化这个过程？嗯，对于React组件，我们有Enzyme——这是来自AirBnB的JavaScript测试实用库，简化了遍历和操作渲染React组件产生的输出的过程。
- en: 'Enzyme is a separate library from Jest. Let''s install it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme是Jest之外的一个独立库。让我们安装它：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To use Enzyme together with Jest, we need to install three modules. Remember
    that Jest runs our tests, whereas Enzyme will help us to write our expectations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Jest一起使用Enzyme，我们需要安装三个模块。记住，Jest运行我们的测试，而Enzyme将帮助我们编写我们的期望。
- en: 'Now let''s rewrite our tests for our `Header` component using Enzyme:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Enzyme重写我们的`Header`组件的测试：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, we import the `shallow` function from the `enzyme` module:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`enzyme`模块中导入`shallow`函数：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, inside of our test, we call the `shallow` function and pass our `Header`
    component as an argument:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的测试中，我们调用`shallow`函数并将我们的`Header`组件作为参数传递：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What we get in return is an object that wraps the result of rendering our `Header`
    component. This object is created by Enzyme's `ShallowWrapper` class and has some
    very useful methods for us to use. We'll call it `wrapper`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个包装渲染我们的`Header`组件结果的对象。这个对象是由Enzyme的`ShallowWrapper`类创建的，并且对我们来说有一些非常有用的方法。我们将其称为`wrapper`。
- en: Now that we have this `wrapper` object available to us, we're ready to write
    our expectations. Notice that unlike `react-test-renderer`, with Enzyme we don't
    need to convert our `wrapper` object into a simplified representation of our component.
    This is because we're not going to traverse our `wrapper` object directly—it's
    not a simple object that is easy for us to read; try to log that object and see
    it for yourself. Instead, we'll use methods provided by Enzyme's `ShallowWrapper`
    API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个`wrapper`对象可供我们使用，我们准备写我们的期望。请注意，与`react-test-renderer`不同，使用Enzyme时我们不需要将`wrapper`对象转换为我们组件的简化表示。这是因为我们不会直接遍历我们的`wrapper`对象——它不是一个简单的对象，很难让我们阅读；尝试记录该对象并亲自看看。相反，我们将使用Enzyme的`ShallowWrapper`
    API提供的方法。
- en: 'Let''s write our first expectation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写我们的第一个期望：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, we're calling the `find` method on our `wrapper` object. This
    is the power of Enzyme. Instead of traversing our React component output object
    directly and finding the nested elements, we can simply call the `find` method
    and tell it what we're looking for. In this example, we're telling Enzyme to find
    all `h2` elements inside of our `wrapper` object, and since it wraps the output
    of our `Header` component, we expect the `wrapper` object to have exactly one
    `h2` element. We use Jest's `toHaveLength` matcher to check this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在`wrapper`对象上调用了`find`方法。这就是Enzyme的强大之处。我们不需要直接遍历我们的React组件输出对象并找到嵌套的元素，我们只需调用`find`方法并告诉它我们要找什么。在这个例子中，我们告诉Enzyme在`wrapper`对象内查找所有的`h2`元素，因为它包裹了我们的`Header`组件的输出，我们期望`wrapper`对象有一个`h2`元素。我们使用Jest的`toHaveLength`匹配器来检查这一点。
- en: 'Here''s our second expectation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第二个期望：
- en: '[PRE63]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can guess, we're checking that our wrapper object contains `DEFAULT_HEADER_TEXT`.
    This check allows us to conclude that our `Header` component renders the default
    text when we don't provide any custom text. We're using Enzyme's `contains` method
    that allows us to conveniently check if our component contains any node. In this
    case, we're checking for a text node.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以猜到，我们正在检查我们的wrapper对象是否包含`DEFAULT_HEADER_TEXT`。这个检查让我们得出结论，当我们没有提供任何自定义文本时，我们的`Header`组件呈现默认文本。我们使用Enzyme的`contains`方法，方便地检查我们的组件是否包含任何节点。在这种情况下，我们正在检查文本节点。
- en: 'Enzyme''s API provides many more methods for us to conveniently inspect our
    component''s output. I recommend that you familiarize yourself with those methods
    by reading the official documentation: [http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme的API提供了更多方法，方便我们检查组件的输出。我建议您通过阅读官方文档熟悉这些方法：[http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)
- en: You might be wondering how to test the behavior of your React component.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何测试您的React组件的行为。
- en: This is what we'll discuss next!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接下来要讨论的内容！
- en: 'Create the `Button.test.js` file in the `~/snapterest/source/components/` directory:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`~/snapterest/source/components/`目录中创建`Button.test.js`文件：
- en: '[PRE64]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `Button.test.js` file will test our `Button` component, and specifically,
    check whether it triggers the click event handler function when you click on it.
    Without further ado, let''s focus on the `''calls click handler function on click''`
    spec implementation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button.test.js`文件将测试我们的`Button`组件，特别是检查当您点击它时是否触发点击事件处理程序函数。话不多说，让我们专注于`''calls
    click handler function on click''`规范的实现：'
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this spec, we''re testing that our `Button` component calls a function that
    we provide via the `handleClick` property. Here''s our testing strategy:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规范中，我们正在测试我们的`Button`组件是否调用我们通过`handleClick`属性提供的函数。这是我们的测试策略：
- en: Generate a mock function.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个模拟函数。
- en: Render the `Button` component with our mock function.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的模拟函数渲染`Button`组件。
- en: Find the `button` element in a wrapper object created by Enzyme as a result
    of rendering our `Button` component.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在由Enzyme创建的包装对象中找到`button`元素，这是渲染我们的`Button`组件的结果。
- en: Simulate a click event on that `button` element.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`button`元素上模拟点击事件。
- en: Check whether our mock function was called exactly once.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们的模拟函数是否确实被调用了一次。
- en: 'Now that we have a plan, let''s implement it. Let''s create a mock function
    first:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个计划，让我们实施它。让我们首先创建一个模拟函数：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `jest.fn()` function call returns the newly generated Jest mock function;
    we name it `handleClickMock`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`jest.fn()`函数调用返回新生成的Jest模拟函数；我们将其命名为`handleClickMock`。'
- en: 'Next, we get the output of our `Button` component by calling Enzyme''s `shallow`
    function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用Enzyme的`shallow`函数来获取我们的`Button`组件的输出：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We pass our `handleClickMock` function as a property to our `Button` component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`handleClickMock`函数作为一个属性传递给我们的`Button`组件。
- en: 'Then, we find the `button` element and we simulate a click event on it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到`button`元素并在其上模拟点击事件：
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'At this point, our button element is expected to call its `onClick` event handler,
    which, in this case is our `handleClickMock` function. This mock function should
    record the fact that it was called one time, or at least this is how we expect
    our `Button` component to behave. Let''s create this expectation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们期望我们的按钮元素调用它的`onClick`事件处理程序，这种情况下是我们的`handleClickMock`函数。这个模拟函数应该记录它被调用了一次，或者至少这是我们期望我们的`Button`组件的行为。让我们创建这个期望：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'How do we check how many times our `handleClickMock` function was called? Our
    `handleClickMock` function has a special mock property that we can inspect to
    find out how many times `handleClickMock` was called:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何检查我们的`handleClickMock`函数被调用了多少次？我们的`handleClickMock`函数有一个特殊的模拟属性，我们可以检查它来找出`handleClickMock`被调用了多少次：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In turn, our `mock` object has a `calls` object that knows everything about
    every call made to our `handleClickMock` function. The `calls` object is an array
    and in our case we expect its `length` property to equal to 1.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，我们的`mock`对象有一个`calls`对象，它知道每次调用我们的`handleClickMock`函数的所有信息。`calls`对象是一个数组，在我们的情况下，我们期望它的`length`属性等于1。
- en: As you can see, with Enzyme it's easier to write expectations. Our tests require
    less work to write them in the first place and maintain them for the long term.
    This is good because now we have more motivation to write more tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用Enzyme更容易编写期望。我们的测试需要更少的工作来编写它们，并且长期维护它们。这很好，因为现在我们有更多的动力来编写更多的测试。
- en: But can we make writing tests with Jest even easier?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们能让使用Jest编写测试变得更容易吗？
- en: Turns out that we can.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 原来我们可以。
- en: Right now we render a React component into an object representation, and then
    inspect that object either with Jest only or with the help of Enzyme. This inspection
    requires us, as developers, to write extra code for our tests to work. How can
    we avoid that?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将一个React组件渲染为一个对象表示，然后使用Jest或Enzyme的帮助来检查该对象。这种检查要求我们作为开发人员编写额外的代码来使我们的测试工作。我们如何避免这种情况？
- en: We can render a React component into a text string that we could easily read
    and understand. Then we can store that text representation in our code base. Later,
    when we run our tests again, we can simply create a new text representation and
    compare it with the one that we're storing. If they're different, then this could
    mean that either we updated our component intentionally and now we need to update
    our text representation as well, or we introduced a bug to our component so that
    now it produces an unexpected text representation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个React组件渲染为一个文本字符串，这样我们可以轻松地阅读和理解。然后我们可以将这个文本表示存储在我们的代码库中。稍后，当我们再次运行我们的测试时，我们可以简单地创建一个新的文本表示并将其与我们存储的进行比较。如果它们不同，那么这可能意味着我们有意更新了我们的组件，现在我们需要更新我们的文本表示，或者我们向我们的组件引入了一个错误，以至于它现在产生了一个意外的文本表示。
- en: 'This idea is called **snapshot testing** in Jest. Let''s rewrite tests for
    our `Header` component using snapshot testing. Replace the existing code in your
    `Header.test.js` file with this new code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法在Jest中被称为**快照测试**。让我们使用快照测试重写我们的`Header`组件的测试。用这段新代码替换你的`Header.test.js`文件中的现有代码：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, we're not using Enzyme in this case, which should make sense
    to us, because we don't want to inspect anything anymore.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在这种情况下没有使用Enzyme，这对我们来说应该是有意义的，因为我们不再想要检查任何东西。
- en: 'On the other hand, we''re using the `react-test-renderer` module again to render
    and convert our components into a simple JavaScript object that we named `tree`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们再次使用`react-test-renderer`模块来渲染和转换我们的组件为一个名为`tree`的简单JavaScript对象：
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The key line of code that puts snapshot testing in action is this line:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将快照测试付诸实践的关键代码行是这一行：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We're simply telling Jest that we expect our tree object to match to an existing
    snapshot. Wait a minute, but we don't have an existing snapshot. Good observation!
    So what happens in this case? Jest won't find an existing snapshot for this test,
    and instead it will create a very first snapshot for this test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是告诉Jest我们期望我们的`tree`对象与现有的快照匹配。等一下，但我们没有现有的快照。很好的观察！那么在这种情况下会发生什么？Jest找不到这个测试的现有快照，而是会为这个测试创建一个第一个快照。
- en: 'Let''s run our test command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试命令：
- en: '[PRE74]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'All tests should pass and you should see this output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都应该通过，你应该看到这个输出：
- en: '[PRE75]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here Jest is telling us that it created two snapshots—one for each test found
    in our `Header.test.js` test suite. Where did Jest store these two snapshots?
    If you check your `~/snapterest/source/components/` directory, you will find a
    new folder there: `__snapshots__`. Inside it, you''ll find the `Header.test.js.snap`
    file. Open this file and look at its contents:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Jest告诉我们它创建了两个快照——一个用于我们`Header.test.js`测试套件中找到的每个测试。Jest把这两个快照存储在哪里？如果你检查`~/snapterest/source/components/`目录，你会发现一个新的文件夹：`__snapshots__`。在里面，你会找到`Header.test.js.snap`文件。打开这个文件并查看它的内容：
- en: '[PRE76]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: What you can see in this file is the text representation of the output that
    our `Header` component produces when we render it with Jest. It's very easy for
    us to read this file and confirm that this is what we expect our `Header` component
    to render. Now our `Header` component has its own snapshots. It's important to
    treat and store these snapshots as part of your source code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你可以看到我们的`Header`组件在使用Jest渲染时产生的输出的文本表示。我们很容易读取这个文件并确认这就是我们期望`Header`组件渲染的内容。现在我们的`Header`组件有了自己的快照。将这些快照视为源代码的一部分进行处理和存储是很重要的。
- en: You should commit them to your Git repository if you have one and you should
    be aware of any changes that you're making to them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有Git仓库，你应该提交它们，并且你应该注意你对它们所做的任何更改。
- en: Now that you've seen three different ways of writing React tests, you need to
    make your own choice of how to test your React components. Now I would recommend
    that you use snapshot testing and Enzyme.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了三种不同的编写React测试的方式，你需要自己选择如何测试你的React组件。现在我建议你使用快照测试和Enzyme。
- en: Great, we've written four test suites. Now it's time to run all our tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经编写了四个测试套件。现在是时候运行我们所有的测试了。
- en: 'Navigate to `~/snapterest/` and run this command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`~/snapterest/`并运行这个命令：
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'All your test suites should `PASS`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你所有的测试套件都应该`通过`。
- en: '[PRE78]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Log messages, such as these, will help you sleep well at night and go on holidays,
    without the need to constantly check your work emails.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的日志消息会帮助你晚上睡得安稳，放假时也不需要不断检查工作邮件。
- en: Well done!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now you know how to create the React components and unit test them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建React组件并对其进行单元测试了。
- en: In this chapter, you learned the essentials of Jest—the unit testing framework
    from Facebook that works well with React. You got introduced to the Enzyme library
    and learned how it simplifies writing unit tests for React components. We discussed
    the test suites, specs, expectations, and matchers. We created mocks and simulated
    click events.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了 Jest 的基本知识——这是 Facebook 推出的一个与 React 配合良好的单元测试框架。您了解了 Enzyme 库，并学会了如何简化编写
    React 组件的单元测试。我们讨论了测试套件、规范、期望和匹配器。我们创建了模拟和模拟点击事件。
- en: In the next chapter, you'll learn the essentials of the Flux architecture and
    how to improve the maintainability of our React application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习 Flux 架构的基本知识，以及如何提高我们的 React 应用程序的可维护性。
