["```jsx\nnpm test\n```", "```jsx\nPASS  src/App.test.js\n ![](Images/a021b99a-9dbe-4033-9351-6670f4a36ba6.png) renders without crashing (3ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.043s, estimated 1s\n```", "```jsx\nWatch Usage\n > Press a to run all tests.\n > Press p to filter by a filename regex pattern.\n > Press t to filter by a test name regex pattern.\n > Press q to quit watch mode.\n > Press Enter to trigger a test run. \n```", "```jsx\nit('renders without crashing', () => { \n  const div = document.createElement('div'); \n  ReactDOM.render(<App />, div); \n}); \n```", "```jsx\nit('renders the App component', () => { \n  const div = document.createElement('div'); \n  ReactDOM.render(<App />, div); \n}); \n```", "```jsx\nPASS  src/App.test.js\n ![](Images/a021b99a-9dbe-4033-9351-6670f4a36ba6.png) renders the App component (4ms)\n```", "```jsx\nexport default ({ times, value }) => \n  new Array(parseInt(times, 10))\n    .fill(value)\n    .join(' ');\n```", "```jsx\nimport React, { Component } from 'react'; \nimport logo from './logo.svg'; \nimport './App.css'; \nimport Repeat from './Repeat'; \n\nclass App extends Component { \n  render() { \n    return ( \n      <div className=\"App\"> \n        <header className=\"App-header\"> \n          <img src={logo} className=\"App-logo\" alt=\"logo\" /> \n          <h1 className=\"App-title\">Welcome to React</h1> \n        </header> \n        <p className=\"App-intro\"> \n          <Repeat times=\"5\" value=\"React!\" /> \n        </p> \n      </div> \n    ); \n  } \n} \n\nexport default App; \n```", "```jsx\nimport React from 'react'; \nimport ReactDOM from 'react-dom'; \nimport Repeat from './Repeat'; \n\nit('renders the Repeat component', () => { \n  const div = document.createElement('div'); \n  ReactDOM.render(<Repeat times=\"5\" value=\"test\" />, div); \n}); \n```", "```jsx\nPASS  src/App.test.js\nPASS  src/Repeat.test.js\n\nTest Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.174s, estimated 1s\nRan all test suites related to changed files.\n```", "```jsx\n PASS  src/App.test.js \n PASS  src/Repeat.test.js \n```", "```jsx\nexport default ({ children }) => children; \n```", "```jsx\nimport Text from './text'; \n\nit('returns the correct text', () => {\n  const children = 'test';\n  expect(Text({ children })).toEqual(children);\n});\n```", "```jsx\nPASS  src/Text.test.js\n ![](Images/a021b99a-9dbe-4033-9351-6670f4a36ba6.png) returns the correct text (1ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\n```", "```jsx\nexport default ({ children }) => 1;\n```", "```jsx\nFAIL  src/Text.test.js\n \u25cf returns the correct text\n\n   expect(received).toEqual(expected)\n\n   Expected value to equal:\n     \"test\"\n   Received:\n     1\n\n   Difference:\n\n    Comparing two different types of values. Expected string but \n     received number.\n```", "```jsx\njest\n```", "```jsx\nFAIL  src/Repeat.test.js\n \u25cf Test suite failed to run\n\n   04/my-react-app/src/Repeat.test.js: Unexpected token (7:18)\n        5 | it('renders the Repeat component', () => {\n        6 |   const div = document.createElement('div');\n      > 7 |   ReactDOM.render(<Repeat times=\"5\" value=\"test\"...\n          |                   ^\n        8 | });\n```", "```jsx\nexport CI=1\n```", "```jsx\nPASS  src/Text.test.js\nPASS  src/App.test.js\nPASS  src/Repeat.test.js\n\nTest Suites: 3 passed, 3 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        1.089s\nRan all test suites.\n```", "```jsx\nunset CI \n```", "```jsx\nit('renders without crashing', () => { \n  ... \n}); \n```", "```jsx\ndescribe('BasicSuite', () => { \n  it('passes the first test', () => { \n    // Assertions... \n  }); \n\n  it('passes the second test', () => { \n    // Assertions... \n  }); \n}); \n```", "```jsx\ndescribe('NestedSuite', () => { \n  describe('state', () => { \n    it('handles the first state', () => { \n\n    }); \n\n    it('handles the second state', () => { \n\n    }); \n  }); \n\n  describe('props', () => { \n    it('handles the first prop', () => { \n\n    });\n it('handles the second prop', () => { \n\n    }); \n  });\n\n describe('render()', () => { \n    it('renders with state', () => { \n\n    }); \n\n    it('renders with props', () => { \n\n    }); \n  }); \n}); \n```", "```jsx\nnpm test -- --verbose\n```", "```jsx\nPASS  src/NestedSuite.test.js\n NestedSuite\n   state\n     ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) handles the first state (1ms)\n     ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) handles the second state\n   props\n     ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) handles the first prop\n     ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) handles the second prop\n   render()\n     ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) renders with state\n     ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) renders with props (1ms)\n\nPASS  src/BasicSuite.test.js\n BasicSuite\n   ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) passes the first test\n   ![](Images/05ee9296-041a-4087-b809-ef2d86a9a6bb.png) passes the second test\n```", "```jsx\ndescribe('basic equality', () => { \n  it('true is true', () => { \n    expect(true).toBe(true); \n    expect(true).not.toBe(false); \n  }); \n\n  it('false is false', () => { \n    expect(false).toBe(false); \n    expect(false).not.toBe(true); \n  }); \n}); \n```", "```jsx\ndescribe('approximate equality', () => { \n  it('1 is truthy', () => { \n    expect(1).toBeTruthy(); \n    expect(1).not.toBeFalsy(); \n  }); \n\n  it('\\'\\' is falsy', () => { \n    expect('').toBeFalsy(); \n    expect('').not.toBeTruthy(); \n  }); \n});\n```", "```jsx\ndescribe('value equality', () => { \n  it('objects are the same', () => { \n    expect({ \n      one: 1, \n      two: 2 \n    }).toEqual({ \n      one: 1, \n      two: 2, \n    });\n\n    expect({ \n      one: 1, \n      two: 2 \n    }).not.toBe({ \n      one: 1, \n      two: 2\n }); \n  }); \n\n  it('arrays are the same', () => { \n    expect([1, 2]).toEqual([1, 2]); \n    expect([1, 2]).not.toBe([1, 2]); \n  }); \n}); \n```", "```jsx\ndescribe('object properties and array values', () => { \n  it('object has property value', () => { \n    expect({ \n      one: 1, \n      two: 2 \n    }).toHaveProperty('two', 2); \n\n    expect({ \n      one: 1, \n      two: 2 \n    }).not.toHaveProperty('two', 3); \n  });\n  it('array contains value', () => { \n    expect([1, 2]).toContain(1); \n    expect([1, 2]).not.toContain(3); \n  }); \n}); \n```", "```jsx\nimport fs from 'fs'; \n\nconst readFile = path => new Promise((resolve, reject) => { \n  fs.readFile(path, (err, data) => { \n    if (err) { \n      reject(err); \n    } else { \n      resolve(data); \n    } \n  }); \n}); \n\nexport default readFile; \n```", "```jsx\nimport fs from 'fs'; \nimport readFile from './readFile'; \n\njest.mock('fs'); \n\ndescribe('readFile', () => { \n  it('calls fs.readFile', (done) => { \n    fs.readFile.mockReset(); \n    fs.readFile.mockImplementation((path, cb) => { \n      cb(false); \n    }); \n\n    readFile('file.txt') \n      .then(() => { \n        expect(fs.readFile).toHaveBeenCalled(); \n        done(); \n      }); \n  }); \n\n  it('resolves a value', (done) => { \n    fs.readFile.mockReset(); \n    fs.readFile.mockImplementation((path, cb) => { \n      cb(false, 'test'); \n    }); \n\n    readFile('file.txt') \n      .then((data) => { \n        expect(data).toBe('test'); \n        done(); \n      }); \n  }); \n\n  it('rejects on error', (done) => { \n    fs.readFile.mockReset(); \n    fs.readFile.mockImplementation((path, cb) => { \n      cb('failed'); \n    }); \n\n    readFile() \n      .catch((err) => { \n        expect(err).toBe('failed'); \n        done(); \n      }); \n  }); \n}); \n```", "```jsx\nimport fs from 'fs'; \n\nconst writeFile = (path, data) => new Promise((resolve, reject) => { \n  fs.writeFile(path, data, (err) => { \n    if (err) { \n      reject(err); \n    } else { \n      resolve(); \n    } \n  }); \n}); \n\nexport default writeFile; \n```", "```jsx\nimport fs from 'fs'; \nimport writeFile from './writeFile'; \n\njest.mock('fs'); \n\ndescribe('writeFile', () => { \n  it('calls fs.writeFile', (done) => { \n    fs.writeFile.mockReset(); \n    fs.writeFile.mockImplementation((path, data, cb) => { \n      cb(false); \n    }); \n\n    writeFile('file.txt') \n      .then(() => { \n        expect(fs.writeFile).toHaveBeenCalled(); \n        done(); \n      }); \n  }); \n\n  it('resolves without a value', (done) => { \n    fs.writeFile.mockReset(); \n    fs.writeFile.mockImplementation((path, data, cb) => { \n      cb(false, 'test'); \n    }); \n\n    writeFile('file.txt', test) \n      .then(() => { \n        done(); \n      }); \n  }); \n\n  it('rejects on error', (done) => { \n    fs.writeFile.mockReset(); \n    fs.writeFile.mockImplementation((path, data, cb) => { \n      cb('failed'); \n    });\n writeFile() \n      .catch((err) => { \n        expect(err).toBe('failed'); \n        done(); \n      }); \n  }); \n}); \n```", "```jsx\nnpm test -- --coverage \n```", "```jsx\n----------|--------|----------|---------|---------|----------------|\nFile      |% Stmts | % Branch | % Funcs | % Lines |Uncovered Lines |\n----------|--------|----------|---------|---------|----------------|\nAll files |   2.17 |        0 |    6.25 |    4.55 |                |\n App.js   |    100 |      100 |     100 |     100 |                |\n index.js |      0 |        0 |       0 |       0 |  1,2,3,4,5,7,8 |\n----------|--------|----------|---------|---------|----------------|\n```", "```jsx\nimport fs from 'fs'; \nimport readFile from './readFile'; \n\njest.mock('fs'); \n\ndescribe('readFile', () => { \n  it('calls fs.readFile', () => { \n    fs.readFile.mockReset(); \n    fs.readFile.mockImplementation((path, cb) => { \n      cb(false); \n    });\nreturn readFile('file.txt') \n      .then(() => { \n        expect(fs.readFile).toHaveBeenCalled(); \n      }); \n  }); \n\n  it('resolves a value', () => { \n    fs.readFile.mockReset(); \n    fs.readFile.mockImplementation((path, cb) => { \n      cb(false, 'test'); \n    }); \n\n    return expect(readFile('file.txt')) \n      .resolves \n      .toBe('test'); \n  }); \n\n  it('rejects on error', () => { \n    fs.readFile.mockReset(); \n    fs.readFile.mockImplementation((path, cb) => { \n      cb('failed'); \n    }); \n\n    return expect(readFile()) \n      .rejects \n      .toBe('failed'); \n  }); \n}); \n```", "```jsx\nimport React from 'react'; \nimport ReactDOM from 'react-dom'; \nimport App from './App'; \n\nit('renders without crashing', () => { \n  const div = document.createElement('div'); \n  ReactDOM.render(<App />, div); \n}); \n```", "```jsx\nimport React from 'react'; \nimport renderer from 'react-test-renderer'; \nimport App from './App'; \n\nit('renders without crashing', () => { \n  const tree = renderer \n    .create(<App />) \n    .toJSON(); \n\n  expect(tree).toMatchSnapshot(); \n}); \n```", "```jsx\nnpm install react-test-renderer --save-dev\n```", "```jsx\n<p className=\"App-intro\"> \n  To get <em>started</em>, edit <code>src/App.js</code> and save to  \n  reload. \n</p> \n```", "```jsx\nReceived value does not match stored snapshot 1\\. \n\n- Snapshot \n+ Received \n\n @@ -16,11 +16,15 @@ \n    </h1> \n    </header> \n    <p \n       className=\"App-intro\" \n    > \n-    To get started, edit  \n+    To get  \n+    <em> \n+      started \n+    </em> \n+    , edit  \n```", "```jsx\nnpm test -- --updateSnapshot\n```", "```jsx\nPASS  src/App.test.js\n ![](Images/a3323890-90b8-4d05-a479-d8046e057b2d.png) renders without crashing (12ms)\n\nSnapshot Summary\n > 1 snapshot updated in 1 test suite.\n\n Test Suites: 1 passed, 1 total\n Tests:       1 passed, 1 total\n Snapshots:   1 updated, 1 total\n Time:        0.631s, estimated 1s \n```"]