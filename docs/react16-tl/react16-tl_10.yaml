- en: Building and Deploying Static React Sites with Gatsby
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gatsby 构建和部署静态 React 站点
- en: Gatsby is a static website generation tool for React developers. In essence,
    this tool lets you build React components and captures their rendered output to
    use as the static site content. However, Gatsby takes static site generation to
    the next level. In particular, it provides mechanisms for sourcing your website
    data and transforming it into GraphQL that's more easily consumed by React components.
    Gatsby can handle anything from a single page brochure site to a site that spans
    hundreds of pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby 是 React 开发人员的静态网站生成工具。本质上，这个工具让你构建 React 组件并捕获它们的渲染输出，以用作静态站点内容。然而，Gatsby
    将静态站点生成提升到了一个新的水平。特别是，它提供了将网站数据作为 GraphQL 源并将其转换为更容易被 React 组件消耗的机制。Gatsby 可以处理从单页宣传册站点到跨越数百页的站点的任何内容。
- en: 'Here''s what you''ll learn in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到以下内容：
- en: Why you would want to build a static site using React components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要使用 React 组件构建静态站点？
- en: Building simple Gatsby sites using starters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用入门者构建简单的 Gatsby 站点
- en: Using data from your local filesystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自本地文件系统的数据
- en: Using remote data from Hacker News
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自 Hacker News 的远程数据
- en: Why static React sites?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要静态 React 站点？
- en: Before you get started with building static websites using Gatsby, let's set
    the context with a brief discussion on why you would want to do this. There are
    three key factors at play here —we'll go over each of them now.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Gatsby 构建静态网站之前，让我们通过简要讨论为什么要这样做来设定背景。这里有三个关键因素——我们现在将逐个讨论每一个。
- en: Types of React apps
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 应用程序的类型
- en: React has connotations with apps that are very interactive and with lively data
    that changes a lot. This might be true of some apps, perhaps even most apps, but
    there are still cases where the user is looking at static data—information that
    doesn't change or changes very infrequently.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React 与非常互动和生动变化的数据相关联。这可能对一些应用程序是真实的，甚至可能对大多数应用程序是真实的，但仍然存在用户查看静态数据的情况——即不会改变或很少改变的信息。
- en: Consider a blog. The typical flow is for an author to publish some content and
    then that content is served to anyone who visits the site, who can then view the
    content. The common case is that once the content is published, it stays the same,
    or, it stays static. The uncommon case is that the author makes updates to their
    post, but even then, this is an infrequent action. Now, think about your typical
    blog publishing platform. Every time a reader visits a page on your blog, database
    queries are executed, content has to be assembled, and so on. Ask yourself, is
    there really any point in issuing all of these queries if the results are going
    to be the same every time?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个博客。典型的流程是作者发布一些内容，然后该内容被提供给访问网站的任何人，然后他们可以查看内容。通常情况是，一旦内容发布，它就保持不变，或者保持静态。不寻常的情况是作者更新他们的帖子，但即使是这样，这也是一个不经常的行为。现在，想想你典型的博客发布平台。每当读者访问博客上的页面时，都会执行数据库查询，必须组装内容等。问问自己，如果结果每次都一样，那么发出所有这些查询真的有意义吗？
- en: 'Let''s look at another example. You have an enterprise-style app—a large app
    with lots of data and lots of features. One part of the app is focused on user
    interactivity—adding/changing data and interacting with near real-time data. Another
    part of the app generates reporting—reports based on database queries and charts
    based on historical snapshots of data. The latter part of this enterprise application
    doesn''t appear to interact with data that changes frequently, or at all. Perhaps,
    the app could benefit by being split into two apps: one that handles user interactions
    with lively data, and another one that generates static content that doesn''t
    change frequently, or at all.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。您有一个企业级应用程序，一个大型应用程序，有大量数据和大量功能。应用程序的一部分专注于用户交互——添加/更改数据和与几乎实时数据交互。应用程序的另一部分生成报告——基于数据库查询的报告和基于历史数据快照的图表。这个企业应用程序的后半部分似乎不与频繁更改的数据交互，或者根本不交互。也许，将应用程序拆分为两个应用程序会有所好处：一个处理用户与活跃数据的交互，另一个生成几乎不频繁更改或根本不更改的静态内容。
- en: You might be building an app or part of a larger app where you have mostly static
    data. If so, you could probably use a tool like Gatsby to generate statically
    rendered content. But why do this? What's the benefit?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在构建一个应用程序或较大应用程序的一部分，其中大部分数据都是静态的。如果是这样，您可能可以使用类似Gatsby的工具来生成静态渲染的内容。但是为什么要这样做？有什么好处呢？
- en: Better user experience
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的用户体验
- en: The most compelling reason for building a static version of your React components
    is to provide a better experience for your users. The key metric here is the overall
    performance improvements. Instead of having to touch various API endpoints and
    handle all of the asynchronous aspects of providing data to your React components,
    everything is loaded upfront.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 构建React组件的静态版本最具说服力的原因是为用户提供更好的体验。关键指标在于整体性能的改进。不必触及各种API端点并处理提供数据给React组件的所有异步方面，而是一切都是预先加载的。
- en: Another less obvious user experience improvement with statically built React
    content is that since there are fewer moving parts, there's less chance of the
    site breaking, leading to user frustration. For example, if your React components
    don't have to reach out over the network to fetch data, this failure vector is
    removed entirely from your site.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态构建的React内容还有一个不太明显的用户体验改进是，由于移动部件较少，网站出现故障的可能性较小，从而减少了用户的挫败感。例如，如果您的React组件不必通过网络获取数据，那么这种故障可能性就完全从您的网站中消除了。
- en: Efficient resource usage
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的资源使用
- en: 'Components that are statically compiled by Gatsby know how to make efficient
    use of the GraphQL resources that they consume. One of the great things about
    GraphQL is that it''s easy for tools to parse and generate efficient code at compile
    time. If you want a more in-depth introduction to GraphQL before continuing with
    Gatsby, a good one can be found here: [http://graphql.org/learn/](http://graphql.org/learn/).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由Gatsby静态编译的组件知道如何有效地使用它们消耗的GraphQL资源。GraphQL的一个很棒的地方是，工具在编译时可以轻松解析和生成高效的代码。如果您在继续使用Gatsby之前想要更深入地了解GraphQL，可以在这里找到一个很好的介绍：[http://graphql.org/learn/](http://graphql.org/learn/)。
- en: Another place that static Gatsby React apps help reduce resource consumption
    is in the backend. These apps aren't constantly hitting API endpoints that return
    the same response every single time. This is time that the same API and database
    could be spent servicing requests that actually need dynamic data or are generating
    new data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 静态Gatsby React应用程序帮助减少资源消耗的另一个地方是后端。这些应用程序不会不断地命中返回相同响应的API端点。这段时间可以用来为实际需要动态数据或正在生成新数据的请求提供服务。
- en: Building your first Gatsby site
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个Gatsby网站
- en: 'The first step to using Gatsby is to install the command-line tool globally:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gatsby的第一步是全局安装命令行工具：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you can run the command-line tool to generate your Gatsby project, not
    unlike how `create-react-app` works. The `gatsby` command takes two arguments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行命令行工具来生成您的Gatsby项目，就像`create-react-app`的工作方式一样。`gatsby`命令接受两个参数：
- en: The name of the new project
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新项目的名称
- en: The URL of the Gatsby starter repository
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gatsby starter存储库的URL
- en: 'The project name is basically the name of the folder that''s created to hold
    all of your project files. A Gatsby starter is kind of like a template that makes
    it easier for you to get rolling, especially if you''re learning. If you don''t
    pass a starter, the default starter is used:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目名称基本上是创建以保存所有项目文件的文件夹的名称。Gatsby starter有点像模板，使您更容易上手，特别是如果您正在学习。如果您不传递一个starter，将使用默认的starter：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running the above command would be the same as running:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令将与运行以下命令相同：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In both cases, the starter repository is cloned into the `your-first-gatsby-site`
    directory and then dependencies are installed for you. If all goes well, you should
    see the console output that looks similar to this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，starter存储库都会克隆到`your-first-gatsby-site`目录中，然后为您安装依赖项。如果一切顺利，您应该看到类似于这样的控制台输出：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now you can change into the `your-first-gatsby-site` directory and start the
    development server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以切换到`your-first-gatsby-site`目录并启动开发服务器：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This starts the Gatsby development server within your project. Once again,
    this is similar to how `create-react-app` works—there''s zero configuration to
    deal with and Webpack is setup to just work. After starting the development server,
    you should see output on the console that looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的项目中启动Gatsby开发服务器。再次强调，这与`create-react-app`的工作方式类似——没有任何配置要处理，Webpack已经设置好了。启动开发服务器后，您应该在控制台上看到类似于这样的输出：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can now view `gatsby-starter-default` in the browser by navigating to `http://localhost:8000/`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过导航到`http://localhost:8000/`在浏览器中查看`gatsby-starter-default`。
- en: View GraphiQL, an in-browser IDE, to explore your site's data and schema
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GraphiQL，一个在浏览器中探索站点数据和模式的IDE
- en: '`http://localhost:8000/___graphql`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/___graphql`。'
- en: 'Note that the development build is not optimized. To create a production build,
    use `gatsby build`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，开发构建未经优化。要创建生产构建，请使用`gatsby build`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you visit `http://localhost:8000/` in your web browser, you should see the
    default content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Web浏览器中访问`http://localhost:8000/`，您应该看到默认内容：
- en: '![](Images/a34620ae-1efb-49f9-9605-c9f83645e039.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a34620ae-1efb-49f9-9605-c9f83645e039.png)'
- en: 'The default starter creates multiple pages so that you can see how to link
    your pages together. If you click on the Go to page 2 link, you''ll be taken to
    the next page of the site, which looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的starter创建了多个页面，这样您就可以看到如何将页面链接在一起。如果您点击“转到第2页”链接，您将被带到站点的下一页，看起来像这样：
- en: '![](Images/9871976b-c9f3-4fb0-b4ee-1f74e97ce782.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9871976b-c9f3-4fb0-b4ee-1f74e97ce782.png)'
- en: 'Here''s what the structure of your default Gatsby starter project looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的默认Gatsby starter项目的结构：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For basic site design and editing, you''ll mostly be concerned with files and
    directories under `src`. Let''s take a look at what you have to work with here,
    starting with the `Header` component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本的站点设计和编辑，您主要关注`src`目录下的文件和目录。让我们看看您要处理的内容，从`Header`组件开始：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This component defines the purple header section. The title is static for now,
    it links to the home page, and defines some inline styles. Next, let''s look at
    the `layouts/index.js` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件定义了紫色的页眉部分。标题目前是静态的，它链接到主页，并定义了一些内联样式。接下来，让我们看一下`layouts/index.js`文件：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This module exports a `TemplateWrapper` component. The job of this component
    is to define the layout for the site. Like other container components that you
    might have implemented, this one is rendered on every page of the site. It's similar
    to what you would do with `react-router`, except with Gatsby, the routing is handled
    for you. For example, the route that handles the link that points to `page-2`
    is created automatically by Gatsby. Likewise, Gatsby automatically handles this
    layout module for you by making sure that it's rendered by every page on the site.
    All you have to do is make sure that it looks the way you want it to and that
    the `children()` function is rendered. For now, you can just leave it as is.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块导出了一个`TemplateWrapper`组件。这个组件的作用是定义网站的布局。就像你可能已经实现的其他容器组件一样，这个组件在网站的每个页面上都会被渲染。这类似于你在`react-router`中所做的事情，只不过在Gatsby中，路由已经为你处理好了。例如，处理指向`page-2`的链接的路由是由Gatsby自动创建的。同样地，Gatsby通过确保它在网站的每个页面上都被渲染来自动处理这个布局模块。你所需要做的就是确保它看起来符合你的要求，并且`children()`函数被渲染。现在，你可以将它保持原样。
- en: You'll notice, too, that the layout module also imports a stylesheet that contains
    styles pertinent to the layout of the site.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，布局模块还导入了一个包含与网站布局相关的样式的样式表。
- en: 'Let''s look at the page components now, starting with `index.js`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看一下页面组件，从`index.js`开始：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like plain HTML sites have an `index.html` file, it''s important that
    static Gatsby sites have an `index.js` page that exports the content to render
    on the home page. The `IndexPage` component that''s defined here renders some
    basic HTML, including a link to `page-2`. Let''s look at `page-2.js` next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通的HTML网站有一个`index.html`文件一样，静态的Gatsby网站也有一个`index.js`页面，它将内容导出到主页上进行渲染。在这里定义的`IndexPage`组件渲染了一些基本的HTML，包括指向`page-2`的链接。接下来让我们来看一下`page-2.js`：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This page looks very similar to the home page. The link that's rendered here
    takes the user back to the home page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面看起来与主页非常相似。在这里渲染的链接将用户带回到主页。
- en: This was just a basic introduction to get you rolling with Gatsby. You didn't
    use any data sources to generate content; you'll do just that in the following
    section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的介绍，让你开始使用Gatsby。你没有使用任何数据源来生成内容；你将在接下来的部分中做到这一点。
- en: Adding local filesystem data
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加本地文件系统数据
- en: In the previous section, you saw how to get a basic Gatsby website up and running.
    This website wasn't very interesting because there was no data to drive it. For
    example, the data that drives a blog is the blog entry content stored in a database—the
    blog framework that renders the post lists and posts themselves use this data
    to render markup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你看到了如何启动并运行一个基本的Gatsby网站。这个网站并不是很有趣，因为没有数据来驱动它。例如，驱动博客的数据是存储在数据库中的博客条目内容，博客框架使用这些数据来渲染文章列表和文章本身的标记。
- en: You can do the same thing with Gatsby but in a more sophisticated way. First,
    the markup (or in this case, React components) is statically built and bundled
    once. These builds are then served to users without having to query a database
    or API. Second, the plugin architecture used by Gatsby means that you're not restricted
    to only one source of data and that different sources are often combined. Lastly,
    GraphQL is the querying abstraction that sits on top of all of these things and
    delivers data to your React components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用Gatsby做同样的事情，但以一种更复杂的方式。首先，标记（或在这种情况下，React组件）是静态构建和捆绑一次的。然后，这些构建被提供给用户，而无需查询数据库或API。其次，Gatsby使用的插件架构意味着你不仅限于一个数据源，不同的数据源经常被结合在一起。最后，GraphQL是一个查询抽象层，位于所有这些东西的顶部，并将数据传递给你的React组件。
- en: 'To get started, you need a data source to drive the content of your website.
    We''ll keep things simple for now and use a local JSON file as the source. To
    do so, you need to install the `gatsby-source-filesystem` plugin:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要一个数据源来驱动你网站的内容。现在我们将保持简单，使用本地JSON文件作为数据源。为此，你需要安装`gatsby-source-filesystem`插件：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once this package is installed, you can add it to your project by editing your
    `gatsby-config.js` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这个包之后，你可以通过编辑`gatsby-config.js`文件将其添加到你的项目中：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `name` option tells the GraphQL backend how to organize the query result.
    In this case, everything will be under a `data` property. The path option restricts
    which files are readable. The path used in this example is `src/data`—feel free
    to throw a file into that directory so that it's queryable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`选项告诉GraphQL后端如何组织查询结果。在这种情况下，所有内容都将在`data`属性下。路径选项限制了可读取的文件。在这个例子中使用的路径是`src/data`—随意将文件放入该目录，以便进行查询。'
- en: 'At this point, you can go ahead and start up the Gatsby development server.
    The GraphiQL utility is accessible at `http://localhost:8000/___graphql`. When
    developing Gatsby websites, you will utilize this tool often as it allows you
    to create ad hoc GraphQL queries and execute them on the fly. When you first load
    this interface, you''ll see something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以启动Gatsby开发服务器。GraphiQL实用程序可在`http://localhost:8000/___graphql`访问。在开发Gatsby网站时，你会经常使用这个工具，因为它允许你创建临时的GraphQL查询并立即执行它们。当你首次加载这个界面时，你会看到类似这样的东西：
- en: '![](Images/516c3d4c-3c8f-4744-92e8-76ce159e7435.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/516c3d4c-3c8f-4744-92e8-76ce159e7435.png)'
- en: The left panel is where you write your GraphQL queries, clicking on the Play
    button above executes the query, and the panel to the right displays the query
    results. The docs link in the top-right is a useful way to explore the available
    GraphQL types that Gatsby creates for you. Additionally, the query editor pane
    to the right will autocomplete as you type to help make building queries easier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧面板是你编写GraphQL查询的地方，点击上面的播放按钮执行查询，右侧面板显示查询结果。右上角的文档链接是一个探索Gatsby为你创建的可用GraphQL类型的有用方式。此外，右侧的查询编辑器窗格将在你输入时自动完成，以帮助更轻松地构建查询。
- en: 'Let''s execute your first query that lists information about files on the filesystem.
    Remember that you need at least one file in `src/data` in order to have your query
    return any results. Here is how to query the name, extension, and the size of
    files in your data directory:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行你的第一个查询，列出文件系统中关于文件的信息。请记住，你需要至少在`src/data`中有一个文件，才能使你的查询返回任何结果。以下是如何查询数据目录中文件的名称、扩展名和大小：
- en: '![](Images/0262adc8-b93d-4f2b-a674-c6e5727dcb0d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0262adc8-b93d-4f2b-a674-c6e5727dcb0d.png)'
- en: As you can see, specific node fields are specified in the query. The result
    in the right panel shows that you get the exact fields that you ask for. Part
    of GraphQLs appeal is that you can create arbitrarily nested and complex queries
    that span multiple backend data sources. However, delving into the specifics of
    GraphQL go way beyond the scope of this book. The Gatsby home page ([https://www.gatsbyjs.org/](https://www.gatsbyjs.org/))
    has some great resources on GraphQL, including links to other GraphQL tutorials
    and documentation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，查询中指定了特定的节点字段。右侧面板中的结果显示你得到了你要求的确切字段。GraphQL的吸引力之一在于你可以创建任意嵌套和复杂的查询，涵盖多个后端数据源。然而，深入研究GraphQL的细节远远超出了本书的范围。Gatsby首页（[https://www.gatsbyjs.org/](https://www.gatsbyjs.org/)）上有一些关于GraphQL的很好的资源，包括其他GraphQL教程和文档的链接。
- en: The takeaway here is that the `gatsby-source-filesystem` data source plugin
    did all of the heavy GraphQL lifting for you. It generates the entire schema for
    you, which means that once you have the plugin installed, you can start the development
    server and experiment with autocomplete and documentation right away.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，`gatsby-source-filesystem`数据源插件为您完成了所有繁重的GraphQL工作。它为您生成了整个模式，这意味着一旦您安装了插件，您就可以启动开发服务器并立即开始使用自动完成和文档。
- en: 'Moving forward with the example, you probably don''t have any need to render
    local file data in your UI. So let''s create a `articles.json` file that has some
    JSON content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用这个例子，您可能不需要在UI中呈现本地文件数据。所以让我们创建一个带有一些JSON内容的`articles.json`文件：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This JSON structure is an array of article objects with `topic` and `title`
    properties. This is the data that you want to query with GraphQL. To do so, you
    need to install another Gatsby plugin:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON结构是一组带有`topic`和`title`属性的文章对象。这是您想要用GraphQL查询的数据。为了做到这一点，您需要安装另一个Gatsby插件：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `gatsby-transformer-json` plugin is from another category of Gatsby plugins—transformers.
    Source plugins are responsible from feeding data into Gatsby, while transformers
    are responsible for making the data queryable via GraphQL. Just like any plugin
    you want to use, you need to add it to your project config:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`gatsby-transformer-json`插件来自Gatsby插件的另一类别——转换器。源插件负责向Gatsby提供数据，而转换器负责使数据可通过GraphQL查询。就像您想要使用的任何插件一样，您需要将它添加到您的项目配置中：'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that you have a file with JSON content in your data directory and the `gatsby-transformer-json`
    plugin installed and enabled, you can go back to GraphiQL and query for JSON content:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您在数据目录中有一个带有JSON内容的文件，并且安装并启用了`gatsby-transformer-json`插件，您可以回到GraphiQL并查询JSON内容：
- en: '![](Images/96aa1a5a-f9cf-44a1-9add-87cbfe07901f.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/96aa1a5a-f9cf-44a1-9add-87cbfe07901f.png)'
- en: The `gatsby-transformer-json` plugin makes the `allArticlesJson` query possible
    because it defines the GraphQL schema for you, based on the JSON data found in
    the data source. Under `node`, you can ask for specific properties, as you would
    with any other GraphQL query. In the results, you get all of the JSON data that
    your query asked for.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`gatsby-transformer-json`插件使`allArticlesJson`查询成为可能，因为它根据数据源中的JSON数据为您定义了GraphQL模式。在`node`下，您可以请求特定属性，就像您对任何其他GraphQL查询一样。在结果中，您会得到您查询的所有JSON数据。'
- en: 'In this example, let''s assume that you want three separate pages for listing
    articles, organized by topic. You need a way to filter the nodes that are returned
    by the query. You can add filters directly into your GraphQL syntax. For example,
    to find only global articles, you do execute the following query:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设您想要为按主题组织的文章列出三个单独的页面。您需要一种方法来过滤查询返回的节点。您可以直接将过滤器添加到您的GraphQL语法中。例如，要仅查找全球文章，您可以执行以下查询：
- en: '![](Images/a8799f8a-f4bf-419d-82d3-bc5cf1987d2b.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a8799f8a-f4bf-419d-82d3-bc5cf1987d2b.png)'
- en: This time a filter argument is passed to the `allArticlesJson` query. Here,
    the query is asking for nodes with a topic value of global. Sure enough, the articles
    with a global topic are returned in the result.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，一个过滤参数被传递给`allArticlesJson`查询。在这里，查询是要求具有全局主题值的节点。果然，具有全局主题的文章在结果中返回。
- en: 'The GraphiQL utility allows you to design a GraphQL query that can then be
    used by your React component. Once you have a query that''s returning the correct
    results, you can simply copy it into your component. This last query returns global
    articles, so you can use it with the component used for the `pages/global.js`
    page:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GraphiQL实用程序允许您设计一个GraphQL查询，然后可以被您的React组件使用。一旦您有一个返回正确结果的查询，您可以简单地将其复制到您的组件中。这个最后的查询返回全球文章，所以您可以将它与用于`pages/global.js`页面的组件一起使用：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are two things to pay attention to in this module. First, look at the
    argument passed to the component and notice how it matches the result data that
    you saw in GraphiQL. This data is then used to render the list of global article
    titles. Next, notice the `query` export string. During build time, Gatsby will
    find this string and execute the appropriate GraphQL query so that your component
    has a static snapshot of the results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中有两件事需要注意。首先，看一下传递给组件的参数，并注意它是如何与您在GraphiQL中看到的结果数据匹配的。然后，注意`query`导出字符串。在构建时，Gatsby将找到此字符串并执行适当的GraphQL查询，以便您的组件具有结果的静态快照。
- en: 'Given that you now know how to filter for global articles, you can now update
    the filter for the `pages/local.js` page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于您现在知道如何筛选全局文章，您现在可以更新`pages/local.js`页面的筛选器：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here''s what the `pages/sports.js` page looks like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`pages/sports.js`页面的样子：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You might have noticed that these three components look very similar. This
    is because they''re all working with the same data. The only unique thing about
    them is their title. To reduce some of this redundancy, you could create a higher-order
    component that takes a `name` argument and returns the same underlying component
    used on each page:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到这三个组件看起来非常相似。这是因为它们都使用相同的数据。它们唯一的不同之处在于它们的标题。为了减少一些冗余，您可以创建一个接受`name`参数并返回在每个页面上使用的相同基础组件的高阶组件：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, you could use it like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像这样使用它：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to view all of these pages, you need an index page that links to each
    of them:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看所有这些页面，您需要一个链接到每个页面的索引页面：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s what the home page looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主页的样子：
- en: '![](Images/4ca67551-6019-4000-9dc4-754b8898244d.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4ca67551-6019-4000-9dc4-754b8898244d.png)'
- en: 'If you were to click on one of the topic links, like Global for example, you''re
    taken to an article list page:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击其中一个主题链接，比如全局，您将进入文章列表页面：
- en: '![](Images/1e75e46a-857c-4c0c-977a-7499101c790b.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1e75e46a-857c-4c0c-977a-7499101c790b.png)'
- en: Fetching remote data
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取远程数据
- en: Gatsby has a rich ecosystem of data source plugins—we don't have time go through
    all of them. It's common for a Gatsby source plugin to reach out to another system
    and fetch data over the network at build time. The `gatsby-source-hacker-news`
    plugin is a great plugin to start with, so that you can see how this fetching
    process works with Gatsby.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby拥有丰富的数据源插件生态系统 - 我们没有时间去了解它们所有。Gatsby源插件通常会在构建时从另一个系统获取数据并通过网络获取数据。`gatsby-source-hacker-news`插件是一个很好的插件，可以让您了解Gatsby如何处理这个获取过程。
- en: 'Instead of building your own Hacker News website using Gatsby, we''ll use the
    demo created by [https://github.com/ajayns](https://github.com/ajayns). To get
    started, you can clone into his repo as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用Gatsby构建自己的Hacker News网站，我们将使用[https://github.com/ajayns](https://github.com/ajayns)创建的演示。要开始，您可以克隆他的存储库，如下所示：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then you can install dependencies, including the `gatsby-source-hacker-news`
    plugin:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以安装依赖项，包括`gatsby-source-hacker-news`插件：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You don''t need to edit the project configuration to enable anything, because
    this is already a Gatsby project. Simply start the development server as you''ve
    done throughout this chapter:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要编辑项目配置来启用任何功能，因为这已经是一个Gatsby项目。只需像在本章中一样启动开发服务器：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compared to other websites you''ve worked on this chapter, this time around
    the build takes longer to complete. This is due to the fact that that Gatsby has
    to fetch data over the network. There are also more resources to fetch. If you
    look at the console output from the development server, you should see the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中您所工作的其他网站相比，这次构建需要更长的时间才能完成。这是因为Gatsby必须通过网络获取数据。还有更多资源需要获取。如果您查看开发服务器的控制台输出，您应该会看到以下内容：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This indicates that the build will take longer due to the work that needs to
    happen in order to load the Hacker News data. Once this process completes, you
    can load the site in your browser. You should see something similar to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明由于需要加载Hacker News数据而导致构建时间较长。一旦此过程完成，您可以在浏览器中加载站点。您应该看到类似以下内容：
- en: '![](Images/46022adb-b2be-4880-b79b-b9570374076e.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/46022adb-b2be-4880-b79b-b9570374076e.png)'
- en: 'Let''s take a look at the GraphQL query that loaded the data used to render
    this content. In the `index.js` page, you''ll find the following query:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下加载用于呈现此内容的数据的GraphQL查询。在`index.js`页面中，您会找到以下查询：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of individual node fields being specified, there''s `...Story`. This
    is called a **fragment** and it''s defined in the `StoryItem` component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不是指定单个节点字段，而是`...Story`。这被称为**片段**，它在`StoryItem`组件中定义：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `StoryItem` component defines this GraphQL fragment because it uses this
    data. Now, let''s shift over to GraphiQL and put this query together and execute
    it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`StoryItem`组件定义了这个GraphQL片段，因为它使用了这些数据。现在，让我们转到GraphiQL，组合并执行这个查询：'
- en: '![](Images/f78af049-2082-4b7d-8bbd-87acf0b5fb1e.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f78af049-2082-4b7d-8bbd-87acf0b5fb1e.png)'
- en: 'This is how the home page of the site loads data fetched from the Hack News
    API. Here''s what the home page component looks like:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是站点首页如何加载从Hack News API获取的数据。以下是首页组件的外观：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The edges of the returned data are mapped to `StoryItem` components, passing
    in the data node. Here''s what the `StoryItem` component looks like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据的边缘被映射到`StoryItem`组件，传入数据节点。以下是`StoryItem`组件的外观：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here you can see how this component uses the data defined by the GraphQL fragment
    that was passed to the larger query.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到这个组件如何使用由传递给更大查询的GraphQL片段定义的数据。
- en: 'Now let''s click on the comments link of a story, which will take you to the
    details page of a story. The new URL should look something like `http://localhost:8000/item/16691203`
    and the page should look something like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们点击一个故事的评论链接，这将带您到故事的详细页面。新的URL应该看起来像`http://localhost:8000/item/16691203`，页面应该看起来像这样：
- en: '![](Images/7848af2c-c83d-4e35-9e58-91967c4017e1.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7848af2c-c83d-4e35-9e58-91967c4017e1.png)'
- en: 'You''re probably wondering where this page comes from, given that it has a
    URL parameter (the ID of the story). When using Gatsby to build static pages that
    have a dynamic URL component to them, you have to write some code whose job is
    to tell Gatsby how to create pages based on GraphQL query results. This code goes
    into the `gatsby-node.js` module. Here''s how the pages in this Hacker News website
    are created:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这个页面是从哪里来的，因为它有一个URL参数（故事的ID）。当使用Gatsby构建具有动态URL组件的静态页面时，您必须编写一些代码，其工作是告诉Gatsby如何根据GraphQL查询结果创建页面。这段代码放在`gatsby-node.js`模块中。这是Hacker
    News网站中页面创建的方式：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This module exports a `createPages()` function that Gatsby will use to create
    the static Hacker News article pages at build time. It starts by using the `grapghql()`
    function to execute a query to find all of the article nodes that you need to
    create pages for:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块导出了一个`createPages()`函数，Gatsby将在构建时使用它来创建静态的Hacker News文章页面。它首先使用`grapghql()`函数执行查询，以找到您需要为其创建页面的所有文章节点：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, the `createPage()` function is called for each node:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对每个节点调用`createPage()`函数：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The properties that are passed to `createPage()` are:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`createPage()`的属性是：
- en: '`path`: This is the URL that when accessed, will render the page.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是访问时将呈现页面的URL。'
- en: '`component`: This is the filesystem path to the React component that renders
    the page content.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：这是呈现页面内容的React组件的文件系统路径。'
- en: '`context`: This is data that''s passed to the React component. In this case,
    it''s important that the component knows the article ID.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：这是传递给React组件的数据。在这种情况下，组件知道文章ID非常重要。'
- en: This is the general approach that you would take with Gatsby any time you have
    lots of pages to generate based on dynamic data, but the same React component
    can be used to render the content. In other words, you would probably rather write
    this code and a React component rather than separate components for every article.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您在使用Gatsby时可能会采取的一般方法，每当您有大量基于动态数据生成页面时，但是相同的React组件可以用于呈现内容。换句话说，您可能更愿意在React组件中编写此代码，而不是为每篇文章单独编写组件。
- en: 'Let''s take a look at the component that''s used to render the article details
    page:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下用于呈现文章详细信息页面的组件：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once again, the component relies on Gatsby executing the GraphQL query found
    in the `pageQuery` constant. The context is passed to `createPage()` in `gatsby-node.js`.
    This is how you're able to feed the `$id` argument into the query so that you
    can query for the specific story data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，该组件依赖于Gatsby执行`pageQuery`常量中的GraphQL查询。上下文被传递给`gatsby-node.js`中的`createPage()`。这就是您能够将`$id`参数传递到查询中，以便您可以查询特定的故事数据的方式。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about Gatsby, a tool for generating static websites
    based on React components. We started the chapter off with a discussion on why
    you might want to consider building static sites, and why React is a good fit
    for this job. Static sites lead to an overall better user experience because they
    don't utilize the same types of resources as regular React apps would.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Gatsby，这是一个基于React组件生成静态网站的工具。我们在本章开始时讨论了为什么您可能希望考虑构建静态站点，以及为什么React非常适合这项工作。静态站点会带来更好的用户体验，因为它们不像常规的React应用程序那样利用相同类型的资源。
- en: Next, you built your first Gatsby website. You learned the basic layout of files
    that are created by Gatsby starter templates and how to link pages together. Then,
    you learned that Gatsby data is driven by a plugin architecture. Gatsby is able
    to support various data sources via plugins. You got started with local filesystem
    data. Next, you learned about transformer plugins. These types of Gatsby plugins
    enable specific types of data sources to be queried via GraphQL.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您构建了自己的第一个Gatsby网站。您了解了Gatsby起始模板创建的基本文件布局以及如何将页面链接在一起。然后，您了解到Gatsby数据是由插件架构驱动的。Gatsby能够通过插件支持各种数据源。您开始使用本地文件系统数据。接下来，您了解了转换器插件。这些类型的Gatsby插件使特定类型的数据源能够通过GraphQL进行查询。
- en: Lastly, you looked at a Hacker News example built using Gatsby. This exposed
    you to fetching remote API data as the data source and generating pages dynamically
    based on GraphQL query results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您看了一个使用Gatsby构建的Hacker News示例。这使您能够获取远程API数据作为数据源，并根据GraphQL查询结果动态生成页面。
- en: In the next and final chapter, you'll learn about tooling to containerize and
    deploy your React applications alongside the services that they consume.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也是最后一章中，您将了解有关工具的内容，以便将您的React应用程序与其消耗的服务一起进行容器化和部署。
