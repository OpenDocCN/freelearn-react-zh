- en: Debugging Components in the Browser
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中调试组件
- en: If you're developing a React web application, you need browser-based tooling
    to help you see what's happening on the page from the perspective of a React developer.
    Web browsers today have amazing developer tools installed by default. These are
    essential if you're doing any kind of web development because they expose what's
    really going on in terms of DOM, styles, performance, network requests, you name
    it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发React Web应用程序，您需要基于浏览器的工具来帮助您从React开发人员的角度查看页面上发生了什么。当今的Web浏览器默认安装了令人惊叹的开发人员工具。如果您进行任何类型的Web开发，这些工具是必不可少的，因为它们公开了DOM、样式、性能、网络请求等方面的真实情况。
- en: With React, you still need all of this tooling, but you need more than that.
    The core tenet of React is declarative markup within JavaScript components. If
    this abstraction isn't present in the web browser tooling that developers rely
    on for everything else, life is more difficult than it needs to be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React，您仍然需要所有这些工具，但您需要的不仅仅是这些。React的核心原则是在JavaScript组件中使用声明性标记。如果这种抽象在开发人员为其他所有事情依赖的Web浏览器工具中不存在，生活会比必要的更加困难。
- en: 'In this chapter, you''ll learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: Installing the React Developer Tools browser add-on
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装React Developer Tools浏览器插件
- en: Locating and selecting React components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位和选择React组件
- en: Manipulating component props and state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作组件的props和state
- en: Profiling component performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析组件性能
- en: Installing the React Developer Tools add-on
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装React Developer Tools插件
- en: The first step to getting started with React tooling is to install the React
    Developer Tools browser extension. I'll be using Chrome in the examples throughout
    this chapter as this is a popular choice. React Developer Tools is also available
    as an extension for Firefox ([https://addons.mozilla.org/en-US/firefox/addon/react-devtools/](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用React工具的第一步是安装React Developer Tools浏览器扩展。在本章的示例中，我将使用Chrome，因为这是一个流行的选择。React
    Developer Tools也可以作为Firefox的扩展使用（[https://addons.mozilla.org/en-US/firefox/addon/react-devtools/](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)）。
- en: 'To get the extension installed in Chrome, visit [https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions)
    and search for `react developer tools`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '要在Chrome中安装扩展，请访问[https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions)并搜索`react
    developer tools`： '
- en: '![](Images/f09d7cd6-acf2-4485-aca6-fb03a882cdbc.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f09d7cd6-acf2-4485-aca6-fb03a882cdbc.png)'
- en: 'The first result should be the extension that you want. Click on the ADD TO
    CHROME button to install it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果应该是您想要的扩展。点击“添加到Chrome”按钮进行安装：
- en: '![](Images/0f971519-8b9b-45f2-bd83-272180ee40c2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0f971519-8b9b-45f2-bd83-272180ee40c2.png)'
- en: 'Chrome might warn you that it can change data on websites that you visit. Don''t
    worry, the extension is only activated when you visit React apps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome可能会警告您，它可以更改您访问的网站上的数据。别担心，该扩展仅在您访问React应用程序时才会激活：
- en: '![](Images/86b0a040-1848-4226-80bf-bbddd1756d1b.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/86b0a040-1848-4226-80bf-bbddd1756d1b.png)'
- en: 'Once you click on the Add extension button, the extension is marked as installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加扩展”按钮后，扩展将被标记为已安装：
- en: '![](Images/4238f215-8429-4760-834c-d10920df4224.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4238f215-8429-4760-834c-d10920df4224.png)'
- en: You're all set! With the React Developer Tools Chrome extension installed and
    enabled, you're ready to start inspecting React components on the page, just like
    you would with regular DOM elements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经准备好了！安装并启用React Developer Tools Chrome扩展后，您就可以开始检查页面上的React组件，就像您检查常规DOM元素一样。
- en: Working with React elements in React Developer Tools
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React Developer Tools中使用React元素
- en: 'Once you''ve installed React Developer Tools in Chrome, you''ll see a button
    in the toolbar located to the right of the browser address bar. Here''s what mine
    looks like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Chrome中的React开发者工具后，你会在浏览器地址栏右侧看到一个按钮。我的按钮是这样的：
- en: '![](Images/cb811ae0-6b77-4acd-a83a-cf6576de8c47.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cb811ae0-6b77-4acd-a83a-cf6576de8c47.png)'
- en: 'I have several buttons for browser extensions here. You can see the React Developer
    Tools button at the far right—the one with the React logo. When the button is
    greyed-out like this, it means that you''re not currently on a page running a
    React application. Go ahead and try clicking on it while you''re on some random
    page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里有几个浏览器扩展的按钮。你可以看到最右边的是React开发者工具按钮，上面有React的标志。当按钮变灰时，意味着当前页面没有运行React应用。试着在其他页面点击一下这个按钮：
- en: '![](Images/06aecb5f-f488-491a-9e82-e955b70ae8fe.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06aecb5f-f488-491a-9e82-e955b70ae8fe.png)'
- en: 'Now let''s use `create-react-app` to create a new application, the same process
    you''ve been following throughout this book:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`create-react-app`来创建一个新的应用程序，就像你在整本书中一直在做的那样：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now fire up the development server:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动开发服务器：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should take you directly to the browser page with your React application
    loaded up in a new tab. Now the React Developer Tools button should look different:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会直接将你带到浏览器页面，你的React应用程序已经加载到一个新的标签页中。现在React开发者工具按钮应该看起来不一样了：
- en: '![](Images/2ffa9251-6af2-41c0-8aad-0490faaccb6f.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2ffa9251-6af2-41c0-8aad-0490faaccb6f.png)'
- en: 'There you go. Since you''re on a page that''s running a React application,
    the React Developer Tools button comes alive to let you know that it''s available.
    Try clicking on it now:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。因为你在运行React应用的页面上，React开发者工具按钮会变亮，告诉你它已经可用。现在试着点击一下它：
- en: '![](Images/258cf495-5c39-4494-b6e6-51149bdafc05.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/258cf495-5c39-4494-b6e6-51149bdafc05.png)'
- en: Awesome! The React Developer Tools can detect that this is a development build
    of the React library. This could come in handy in case you ever find yourself
    in a situation where you accidentally deploy the development build of React to
    a production environment. Admittedly, this is more difficult to do today with
    tools like `create-react-app` where you have the tooling in place to build production
    versions for free.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！React开发者工具可以检测到这是React库的开发版本。如果你不小心将React的开发版本部署到生产环境中，这可能会派上用场。诚然，如今使用诸如`create-react-app`之类的工具构建生产版本是更加困难的，因为你已经具备了构建生产版本的工具。
- en: 'Okay, so now that you have your React browser tooling in place, what else can
    it do for you other than detect the type of React build that''s being used by
    a given app? Let''s open up the developer tools pane within Chrome and find out:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经安装了React浏览器工具，除了检测应用程序使用的React构建类型，它还能为你做些什么呢？让我们在Chrome中打开开发者工具面板看看：
- en: '![](Images/c1240c93-ff99-4812-ae3f-e92b0f059b2d.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c1240c93-ff99-4812-ae3f-e92b0f059b2d.png)'
- en: 'You can see all of the regular sections that you normally see in the developer
    tools pane: Elements, Console, and so on. But there''s nothing about React? I
    happen to have my developer tools pane docked to the right-hand side of my browser
    window, so you can''t see every section. If you''re seeing the same thing, you
    just have to click on the arrow button next to Performance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到开发者工具面板中通常的部分：元素、控制台等等。但是没有关于React的内容？我把开发者工具面板停靠在了浏览器窗口的右侧，所以你看不到每个部分。如果你看到的也是一样的情况，你只需要点击性能旁边的箭头按钮：
- en: '![](Images/a19e461d-bb35-4dd2-b858-0e2f5c6bf504.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a19e461d-bb35-4dd2-b858-0e2f5c6bf504.png)'
- en: 'Select React from the menu and you''ll be taken to the React section of the
    developer tools panel. Once it loads, you should see the root React component
    displayed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择React，你将进入开发者工具面板的React部分。加载完成后，你应该会看到根React组件显示出来：
- en: '![](Images/4556b196-8ec0-4819-8939-18845b62d6f6.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4556b196-8ec0-4819-8939-18845b62d6f6.png)'
- en: If you've used the DOM inspector tool in any browser, this interface should
    feel familiar. In the main section to the left, you have your React element tree.
    This should closely resemble your JSX source. To the right of this tree, you have
    details of the currently-selected element, in this case it's `App`, and it doesn't
    define any properties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在任何浏览器中使用过DOM检查工具，这个界面应该会让你感到熟悉。在左侧的主要部分，你有你的React元素树。这应该与你的JSX源代码非常相似。在这个树的右侧，你有当前选中元素的详细信息，在这种情况下是`App`，它没有定义任何属性。
- en: 'If you expand `App`, you''ll see its child HTML markup and other React elements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开`App`，你会看到它的子HTML标记和其他React元素：
- en: '![](Images/7e88c0de-1ee6-4e1d-8132-7cb0e1b39a06.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7e88c0de-1ee6-4e1d-8132-7cb0e1b39a06.png)'
- en: This is the default source code after running `create-react-app`, so there isn't
    very much of interest under the `App` element. To further explore React Developer
    Tools, you'll have to introduce some more components and render more React elements
    on the page.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行`create-react-app`后的默认源代码，因此在`App`元素下没有太多有趣的内容。要进一步探索React开发者工具，你需要引入一些更多的组件并在页面上渲染更多的React元素。
- en: Selecting React elements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择React元素
- en: There are actually two ways to select a React element using React Developer
    tools. When you open the React section of the developer tools pane, the root element
    of the React app is automatically selected in the element tree. However, you can
    expand this element to reveal child elements and select them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种方法可以使用React开发者工具选择React元素。当你打开开发者工具窗格的React部分时，React应用的根元素会自动被选中在元素树中。然而，你可以展开此元素以显示子元素并选择它们。
- en: 'Let''s put together a simple app that will help you explore the rendered React
    elements on the page using React Developer Tools. Starting from the top level,
    here''s the `App` component:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们组合一个简单的应用程序，帮助你使用React开发者工具探索页面上渲染的React元素。从顶层开始，这是`App`组件：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By looking at this source, you can take a glimpse at the overall structure
    of the React elements when they''re rendered on the page. Next, let''s look at
    the `MyContainer` component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个源代码，你可以一览在页面上渲染React元素的整体结构。接下来，让我们看看`MyContainer`组件：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This component renders some header text and whatever children are passed to
    it. In this application, you''re passing it a `MyChild` element, so let''s look
    at this component next:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件渲染一些标题文本和传递给它的任何子元素。在这个应用程序中，你传递给它一个`MyChild`元素，所以让我们接下来看看这个组件：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now when you run `npm start`, you should see the following content rendered:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行`npm start`时，你应该会看到以下内容被渲染出来：
- en: '![](Images/36566035-9d1c-41c1-b546-2f4856a88f05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/36566035-9d1c-41c1-b546-2f4856a88f05.png)'
- en: 'Not much to look at, but you know that everything is working as expected. The
    app is small enough that you can see every JSX element within the tree view of
    the React Developer Tools pane:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不起眼，但你知道一切都按预期工作。该应用程序足够小，以至于你可以在React开发者工具窗格的树视图中看到每个JSX元素：
- en: '![](Images/65e61109-c368-404f-be29-d81778caa0d1.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/65e61109-c368-404f-be29-d81778caa0d1.png)'
- en: 'There is a visual distinction between React elements and other element types,
    so that they''re easier to spot in this tree view. For example, the `<MyContainer>`
    element is in one color while the `<section>` element is in a different color.
    Let''s select the `<MyContainer>` element and see what happens:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: React元素和其他元素类型之间有视觉区别，因此它们在树视图中更容易识别。例如，`<MyContainer>`元素是一种颜色，而`<section>`元素是另一种颜色。让我们选择`<MyContainer>`元素，看看会发生什么：
- en: '![](Images/7fb9bbf7-602d-41a1-9766-118e5869d1b0.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7fb9bbf7-602d-41a1-9766-118e5869d1b0.png)'
- en: Up until this point, you've only had the `<App>` element selected, so there
    wasn't anything to show about this element—it has no props or state. The `<MyContainer>`
    element, on the other hand, does have properties to show. In this case, it has
    a `children` property because a `<MyChild>` element was rendered as a child element
    of `<MyContainer>`. Don't worry about the specifics displayed to the right of
    the selected element just yet—we'll go into more detail in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，你只选择了`<App>`元素，所以关于这个元素没有什么可显示的——它没有props或状态。另一方面，`<MyContainer>`元素确实有要显示的属性。在这种情况下，它有一个`children`属性，因为`<MyChild>`元素被呈现为`<MyContainer>`的子元素。暂时不要担心所选元素右侧显示的具体内容——我们将在下一节详细介绍。
- en: 'Next, let''s activate the selection tool. It''s the button above element tree
    that has a target icon in it. When you click on the icon, it changes to blue to
    let you know that it''s active:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们激活选择工具。它是元素树上方的按钮，上面有一个目标图标。当你点击图标时，它会变成蓝色，让你知道它是激活的：
- en: '![](Images/b2795945-0e0b-496f-bd11-8a322ac6cddd.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b2795945-0e0b-496f-bd11-8a322ac6cddd.png)'
- en: 'The idea of this tool is to allow you to click elements on the page and have
    the corresponding React component selected in the developer tools pane. You''ll
    notice that when the tool is active, elements are highlighted as you move over
    them, letting you know what they are:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具的想法是允许你点击页面上的元素，并在开发者工具窗格中选择相应的React组件。当工具激活时，当你移动到元素上时，元素会被突出显示，让你知道它们是什么：
- en: '![](Images/59a7ce26-351f-4e28-b001-3189828643cc.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/59a7ce26-351f-4e28-b001-3189828643cc.png)'
- en: 'Here, the mouse pointer is over the `<p>` element on the page, as the little
    box indicates. If you click on the element, the selection tool will select the
    appropriate element in the developer tools pane and then deactivate itself. Here''s
    what the `<p>` element looks like when selected:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，鼠标指针位于页面上的`<p>`元素上，如小框所示。如果你点击元素，选择工具将在开发者工具窗格中选择适当的元素，然后停用自身。当选择时，`<p>`元素的样子如下：
- en: '![](Images/760c5a8d-f00a-4bcf-bc36-dad8b9efc6c0.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/760c5a8d-f00a-4bcf-bc36-dad8b9efc6c0.png)'
- en: Even though the `<p>` element is selected here, you're seeing props from the
    React element that rendered it—`<MyChild>`. If you're working with page elements
    and you're not exactly sure which React element rendered them, using the selection
    tool in React Developer Tools is a quick way to find out.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这里选择了`<p>`元素，你看到的是由React元素渲染的props——`<MyChild>`。如果你正在处理页面元素，而不确定哪个React元素呈现了它们，使用React开发者工具中的选择工具是快速找出的方法。
- en: Searching for React elements
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索React元素
- en: 'When your application gets bigger, traversing elements on the page or in the
    element tree in the React Developer Tools panel doesn''t work so well. You need
    a way to search for React elements. Luckily, there''s a search box located right
    above the element tree:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序变得更大时，在React开发者工具面板中遍历页面或元素树上的元素效果不佳。你需要一种搜索React元素的方法。幸运的是，元素树上方有一个搜索框：
- en: '![](Images/70d8b0fe-d6ad-433f-a0e8-f0f2b2f869ef.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/70d8b0fe-d6ad-433f-a0e8-f0f2b2f869ef.png)'
- en: As you type in the search box, elements are filtered in the element tree below.
    As you can see, the matching text is also highlighted. The search only matches
    against the name of the element, which means that searching will not help you
    if you need to filter down from 100 of the same type of element. However, even
    in these cases, searching can remove everything else in the app, so that you have
    a smaller list to manually go through.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在搜索框中输入时，元素在下面的元素树中被过滤。正如你所看到的，匹配的文本也被高亮显示。搜索只匹配元素的名称，这意味着如果你需要从100个相同类型的元素中进行过滤，搜索将无法帮助你。然而，即使在这些情况下，搜索也可以删除应用中的其他所有内容，这样你就可以手动浏览一个较小的列表。
- en: 'If you select the Highlight Search checkbox, searching will highlight React
    elements in the main browser window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了高亮搜索复选框，搜索将在主浏览器窗口中高亮显示React元素：
- en: '![](Images/9b9e7899-1658-4852-a904-d1aa21cb1f28.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9b9e7899-1658-4852-a904-d1aa21cb1f28.png)'
- en: 'Both React elements (`<MyContainer>` and `<MyChild>`) on this page are highlighted
    because they both match the search criteria, `my`. Let''s see what happens when
    you search for `child` instead:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面上的两个React元素（`<MyContainer>`和`<MyChild>`）都被高亮显示，因为它们都符合搜索条件`my`。让我们看看当你搜索`child`时会发生什么：
- en: '![](Images/b4810a54-a129-4f5c-811b-b576283bf1d9.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b4810a54-a129-4f5c-811b-b576283bf1d9.png)'
- en: This time, you can see the only React element that matches your search. It's
    highlighted in the main browser window and in the element tree. By searching like
    this, you know exactly what element on the screen you're working with when you
    select it in the element tree.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你可以看到唯一匹配你搜索的React元素。它在主浏览器窗口和元素树中都被高亮显示。通过这样搜索，你可以确切地知道在屏幕上选择的元素是什么，当你在元素树中选择它时。
- en: Inspecting component properties and state
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查组件属性和状态
- en: 'React follows a declarative paradigm so it helps to have tooling in place like
    React Developer Tools that lets you see your JSX markup in the browser. This is
    only the static aspect of your React app—you declare the elements of your UI and
    let data control the rest. Using the same tool, you can watch props and state
    as they flow through your app. To demonstrate this, let''s create a simple list
    that fills itself up once mounted:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: React遵循声明式范式，因此有助于在浏览器中使用React开发者工具等工具，让你看到你的JSX标记。这只是你的React应用的静态方面——你声明UI的元素，让数据控制其余部分。使用相同的工具，你可以观察props和state在你的应用中流动。为了演示这一点，让我们创建一个简单的列表，一旦挂载就填满自己：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s a rough breakdown of everything that this component does:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个组件所做的一切的大致分解：
- en: '`timer` and `state`: These properties are initialized. The main state of this
    component is an `items` array.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timer`和`state`: 这些属性被初始化。这个组件的主要状态是一个`items`数组。'
- en: '`componentDidMount()`: Sets up an interval timer that adds a new value to the
    `items` array every three seconds. Once there are ten items, the interval is cleared.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount()`: 设置一个间隔计时器，每三秒向`items`数组添加一个新值。一旦有十个项目，间隔就会被清除。'
- en: '`componentWillUnmount()`: Makes sure the `timer` property is forcefully cleared.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount()`: 确保`timer`属性被强制清除。'
- en: '`onItemClick()`: Takes an `index` argument and returns an event handler for
    the index. When the handler is called, the `strikethrough` state is toggled.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onItemClick()`: 接受一个`index`参数，并返回一个索引的事件处理程序。当调用处理程序时，`strikethrough`状态将被切换。'
- en: '`render()`: Renders a `<ul>` list of `<MyItem>` elements, passing it relevant
    props.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`: 渲染一个`<ul>`列表，包含`<MyItem>`元素，传递相关的props。'
- en: 'The idea here is to slowly build the list so that you can watch the state changes
    happen in the browser tooling. Then, with the `MyList` elements, you can watch
    the props that are passed to it. Here''s what this component looks like:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是慢慢地建立列表，这样你就可以在浏览器工具中观察状态变化发生。然后，通过`MyList`元素，你可以观察传递给它的props。这个组件看起来是这样的：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's a simple list item. The `textDecoration` style changes based on the value
    of the `strikethrough` prop. When this is true, the text will appear to be striked
    out.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的列表项。`textDecoration`样式根据`strikethrough` prop的值而改变。当这个值为true时，文本将显示为被划掉的样子。
- en: 'Let''s load up this app in your browser and watch the state of `MyList` change
    as the interval handler is called. Once the app loads, make sure you have the
    React Developer Tools pane open and ready to go. Then, expand the `<App>` element
    and select `<MyList>`. You''ll see the state of the element to the right:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中加载这个应用程序，并观察`MyList`的状态随着间隔处理程序的调用而改变。应用程序加载后，请确保您已经打开并准备好使用React Developer
    Tools窗格。然后，展开`<App>`元素并选择`<MyList>`。您将在右侧看到元素的状态：
- en: '![](Images/0f159b9e-8a29-4305-8f89-0f2f1fae98b0.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0f159b9e-8a29-4305-8f89-0f2f1fae98b0.png)'
- en: 'The rendered content to the left matches the state displayed to the right for
    the selected `<MyList>` element. There''s an array of 5 items, and a list of 5
    items is rendered on the page. This example uses an interval timer to update the
    state over time (until it reaches 10 items). If you watch closely, you can see
    that the state value to the right changes in sync with the rendered content, as
    new list items are added. You can also expand individual items in the state to
    see their values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧呈现的内容与所选`<MyList>`元素的右侧显示的状态相匹配。有一个包含5个项目的数组，并且页面上呈现了5个项目的列表。这个例子使用间隔计时器随着时间更新状态（直到达到10个项目）。如果您仔细观察，您会发现右侧的状态值随着新的列表项的添加而与呈现的内容同步变化。您还可以展开状态中的单个项目以查看它们的值：
- en: '![](Images/795ca4e2-6827-4504-b900-bb0066593c4a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/795ca4e2-6827-4504-b900-bb0066593c4a.png)'
- en: 'If you expand the `<MyList>` element, you''ll see all of the `<MyItem>` elements
    rendered as a result of items being added to the `items` array state. From there,
    you can select `<MyItem>` elements to view its props and state. In this example,
    the `<MyItem>` elements only have props—no state:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您展开`<MyList>`元素，您将看到所有`<MyItem>`元素作为`items`数组状态添加到结果中呈现的结果。从那里，您可以选择`<MyItem>`元素来查看其props和状态。在这个例子中，`<MyItem>`元素只有props，没有状态：
- en: '![](Images/09385fb8-63fe-4620-92cb-f6bf5d364426.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09385fb8-63fe-4620-92cb-f6bf5d364426.png)'
- en: 'You can see the props passed to a given element in the tree view to the left.
    This is a little difficult to read though, compared to the values you can see
    to the right that show you the prop values of the selected element. The following
    props are passed to `<MyItem>`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在左侧的树视图中看到传递给给定元素的props。与您可以在右侧看到的值相比，这有点难以阅读，右侧显示了所选元素的prop值。以下props被传递给`<MyItem>`：
- en: '`label`: The text to be rendered'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：要呈现的文本'
- en: '`onClick`: The function that''s called when the item is clicked'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`：当点击项目时调用的函数'
- en: '`strikethrough`: If `true`, the text is rendered with a `strikethrough` style'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strikethrough`：如果为`true`，则文本将以`strikethrough`样式呈现'
- en: 'You can watch the values of properties change as elements are re-rendered.
    In the case of this app, when you click on a list item, the handler function will
    change the state of the items list in the `<MyList>` element. Specifically, the
    index of the item clicked will toggle its `strikethrough` value. This in turn
    will cause the `<MyItem>` element to re-render itself with the new prop value.
    If you keep the element that you''re about to click on selected in the developer
    tools pane, you can keep an eye on props as they change:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察属性值随着元素重新呈现而改变。在这个应用程序的情况下，当您点击列表项时，处理函数将更改`<MyList>`元素中项目列表的状态。具体来说，被点击的项目的索引将切换其`strikethrough`值。这将导致`<MyItem>`元素重新呈现自身以新的prop值。如果您在开发者工具窗格中选择要点击的元素，您可以随时关注prop的变化：
- en: '![](Images/9b6e0451-9f61-4f6d-8d69-9f173c567d36.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9b6e0451-9f61-4f6d-8d69-9f173c567d36.png)'
- en: The text for the first item is rendered with the `strikethrough` style. This
    is because the `strikethrough` property is `true`. If you look closely at the
    prop values to the right of the element tree in the developer tools pane, you
    can see individual props flash yellow when they change—a visual cue that's handy
    for debugging your components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项的文本以`strikethrough`样式呈现。这是因为`strikethrough`属性为`true`。如果你仔细看开发者工具窗格中元素树右侧的属性值，你会看到当它们改变时会闪烁黄色，这是一个方便调试组件的视觉提示。
- en: Manipulating element state values
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作元素状态值
- en: React Developer Tools lets you inspect the current state of elements that you
    select. You can also monitor state changes as they happen, as was demonstrated
    in the preceding section where you had set up an interval timer that changed the
    state of your element over time. The state of an element can also be manipulated
    in limited ways.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: React开发者工具允许你检查所选元素的当前状态。你也可以监视状态的变化，就像前面演示的那样，你可以设置一个间隔定时器来随时间改变元素的状态。元素的状态也可以以有限的方式进行操作。
- en: 'For this next example, let''s modify the `MyList` component to remove the interval
    timer and simply populate the state when it''s constructed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，让我们修改`MyList`组件，移除间隔定时器并在构造时简单地填充状态：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now when you run this app, you''ll see the 10 items rendered immediately. Other
    than this, there are no other changes. You can still click on individual items
    to toggle their `strikethrough` state. Once you have this app up and running,
    make sure the React Developer Tools browser pane is open so that you can select
    the `<MyList>` element:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行这个应用时，你会立即看到10个项目被渲染出来。除此之外，没有其他改变。你仍然可以点击单个项目来切换它们的`strikethrough`状态。一旦你运行了这个应用，请确保React开发者工具浏览器窗格是打开的，这样你就可以选择`<MyList>`元素：
- en: '![](Images/5d3028cd-16ff-4ef1-b0e6-7e6605fc6e38.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5d3028cd-16ff-4ef1-b0e6-7e6605fc6e38.png)'
- en: 'To the right, you can see the state of the selected element. You can actually
    expand one of the objects in the `items` array and change its property values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，你可以看到所选元素的状态。你实际上可以展开`items`数组中的一个对象并改变它的属性值：
- en: '![](Images/2c94a3b4-a5d5-4de6-8050-4e1d551c34fd.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2c94a3b4-a5d5-4de6-8050-4e1d551c34fd.png)'
- en: The `label` and `strikethrough` properties of the first object in the `items`
    array state were changed. This caused the `<MyList>` and the first `<MyItem>`
    elements to be re-rendered. As expected, the changed state is reflected in the
    rendered output to the left. This is handy when you need to troubleshoot components
    that aren't updating their rendered content as they should be. Rather than having
    to orchestrate some test code within the component, you can simply reach directly
    into the rendered element's state and manipulate it within the browser.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`数组状态中第一个对象的`label`和`strikethrough`属性被改变。这导致了`<MyList>`和第一个`<MyItem>`元素被重新渲染。如预期的那样，改变的状态在左侧的渲染输出中反映出来。当你需要排除组件没有按照预期更新渲染内容时，这是很方便的。你不需要在组件内部编写测试代码，只需直接进入浏览器中渲染元素的状态并在其中进行操作。'
- en: The one caveat with editing state like this using React Developer Tools is that
    you can't add or remove items from collections. For example, I can't add a new
    item to the `items` array, nor can I add a new property to one of the objects
    in the array. For this, you need to orchestrate your state in the code, as you
    did in the example prior to this one.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React开发者工具编辑状态的一个注意事项是，你不能向集合中添加或删除项目。例如，我不能向`items`数组中添加新项目，也不能向数组中的对象添加新属性。对此，你需要在代码中编排你的状态，就像在之前的示例中所做的那样。
- en: Profiling component performance
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件性能分析
- en: Profiling the performance of your React components is made easier by React Developer
    Tools. It makes it easier to spot updates that cause elements to re-render when
    no re-render is actually necessary. It also makes it easier to collect the amount
    of CPU time that a given component spends, and where it spends it during its lifespan.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过React开发者工具，更容易地对React组件的性能进行分析。它更容易发现导致元素重新渲染的更新，当实际上不需要重新渲染时。它还更容易收集给定组件在其生命周期内花费的CPU时间以及花费在哪里。
- en: Although React Developer Tools does not include any memory profile tooling,
    we'll look at how you can use the existing memory developer tool to specifically
    profile for React elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管React开发者工具不包括任何内存分析工具，但我们将看看如何使用现有的内存开发者工具来专门为React元素进行分析。
- en: Removing reconciliation work
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除协调工作
- en: Reconciliation is what happens when a React element is rendered. It first computes
    the virtual DOM tree that will render the element's current state and props. Then,
    this tree is compared to the existing tree for the element, assuming it has been
    rendered at least once already. The reason that React does this is because reconciling
    changes like this in JavaScript, before interacting with the DOM, is more performant.
    DOM interactions are relatively expensive compared to simple JavaScript code.
    Additionally, there are a number of common cases that the React reconciler has
    heuristics for.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染React元素时，会发生协调。它首先计算将呈现元素的当前状态和props的虚拟DOM树。然后，将该树与元素的现有树进行比较，假设该树已经至少渲染过一次。React这样做的原因是因为在与DOM交互之前，在JavaScript中协调这样的更改更具性能。与简单的JavaScript代码相比，DOM交互相对昂贵。此外，React协调器还有一些常见情况的启发式方法。
- en: React handles all of this for you—you just need to think about writing declarative
    React components. This doesn't mean that you'll never run into performance issues.
    Just because reconciliation in JavaScript often performs better than directly
    manipulating the DOM doesn't mean that it's cheap. So let's put together an application
    that highlights some potential issues with reconciliation and then let's fix them
    with the help of React Developer Tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: React为您处理所有这些-您只需要考虑编写声明性的React组件。这并不意味着您永远不会遇到性能问题。仅仅因为JavaScript中的协调通常比直接操作DOM表现更好，并不意味着它是廉价的。因此，让我们组合一个应用程序，突出显示协调的一些潜在问题，然后让我们借助React开发者工具来解决这些问题。
- en: 'We''ll create an app that renders groups and members of each group. It''ll
    have controls that change the number of groups and the number of members in each
    group. Lastly, each rendered group will have a button for adding a new group.
    Let''s start with `index.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，用于呈现每个组的组和成员。它将具有更改组数和每个组成员数的控件。最后，每个呈现的组将有一个添加新组的按钮。让我们从`index.js`开始：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is almost like any `index.js` that you would see from `create-react-app`.
    The difference is that there's an `update()` function that's called in an interval
    using `setInterval()`. You wouldn't randomly throw an interval timer that re-renders
    your app every five seconds into your app. I'm adding this here just as a simple
    means to illustrate repetitive re-rendering and what the reconciliation consequences
    of this are. You'll likely find similar behavior in a real app where you update
    components to keep their state fresh—this is an approximation of this behavior.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就像你从`create-react-app`看到的任何`index.js`。不同之处在于有一个使用`setInterval()`调用的`update()`函数。你不会随机地在你的应用程序中抛出一个每五秒重新渲染一次应用程序的间隔计时器。我在这里添加这个只是为了简单地说明重复重新渲染以及这样做的协调后果。在真实的应用程序中，你可能会发现类似的行为，其中你更新组件以保持它们的状态新鲜-这是这种行为的近似。
- en: 'Next, you have the main `App` component. This is where all of the application
    state lives, and most of the functionality for that matter. Let''s take a look
    at the file in its entirety, then I''ll break it down for you:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主要的`App`组件。这是应用程序状态的所在地，也是大部分功能所在地。让我们先看一下整个文件，然后我会为你解释：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s start with the initial state:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从初始状态开始：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The state that this component manages is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件管理的状态如下：
- en: '`groupCount`: How many groups to render'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupCount`: 要渲染的组数'
- en: '`memberCount`: How many members to render in each group'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memberCount`: 每个组中要渲染的成员数量'
- en: '`groups`: An array of group objects'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groups`: 一个组对象数组'
- en: 'Each of these values is stored as state because they can be changed. Next,
    let''s look at the `refreshGroups()` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值都存储为状态，因为它们可以被改变。接下来，让我们看一下`refreshGroups()`函数：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Don''t worry about the implementation specifics too much here. The purpose
    of this function is to populate the state as the number of groups and the number
    of group members change. For example, once called, you''d have state that looks
    something like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不要太担心具体的实现细节。这个函数的目的是在组数和组成员数改变时填充状态。例如，一旦调用，你会有类似以下的状态：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The reason that this is defined in its own function is because you''ll end
    up calling it in several places. For example, in `componentWillMount()` it is
    called so that the component has initial state before it''s rendered for the first
    time. Next, let''s look at the event handler functions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以将这个定义为自己的函数，是因为你将在几个地方调用它。例如，在`componentWillMount()`中调用它，以便组件在首次渲染之前具有初始状态。接下来，让我们看一下事件处理程序函数：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些做以下事情：
- en: '`onGroupCountChange()`: Updates the groups state by calling `refreshGroups()`
    with the new number of groups'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onGroupCountChange()`: 通过使用新的组数调用`refreshGroups()`来更新组状态'
- en: '`onMemberCountChange()`: Updates every member object in the groups state with
    the new number of members.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMemberCountChange()`: 使用新的成员数量更新组状态中的每个成员对象。'
- en: '`onAddMemberClick()`: Updates the groups state by adding a new member object
    at the given index'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAddMemberClick()`: 通过在给定索引处添加新成员对象来更新组状态'
- en: 'Finally, let''s have a look at the JSX that''s rendered by this component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下这个组件渲染的JSX：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This component renders two slider controls: one that controls the number of
    groups and one that controls the number of members in each group. Next, the list
    of groups is rendered. For this, there''s a `Group` component, which looks like
    this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件渲染两个滑块控件：一个控制组数，一个控制每个组中的成员数。接下来，渲染组列表。为此，有一个`Group`组件，看起来像这样：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will render the name of the group, followed by a button that adds a new
    member, and then, by the list of members. When you first load the page, you''ll
    see output that looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染组的名称，然后是一个添加新成员的按钮，然后是成员列表。当你首次加载页面时，你会看到以下输出：
- en: '![](Images/1cc3abc1-8e70-4e4e-a114-ff7253f52975.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1cc3abc1-8e70-4e4e-a114-ff7253f52975.png)'
- en: 'Only a portion of the output is shown here—there are more members in Group
    1 and there are more groups that follow, rendered using the same pattern. Before
    using any of the controls on this page open up React Developer Tools. Then, look
    for the Highlight Updates checkbox:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只显示了部分输出——在第1组中有更多成员，后面还有更多组，使用相同的模式渲染。在使用页面上的任何控件之前，打开React开发者工具。然后，查找“高亮更新”复选框：
- en: '![](Images/69cc8fd5-15bf-4eda-98a2-b083ae7b1cb7.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/69cc8fd5-15bf-4eda-98a2-b083ae7b1cb7.png)'
- en: 'Once you''ve checked this box, your rendered elements will be visually augmented
    when their state is updated. Recall that you set up the `App` component to re-render
    every five seconds. Every time, it''s calling `setState()`, which results in output
    that looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您勾选了这个框，当它们的状态更新时，您渲染的元素将在视觉上得到增强。请记住，您设置了`App`组件每五秒重新渲染一次。每次调用`setState()`时，输出看起来像这样：
- en: '![](Images/a4dfa551-27c4-4e87-88de-f088df5b408d.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a4dfa551-27c4-4e87-88de-f088df5b408d.png)'
- en: The blue border briefly flashes around the element that's just been updated.
    Although you can't see everything that `<App>` renders in this screenshot, the
    blue border is surrounding all `<Group>` elements because it's indicating that
    the `<App>` component was just updated. If you watch your screen for a few moments,
    you'll notice that the blue border shows up every 5 seconds. This indicates that
    even though nothing has changed with the state of your element, it's still performing
    reconciliation. It's traversing potentially hundreds or thousands of tree nodes
    to find any differences and make the appropriate DOM updates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色边框会在刚刚更新的元素周围闪烁一下。虽然您在这个截图中看不到`<App>`渲染的所有内容，但蓝色边框围绕所有`<Group>`元素，因为它表示`<App>`组件刚刚更新。如果您观察一会儿屏幕，您会注意到蓝色边框每5秒出现一次。这表明即使您的元素状态没有改变，它仍在执行协调。它正在遍历可能有数百或数千个树节点，查找任何差异并进行适当的DOM更新。
- en: While you can't notice a difference in this app, the cumulative effect of a
    more complex React application might become a problem. In this specific case,
    it's a potential problem because of the update frequency.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您在这个应用程序中看不到差异，但更复杂的React应用程序的累积效果可能会成为问题。在这种特定情况下，由于更新频率，这是一个潜在的问题。
- en: 'Let''s make an addition to `App` that looks for a shortcut to performing full
    reconciliation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`App`进行一个补充，看看是否有一种快捷方式可以执行完全的协调：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a React component class has the `shouldComponentUpdate()` method and it returns
    false, reconciliation is completely avoided and no re-render takes place. You
    can see the change immediately in your browser by making sure that the Highlight
    Updates checkbox is checked. If you sit and watch for a few more moments, you'll
    see that no more blue borders show up.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个React组件类有`shouldComponentUpdate()`方法并且返回false，就会完全避免协调，不会进行重新渲染。通过确保勾选了高亮更新复选框，您可以立即在浏览器中看到变化。如果您坐下来观察一会儿，您会发现没有更多的蓝色边框出现。
- en: There are different colors for the update borders. The blue that you're seeing
    represents infrequent updates. These range all the way to red, depending on the
    frequency of update. For example, if you slide the groups or members sliders aggressively
    back and forth, you should be able to produce the red border.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 更新边框有不同的颜色。您看到的蓝色代表不经常的更新。这取决于更新的频率，可以一直到红色。例如，如果您来回快速滑动组或成员滑块，您应该能够产生红色边框。
- en: Note, however, that you can't always avoid reconciliation. What's important
    is that you macro-optimize for this. For example, the solution that you've just
    added to the `App` component addresses re-rendering a huge component with lots
    of children when it clearly isn't necessary. This is valuable compared to micro-optimizing
    the `Group` component—it's small enough that you don't save much by avoiding reconciliation
    here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，您并不总是能够避免协调。重要的是要对此进行宏观优化。例如，您刚刚添加到`App`组件的解决方案解决了在明显不必要的情况下重新渲染具有大量子元素的巨大组件。与微观优化`Group`组件相比，这是有价值的——它足够小，以至于在这里避免协调并不能节省太多。
- en: Your goal should be to keep it high level, and to keep `shouldComponentUpdate()`
    simple. This is an entry point for bugs to slip into your components. In fact,
    you've already introduced a bug. Try clicking on one of the Add Member buttons
    for a group—they no longer work. This is because the criteria you're using in
    `shouldComponentUpdate()` only takes into consideration the `groupCount` and `memberCount`
    states. It doesn't take into consideration adding new members to groups.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标应该是保持高水平，并保持`shouldComponentUpdate()`简单。这是bug进入组件的入口点。事实上，您已经引入了一个bug。尝试点击一个组的“添加成员”按钮，它们不再起作用。这是因为您在`shouldComponentUpdate()`中使用的标准只考虑了`groupCount`和`memberCount`状态。它没有考虑将新成员添加到组中。
- en: 'To fix this problem, you have to use the same approach as you have with the
    `groupCount` and `memberState` states in `shouldComponentUpdate()`. If the total
    number of members across all groups changes, then you know that your app needs
    to re-render. Let''s make this change in `shouldComponentUpdate()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，您必须使用与`shouldComponentUpdate()`中的`groupCount`和`memberState`状态相同的方法。如果所有组的成员总数发生变化，那么您就知道您的应用程序需要重新渲染。让我们在`shouldComponentUpdate()`中进行这个更改：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `totalMembers()` function takes a component state as an argument and returns
    the total number of group members. Using this, you can add another condition that
    uses this function to compare the number of members in the current state to the
    number of members in the new state:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalMembers()`函数以组件状态作为参数，并返回组成员的总数。使用这个函数，你可以添加另一个条件，使用这个函数来比较当前状态中的成员数量和新状态中的成员数量：'
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now if you try clicking on the Add Member button again, it will add the member
    as expected, because the component can detect that something about the state change.
    Once again, you're trading off the cost of summing the lengths of member arrays
    and comparing the two, with the cost of performing reconciliation in the React
    DOM tree.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您再次尝试点击“添加成员”按钮，它将如预期般添加成员，因为组件可以检测到状态变化。再次，您需要权衡计算成员数组长度并比较两者的成本，以及在React
    DOM树中执行协调的成本。
- en: Finding CPU intensive components
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找CPU密集型组件
- en: The `shouldComponentUpdate()` life cycle method enables macro-optimization of
    your component performance. If there's clearly no need to re-render the element,
    then let's sidestep the reconciliation process entirely. Other times, reconciliation
    simply cannot be avoided—the element state is changing frequently, and these changes
    need to be reflected in the DOM for the user to see.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate()`生命周期方法可以实现组件性能的宏观优化。如果明显不需要重新渲染元素，那么让我们完全绕过协调过程。其他时候，协调是无法避免的——元素状态经常发生变化，这些变化需要在DOM中反映出来供用户看到。'
- en: The development version of React 16 has some handy performance tooling built
    into it. It calls the relevant browser dev tool APIs in order to record relevant
    metrics while a profile is being recorded. Note that this isn't related to the
    React Developer Tools browser extension that you installed earlier; this is simply
    React interacting with the browser when in development mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: React 16的开发版本内置了一些方便的性能工具。它调用相关的浏览器开发工具API，以记录相关指标，同时记录性能概要。请注意，这与您之前安装的React开发者工具浏览器扩展无关；这只是React在开发模式下与浏览器交互。
- en: The aim is to produce React-specific timing data so that you don't have to mentally
    map 20 other browser performance metrics to your component and figure out what
    they all mean. Everything is there for you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是生成React特定的时间数据，这样您就不必将其他20个浏览器性能指标心算一遍，然后弄清楚它们的含义。一切都为您准备好了。
- en: 'To demonstrate this functionality, you can use the same code from the previous
    section with a couple of minor adjustments. First, let''s make more members available
    in each group:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个功能，您可以使用上一节中的相同代码，只需进行一些小的调整。首先，让我们在每个组中提供更多成员：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The reason we''ve increased this number is so that the performance of the app
    degrades as you fiddle with controls—it''s this performance degradation that you
    want to capture using performance dev tools. Next, let''s increase the maximum
    slider value for the members field:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加这个数字的原因是，当您操作控件时，应用的性能会下降——您希望使用性能开发工具来捕获这种性能下降。接下来，让我们增加成员字段的最大滑块值：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it. Now when you view this app in your browser, it should look like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在当您在浏览器中查看此应用时，它应该是这样的：
- en: '![](Images/d94284d1-cb45-41aa-9581-48035d414df0.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d94284d1-cb45-41aa-9581-48035d414df0.png)'
- en: 'Before changing any of these slider values, make sure that your developer tools
    pane is open and that the Performance tab is selected:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改任何这些滑块数值之前，请确保您的开发者工具窗格已打开，并且已选择“性能”选项卡：
- en: '![](Images/6c402524-13d2-4263-b2f4-207eb195edd9.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6c402524-13d2-4263-b2f4-207eb195edd9.png)'
- en: 'Next, click on the circle icon to the left to start recording a performance
    profile. The button will change to red and you''ll see a status dialog appear,
    indicating that profiling has started:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击左侧的圆圈图标开始记录性能概要。按钮将变为红色，您会看到一个状态对话框出现，表示已开始分析：
- en: '![](Images/1deafabf-f16c-473c-912a-a928c7235061.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1deafabf-f16c-473c-912a-a928c7235061.png)'
- en: 'Now that you''re recording, slide the Groups slider all the way to the right.
    As you get closer to the right, you might notice some lag in the UI, which is
    a good thing since this is what you''re trying to engineer. Once you reach the
    right side of the slider, stop the recording by clicking on the red circle that
    you clicked on to start the recording. You should see something similar to the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您正在记录，将“组”滑块滑动到最右边。当您接近右边时，您可能会注意到UI有些延迟，这是件好事，因为这正是您想要设计的。一旦滑块滑到最右边，点击开始录制时点击的红色圆圈来停止录制。您应该会看到类似以下的内容：
- en: '![](Images/8a141de3-4c30-4c9a-94e2-2be50a38a43f.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a141de3-4c30-4c9a-94e2-2be50a38a43f.png)'
- en: I've expanded the User Timing label on the left because this is where all of
    the React-specific timings are displayed. Time flows from left to right in this
    graph. The wider something is, the longer it took to happen. You might notice
    that the performance worsens as you near the right-hand side of the slider (and
    this might also coincide with the lag you noticed in the slider control).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我扩大了左侧的用户定时标签，因为这里显示了所有React特定的时间。在这个图表中，时间从左到右流动。某件事情越宽，它花费的时间就越长。您可能会注意到，当您接近滑块的右侧时，性能会变差（这也可能与您在滑块控制中注意到的延迟相吻合）。
- en: 'So, let''s explore what some of this data means. We''ll look at data on the
    far right since this is where performance really dropped off:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们探索一下这些数据的含义。我们将查看最右边的数据，因为这里性能真的下降了：
- en: '![](Images/1d20af25-e877-45b5-bebb-b1a522feceb2.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1d20af25-e877-45b5-bebb-b1a522feceb2.png)'
- en: 'This label tells you that the React Tree Reconciliation took 78 milliseconds
    to perform. Not terribly slow, but slow enough that it had a tangible impact on
    user experience. As you move your way down through these labels, you should be
    able to get a better idea of why the reconciliation process takes as long as it
    does. Let''s look at the next one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签告诉您，React树协调需要78毫秒来执行。并不是非常慢，但足够慢以至于对用户体验产生了实质性影响。当您逐个查看这些标签时，您应该能更好地了解为什么协调过程需要这么长时间。让我们看下一个：
- en: '![](Images/fb5e831e-1891-4aac-8cad-7ecfac962b94.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fb5e831e-1891-4aac-8cad-7ecfac962b94.png)'
- en: 'This is interesting: the App [update] label is telling you that a state update
    in the `App` component took 78 milliseconds. At this point, you know that a state
    update in `App` caused the React reconciliation process to take 78 milliseconds.
    Let''s jump down to the next level. At this level, there are two colors. Let''s
    see what the yellow represents:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣：`App [update]` 标签告诉你，在 `App` 组件中的状态更新花费了 78 毫秒。在这一点上，你知道 `App` 中的状态更新导致了
    React 协调过程花费了 78 毫秒。让我们跳到下一个级别。在这个级别，有两种颜色。让我们看看黄色代表什么：
- en: '![](Images/0ee7953c-f898-4e19-b24c-1cc5e0c397dc.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0ee7953c-f898-4e19-b24c-1cc5e0c397dc.png)'
- en: 'By hovering over one of the yellow slices, you can see that Group [update]
    took 7.7 milliseconds to update a `Group` component. This is a tiny amount of
    time that probably can''t be improved upon in any meaningful way. However, take
    a look at the number of yellow slices representing `Group` updates. All of these
    slices of single-digit timings add up to a significant portion of the overall
    reconciliation time. Lastly, let''s look at the brown color:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过悬停在黄色的片段上，你可以看到 `Group [update]` 花费了 7.7 毫秒来更新一个 `Group` 组件。这可能是一个微不足道的时间，可能无法以任何有意义的方式改进。然而，看一下代表
    `Group` 更新的黄色片段的数量。所有这些单位数时间片段加起来占据了整体协调时间的相当大一部分。最后，让我们看看棕色：
- en: '![](Images/942e8e87-2081-4841-8f72-8360e6901a41.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/942e8e87-2081-4841-8f72-8360e6901a41.png)'
- en: This label, Group [mount], indicates that it took 6.5 milliseconds to mount
    a new `Group` component. Once again, this is a small number, but there are several
    slices of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签，`Group [mount]`，表示安装一个新的 `Group` 组件花费了 6.5 毫秒。再一次，这是一个小数字，但有几个片段。
- en: At this point, you've drilled all the way down to the bottom of the component
    hierarchy to examine what's causing your performance issues. What's the takeaway
    here? You determined that the bulk of the time taken by React to perform reconciliation
    is happening in the `Group` component. Each time it renders a `Group` component,
    it only takes single-digit milliseconds to complete, but there are a lot of groups.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你已经一直深入到组件层次结构的底部，以检查是什么导致了你的性能问题。这里的要点是什么？你确定了 React 执行协调所花费的大部分时间发生在
    `Group` 组件中。每次渲染 `Group` 组件时，只需要几毫秒的时间来完成，但有很多组。
- en: Thanks to the performance graph in the browser developer tools, you now know
    that there's nothing to gain by changing your code—you're not going to improve
    on single-digit millisecond times in any meaningful way. In this app, the only
    way to fix the lag that you felt as you moved the slider toward the right is to
    somehow reduce the number of elements that get rendered on the page. On the other
    hand, you might notice that some of these React performance metrics have 50 milliseconds,
    or hundreds of milliseconds in some cases. You can easily fix your code to provide
    a better user experience. The key is that you'll never know what actually makes
    a difference without a performance dev tool like the one you've worked with in
    this section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢浏览器开发者工具中的性能图表，现在你知道改变你的代码并不会有所收获——你不会以任何有意义的方式改善单位数毫秒的时间。在这个应用程序中，解决你在将滑块向右移动时感到的延迟的唯一方法是以某种方式减少在页面上呈现的元素数量。另一方面，你可能会注意到一些
    React 性能指标有 50 毫秒，或在某些情况下有数百毫秒。你可以轻松修复你的代码以提供更好的用户体验。关键是，如果没有像你在本节中使用过的性能开发工具，你将永远不知道实际上有什么会产生差异。
- en: You can often feel the performance issues when you interact with your application
    as a user. But another way to verify that your components have performance woes
    is to look at the frame rate that is displayed just above the React metrics in
    green. It shows you how long frames took to render during the corresponding React
    code below. This example that you've just built starts off at 40 frames per second
    when the slider is to the left but ends at 10 frames per second when the slider
    makes it all the way to the right.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您作为用户与应用程序交互时，通常会感觉到性能问题。但验证组件是否存在性能问题的另一种方法是查看显示在React指标上方的帧速率，呈绿色。它显示了在相应的React代码下渲染帧所花费的时间。您刚刚构建的示例在滑块位于左侧时以每秒40帧开始，但当滑块移至最右侧时以每秒10帧结束。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about React tooling that is available directly
    through the web browser. The tool of choice here is a Chrome/Firefox extension
    called React Developer Tools. This extension adds React-specific capabilities
    to the browsers native developer tools. After you installed the extension, you
    learned how to select React elements and how to search for React elements by tag
    name.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了可以直接通过Web浏览器使用的React工具。这里的首选工具是一个名为React Developer Tools的Chrome/Firefox扩展程序。该扩展程序为浏览器的原生开发者工具添加了特定于React的功能。安装了该扩展程序后，您学会了如何选择React元素以及如何按标签名称搜索React元素。
- en: Next, you looked at the properties and state values of the selected React component
    in React Developer Tools. These values are kept up to date automatically, as they're
    changed by your application. You then learned how to directly manipulate element
    state directly within the browser. The limitation here being that you can't add
    or remove values from collections.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您查看了React Developer Tools中所选React组件的属性和状态值。这些值会自动更新，因为它们被应用程序更改。然后，您学会了如何在浏览器中直接操作元素状态。这里的限制是您无法向集合中添加或删除值。
- en: Finally, you learned how to profile your React component performance within
    the browser. This isn't a React Developer Tools feature, but something the develop
    build of React 16 does automatically. Using profiles like these allows you to
    make sure that you're addressing the right things when you're experiencing performance
    issues. The example that you looked at in this chapter showed that there wasn't
    actually anything wrong with the code—it was a problem of rendering too many elements
    on the screen at once.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学会了如何在浏览器中对React组件的性能进行分析。这不是React Developer Tools的功能，而是React 16的开发版本自动执行的。使用这样的分析可以确保在遇到性能问题时您正在解决正确的问题。本章中您查看的示例表明，代码实际上并没有问题，问题在于一次在屏幕上渲染了太多的元素。
- en: In the next chapter, you'll build a Redux-based React application and use Redux
    DevTools to instrument the state of your application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将构建一个基于Redux的React应用程序，并使用Redux DevTools来监视应用程序的状态。
