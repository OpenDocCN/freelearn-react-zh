- en: Instrumenting Application State with Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux对应用程序状态进行仪器化
- en: Redux is the de facto library for managing state in your React applications.
    On their own, React applications can manage the state of their components using
    nothing but `setState()`. The challenge with this approach is that there's nothing
    controlling the ordering of state changes (think about asynchronous calls like
    HTTP requests).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是在React应用程序中管理状态的事实标准库。单独使用React应用程序可以使用`setState()`来管理其组件的状态。这种方法的挑战在于没有控制状态更改的顺序（考虑异步调用，如HTTP请求）。
- en: The aim of this chapter isn't to introduce you to Redux—there are plenty of
    resources for this, including Packt books and the official Redux documentation.
    So, if you're new to Redux, you might want to spend 30 minutes familiarizing yourself
    with the basics of Redux before continuing here. The focus of this chapter is
    the tooling that you can enable within your web browser. I think that a significant
    portion of the value of Redux comes from the Redux DevTools browser extension.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是向您介绍Redux——有很多资源可以做到这一点，包括Packt图书和官方Redux文档。因此，如果您对Redux还不熟悉，您可能希望在继续之前花30分钟熟悉Redux的基础知识。本章的重点是您可以在Web浏览器中启用的工具。我认为Redux的重要价值之一来自Redux
    DevTools浏览器扩展。
- en: 'In this chapter, you''ll learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: How to build a basic Redux app (without going into depth on Redux concepts)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建一个基本的Redux应用程序（而不深入研究Redux概念）
- en: Installing the Redux DevTools Chrome extension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Redux DevTools Chrome扩展
- en: Selecting Redux actions and examining their contents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择Redux操作并检查其内容
- en: How to use time-travel debugging techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用时光旅行调试技术
- en: Triggering actions manually to change state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动触发操作以更改状态
- en: Exporting application state and importing it later
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出应用程序状态并稍后导入
- en: Building a Redux app
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Redux应用程序
- en: The example application that you'll use in this chapter is a basic book manager.
    The goal is to have something that has enough functionality to demonstrate different
    Redux actions, but simple enough that you can learn Redux DevTools without feeling
    overwhelmed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中您将使用的示例应用程序是一个基本的图书管理器。目标是拥有足够的功能来演示不同的Redux操作，但又足够简单，以便您可以学习Redux DevTools而不感到不知所措。
- en: 'The high-level functionality of this application is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的高级功能如下：
- en: Renders a list of books that you want to keep track of. Each book displays the
    title, author, and cover image of the book.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现您想要跟踪的书籍列表。每本书显示书籍的标题、作者和封面图片。
- en: Allows the user to filter the list by typing in a text input.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过在文本输入中键入来筛选列表。
- en: The user can create a new book.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以创建新书籍。
- en: The user can select a book to view more details.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择一本书查看更多详情。
- en: Books can be deleted.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍可以被删除。
- en: Let's spend a few minutes walking through the implementation of this app before
    you dive into the Redux DevTools extension.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在您深入研究Redux DevTools扩展之前，让我们花几分钟来了解这个应用程序的实现方式。
- en: The App component and state
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: App组件和状态
- en: 'The `App` component is the outer shell of the book manager application. You
    can think of `App` as the container for every other component that gets rendered.
    It is responsible for rendering the left-hand side navigation, and for defining
    the routes of the application so that the appropriate components are mounted and
    unmounted as the user moves around. Here''s what the implementation of `App` looks
    like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件是图书管理应用程序的外壳。您可以将`App`视为呈现的每个其他组件的容器。它负责呈现左侧导航，并定义应用程序的路由，以便在用户移动时挂载和卸载适当的组件。以下是`App`的实现方式：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `connect()` function from the `react-redux` package is used to connect the
    `App` component to the Redux store (where your application state lives). The `mapState()`
    and `mapDispatch()` functions add props to the `App` component—state values and
    action dispatcher functions respectively. So far, the `App` component has only
    one state value and no action dispatcher functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-redux`包中的`connect()`函数用于将`App`组件连接到Redux存储（应用程序状态所在的地方）。`mapState()`和`mapDispatch()`函数分别向`App`组件添加props——状态值和动作分发函数。到目前为止，`App`组件只有一个状态值和没有动作分发函数。'
- en: 'For a more in-depth look at how to connect React components to Redux stores,
    take a look at this page: [https://redux.js.org/basics/usage-with-react](https://redux.js.org/basics/usage-with-react).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解如何将React组件连接到Redux存储，请查看此页面：[https://redux.js.org/basics/usage-with-react](https://redux.js.org/basics/usage-with-react)。
- en: 'Let''s take a look at the `app()` reducer function next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来看一下`app()`reducer函数：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There isn't much to the state used by `App` except a `title`. In fact, this
    `title` never changes. The reducer function simply returns the state that's passed
    to it. You don't actually need a `switch` statement here because there are no
    actions to handle. However, the `title` state is likely something that will change
    based on actions—you just don't know yet. It's never a bad idea to set up reducer
    functions like this so that you can connect a component to the Redux store, and
    so that once you identify an action that should cause a state change, you have
    a reducer function ready to handle it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`使用的状态并不多，只有一个`title`。实际上，这个`title`永远不会改变。reducer函数只是简单地返回传递给它的状态。在这里实际上不需要`switch`语句，因为没有需要处理的动作。然而，`title`状态很可能会根据动作而改变——只是您还不知道。设置这样的reducer函数从来不是坏主意，这样您就可以将组件连接到Redux存储，一旦确定应该引起状态改变的动作，就有一个准备好处理它的reducer函数。'
- en: The Home component and state
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页组件和状态
- en: 'The `Home` component is the first component that is rendered as a child component
    of `App`. The route for `Home` is `/`, and this is where the filter text input
    and book list are rendered. Here is what the user will see when they first load
    the app:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home`组件是作为`App`的子组件首先呈现的组件。`Home`的路由是`/`，这是过滤文本输入和书籍列表呈现的地方。当用户首次加载应用程序时，用户将看到以下内容：'
- en: '![](Images/0a050df1-aad0-4cee-8122-e23050da6408.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0a050df1-aad0-4cee-8122-e23050da6408.png)'
- en: 'To the left, you have the two navigation links that are rendered by the `App`
    component. To the right of these links you have the filter text input, followed
    by the list of books—React books no less. Now, let''s take a look at the `Home`
    component implementation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边，您有由`App`组件呈现的两个导航链接。在这些链接的右侧，您有过滤文本输入，然后是书籍列表——React书籍。现在，让我们来看一下`Home`组件的实现：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The key things to pay attention to here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的关键事项：
- en: The `componentWillMount()` calls `fetchBooks()` to load book data from the API
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount()`调用`fetchBooks()`从API加载书籍数据'
- en: The `Loading` component is used to display loading text while books are being
    fetched
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loading`组件用于在获取书籍时显示加载文本'
- en: The `Home` component defines functions that dispatch actions, something you'll
    want to look at using Redux DevTools
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Home`组件定义了分发动作的函数，这是您希望使用Redux DevTools查看的内容'
- en: The book and filter data come from the Redux store
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍和过滤数据来自Redux存储
- en: 'Here''s the reducer function that handles actions and maintains state relevant
    to this component:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理动作并维护与该组件相关状态的reducer函数：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you look at the `initialState` object, you can see that `Home` depends on
    a `books` array, a `filterValue` string, and a `loading` Boolean. Each of the
    action cases within the `switch` statement changes part of this state. While it
    might be a little tricky to decipher what's happening by looking at this reducer
    code, combined with Redux browser tooling, the picture becomes clear because you
    can map what you're seeing in the app back to this code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看`initialState`对象，你会看到`Home`依赖于一个`books`数组，一个`filterValue`字符串和一个`loading`布尔值。`switch`语句中的每个动作情况都会改变这个状态的一部分。虽然通过查看这个reducer代码可能有点棘手，但结合Redux浏览器工具，情况变得清晰起来，因为你可以将在应用程序中看到的内容映射回这段代码。
- en: The NewBook component and state
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NewBook组件和状态
- en: 'Under the Home link in the left-hand side navigation, there is a NewBook link.
    Clicking on this link will take you to the form that allows you to create a new
    book. Let''s take a look at the `NewBook` component source now:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧导航栏的主页链接下面，有一个NewBook链接。点击这个链接将带你到一个允许你创建新书的表单。现在让我们来看一下`NewBook`组件的源码：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you look at the markup that's used to render this component, you'll see that
    there are three input fields. The values of these fields are passed as props.
    The connection to the Redux store is actually where these props come from. As
    their state changes, the `NewBook` component is re-rendered.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下用于渲染这个组件的标记，你会看到有三个输入字段。这些字段的值作为props传递。与Redux存储的连接实际上就是这些props的来源。随着它们的状态改变，`NewBook`组件会重新渲染。
- en: 'The dispatch functions that are mapped to this component are responsible for
    dispatching actions that maintain the state of this component. Their responsibilities
    are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到这个组件的调度函数负责调度维护这个组件状态的动作。它们的责任如下：
- en: '`onTitleChange()`: Dispatches the `SET_NEW_BOOK_TITLE` action along with the
    new `title` state'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTitleChange()`: 调度`SET_NEW_BOOK_TITLE`动作以及新的`title`状态'
- en: '`onAuthorChange()`: Dispatches the `SET_NEW_BOOK_AUTHOR` action along with
    the new `author` state'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAuthorChange()`: 调度`SET_NEW_BOOK_AUTHOR`动作以及新的`author`状态'
- en: '`onImageURLChange()`: Dispatches the `SET_NEW_BOOK_IMAGE_URL` action along
    with the new `imgURL` state'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onImageURLChange()`: 调度`SET_NEW_BOOK_IMAGE_URL`动作以及新的`imgURL`状态'
- en: '`onCreateBook()`: Dispatches the `CREATING_BOOK` action then dispatches the
    `CREATED_BOOK` action when the `createBook()` API call returns'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateBook()`: 调度`CREATING_BOOK`动作，然后在`createBook()` API调用返回时调度`CREATED_BOOK`动作'
- en: Don't worry if it's not clear how all of these actions result in high-level
    application behavior. This is why you're going to install Redux DevTools shortly,
    so that you can understand what's happening with your application state as it
    changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不清楚所有这些动作是如何导致高级应用程序行为的，不要担心。这就是为什么你马上要安装Redux DevTools，这样你就可以理解应用程序状态的变化情况。
- en: 'Here''s the reducer function that handles these actions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理这些动作的reducer函数：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, here''s what the new book form looks like when rendered:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这就是渲染时新书表单的样子：
- en: '![](Images/dbcc1d82-4baf-4e9a-9c23-2ce022aad8c2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dbcc1d82-4baf-4e9a-9c23-2ce022aad8c2.png)'
- en: When you fill out these fields and click on the Create button, the new book
    will be created by the mock API and you'll be taken back to the Home page, where
    the new book should be listed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你填写这些字段并点击创建按钮时，新书将由模拟API创建，并且你将被带回到主页，新书应该会被列出。
- en: The API abstraction
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API抽象
- en: 'For this application, I''m using a simple API abstraction. In Redux apps, you
    should be able to have your asynchronous functionality—API or otherwise—encapsulated
    in its own module or package. Here''s what the `api.js` module looks like, with
    some of the mock data redacted for brevity:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我正在使用一个简单的API抽象。在Redux应用程序中，您应该能够将您的异步功能（API或其他）封装在自己的模块或包中。以下是`api.js`模块的样子，其中一些模拟数据已被省略以保持简洁：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To get started with building your Redux app, this is all you need. The important
    thing to note here is that each of these API functions returns a `Promise` object.
    For good measure, I'm adding some simulated latency because this more closely
    resembles a real API. Something you don't want to do with your API abstractions
    is have them return regular values—like objects or arrays. If they're going to
    be asynchronous when interacting with a real API, make sure that the initial mocks
    are asynchronous as well. Otherwise, this is exceedingly difficult to correct.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建您的Redux应用程序，这就是您所需要的。这里需要注意的重要一点是，这些API函数中的每一个都返回一个`Promise`对象。为了更贴近真实API，我添加了一些模拟的延迟。您不希望API抽象返回常规值，比如对象或数组。如果它们在与真实API交互时会是异步的，请确保初始模拟也是异步的。否则，这将非常难以纠正。
- en: Putting it all together
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'Let''s quickly look at the source files that bring everything together to give
    you a sense of completeness. Let''s start with `index.js`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下将所有内容整合在一起的源文件，以便让您感受到完整性。让我们从`index.js`开始：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This looks just like most `index.js` files in `create-react-app` that you''ve
    worked with so far in this book. Instead of rendering an `App` component, it''s
    rendering a `Root` component. Let''s look at this next:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来就像这本书中到目前为止您所使用的`create-react-app`中的大多数`index.js`文件。它不是渲染一个`App`组件，而是渲染一个`Root`组件。让我们接着看：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The job of `Root` is to wrap the `App` component with a `Provider` component
    from `react-redux`. This component takes a `store` prop, which is how you're able
    to ensure that connected components have access to Redux store data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Root`的工作是用`react-redux`中的`Provider`组件包装`App`组件。这个组件接受一个`store`属性，这样您就能确保连接的组件可以访问Redux
    store数据。'
- en: 'Let''s take a look at the `store` prop next:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看一下`store`属性：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Redux has a `createStore()` function that builds a store for your React app.
    The first argument is the reducer function that handles actions and returns the
    new state of the store. The second argument is an enhancer function that can respond
    to changes in store state. In this case, you want to check if the Redux DevTools
    browser extension is installed and if it is, then connect it to your store. Without
    this step, you won't be able to use browser tooling with your Redux app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Redux有一个`createStore()`函数，用于为您的React应用程序构建一个store。第一个参数是处理操作并返回store新状态的reducer函数。第二个参数是一个增强器函数，可以响应store状态的变化。在这种情况下，您需要检查Redux
    DevTools浏览器扩展是否安装，如果安装了，就将其连接到您的store。如果没有这一步，您将无法使用浏览器工具与您的Redux应用程序一起使用。
- en: 'We''re almost done. Let''s look at the `reducers/index.js` file that combines
    your reducer functions into one function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了。让我们看一下`reducers/index.js`文件，它将您的reducer函数组合成一个函数：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Redux has only one store. In order to subdivide your store into slices of state
    that map to the concepts of your application, you name the individual reducer
    functions that handle the various slices of state and pass them to `combineReducers()`.
    With this app, your store has the following slices of state that can be mapped
    to components:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Redux只有一个store。为了将您的store细分为映射到应用程序概念的状态片段，您需要命名处理各种状态片段的个体reducer函数，并将它们传递给`combineReducers()`。对于这个应用程序，您的store有以下状态片段，可以映射到组件：
- en: '`app`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`'
- en: '`home`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home`'
- en: '`newBook`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newBook`'
- en: '`bookDetails`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bookDetails`'
- en: Now that you've seen how this app is put together and how it works, it's time
    to start instrumenting it with the Redux DevTools browser extension.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了这个应用程序是如何组合和工作的，现在是时候开始使用Redux DevTools浏览器扩展对其进行调试了。
- en: Installing Redux DevTools
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Redux DevTools
- en: 'Installing the Redux DevTools browser extension follows a process similar to
    the one used to install the React Developer Tools extension. The first step is
    to open the Chrome Web Store and search for `redux`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Redux DevTools浏览器扩展的过程与安装React Developer Tools扩展的过程类似。第一步是打开Chrome Web Store并搜索`redux`：
- en: '![](Images/a957174c-636f-4f30-95c0-6003d056f060.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a957174c-636f-4f30-95c0-6003d056f060.png)'
- en: 'The extension that you''re looking for will likely be the first result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您要寻找的扩展很可能是第一个结果：
- en: '![](Images/4096be9e-1222-468c-9bb0-f7584bcc05f4.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4096be9e-1222-468c-9bb0-f7584bcc05f4.png)'
- en: 'Go ahead and click on the Add To Chrome button. You''ll then see a dialog that
    asks for your permission to install the extension after showing you what it can
    change:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加到Chrome”按钮。然后，您将看到一个对话框，询问您是否同意安装该扩展，并在向您展示它可以更改的内容后安装该扩展：
- en: '![](Images/2bd0242f-e927-4bb9-b575-790da2950230.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2bd0242f-e927-4bb9-b575-790da2950230.png)'
- en: 'After you click on the Add extension button, you''ll see a notification that
    the extension has been installed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“添加扩展”按钮后，您将看到一个通知，指出已安装了该扩展：
- en: '![](Images/b3d17380-897b-4aee-ada0-3589c61405f5.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b3d17380-897b-4aee-ada0-3589c61405f5.png)'
- en: 'Just like the React Developer Tools extension, the Redux DevTools icon will
    remain disabled until you open a page that is running Redux and has added support
    for the tool. Recall that you explicitly added support for this tool in the book
    manager app with the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像React Developer Tools扩展一样，Redux DevTools图标在打开运行Redux并添加了对该工具的支持的页面之前都会保持禁用状态。请记住，您在图书管理应用程序中明确添加了对该工具的支持，使用了以下代码：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s fire up the book manager app and make sure that you can use the
    extension with it. After running `npm start` and waiting for the UI to open and
    load in a browser tab, the React and Redux developer tool icons should both be
    enabled:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动图书管理应用程序，并确保您可以使用该扩展。运行`npm start`并等待UI在浏览器选项卡中打开和加载后，React和Redux开发人员工具图标应该都是启用状态：
- en: '![](Images/16668166-462b-4619-a3bd-8a90e1e74ac4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16668166-462b-4619-a3bd-8a90e1e74ac4.png)'
- en: 'Next, open up the developer tools browser pane. You can access the Redux DevTools
    the same way that you would access the React Developer Tools:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开开发人员工具浏览器窗格。您可以以与访问React Developer Tools相同的方式访问Redux DevTools：
- en: '![](Images/a4b67925-eece-47eb-9666-4e153302dddf.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a4b67925-eece-47eb-9666-4e153302dddf.png)'
- en: 'When you select the Redux tool, you should see something similar to this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择Redux工具时，您应该看到类似于这样的东西：
- en: '![](Images/6ba88c51-acc2-466d-bdd3-8546902118ac.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6ba88c51-acc2-466d-bdd3-8546902118ac.png)'
- en: The left pane in the Redux DevTools has the most important data—the actions
    in your application. As reflected here, three actions have been dispatched by
    your book manager app, so you know that everything's working!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools中的左侧窗格包含最重要的数据——应用程序中的操作。正如在这里反映的，您的图书管理应用程序已经分派了三个操作，因此您知道一切都在运作！
- en: Selecting and examining actions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和检查操作
- en: The actions displayed on the left-hand side pane of Redux DevTools are listed
    chronologically, based on when they were dispatched. Any action can be selected,
    and by doing so, you can use the right-hand side pane to examine different aspects
    of the application state and of the action itself. In this section, you'll learn
    how to look deeper into how Redux actions drive your application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools左侧窗格上显示的操作是按时间顺序列出的，根据它们的分派时间。可以选择任何操作，并通过这样做，您可以使用右侧窗格来检查应用程序状态和操作本身的不同方面。在本节中，您将学习如何深入了解Redux操作如何驱动您的应用程序。
- en: Action data
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数据
- en: 'By selecting an action, you can view the data that''s dispatched as part of
    the action. But first, let''s generate some actions. Once the app loads, the `FETCHING_BOOKS`
    and `FETCHED_BOOKS` actions are dispatched. Click on the React Native Blueprints
    link, which loads the book data and takes you to the book details page. This results
    in two new actions being dispatched: `FETCHING_BOOK` and `FETCHED_BOOK`. The rendered
    React content should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择一个动作，你可以查看作为动作一部分分发的数据。但首先，让我们生成一些动作。一旦应用程序加载，就会分发`FETCHING_BOOKS`和`FETCHED_BOOKS`动作。点击React
    Native Blueprints链接，加载书籍数据并转到书籍详情页面。这将导致分发两个新动作：`FETCHING_BOOK`和`FETCHED_BOOK`。渲染的React内容应该是这样的：
- en: '![](Images/e574e27f-5535-4f5e-9eb9-6d67c411b22c.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e574e27f-5535-4f5e-9eb9-6d67c411b22c.png)'
- en: 'The list of actions in Redux DevTools should look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools中的动作列表应该是这样的：
- en: '![](Images/62944f30-feff-4817-9ed8-228666916afb.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/62944f30-feff-4817-9ed8-228666916afb.png)'
- en: The `@@INIT` action is dispatched automatically by Redux and is always the first
    action. Typically, you don't need to worry about this action unless you need to
    know what the state of your application looked like before dispatching and actions—we'll
    cover this in the following section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`@@INIT`动作是由Redux自动分发的，并且始终是第一个动作。通常情况下，你不需要担心这个动作，除非你需要知道在分发动作之前应用程序的状态是什么样子的——我们将在接下来的部分中介绍这个。'
- en: 'For now, let''s select the `FETCHING_BOOKS` action. Then, in the right-hand
    side pane, select the Action toggle button to see action data. You should see
    something that looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们选择`FETCHING_BOOKS`动作。然后，在右侧窗格中，选择动作切换按钮以查看动作数据。你应该看到类似这样的东西：
- en: '![](Images/0bbf2c89-66a2-4724-85e6-50753006196c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0bbf2c89-66a2-4724-85e6-50753006196c.png)'
- en: The tree view of the action is selected by default. You can see here that the
    action data has a single property called `type` and its value is the name of the
    action. This tells you that the reducer should know what to do with this action
    and that it doesn't need any additional data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下选择了动作的树视图。你可以在这里看到动作数据有一个名为`type`的属性，其值是动作的名称。这告诉你reducer应该知道如何处理这个动作，而且它不需要任何额外的数据。
- en: 'Let''s select the `FETCHED_BOOKS` action now and see what the action data looks
    like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们选择`FETCHED_BOOKS`动作，看看动作数据是什么样子的：
- en: '![](Images/dd659a0a-b418-478b-a04f-8dedf308ef97.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dd659a0a-b418-478b-a04f-8dedf308ef97.png)'
- en: Once again, you have the `type` property with the name of the action. This time,
    you also have a `books` property with an array of books. This action is dispatched
    in response to API data resolving and how book data makes its way into the store—its
    carried in by an action.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你有一个带有动作名称的`type`属性。这次，你还有一个带有书籍数组的`books`属性。这个动作是作为对API数据解析的响应而分发的，以及书籍数据如何进入存储——它是通过动作携带进来的。
- en: By looking at action data, you can compare what's actually dispatched versus
    what you're seeing in your application state. The only way to change application
    state is by dispatching actions with new state. Next, let's look at how individual
    actions change the state of the application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看动作数据，你可以比较实际分发的内容与应用程序状态中所看到的内容。改变应用程序状态的唯一方法是通过分发具有新状态的动作。接下来，让我们看看单个动作如何改变应用程序的状态。
- en: Action state trees and charts
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作状态树和图表
- en: In the previous section, you saw how to use Redux DevTools to select specific
    actions to view their data. Actions and the data that they carry lead to changes
    in application state. When you select an action, you can view the effect that
    the action has on the overall application state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你看到了如何使用Redux DevTools来选择特定的动作以查看它们的数据。动作及其携带的数据导致应用程序状态的变化。当你选择一个动作时，你可以查看该动作对整个应用程序状态的影响。
- en: 'Let''s select the `FETCHING_BOOK` action and then select the State toggle button
    in the right-hand side pane:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择`FETCHING_BOOK`操作，然后选择右侧窗格中的状态切换按钮：
- en: '![](Images/8dd1c0a5-9e74-4e19-a8dc-08f794b32d83.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8dd1c0a5-9e74-4e19-a8dc-08f794b32d83.png)'
- en: This Tree view shows you the entire state of the application after the `FETCHING_BOOK`
    action is dispatched. The `bookDetails` state is expanded here so that you can
    see the effect the action has on the state. In this case it's the `loading` value—which
    is now `true`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此树视图显示了在分派`FETCHING_BOOK`操作后应用程序的整个状态。在这里，`bookDetails`状态被展开，以便您可以看到该操作对状态的影响。在这种情况下，它是`loading`的值——现在是`true`。
- en: 'Let''s select the Chart view of this action now:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们选择此操作的图表视图：
- en: '![](Images/d006104a-453c-4e8d-82a9-199f2a7b6f51.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d006104a-453c-4e8d-82a9-199f2a7b6f51.png)'
- en: I happen to like the Chart view better than the Tree view for visualizing the
    entire state of the application. At the far left of the chart you have the root
    state. To the right of this, you have the main slices of application state—`app`,
    `home`, `newBook`, and `bookDetails`. As you move further and further right, you're
    drilling down into the specific state of components in your app. As you can see
    here, the deepest level is the individual books within the `books` array, which
    is part of the `home` state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我偏好图表视图而不是树视图，用于可视化应用程序的整个状态。在图表的最左边，您有根状态。在其右侧，您有应用程序状态的主要部分——`app`、`home`、`newBook`和`bookDetails`。随着您向右移动，您会深入到应用程序中组件的具体状态。正如您在这里看到的，最深层次是`home`状态中`books`数组中的个别书籍。
- en: 'The `FETCHING_BOOK` action is still selected, which means that this chart is
    a reflection of the application state after reducers have responded to this action.
    This action changes the `loading` state within `bookDetails`. If you move your
    mouse pointer over the state label, you''ll see its value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`FETCHING_BOOK`操作仍然被选中，这意味着该图表反映了reducers响应该操作后的应用程序状态。此操作改变了`bookDetails`中的`loading`状态。如果您将鼠标指针移动到状态标签上，您将看到它的值：'
- en: '![](Images/aa1973ca-bf4d-427e-bab2-57c092b02fc8.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aa1973ca-bf4d-427e-bab2-57c092b02fc8.png)'
- en: 'Now let''s select the `FETCHED_BOOK` action. This action is dispatched when
    the book detail data is resolved from the API call that is made to get it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们选择`FETCHED_BOOK`操作。当书籍详细数据从调用API获取解析时，将分派此操作：
- en: '![](Images/e231a49f-95ce-4e91-8f9b-353b5a3c5717.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e231a49f-95ce-4e91-8f9b-353b5a3c5717.png)'
- en: If you keep the Chart view activated while switching to a different action,
    you'll notice that the chart actually animates the changes in state. It looks
    cool, no doubt, but it also calls your attention to the values that actually changes
    so that they're easier to see. In this example, if you look at the `book` object
    under `bookDetails`, you'll see that it now has new properties. You can move your
    mouse pointer over each of them to reveal their value. You can also check the
    `loading` value—it should be back to `false`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在切换到不同的操作时保持图表视图处于激活状态，您会注意到图表实际上会动画显示状态的变化。这看起来很酷，毫无疑问，但它也会吸引您注意实际发生变化的值，以便更容易看到。在这个例子中，如果您查看`bookDetails`下的`book`对象，您会发现它现在有了新的属性。您可以将鼠标指针移动到每个属性上以显示其值。您还可以检查`loading`的值——它应该恢复为`false`。
- en: Action state diffs
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作状态差异
- en: Another way to view action data in Redux DevTools is to look at the state diff
    that results from dispatching the action. Instead of trying to glean the changes
    in state by looking at the entire state tree, this view only shows you what changed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux DevTools中查看操作数据的另一种方法是查看从分派操作中产生的状态差异。这个视图不是试图通过查看整个状态树来推断状态的变化，而是只向您展示了发生了什么变化。
- en: 'Let''s try adding a new book to generate some actions. I''m going to add the
    book you''re reading right now. First, I''ll paste in the title of the book that
    generates a change event on the input element, which in turn dispatches a `SET_NEW_BOOK_TITLE`
    action. If you select the action, you should see the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试添加一本新书来生成一些动作。我要添加你现在正在阅读的这本书。首先，我会粘贴生成输入元素上的更改事件的书名，然后触发`SET_NEW_BOOK_TITLE`动作。如果你选择该动作，你应该会看到以下内容：
- en: '![](Images/0184a821-7191-4608-bcb9-63c7002f8de5.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0184a821-7191-4608-bcb9-63c7002f8de5.png)'
- en: The `title` value of the `newBook` state went from an empty string to the value
    that was pasted into the title text input. Rather than having to hunt this change
    down, it is clearly marked for you to see, with all irrelevant state data hidden
    from view.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`newBook`状态的`title`值从空字符串变为了粘贴到标题文本输入框中的值。您无需寻找此更改，它已清晰标记，所有不相关的状态数据都被隐藏起来。'
- en: 'Next, let''s paste in the author and select the `SET_NEW_BOOK_AUTHOR` action:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们粘贴作者并选择`SET_NEW_BOOK_AUTHOR`动作：
- en: '![](Images/0b08d994-a1c6-4b75-8c78-ebfd3e6a0d5f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0b08d994-a1c6-4b75-8c78-ebfd3e6a0d5f.png)'
- en: 'Once again, only the `author` value is shown here because it''s the only value
    that changed as a result of dispatching `SET_NEW_BOOK_AUTHOR`. Here''s the final
    form field—the image URL:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里只显示了`author`值，因为它是由于分派`SET_NEW_BOOK_AUTHOR`而发生变化的唯一值。这是最终的表单字段-图像URL：
- en: '![](Images/1c1eb8d9-3ba2-4342-bb2f-00ee52fb5a72.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1c1eb8d9-3ba2-4342-bb2f-00ee52fb5a72.png)'
- en: By using the Diff view of actions, you only see data that has changed as a result
    of the action. If this doesn't give you enough perspective, you can always jump
    to the State view so that you can see the state of the entire application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用动作的差异视图，您只会看到由于动作而发生变化的数据。如果这不能给您足够的视角，您可以随时跳转到状态视图，以便查看整个应用程序的状态。
- en: 'Let''s create the new book by clicking the Create button. This will dispatch
    two actions: `CREATING_BOOK` and `CREATED_BOOK`. First, let''s look at `CREATING_BOOK`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击“创建”按钮来创建新书。这将分派两个动作：`CREATING_BOOK`和`CREATED_BOOK`。首先，让我们看看`CREATING_BOOK`：
- en: '![](Images/422ddb74-c474-4959-95c3-3da974d73a7a.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/422ddb74-c474-4959-95c3-3da974d73a7a.png)'
- en: This action is dispatched before the API call to *create the book* is made.
    This gives your React component an opportunity to handle the asynchronous nature
    of the user interaction. In this case, you don't want the user to be able to interact
    with any form controls while the request is pending. As you can see by looking
    at this diff, the `controlsDisabled` value is now `false`, which the React component
    can use to disable any form controls.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此动作在进行API调用*创建书籍*之前分派。这使得您的React组件有机会处理用户交互的异步性质。在这种情况下，您不希望用户在请求挂起时能够与任何表单控件进行交互。通过查看此差异，您可以看到`controlsDisabled`值现在为`false`，React组件可以使用它来禁用任何表单控件。
- en: 'Lastly, let''s look at the `CREATED_BOOK` action:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下`CREATED_BOOK`动作：
- en: '![](Images/04ae06c1-2447-4ed7-96c6-63cd93fbdae2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04ae06c1-2447-4ed7-96c6-63cd93fbdae2.png)'
- en: The `title`, `author`, and `imgURL` values are set to empty strings, which resets
    the form field values. The form fields are also re-enabled by setting `controlsDisabled`
    to `false`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`、`author`和`imgURL`的值都被设置为空字符串，这将重置表单字段的值。通过将`controlsDisabled`设置为`false`，表单字段也被重新启用。'
- en: Time travel debugging
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间旅行调试
- en: One requirement of reducer functions in Redux is that they're pure; that is,
    they only return new data as opposed to mutating existing data. One consequence
    of this is that it enables time travel debugging. Because nothing ever changes,
    you can move the state of your application forward, backward, or to an arbitrary
    point in time. The Redux DevTools make this easy to do.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中reducer函数的一个要求是它们必须是纯函数；也就是说，它们只返回新数据，而不是改变现有数据。这样做的一个结果是它可以实现时间旅行调试。因为没有任何改变，你可以将应用程序的状态向前、向后或者到任意时间点。Redux
    DevTools使这变得很容易。
- en: 'To see time travel debugging in action, let''s type some filter text into the
    filter input box:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到时间旅行调试的效果，让我们在过滤输入框中输入一些过滤文本：
- en: '![](Images/4890fad5-a3b9-40bd-b13e-5f0638cb5528.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4890fad5-a3b9-40bd-b13e-5f0638cb5528.png)'
- en: 'Looking at the actions in Redux DevTools, you should see something along these
    lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux DevTools中查看动作，你应该看到类似以下的内容：
- en: '![](Images/44479dd4-612e-464c-9b36-686871a88bd3.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/44479dd4-612e-464c-9b36-686871a88bd3.png)'
- en: 'I''ve selected the last `SET_FILTER_VALUE` action that was dispatched. The
    `filterValue` value should be `native b`, which reflects the titles that are currently
    displayed. Now, let''s travel back to two actions ago. To do this, move your mouse
    pointer over the action that''s two positions behind the currently selected action.
    Click on the Jump button, and the state of the application will be changed to
    the state when this `SET_FILTER_VALUE` was dispatched:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了最后一个被分发的`SET_FILTER_VALUE`动作。`filterValue`的值应该是`native b`，这反映了当前显示的标题。现在，让我们回到两个动作之前。为了做到这一点，将鼠标指针移动到当前选定动作的两个位置之前的动作上。点击Jump按钮，应用程序的状态将被更改为分发`SET_FILTER_VALUE`时的状态：
- en: '![](Images/2fefa33d-f519-4a4f-a49a-426a1cf58691.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2fefa33d-f519-4a4f-a49a-426a1cf58691.png)'
- en: 'You can see that `filterValue` has changed from `native b` to `native`. You''ve
    effectively undone the last two keystrokes, updating the state and the UI accordingly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`filterValue`已经从`native b`变成了`native`。你已经成功地撤销了最后两次按键，相应地更新了状态和UI：
- en: '![](Images/b7527dd9-15a2-423a-a19a-a019ebd351ab.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b7527dd9-15a2-423a-a19a-a019ebd351ab.png)'
- en: To bring the application state back to the current time, follow the same process
    but in reverse. Click on Jump on the most recent state.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序状态恢复到当前时间，按照相同的过程但是反向操作。点击最近状态上的Jump。
- en: Manually triggering actions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动触发动作
- en: 'The ability to manually trigger actions during development of a Redux application
    can be helpful. For instance, you might have components ready, but you''re unsure
    of how the user interaction will work or you just need to troubleshoot something
    that should be working but isn''t. You can use Redux DevTools to manually trigger
    actions by clicking on the button with the keyboard icon, near the bottom of the
    pane:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Redux应用程序时手动触发动作的能力是很有帮助的。例如，你可能已经准备好了组件，但是不确定用户交互会如何工作，或者你只是需要排除一些本应该工作但是却没有的问题。你可以使用Redux
    DevTools通过点击面板底部附近带有键盘图标的按钮来手动触发动作：
- en: '![](Images/e6616ed3-8773-4ad3-a25e-9d017bd38697.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e6616ed3-8773-4ad3-a25e-9d017bd38697.png)'
- en: 'This will display a text input where you can enter the action payload. For
    example, I''ve navigated to the book detail page for React Native By Example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个文本输入框，你可以在其中输入动作的载荷。例如，我已经导航到了《React Native By Example》的书籍详情页面：
- en: '![](Images/d9e90133-2813-482c-9715-d665919f4fc2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d9e90133-2813-482c-9715-d665919f4fc2.png)'
- en: 'Instead of clicking on the Delete button, I only want to see what happens regarding
    the state of the application, without triggering DOM events or API calls. To do
    this, I can click on the keyboard button in Redux DevTools, which allows me to
    manually enter an action and dispatch it. For example, here is how I would dispatch
    the `DELETING_BOOK` action:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想点击删除按钮，我只想看看应用程序的状态会发生什么变化，而不触发DOM事件或API调用。为了做到这一点，我可以点击Redux DevTools中的键盘按钮，这样我就可以手动输入一个动作并分派它。例如，这是我如何分派`DELETING_BOOK`动作的方式：
- en: '![](Images/3b466c6a-a022-42a3-a804-bf839d911c73.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b466c6a-a022-42a3-a804-bf839d911c73.png)'
- en: 'This results in the action being dispatched and consequently, the UI is updated.
    Here''s the `DELETING_BOOK` action:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致动作被分派，因此UI被更新。这是`DELETING_BOOK`动作：
- en: '![](Images/97ce8c9c-12b6-46fd-af51-6546958aa2fc.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/97ce8c9c-12b6-46fd-af51-6546958aa2fc.png)'
- en: 'To set `controlsDisabled` back to `false`, you can dispatch the `DELETED_BOOK`
    action:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`controlsDisabled`设置回`false`，您可以分派`DELETED_BOOK`动作：
- en: '![](Images/6e2d96cc-df1f-4e33-8a6b-a6a5d6eea9b0.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6e2d96cc-df1f-4e33-8a6b-a6a5d6eea9b0.png)'
- en: Exporting and importing state
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和导入状态
- en: As your Redux applications grow in size and complexity, the size and complexity
    of your state trees will grow in tandem. Because of this, there will be times
    when playing around with individual actions and to get your app into a specific
    state could be too cumbersome to perform manually over and over again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Redux应用程序的规模和复杂性的增长，状态树的大小和复杂性也会同步增长。因此，有时玩弄单个动作并使应用程序进入特定状态可能会太繁琐，无法手动一遍又一遍地执行。
- en: Using Redux DevTools, you can export the current state of the application. Then,
    when you're troubleshooting later on and you need a specific state as a starting
    point, you can load it directly, rather than manually recreate it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Redux DevTools，您可以导出应用程序的当前状态。然后，当您以后进行故障排除并需要特定状态作为起点时，您可以直接加载它，而不是手动重新创建它。
- en: 'Let''s try exporting the application state. First, navigate to the details
    page for React 16 Essentials:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试导出应用程序状态。首先，导航到React 16 Essentials的详细信息页面：
- en: '![](Images/9788df87-be18-4f79-9e26-9fd41416a8a3.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9788df87-be18-4f79-9e26-9fd41416a8a3.png)'
- en: 'To export the current state using Redux DevTools, click on the button with
    the down arrow:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Redux DevTools导出当前状态，请单击带有向下箭头的按钮：
- en: '![](Images/7a98ac22-dbe4-4483-afc2-270a94abf852.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7a98ac22-dbe4-4483-afc2-270a94abf852.png)'
- en: 'Then, you can use the up arrow to import the state. But before you do that,
    navigate to a different book title, such as Getting Started with React VR:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用向上箭头导入状态。但在这之前，导航到不同的书名，比如《使用React VR入门》：
- en: '![](Images/a7901dfa-fd1a-495c-8bab-a173b0ddd1d8.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a7901dfa-fd1a-495c-8bab-a173b0ddd1d8.png)'
- en: 'Now, you can use the upload button in the Redux DevTools pane:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在Redux DevTools窗格中使用上传按钮：
- en: '![](Images/bf99d7ef-83a4-44ff-907e-1df3592edd9b.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bf99d7ef-83a4-44ff-907e-1df3592edd9b.png)'
- en: 'Since you''re already on the book details page, loading this state will replace
    the state values that are rendered by components on this page:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经在书籍详细信息页面上，加载此状态将替换由此页面上的组件呈现的状态值：
- en: '![](Images/bf29eba2-d5d9-42c3-81b1-0e61af7e6d61.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bf29eba2-d5d9-42c3-81b1-0e61af7e6d61.png)'
- en: Now you know how to restore the state of your Redux store to any given point
    that you've exported and saved locally. The idea is to avoid having to remember
    and perform the correction actions in the correct order to arrive at a particular
    state. This is error-prone and exporting the exact state that's needed obviates
    the whole process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何将Redux存储的状态恢复到您导出并本地保存的任何给定点。这样做的想法是避免记住并按照正确的顺序执行校正操作以达到特定状态。这是容易出错的，导出所需的确切状态可以避免整个过程。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you put together a simple book manager Redux app. With the
    app in place, you then learned how to install the Redux DevTools browser extension
    in Chrome. From there, you learned how to view and select actions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你组合了一个简单的图书管理Redux应用程序。有了这个应用程序，然后你学会了如何在Chrome中安装Redux DevTools浏览器扩展。然后，你学会了如何查看和选择动作。
- en: There are a number of ways to view information about the application once you've
    selected an action. You can look at the action payload data. You can look at the
    application state in its entirety. You can look at diffs between the app state
    and the last dispatched action. These are all different approaches you can use
    to instrument your Redux applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了一个动作，就有许多方法可以查看有关应用程序的信息。你可以查看动作的载荷数据。你可以查看整个应用程序状态。你可以查看应用程序状态和上次分发的动作之间的差异。这些都是你可以用来调试Redux应用程序的不同方法。
- en: Then, you learned how time travel debugging works in Redux DevTools. Because
    state changes are immutable in Redux, you can use Redux DevTools to jump around
    from action to action. This can drastically simplify debugging cycles. Lastly,
    you learned how to manually dispatch actions and import/export the state of your
    application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学会了如何在Redux DevTools中进行时间旅行调试。因为在Redux中状态变化是不可变的，你可以使用Redux DevTools从一个动作跳转到另一个动作。这可以极大地简化调试周期。最后，你学会了如何手动分发动作以及导入/导出应用程序的状态。
- en: In the next chapter, you'll learn how to use Gatsby to generate static content
    from React components.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用Gatsby从React组件生成静态内容。
