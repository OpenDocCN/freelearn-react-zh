["```jsx\nimport React from 'react';\nimport { Map } from 'immutable';\n\n// This component displays the passed-in \"error\"\n// property as bold text. If it's null, then\n// nothing is rendered.\nconst ErrorMessage = ({ error }) =>\n  Map([[null, null]]).get(error, <strong>{error}</strong>);\n\n// This component displays the passed-in \"loading\"\n// property as italic text. If it's null, then\n// nothing is rendered.\nconst LoadingMessage = ({ loading }) =>\n  Map([[null, null]]).get(loading, <em>{loading}</em>);\n\nexport default ({\n  error, \n  loading,\n  users\n}) => (\n  <section>\n    {/* Displays any error messages... */}\n    <ErrorMessage error={error} />\n\n    {/* Displays any loading messages, while\n         waiting for the API... */}\n    <LoadingMessage loading={loading} />\n\n    {/* Renders the user list... */}\n    <ul>{users.map(i => <li key={i.id}>{i.name}</li>)}</ul>\n  </section>\n);\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport { users } from './api';\nimport UserList from './UserList';\n\nexport default class UserListContainer extends Component {\n  state = {\n    data: fromJS({\n      error: null,\n      loading: 'loading...',\n      users: []\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // When component has been rendered, \"componentDidMount()\"\n  // is called. This is where we should perform asynchronous\n  // behavior that will change the state of the component.\n  // In this case, we're fetching a list of users from\n  // the mock API.\n  componentDidMount() {\n    users().then(\n      result => {\n        // Populate the \"users\" state, but also\n        // make sure the \"error\" and \"loading\"\n        // states are cleared.\n        this.data = this.data\n          .set('loading', null)\n          .set('error', null)\n          .set('users', fromJS(result.users));\n      },\n      error => {\n        // When an error occurs, we want to clear\n        // the \"loading\" state and set the \"error\"\n        // state.\n        this.data = this.data\n          .set('loading', null)\n          .set('error', error);\n      }\n    );\n  }\n\n  render() {\n    return <UserList {...this.data.toJS()} />;\n  }\n}\n```", "```jsx\n// Returns a promise that's resolved after 2\n// seconds. By default, it will resolve an array\n// of user data. If the \"fail\" argument is true,\n// the promise is rejected.\nexport function users(fail) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (fail) {\n        reject('epic fail');\n      } else {\n        resolve({\n          users: [\n            { id: 0, name: 'First' },\n            { id: 1, name: 'Second' },\n            { id: 2, name: 'Third' },\n          ],\n        });\n      }\n    }, 2000);\n  });\n}\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport { users } from './api';\nimport UserList from './UserList';\n\nclass UserListContainer extends Component {\n  state = {\n    data: fromJS({\n      error: null,\n      users: []\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // When component has been rendered, \"componentDidMount()\"\n  // is called. This is where we should perform asynchronous\n  // behavior that will change the state of the component.\n  // In this case, we're fetching a list of users from\n  // the mock API.\n  componentDidMount() {\n    users().then(\n      result => {\n        // Populate the \"users\" state, but also\n        // make sure the \"error\" and \"loading\"\n        // states are cleared.\n        this.data = this.data\n          .set('error', null)\n          .set('users', fromJS(result.users));\n      },\n      error => {\n        // When an error occurs, we want to clear\n        // the \"loading\" state and set the \"error\"\n        // state.\n        this.data = this.data\n          .set('loading', null)\n          .set('error', error);\n      }\n    );\n  }\n\n  render() {\n    return <UserList {...this.data.toJS()} />;\n  }\n\n  // Called right before render, you can use this method\n  // to update the state of the component based on prop\n  // values.\n  static getDerivedStateFromProps(props, state) {\n    return {\n      ...state,\n      data: state.data.set(\n        'loading',\n        state.data.get('users').size === 0 ? props.loading : null\n      )\n    };\n  }\n}\n\nUserListContainer.defaultProps = {\n  loading: 'loading...'\n};\n\nexport default UserListContainer;\n\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport UserListContainer from './UserListContainer';\n\n// Renders the component with a \"loading\" property.\n// This value ultimately ends up in the component state.\nrender(\n  <UserListContainer loading=\"playing the waiting game...\" />,\n  document.getElementById('root')\n);\n\n```", "```jsx\nimport React from 'react';\n\nexport default ({\n  clicks,\n  disabled,\n  text,\n  onClick\n}) => (\n  <section>\n    {/* Renders the number of button clicks,\n         using the \"clicks\" property. */}\n    <p>{clicks} clicks</p>\n\n    {/* Renders the button. It's disabled state\n         is based on the \"disabled\" property, and\n         the \"onClick()\" handler comes from the\n         container component. */}\n    <button disabled={disabled} onClick={onClick}>\n      {text}\n    </button>\n  </section>\n);\n\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport MyButton from './MyButton';\n\nclass MyFeature extends Component {\n  state = {\n    data: fromJS({\n      clicks: 0,\n      disabled: false,\n      text: ''\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // Click event handler, increments the \"click\" count.\n  onClick = () => {\n    this.data = this.data.update('clicks', c => c + 1);\n  };\n\n  // Renders the \"<MyButton>\" component, passing it the\n  // \"onClick()\" handler, and the state as properties.\n  render() {\n    return <MyButton onClick={this.onClick} {...this.data.toJS()} />;\n  }\n\n  // If the component is re-rendered with new\n  // property values, this method is called with the\n  // new property values. If the \"disabled\" property\n  // is provided, we use it to update the \"disabled\"\n  // state. Calling \"setState()\" here will not\n  // cause a re-render, because the component is already\n  // in the middle of a re-render.\n  static getDerivedStateFromProps({ disabled, text }, state) {\n    return {\n      ...state,\n      data: state.data.set('disabled', disabled).set('text', text)\n    };\n  }\n}\n\nMyFeature.defaultProps = {\n  text: 'A Button'\n};\n\nexport default MyFeature;\n\n```", "```jsx\nimport React from 'react';\nimport { render as renderJSX } from 'react-dom';\n\nimport MyFeature from './MyFeature';\n\n// Determines the state of the button\n// element in \"MyFeature\".\nlet disabled = true;\n\nfunction render() {\n  // Toggle the state of the \"disabled\" property.\n  disabled = !disabled;\n\n  renderJSX(\n    <MyFeature {...{ disabled }} />,\n    document.getElementById('root')\n  );\n}\n\n// Re-render the \"<MyFeature>\" component every\n// 3 seconds, toggling the \"disabled\" button\n// property.\nsetInterval(render, 3000);\n\nrender();\n\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nexport default class MyList extends Component {\n  state = {\n    data: fromJS({\n      items: [...Array(5000).keys()]\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // If this method returns false, the component\n  // will not render. Since we're using an Immutable.js\n  // data structure, we simply need to check for equality.\n  // If \"state.data\" is the same, then there's no need to\n  // render because nothing has changed since the last render.\n  shouldComponentUpdate(props, state) {\n    return this.data !== state.data;\n  }\n\n  // Renders the complete list of items, even if it's huge.\n  render() {\n    const items = this.data.get('items');\n\n    return <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>;\n  }\n}\n\n```", "```jsx\nimport React from 'react';\nimport { render as renderJSX } from 'react-dom';\n\nimport MyList from './MyList';\n\n// Renders the \"<MyList>\" component. Then, it sets\n// the state of the component by changing the value\n// of the first \"items\" element. However, the value\n// didn't actually change, so the same Immutable.js\n// structure is reused. This means that\n// \"shouldComponentUpdate()\" will return false.\nfunction render() {\n  const myList = renderJSX(\n    <MyList />,\n    document.getElementById('root')\n  );\n\n  // Not actually changing the value of the first\n  // \"items\" element. So, Immutable.js recognizes\n  // that nothing changed, and instead of\n  // returning a new object, it returns the same\n  // \"myList.data\" reference.\n  myList.data = myList.data.setIn(['items', 0], 0);\n}\n\n// Instead of performing 500,000 DOM operations,\n// \"shouldComponentUpdate()\" turns this into\n// 5000 DOM operations.\nfor (let i = 0; i < 100; i++) {\n  render();\n}\n\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyUser extends Component {\n  state = {\n    modified: new Date(),\n    first: 'First',\n    last: 'Last'\n  };\n\n  // The \"modified\" property is used to determine\n  // whether or not the component should render.\n  shouldComponentUpdate(props, state) {\n    return Number(state).modified > Number(this.state.modified);\n  }\n\n  render() {\n    const { modified, first, last } = this.state;\n\n    return (\n      <section>\n        <p>{modified.toLocaleString()}</p>\n        <p>{first}</p>\n        <p>{last}</p>\n      </section>\n    );\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyUser from './MyUser';\n\n// Performs the initial rendering of \"<MyUser>\".\nconst myUser = render(<MyUser />, document.getElementById('root'));\n\n// Sets the state, with a new \"modified\" value.\n// Since the modified state has changed, the\n// component will re-render.\nmyUser.setState({\n  modified: new Date(),\n  first: 'First1',\n  last: 'Last1'\n});\n\n// The \"first\" and \"last\" states have changed,\n// but the \"modified\" state has not. This means\n// that the \"First2\" and \"Last2\" values will\n// not be rendered.\nmyUser.setState({\n  first: 'First2',\n  last: 'Last2'\n});\n```", "```jsx\nimport React, { Component } from 'react';\n\n// Import all the jQuery UI widget stuff...\nimport $ from 'jquery';\nimport 'jquery-ui/ui/widgets/button';\nimport 'jquery-ui/themes/base/all.css';\n\nexport default class MyButton extends Component {\n  // When the component is mounted, we need to\n  // call \"button()\" to initialize the widget.\n  componentDidMount() {\n    $(this.button).button(this.props);\n  }\n\n  // After the component updates, we need to use\n  // \"this.props\" to update the options of the\n  // jQuery UI button widget.\n  componentDidUpdate() {\n    $(this.button).button('option', this.props);\n  }\n\n  // Renders the \"<button>\" HTML element. The \"onClick()\"\n  // handler will always be a assigned, even if it's a\n  // noop function. The \"ref\" property is used to assign\n  // \"this.button\". This is the DOM element itself, and\n  // it's needed by the \"componentDidMount()\" and\n  // \"componentDidUpdate()\" methods.\n  render() {\n    return (\n      <button\n        onClick={this.props.onClick}\n        ref={button => {\n          this.button = button;\n        }}\n      />\n    );\n  }\n}\n\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport MyButton from './MyButton';\n\nclass MyButtonContainer extends Component {\n  // The initial state is an empty Immutable map, because\n  // by default, we won't pass anything to the jQuery UI\n  // button widget.\n  state = {\n    data: fromJS({})\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // When the component is mounted for the first time,\n  // we have to bind the \"onClick()\" handler to \"this\"\n  // so that the handler can set the state.\n  componentDidMount() {\n    this.data = this.data.merge(this.props, {\n      onClick: this.props.onClick.bind(this)\n    });\n  }\n\n  // Renders the \"<MyButton>\" component with this\n  // component's state as properties.\n  render() {\n    return <MyButton {...this.state.data.toJS()} />;\n  }\n}\n\n// By default, the \"onClick()\" handler is a noop.\n// This makes it easier because we can always assign\n// the event handler to the \"<button>\".\nMyButtonContainer.defaultProps = {\n  onClick: () => {}\n};\n\nexport default MyButtonContainer;\n\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyButtonContainer from './MyButtonContainer';\n\n// Simple button event handler that changes the\n// \"disabled\" state when clicked.\nfunction onClick() {\n  this.data = this.data.set('disabled', true);\n}\n\nrender(\n  <section>\n    {/* A simple button with a simple label. */}\n    <MyButtonContainer label=\"Text\" />\n\n    {/* A button with an icon, and a hidden label. */}\n    <MyButtonContainer\n      label=\"My Button\"\n      icon=\"ui-icon-person\"\n      showLabel={false}\n    />\n\n    {/* A button with a click event handler. */}\n    <MyButtonContainer label=\"Disable Me\" onClick={onClick} />\n  </section>,\n  document.getElementById('root')\n);\n\n```", "```jsx\n// Adapted from:\n// https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html\nfunction cancellable(promise) {\n  let cancelled = false;\n\n  // Creates a wrapper promise to return. This wrapper is\n  // resolved or rejected based on the wrapped promise, and\n  // on the \"cancelled\" value.\n  const promiseWrapper = new Promise((resolve, reject) => {\n    promise.then(\n      value => {\n        return cancelled ? reject({ cancelled: true }) : resolve(value);\n      },\n      error => {\n        return cancelled\n          ? reject({ cancelled: true })\n          : reject(error);\n      }\n    );\n  });\n\n  // Adds a \"cancel()\" method to the promise, for\n  // use by the React component in \"componentWillUnmount()\".\n  promiseWrapper.cancel = function cancel() {\n    cancelled = true;\n  };\n\n  return promiseWrapper;\n}\n\nexport function users(fail) {\n  // Make sure that the returned promise is \"cancellable\", by\n  // wrapping it with \"cancellable()\".\n  return cancellable(\n    new Promise((resolve, reject) => {\n      setTimeout(() => {\n        if (fail) {\n          reject(fail);\n        } else {\n          resolve({\n            users: [\n              { id: 0, name: 'First' },\n              { id: 1, name: 'Second' },\n              { id: 2, name: 'Third' }\n            ]\n          });\n        }\n      }, 4000);\n    })\n  );\n}\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\nimport { render } from 'react-dom';\n\nimport { users } from './api';\nimport UserList from './UserList';\n\n// When the \"cancel\" link is clicked, we want to render\n// a new element in \"#app\". This will unmount the\n// \"<UserListContainer>\" component.\nconst onClickCancel = e => {\n  e.preventDefault();\n\n  render(<p>Cancelled</p>, document.getElementById('root'));\n};\n\nexport default class UserListContainer extends Component {\n  state = {\n    data: fromJS({\n      error: null,\n      loading: 'loading...',\n      users: []\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  componentDidMount() {\n    // We have to store a reference to any async promises,\n    // so that we can cancel them later when the component\n    // is unmounted.\n    this.job = users();\n\n    this.job.then(\n      result => {\n        this.data = this.data\n          .set('loading', null)\n          .set('error', null)\n          .set('users', fromJS(result.users));\n      },\n\n      // The \"job\" promise is rejected when it's cancelled.\n      // This means that we need to check for the \"cancelled\"\n      // property, because if it's true, this is normal\n      // behavior.\n      error => {\n        if (!error.cancelled) {\n          this.data = this.data\n            .set('loading', null)\n            .set('error', error);\n        }\n      }\n    );\n  }\n\n  // This method is called right before the component\n  // is unmounted. It is here, that we want to make sure\n  // that any asynchronous behavior is cleaned up so that\n  // it doesn't try to interact with an unmounted component.\n  componentWillUnmount() {\n    this.job.cancel();\n  }\n\n  render() {\n    return (\n      <UserList onClickCancel={onClickCancel} {...this.data.toJS()} />\n    );\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport { users } from './api';\nimport UserList from './UserList';\n\nexport default class UserListContainer extends Component {\n  state = {\n    data: fromJS({\n      error: null,\n      loading: 'loading...',\n      users: []\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // When component has been rendered, \"componentDidMount()\"\n  // is called. This is where we should perform asynchronous\n  // behavior that will change the state of the component.\n  // In this case, we're fetching a list of users from\n  // the mock API.\n  componentDidMount() {\n    users(true).then(\n      result => {\n        // Populate the \"users\" state, but also\n        // make sure the \"error\" and \"loading\"\n        // states are cleared.\n        this.data = this.data\n          .set('loading', null)\n          .set('error', null)\n          .set('users', fromJS(result.users));\n      },\n      error => {\n        // When an error occurs, we want to clear\n        // the \"loading\" state and set the \"error\"\n        // state.\n        this.data = this.data\n          .set('loading', null)\n          .set('error', error);\n      }\n    );\n  }\n\n  render() {\n    // If the error state has a string value in it, it\n    // means that something went wrong during the asynchronous\n    // data fetching for this component. You can just throw an\n    // error using this string instead of rendering.\n    if (this.data.get('error') !== null) {\n      throw new Error(this.data.get('error'));\n    }\n    return <UserList {...this.data.toJS()} />;\n  }\n}\n```", "```jsx\ncomponentDidMount() {\n  users(true).then(\n    ...\n```", "```jsx\nif (this.data.get('error') !== null) {\n  throw new Error(this.data.get('error'));\n}\n```", "```jsx\nimport React, { Component } from 'react';\n\n// A basic error boundary used to display error messages.\nexport default class ErrorBoundary extends Component {\n  state = {\n    error: null\n  };\n\n  // This lifecycle method is only called if a component\n  // lower in the tree than this component throws an error.\n  // You can handle the error however you like in this method,\n  // including setting it as a state value so that it can be used\n  // for rendering.\n  componentDidCatch(error) {\n    this.setState({ error });\n  }\n\n  // If there's no error, you can just render the boundary's\n  // children as usual. If there's an error, you can render\n  // the error message while ignoring the child components.\n  render() {\n    if (this.state.error === null) {\n      return this.props.children;\n    } else {\n      return <strong>{this.state.error.toString()}</strong>;\n    }\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport ErrorBoundary from './ErrorBoundary';\nimport UserListContainer from './UserListContainer';\n\n// The <ErrorBoundary> component can wrap any component you need.\n// You can also create different error boundary components that\n// render errors differently.\nrender(\n  <ErrorBoundary>\n    <UserListContainer />\n  </ErrorBoundary>,\n  document.getElementById('root')\n);\n```", "```jsx\nimport React from 'react';\nimport { Map } from 'immutable';\n\n// This component displays the passed-in \"loading\"\n// property as italic text. If it's null, then\n// nothing is rendered.\nconst LoadingMessage = ({ loading }) =>\n  Map([[null, null]]).get(loading, <em>{loading}</em>);\n\nexport default ({\n  error, // eslint-disable-line react/prop-types\n  loading, // eslint-disable-line react/prop-types\n  users // eslint-disable-line react/prop-types\n}) => (\n  <section>\n    {/* Displays any loading messages, while\n         waiting for the API... */}\n    <LoadingMessage loading={loading} />\n\n    {/* Attempts to render the user list but throws an\n        error by attempting to call toUpperCase() on a number. */}\n    <ul>\n      {users.map(i => <li key={i.id.toUpperCase()}>{i.name}</li>)}\n    </ul>\n  </section>\n);\n```"]