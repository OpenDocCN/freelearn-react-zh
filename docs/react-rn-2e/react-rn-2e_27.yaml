- en: Test Your Knowledge Answers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识答案
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: What is a declarative UI structure and how does React support this idea?
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明式UI结构是什么，React如何支持这个想法？
- en: '**Declarative UI structures define what the UI component is instead of worrying
    about how it is defined. React supports this idea by allowing components to be
    declared using JSX syntax.**'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**声明式UI结构定义了UI组件是什么，而不是担心它是如何定义的。React通过允许使用JSX语法声明组件来支持这个想法。**'
- en: How does React improve rendering performance?
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React如何提高渲染性能？
- en: '**React has a virtual DOM that compares changes made to components'' data in
    memory, avoiding the browser DOM when possible. React 16 has a new internal architecture
    that allows rendering to be split up into smaller chunks of work and prioritized.**'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**React具有虚拟DOM，它比较内存中组件数据的更改，尽量避免浏览器DOM。React 16具有新的内部架构，允许将渲染分成更小的工作块并优先处理。**'
- en: When would you render a fragment?
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时会渲染片段？
- en: '**Fragments are used to avoid having to render unnecessary DOM elements**'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**片段用于避免渲染不必要的DOM元素**'
- en: Chapter 2
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: Can you use all of the standard HTML tags as JSX elements?
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将所有标准HTML标签用作JSX元素吗？
- en: '**Yes, React supports this out of the box**'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的，React默认支持这一点**'
- en: How do you access child elements from your component?
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从组件中访问子元素？
- en: '**Child JSX elements are always accessible via the `children` property**'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过 `children` 属性始终可以访问子JSX元素**'
- en: What does the `Fragment` component from React do?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React中的 `Fragment` 组件是做什么的？
- en: '**It acts as a container component by negating the need to render pointless
    elements, such as container divs**'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它作为一个容器组件，通过 否定 渲染无意义的元素， 如 容器divs**'
- en: Chapter 3
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: Why is it always a good idea to initialize the state of a component?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么总是初始化组件的状态是一个好主意？
- en: '**Because if the** `render()` **method expects state values, you need to make
    sure they''re always there to avoid unexpected rendering behavior.**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为如果 `render()` 方法期望状态值，您需要确保它们始终存在，以避免意外的渲染行为。**'
- en: When should you use properties instead of state?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用属性而不是状态？
- en: '**State should only be used for values that can change. For everything else,
    properties should be used.**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**状态应该只用于可以改变的值。对于其他所有情况，应该使用属性。**'
- en: What is a context in React?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中什么是上下文？
- en: '**Context is used to avoid transient properties. Contexts are used to share
    common data with a select number of components.**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**上下文用于避免瞬态属性。上下文用于与少数组件共享常见数据。**'
- en: Chapter 4
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: What makes event handlers in React declarative?
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中，事件处理程序是什么使得它声明式的？
- en: '**React event handlers are declared as part of the component JSX**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**React事件处理程序被声明为组件JSX的一部分**'
- en: What's a common use of higher-order event handler functions?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高阶事件处理程序函数的常见用途是什么？
- en: '**When you have several components that handle the same event, you can use
    a higher-order function to bind the ID of the item being clicked to the handler
    function**'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当您有多个处理相同事件的组件时，可以使用高阶函数将被点击的项目的ID绑定到处理程序函数**'
- en: Can you pass inline functions to event properties?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将内联函数传递给事件属性吗？
- en: '**Yes. This is preferable when event handlers are simple one-liners.**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的。当事件处理程序很简单时，这是更可取的。**'
- en: Why does React use pools of event instances instead of creating new instances
    with each event?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么React使用事件实例池而不是在每个事件中创建新实例？
- en: '**To avoid invoking the garbage collector to delete unused event instances
    when lots of events are fired in a small amount of time**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为了避免在 短时间内 触发大量事件时调用垃圾收集器来删除未使用的事件实例**'
- en: Chapter 5
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Why should monolithic React components be avoided?
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该避免庞大的React组件？
- en: '**Because they''re difficult to comprehend, and difficult to refactor into
    smaller reusable components later on.**'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为它们难以理解，并且难以重构为以后可重用的较小组件。**'
- en: Why should you make components functional?
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该使组件功能化？
- en: '**Functional components only rely on property values that are passed to it.
    They don''t rely on state or lifecycle methods, both potential problem sources.**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**功能组件只依赖于传递给它的属性值。它们不依赖于状态或生命周期方法，这两者都是潜在的问题来源。**'
- en: How do render props simplify React apps?
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染道具如何简化React应用程序？
- en: '**They reduce the number of direct dependencies that a component has, allowing
    you to compose new behavior.**'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它们减少了组件的直接依赖数量，使您能够组合新的行为。**'
- en: Chapter 6
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Is `render()` a lifecycle method?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render()`是一个生命周期方法吗？'
- en: '**Yes, `render()` is no different from any other lifecycle method.**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的，`render()`与任何其他生命周期方法没有区别。**'
- en: Which of the following is a valid use of the `componentWillUnmount()` method?
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是`componentWillUnmount()`方法的有效用途？
- en: '**To cancel an asynchronous action that will fail if the component us unmounted.**'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**取消异步操作，如果组件未挂载则会失败。**'
- en: Which lifecycle method is used by an error boundary component?
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误边界组件使用哪个生命周期方法？
- en: '`**componentDidCatch()**`'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**componentDidCatch()**`'
- en: Chapter 7
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: Which of the following best describes the `prop-types` package?
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项最能描述`prop-types`包？
- en: '**A tool to validate prop values that are passed to components during development.**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用于在开发过程中验证传递给组件的属性值。**'
- en: How do you validate that a property value is something that can be rendered?
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何验证属性值是否可以被渲染？
- en: '**Use the** `PropTypes.node `**validator.**'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用`PropTypes.node`验证器。**'
- en: What is the purpose of the `PropTypes.shape` validator?
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PropTypes.shape`验证器的目的是什么？'
- en: '**To make sure that an object has certain properties with certain types, ignoring
    any additional properties.**'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确保对象具有特定类型的特定属性，忽略任何额外的属性。**'
- en: Chapter 8
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: When should you inherit component state?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该继承组件状态？
- en: '**Only when you have many different components that all share the same state
    structure, but render different output**'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**只有当你有许多不同的组件都共享相同的状态结构，但渲染不同的输出时**'
- en: What is a higher-order component?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是高阶组件？
- en: '**A component that returns another component**'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**返回另一个组件的组件**'
- en: If you inherit JSX from a component, what should you override?
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你从一个组件继承JSX，你应该覆盖什么？
- en: '**You can pass new state values to the inherited component in **`componentDidMount()`**.**'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你可以在`componentDidMount()`中向继承的组件传递新的状态值。**'
- en: Chapter 9
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: The `react-router` package is the official package used for routing in React
    apps and therefore, the only option.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`react-router`包是React应用程序中路由的官方包，因此是唯一的选择。'
- en: '**No,** `react-router` **is the de facto routing solution for React and you
    should use it unless you have a strong reason not to.**'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不，`react-router`是React的事实上的路由解决方案，除非你有充分的理由不使用它。**'
- en: What's the difference between Route and Router components?
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Route`和`Router`组件之间有什么区别？'
- en: '**A** `Route` **is used to render components based on URL matches and a Router is
    used to declare route-component mappings.**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Route`用于根据URL匹配渲染组件，`Router`用于声明路由-组件映射。**'
- en: How do you change only certain parts of the UI as the route changes?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在路由更改时仅更改UI的某些部分？
- en: '**You use** `Route` **components to render content that is specific to any
    given section, based on the provided path property. You can have more than one Route with
    the same path value.**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您可以使用`Route`组件根据提供的`path`属性渲染特定于任何给定部分的内容。您可以有多个具有相同`path`值的`Route`。**'
- en: When should you use the `NavLink` component?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`NavLink`组件？
- en: '**When you want to use the** `activeStyle`** or **`activeClassName`** properties
    to style active links**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当您想要使用`activeStyle`或`activeClassName`属性来为活动链接设置样式时**'
- en: How do you get values from URL paths?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从URL路径中获取值？
- en: '**You use the**` : `**syntax to specify that this is a variable and** `react-router `**will
    pass this value into your component as a property**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您可以使用`: `语法来指定这是一个变量，`react-router`将将此值作为属性传递给您的组件**'
- en: Chapter 10
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: What is the difference between the `render()` function from `react-dom` and
    the `renderToString()` function from `react-dom/server`?
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`react-dom`中的`render()`函数和`react-dom/server`中的`renderToString()`函数之间有什么区别？'
- en: '**The `render()` function is only used to sync React component content with
    the DOM in a browser. The `renderToString()` function doesn''t require a DOM because
    it renders markup as a string.**'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`render()`函数仅用于在浏览器中将React组件内容与DOM同步。`renderToString()`函数不需要DOM，因为它将标记呈现为字符串。**'
- en: 'Routing on the server is necessary because:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端的路由是必要的，因为：
- en: '**The router on the server will determine that content is rendered based on
    the requested URL. This content is then sent to the browser so that the user perceives
    a faster load time.**'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器上的路由将根据请求的URL确定渲染的内容。然后将此内容发送到浏览器，以便用户感知更快的加载时间。**'
- en: What function should you use when reconciling server-rendered React markup with
    React components in the browser?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在协调服务器端渲染的React标记与浏览器中的React组件时应该使用哪个函数？
- en: '**Always use** `hydrate() `**when the server sends rendered React** **components.
    Unlike** `render()`, `hydrate()` **expects rendered** **component markup and can
    handle it efficiently.**'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当服务器发送渲染的React组件时，始终使用`hydrate()`。与`render()`不同，`hydrate()`期望渲染的组件标记并且可以有效地处理它。**'
- en: Chapter 11
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: Why should React developers consider the mobile-first approach to designing
    their applications?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么React开发人员应该考虑移动优先的方法来设计他们的应用程序？
- en: '**Because targeting mobile devices as the primary display for your application
    ensures that you can handle mobile devices and scaling up to larger devices is
    easier than the other way around.**'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为将移动设备作为应用程序的主要显示目标可以确保您可以处理移动设备，并且向更大的设备进行扩展比反之容易。**'
- en: Does `react-router` integrate well with `react-bootstrap`?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`react-router`与`react-bootstrap`集成良好吗？'
- en: '**Yes. Although you''ll want to use the **`react-router-bootstrap`** package
    to make sure that you can add links to the**` NavItem`** and **`MenuItem `**components.**'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的。尽管您可能希望使用`react-router-bootstrap`包，以确保您可以将链接添加到`NavItem`和`MenuItem`组件中。**'
- en: How would you go about rendering lists of items using `react-bootstrap`?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用`react-bootstrap`渲染项目列表？
- en: '**Use **`ListGroup `**and **`ListGroupItem `**components from react-bootstrap.**'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`react-bootstrap`中的`ListGroup`和`ListGroupItem`组件。
- en: Why should you create an abstraction for `react-bootstrap` form components?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该为`react-bootstrap`表单组件创建一个抽象？
- en: '**Because there are many related components that you need to use for basic
    inputs and creating this abstraction makes life easier.**'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为有许多相关的组件需要用于基本输入，创建这种抽象会让生活更容易。**'
- en: Chapter 12
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: What is the primary goal of React Native?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native的主要目标是什么？
- en: '**To make it easy for React developers to apply what they already know about
    building UI components to building native mobile apps.**'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让React开发人员能够将他们已经了解的构建UI组件的知识应用到构建原生移动应用程序中。**'
- en: Does React Native provide the exact same experience on iOS and Android?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native在iOS和Android上提供完全相同的体验吗？
- en: '**No, iOS and Android have fundamentally different user experiences.**'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不，iOS和Android有根本不同的用户体验。**'
- en: Does React Native remove the need for mobile web apps?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native是否消除了移动Web应用的需求？
- en: '**No, there will always be a need for mobile web apps. React Native is there
    for you when you have demand for a native mobile app.**'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不，移动Web应用程序始终需要。当您需要原生移动应用程序时，React Native就在那里为您。**'
- en: Chapter 13
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: The `create-react-native-app` tool was created by Facebook
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`create-react-native-app`**工具是由Facebook创建的'
- en: '**No, this is a community-supported tool that follows in the footsteps of **`create-react-app`'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不，这是一个社区支持的工具，跟随** `create-react-app` **的脚步**'
- en: Why should you install `create-react-native-app` globally?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该全局安装**`create-react-native-app`**？
- en: '**Because this is a tool for generating project boilerplate and isn''t actually
    part of the project**'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为这是一个用于生成项目样板的工具，实际上并不是项目的一部分**'
- en: What's the role of the Expo app on mobile devices?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Expo应用在移动设备上的作用是什么？
- en: '**It''s a tool that helps developers run their apps on mobile devices during
    development with very little overhead**'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这是一个帮助开发人员在开发过程中在移动设备上运行其应用程序的工具，开销非常小**'
- en: The React Native packager is able to simulate both iOS and Android devices
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native打包程序能够模拟iOS和Android设备
- en: '**It doesn''t do this, but it communicates with iOS and Android simulators
    in order to run the app**'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它不会这样做，但它会与iOS和Android模拟器通信以运行应用程序**'
- en: Chapter 14
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: What's the difference between CSS styles and styles used with React Native components?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSS样式和React Native组件使用的样式有什么区别？
- en: '**React Native shares many style properties with CSS. Style properties are
    expressed as plain object properties in React Native**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**React Native与CSS共享许多样式属性。样式属性在React Native中表示为普通对象属性**'
- en: Why do you need to consider the status bar when designing your layout?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在设计布局时需要考虑状态栏？
- en: '**Because the status bar can interfere with your components on iOS**'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为状态栏可能会干扰iOS上的组件**'
- en: What is the flexbox model?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是flexbox模型？
- en: '**The flexbox layout model is used to lay out components in a way that abstracts
    away many small details and automatically flexes in response to layout changes**'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**flexbox布局模型用于以一种抽象许多细节并自动对布局更改做出灵活响应的方式来布局组件**'
- en: Is screen orientation a factor when considering your layout options?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑布局选项时，屏幕方向是否是一个因素？
- en: '**Yes, you always need to make sure there are no surprises in portrait or landscape
    orientation during development**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的，在开发过程中，始终需要确保在纵向或横向方向上没有意外情况**'
- en: Chapter 15
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: What's the main difference between navigation in React web apps and React Native
    apps?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React web应用和React Native应用中导航的主要区别是什么？
- en: '**Web applications rely on URLs as the central concept for moving around. Native
    apps have no such concept, so it''s up to the developer and the navigation libs
    they use to manage their screens.**'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Web应用程序依赖于URL作为移动的中心概念。原生应用程序没有这样的概念，因此由开发人员和他们使用的导航库来管理他们的屏幕。**'
- en: What function should be used to navigate to a new screen?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用什么函数来导航到新屏幕？
- en: '**Screen components are passed a navigation property. You should** **use** `navigation.navigate()` **to
    move to another screen.**'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**屏幕组件会传递一个导航属性。您应该** **使用** `navigation.navigate()` **来移动到另一个屏幕。**'
- en: Does react-navigation handle back button functionality for you?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: react-navigation是否为您处理返回按钮功能？
- en: '**Yes. Including the built-in back button on Android systems.**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的。包括Android系统上的内置返回按钮。**'
- en: How do you pass data to screens?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将数据传递给屏幕？
- en: '**You can pass a plain object as the second argument to** `navigation.navigate()`.
    **The properties are then accessible to the screen via** `navigation.getParam()`.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您可以将普通对象作为第二个参数传递给** `navigation.navigate()`。 **然后，通过** `navigation.getParam()`
    **可以访问这些属性。**'
- en: Chapter 16
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: What type of data can the `FlatList` component render?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`FlatList`**组件可以呈现什么类型的数据？'
- en: '**The `FlatList` expects an array of objects. The `renderItem` property takes
    a function that is responsible for rendering each item.**'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`FlatList`期望一个对象数组。`renderItem`属性接受一个负责渲染每个项目的函数。**'
- en: Why is the `key` property a requirement for each data item that's passed to `FlatList`?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`key`属性是传递给`FlatList`的每个数据项的要求？
- en: '**So that the list can do efficient equality checks that help with the rendering
    performance during list data updates.**'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这样列表可以进行有效的相等性检查，有助于在列表数据更新期间提高渲染性能。**'
- en: How do you render list controls that stay in a fixed position during scrolling?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何渲染在滚动期间保持固定位置的列表控件？
- en: '**You can use the** `ListHeaderComponent `**property of** `FlatList`.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您可以使用`FlatList`的`ListHeaderComponent`属性。**'
- en: How to you lazily load more data as the user scrolls through your list?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户滚动列表时，如何懒加载更多数据？
- en: '**You can provide a function to the `onEndReached` property of `FlatList`.
    This is called when the user nears the end of the list and the function can populate
    the list data with more data.**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您可以为`FlatList`的`onEndReached`属性提供一个函数。当用户接近列表的末尾时，将调用此函数，并且该函数可以使用更多数据填充列表数据。**'
- en: Chapter 17
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: What's the difference between a progress bar and an activity indicator?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进度条和活动指示器有什么区别？
- en: '**A progress bar is determinate whereas a progress indicator is used to indicate
    an indeterminate amount of time.**'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进度条是确定的，而进度指示器用于指示不确定的时间量。**'
- en: Does the React Native `ActivityIndicator` component work the same on iOS and
    Android?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native的`ActivityIndicator`组件在iOS和Android上是否工作相同？
- en: '**Yes, this component is platform agnostic.**'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的，这个组件是平台无关的。**'
- en: How can you use the `ProgressViewIOS` and the `ProgressBarAndroid` components
    in a platform agnostic way?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何以平台无关的方式使用`ProgressViewIOS`和`ProgressBarAndroid`组件？
- en: '**You can define your own `ProgressBar` component that imports other components
    with platform-specific file extensions.**'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您可以定义自己的`ProgressBar`组件，导入具有特定于平台的文件扩展名的其他组件。**'
- en: Chapter 18
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章
- en: The geolocation API found in React Native works the same way as the geolocation
    API found in web browsers.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React Native中找到的地理位置API的工作方式与Web浏览器中找到的地理位置API相同。
- en: '**Yes, it''s the same API.**'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的，它是相同的API。**'
- en: What is the main purpose of the geolocation API in React Native applications?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native应用程序中地理位置API的主要目的是什么？
- en: '**To find the latitude and longitude coordinates of the devices and use those
    values with other APIs to look up useful information such as addresses.**'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找设备的纬度和经度坐标，并将这些值与其他API一起使用，以查找有用信息，比如地址。**'
- en: Can the `MapView` component show points of interest near the user?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MapView`组件能够显示用户附近的兴趣点吗？'
- en: '**Yes, this is enabled by default.**'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是的，默认情况下已启用。**'
- en: How do you plot points on maps?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在地图上标记点？
- en: '**By passing latitude/longitude array data to the `MapView` component as a
    property.**'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过将纬度/经度数组数据作为属性传递给`MapView`组件。**'
- en: Chapter 19
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章
- en: Why would you want to change the return key on the virtual keyboard for text
    inputs?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要更改文本输入的虚拟键盘上的返回键？
- en: '**Because in some cases, it makes sense to have a search button or something
    else that better matches the context of the input**'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为在某些情况下，有一个搜索按钮或其他更符合输入上下文的东西是有意义的**'
- en: Which `TextInput` property should be used to mark the input as a password field?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个`TextInput`属性将输入标记为密码字段？
- en: '`**secureTextEntry**`'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**secureTextEntry**`'
- en: Why should you create an abstraction for selection elements?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要为选择元素创建抽象？
- en: '**Because of styling challenges between the two platforms**'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**由于两个平台之间的样式挑战**'
- en: Why should you create abstraction for date and time pickers?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要为日期和时间选择器创建抽象？
- en: '**Because the components are completely different for iOS and Android**'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因为iOS和Android的组件完全不同**'
- en: Chapter 20
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章
- en: What's the difference between an alert and a modal?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报和模态之间有什么区别？
- en: '**Alerts are good at inheriting the look and feel of the mobile environment
    whereas modals are regular React Native views that you have total stylistic control
    over.**'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报在继承移动环境的外观和感觉方面做得很好，而模态是常规的React Native视图，您可以完全控制其样式。
- en: Which React Native component can be used to create a modal view that overlays
    other components on the screen?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个React Native组件可用于创建覆盖屏幕上其他组件的模态视图？
- en: '**The **`Modal `**component**.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Modal`组件。'
- en: What's the best way to display passive notifications on Android systems?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android系统上显示被动通知的最佳方法是什么？
- en: '**You can use the **`ToastAndroid `**React Native API. There''s no good alternative
    on iOS that doesn''t involve rolling your own code.**'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`ToastAndroid` React Native API。在iOS上没有不涉及自己编写代码的好的替代方法。
- en: The React Native Alert API is only available on iOS.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native Alert API仅在iOS上可用。
- en: '**False**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Chapter 21
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章
- en: What's the main difference between user interactions with web applications and
    native mobile applications?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web应用程序和本机移动应用程序之间用户交互的主要区别是什么？
- en: '**There is no mouse. Instead, the user interacts with your UI using their fingers.
    This is a fundamentally different experience than using a mouse and needs to be
    accommodated.**'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有鼠标。相反，用户使用手指与您的UI进行交互。这是一种根本不同于使用鼠标的体验，需要进行调整。
- en: How do you provide the user with touch feedback in React Native?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在React Native中为用户提供触摸反馈？
- en: '**By wrapping touchable components with** **the** `TouchableOpacity `**or** `TouchableHighlight `**component.**'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`TouchableOpacity`或`TouchableHighlight`组件包装可触摸组件。
- en: What makes scrolling in mobile apps so much more complex than web app scrolling?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动应用程序中的滚动比Web应用程序中的滚动复杂得多的原因是什么？
- en: '**Scrolling in mobile web apps needs to take into consideration things like
    velocity because the user is interacting with their fingers. Otherwise, the interactions
    feel unnatural.**'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移动Web应用程序中滚动需要考虑诸如速度之类的因素，因为用户是用手指进行交互的。否则，交互会感觉不自然。
- en: Why would you use the `ScrollView` component to implement swipeable behavior?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用`ScrollView`组件来实现可滑动行为？
- en: '**Because this is what users are used to in mobile web applications and how
    they learn the controls of the UI.**'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为这是用户在移动Web应用程序中习惯的，以及他们学习UI控件的方式。
- en: Chapter 22
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第22章
- en: What types of values does the `source` property of the `Image` component accept?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Image`组件的`source`属性接受哪些类型的值？'
- en: Image components accept paths to local files and remote image URLs.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像组件接受本地文件和远程图像URL的路径。
- en: What should you use as a placeholder while images load?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像加载时应该使用什么作为占位符？
- en: '**You should use a placeholder image that makes sense for the context where
    the image is used.**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该使用在图像使用的上下文中有意义的占位图像。
- en: How can you scale an image using the `Image` component?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用`Image`组件缩放图像？
- en: '**By setting the** `width `**and the** `height `**property,** **the** `Image `**component
    will automatically handle scaling the image for you.**'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置`width`和`height`属性，`Image`组件将自动处理图像的缩放。
- en: Is it worth installing the `react-native-vector-icons` package for your app?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`react-native-vector-icons`包值得吗？
- en: '**Yes, this package makes thousands of icons available to your app and icons
    are an important tool for communicating intent to users.**'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，这个包为您的应用程序提供了数千个图标，并且图标是向用户传达意图的重要工具。
- en: Chapter 23
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章
- en: Why are operations in the `AsyncStorage` API asynchronous?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`AsyncStorage` API中的操作是异步的？
- en: '**To avoid interfering with the responsiveness of the UI.**'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免干扰UI的响应性。
- en: Which `AsyncStorage` API would you use to look up several items at once?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个`AsyncStorage` API来一次查找多个项目？
- en: '**A combination of `AsyncStorage.getAllKeys()` and `AsyncStorage.multiGet()`.**'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AsyncStorage.getAllKeys()`和`AsyncStorage.multiGet()`的组合。'
- en: How do you get the connectivity status of the device in a React Native application?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React Native应用程序中，如何获取设备的连接状态？
- en: '**You call `NetInfo.getConnectionInfo()` and read the resulting connection
    type.**'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您调用`NetInfo.getConnectionInfo()`并读取生成的连接类型。
- en: How do you respond to a change in connectivity status in a React Native application?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React Native应用程序中如何响应连接状态的变化？
- en: '**You can listen to the `connectionChange` event by calling `NetInfo.addEventListener(''connectionChange'',
    ...)`.**'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过调用`NetInfo.addEventListener('connectionChange', ...)`来监听`connectionChange`事件。
- en: Chapter 24
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章
- en: Which of the following best describes Flux?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项最能描述Flux？
- en: '**Flux is an architectural pattern used to control the unidirectional flow
    of data in your app, making changes more predictable.**'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flux是一种用于控制应用程序中数据单向流动的架构模式，使变化更加可预测。
- en: What's the difference between Flux and Redux?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flux和Redux之间有什么区别？
- en: '**Redux is an opinionated implementation of Flux concepts that you can use
    to help manage data flow in your application.**'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux是Flux概念的一种有偏见的实现，您可以使用它来帮助管理应用程序中的数据流。
- en: How do you get data from a Redux store into your components?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将Redux存储中的数据传递到您的组件中？
- en: '**You use the` connect()` higher-order function to connection your component
    to the store, using a function that translates store data into component properties.**'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`connect()`高阶函数将您的组件连接到存储，使用一个将存储数据转换为组件属性的函数。
- en: What's the difference between Redux in a web app and a native mobile app?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redux在Web应用程序和原生移动应用程序中有什么区别？
- en: '**There is no difference.**'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有区别。
- en: Chapter 25
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第25章
- en: What's the difference between Relay and other Flux inspired libraries like Redux?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Relay和其他受Flux启发的库（如Redux）之间有什么区别？
- en: '**Relay helps scale your Flux architecture by allowing data dependency declarations
    and hiding all of the server communication complexity.**'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Relay通过允许数据依赖声明并隐藏所有服务器通信复杂性来帮助扩展您的Flux架构。
- en: How does Relay simplify the data requirements of React components?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Relay如何简化React组件的数据需求？
- en: '**By colocating the data dependency queries, you can see exactly what data
    your components use without having to sift through code that does the fetching.**'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过合并数据依赖查询，您可以准确地看到您的组件使用的所有数据，而无需查看执行获取操作的代码。
- en: How do your React components communicate with the server in a Relay based application?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于Relay的应用程序中，您的React组件如何与服务器通信？
- en: '**Relay compiles the GraphQL queries that it finds in your components and handles
    all of the GraphQL server communication for you, including caching optimizations.**'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Relay编译在您的组件中找到的GraphQL查询，并为您处理所有的GraphQL服务器通信，包括缓存优化。
