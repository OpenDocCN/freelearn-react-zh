["```jsx\nimport React, { Component } from 'react';\nimport { Text, View, NetInfo } from 'react-native';\nimport { fromJS } from 'immutable';\n\nimport styles from './styles';\n\n// Maps the state returned from \"NetInfo\" to\n// a string that we want to display in the UI.\nconst connectedMap = {\n  none: 'Disconnected',\n  unknown: 'Disconnected',\n  wifi: 'Connected',\n  cell: 'Connected',\n  mobile: 'Connected'\n};\n\nexport default class NetworkState extends Component {\n  // The \"connected\" state is a simple\n  // string that stores the state of the\n  // network.\n  state = {\n    data: fromJS({\n      connected: ''\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // When the network state changes, use the\n  // \"connectedMap\" to find the string to display.\n  onNetworkChange = connection => {\n    this.data = this.data.set(\n      'connected',\n      connectedMap[connection.type]\n    );\n  };\n\n  // When the component is mounted, we add a listener\n  // that changes the \"connected\" state when the\n  // network state changes.\n  componentDidMount() {\n    NetInfo.addEventListener(\n      'connectionChange',\n      this.onNetworkChange\n    );\n  }\n\n  // Make sure the listener is removed...\n  componentWillUnmount() {\n    NetInfo.removeEventListener(\n      'connectionChange',\n      this.onNetworkChange\n    );\n  }\n\n  // Simply renders the \"connected\" state as\n  // it changes.\n  render() {\n    return (\n      <View style={styles.container}>\n        <Text>{this.data.get('connected')}</Text>\n      </View>\n    );\n  }\n} \n```", "```jsx\nimport React, { Component } from 'react';\nimport {\n  Text,\n  TextInput,\n  View,\n  FlatList,\n  AsyncStorage\n} from 'react-native';\nimport { fromJS } from 'immutable';\n\nimport styles from './styles';\nimport Button from './Button';\n\nexport default class StoringData extends Component {\n  // The initial state of this component\n  // consists of the current \"key\" and \"value\"\n  // that the user is entering. It also has\n  // a \"source\" for the list view to display\n  // everything that's been stored.\n  state = {\n    data: fromJS({\n      key: null,\n      value: null,\n      source: []\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // Uses \"AsyncStorage.setItem()\" to store\n  // the current \"key\" and \"value\" states.\n  // When this completes, we can delete\n  // \"key\" and \"value\" and reload the item list.\n  setItem = () =>\n    AsyncStorage.setItem(this.data.get('key'), this.data.get('value'))\n      .then(() => {\n        this.data = this.data.delete('key').delete('value');\n      })\n      .then(() => this.loadItems());\n\n  // Uses \"AsyncStorage.clear()\" to empty any stored\n  // values. Then, it loads the empty list of\n  // items to clear the item list on the screen.\n  clearItems = () =>\n    AsyncStorage.clear().then(() => this.loadItems());\n\n  // This method is async because awaits on the\n  // data store keys and values, which are two\n  // dependent async calls.\n  async loadItems() {\n    const keys = await AsyncStorage.getAllKeys();\n    const values = await AsyncStorage.multiGet(keys);\n\n    this.data = this.data.set('source', fromJS(values));\n  }\n\n  // Load any existing items that have\n  // already been stored when the app starts.\n  componentDidMount() {\n    this.loadItems();\n  }\n\n  render() {\n    // The state that we need...\n    const { source, key, value } = this.data.toJS();\n\n    return (\n      <View style={styles.container}>\n        <Text>Key:</Text>\n        <TextInput\n          style={styles.input}\n          value={key}\n          onChangeText={v => {\n            this.data = this.data.set('key', v);\n          }}\n        />\n        <Text>Value:</Text>\n        <TextInput\n          style={styles.input}\n          value={value}\n          onChangeText={v => {\n            this.data = this.data.set('value', v);\n          }}\n        />\n        <View style={styles.controls}>\n          <Button label=\"Add\" onPress={this.setItem} />\n          <Button label=\"Clear\" onPress={this.clearItems} />\n        </View>\n        <View style={styles.list}>\n          <FlatList\n            data={source.map(([key, value]) => ({\n              key: key.toString(),\n              value\n            }))}\n            renderItem={({ item: { value, key } }) => (\n              <Text>\n                {value} ({key})\n              </Text>\n            )}\n          />\n        </View>\n      </View>\n    );\n  }\n} \n```", "```jsx\nimport { NetInfo, AsyncStorage } from 'react-native';\nimport { Map as ImmutableMap } from 'immutable';\n\n// Mock data that would otherwise come from a real\n// networked API endpoint.\nconst fakeNetworkData = {\n  first: false,\n  second: false,\n  third: false\n};\n\n// We'll assume that the device isn't \"connected\"\n// by default.\nlet connected = false;\n\n// There's nothing to sync yet...\nconst unsynced = [];\n\n// Sets the given \"key\" and \"value\". The idea\n// is that application that uses this function\n// shouldn't care if the network is connected\n// or not.\nexport const set = (key, value) =>\n  // The returned promise resolves to true\n  // if the network is connected, false otherwise.\n  new Promise((resolve, reject) => {\n    if (connected) {\n      // We're online - make the proper request (or fake\n      // it in this case) and resolve the promise.\n      fakeNetworkData[key] = value;\n      resolve(true);\n    } else {\n      // We're offline - save the item using \"AsyncStorage\"\n      // and add the key to \"unsynced\" so that we remember\n      // to sync it when we're back online.\n      AsyncStorage.setItem(key, value.toString()).then(\n        () => {\n          unsynced.push(key);\n          resolve(false);\n        },\n        err => reject(err)\n      );\n    }\n  });\n\n// Gets the given key/value. The idea is that the application\n// shouldn't care whether or not there is a network connection.\n// If we're offline and the item hasn't been synced, read it\n// from local storage.\nexport const get = key =>\n  new Promise((resolve, reject) => {\n    if (connected) {\n      // We're online. Resolve the requested data.\n      resolve(key ? fakeNetworkData[key] : fakeNetworkData);\n    } else if (key) {\n      // We've offline and they're asking for a specific key.\n      // We need to look it up using \"AsyncStorage\".\n      AsyncStorage.getItem(key).then(\n        item => resolve(item),\n        err => reject(err)\n      );\n    } else {\n      // We're offline and they're asking for all values.\n      // So we grab all keys, then all values, then we\n      // resolve a plain JS object.\n      AsyncStorage.getAllKeys().then(\n        keys =>\n          AsyncStorage.multiGet(keys).then(\n            items => resolve(ImmutableMap(items).toJS()),\n            err => reject(err)\n          ),\n        err => reject(err)\n      );\n    }\n  });\n\n// Check the network state when the module first\n// loads so that we have an accurate value for \"connected\".\nNetInfo.getConnectionInfo().then(\n  connection => {\n    connected = ['wifi', 'unknown'].includes(connection.type);\n  },\n  () => {\n    connected = false;\n  }\n);\n\n// Register a handler for when the state of the network changes.\nNetInfo.addEventListener('connectionChange', connection => {\n  // Update the \"connected\" state...\n  connected = ['wifi', 'unknown'].includes(connection.type);\n\n  // If we're online and there's unsynced values,\n  // load them from the store, and call \"set()\"\n  // on each of them.\n  if (connected && unsynced.length) {\n    AsyncStorage.multiGet(unsynced).then(items => {\n      items.forEach(([key, val]) => set(key, val));\n      unsynced.length = 0;\n    });\n  }\n}); \n```", "```jsx\nimport React, { Component } from 'react';\nimport { Text, View, Switch, NetInfo } from 'react-native';\nimport { fromJS } from 'immutable';\n\nimport styles from './styles';\nimport { set, get } from './store';\n\n// Used to provide consistent boolean values\n// for actual booleans and their string representations.\nconst boolMap = {\n  true: true,\n  false: false\n};\n\nexport default class SynchronizingData extends Component {\n  // The message state is used to indicate that\n  // the user has gone offline. The other state\n  // items are things that the user wants to change\n  // and sync.\n  state = {\n    data: fromJS({\n      message: null,\n      first: false,\n      second: false,\n      third: false\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // Generates a handler function bound to a given key.\n  save = key => value => {\n    // Calls \"set()\" and depending on the resolved value,\n    // sets the user message.\n    set(key, value).then(\n      connected => {\n        this.data = this.data\n          .set('message', connected ? null : 'Saved Offline')\n          .set(key, value);\n      },\n      err => {\n        this.data = this.data.set('message', err);\n      }\n    );\n  };\n\n  componentDidMount() {\n    // We have to call \"NetInfo.fetch()\" before\n    // calling \"get()\" to ensure that the\n    // connection state is accurate. This will\n    // get the initial state of each item.\n    NetInfo.getConnectionInfo().then(() =>\n      get().then(\n        items => {\n          this.data = this.data.merge(items);\n        },\n        err => {\n          this.data = this.data.set('message', err);\n        }\n      )\n    );\n  }\n\n  render() {\n    // Bound methods...\n    const { save } = this;\n\n    // State...\n    const { message, first, second, third } = this.data.toJS();\n\n    return (\n      <View style={styles.container}>\n        <Text>{message}</Text>\n        <View>\n          <Text>First</Text>\n          <Switch\n            value={boolMap[first.toString()]}\n            onValueChange={save('first')}\n          />\n        </View>\n        <View>\n          <Text>Second</Text>\n          <Switch\n            value={boolMap[second.toString()]}\n            onValueChange={save('second')}\n          />\n        </View>\n        <View>\n          <Text>Third</Text>\n          <Switch\n            value={boolMap[third.toString()]}\n            onValueChange={save('third')}\n          />\n        </View>\n      </View>\n    );\n  }\n} \n```"]