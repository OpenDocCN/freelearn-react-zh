["```jsx\nimport React, { Component } from 'react';\n\nexport default class MyButton extends Component {\n  // The click event handler, there's nothing much\n  // happening here other than a log of the event.\n  onClick() {\n    console.log('clicked');\n  }\n\n  // Renders a \"<button>\" element with the \"onClick\"\n  // event handler set to the \"onClick()\" method of\n  // this component.\n  render() {\n    return (\n      <button onClick={this.onClick}>{this.props.children}</button>\n    );\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyInput extends Component {\n  // Triggered when the value of the text input changes...\n  onChange() {\n    console.log('changed');\n  }\n\n  // Triggered when the text input loses focus...\n  onBlur() {\n    console.log('blured');\n  }\n\n  // JSX elements can have as many event handler\n  // properties as necessary.\n  render() {\n    return <input onChange={this.onChange} onBlur={this.onBlur} />;\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\n\n// Import the generic event handler that\n// manipulates the state of a component.\nimport reverse from './reverse';\n\nexport default class MyList extends Component {\n  state = {\n    items: ['Angular', 'Ember', 'React']\n  };\n\n  // Makes the generic function specific\n  // to this component by calling \"bind(this)\".\n  onReverseClick = reverse.bind(this);\n\n  render() {\n    const { state: { items }, onReverseClick } = this;\n\n    return (\n      <section>\n        {/* Now we can attach the \"onReverseClick\" handler\n            to the button, and the generic function will\n            work with this component's state. */}\n        <button onClick={onReverseClick}>Reverse</button>\n        <ul>{items.map((v, i) => <li key={i}>{v}</li>)}</ul>\n      </section>\n    );\n  }\n}\n```", "```jsx\n// Exports a generic function that changes the \n// state of a component, causing it to re-render \n// itself.\nexport default function reverse() { \n  this.setState(this.state.items.reverse()); \n} \n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyList from './MyList';\n\n// The items to pass to \"<MyList>\" as a property.\nconst items = [\n  { id: 0, name: 'First' },\n  { id: 1, name: 'Second' },\n  { id: 2, name: 'Third' }\n];\n\n// Renders \"<MyList>\" with an \"items\" property.\nrender(<MyList items={items} />, document.getElementById('root'));\n\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyList extends Component {\n  constructor() {\n    super();\n\n    // We want to make sure that the \"onClick()\"\n    // handler is explicitly bound to this component\n    // as it's context.\n    this.onClick = this.onClick.bind(this);\n  }\n\n  // When a list item is clicked, look up the name\n  // of the item based on the \"id\" argument. This is\n  // why we need access to the component through \"this\",\n  // for the properties.\n  onClick(id) {\n    const { name } = this.props.items.find(i => i.id === id);\n    console.log('clicked', `\"${name}\"`);\n  }\n\n  render() {\n    return (\n      <ul>\n        {/* Creates a new handler function with\n            the bound \"id\" argument. Notice that\n            the context is left as null, since that\n            has already been bound in the\n            constructor. */}\n        {this.props.items.map(({ id, name }) => (\n          <li key={id} onClick={this.onClick.bind(null, id)}>\n            {name}\n          </li>\n        ))}\n      </ul>\n    );\n  }\n}\n```", "```jsx\nimport React, { Fragment, Component } from 'react';\n\nexport default class App extends Component {\n  state = {\n    first: 0,\n    second: 0,\n    third: 0\n  };\n\n  // This function is defined as an arrow function, so \"this\" is\n  // lexically-bound to this component. The name argument is used\n  // by the function that's returned as the event handler in the\n  // computed property name.\n  onClick = name => () => {\n    this.setState(state => ({\n      ...state,\n      [name]: state[name] + 1\n    }));\n  };\n\n  render() {\n    const { first, second, third } = this.state;\n\n    return (\n      <Fragment>\n        {/* By calling this.onClick() and supplying an argument value,\n            you're creating a new event handler function on the fly. \n       */}\n        <button onClick={this.onClick('first')}>First {first}</button>\n        <button onClick={this.onClick('second')}>\n          Second {second}\n        </button>\n        <button onClick={this.onClick('third')}>Third {third}</button>\n      </Fragment>\n    );\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyButton extends Component {\n  // Renders a button element with an \"onClick()\" handler.\n  // This function is declared inline with the JSX, and is\n  // useful in scenarios where you need to call another\n  // function.\n  render() {\n    return (\n      <button onClick={e => console.log('clicked', e)}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\n```", "```jsx\nimport React, { Component } from 'react'; \n\n// Mock function, meant to simulate fetching \n// data asynchronously from an API. \nfunction fetchData() { \n  return new Promise((resolve) => { \n    setTimeout(() => { \n      resolve(); \n    }, 1000); \n  }); \n} \n\nexport default class MyButton extends Component { \n  onClick(e) { \n    // This works fine, we can access the DOM element \n    // through the \"currentTarget\" property. \n    console.log('clicked', e.currentTarget.style); \n\n    fetchData().then(() => { \n      // However, trying to access \"currentTarget\" \n      // asynchronously fails, because it's properties \n      // have all been nullified so that the instance \n      // can be reused. \n      console.log('callback', e.currentTarget.style); \n    }); \n  } \n\n  render() { \n    return ( \n      <button onClick={this.onClick}> \n        {this.props.children} \n      </button> \n    ); \n  } \n} \n```"]