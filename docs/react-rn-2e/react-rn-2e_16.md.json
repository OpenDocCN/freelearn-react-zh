["```jsx\nimport React from 'react';\nimport { Text, View, FlatList } from 'react-native';\n\nimport styles from './styles';\n\nconst data = new Array(100)\n  .fill(null)\n  .map((v, i) => ({ key: i.toString(), value: `Item ${i}` }));\n\nexport default () => (\n  <View style={styles.container}>\n    <FlatList\n      data={data}\n      renderItem={({ item }) => (\n        <Text style={styles.item}>{item.value}</Text>\n      )}\n    />\n  </View>\n); \n```", "```jsx\nimport { StyleSheet } from 'react-native';\n\nexport default StyleSheet.create({\n  container: {\n    // Flexing from top to bottom gives the\n    // container a height, which is necessary\n    // to enable scrollable content.\n    flex: 1,\n    flexDirection: 'column',\n    paddingTop: 20,\n  },\n\n  item: {\n    margin: 5,\n    padding: 5,\n    color: 'slategrey',\n    backgroundColor: 'ghostwhite',\n    textAlign: 'center',\n  },\n}); \n```", "```jsx\nimport React, { Component } from 'react';\n\nimport List from './List';\n\nconst mapItems = items =>\n  items.map((value, i) => ({ key: i.toString(), value }));\n\n// Performs sorting and filtering on the given \"data\".\nconst filterAndSort = (data, text, asc) =>\n  data\n    .filter(\n      i =>\n        // Items that include the filter \"text\" are returned.\n        // Unless the \"text\" argument is an empty string,\n        // then everything is included.\n        text.length === 0 || i.includes(text)\n    )\n    .sort(\n      // Sorts either ascending or descending based on \"asc\".\n      asc\n        ? (a, b) => (b > a ? -1 : a === b ? 0 : 1)\n        : (a, b) => (a > b ? -1 : a === b ? 0 : 1)\n    );\n\nclass ListContainer extends Component {\n  state = {\n    data: filterAndSort(\n      new Array(100).fill(null).map((v, i) => `Item ${i}`),\n      '',\n      true\n    ),\n    asc: true,\n    filter: ''\n  };\n\n  render() {\n    return (\n      <List\n        data={mapItems(this.state.data)}\n        asc={this.state.asc}\n        onFilter={text => {\n          // Updates the \"filter\" state, the actualy filter text,\n          // and the \"source\" of the list. The \"data\" state is\n          // never actually touched - \"filterAndSort()\" doesn't\n          // mutate anything.\n          this.setState({\n            filter: text,\n            data: filterAndSort(this.state.data, text, this.state.asc)\n          });\n        }}\n        onSort={() => {\n          this.setState({\n            // Updates the \"asc\" state in order to change the\n            // order of the list. The same principles as used\n            // in the \"onFilter()\" handler are applied here,\n            // only with diferent arguments passed to\n            // \"filterAndSort()\"\n            asc: !this.state.asc,\n            data: filterAndSort(\n              this.state.data,\n              this.state.filter,\n              !this.state.asc\n            )\n          });\n        }}\n      />\n    );\n  }\n}\n\nexport default ListContainer;\n\n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Text, FlatList } from 'react-native';\n\nimport styles from './styles';\nimport ListControls from './ListControls';\n\nconst List = ({ Controls, data, onFilter, onSort, asc }) => (\n  <FlatList\n    data={data}\n    ListHeaderComponent={<Controls {...{ onFilter, onSort, asc }} />}\n    renderItem={({ item }) => (\n      <Text style={styles.item}>{item.value}</Text>\n    )}\n  />\n);\n\nList.propTypes = {\n  Controls: PropTypes.func.isRequired,\n  data: PropTypes.array.isRequired,\n  onFilter: PropTypes.func.isRequired,\n  onSort: PropTypes.func.isRequired,\n  asc: PropTypes.bool.isRequired\n};\n\nList.defaultProps = {\n  Controls: ListControls\n};\n\nexport default List; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { View } from 'react-native';\n\nimport styles from './styles';\nimport ListFilter from './ListFilter';\nimport ListSort from './ListSort';\n\n// Renders the \"<ListFilter>\" and \"<ListSort>\"\n// components within a \"<View>\". The\n// \"styles.controls\" style lays out the controls\n// horizontally.\nconst ListControls = ({ onFilter, onSort, asc }) => (\n  <View style={styles.controls}>\n    <ListFilter onFilter={onFilter} />\n    <ListSort onSort={onSort} asc={asc} />\n  </View>\n);\n\nListControls.propTypes = {\n  onFilter: PropTypes.func.isRequired,\n  onSort: PropTypes.func.isRequired,\n  asc: PropTypes.bool.isRequired\n};\n\nexport default ListControls; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { View, TextInput } from 'react-native';\n\nimport styles from './styles';\n\n// Renders a \"<TextInput>\" component which allows the\n// user to type in their filter text. This causes\n// the \"onFilter()\" event handler to be called.\n// This handler comes from \"ListContainer\" and changes\n// the state of the list data source.\nconst ListFilter = ({ onFilter }) => (\n  <View>\n    <TextInput\n      autoFocus\n      placeholder=\"Search\"\n      style={styles.filter}\n      onChangeText={onFilter}\n    />\n  </View>\n);\n\nListFilter.propTypes = {\n  onFilter: PropTypes.func.isRequired\n};\n\nexport default ListFilter; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Text } from 'react-native';\n\n// The arrows to render based on the state of\n// the \"asc\" property. Using a Map let's us\n// stay declarative, rather than introducing\n// logic into the JSX.\nconst arrows = new Map([[true, '\u25bc'], [false, '\u25b2']]);\n\n// Renders the arrow text. When clicked, the\n// \"onSort()\" function that's passed down from\n// the container.\nconst ListSort = ({ onSort, asc }) => (\n  <Text onPress={onSort}>{arrows.get(asc)}</Text>\n);\n\nListSort.propTypes = {\n  onSort: PropTypes.func.isRequired,\n  asc: PropTypes.bool.isRequired\n};\n\nexport default ListSort; \n```", "```jsx\nimport fetchMock from 'fetch-mock';\nimport querystring from 'querystring';\n\n// A mock item list...\nconst items = new Array(100).fill(null).map((v, i) => `Item ${i}`);\n\n// The same filter and sort functionality\n// as the previous example, only it's part of the\n// API now, instead of part of the React component.\nconst filterAndSort = (data, text, asc) =>\n  data\n    .filter(i => text.length === 0 || i.includes(text))\n    .sort(\n      asc\n        ? (a, b) => (b > a ? -1 : a === b ? 0 : 1)\n        : (a, b) => (a > b ? -1 : a === b ? 0 : 1)\n    );\n\nexport const fetchItems = (filter, asc) =>\n  new Promise(resolve => {\n    resolve({\n      json: () =>\n        Promise.resolve({\n          items: filterAndSort(items, filter, asc)\n        })\n    });\n  }); \n```", "```jsx\nimport React, { Component } from 'react';\n\nimport { fetchItems } from './api';\nimport List from './List';\n\nconst mapItems = items =>\n  items.map((value, i) => ({ key: i.toString(), value }));\n\nclass ListContainer extends Component {\n  // The \"source\" state is empty because we need\n  // to fetch the data from the API.\n  state = {\n    asc: true,\n    filter: '',\n    data: []\n  };\n\n  // When the component is first mounted, fetch the initial\n  // items from the API, then\n  componentDidMount() {\n    fetchItems(this.state.filter, this.state.asc)\n      .then(resp => resp.json())\n      .then(({ items }) => {\n        this.setState({ data: mapItems(items) });\n      });\n  }\n\n  render() {\n    return (\n      <List\n        data={this.state.data}\n        asc={this.state.asc}\n        onFilter={text => {\n          // Makes an API call when the filter changes...\n          fetchItems(text, this.state.asc)\n            .then(resp => resp.json())\n            .then(({ items }) =>\n              this.setState({\n                filter: text,\n                data: mapItems(items)\n              })\n            );\n        }}\n        onSort={() => {\n          // Makes an API call when the sort order changes...\n          fetchItems(this.state.filter, !this.state.asc)\n            .then(resp => resp.json())\n            .then(({ items }) =>\n              this.setState({\n                asc: !this.state.asc,\n                data: mapItems(items)\n              })\n            );\n        }}\n      />\n    );\n  }\n}\n\nexport default ListContainer; \n```", "```jsx\n// Items...keep'em coming!\nfunction* genItems() {\n  let cnt = 0;\n\n  while (true) {\n    yield `Item ${cnt++}`;\n  }\n}\n\nconst items = genItems();\n\nexport const fetchItems = () =>\n  Promise.resolve({\n    json: () =>\n      Promise.resolve({\n        items: new Array(20).fill(null).map(() => items.next().value)\n      })\n  }); \n```", "```jsx\nimport React, { Component } from 'react';\n\nimport * as api from './api';\nimport List from './List';\n\nclass ListContainer extends Component {\n  state = {\n    data: [],\n    asc: true,\n    filter: ''\n  };\n\n  fetchItems = () =>\n    api\n      .fetchItems()\n      .then(resp => resp.json())\n      .then(({ items }) =>\n        this.setState(state => ({\n          data: [...state.data, ...items.map((value, i) => ({\n            key: i.toString(),\n            value\n          }))]\n        })\n      );\n\n  // Fetches the first batch of items once the\n  // component is mounted.\n  componentDidMount() {\n    this.fetchItems();\n  }\n\n  render() {\n    return (\n      <List data={this.state.data} fetchItems={this.fetchItems} />\n    );\n  }\n}\n\nexport default ListContainer; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Text, FlatList } from 'react-native';\n\nimport styles from './styles';\n\n// Renders a \"<FlatList>\" component, and\n// calls \"fetchItems()\" and the user scrolls\n// to the end of the list.\nconst List = ({ data, fetchItems }) => (\n  <FlatList\n    data={data}\n    renderItem={({ item }) => (\n      <Text style={styles.item}>{item.value}</Text>\n    )}\n    onEndReached={fetchItems}\n  />\n);\n\nList.propTypes = {\n  data: PropTypes.array.isRequired,\n  fetchItems: PropTypes.func.isRequired\n};\n\nexport default List; \n```"]