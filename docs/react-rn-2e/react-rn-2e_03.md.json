["```jsx\nimport React, { Component } from 'react';\n\nexport default class MyComponent extends Component {\n // The initial state is set as a simple property\n  // of the component instance.\n  state = {\n    first: false,\n    second: true\n  };\n\n  render() {\n    // Gets the \"first\" and \"second\" state properties\n    // into constants, making our JSX less verbose.\n    const { first, second } = this.state;\n\n    // The returned JSX uses the \"first\" and \"second\"\n    // state properties as the \"disabled\" property\n    // value for their respective buttons.\n    return (\n      <main>\n        <section>\n          <button disabled={first}>First</button>\n        </section>\n        <section>\n          <button disabled={second}>Second</button>\n        </section>\n      </main>\n    );\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyComponent from './MyComponent';\n\n// \"MyComponent\" has an initial state, nothing is passed\n// as a property when it's rendered.\nrender(<MyComponent />, document.getElementById('root'));\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyComponent extends Component {\n  // The initial state is used, until something\n  // calls \"setState()\", at which point the state is\n  // merged with this state.\n  state = {\n    heading: 'React Awesomesauce (Busy)',\n    content: 'Loading...'\n  };\n\n  render() {\n    const { heading, content } = this.state;\n\n    return (\n      <main>\n        <h1>{heading}</h1>\n        <p>{content}</p>\n      </main>\n    );\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyComponent from './MyComponent';\n\n// The \"render()\" function returns a reference to the\n// rendered component. In this case, it's an instance\n// of \"MyComponent\". Now that we have the reference,\n// we can call \"setState()\" on it whenever we want.\nconst myComponent = render(\n  <MyComponent />,\n  document.getElementById('root')\n);\n\n// After 3 seconds, set the state of \"myComponent\",\n// which causes it to re-render itself.\nsetTimeout(() => {\n  myComponent.setState({\n    heading: 'React Awesomesauce',\n    content: 'Done!'\n  });\n}, 3000);\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyComponent extends Component {\n  // The initial state...\n  state = {\n    first: 'loading...',\n    second: 'loading...',\n    third: 'loading...',\n    fourth: 'loading...',\n    doneMessage: 'finished!'\n  };\n\n  render() {\n    const { state } = this;\n\n    // Renders a list of items from the\n    // component state.\n    return (\n      <ul>\n        {Object.keys(state)\n          .filter(key => key !== 'doneMessage')\n          .map(key => (\n            <li key={key}>\n              <strong>{key}: </strong>\n              {state[key]}\n            </li>\n          ))}\n      </ul>\n    );\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyComponent from './MyComponent';\n\n// Stores a reference to the rendered component...\nconst myComponent = render(\n  <MyComponent />,\n  document.getElementById('root')\n);\n\n// Change part of the state after 1 second...\nsetTimeout(() => {\n  myComponent.setState({ first: 'done!' });\n}, 1000);\n\n// Change another part of the state after 2 seconds...\nsetTimeout(() => {\n  myComponent.setState({ second: 'done!' });\n}, 2000);\n\n// Change another part of the state after 3 seconds...\nsetTimeout(() => {\n  myComponent.setState({ third: 'done!' });\n}, 3000);\n\n// Change another part of the state after 4 seconds...\nsetTimeout(() => {\n  myComponent.setState(state => ({\n    ...state,\n    fourth: state.doneMessage\n  }));\n}, 4000);\n\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyButton extends Component {\n  // The \"defaultProps\" values are used when the\n  // same property isn't passed to the JSX element.\n  static defaultProps = {\n    disabled: false,\n    text: 'My Button'\n  };\n\n  render() {\n    // Get the property values we want to render.\n    // In this case, it's the \"defaultProps\", since\n    // nothing is passed in the JSX.\n    const { disabled, text } = this.props; \n\n    return <button disabled={disabled}>{text}</button>;\n  }\n}\n\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyButton from './MyButton';\n\n// Renders the \"MyButton\" component, without\n// passing any property values.\nrender(<MyButton />, document.getElementById('root'));\n\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyButton extends Component {\n  // Renders a \"<button>\" element using values\n  // from \"this.props\".\n  render() {\n    const { disabled, text } = this.props;\n\n    return <button disabled={disabled}>{text}</button>;\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\n\nexport default class MyList extends Component {\n  render() {\n    // The \"items\" property is an array.\n    const { items } = this.props;\n\n    // Maps each item in the array to a list item.\n    return <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>;\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render as renderJSX } from 'react-dom';\n\n// The two components we're to pass props to\n// when they're rendered.\nimport MyButton from './MyButton';\nimport MyList from './MyList';\n\n// This is the \"application state\". This data changes\n// over time, and we can pass the application data to\n// components as properties.\nconst appState = {\n  text: 'My Button',\n  disabled: true,\n  items: ['First', 'Second', 'Third']\n};\n\n// Defines our own \"render()\" function. The \"renderJSX()\"\n// function is from \"react-dom\" and does the actual\n// rendering. The reason we're creating our own \"render()\"\n// function is that it contains the JSX that we want to\n// render, and so we can call it whenever there's new\n// application data.\nfunction render(props) {\n  renderJSX(\n    <main>\n      {/* The \"MyButton\" component relies on the \"text\"\n           and the \"disabed\" property. The \"text\" property\n           is a string while the \"disabled\" property is a\n           boolean. */}\n      <MyButton text={props.text} disabled={props.disabled} />\n\n      {/* The \"MyList\" component relies on the \"items\"\n           property, which is an array. Any valid\n           JavaScript data can be passed as a property. */}\n      <MyList items={props.items} />\n    </main>,\n    document.getElementById('root')\n  );\n}\n\n// Performs the initial rendering...\nrender(appState);\n\n// After 1 second, changes some application data, then\n// calls \"render()\" to re-render the entire structure.\nsetTimeout(() => {\n  appState.disabled = false;\n  appState.items.push('Fourth');\n\n  render(appState);\n}, 1000);\n\n```", "```jsx\nimport React from 'react'; \n\n// Exports an arrow function that returns a \n// \"<button>\" element. This function is pure \n// because it has no state, and will always \n// produce the same output, given the same \n// input. \nexport default ({ disabled, text }) => ( \n  <button disabled={disabled}>{text}</button> \n); \n```", "```jsx\nimport React from 'react';\nimport { render as renderJSX } from 'react-dom';\n\n// \"MyButton\" is a function, instead of a\n// \"Component\" subclass.\nimport MyButton from './MyButton';\n\n// Renders two \"MyButton\" components. We only need\n// the \"first\" and \"second\" properties from the\n// props argument by destructuring it.\nfunction render({ first, second }) {\n  renderJSX(\n    <main>\n      <MyButton text={first.text} disabled={first.disabled} />\n      <MyButton text={second.text} disabled={second.disabled} />\n    </main>,\n    document.getElementById('root')\n  );\n}\n\n// Reders the components, passing in property data.\nrender({\n  first: {\n    text: 'First Button',\n    disabled: false\n  },\n  second: {\n    text: 'Second Button',\n    disabled: true\n  }\n});\n```", "```jsx\nimport React from 'react';\n\n// The functional component doesn't care if the property\n// values are the defaults, or if they're passed in from\n// JSX. The result is the same.\nconst MyButton = ({ disabled, text }) => (\n  <button disabled={disabled}>{text}</button>\n);\n\n// The \"MyButton\" constant was created so that we could\n// attach the \"defaultProps\" metadata here, before\n// exporting it.\nMyButton.defaultProps = {\n  text: 'My Button',\n  disabled: false\n};\n\nexport default MyButton;\n\n```", "```jsx\nimport React, { Component } from 'react';\n\nimport MyList from './MyList';\n\n// Utility function that's intended to mock\n// a service that this component uses to\n// fetch it's data. It returns a promise, just\n// like a real async API call would. In this case,\n// the data is resolved after a 2 second delay.\nfunction fetchData() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(['First', 'Second', 'Third']);\n    }, 2000);\n  });\n}\n\n// Container components usually have state, so they\n// can't be declared as functions.\nexport default class MyContainer extends Component {\n  // The container should always have an initial state,\n  // since this will be passed down to child components\n  // as properties.\n  state = { items: [] };\n\n  // After the component has been rendered, make the\n  // call to fetch the component data, and change the\n  // state when the data arrives.\n  componentDidMount() {\n    fetchData().then(items => this.setState({ items }));\n  }\n\n  // Renders the container, passing the container\n  // state as properties, using the spread operator: \"...\".\n  render() {\n    return <MyList {...this.state} />;\n  }\n}\n```", "```jsx\nimport React from 'react';\n\n// A stateless component that expects\n// an \"items\" property so that it can render\n// a \"<ul>\" element.\nexport default ({ items }) => (\n  <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>\n);\n\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport MyContainer from './MyContainer';\n\n// All we have to do is render the \"MyContainer\"\n// component, since it looks after providing props\n// for it's children.\nrender(<MyContainer />, document.getElementById('root'));\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport { PermissionProvider } from './PermissionContext';\nimport App from './App';\n\nrender(\n  <PermissionProvider>\n    <App />\n  </PermissionProvider>,\n  document.getElementById('root')\n);\n```", "```jsx\nimport React, { Component, createContext } from 'react';\n\nconst { Provider, Consumer } = createContext('permissions');\n\nexport class PermissionProvider extends Component {\n  state = {\n    first: true,\n    second: false,\n    third: true\n  };\n\n  render() {\n    return (\n      <Provider value={this.state}>{this.props.children}</Provider>\n    );\n  }\n}\n\nconst PermissionConsumer = ({ name, children }) => (\n  <Consumer>{value => value[name] && children}</Consumer>\n);\n\nexport { PermissionConsumer };\n```", "```jsx\nimport React, { Fragment } from 'react';\n\nimport First from './First';\nimport Second from './Second';\nimport Third from './Third';\n\nexport default () => (\n  <Fragment>\n    <First />\n    <Second />\n    <Third />\n  </Fragment>\n);\n```", "```jsx\nimport React from 'react';\nimport { PermissionConsumer } from './PermissionContext';\n\nexport default () => (\n  <PermissionConsumer name=\"first\">\n    <div>\n      <button>First</button>\n    </div>\n  </PermissionConsumer>\n);\n```"]