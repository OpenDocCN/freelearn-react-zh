["```jsx\nimport { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nexport default class BaseComponent extends Component {\n  state = {\n    data: fromJS({\n      name: 'Mark',\n      enabled: false,\n      placeholder: ''\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // The base component doesn't actually render anything,\n  // but it still needs a render method.\n  render() {\n    return null;\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport BaseComponent from './BaseComponent';\n\n// Extends \"BaseComponent\" to inherit the\n// initial component state.\nexport default class MyComponent extends BaseComponent {\n  // This is our chance to build on the initial state.\n  // We change the \"placeholder\" text and mark it as\n  // \"enabled\".\n  componentDidMount() {\n    this.data = this.data.merge({\n      placeholder: 'Enter a name...',\n      enabled: true\n    });\n  }\n\n  // Used to set the name state whenever the input\n  // value changes.\n  onChange = ({ target: { value } }) => {\n    this.data = this.data.set('name', value);\n  };\n\n  // Renders a simple input element, that uses the\n  // state of this component as properties.\n  render() {\n    const { enabled, name, placeholder } = this.data.toJS();\n\n    return (\n      <label htmlFor=\"my-input\">\n        Name:\n        <input\n          type=\"text\"\n          id=\"my-input\"\n          disabled={!enabled}\n          placeholder={placeholder}\n          value={name}\n          onChange={this.onChange}\n        />\n      </label>\n    );\n  }\n}\n```", "```jsx\nimport { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nexport default class BaseComponent extends Component {\n  // The specifiction for these base properties.\n  static propTypes = {\n    users: PropTypes.array.isRequired,\n    groups: PropTypes.array.isRequired\n  };\n\n  // The default values of these base properties.\n  static defaultProps = {\n    users: [],\n    groups: []\n  };\n\n  render() {\n    return null;\n  }\n} \n```", "```jsx\nimport React from 'react';\nimport { Map } from 'immutable';\n\nimport BaseComponent from './BaseComponent';\n\n// Renders the given \"text\" as a header, unless\n// the given \"length\" is 0.\nconst SectionHeader = ({ text, length }) =>\n  Map([[0, null]]).get(length, <h1>{text}>/h1>);\n\nexport default class MyComponent extends BaseComponent {\n  render() {\n    const { users, groups } = this.props;\n\n    // Renders the \"users\" and \"groups\" arrays. There\n    // are not property validators or default values\n    // in this component, since these are declared in\n    // \"BaseComponent\".\n    return (\n      <section>\n        <SectionHeader text=\"Users\" length={users.length} />\n        <ul>{users.map(i => <li key={i}>{i}</li>)}</ul>\n\n        <SectionHeader text=\"Groups\" length={groups.length} />\n        <ul>{groups.map(i => <li key={i}>{i}</li>)}</ul>\n      </section>\n    );\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport ErrorBoundary from './ErrorBoundary';\nimport MyComponent from './MyComponent';\n\nconst users = ['User 1', 'User 2'];\n\nconst groups = ['Group 1', 'Group 2'];\n\nrender(\n  <section>\n    {/* Renders as expected, using the defaults. */}\n    <ErrorBoundary>\n      <MyComponent />\n    </ErrorBoundary>\n\n    {/* Renders as expected, using the \"groups\" default. */}\n    <ErrorBoundary>\n      <MyComponent users={users} />\n      <hr />\n    </ErrorBoundary>\n\n    {/* Renders as expected, using the \"users\" default. */}\n    <ErrorBoundary>\n      <MyComponent groups={groups} />\n      <hr />\n    </ErrorBoundary>\n\n    {/* Renders as expected, providing property values. */}\n    <ErrorBoundary>\n      <MyComponent users={users} groups={groups} />\n    </ErrorBoundary>\n\n    {/* Fails to render, the property validators in the base\n         component detect the invalid number type. */}\n    <ErrorBoundary>\n      <MyComponent users={0} groups={0} />\n    </ErrorBoundary>\n  </section>,\n  document.getElementById('root')\n);\n\n```", "```jsx\nimport { Component } from 'react';\n\n// Uses the componentDidCatch() method to set the\n// error state of this component. When rendering,\n// if there's an error it gets logged and nothing\n// is rendered.\nexport default class ErrorBoundary extends Component {\n  state = { error: null };\n\n  componentDidCatch(error) {\n    this.setState({ error });\n  }\n\n  render() {\n    if (this.state.error === null) {\n      return this.props.children;\n    } else {\n      console.error(this.state.error);\n      return null;\n    }\n  }\n}\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nexport default class BaseComponent extends Component {\n  state = {\n    data: fromJS({\n      items: []\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // The click event handler for each item in the\n  // list. The context is the lexically-bound to\n  // this component.\n  onClick = id => () => {\n    this.data = this.data.update('items', items =>\n      items.update(\n        items.indexOf(items.find(i => i.get('id') === id)),\n        item => item.update('done', d => !d)\n      )\n    );\n  };\n\n  // Renders a list of items based on the state\n  // of the component. The style of the item\n  // depends on the \"done\" property of the item.\n  // Each item is assigned an event handler that\n  // toggles the \"done\" state.\n  render() {\n    const { items } = this.data.toJS();\n\n    return (\n      <ul>\n        {items.map(i => (\n          <li\n            key={i.id}\n            onClick={this.onClick(i.id)}\n            style={{\n              cursor: 'pointer',\n              textDecoration: i.done ? 'line-through' : 'none'\n            }}\n          >\n            {i.name}\n          </li>\n        ))}\n      </ul>\n    );\n  }\n} \n```", "```jsx\nimport BaseComponent from './BaseComponent';\n\nexport default class MyComponent extends BaseComponent {\n  // Initializes the component state, by using the\n  // \"data\" getter method from \"BaseComponent\".\n  componentDidMount() {\n    this.data = this.data.merge({\n      items: [\n        { id: 1, name: 'One', done: false },\n        { id: 2, name: 'Two', done: false },\n        { id: 3, name: 'Three', done: false }\n      ]\n    });\n  }\n} \n```", "```jsx\nimport React from 'react';\n\n// The world's simplest component...\nexport default () => <p>My component...</p>; \n```", "```jsx\nimport React from 'react';\n\n// A minimal higher-order function is all it\n// takes to create a component repeater. Here, we're\n// returning a function that calls \"predicate()\".\n// If this returns true, then the rendered\n// \"<Component>\" is returned.\nexport default (Component, predicate) => props =>\n  predicate() && <Component {...props} />; \n```", "```jsx\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport cond from './cond';\nimport MyComponent from './MyComponent';\n\n// Two compositions of \"MyComponent\". The\n// \"ComposedVisible\" version will render\n// because the predicate returns true. The\n// \"ComposedHidden\" version doesn't render.\nconst ComposedVisible = cond(MyComponent, () => true);\nconst ComposedHidden = cond(MyComponent, () => false);\n\nrender(\n  <section>\n    <h1>Visible</h1>\n    <ComposedVisible />\n    <h2>Hidden</h2>\n    <ComposedHidden />\n  </section>,\n  document.getElementById('root')\n); \n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\n// The components that are connected to this store.\nlet components = fromJS([]);\n\n// The state store itself, where application data is kept.\nlet store = fromJS({});\n\n// Sets the state of the store, then sets the\n// state of every connected component.\nexport function setState(state) {\n  store = state;\n\n  for (const component of components) {\n    component.setState({\n      data: store\n    });\n  }\n}\n\n// Returns the state of the store.\nexport function getState() {\n  return store;\n}\n\n// Returns a higher-order component that's connected\n// to the \"store\".\nexport function connect(ComposedComponent) {\n  return class ConnectedComponent extends Component {\n    state = { data: store };\n\n    // When the component is mounted, add it to \"components\",\n    // so that it will receive updates when the store state\n    // changes.\n    componentDidMount() {\n      components = components.push(this);\n    }\n\n    // Deletes this component from \"components\" when it is\n    // unmounted from the DOM.\n    componentWillUnmount() {\n      const index = components.findIndex(this);\n      components = components.delete(index);\n    }\n\n    // Renders \"ComposedComponent\", using the \"store\" state\n    // as properties.\n    render() {\n      return <ComposedComponent {...this.state.data.toJS()} />;\n    }\n  };\n} \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\n// Renders an item list...\nconst MyList = ({ filterValue, items }) => {\n  const filter = new RegExp(filterValue, 'i');\n\n  return (\n    <ul>\n      {items\n        .filter(item => filter.test(item))\n        .map(item => <li key={item}>{item}>/li>)}\n    </ul>\n  );\n};\n\nMyList.propTypes = {\n  items: PropTypes.array.isRequired\n};\n\nexport default MyList; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { getState, setState } from './store';\n\n// When the filter input value changes.\nfunction onChange(e) {\n  // Updates the state of the store.\n  setState(getState().set('filterValue', e.target.value));\n}\n\n// Renders a simple input element to filter a list.\nconst MyInput = ({ value, placeholder }) => (\n  <input\n    autoFocus\n    value={value}\n    placeholder={placeholder}\n    onChange={onChange}\n  />\n);\n\nMyInput.propTypes = {\n  value: PropTypes.string,\n  placeholder: PropTypes.string\n};\n\nexport default MyInput;\n```"]