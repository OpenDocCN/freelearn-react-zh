- en: Building Responsive Layouts with Flexbox
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flexbox构建响应式布局
- en: In this chapter, you'll get a feel for what it's like to lay out components
    on the screen of mobile devices. Thankfully, React Native polyfills many CSS properties
    that you might have used in the past to implement page layouts in web applications.
    You'll learn how to use the flexbox model to layout our React Native screens.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将体会到在移动设备屏幕上布局组件的感觉。幸运的是，React Native为许多您过去可能在Web应用程序中使用的CSS属性提供了polyfill。您将学习如何使用flexbox模型来布局我们的React
    Native屏幕。
- en: Before you dive into implementing layouts, you'll get a brief primer on flexbox
    and using CSS style properties in React Native apps—it's not quite what you're
    used to with regular CSS stylesheets. Then, you'll implement several React Native
    layouts using flexbox.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现布局之前，您将简要介绍flexbox和在React Native应用程序中使用CSS样式属性——这与常规CSS样式表不太一样。然后，您将使用flexbox实现几个React
    Native布局。
- en: Flexbox is the new layout standard
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flexbox是新的布局标准
- en: Before the flexible box layout model was introduced to CSS, the various approaches
    used to build layouts felt hacky and were prone to errors. Flexbox fixes this
    by abstracting many of the properties that you would normally have to provide
    in order to make the layout work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS引入灵活的盒子布局模型之前，用于构建布局的各种方法都感觉很巧妙，并且容易出错。Flexbox通过抽象化许多通常需要提供的属性来修复这一问题，以使布局正常工作。
- en: 'In essence, the flexbox is exactly what it sounds like—a box model that''s
    flexible. That''s the beauty of flexbox—its simplicity. You have a box that acts
    as a container, and you have child elements within that box. Both the container
    and the child elements are flexible in how they''re rendered on the screen, as
    illustrated here:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，flexbox就是其字面意思——一个灵活的盒子模型。这就是flexbox的美妙之处——它的简单性。您有一个充当容器的盒子，以及该盒子内的子元素。容器和子元素在屏幕上的呈现方式都是灵活的，如下所示：
- en: '![](Images/b21c0689-a915-41fe-b299-69805fde62e8.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b21c0689-a915-41fe-b299-69805fde62e8.png)'
- en: 'Flexbox containers have a direction, either column (up/down) or row (left/right).
    This actually confused me when I was first learning flexbox: my brain refused
    to believe that rows move from left to right. Rows stack on top of one another!
    The key thing to remember is that it''s the direction that the box flexes, not
    the direction that boxes are placed on the screen.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox容器有一个方向，可以是列（上/下）或行（左/右）。当我第一次学习flexbox时，这实际上让我感到困惑：我的大脑拒绝相信行是从左到右移动的。行是堆叠在彼此上面的！要记住的关键是，这是盒子伸展的方向，而不是盒子在屏幕上放置的方向。
- en: 'For a more in-depth treatment of flexbox concepts, check out this page: [https://css-tricks.com/snippets/css/a-guide-to-flexbox/](https://css-tricks.com/snippets/css/a-guide-to-flexbox/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有关flexbox概念的更深入的处理，请查看此页面：[https://css-tricks.com/snippets/css/a-guide-to-flexbox/](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)。
- en: Introducing React Native styles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React Native样式
- en: 'It''s time to implement your first React Native app, beyond the boilerplate
    that''s generated by `create-react-native-app`. I want to make sure that you feel
    comfortable using React Native stylesheets before you start implementing flexbox
    layouts in the next section. Here''s what a React Native stylesheet looks like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现您的第一个React Native应用程序了，超出了`create-react-native-app`生成的样板。我希望在您开始在下一节中实现flexbox布局之前，您能够确保在使用React
    Native样式表时感到舒适。以下是React Native样式表的样子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a JavaScript module, not a CSS module. If you want to declare React
    Native styles, you need to use plain objects. Then, you call `StyleSheet.create()`
    and export this from the style module.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JavaScript模块，而不是CSS模块。如果要声明React Native样式，需要使用普通对象。然后，调用`StyleSheet.create()`并从样式模块导出它。
- en: 'As you can see, this stylesheet has three styles: `container`, `box`, and `boxText`.
    Within the container style, there''s a call to `Platform.select()`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个样式表有三种样式：`container`、`box`和`boxText`。在容器样式中，有一个调用`Platform.select()`的方法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function will return different styles based on the platform of the mobile
    device. Here, you're handling the top padding of the top-level container view.
    You'll probably use this code in most of your apps to make sure that your React
    components don't render underneath the status bar of the device. Depending on
    the platform, the padding will require different values. If it's iOS, `paddingTop`
    is `20`. If it's Android, `paddingTop` will be the value of `StatusBar.currentHeight`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将根据移动设备的平台返回不同的样式。在这里，你正在处理顶层容器视图的顶部填充。你可能会在大多数应用中使用这段代码，以确保你的React组件不会渲染在设备的状态栏下面。根据平台的不同，填充将需要不同的值。如果是iOS，`paddingTop`是`20`。如果是Android，`paddingTop`将是`StatusBar.currentHeight`的值。
- en: The preceding `Platform.select()` code is an example of a case where you need
    to implement a workaround for differences in the platform. For example, if `StatusBar.currentHeight`
    were available on iOS and Android, you wouldn't need to call `Platform.select()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Platform.select()`代码是一个例子，说明你需要为平台的差异实现一个解决方法。例如，如果`StatusBar.currentHeight`在iOS和Android上都可用，你就不需要调用`Platform.select()`。
- en: 'Let''s see how these styles are imported and applied to React Native components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些样式是如何被导入并应用到React Native组件的：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The styles are assigned to each component via the `style` property. You''re
    trying to render a box with some text in the middle of the screen. Let''s make
    sure that this looks as we expect:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式通过`style`属性分配给每个组件。你正在尝试渲染一个带有一些文本的框在屏幕中间。让我们确保这看起来和我们期望的一样：
- en: '![](Images/3f0c5355-7581-40c7-8bd7-016d6b588d90.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3f0c5355-7581-40c7-8bd7-016d6b588d90.png)'
- en: Perfect! Now that you have an idea of how to set styles on React Native elements,
    it's time to start creating some screen layouts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你已经知道如何在React Native元素上设置样式，是时候开始创建一些屏幕布局了。
- en: Building flexbox layouts
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建flexbox布局
- en: In this section, you'll learn about several potential layouts that you can use
    in your React Native applications. I want to stay away from the idea that one
    layout is better than others. Instead, I'll show you how powerful the flexbox
    layout model is for mobile screens so that you can design the layout that best
    suits your application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将了解在React Native应用中可以使用的几种潜在布局。我想远离一个布局比其他布局更好的想法。相反，我会向你展示flexbox布局模型对于移动屏幕有多么强大，这样你就可以设计最适合你的应用的布局。
- en: Simple three column layout
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的三列布局
- en: 'To start things off, let''s implement a simple layout with three sections that
    flex in the direction of the column (top to bottom). Let''s start by taking a
    look at the resulting screen:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现一个简单的布局，其中有三个部分在列的方向上弹性伸缩（从上到下）。让我们先来看一下结果屏幕：
- en: '![](Images/cfc50f9a-7cda-4907-813c-a7ee6061392b.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cfc50f9a-7cda-4907-813c-a7ee6061392b.png)'
- en: The idea with this example is that you've styled and labeled the three screen
    sections so that they stand out. In other words, these components wouldn't necessarily
    have any styling in a real application since they're used to arrange other components
    on the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的想法是，你已经为三个屏幕部分设置了样式和标签，使它们突出显示。换句话说，在真实应用中，这些组件不一定会有任何样式，因为它们用于在屏幕上排列其他组件。
- en: 'Let''s take a look at the components used to create this screen layout:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下用于创建此屏幕布局的组件：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The container view (the outermost `<View>` component) is the column and the
    child views are the rows. The `<Text>` component is used to label each row. In
    terms of HTML elements, `<View>` is similar to a `<div>` while `<Text>` is similar
    to a `<p>`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器视图（最外层的 `<View>` 组件）是列，子视图是行。`<Text>` 组件用于标记每一行。在 HTML 元素方面，`<View>` 类似于 `<div>`，而
    `<Text>` 类似于 `<p>`。
- en: Maybe this example could have been called *three row layout*, since it has three
    rows. But, at the same time, the three layout sections are flexing in the direction
    of the column that they're in. Use the naming convention that makes the most conceptual
    sense to you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这个例子本来可以被称为“三行布局”，因为它有三行。但与此同时，三个布局部分都在其所在的列的方向上伸展。使用对你来说最有概念意义的命名约定。
- en: 'Now let''s take a look at the styles used to create this layout:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下用于创建此布局的样式：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `flex` and `flexDirection` properties of `container` enable the layout of
    the rows to flow from top to bottom. The `alignItems` and `justifyContent` properties
    align the child elements to the center of the container and add space around them,
    respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`container` 的 `flex` 和 `flexDirection` 属性使得行的布局从上到下流动。`alignItems` 和 `justifyContent`
    属性将子元素对齐到容器的中心，并在它们周围添加空间。'
- en: 'Let''s see how this layout looks when you rotate the device from a portrait
    orientation to a landscape orientation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你将设备从竖屏旋转到横屏时，这个布局是什么样子的：
- en: '![](Images/84f1fc09-2559-449a-adda-0ca301c252fa.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/84f1fc09-2559-449a-adda-0ca301c252fa.png)'
- en: The flexbox automatically figured out how to preserve the layout for you. However,
    you can improve on this a little bit. For example, the landscape orientation has
    a lot of wasted space to the left and right now. You could create your own abstraction
    for the boxes that you're rendering.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: flexbox 自动找到了如何为你保留布局。但是，你可以稍微改进一下。例如，横屏模式现在左右有很多浪费的空间。你可以为渲染的盒子创建自己的抽象。
- en: Improved three column layout
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进后的三列布局
- en: 'There are a few things that I think you can improve upon from the last example.
    Let''s fix the styles so that the children of the flexbox stretch to take advantage
    of the available space. Remember in the last example, when you rotated the device
    from portrait to landscape orientation? There was a lot of wasted space. It would
    be nice to have the components automatically adjust themselves. Here''s what the
    new styles module looks like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你可以从上一个例子中改进一些东西。让我们修复样式，使得 flexbox 的子元素能够充分利用可用空间。还记得上一个例子中，当你将设备从竖屏旋转到横屏时发生了什么吗？有很多空间被浪费了。让组件自动调整会很好。下面是新样式模块的样子：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The key change here is the `alignSelf` property. This tells elements with the
    `box` style to change their width or height (depending on the `flexDirection`
    of their container) to fill space. Also, the `box` style no longer defines a `width`
    property because this will be computed on the fly now. Here''s what the sections
    look like in portrait mode:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键变化是 `alignSelf` 属性。这告诉具有 `box` 样式的元素改变宽度或高度（取决于其容器的 `flexDirection`）以填充空间。此外，`box`
    样式不再定义 `width` 属性，因为现在将动态计算它。在竖屏模式下，各个部分的样子如下：
- en: '![](Images/b6823803-9c64-4f2a-a7a1-aaa4d3d62f35.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b6823803-9c64-4f2a-a7a1-aaa4d3d62f35.png)'
- en: 'Now each section takes the full width of the screen, which is exactly what
    you want to happen. The issue of wasted space was actually more prevalent in landscape
    orientation, so let''s rotate the device and see what happens to these sections
    now:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个部分都占据了屏幕的整个宽度，这正是你希望发生的。浪费空间的问题实际上在横屏模式下更为突出，所以让我们旋转设备，看看这些部分现在会发生什么：
- en: '![](Images/09165861-0bf5-4c97-8afe-d797fba4d9e8.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09165861-0bf5-4c97-8afe-d797fba4d9e8.png)'
- en: 'Now your layout is utilizing the entire width of the screen, regardless of
    orientation. Lastly, let''s implement a proper `Box` component that can be used
    by `App.js` instead of having repetitive style properties in place. Here''s what
    the `Box` component looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的布局利用了整个屏幕的宽度，不管方向如何。最后，让我们实现一个适当的`Box`组件，可以被`App.js`使用，而不是在原地重复样式属性。`Box`组件的样子如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You now have the beginnings of a nice layout. Next, you'll learn about flexing
    in the other direction—left to right.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个不错的布局的开端。接下来，你将学习如何在另一个方向上进行弹性布局——从左到右。
- en: Flexible rows
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活的行
- en: 'In this section, you''ll learn how to make screen layout sections stretch from
    top to bottom. To do this, you need a flexible row. Here are what the styles for
    this screen look like:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习如何使屏幕布局部分从上到下延伸。为此，你需要一个灵活的行。这个屏幕的样式如下：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the `App` component, using the same `Box` component that you implemented
    in the previous section:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`App`组件，使用了你在上一节中实现的`Box`组件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s what the resulting screen looks like in portrait mode:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是纵向模式下的屏幕效果：
- en: '![](Images/f56cfffc-2dad-426c-8f05-f7c053f4acf0.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f56cfffc-2dad-426c-8f05-f7c053f4acf0.png)'
- en: The two columns stretch all the way from the top of the screen to the bottom
    of the screen because of the `alignSelf` property, which doesn't actually say
    which direction to stretch in. The two `Box` components stretch from top to bottom
    because they're displayed in a flex row. Note how the spacing between these two
    sections goes from left to right? This is because of the container's `flexDirection`
    property, which has a value of `row`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两列从屏幕顶部一直延伸到屏幕底部，这是因为`alignSelf`属性，它实际上并没有指定要延伸的方向。这两个`Box`组件从上到下延伸，因为它们显示在一个弹性行中。注意这两个部分之间的间距是从左到右的吗？这是因为容器的`flexDirection`属性，它的值是`row`。
- en: 'Now let''s see how this flex direction impacts the layout when the screen is
    rotated into a landscape orientation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当屏幕旋转到横向方向时，这种弹性方向对布局的影响：
- en: '![](Images/30184fb5-cf9d-4b9d-bc98-cd5a0a89c051.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/30184fb5-cf9d-4b9d-bc98-cd5a0a89c051.png)'
- en: Since the flexbox has a `justifyContent` style property value of `space-around`,
    space is proportionally added to the left, the right, and in-between the sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于弹性盒模型具有`justifyContent`样式属性值为`space-around`，空间被比例地添加到左侧、右侧和部分之间。
- en: Flexible grids
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活的网格
- en: Sometimes, you need a screen layout that flows like a grid. For example, what
    if you have several sections that are the same width and height, but you're not
    sure how many of these sections will be rendered? The flexbox makes it easy to
    build a row that flows from left to right until the end of the screen is reached.
    Then, it automatically continues rendering elements from left to right on the
    next row.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要一个像网格一样流动的屏幕布局。例如，如果你有几个宽度和高度相同的部分，但你不确定会渲染多少个这样的部分呢？弹性盒模型使得从左到右流动的行的构建变得容易，直到屏幕的末端。然后，它会自动继续从左到右在下一行渲染元素。
- en: 'Here''s an example layout in portrait mode:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是纵向模式下的一个布局示例：
- en: '![](Images/1d539b72-e514-486e-aaa9-def0393fd2fe.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1d539b72-e514-486e-aaa9-def0393fd2fe.png)'
- en: 'The beauty of this approach is that you don''t need to know in advance how
    many columns are in a given row. The dimensions of each child determine what will
    fit in a given row. Let''s take a look at the styles used to create this layout:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的美妙之处在于，你不需要提前知道每一行有多少列。每个子元素的尺寸决定了每一行可以容纳多少个元素。让我们来看一下用于创建这个布局的样式：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s the `App` component that renders each section:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染每个部分的`App`组件：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, let''s make sure that the landscape orientation works with this layout:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保横向方向与这个布局兼容：
- en: '![](Images/6cb2d557-480d-462f-a4f9-928a1420ea5b.png)You might have noticed
    that there''s some superfluous space on the right side. Remember, these sections
    are only visible in this book because we want them to be visible. In a real app,
    they''re just grouping other React Native components. However, if the space to
    the right of the screen becomes an issue, play around with the margin and the
    width of the child components.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6cb2d557-480d-462f-a4f9-928a1420ea5b.png)你可能已经注意到右侧有一些多余的空间。请记住，这些部分只在本书中可见，因为我们希望它们可见。在真实的应用中，它们只是其他React
    Native组件的分组。但是，如果屏幕右侧的空间成为问题，请尝试调整子组件的边距和宽度。'
- en: Flexible rows and columns
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活的行和列
- en: 'In this final section of the chapter, you''ll learn how to combine rows and
    columns to create a sophisticated layout for your app. For example, sometimes
    you need the ability to nest columns within rows or rows within columns. Let''s
    take a look at the `App` component of an application that nests columns within
    rows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，您将学习如何将行和列组合在一起，为应用程序创建复杂的布局。例如，有时您需要能够在行内嵌套列或在列内嵌套行。让我们看看一个应用程序的`App`组件，它在行内嵌套列：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You''ve created abstractions for the layout pieces (`<Row>` and `<Column>`)
    and the content piece (`<Box>`). Let''s see what this screen looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为布局部分（`<Row>`和`<Column>`）和内容部分（`<Box>`）创建了抽象。让我们看看这个屏幕是什么样子的：
- en: '![](Images/6c90900f-bf41-4d07-b50a-802aaf13428c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6c90900f-bf41-4d07-b50a-802aaf13428c.png)'
- en: 'This layout probably looks familiar, because you''ve done it already in this
    chapter. The key difference is in how these content sections are ordered. For
    example, #2 doesn''t go to the left of #1, it goes below it. This is because we''ve
    placed #1 and #2 in a `<Column>`. The same with #3 and #4. These two columns are
    placed in a row. Then the next row begins, and so on.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局可能看起来很熟悉，因为你在本章中已经做过了。关键区别在于这些内容部分的排序方式。例如，#2不会放在#1的左侧，而是放在下面。这是因为我们将#1和#2放在了`<Column>`中。#3和#4也是一样。这两列放在了一行中。然后下一行开始，依此类推。
- en: 'This is just one of many possible layouts that you can achieve by nesting row
    flexboxes and column flexboxes. Let''s take a look at the `Row` component now:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套行flexbox和列flexbox，您可以实现许多可能的布局之一。现在让我们看看`Row`组件：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This component applies the `row` style to the `<View>` component. The end result
    is cleaner JSX markup in the `App` component when creating a complex layout. Finally,
    let''s look at the `Column` component:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将`<View>`组件应用了`row`样式。最终结果是在创建复杂布局时，`App`组件中的JSX标记更清晰。最后，让我们看看`Column`组件：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This looks just like the `Row` component, only with a different style applied
    to it. It also serves the same purpose as `Row` - to enable simpler JSX markup
    for layouts in other components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来就像`Row`组件，只是应用了不同的样式。它也和`Row`有相同的作用 - 为其他组件的布局提供更简单的JSX标记。
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced you to styles in React Native. Though you can use many
    of the same CSS style properties that you're used to, the CSS stylesheets used
    in web applications look very different. Namely, they're composed of plain JavaScript
    objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了React Native中的样式。虽然您可以使用许多您习惯的CSS样式属性，但在Web应用程序中使用的CSS样式表看起来非常不同。换句话说，它们由普通的JavaScript对象组成。
- en: Then, you learned how to work with the main React Native layout mechanism—the
    flexbox. This is the preferred way to layout most web applications these days,
    so it makes sense to be able to reuse this approach in a native app. You created
    several different layouts, and you saw how they looked in portrait and in landscape
    orientation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学习了如何使用主要的React Native布局机制 - flexbox。这是如今布局大多数Web应用程序的首选方式，因此能够在原生应用中重用这种方法是有意义的。您创建了几种不同的布局，并看到它们在纵向和横向方向上的外观。
- en: In the following chapter, you'll start implementing navigation for your app.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将开始为你的应用实现导航。
- en: Test your knowledge
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: What's the difference between CSS styles and styles used with React Native components?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSS样式和React Native组件使用的样式有什么区别？
- en: React Native shares many style properties with CSS. Style properties are expressed
    as plain object properties in React Native
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native与CSS共享许多样式属性。样式属性在React Native中以普通对象属性的形式表达
- en: There is no difference—you style React Native components just like any other
    React component
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有区别——你可以像其他React组件一样样式化React Native组件
- en: They are completely different—React Native doesn't share any style properties
    from CSS
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们完全不同——React Native不与CSS共享任何样式属性
- en: Why do you need to consider the status bar when designing your layout?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在设计布局时需要考虑状态栏？
- en: You don't need to consider the status bar
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不需要考虑状态栏
- en: Because the status bar can interfere with your components on iOS
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为状态栏可能会干扰你的iOS组件
- en: Because the status bar can interfere with your components on Android
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为状态栏可能会干扰你的Android组件
- en: What is the flexbox model?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是弹性盒模型？
- en: It's the model that's used to control how View components flex to occupy horizontal
    space in a layout
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是用于控制View组件如何伸缩以占据布局中的水平空间的模型
- en: It provides flexible columns that respond to screen orientation changes
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了灵活的列，可以响应屏幕方向的变化
- en: The flexbox layout model is used to lay out components in a way that abstracts
    away many small details and automatically flexes in response to layout changes
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹性盒布局模型用于以一种抽象方式布置组件，并在布局变化时自动伸缩
- en: Is screen orientation a factor when considering your layout options?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑布局选项时，屏幕方向是否是一个因素？
- en: Yes, you always need to make sure there are no surprises in portrait or landscape
    orientation during development
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你总是需要确保在开发过程中，横向或纵向方向没有意外
- en: No, the orientation details are handled for you so that you can focus on application
    functionality
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，方向细节会被处理，这样你就可以专注于应用功能
- en: Further reading
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Go to the following links for more information:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 点击以下链接获取更多信息：
- en: '[https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)'
- en: '[https://facebook.github.io/react-native/docs/statusbar](https://facebook.github.io/react-native/docs/statusbar)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/statusbar](https://facebook.github.io/react-native/docs/statusbar)'
- en: '[https://facebook.github.io/react-native/docs/stylesheet](https://facebook.github.io/react-native/docs/stylesheet)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/stylesheet](https://facebook.github.io/react-native/docs/stylesheet)'
