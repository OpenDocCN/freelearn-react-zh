# 第二十五章：为什么选择 Relay 和 GraphQL？

在前一章中，你了解了 Flux 的架构原则。特别是，你使用 Redux 库在 React 应用程序中实现了具体的 Flux 概念。有了像 Flux 这样的模式框架，可以帮助你思考状态如何改变并在应用程序中流动，这是一件好事。在本章的结尾，你了解了在扩展方面的潜在限制。

在本章中，我们将带你走进另一种处理 React 应用程序状态的方法。与 Redux 一样，Relay 用于 Web 和移动 React 应用程序。Relay 依赖一种叫做 GraphQL 的语言，用于获取资源和改变这些资源。

Relay 的前提是它可以以 Redux 和其他处理状态的方法所限制的方式进行扩展。它通过消除它们，将焦点放在组件的数据需求上来实现这一点。

在本书的最后一章，你将会在 React Native 中实现备受欢迎的 Todo MVC 应用程序。

# 又一种方法？

当我了解 Relay 和 GraphQL 时，我就有了这个确切的问题。然后我提醒自己，React 的美妙之处在于它只是 UI 的视图抽象；当然会有许多处理数据的方法。因此，真正的问题是，Relay 比 Redux 之类的东西更好还是更差？

在高层次上，你可以将 Relay 看作是 Flux 架构模式的一种实现，你可以将 GraphQL 看作是描述 Relay 内部 Flux 存储工作方式的接口。在更实际的层面上，Relay 的价值在于实现的便利性。例如，使用 Redux，你需要做很多实现工作，只是为了用数据填充存储。随着时间的推移，这变得冗长。正是这种冗长使得 Redux 难以在一定程度之上进行扩展。

难以扩展的不是单个数据点。而是有大量获取请求最终构建非常复杂的存储的总体效果。Relay 通过允许你声明给定组件需要的数据，并让 Relay 找出获取这些数据并将其与本地存储同步的最佳方法来改变这一点。

Relay 的方法是否比 Redux 和其他处理 React 应用程序中数据的方法更好？在某些方面，是的。它完美吗？远非如此。这涉及到一个学习曲线，并非每个人都能理解它。它是不可变的，其中的一些部分很难使用。然而，了解 Relay 的方法的前提并看到它的实际效果是值得的，即使你最终决定不采用它。

现在，让我们分解一些词汇。

# 冗长的俗语

在我开始更深入地讨论数据依赖和突变之前，我认为我应该先介绍一些一般的 Relay 和 GraphQL 术语定义：

+   Relay：一个管理应用程序数据获取和数据突变的库，并提供高阶组件，将数据传递给我们的应用程序组件

+   GraphQL：用于指定数据需求和数据突变的查询语言

+   数据依赖：一个抽象概念，表示给定的 React 组件依赖于特定的数据

+   查询：查询是数据依赖的一部分，用 GraphQL 语法表示，并由封装的 Relay 机制执行

+   片段：较大的 GraphQL 查询的一部分

+   容器：一个 Relay React 组件，将获取的数据传递给应用程序 React 组件

+   突变：一种特殊类型的 GraphQL 查询，它改变了一些远程资源的状态，一旦完成，Relay 必须找出如何在前端反映这种变化

让我们快速谈谈数据依赖和突变，这样我们就可以看一些应用程序代码。

# 声明性数据依赖

Relay 使用 collocation 这个术语来描述声明性数据依赖，这些数据依赖与使用数据的组件并存。这意味着你不必四处寻找实际获取组件数据的动作创建函数，这些函数分散在几个模块中。通过 collocation，你可以清楚地看到组件需要什么。

让我们先尝试一下这是什么样子。如果你想显示用户的名字和姓氏，你需要告诉 Relay 你的组件需要这些数据。然后，你可以放心，数据将始终存在于你的组件中。这是一个例子：

```jsx
const User = ({ first, last }) => ( 
  <section> 
    <p>{first}</p> 
    <p>{last}</p> 
  </section> 
); 

const UserContainer = Relay.createFragmentContainer(User, { 
   user: () => graphql` 
    fragment on User { 
      first, 
      last, 
   } 
  `
}); 
```

你有两个组件在这里。首先，有`User`组件。这是应用程序组件，实际上呈现了`first`和`last`名称数据的 UI 元素。请注意，这只是一个普通的旧 React 组件，呈现传递给它的 props。使用您创建的`UserContainer`组件，Relay 遵循了您在本书中学到的容器模式。在`createFragmentContainer()`函数中，您通过传递 GraphQL 语法的片段来指定此组件需要的数据依赖关系。

再次强调，暂时不要过多关注 Relay/GraphQL 的具体细节。这里的想法只是简单说明这是您需要编写的所有代码，以获取组件所需的数据。其余的只是引导 Relay 查询机制，您将在下一章中看到。

# 改变应用程序状态

Relay mutations 是导致系统产生副作用的操作，因为它们改变了 UI 关心的某些资源的状态。关于 Relay mutations 有趣的是，它们关心的是由于某些状态变化而导致的数据的副作用。例如，如果您更改用户的名称，这肯定会影响显示用户详细信息的屏幕。但是，它也可能影响显示多个用户的列表屏幕。

让我们看看 mutation 是什么样子的：

```jsx
const mutation = graphql`
  mutation ChangeAgeMutation($input: ChangeAgeInput!) {
    changeTodoStatus(input: $input) {
      viewer {
        users
      }
      user {
        age
      }
    }
  }
`; 
```

这就是 Relay 能够确定在执行此 mutation 的副作用可能受到影响的内容。例如，用户可能会改变，但`viewer.users`集合也可能会改变。您将在接下来的章节中看到更多 mutation 的操作。

# GraphQL 后端和微服务

到目前为止，我所涵盖的关于 Relay 的一切都是在浏览器中的。Relay 需要将其 GraphQL 查询发送到某个地方。为此，您需要一个 GraphQL 后端。您可以使用 Node.js 和一些 GraphQL 库来实现这一点。您创建所谓的模式，描述将使用的所有数据类型、查询和 mutation。

在浏览器中，Relay 通过减少数据流复杂性来帮助您扩展应用程序。您有一种声明所需数据的方法，而不必担心如何获取它。实际上需要解析这些数据的是后端的模式。

这是 GraphQL 帮助解决的另一个扩展问题。现代 Web 应用程序由微服务组成。这些是较小的、自包含的 API 端点，提供一些比整个应用程序更小的特定目的（因此称为微服务）。我们的应用程序的工作是将这些微服务组合在一起，并为前端提供有意义的数据。

再次，你面临着一个可扩展性问题——如何在不引入不可逾越的复杂性的情况下维护由许多微服务组成的后端？这是 GraphQL 类型擅长的事情。在接下来的章节中，您将开始使用后端 GraphQL 服务实现您的 Todo 应用程序。

# 摘要

本章的目标是在本书的最后一章之前，快速向您介绍 Relay 和 GraphQL 的概念，您将在最后一章中实现一些 Relay/GraphQL 代码。

Relay 是 React 应用程序中状态管理问题的另一种方法。它不同之处在于，它减少了与数据获取代码相关的复杂性，我们必须使用其他 Flux 方法（如 Redux）编写。

Relay 的两个关键方面是声明式数据依赖和显式的突变副作用处理。所有这些都通过 GraphQL 语法表达。为了拥有一个 Relay 应用程序，你需要一个数据模式存在的 GraphQL 后端。现在，进入最后一章，你将更详细地研究 Relay/GraphQL 的概念。

# 测试你的知识

1.  Relay 和其他受 Flux 启发的库（如 Redux）之间有什么区别？

1.  没有区别，Relay 只是另一个 Flux 选项。

1.  Relay 是为 React Native 应用程序设计的，你应该在 Web 应用程序中使用 Redux。

1.  Relay 通过允许数据依赖声明和隐藏所有服务器通信复杂性来帮助扩展您的 Flux 架构。

1.  Relay 如何简化 React 组件的数据需求？

1.  通过合并数据依赖查询，您可以准确地看到您的组件使用的数据，而无需查看执行获取操作的代码。

1.  通过预先获取所有应用程序数据，Relay 可以查询每个组件需要的数据。

1.  通过抽象网络调用。GraphQL 是可选的，如果你愿意，你可以使用直接的 HTTP。

1.  在基于 Relay 的应用程序中，您的 React 组件如何与服务器通信？

1.  您必须实现自己的网络通信逻辑。Relay 只处理将数据传递给组件。

1.  Relay 编译在您的组件中找到的 GraphQL 查询，并为您处理所有的 GraphQL 服务器通信，包括缓存优化。

# 更多阅读

访问以下链接获取更多信息：

+   [`facebook.github.io/relay/`](https://facebook.github.io/relay/)
