["```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { View, Text, Modal } from 'react-native';\n\nimport styles from './styles';\n\n// Uses \"<Modal>\" to display the underlying view\n// on top of the current view. Properties passed to\n// this component are also passed to the modal.\nconst ConfirmationModal = props => (\n  <Modal {...props}>\n    {/* Slightly confusing, but we need an inner and\n         an outer \"<View>\" to style the height of the\n         modal correctly. */}\n    <View style={styles.modalContainer}>\n      <View style={styles.modalInner}>\n        {/* The confirmation message... */}\n        <Text style={styles.modalText}>Dude, srsly?</Text>\n\n        {/* The confirmation and the cancel buttons. Each\n             button triggers a different callback function\n             that's passed in from the container\n             component. */}\n        <Text\n          style={styles.modalButton}\n          onPress={props.onPressConfirm}\n        >\n          Yep\n        </Text>\n        <Text\n          style={styles.modalButton}\n          onPress={props.onPressCancel}\n        >\n          Nope\n        </Text>\n      </View>\n    </View>\n  </Modal>\n);\n\nConfirmationModal.propTypes = {\n  visible: PropTypes.bool.isRequired,\n  onPressConfirm: PropTypes.func.isRequired,\n  onPressCancel: PropTypes.func.isRequired\n};\n\nConfirmationModal.defaultProps = {\n  transparent: true,\n  onRequestClose: () => {}\n};\n\nexport default ConfirmationModal;\n```", "```jsx\nmodalContainer: { \n  flex: 1, \n  justifyContent: 'center', \n  alignItems: 'center', \n}, \n\nmodalInner: { \n  backgroundColor: 'azure', \n  padding: 20, \n  borderWidth: 1, \n  borderColor: 'lightsteelblue', \n  borderRadius: 2, \n  alignItems: 'center', \n}, \n\nmodalText: { \n  fontSize: 16, \n  margin: 5, \n  color: 'slategrey', \n}, \n\nmodalButton: { \n  fontWeight: 'bold', \n  margin: 5, \n  color: 'slategrey', \n}, \n```", "```jsx\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Alert } from 'react-native';\n\n// The \"actions\" Map will map the \"visible\"\n// property to the \"Alert.alert()\" function,\n// or to a noop function.\nconst actions = new Map([[true, Alert.alert], [false, () => {}]]);\n\nclass ConfirmationAlert extends Component {\n  state = { visible: false, title: '', message: '', buttons: [] };\n\n  static getDerivedStateFromProps(props) {\n    return props;\n  }\n\n  render() {\n    actions.get(this.state.visible)(\n      this.state.title,\n      this.state.message,\n      this.state.buttons\n    );\n\n    return null;\n  }\n}\n\nConfirmationAlert.propTypes = {\n  visible: PropTypes.bool.isRequired,\n  title: PropTypes.string,\n  message: PropTypes.string,\n  buttons: PropTypes.array\n};\n\nexport default ConfirmationAlert;\n```", "```jsx\nimport React, { Component } from 'react';\nimport { View, Text } from 'react-native';\nimport { fromJS } from 'immutable';\n\nimport styles from './styles';\nimport ConfirmationModal from './ConfirmationModal';\nimport ConfirmationAlert from './ConfirmationAlert';\n\nexport default class SuccessConfirmation extends Component {\n  // The two pieces of state used to control\n  // the display of the modal and the alert\n  // views.\n  state = {\n    data: fromJS({\n      modalVisible: false,\n      alertVisible: false\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // A \"modal\" button was pressed. So show\n  // or hide the modal based on its current state.\n  toggleModal = () => {\n    this.data = this.data.update('modalVisible', v => !v);\n  };\n\n  // A \"alert\" button was pressed. So show\n  // or hide the alert based on its current state.\n  toggleAlert = () => {\n    this.data = this.data.update('alertVisible', v => !v);\n  };\n\n  render() {\n    const { modalVisible, alertVisible } = this.data.toJS();\n\n    const { toggleModal, toggleAlert } = this;\n\n    return (\n      <View style={styles.container}>\n        {/* Renders the \"<ConfirmationModal>\" component,\n             which is hidden by default and controlled\n             by the \"modalVisible\" state. */}\n        <ConfirmationModal\n          animationType=\"fade\"\n          visible={modalVisible}\n          onPressConfirm={toggleModal}\n          onPressCancel={toggleModal}\n        />\n\n        {/* Renders the \"<ConfirmationAlert>\" component,\n             which doesn't actually render anything since\n             it controls an imperative API under the hood.\n             The \"alertVisible\" state controls this API. */}\n        <ConfirmationAlert\n          title=\"Are you sure?\"\n          message=\"For realz?\"\n          visible={alertVisible}\n          buttons={[\n            {\n              text: 'Nope',\n              onPress: toggleAlert\n            },\n            {\n              text: 'Yep',\n              onPress: toggleAlert\n            }\n          ]}\n        />\n\n        {/* Shows the \"<ConfirmationModal>\" component\n             by changing the \"modalVisible\" state. */}\n        <Text style={styles.text} onPress={toggleModal}>\n          Show Confirmation Modal\n        </Text>\n\n        {/* Shows the \"<ConfirmationAlert>\" component\n             by changing the \"alertVisible\" state. */}\n        <Text style={styles.text} onPress={toggleAlert}>\n          Show Confimation Alert\n        </Text>\n      </View>\n    );\n  }\n} \n```", "```jsx\nimport { StyleSheet } from 'react-native'; \n\nexport default StyleSheet.create({ \n  container: { \n    flex: 1, \n    justifyContent: 'center', \n    alignItems: 'center', \n    backgroundColor: 'ghostwhite', \n  }, \n\n  text: { \n    color: 'slategrey', \n  }, \n\n  modalContainer: { \n    flex: 1, \n    justifyContent: 'center', \n    alignItems: 'center', \n  }, \n\n  modalInner: { \n    backgroundColor: 'azure', \n    padding: 20, \n    borderWidth: 1, \n    borderColor: 'lightsteelblue', \n    borderRadius: 2, \n    alignItems: 'center', \n  }, \n\n  modalInnerError: { \n    backgroundColor: 'lightcoral', \n    borderColor: 'darkred', \n  }, \n\n  modalText: { \n    fontSize: 16, \n    margin: 5, \n    color: 'slategrey', \n  }, \n\n  modalTextError: { \n    fontSize: 18, \n    color: 'darkred', \n  }, \n\n  modalButton: { \n    fontWeight: 'bold', \n    margin: 5, \n    color: 'slategrey', \n  }, \n\n  modalButtonError: { \n    color: 'black', \n  }, \n}); \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { View, Text, Modal } from 'react-native';\n\nimport styles from './styles';\n\n// Declares styles for the error modal by\n// combining regular modal styles with\n// error styles.\nconst innerViewStyle = [styles.modalInner, styles.modalInnerError];\n\nconst textStyle = [styles.modalText, styles.modalTextError];\n\nconst buttonStyle = [styles.modalButton, styles.modalButtonError];\n\n// Just like a success modal, accept for the addition of\n// error styles.\nconst ErrorModal = props => (\n  <Modal {...props}>\n    <View style={styles.modalContainer}>\n      <View style={innerViewStyle}>\n        <Text style={textStyle}>Epic fail!</Text>\n        <Text style={buttonStyle} onPress={props.onPressConfirm}>\n          Fix it\n        </Text>\n        <Text style={buttonStyle} onPress={props.onPressCancel}>\n          Ignore it\n        </Text>\n      </View>\n    </View>\n  </Modal>\n);\n\nErrorModal.propTypes = {\n  visible: PropTypes.bool.isRequired,\n  onPressConfirm: PropTypes.func.isRequired,\n  onPressCancel: PropTypes.func.isRequired\n};\n\nErrorModal.defaultProps = {\n  transparent: true,\n  onRequestClose: () => {}\n};\n\nexport default ErrorModal; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { ToastAndroid } from 'react-native';\nimport { Map } from 'immutable';\n\n// Toast helper. Always returns \"null\" so that the\n// output can be rendered as a React element.\nconst show = (message, duration) => {\n  ToastAndroid.show(message, duration);\n  return null;\n};\n\n// This component will always return null,\n// since it's using an imperative React Native\n// interface to display popup text. If the\n// \"message\" property was provided, then\n// we display a message.\nconst Notification = ({ message, duration }) =>\n  Map([[null, null], [undefined, null]]).get(\n    message,\n    show(message, duration)\n  );\n\nNotification.propTypes = {\n  message: PropTypes.string,\n  duration: PropTypes.number.isRequired\n};\n\nNotification.defaultProps = {\n  duration: ToastAndroid.LONG\n};\n\nexport default Notification;\n```", "```jsx\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { View, Modal, Text } from 'react-native';\nimport { Map } from 'immutable';\n\nimport styles from './styles';\n\nclass Notification extends Component {\n  static propTypes = {\n    message: PropTypes.string,\n    duration: PropTypes.number.isRequired\n  };\n\n  static defaultProps = {\n    duration: 1500\n  };\n\n  static getDerivedStateFromProps(props) {\n    // Update the \"visible\" state, based on whether\n    // or not there's a \"message\" value.\n    return {\n      ...this.state,\n      visible: Map([[null, false], [undefined, false]]).get(\n        props.message,\n        true\n      )\n    };\n  }\n\n  // The modal component is either \"visible\", or not.\n  // The \"timer\" is used to hide the notification\n  // after some predetermined amount of time.\n  state = { visible: false };\n  timer = null;\n\n  componentWillUnmount() {\n    clearTimeout(this.timer);\n  }\n\n  render() {\n    const modalProps = {\n      animationType: 'fade',\n      transparent: true,\n      visible: this.state.visible\n    };\n\n    this.timer = Map([\n      [null, () => null],\n      [undefined, () => null]\n    ]).get(this.props.message, () =>\n      setTimeout(\n        () => this.setState({ visible: false }),\n        this.props.duration\n      )\n    )();\n\n    return (\n      <Modal {...modalProps}>\n        <View style={styles.notificationContainer}>\n          <View style={styles.notificationInner}>\n            <Text>{this.props.message}</Text>\n          </View>\n        </View>\n      </Modal>\n    );\n  }\n}\n\nNotification.propTypes = {\n  message: PropTypes.string,\n  duration: PropTypes.number.isRequired\n};\n\nNotification.defaultProps = {\n  duration: 1500\n};\n\nexport default Notification; \n```", "```jsx\nimport React, { Component } from 'react';\nimport { Text, View } from 'react-native';\nimport { fromJS } from 'immutable';\n\nimport styles from './styles';\nimport Notification from './Notification';\n\nexport default class PassiveNotifications extends Component {\n  // The initial state is the number of times\n  // the counter button has been clicked, and\n  // the notification message.\n  state = {\n    data: fromJS({\n      count: 0,\n      message: null\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  render() {\n    const { count, message } = this.data.toJS();\n\n    return (\n      <View style={styles.container}>\n        {/* The \"Notification\" component is\n             only displayed if the \"message\" state\n             has something in it. */}\n        <Notification message={message} />\n\n        {/* Updates the count. Also needs to make\n             sure that the \"message\" state is null,\n             even if the message has been hidden\n             already. */}\n        <Text\n          onPress={() => {\n            this.data = this.data\n              .update('count', c => c + 1)\n              .set('message', null);\n          }}\n        >\n          Pressed {count}\n        </Text>\n\n        {/* Displays the notification by\n             setting the \"message\" state. */}\n        <Text\n          onPress={() => {\n            this.data = this.data.set(\n              'message',\n              'Something happened!'\n            );\n          }}\n        >\n          Show Notification\n        </Text>\n      </View>\n    );\n  }\n}\n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { View, Modal, ActivityIndicator } from 'react-native';\n\nimport styles from './styles';\n\n// The \"Activity\" component will only display\n// if the \"visible\" property is try. The modal\n// content is an \"<ActivityIndicator>\" component.\nconst Activity = props => (\n  <Modal visible={props.visible} transparent>\n    <View style={styles.modalContainer}>\n      <ActivityIndicator size={props.size} />\n    </View>\n  </Modal>\n);\n\nActivity.propTypes = {\n  visible: PropTypes.bool.isRequired,\n  size: PropTypes.string.isRequired\n};\n\nActivity.defaultProps = {\n  visible: false,\n  size: 'large'\n};\n\nexport default Activity; \n```", "```jsx\nmodalContainer: { \n  flex: 1, \n  justifyContent: 'center', \n  alignItems: 'center', \n  backgroundColor: 'rgba(0, 0, 0, 0.2)', \n}, \n```", "```jsx\nimport React, { Component } from 'react';\nimport { Text, View } from 'react-native';\nimport { fromJS } from 'immutable';\n\nimport styles from './styles';\nimport Activity from './Activity';\n\nexport default class ActivityModals extends Component {\n  // The state is a \"fetching\" boolean value,\n  // and a \"promise\" that is used to determine\n  // when the fetching is done.\n  state = {\n    data: fromJS({\n      fetching: false,\n      promise: Promise.resolve()\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  // When the fetch button is pressed, the\n  // promise that simulates async activity\n  // is set, along with the \"fetching\" state.\n  // When the promise resolves, the \"fetching\"\n  // state goes back to false, hiding the modal.\n  onPress = () => {\n    this.data = this.data.merge({\n      promise: new Promise(resolve => setTimeout(resolve, 3000)).then(\n        () => {\n          this.data = this.data.set('fetching', false);\n        }\n      ),\n      fetching: true\n    });\n  };\n\n  render() {\n    return (\n      <View style={styles.container}>\n        {/* The \"<Activity>\" modal is only visible\n             when the \"fetching\" state is true. */}\n        <Activity visible={this.data.get('fetching')} />\n        <Text onPress={this.onPress}>Fetch Stuff...</Text>\n      </View>\n    );\n  }\n} \n```"]