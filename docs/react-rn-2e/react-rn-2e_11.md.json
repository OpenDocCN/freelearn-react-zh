["```jsx\n{/* The \"NavBar\" is statically-placed across the\n   top of every page. It contains things like the\n   title of the application, and menu items. */}\n<Navbar className=\"navbar-top\" fluid>\n  <Navbar.Header>\n    <Navbar.Brand>\n      <Link to=\"/\">Mobile-First React</Link>\n    </Navbar.Brand>\n\n    {/* The \"<Navbar.Taggle>\" coponent is used to replace any\n       navigation links with a drop-down menu for smaller\n       screens. */}\n    <Navbar.Toggle />\n  </Navbar.Header>\n\n  {/* The actual menu with links to makes. It's wrapped\n     in the \"<Navbar.Collapse>\"\" component so that it\n     work properly when the links have been collapsed. */}\n  <Navbar.Collapse>\n    <Nav pullRight>\n      <IndexLinkContainer to=\"/\">\n        <MenuItem>Home</MenuItem>\n      </IndexLinkContainer>\n      <LinkContainer to=\"forms\">\n        <MenuItem>Forms</MenuItem>\n      </LinkContainer>\n      <LinkContainer to=\"lists\">\n        <MenuItem>Lists</MenuItem>\n      </LinkContainer>\n    </Nav>\n  </Navbar.Collapse>\n</Navbar> \n```", "```jsx\n{/* This navigation menu has the same links\n   as the top navbar. The difference is that\n   this navigation is a sidebar. It's completely\n   hidden on smaller screens. */}\n<Col sm={3} md={2} className=\"sidebar\">\n  <Nav stacked>\n    <IndexLinkContainer to=\"/\">\n      <NavItem>Home</NavItem>\n    </IndexLinkContainer>\n    <LinkContainer to=\"forms\">\n      <NavItem>Forms</NavItem>\n    </LinkContainer>\n    <LinkContainer to=\"lists\">\n      <NavItem>Lists</NavItem>\n    </LinkContainer>\n  </Nav>\n</Col> \n```", "```jsx\n.sidebar { \n  display: none; \n} \n\n@media (min-width: 768px) { \n  .sidebar { \n    display: block; \n    position: fixed; \n    top: 60px; \n  } \n} \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport {\n  Button,\n  ButtonGroup,\n  ListGroupItem,\n  ListGroup,\n  Glyphicon\n} from 'react-bootstrap';\n\nimport './FilteredList.css';\n\n// Utility function to get the bootstrap style\n// for an item, based on the \"done\" value.\nconst itemStyle = done => (done ? { bsStyle: 'success' } : {});\n\n// Utility component for rendering a bootstrap\n// icon based on the value of \"done\".\nconst ItemIcon = ({ done }) =>\n  done ? <Glyphicon glyph=\"ok\" className=\"item-done\" /> : null;\n\n// Renders a list of items, and a set of filter\n// controls to change what's displayed in the\n// list.\nconst FilteredList = props => (\n  <section>\n    {/* Three buttons that control what's displayed\n         in the list below. Clicking one of these\n         buttons will toggle the state of the others. */}\n    <ButtonGroup className=\"filters\">\n      <Button active={props.todoFilter} onClick={props.todoClick}>\n        Todo\n      </Button>\n      <Button active={props.doneFilter} onClick={props.doneClick}>\n        Done\n      </Button>\n      <Button active={props.allFilter} onClick={props.allClick}>\n        All\n      </Button>\n    </ButtonGroup>\n\n    {/* Renders the list of items. It passes the\n         \"props.filter()\" function to \"items.filter()\".\n         When the buttons above are clicked, the \"filter\"\n         function is changed. */}\n    <ListGroup>\n      {props.items.filter(props.filter).map(i => (\n        <ListGroupItem\n          key={i.name}\n          onClick={props.itemClick(i)}\n          href=\"#\"\n          {...itemStyle(i.done)}\n        >\n          {i.name}\n          <ItemIcon done={i.done} />\n        </ListGroupItem>\n      ))}\n    </ListGroup>\n  </section>\n);\n\nFilteredList.propTypes = {\n  todoFilter: PropTypes.bool.isRequired,\n  doneFilter: PropTypes.bool.isRequired,\n  allFilter: PropTypes.bool.isRequired,\n  todoClick: PropTypes.func.isRequired,\n  doneClick: PropTypes.func.isRequired,\n  allClick: PropTypes.func.isRequired,\n  itemClick: PropTypes.func.isRequired,\n  filter: PropTypes.func.isRequired,\n  items: PropTypes.array.isRequired\n};\n\nexport default FilteredList;\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport FilteredList from './FilteredList';\n\nclass FilteredListContainer extends Component {\n  // Controls the state of the the filter buttons\n  // as well as the state of the function that\n  // filters the item list.\n  state = {\n    data: fromJS({\n      // The items...\n      items: [\n        { name: 'First item', done: false },\n        { name: 'Second item', done: false },\n        { name: 'Third item', done: false }\n      ],\n\n      // The filter button states...\n      todoFilter: true,\n      doneFilter: false,\n      allFilter: false,\n\n      // The default filter...\n      filter: i => !i.done,\n\n      // The \"todo\" filter button was clicked.\n      todoClick: () => {\n        this.data = this.data.merge({\n          todoFilter: true,\n          doneFilter: false,\n          allFilter: false,\n          filter: i => !i.done\n        });\n      },\n\n      // The \"done\" filter button was clicked.\n      doneClick: () => {\n        this.data = this.data.merge({\n          todoFilter: false,\n          doneFilter: true,\n          allFilter: false,\n          filter: i => i.done\n        });\n      },\n\n      // The \"all\" filter button was clicked.\n      allClick: () => {\n        this.data = this.data.merge({\n          todoFilter: false,\n          doneFilter: false,\n          allFilter: true,\n          filter: () => true\n        });\n      },\n\n      // When the item is clicked, toggle it's\n      // \"done\" state.\n      itemClick: item => e => {\n        e.preventDefault();\n\n        this.data = this.data.update('items', items =>\n          items.update(\n            items.findIndex(i => i.get('name') === item.name),\n            i => i.update('done', done => !done)\n          )\n        );\n      }\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  render() {\n    return <FilteredList {...this.state.data.toJS()} />;\n  }\n}\n\nexport default FilteredListContainer;\n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  FormGroup,\n  FormControl,\n  ControlLabel,\n  HelpBlock\n} from 'react-bootstrap';\n\n// A generic input element that encapsulates several\n// of the react-bootstrap components that are necessary\n// for event simple scenarios.\nconst Input = ({\n  type,\n  label,\n  value,\n  placeholder,\n  onChange,\n  validationState,\n  validationText\n}) => (\n  <FormGroup validationState={validationState}>\n    <ControlLabel>{label}</ControlLabel>\n    <FormControl\n      type={type}\n      value={value}\n      placeholder={placeholder}\n      onChange={onChange}\n    />\n    <FormControl.Feedback />\n    <HelpBlock>{validationText}</HelpBlock>\n  </FormGroup>\n);\n\nInput.propTypes = {\n  type: PropTypes.string.isRequired,\n  label: PropTypes.string,\n  value: PropTypes.any,\n  placeholder: PropTypes.string,\n  onChange: PropTypes.func,\n  validationState: PropTypes.oneOf([\n    undefined,\n    'success',\n    'warning',\n    'error'\n  ]),\n  validationText: PropTypes.string\n};\n\nexport default Input; \n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Panel } from 'react-bootstrap';\n\nimport Input from './Input';\n\nconst InputsForm = props => (\n  <Panel header={<h3>Inputs</h3>}>\n    <form>\n      {/* Uses the <Input> element to render\n           a simple name field. There's a lot of\n           properties passed here, many of them\n           come from the container component. */}\n      <Input\n        type=\"text\"\n        label=\"Name\"\n        placeholder=\"First and last...\"\n        value={props.nameValue}\n        onChange={props.nameChange}\n        validationState={props.nameValidationState}\n        validationText={props.nameValidationText}\n      />\n\n      {/* Uses the \"<Input>\" element to render a\n           password input. */}\n      <Input\n        type=\"password\"\n        label=\"Password\"\n        value={props.passwordValue}\n        onChange={props.passwordChange}\n      />\n    </form>\n  </Panel>\n);\n\nInputsForm.propTypes = {\n  nameValue: PropTypes.any,\n  nameChange: PropTypes.func,\n  nameValidationState: PropTypes.oneOf([\n    undefined,\n    'success',\n    'warning',\n    'error'\n  ]),\n  nameValidationText: PropTypes.string,\n  passwordValue: PropTypes.any,\n  passwordChange: PropTypes.func\n};\n\nexport default InputsForm;\n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport InputsForm from './InputsForm';\n\n// Validates the given \"name\". It should have a space,\n// and it should have more than 3 characters. There are\n// many scenarios not accounted for here, but are easy\n// to add.\nfunction validateName(name) {\n  if (name.search(/ /) === -1) {\n    return 'First and last name, separated with a space';\n  } else if (name.length < 4) {\n    return 'Less than 4 characters? Srsly?';\n  }\n\n  return null;\n}\n\nclass InputsFormContainer extends Component {\n  state = {\n    data: fromJS({\n      // \"Name\" value and change handler.\n      nameValue: '',\n      // When the name changes, we use \"validateName()\"\n      // to set \"nameValidationState\" and\n      // \"nameValidationText\".\n      nameChange: e => {\n        this.data = this.data.merge({\n          nameValue: e.target.value,\n          nameValidationState:\n            validateName(e.target.value) === null\n              ? 'success'\n              : 'error',\n          nameValidationText: validateName(e.target.value)\n        });\n      },\n      // \"Password\" value and change handler.\n      passwordValue: '',\n      passwordChange: e => {\n        this.data = this.data.set('passwordValue', e.target.value);\n      }\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  render() {\n    return <InputsForm {...this.data.toJS()} />;\n  }\n}\n\nexport default InputsFormContainer;\n```", "```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Panel, Radio, Checkbox, FormGroup } from 'react-bootstrap';\n\nconst RadioForm = props => (\n  <Panel header={<h3>Radios & Checkboxes</h3>}>\n    {/* Renders a group of related radio buttons. Note\n         that each radio needs to hae the same \"name\"\n         property, otherwise, the user will be able to\n         select multiple radios in the same group. The\n         \"checked\", \"disabled\", and \"onChange\" properties\n         all come from the container component. */}\n    <FormGroup>\n      <Radio\n        name=\"radio\"\n        onChange={props.checkboxEnabledChange}\n        checked={props.checkboxEnabled}\n        disabled={!props.radiosEnabled}\n      >\n        Checkbox enabled\n      </Radio>\n      <Radio\n        name=\"radio\"\n        onChange={props.checkboxDisabledChange}\n        checked={!props.checkboxEnabled}\n        disabled={!props.radiosEnabled}\n      >\n        Checkbox disabled\n      </Radio>\n    </FormGroup>\n\n    {/* Reanders a checkbox and uses the same approach\n         as the radios above: setting it's properties from\n         state that's passed in from the container. */}\n    <FormGroup>\n      <Checkbox\n        onChange={props.checkboxChange}\n        checked={props.radiosEnabled}\n        disabled={!props.checkboxEnabled}\n      >\n        Radios enabled\n      </Checkbox>\n    </FormGroup>\n  </Panel>\n);\n\nRadioForm.propTypes = {\n  checkboxEnabled: PropTypes.bool.isRequired,\n  radiosEnabled: PropTypes.bool.isRequired,\n  checkboxEnabledChange: PropTypes.func.isRequired,\n  checkboxDisabledChange: PropTypes.func.isRequired,\n  checkboxChange: PropTypes.func.isRequired\n};\n\nexport default RadioForm; \n```", "```jsx\nimport React, { Component } from 'react';\nimport { fromJS } from 'immutable';\n\nimport RadioForm from './RadioForm';\n\nclass RadioFormContainer extends Component {\n  // Controls the enabled state of a group of\n  // radio buttons and a checkbox. The radios\n  // toggle the state of the checkbox while the\n  // checkbox toggles the state of the radios.\n  state = {\n    data: fromJS({\n      checkboxEnabled: false,\n      radiosEnabled: true,\n      checkboxEnabledChange: () => {\n        this.data = this.data.set('checkboxEnabled', true);\n      },\n      checkboxDisabledChange: () => {\n        this.data = this.data.set('checkboxEnabled', false);\n      },\n      checkboxChange: () => {\n        this.data = this.data.update(\n          'radiosEnabled',\n          enabled => !enabled\n        );\n      }\n    })\n  };\n\n  // Getter for \"Immutable.js\" state data...\n  get data() {\n    return this.state.data;\n  }\n\n  // Setter for \"Immutable.js\" state data...\n  set data(data) {\n    this.setState({ data });\n  }\n\n  render() {\n    return <RadioForm {...this.data.toJS()} />;\n  }\n}\n\nexport default RadioFormContainer; \n```"]