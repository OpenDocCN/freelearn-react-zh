- en: Adding Native Functionality - Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加原生功能-第一部分
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下内容：
- en: Exposing custom iOS modules
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露自定义iOS模块
- en: Rendering custom iOS view components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染自定义iOS视图组件
- en: Exposing custom Android modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露自定义Android模块
- en: Rendering custom Android view components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染自定义Android视图组件
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the core principles in React Native development is writing JavaScript
    to build truly native mobile applications. To accomplish this, many native APIs
    and UI components are exposed through an abstraction layer and are accessed through
    the React Native bridge. While the React Native and Expo teams continue to improve
    and expand on the already impressive APIs that currently exist, through the native
    APIs we can access functionality that isn't available otherwise, such as vibration,
    contacts, and native alerts and toasts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: React Native开发的核心原则之一是使用JavaScript构建真正的原生移动应用程序。为了实现这一点，许多原生API和UI组件通过抽象层暴露，并通过React
    Native桥访问。虽然React Native和Expo团队继续改进和扩展已经存在的令人印象深刻的API，但通过原生API，我们可以访问其他方式无法获得的功能，比如振动、联系人以及原生警报和提示。
- en: By exposing the native view components, we're able to leverage all of the rendering
    performance the device has to offer, as we're not going through a WebView as in
    a hybrid app. This gives a native look and feel that adapts to the platform the
    user is running the app on. With React Native, we're already able to render many
    native view components including maps, lists, input fields, toolbars, and pickers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过暴露原生视图组件，我们能够利用设备提供的所有渲染性能，因为我们不像混合应用程序那样通过WebView进行渲染。这给用户提供了原生的外观和感觉，可以适应用户运行应用程序的平台。使用React
    Native，我们已经能够渲染许多原生视图组件，包括地图、列表、输入字段、工具栏和选择器。
- en: While React Native comes with many built-in native modules and view components,
    we're sometimes in a position where we need some custom functionality leveraging
    the native application layer that isn't provided out of the box. Fortunately,
    there's an extremely rich open source community supporting React Native that not
    only contributes to the library itself, but also publishes libraries that export
    some common native modules and view components. If you can't find a first- or
    third-party library to accomplish what you need, you can always build it yourself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React Native带有许多内置的原生模块和视图组件，但有时我们需要一些自定义功能，利用原生应用程序层，这些功能并不是开箱即用的。幸运的是，有一个非常丰富的开源社区支持React
    Native，不仅为库本身做出贡献，还发布了一些导出常见原生模块和视图组件的库。如果找不到满足需求的第一方或第三方库，您总是可以自己构建。
- en: In this chapter, we'll cover recipes that go over exposing custom native functionality,
    whether it's an API or view component, on both platforms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖一些关于在两个平台上暴露自定义原生功能的方法，无论是API还是视图组件。
- en: There will be a lot of generated code in the native portions of the code we'll
    be using in these recipes. The code blocks provided throughout this chapter will,
    like in previous chapters, continue to display all of the code used in a particular
    step, whether it's added by us or generated, unless stated otherwise. This is
    intended to ease the burden of understanding the context of a piece of code, and
    facilitates the discussion of these pieces of generated code when further explanation
    is warranted.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些配方中，我们将使用原生部分中的大量生成的代码。本章中提供的代码块将像以前的章节一样，继续显示特定步骤中使用的所有代码，无论是我们添加的还是生成的，除非另有说明。这旨在减轻理解代码片段的上下文的负担，并在需要进一步解释这些生成的代码片段时促进讨论。
- en: Exposing custom iOS modules
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露自定义iOS模块
- en: As you begin developing more interesting and complex React Native applications,
    you could possibly reach a point where executing certain code would be only possible
    (or significantly improved) in the native layer. This allows for executing data
    processing that's faster in the native layer when compared with JavaScript, and
    for accessing certain native functionality that isn't otherwise exposed, such
    as file I/O, or leveraging existing native code from other applications or libraries
    in your React Native app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始开发更有趣和复杂的React Native应用程序时，可能会达到一个只能在本地层执行某些代码（或显着改进）的点。这允许在本地层执行比JavaScript更快的数据处理，并访问某些本地功能，否则这些功能不会暴露，例如文件I/O，或者利用React
    Native应用程序中其他应用程序或库中的现有本地代码。
- en: This recipe will walk you through the process of executing some native Objective-C
    or Swift code and communicating with the JavaScript layer. We'll build a native
    `HelloManager` module that will greet our user with a message. We'll also show
    how to execute native Objective-C and Swift code, taking in arguments, and showing
    several ways of communicating back with the UI (or JavaScript) layer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将引导您执行一些本地Objective-C或Swift代码并与JavaScript层进行通信的过程。我们将构建一个本地的`HelloManager`模块来向用户问候。我们还将展示如何执行本地的Objective-C和Swift代码，传入参数，并展示与UI（或JavaScript）层进行多种通信的方式。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need a new empty, pure React Native application. Let's
    call it `NativeModuleApp`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一个新的空的纯React Native应用程序。让我们称之为`NativeModuleApp`。
- en: 'In this recipe, we''ll also make use of the `react-native-button` library.
    This library will allow us to work with a  `Button` component that''s more sophisticated
    than the React Native counterparts. It can be installed with `npm`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们还将使用`react-native-button`库。这个库将允许我们使用比React Native对应组件更复杂的`Button`组件。它可以使用`npm`进行安装：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or it can be installed using `yarn`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以使用`yarn`进行安装：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We'll start by opening the iOS Project in Xcode. The project file has an `.xcodeproj`
    file extension and is located in the `ios/` directory in the root of the project.
    In our case, the file will be called `NativeModuleApp.xcodeproj`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在Xcode中打开iOS项目开始。项目文件的文件扩展名为`.xcodeproj`，位于项目根目录的`ios/`目录中。在我们的情况下，文件将被称为`NativeModuleApp.xcodeproj`。
- en: 'We need to make a new file by selecting and right-clicking on the group/folder
    that matches the project name, then clicking on New File... as shown in the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要通过选择并右键单击与项目名称匹配的组/文件夹来创建一个新文件，然后点击New File...，如下所示：
- en: '![](assets/1776e333-b5bc-43a0-ab3d-71974adfe908.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1776e333-b5bc-43a0-ab3d-71974adfe908.png)'
- en: We'll be making a Cocoa class, so select Cocoa Class and click Next.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将制作一个Cocoa类，所以选择Cocoa Class并点击Next。
- en: 'We''ll use `HelloManager` for the Class name and set the Subclass of to NSObject,
    and the Language as Objective-C as shown in the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`HelloManager`作为类名，并将子类设置为NSObject，语言设置为Objective-C，如下所示：
- en: '![](assets/708e04f5-1712-4fa8-9e96-aa63650ed06c.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/708e04f5-1712-4fa8-9e96-aa63650ed06c.png)'
- en: After clicking Next, we'll be prompted to choose the directory for the new class.
    We want to save it to the `NativeModuleApp` directory.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Next后，我们将被提示选择新类的目录。我们希望将其保存到`NativeModuleApp`目录中。
- en: 'Creating this new Cocoa class has added two new files to the project: a header
    file (`HelloManager.h`) and an implementation file (`HelloManager.m`).'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建这个新的Cocoa类已经向项目中添加了两个新文件：一个头文件（`HelloManager.h`）和一个实现文件（`HelloManager.m`）。
- en: 'Inside the header file (`HelloManager.h`), you should see some generated code
    implementing the new `HelloManager` protocol. We need to import the React `RCTBridgeModule`
    library as well. The file should ultimately look like this:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件（`HelloManager.h`）中，您应该看到一些生成的代码来实现新的`HelloManager`协议。我们还需要导入React的`RCTBridgeModule`库。文件最终应该看起来像这样：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The implementation file (`HelloManager.m`) houses the functionality of our
    module. In order for our React Native app to be able to access this module from
    the JavaScript layer, we need to register it with the React Bridge. This is done
    by adding `RCT_EXPORT_MODULE()` after the `@implementation` tag. Also note that
    the header file should already be imported into this file as well:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现文件（`HelloManager.m`）包含了我们模块的功能。为了让我们的React Native应用能够从JavaScript层访问这个模块，我们需要在React
    Bridge中注册它。这是通过在`@implementation`标签后添加`RCT_EXPORT_MODULE()`来完成的。还要注意，头文件也应该已经被导入到这个文件中：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to add the function we''ll be exporting to the React Native app. We''ll
    create a `greetUser` method that will take two arguments, `name` and `isAdmin`.
    These arguments will be used to create a greeting message using string concatenation
    and then send it back to the JavaScript layer via `callback`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加我们将要导出到React Native应用的函数。我们将创建一个`greetUser`方法，它将接受两个参数，`name`和`isAdmin`。这些参数将用于使用字符串连接创建问候消息，然后通过`callback`发送回JavaScript层：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re ready to switch over to the JavaScript layer, which will have a UI that
    will invoke the native `HelloManager greetUser` method we''ve just created, then
    display its output. Fortunately, the React Native bridge does all of the heavy
    lifting for us and leaves us with a simple-to-use JavaScript object that mimics
    the `NativeModules` API. In this example, we''ll be using `TextInput` and `Switch`
    to provide `name` and the `isAdmin` value for the native modules method. Let''s
    start with out imports in `App.js`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备切换到JavaScript层，这将有一个UI，将调用我们刚刚创建的原生`HelloManager greetUser`方法，然后显示其输出。幸运的是，React
    Native桥为我们完成了所有繁重的工作，并留下了一个简单易用的JavaScript对象，模仿了`NativeModules` API。在这个例子中，我们将使用`TextInput`和`Switch`来为原生模块方法提供`name`和`isAdmin`值。让我们从`App.js`中开始导入：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use the `NativeModules` component we imported to get the `HelloManager`
    protocol we created from the native layer:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们导入的`NativeModules`组件来从原生层获取我们创建的`HelloManager`协议：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s create the `App` component and define the initial `state` object. We''ll
    add a `greetingMessage` property for saving the message received from the native
    module, `userName` for storing the entered user name, and an `isAdmin` Boolean
    for representing whether the user is an administrator:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`App`组件并定义初始的`state`对象。我们将添加一个`greetingMessage`属性来保存从原生模块接收到的消息，`userName`来存储输入的用户名，以及一个`isAdmin`布尔值来表示用户是否是管理员：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''re ready to start building the `render` method. First, we''ll need a `TextInput`
    component for getting a user name from the user, and a `Switch` component for
    toggling the `isAdmin` state:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备开始构建`render`方法。首先，我们需要一个`TextInput`组件来从用户那里获取用户名，以及一个`Switch`组件来切换`isAdmin`状态：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The UI will also need `Button` for submitting the callback to the native module
    and a `Text` component for displaying the message returned from the native module:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UI还需要`Button`来提交回调到原生模块，以及一个`Text`组件来显示从原生模块返回的消息：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the UI rendering the necessary components, we''re ready to wire up the  `onPress`
    handler of `Button` to a call to the native layer. This function passes the `displayResults`
    class method as the third parameter, which is the callback to be used by the native
    `greetUser` function. We''ll define `displayResults` in the next step:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着UI渲染必要的组件，我们准备将`Button`的`onPress`处理程序连接到本地层的调用。这个函数将`displayResults`类方法作为第三个参数传递，这是本地`greetUser`函数要使用的回调。我们将在下一步中定义`displayResults`：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`displayResults` will need to do two things: `blur` the `TextInput` using the
    `refs` associated with the component and set `greetingMessage` on `state` to the `results`
    returned from the native module:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`displayResults`需要做两件事：使用与组件关联的`refs`来`blur` `TextInput`，并将`greetingMessage`设置为从本地模块返回的`results`：'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last step is adding the styles to the layout and styling the app:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是向布局添加样式并设计应用程序的样式：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now have a working React Native app that''s able to communicate directly
    with the native iOS layer:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有一个可以直接与本地iOS层通信的工作React Native应用程序：
- en: '![](assets/b60dc2de-a7fd-4c7c-a1fd-d757beaa4cb9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b60dc2de-a7fd-4c7c-a1fd-d757beaa4cb9.png)'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The app we built in this recipe will serve as the foundation for many of the
    following recipes in this chapter. It's also the method Facebook uses to implement
    many bundled React Native APIs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个教程中构建的应用程序将成为本章后续许多教程的基础。这也是Facebook用来实现许多捆绑的React Native API的方法。
- en: There are several important concepts to keep in mind going forward. Any native
    module class we want to use in the JavaScript layer has to extend `RCTBridgeModule`,
    as it contains functionality for registering our class onto the React Native bridge.
    We register our class with the `RCT_EXPORT_MODULE` method call, which registers
    methods on the module once the module has been registered. Registering the module
    along with its respective methods and properties is what allows us to interface
    with the native layer from the JavaScript layer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，有几个重要的概念需要牢记。我们想要在JavaScript层中使用的任何本地模块类都必须扩展`RCTBridgeModule`，因为它包含了将我们的类注册到React
    Native桥上的功能。我们使用`RCT_EXPORT_MODULE`方法调用注册我们的类，一旦模块被注册，就会注册模块上的方法。注册模块以及其相应的方法和属性是允许我们从JavaScript层与本地层进行接口的。
- en: The `greetUser` method is executed when the button is pressed. This function
    in turn makes a call to `HelloManager.greetUser`, passing the `userName` and `isAdmin`
    properties from `state` and the `displayResults` function as a callback. `displayResults`
    sets the new `greetingMessage` on `state`, causing the UI to be refreshed and
    the message to be displayed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下按钮时，将执行`greetUser`方法。这个函数反过来调用`HelloManager.greetUser`，传递`state`中的`userName`和`isAdmin`属性以及`displayResults`函数作为回调。`displayResults`设置`state`上的新`greetingMessage`，导致UI刷新并显示消息。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'An explanation of how React Native applications boot up: [https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f](https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文解释了React Native应用程序如何启动：[https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f](https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f)
- en: 'A deep dive into how React Native events actually work: [https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c](https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解React Native事件的实际工作原理：[https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c](https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c)
- en: Rendering custom iOS view components
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染自定义iOS视图组件
- en: While it's very important to leverage the devices processing power in executing
    code on the native layer in our React Native application, it's equally important
    to leverage its rendering power to show native UI components. React Native can
    render any UI component that's an implementation of `UIView` inside an application.
    These components can be lists, form fields, tables, graphics, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的React Native应用程序中，在本地层执行代码时利用设备的处理能力非常重要，同样重要的是利用其渲染能力来显示本地UI组件。 React Native可以在应用程序中呈现任何`UIView`的UI组件实现。
    这些组件可以是列表、表单字段、表格、图形等等。
- en: For this recipe, we'll create a React Native application titled `NativeUIComponent`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将创建一个名为`NativeUIComponent`的React Native应用程序。
- en: In this recipe, we'll take a native `UIButton` and expose it as a React Native
    view component. You'll be able to set the button label and attach a handler for
    when it's pressed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将采用原生的`UIButton`并将其公开为React Native视图组件。 您将能够设置按钮标签并附加一个处理程序以在按下按钮时执行。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start by opening the iOS project in Xcode. The project file is located
    in the `ios/` directory of the project and should be called `NativeUIComponent.xcodeproj`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在Xcode中打开iOS项目开始。 项目文件位于项目的`ios/`目录中，应该被称为`NativeUIComponent.xcodeproj`。
- en: 'Select and right-click on the group that matches your project name and click
    on New File...:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并右键单击与项目名称匹配的组，并单击“新建文件...”：
- en: '![](assets/0b0b6694-a324-4ad7-8931-abab7e95d2f0.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b0b6694-a324-4ad7-8931-abab7e95d2f0.png)'
- en: We'll be making a Cocoa class, so select Cocoa Class and click Next.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个Cocoa类，所以选择`Cocoa Class`并单击`下一步`。
- en: 'We''ll be creating a button, so let''s name the Class `Button` and set the Subclass
    of to UIView and the Language as Objective-C:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个按钮，所以让我们将类命名为`Button`，将`Subclass of`设置为`UIView`，将`Language`设置为`Objective-C`：
- en: '![](assets/cbed707c-06cb-4418-b991-ac0cb10187cd.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cbed707c-06cb-4418-b991-ac0cb10187cd.png)'
- en: After clicking Next, we'll be prompted to choose the directory for the new class.
    We want to save it to the `NativeUIComponent` directory to create the class.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”后，我们将被提示选择新类的目录。 我们要将其保存到`NativeUIComponent`目录以创建该类。
- en: We're also going to need a `ButtonViewManager` class as well. You can repeat
    steps 2 to 5 with `ButtonViewManager` as the class name and `RCTViewManager` as
    the subclass.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`ButtonViewManager`类。 您可以将步骤2到5重复使用`ButtonViewManager`作为类名和`RCTViewManager`作为子类。
- en: 'First, we''re going to implement our `Button` UI class. In the header (`Button.h`)
    file, we''ll import `RCTComponent.h` from React and add an `onTap` property to
    wire up our tap event:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现我们的`Button` UI类。 在头文件（`Button.h`）中，我们将从React中导入`RCTComponent.h`并添加一个`onTap`属性来连接我们的点击事件：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s work on the implementation file (`Button.m`). We''ll start by creating
    references for our `UIButton` instance and the string that will hold the button
    label:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在实现文件（`Button.m`）上工作。 我们将首先创建我们的`UIButton`实例和将保存按钮标签的字符串的引用：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The bridge will look for a setter for the `buttonText` property. This is where
    we''ll set the `UIButton` instance title field:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桥梁将寻找`buttonText`属性的setter。 这是我们将设置`UIButton`实例标题字段的地方：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `Button` will accept an `onTap` event handler from the React Native app.
    We need to wire this to our `UIButton` instance through an action selector:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Button`将从React Native应用程序接受一个`onTap`事件处理程序。我们需要通过动作选择器将其连接到我们的`UIButton`实例：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to instantiate the `UIButton` and place it inside a React `Subview`.
    We''ll call this method `layoutSubviews`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实例化`UIButton`并将其放置在React `Subview`中。我们将称这个方法为`layoutSubviews`：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s import the React `RCTViewManager` in the `ButtonViewManager.h` header
    file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ButtonViewManager.h`头文件中导入React `RCTViewManager`：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we need to implement our `ButtonViewManager`, which will interface with
    our React Native application. Let''s work on the implementation file (`ButtonViewManager.m`)
    to make this happen. We use `RCT_EXPORT_VIEW_PROPERTY` to pass along the `buttonText` property
    and `onTap` method to the React Native layer:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要实现我们的`ButtonViewManager`，它将与我们的React Native应用程序进行交互。让我们在实现文件（`ButtonViewManager.m`）上工作，使其发生。我们使用`RCT_EXPORT_VIEW_PROPERTY`来传递`buttonText`属性和`onTap`方法到React
    Native层：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are ready to switch over to the React Native layer. We''re going to need
    a custom `Button` component, so let''s create a new `components` folder in the
    root of the project with a new `Button.js` file inside of it. We''ll also need
    to import the `requireNativeComponent` component from React Native for interfacing
    with our native UI component:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备切换到React Native层。我们需要一个自定义的`Button`组件，所以让我们在项目的根目录下创建一个新的`components`文件夹，并在其中创建一个新的`Button.js`文件。我们还需要从React
    Native中导入`requireNativeComponent`组件，以便与我们的原生UI组件进行交互：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Button` component will grab the native `Button` module we created earlier
    via the `requireNativeComponent` React Native helper. The call takes a string
    to be used as the component''s name in the React Native layer as the first parameter,
    and the second takes the `Button` component in the file, effectively wiring the
    two together:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Button`组件将通过`requireNativeComponent` React Native助手获取我们之前创建的原生`Button`模块。调用以字符串作为组件在React
    Native层中的名称作为第一个参数，并且第二个参数将`Button`组件在文件中，有效地将两者连接在一起：'
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''re ready to build out the main `App` component in the `App.js` file in
    the root of the project. We''ll start with the imports, which will include the `Button`
    component we created in the last two steps:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备在项目的根目录下的`App.js`文件中构建主要的`App`组件。我们将从导入开始，其中将包括我们在最后两个步骤中创建的`Button`组件：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s define the `App` component and the initial `state` object. The `count`
    property will keep track of the number of times the `Button` component has been
    pressed:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`App`组件和初始的`state`对象。`count`属性将跟踪`Button`组件被按下的次数：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re ready to define the `render` method, which will just consist of the
    `Button` component, along with a `Text` element for displaying the current button
    press count:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好定义`render`方法，它将由`Button`组件和用于显示当前按钮按下计数的`Text`元素组成：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You may recall that the `Button` component we created has an `onTap` property,
    which takes a callback function. In this case we''ll just use this function to
    increase the counter that lives on `state`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还记得我们创建的`Button`组件具有一个`onTap`属性，它接受一个回调函数。在这种情况下，我们将使用此函数来增加`state`上的计数器：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s wrap up this recipe with a few basic styles:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一些基本的样式结束这个教程：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The app is complete! When the button is pressed, the function passed to `onTap` will
    be executed, increasing the counter by one:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序完成了！当按下按钮时，将执行传递给`onTap`的函数，将计数器增加一：
- en: '![](assets/c4d79bfc-c22f-48dd-95d7-19221383b3e1.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c4d79bfc-c22f-48dd-95d7-19221383b3e1.png)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we exposed a basic native UI component. This is the same method
    by which all of the UI components built into React Native (for example, `Slider`,
    `Picker`, and `ListView`) were created.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们暴露了一个基本的原生UI组件。这是创建React Native内置的所有UI组件（例如`Slider`、`Picker`和`ListView`）的方法。
- en: The most important requirement in creating UI components is that your `ViewManager`
    extends `RCTViewManager` and returns an instance of `UIView`. In our case, we're
    wrapping `UIButton` with a React-specific `UIView` extension, which improves our
    ability to layout and style the component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建UI组件最重要的要求是，你的`ViewManager`要扩展`RCTViewManager`并返回一个`UIView`的实例。在我们的情况下，我们用React特定的`UIView`扩展来包装`UIButton`，这样可以提高我们布局和样式组件的能力。
- en: 'The next important factor is sending properties and reacting to component events.
    In step 13, we used the `RCT_EXPORT_VIEW_PROPERTY` method provided by React Native
    to register the `buttonText` and `onTap` view properties that will come from the
    JavaScript layer to the `Button` component. That `Button` component is then created
    and returned to be used in the JavaScript layer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要因素是发送属性和对组件事件做出反应。在第13步中，我们使用了React Native提供的`RCT_EXPORT_VIEW_PROPERTY`方法来注册来自JavaScript层的`buttonText`和`onTap`视图属性，这些属性将传递给`Button`组件。然后创建并返回`Button`组件以在JavaScript层中使用：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exposing custom Android modules
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露自定义的Android模块
- en: Often, you'll find the need for React Native applications to interface with
    native iOS and Android code. Having discussed integrating native iOS modules,
    now it's time to cover the equivalent recipes in Android.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现React Native应用程序需要与原生iOS和Android代码进行接口。在讨论了集成原生iOS模块之后，现在是时候覆盖Android中的等效配方了。
- en: This recipe will take us through writing our first Android native module. We're
    going to create a `HelloManager` native module with a `greetUser` method that
    takes `name` and an `isAdmin` Boolean as arguments, which will return a greeting
    message that we'll display in the UI.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将带领我们编写我们的第一个Android原生模块。我们将创建一个`HelloManager`原生模块，其中包含一个`greetUser`方法，该方法接受`name`和一个`isAdmin`布尔值作为参数，然后返回一个我们将在UI中显示的问候消息。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need to create another pure React Native app. Let's name
    this project `NativeModuleApp` as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要创建另一个纯React Native应用程序。我们也将这个项目命名为`NativeModuleApp`。
- en: 'We''ll also be making use of the `react-native-button` library again, which
    can be installed with `npm`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将再次使用`react-native-button`库，可以使用`npm`安装：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, it can be installed using `yarn`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用`yarn`进行安装：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll start by opening the new project's Android code in Android Studio. From
    the Android Studio welcome screen, you can select Open an existing Android Studio
    project, then select the `android` directory inside of the project folder.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在Android Studio中打开新项目的Android代码。从Android Studio的欢迎屏幕，你可以选择打开现有的Android
    Studio项目，然后选择项目文件夹内的`android`目录。
- en: 'Once the project has loaded, let''s open the project explorer (that is, the
    directory tree) on the left side of Android Studio and expand the package structure
    to find the Java source files, which should live in  `app/java/com.nativemoduleapp`.
    The folder should already have two `.java` files in it, `MainActivity` and `MainApplication`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目加载完成后，让我们在Android Studio左侧打开项目资源管理器（即目录树），并展开包结构以找到Java源文件，它应该位于`app/java/com.nativemoduleapp`中。该文件夹应该已经有两个`.java`文件，`MainActivity`和`MainApplication`：
- en: '![](assets/f26cf594-e058-4d2d-a1d4-c4fdfca09273.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f26cf594-e058-4d2d-a1d4-c4fdfca09273.png)'
- en: Right-click on the com.nativemoduleapp package, select New | Java Class, and
    name the class `HelloManager`. Also, be sure to set the Kind field to Class:![](assets/013c754f-9fee-45fe-bc62-489f19635a05.png)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '右键单击com.nativemoduleapp包，选择New | Java Class，并命名类为`HelloManager`。还要确保将Kind字段设置为Class:
    ![](assets/013c754f-9fee-45fe-bc62-489f19635a05.png)'
- en: We'll also need a `HelloPackage` class in the same directory. You can repeat
    steps 2 and 3 to create this class, simply applying the new name and keeping the
    Kind field set to Class.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在同一个目录中创建一个`HelloPackage`类。您可以重复步骤2和3来创建这个类，只需应用新名称并保持Kind字段设置为Class。
- en: 'Let''s start by implementing our `HelloManager` native module. We''ll start
    with the `package` name and the dependencies we''ll need in this file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现我们的`HelloManager`本机模块开始。我们将从`package`名称和我们在此文件中需要的依赖项开始：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`ReactContextBaseJavaModule` is the base class for all React Native modules,
    so we''ll be creating the `HelloManager` class as a subclass of it. We also need
    to define a `getName` method, which is used for registering native modules with
    the React Native bridge. This is one difference from the iOS native module implementations,
    as those are defined via class name:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReactContextBaseJavaModule`是所有React Native模块的基类，因此我们将创建`HelloManager`类作为其子类。我们还需要定义一个`getName`方法，该方法用于向React
    Native桥注册本机模块。这是与iOS本机模块实现的一个区别，因为那些是通过类名定义的：'
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we''ve set up our `HelloManager` native module, it''s time to add
    the `greetUser` method to it, which will expect as arguments `name`, `isAdmin`,
    and the callback that will be executed to send the message to the React Native
    layer:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了`HelloManager`本机模块，是时候向其中添加`greetUser`方法了，该方法将期望作为参数`name`、`isAdmin`和将执行以将消息发送到React
    Native层的回调：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another step that''s unique to Android is having to register the native module
    with the application, which is a two-step process. The first step is to add our
    `HelloManager` module to the `HelloPackage` class we created earlier. We''ll start
    with the dependencies for `HelloPackage.java`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android独有的另一个步骤是必须将本机模块注册到应用程序中，这是一个两步过程。第一步是将我们的`HelloManager`模块添加到之前创建的`HelloPackage`类中。我们将从`HelloPackage.java`的依赖项开始：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The implementation of `HelloPackage` simply follows the pattern provided by
    the official documentation ([https://facebook.github.io/react-native/docs/native-modules-android.html](https://facebook.github.io/react-native/docs/native-modules-android.html)).
    The most important piece here is the call to `modules.add`, where a new instance
    of `HelloManager` is passed in with `reactContext` as its parameter:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HelloPackage`的实现只是遵循官方文档提供的模式（[https://facebook.github.io/react-native/docs/native-modules-android.html](https://facebook.github.io/react-native/docs/native-modules-android.html)）。这里最重要的部分是对`modules.add`的调用，其中传入了带有`reactContext`作为参数的`HelloManager`的新实例：'
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second step in registering the native module with the React Native app
    is to add `HelloPackage` to the `MainApplication` module. Most of the code here
    is generated by the React Native bootstrapping process. The `getPackages` method
    needs to be updated to take both `new MainReactPackage()` and `new HelloPackage()`
    as arguments passed to `Arrays.asList`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将本机模块注册到React Native应用程序的第二步是将`HelloPackage`添加到`MainApplication`模块中。这里的大部分代码都是由React
    Native引导过程生成的。`getPackages`方法需要更新，以将`new MainReactPackage()`和`new HelloPackage()`作为传递给`Arrays.asList`的参数：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''re all done on the Java portion of this recipe. We need to build our UI,
    which will invoke the native `HelloManager greetUser` method and display its output.
    In this example, we''ll be using `TextInput` and `Switch` to provide `name` and
    the `isAdmin` value for the native module method. This is the same functionality
    as we implemented on iOS in the *Exposing custom iOS modules* recipe. Let''s get
    to building out `App.js`, starting with the dependencies we''ll need:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个配方的Java部分已经完成了。 我们需要构建我们的UI，这将调用本机的`HelloManager greetUser`方法并显示其输出。 在这个例子中，我们将使用`TextInput`和`Switch`来提供本机模块方法的`name`和`isAdmin`值。
    这与我们在*暴露自定义iOS模块*配方中在iOS上实现的功能相同。 让我们开始构建`App.js`，首先是我们需要的依赖项：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We need to make a reference to the `HelloManager` object that lives on the
    imported `NativeModules` component:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要引用存储在导入的`NativeModules`组件上的`HelloManager`对象：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s create the `App` class and the initial `state`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`App`类和初始`state`：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''re ready to define the component''s `render` function. This piece of code
    will not be described in great detail, as it''s basically the same `render` function
    defined in the *Exposing custom iOS modules* recipe at the beginning of this chapter:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备定义组件的`render`函数。 这段代码将不会被详细描述，因为它基本上与本章开头的*暴露自定义iOS模块*配方中定义的`render`函数相同：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the UI rendering the necessary components, we now need to wire up the `onPress`
    handler of `Button` to make the native call via `HelloManager.greetUser`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着UI渲染必要的组件，我们现在需要将`Button`的`onPress`处理程序连接起来，通过`HelloManager.greetUser`进行本机调用：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll add styles to layout and style the app. Again, these are the same styles
    as used in the *Exposing custom iOS modules* recipe at the beginning of this chapter:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加样式来布局和设计应用程序。 再次强调，这些样式与本章开头的*暴露自定义iOS模块*配方中使用的样式相同：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/7eb97b69-1929-45c0-adb7-a2d689e5b051.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7eb97b69-1929-45c0-adb7-a2d689e5b051.png)'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe covers the foundation for much of what we'll be doing with adding
    native Android modules in future recipes. All native module classes need to extend
    `ReactContextBaseJavaModule`, implement the constructor, and define the `getName`
    method. All methods that should be exposed to the React Native layer need to have
    the `@ReactMethod` annotation. Creating a React Native Android native module has
    more overhead as compared with iOS, since you have to also wrap your module in
    a class that implements `ReactPackage` (in this recipe, that's the `HelloPackage`
    module), and register the package with the React Native project. This is done
    in steps 7 and 8.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方涵盖了我们将在未来的配方中添加本机Android模块的大部分基础知识。 所有本机模块类都需要扩展`ReactContextBaseJavaModule`，实现构造函数，并定义`getName`方法。
    所有应该暴露给React Native层的方法都需要有`@ReactMethod`注解。 创建React Native Android本机模块的开销比iOS更大，因为您还必须将模块包装在实现`ReactPackage`的类中（在这个配方中，那就是`HelloPackage`模块），并将包注册到React
    Native项目中。 这是在步骤7和8中完成的。
- en: In the JavaScript portion of the recipe, the `greetUser` function is executed
    when the user presses the `Button` component. This, in turn, makes a call to `HelloManager.greetUser`,
    passing along the `userName` and `isAdmin` properties from `state` and the `updateGreetingMessage` method
    as a callback. The `updateGreetingMessage` sets the new `greetingMessage` on `state`,
    causing a refresh of the UI and the message to be displayed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方的JavaScript部分，当用户按下`Button`组件时，将执行`greetUser`函数。 这反过来又调用`HelloManager.greetUser`，并传递`state`中的`userName`和`isAdmin`属性以及`updateGreetingMessage`方法作为回调。
    `updateGreetingMessage`在`state`上设置新的`greetingMessage`，导致UI刷新并显示消息。
- en: Rendering custom Android view components
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染自定义Android视图组件
- en: One reason React Native has gained so much popularity so far is its ability
    to render truly native UI components. With native UI components on Android, we're
    able to leverage not only the GPU rendering power, but we also get the native
    look and feel of native components, including native fonts, colors, and animations.
    Web and hybrid applications on Android use CSS polyfills to simulate a native
    animation but, in React Native, we can get the real thing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，React Native之所以如此受欢迎的一个原因是它能够渲染真正的本机UI组件。在Android上使用本机UI组件，我们不仅能够利用GPU渲染能力，还能获得本机组件的本机外观和感觉，包括本机字体、颜色和动画。在Android上，Web和混合应用程序使用CSS
    polyfills来模拟本机动画，但在React Native中，我们可以得到真正的东西。
- en: We'll need a new pure React Native app for this recipe. Let's name it `NativeUIComponent`.
    In this recipe, we'll take a native `Button` and expose it as a React Native view
    component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新的纯React Native应用程序来完成这个示例。让我们将其命名为`NativeUIComponent`。在这个示例中，我们将采用本机`Button`并将其公开为React
    Native视图组件。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start by opening the Android project in Android Studio. In the Android
    Studio welcome screen, select Open an existing Android Studio project and open
    the `android` directory of the project.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在Android Studio中打开Android项目开始。在Android Studio欢迎屏幕上，选择打开现有的Android Studio项目，并打开项目的`android`目录。
- en: 'Open the project explorer and expand the package structure until you can see
    the Java source files (for example, `app/java/com.nativeuicomponent`):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目资源管理器，并展开包结构，直到您可以看到Java源文件（例如，`app/java/com.nativeuicomponent`）：
- en: '![](assets/ea40d86e-ce4c-419a-a7fc-6ded42199f2c.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea40d86e-ce4c-419a-a7fc-6ded42199f2c.png)'
- en: Right-click on the package and select New | Java Class. Use `ButtonViewManager`
    for the class name and set the Kind field to Class.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击包，然后选择New | Java Class。使用`ButtonViewManager`作为类名，并将Kind字段设置为Class。
- en: Use the same method to also create a `ButtonPackage` class.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的方法也创建一个`ButtonPackage`类。
- en: 'Let''s begin implementing our `ButtonViewManager` class, which must be a subclass
    of `SimpleViewManager<View>`. We''ll start with the imports and define the class
    itself:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始实现我们的`ButtonViewManager`类，它必须是`SimpleViewManager<View>`的子类。我们将从导入开始，并定义类本身：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The file class name `ButtonViewManager` follows the Android naming convention
    of adding the suffix `ViewManager` to any `View` component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类名`ButtonViewManager`遵循Android命名约定，将后缀`ViewManager`添加到任何`View`组件。
- en: 'Let''s start the class definition with the `getName` method that returns the
    string name we''re assigning the component, which in this case is `ButtonView`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`getName`方法开始类定义，该方法返回我们为组件分配的字符串名称，在本例中为`ButtonView`：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `createViewInstance` method is required for defining how React should initialize
    the module:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createViewInstance`方法是必需的，用于定义React应该如何初始化模块：'
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`setButtonText` will be used from the properties on the React Native element
    to set the text on the button:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setButtonText`将从React Native元素的属性中使用，以设置按钮上的文本：'
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `onClick` method defines what will happen when the button is pressed. This
    method uses `RCTEventEmitter` to handle receiving events from the React Native
    layer:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onClick`方法定义了按钮按下时会发生什么。此方法使用`RCTEventEmitter`来处理从React Native层接收事件：'
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Just like in the last recipe, we need to add `ButtonViewManager` to `ButtonPackage`;
    however, this time, we''re defining it as `ViewManager` and not `NativeModule`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在上一个示例中一样，我们需要将`ButtonViewManager`添加到`ButtonPackage`；但是，这次，我们将其定义为`ViewManager`而不是`NativeModule`：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last step in the Java layer is adding `ButtonPackage` to `MainApplication`.  `MainApplication.java`
    already has quite a bit of boilerplate code in it, and we''ll only need to change
    the `getPackages` method:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java层的最后一步是将`ButtonPackage`添加到`MainApplication`。`MainApplication.java`中已经有相当多的样板代码，我们只需要更改`getPackages`方法：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Switching over to the JavaScript layer, let''s build out our React Native app.
    First, let''s create a new `Button` component in `components/Button.js` in the
    project''s root directory. This is where the native button will live inside the
    React Native layer of the app. The `render` method uses the native button as `ButtonView`,
    which we''ll define in the next step:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到JavaScript层，让我们构建我们的React Native应用程序。首先，在项目的根目录中的`components/Button.js`中创建一个新的`Button`组件。这是原生按钮将存在于应用程序的React
    Native层内。`render`方法使用原生按钮作为`ButtonView`，我们将在下一步中定义：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can create the native button as a React Native component with the `requireNativeComponent`
    helper, which takes three parameters: the string `ButtonView` to define the components
    name, the `Button` component defined in the previous step, and the options object.
    There''s more information on this object in the *How it works...* section at the
    end of this recipe:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`requireNativeComponent`助手将原生按钮创建为React Native组件，它接受三个参数：字符串`ButtonView`来定义组件名称，上一步中定义的`Button`组件，以及选项对象。有关此对象的更多信息，请参阅本教程末尾的*它是如何工作的...*部分：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''re ready to define the `App` class. Let''s start with dependencies, including
    the `Button` component created previously:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好定义`App`类。让我们从依赖项开始，包括先前创建的`Button`组件：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `App` component in this recipe is essentially the same as the *Rendering
    custom iOS view components* recipe earlier in this chapter. The custom `onTap`
    property is fired when the `Button` component is pressed, adding `1` to the `count`
    property on `state`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本教程中的`App`组件本质上与本章前面的*渲染自定义iOS视图组件*教程相同。当按下`Button`组件时，自定义的`onTap`属性被触发，将`1`添加到`state`的`count`属性中。
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s add a few styles to layout and size the app''s UI:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为布局添加一些样式，调整应用的UI大小：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/c356c27a-7bdc-4589-ba9e-4c510bdf34db.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c356c27a-7bdc-4589-ba9e-4c510bdf34db.png)'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When defining a native view, as we did with the `ButtonViewManager` class, it
    must extend `SimpleViewManager` and render a type that extends `View`. In our
    recipe, we rendered a `Button` view, and we used the `@ReactProp` annotation for
    defining properties. When we need to communicate back to the JavaScript layer,
    we fire an event from the native component, which we implemented in *step 9* of
    this recipe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义原生视图时，就像我们在`ButtonViewManager`类中所做的那样，它必须扩展`SimpleViewManager`并呈现一个扩展`View`的类型。在我们的教程中，我们呈现了一个`Button`视图，并使用了`@ReactProp`注释来定义属性。当我们需要与JavaScript层通信时，我们从原生组件触发一个事件，这是我们在本教程的*步骤9*中实现的。
- en: In *step 12*, we created an `onChange` listener, which will execute the event
    handler passed in from the Android layer (`event.nativeEvent.message`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤12*中，我们创建了一个`onChange`监听器，它将执行从Android层传递的事件处理程序（`event.nativeEvent.message`）。
- en: 'Regarding the use of the `nativeOnly` option on *step 13*, from the React Native
    documents:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在*步骤13*中使用`nativeOnly`选项，来自React Native文档：
- en: Sometimes you'll have some special properties that you need to expose for the
    native component, but don't actually want them as part of the API for the associated
    React component. For example, `Switch` has a custom `onChange` handler for the
    raw native event, and exposes an `onValueChange` handler property that is invoked
    with just the Boolean value, rather than the raw event. Since you don't want these
    native only properties to be part of the API, you don't want to put them in `propTypes`,
    but if you don't, you'll get an error. The solution is simply to call them out
    via the `nativeOnly` option.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会有一些特殊属性，您需要为原生组件公开，但实际上不希望它们成为关联的React组件API的一部分。例如，`Switch`具有用于原始原生事件的自定义`onChange`处理程序，并公开一个`onValueChange`处理程序属性，该属性仅使用布尔值调用，而不是原始事件。由于您不希望这些仅限于原生的属性成为API的一部分，因此您不希望将它们放在`propTypes`中，但如果不这样做，就会出错。解决方案很简单，只需通过`nativeOnly`选项调用它们。
