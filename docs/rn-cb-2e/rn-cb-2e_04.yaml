- en: Implementing Complex User Interfaces - Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现复杂用户界面-第二部分
- en: This chapter will cover more recipes on building UIs with React Native. We'll
    get our first look at linking to other applications and websites, handling a change
    in device orientation, and how to build a form for collecting user input.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖更多使用React Native构建UI的技巧。我们将首次了解如何链接到其他应用程序和网站，处理设备方向的变化，以及如何构建用于收集用户输入的表单。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下技巧：
- en: Dealing with universal applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理通用应用程序
- en: Detecting orientation changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测方向变化
- en: Using a WebView to embed external websites
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebView嵌入外部网站
- en: Linking to websites and other applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到网站和其他应用程序
- en: Creating a form component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个表单组件
- en: Dealing with universal applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理通用应用程序
- en: One of the benefits of using React Native is its ability to easily create universal applications.
    We can share a lot of code between phone and tablet applications. The layouts
    might change, depending on the device, but we can reuse pieces of code for both
    types of device across layouts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native的好处之一是它能够轻松创建通用应用程序。我们可以在手机和平板应用程序之间共享大量代码。布局可能会根据设备而改变，但我们可以在布局之间重用代码片段。
- en: In this recipe, we will build an app that runs on phones and tablets. The tablet
    version will include a different layout, but we will reuse the same internal components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个可以在手机和平板上运行的应用程序。平板版本将包括不同的布局，但我们将重用相同的内部组件。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will show a list of contacts. For now, we will load the
    data from a `.json` file. We will explore how to load remote data from a **Representational
    State Transfer** (**REST**) API in a later chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将展示一个联系人列表。目前，我们将从`.json`文件中加载数据。我们将在以后的章节中探讨如何从**表述性状态转移**（**REST**）API中加载远程数据。
- en: Let's open the following URL and copy the generated JSON to a file called `data.json` at
    the root of the project. We will use this data to render the list of contacts.
    It returns a JSON object of fake user data at [http://api.randomuser.me/?results=20](http://api.randomuser.me/?results=20).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开以下URL并将生成的JSON复制到名为`data.json`的文件中，放在项目的根目录。我们将使用这些数据来渲染联系人列表。它返回一个假用户数据的JSON对象，网址是[http://api.randomuser.me/?results=20](http://api.randomuser.me/?results=20)。
- en: Let's create a new app called `universal-app`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`universal-app`的新应用。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s open `App.js` and import the dependencies we''ll need in this app, as
    well as our `data.json` file we created in the previous *Getting ready *section.
    We''ll also import a `Device` utility from `./utils/Device`, which we will build
    in a later step:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`App.js`并导入我们在上一节“准备工作”中创建的依赖项以及我们的`data.json`文件。我们还将从`./utils/Device`导入`Device`实用程序，我们将在以后的步骤中构建它：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we''re going to create the main `App` component and its basic layout.
    This top-level component will decide whether to render the phone or tablet UI. We
    are only rendering two `Text` elements. The `renderDetail` text should be displayed
    on tablets only and the `renderMaster` text should be displayed on phones and
    tablets:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将创建主要的`App`组件及其基本布局。这个顶层组件将决定是渲染手机还是平板UI。我们只渲染两个`Text`元素。`renderDetail`文本应该只在平板上显示，而`renderMaster`文本应该在手机和平板上显示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Under the `App` component, we''ll add a few basic styles. The styles temporarily
    include `paddingTop: 40` so that our rendered text is not overlapped by the device''s
    system bar:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`App`组件下，我们将添加一些基本样式。这些样式临时包括`paddingTop: 40`，以便我们渲染的文本不会被设备的系统栏覆盖：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we try to run our app as it is, it will fail with an error telling us that
    the `Device` module cannot be found, so let''s create it. The purpose of this
    utility class is to calculate whether the current device is a phone or tablet,
    based on the screen dimensions. It will have an `isTablet` method and an `isPhone` method.
    We need to create a `utils` folder in the root of the project and add a `Device.js`
    for the utility. Now we can add the basic structure of the utility:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试按原样运行我们的应用程序，它将失败，并显示错误，告诉我们找不到`Device`模块，所以让我们创建它。这个实用程序类的目的是根据屏幕尺寸计算当前设备是手机还是平板电脑。它将有一个`isTablet`方法和一个`isPhone`方法。我们需要在项目的根目录中创建一个`utils`文件夹，并添加一个`Device.js`作为实用程序。现在我们可以添加实用程序的基本结构：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s start building out the utility by creating two methods: one to get the
    dimensions in portrait and the other to get the dimensions in landscape. Depending
    on the device rotation, the values of `width` and `height` will change, which
    is why we need these two methods to always get the correct values, whether the
    device is `landscape` or `portrait`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始构建实用程序，通过创建两种方法：一个用于获取纵向尺寸，另一个用于获取横向尺寸。根据设备旋转，`width`和`height`的值将改变，这就是为什么我们需要这两种方法始终获取正确的值，无论设备是`landscape`还是`portrait`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s create the two methods our app will use to determine whether the
    app is running on a tablet or a phone. To calculate this, we need to get the dimensions
    in portrait mode and compare them with the dimensions we have defined for a tablet:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的应用程序将用来确定应用程序是在平板电脑上运行还是在手机上运行的两种方法。为了计算这一点，我们需要获取纵向模式下的尺寸，并将它们与我们为平板电脑定义的尺寸进行比较：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if we open the app, we should see two different texts being rendered,
    depending on whether we''re running the app on a phone or a tablet:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们打开应用程序，我们应该看到两种不同的文本被呈现，取决于我们是在手机上还是在平板上运行应用程序：
- en: '![](assets/4b04e46d-e2f8-4753-b51a-2a5053e3f3a2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4b04e46d-e2f8-4753-b51a-2a5053e3f3a2.png)'
- en: 'The utility works as expected! Let''s return to working on the `renderMaster`
    method of the main `App.js`. We want this method to render the list of contacts
    that live in the `data.json` file. Let''s import a new component, which we''ll
    build out in the following steps, and update the `renderMaster` method to use
    our new component:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实用程序按预期工作！让我们回到主`App.js`的`renderMaster`方法上。我们希望这个方法渲染存储在`data.json`文件中的联系人列表。让我们导入一个新的组件，我们将在接下来的步骤中构建它，并更新`renderMaster`方法以使用我们的新组件：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s create a new `UserList` folder. Inside this folder, we need to create
    the `index.js` and `styles.js` files for the new component. The first thing we
    need to do is import the dependencies into the new `index.js`, create the `UserList`
    class, and export it as the `default`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的`UserList`文件夹。在这个文件夹里，我们需要为新组件创建`index.js`和`styles.js`文件。我们需要做的第一件事是将依赖项导入到新的`index.js`中，创建`UserList`类，并将其导出为`default`：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ve already covered how to create a list. If you are not clear on how the
    `ListView` component works, read the *Displaying a list of items* recipe in [Chapter
    2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating a Simple React Native
    App*. In the constructor of the class, we will create the `dataSource` and then
    add it to the `state`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何创建列表。如果您不清楚`ListView`组件的工作原理，请阅读[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中的*显示项目列表*配方，*创建一个简单的React
    Native应用程序*。在类的构造函数中，我们将创建`dataSource`，然后将其添加到`state`中：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `render` method also follows the same pattern introduced in the `ListView`
    recipe, *Displaying a list of items,* from [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml),
    *Creating a Simple React Native App*:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法也遵循了在[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中介绍的`ListView`配方中引入的相同模式，*显示项目列表*：'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we need to define the `renderContact` method to render each
    of the rows. We are using the `TouchableOpacity` component as the main wrapper,
    which will allow us to use a callback function to perform some actions when a
    list item is pressed. For now, we are not doing anything when the button is pressed.
    We will learn more about communicating between components using Redux in [Chapter
    9](769c6947-a93b-4ede-95a3-e92cb4044a5e.xhtml), *Implementing Redux*:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们需要定义`renderContact`方法来呈现每一行。我们正在使用`TouchableOpacity`组件作为主要包装器，这将允许我们在列表项被按下时执行一些操作的回调函数。目前，当按钮被按下时我们并没有做任何事情。我们将在[第9章](769c6947-a93b-4ede-95a3-e92cb4044a5e.xhtml)中学习如何使用Redux在组件之间进行通信，*实现Redux*：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We don''t have a way to capitalize the texts using styles, so we need to use
    JavaScript for that. The `capitalize` function is quite simple, and sets the first
    letter of the given string to uppercase:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有使用样式来使文本大写，所以我们需要使用JavaScript。`capitalize`函数非常简单，它将给定字符串的第一个字母设置为大写：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are almost done with this component. All that''s left are the `styles`.
    Let''s open the `/UserList/styles.js` file and add styles for the main container
    and the toolbar:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了这个组件。剩下的只有`styles`。让我们打开`/UserList/styles.js`文件，并为主容器和工具栏添加样式：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, for each row, we want to render the image of each contact on the left,
    and the contact''s name and phone number on the right:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于每一行，我们希望在左边呈现每个联系人的图像，右边是联系人的姓名和电话号码：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s switch over to the `App.js` file and remove the `paddingTop` property
    we used for making text legible in *step 7*; the line to be removed is shown in
    bold:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们切换到`App.js`文件，并删除我们在*步骤7*中用于使文本可读的`paddingTop`属性；要删除的行已用粗体显示：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we try to run our app, we should be able to see a really nice list on the
    phone as well as the tablet, and the same component on the two different devices:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试运行我们的应用程序，我们应该能够在手机和平板上看到一个非常漂亮的列表，并且在两个不同的设备上看到相同的组件：
- en: '![](assets/3a0e3972-6f01-4526-855d-67962d131503.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3a0e3972-6f01-4526-855d-67962d131503.png)'
- en: 'We are already displaying two different layouts based on the current device!
    Now we need to work on the `UserDetail` view, which will show the selected contact.
    Let''s open `App.js`, import the `UserDetail` views, and update the `renderDetail` method,
    as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经根据当前设备显示了两种不同的布局！现在我们需要在`UserDetail`视图上进行工作，它将显示所选的联系人。让我们打开`App.js`，导入`UserDetail`视图，并更新`renderDetail`方法，如下所示：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As mentioned earlier, in this recipe, we are not focusing on sending data from
    one component to another, but instead on rendering a different layout in tablets
    and phones. Therefore, we will always send the first record to the user details
    view for this recipe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这个食谱中，我们不专注于从一个组件向另一个组件发送数据，而是专注于在平板电脑和手机上呈现不同的布局。因此，对于这个食谱，我们将始终将第一条记录发送到用户详细信息视图。
- en: 'To make things simple and to make the recipe as short as possible, for the
    user details view, we will only display a toolbar and some text showing the first
    and last name of the given record. We are going to use a stateless component here:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化事情并尽可能缩短食谱，对于用户详细信息视图，我们将只显示一个工具栏和一些显示给定记录的名字和姓氏的文本。我们将在这里使用一个无状态组件：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to style this component. We want to assign three-quarters
    of the screen to the details page and one-quarter to the master list. This can
    be done easily by using flexbox. Since the `UserList` component has a `flex` property
    of `1`, we can set the `flex` property of `UserDetail` to `3`, allowing `UserDetail`
    to take up 75% of the screen. Here are the styles we''ll add to the `/UserDetail/styles.js` file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为这个组件设置样式。我们希望将屏幕的四分之三分配给详细页面，四分之一分配给主列表。这可以通过使用flexbox轻松实现。由于`UserList`组件具有`flex`属性为`1`，我们可以将`UserDetail`的`flex`属性设置为`3`，允许`UserDetail`占据屏幕的75%。以下是我们将添加到`/UserDetail/styles.js`文件的样式：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we try to run our app again, we will see that on the tablet, it will render
    a nice layout showing both the list view and the detail view, while on the phone
    it only shows the list of contacts:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次尝试运行我们的应用程序，我们会发现在平板上，它将呈现一个漂亮的布局，显示列表视图和详细视图，而在手机上，它只显示联系人列表。
- en: '![](assets/b50ed65a-c2a9-4d6a-bb60-d8c18e038932.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b50ed65a-c2a9-4d6a-bb60-d8c18e038932.png)'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the `Device` utility, we imported a dependency that React Native provides
    called `Dimension` for getting the dimensions of the current device. We also defined
    a `tablet` constant in the `Device` utility, which is an object containing the `width` and `height`
    that is used with `Dimension` to calculate whether the device is a tablet or not.
    The values of this constant are based on the smallest Android tablet available
    on the market.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Device`实用程序中，我们导入了React Native提供的名为`Dimension`的依赖项，用于获取当前设备的尺寸。我们还在`Device`实用程序中定义了一个名为`tablet`的常量，它是一个包含`width`和`height`的对象，用于与`Dimension`一起计算设备是否为平板电脑。这个常量的值是基于市场上最小的Android平板电脑。
- en: In *step 5*, we got the width and height by calling the `Dimensions.get("window")` method,
    and then we got the maximum and minimum values depending on the orientation we
    wanted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们通过调用`Dimensions.get("window")`方法获得了宽度和高度，然后根据我们想要的方向获得了最大值和最小值。
- en: In *step 12*, it's important to note that we used an arrow function to define
    the `renderContact` method. Using an arrow function keeps the correct binding
    scope, otherwise, the `this` in the call to `this.capitalize` would be bound to
    the wrong scope. Check the *See also *section for more information on how both
    the `this` keyword and arrow functions work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤12*中，重要的是要注意我们使用箭头函数来定义`renderContact`方法。使用箭头函数可以保持正确的绑定范围，否则，在调用`this.capitalize`时，`this`将绑定到错误的范围。查看*另请参阅*部分，了解有关`this`关键字和箭头函数工作原理的更多信息。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A good explanation of ES6 arrow functions from ponyfoo at [https://ponyfoo.com/articles/es6-arrow-functions-in-depth](https://ponyfoo.com/articles/es6-arrow-functions-in-depth)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ponyfoo的[https://ponyfoo.com/articles/es6-arrow-functions-in-depth]中获得了对ES6箭头函数的良好解释。
- en: An in-depth look at how `this` works in JavaScript by Kyle Simpson at [https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kyle Simpson在[https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md]深入探讨了JavaScript中`this`的工作原理。
- en: Detecting orientation changes
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测方向变化
- en: When building complex interfaces, it's very common to render different UI components,
    based on the device's orientation. This is especially true when dealing with tablets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建复杂的界面时，根据设备的方向渲染不同的UI组件是非常常见的。这在处理平板电脑时尤其如此。
- en: In this recipe, we will render a menu based on screen orientation. In landscape,
    we will render an expanded menu with icons and texts, and in portrait, we will
    only render the icons.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将根据屏幕方向渲染菜单。在横向时，我们将渲染一个带有图标和文本的扩展菜单，而在纵向时，我们只会渲染图标。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To support orientation changes, we are going to use Expo's helper utility called
    `ScreenOrientation`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持方向变化，我们将使用Expo的辅助工具`ScreenOrientation`。
- en: We will also use the `FontAwesome` component provided by the Expo package `@expo/vector-icons`.
    The *Using font icons* recipe in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App, *describes how to use this component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Expo软件包`@expo/vector-icons`提供的`FontAwesome`组件。[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中的*使用字体图标*一节描述了如何使用这个组件。
- en: Before we get started, let's create a new app called `screen-orientation`. We'll
    also need to make a tweak to the `app.json` file that Expo creates in the root
    of the directory. This file has a few basic settings Expo uses when building the
    app. One of these settings is `orientation`, which is automatically set to `portrait` for
    every new app. This setting determines the orientations the app allows, and can
    be set to `portrait`, `landscape`, or `default`. If we change this to `default`,
    our app will allow both portrait and landscape orientations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们创建一个名为`screen-orientation`的新应用程序。我们还需要对Expo在目录根目录中创建的`app.json`文件进行微调。这个文件有一些Expo在构建应用程序时使用的基本设置。其中之一是`orientation`，它自动设置为`portrait`，用于每个新应用程序。此设置确定应用程序允许的方向，并且可以设置为`portrait`、`landscape`或`default`。如果我们将其更改为`default`，我们的应用程序将允许纵向和横向方向。
- en: To see these changes take effect, be sure to restart your Expo project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这些更改生效，请确保重新启动Expo项目。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start by opening `App.js` and adding the imports we''ll be using:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先打开`App.js`并添加我们将使用的导入：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we''ll add the empty `App` class for the component, along with some basic
    styles:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加空的`App`组件类，以及一些基本样式：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the shell of our app in place, we can now add the `render` method. In
    the `render` method, you''ll notice we''ve got a `View` component using the `onLayout`
    property, which will fire off whenever the orientation of the device changes.
    The `onLayout` will then run `this.handleLayoutChange`, which we will define in
    the next step. In the `Text` element, we simply display the value of `orientation`
    on the `state` object:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序框架就位后，我们现在可以添加`render`方法。在`render`方法中，您会注意到我们使用了`View`组件，并使用了`onLayout`属性，这将在设备方向发生变化时触发。然后`onLayout`将运行`this.handleLayoutChange`，我们将在下一步中定义。在`Text`元素中，我们只是显示`state`对象上`orientation`的值：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s create the `handleLayoutChange` method of our component, as well as
    the `getOrientation` function that the `handleLayoutChange` method calls. The `getOrientation` function
    uses the React Native `Dimensions` utility to get the width and height of the
    screen. If `height > width`, we know that the device is in portrait orientation,
    and if not, then it is in landscape orientation. By updating `state`, a re-render
    will be initiated, and the value of `this.state.orientation` will reflect the
    orientation:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建组件的`handleLayoutChange`方法，以及`handleLayoutChange`方法调用的`getOrientation`函数。`getOrientation`函数使用React
    Native的`Dimensions`工具来获取屏幕的宽度和高度。如果`height > width`，我们就知道设备处于纵向方向，如果不是，那么它就是横向方向。通过更新`state`，将启动重新渲染，并且`this.state.orientation`的值将反映方向：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the app at this point, we''ll get the error TypeError: null is not
    an object: (evaluating ''this.state.orientation''). This happens because the `render`
    method is attempting to read from the `this.state.orientation` value before it''s
    even been defined. We can easily fix this problem by getting the orientation before
    `render` runs for the first time, via the React life cycle `componentWillMount` hook:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们此时运行应用程序，将会得到错误类型错误：null不是对象：（评估'this.state.orientation'）。这是因为`render`方法试图在`this.state.orientation`值甚至被定义之前读取它。我们可以通过React生命周期`componentWillMount`钩子在`render`首次运行之前轻松解决这个问题来获取方向：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That''s all it takes to get the basic functionality we''re looking for! Run
    the app again and you should see the displayed text reflect the orientation of
    the device. Rotate the device, and the orientation text should update:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们寻找的基本功能所需的全部内容！再次运行应用程序，您应该看到显示的文本反映了设备的方向。旋转设备，方向文本应该更新：
- en: '![](assets/23ba5cc4-36e7-4728-ac3a-3bc00b4846fa.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23ba5cc4-36e7-4728-ac3a-3bc00b4846fa.png)'
- en: 'Now that the orientation `state` value is updating properly, we can focus on
    the UI. As mentioned before, we will create a menu that renders the options slightly
    differently based on the current orientation. Let''s import a `Menu` component,
    which we''ll build out in the next steps, and update the `render` method of our
    `App` component to use the new `Menu` component. Notice that we are now passing
    `this.state.orientation` to the `orientation` property of the `Menu` component:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`orientation`状态值已经正确更新，我们可以专注于UI。如前所述，我们将创建一个菜单，根据当前方向稍微不同地呈现选项。让我们导入一个`Menu`组件，我们将在接下来的步骤中构建它，并更新我们的`App`组件的`render`方法以使用新的`Menu`组件。请注意，我们现在将`this.state.orientation`传递给`Menu`组件的`orientation`属性：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s also update the styles for our `App` component. You can replace the
    styles from *step 2* with the following code. By setting the `flexDirection` to `row` on
    the `container` styles, we''ll be able to display the two components horizontally:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也更新我们的`App`组件的样式。您可以用以下代码替换*步骤2*中的样式。通过在`container`样式上将`flexDirection`设置为`row`，我们将能够水平显示两个组件：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let''s build out the `Menu` component. We''ll need to create a new `/Menu/index.js` file,
    which will define the `Menu` class. This component will receive the `orientation` property
    and decide how to render the menu options based on the `orientation` value. Let''s
    start by importing the dependencies for this class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建`Menu`组件。我们需要创建一个新的`/Menu/index.js`文件，其中将定义`Menu`类。这个组件将接收`orientation`属性，并根据`orientation`值决定如何呈现菜单选项。让我们首先导入这个类的依赖项：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can define the `Menu` class. On the `state` object, we will define an
    array of `options`. These `option` objects will be used to define the icons. As
    discussed in the *Using font icons* recipe in the previous chapter we can define
    icons via keywords, as defined in the vector-icon directory, found at [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义`Menu`类。在`state`对象上，我们将定义一个`options`数组。这些`option`对象将用于定义图标。如前一章中的*使用字体图标*中讨论的，我们可以通过关键字来定义图标，如在[https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/)中的矢量图标目录中定义的那样：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `render` method for this component loops through the array of `options` in
    the `state` object:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件的`render`方法循环遍历`state`对象中的`options`数组：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, inside the JSX in the last step, there''s a call to `renderOption`.
    In this method, we are going to render the icon and the label for each option.
    We''ll also use the orientation value to toggle showing the label, and to change
    the icon''s size:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您在上一步中的JSX中所看到的，有一个对`renderOption`的调用。在这个方法中，我们将为每个选项呈现图标和标签。我们还将使用方向值来切换显示标签，并更改图标的大小：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code block, notice that we are defining a `key` property. When
    dynamically creating a new component, we always need to set a `key` property.
    This property should be unique for each item, since it's used internally by React.
    In this case, we are using the index of the loop iteration. This way, we can be
    assured that every item will have a unique `key` value since the data is static.
    You can read more about it in the official documentation at [https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码块中，请注意我们正在定义`key`属性。在动态创建新组件时，我们总是需要设置`key`属性。该属性对于每个项目应该是唯一的，因为它在内部被React使用。在这种情况下，我们使用循环迭代的索引。这样，我们可以确保每个项目都有一个唯一的`key`值，因为数据是静态的。您可以在官方文档中阅读更多关于它的信息[https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html)。
- en: 'Finally, we''ll define the styles for the menu. First, we will set the `backgroundColor` to
    dark blue, and then, for each option, we''ll change the `flexDirection` to render
    the icon and label horizontally. The rest of the styles add margins and paddings
    so that the menu items are nicely spaced apart:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将为菜单定义样式。首先，我们将把`backgroundColor`设置为深蓝色，然后，对于每个选项，我们将改变`flexDirection`以水平渲染图标和标签。其余的样式添加边距和填充，以便菜单项之间有很好的间距：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run our application now, it will display the menu UI differently depending
    on the orientation of the screen. Rotate the device, and the layout will automatically
    update:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，它将根据屏幕的方向不同显示菜单UI。旋转设备，布局将自动更新：
- en: '![](assets/12a5ad38-0756-4ed5-a189-2f3e4412e2c1.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12a5ad38-0756-4ed5-a189-2f3e4412e2c1.png)'
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we had a look at the `app.json` file that exists as part of
    every Expo project. There are many useful settings that can be adjusted in this
    file that affect the build process of the project. You can use this file to adjust
    orientation lock, define an app icon, and set a splash screen, among many other
    settings. You can review all of the settings supported by `app.json` in the Expo
    configuration documentation, hosted at [https://docs.expo.io/versions/latest/guides/configuration.html](https://docs.expo.io/versions/latest/guides/configuration.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们查看了作为每个Expo项目一部分存在的`app.json`文件。在这个文件中有许多有用的设置，可以调整这些设置会影响项目的构建过程。您可以使用这个文件来调整方向锁定，定义应用程序图标，并设置启动画面，以及其他许多设置。您可以在Expo配置文档中查看`app.json`支持的所有设置，托管在[https://docs.expo.io/versions/latest/guides/configuration.html](https://docs.expo.io/versions/latest/guides/configuration.html)。
- en: Expo also provides the `ScreenOrientation` utility, which can be used instead
    to declare the allowed orientations for your app. Using the utility's main method
    `ScreenOrientation.allow(orientation)`, will overwrite the corresponding setting
    in `app.json`. The utility also provides more granular options than the setting
    in `app.json`, such as `ALL_BUT_UPSIDE_DOWN` and `LANDSCAPE_RIGHT`. For more on
    this utility, you can read the documentation at [https://docs.expo.io/versions/latest/sdk/screen-orientation.html](https://docs.expo.io/versions/latest/sdk/screen-orientation.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Expo还提供了`ScreenOrientation`实用程序，可以用来声明应用程序的允许方向。使用实用程序的主要方法`ScreenOrientation.allow(orientation)`，将覆盖`app.json`中的相应设置。该实用程序还提供比`app.json`中设置更精细的选项，例如`ALL_BUT_UPSIDE_DOWN`和`LANDSCAPE_RIGHT`。有关此实用程序的更多信息，您可以阅读文档[https://docs.expo.io/versions/latest/sdk/screen-orientation.html](https://docs.expo.io/versions/latest/sdk/screen-orientation.html)。
- en: Using a WebView to embed external websites
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebView嵌入外部网站
- en: For many applications, it's required that external links can be visited and
    displayed within the app. This can be for showing a third-party website, online
    help, and the terms and conditions of using your app, among other things.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序，需要访问和在应用程序中显示外部链接是必需的。这可以用于显示第三方网站、在线帮助以及使用您的应用程序的条款和条件等。
- en: In this recipe, we will see how to open a WebView by clicking on a button in
    our app and dynamically setting the URL value. We'll also be using the `react-navigation`
    package for creating basic stack navigation in this recipe. Please check out the
    *Setting up and using navigation* recipe in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I* for a deeper dive into building navigation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看到如何在我们的应用程序中通过点击按钮打开一个WebView，并动态设置URL值。我们还将在这个教程中使用`react-navigation`包来创建基本的堆栈导航。请查看[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)中的*设置和使用导航*教程，深入了解构建导航。
- en: If the needs of your app are better met by loading external websites via the
    device's browser, see the next recipe, *Linking to websites and other applications*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序更适合通过设备浏览器加载外部网站，请参阅下一个教程*链接到网站和其他应用程序*。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need to create a new app for our WebView-based recipe. Let''s name
    our new app `web-view`. We''ll also be using `react-navigation`, so be sure to
    install this as well. You can use `yarn` or `npm` to install the package. In the
    root of the project, run the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为基于WebView的教程创建一个新的应用程序。让我们将我们的新应用命名为`web-view`。我们还将使用`react-navigation`，所以一定要安装这个包。您可以使用`yarn`或`npm`来安装这个包。在项目的根目录中，运行以下命令：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, install them using `npm`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`npm`进行安装：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening the `App.js` file. In this file, we''ll be using the
    `StackNavigator` component provided by the `react-navigation` package. First,
    let''s add the imports we''ll be using in this file. `HomeScreen` is a component
    we will be building later in this recipe:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`App.js`文件开始。在这个文件中，我们将使用`react-navigation`包提供的`StackNavigator`组件。首先，让我们添加在这个文件中将要使用的导入。`HomeScreen`是我们将在本教程中稍后构建的一个组件：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have our imports, let''s use the `StackNavigator` component to
    define the first route; we''ll be using a `Home` route with links that should
    be displayed using the React Native `WebView` component. The `navigationOptions`
    property allows us to define a title to be displayed in the navigation header:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了导入，让我们使用`StackNavigator`组件来定义第一个路由；我们将使用一个带有链接的`Home`路由，这些链接应该使用React
    Native的`WebView`组件显示。`navigationOptions`属性允许我们定义要在导航标题中显示的标题：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We are now ready to create the `HomeScreen` component. Let''s create a new
    folder in the root of our project, called `HomeScreen`, and add an `index.js`
    file to the folder. As usual, we can begin with our imports:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好创建`HomeScreen`组件了。让我们在项目的根目录中创建一个名为`HomeScreen`的新文件夹，并在文件夹中添加一个`index.js`文件。和往常一样，我们可以从导入开始：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can declare our `HomeScreen` component. Let''s also add a `state` object
    to the component with a `links` array. This array has an object for each link
    we''ll be using in this component. I''ve provided four `links` for you to use;
    however, you can edit the `title` and `url` in each `links` array object to any
    websites you''d like:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以声明我们的`HomeScreen`组件。让我们还向组件添加一个`state`对象，其中包含一个`links`数组。这个数组中有一个对象，代表我们将在这个组件中使用的每个链接。我已经为您提供了四个`links`供您使用；但是，您可以编辑每个`links`数组对象中的`title`和`url`到任何您喜欢的网站：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''re ready to add a `render` function to this component. Here, we are using
    the `SafeAreaView` for the container element. This works just like a normal `View`
    element, but also accounts for the notch area on the iPhone X so that no part
    of our layout is obscured by the device bezels. You''ll notice that we are using `map` to
    map over the `links` array from the previous step, passing each one to the `renderButton`
    function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备向该组件添加一个`render`函数。在这里，我们使用`SafeAreaView`作为容器元素。这与普通的`View`元素一样工作，但也考虑了iPhone
    X上的刘海区域，以便我们的布局不会被设备边框遮挡。您会注意到我们正在使用`map`来遍历上一步中的`links`数组，将每个传递给`renderButton`函数：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we have defined the `render` method, we'll need to create the `renderButton`
    method that it's using. This method takes each link as a parameter called `button`,
    and the `index`, which we'll use as the unique `key` for each element `renderButton`
    is creating. For more on this point, see the *Tip*in *step 12* of the second recipe
    in this chapter, *Detecting orientation changes*.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`render`方法，我们需要创建它正在使用的`renderButton`方法。该方法将每个链接作为名为`button`的参数，并且我们将使用`index`作为`key`的唯一标识符，用于`renderButton`创建的每个元素。有关此点的更多信息，请参见本章第二个食谱中*检测方向更改*的*步骤12*中的*提示*。
- en: 'The `TouchableOpacity` button element will fire `this.handleButtonPress(button)`
    when pressed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下`TouchableOpacity`按钮元素时，将触发`this.handleButtonPress(button)`：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we need to create the `handleButtonPress` method used in the previous step.
    This method uses the `url` and `title` properties from the passed-in `button`
    parameter. We can then use these in a call to `this.properties.navigation.navigate()`,
    passing in the name of the route we want to navigate to and the parameters that
    should be passed along to that route. We have access to a `property` called `navigation`
    because we are using `StackNavigator`, which we set up in *step 2*:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建`handleButtonPress`方法，该方法在上一步中使用。此方法使用传入的`button`参数的`url`和`title`属性。然后，我们可以在调用`this.properties.navigation.navigate()`时使用这些属性，传递要导航到的路由的名称和应传递到该路由的参数。我们可以访问名为`navigation`的`property`，因为我们正在使用`StackNavigator`，这是我们在*步骤2*中设置的：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `HomeScreen` component is done, except for the styles. Let''s add a `styles.js`
    file in the `HomeScreen` folder to define these styles:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HomeScreen`组件已经完成，除了样式。让我们在`HomeScreen`文件夹中添加一个`styles.js`文件来定义这些样式：'
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, if we open the app, we should see the `HomeScreen` component being rendered
    with our list of four link buttons, and a header with the title Home rendered
    in the native style on each device. Since there is no `Browser` route in our `StackNavigator`,
    however, the buttons will not actually do anything when pressed:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们打开应用程序，我们应该看到`HomeScreen`组件呈现为带有四个链接按钮的列表，并且在每个设备上以本机样式呈现标题为Home。然而，由于我们的`StackNavigator`中没有`Browser`路由，当按下按钮时实际上不会发生任何事情：
- en: '![](assets/b705e213-90c2-4eb1-b741-7a9a48c1835f.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b705e213-90c2-4eb1-b741-7a9a48c1835f.png)'
- en: 'Let''s return to the `App.js` file and add the `Browser` route. First, we''ll
    need to import the `BrowserScreen` component, which we''ll create in the following
    steps:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们返回`App.js`文件并添加`Browser`路由。首先，我们需要导入`BrowserScreen`组件，我们将在接下来的步骤中创建：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that the `BrowserScreen` component has been imported, we can add it to
    the `StackNavigator` object to create a `Browser` route. In `navigationOptions`,
    we''re defining a dynamic title based on the parameters passed to the route. These
    parameters are the same as the object we passed into the `navigation.navigate()` call
    as the second argument in *step 7*:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`BrowserScreen`组件已经被导入，我们可以将它添加到`StackNavigator`对象中，以创建一个`Browser`路由。在`navigationOptions`中，我们正在根据传递给路由的参数定义动态标题。这些参数与我们在*步骤7*中作为第二个参数传递给`navigation.navigate()`调用的对象相同：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are ready to create the `BrowserScreen` component. Let''s create a new folder
    in the root of the project called `BrowserScreen` with a new `index.js` file inside,
    then add the imports this component needs:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备创建`BrowserScreen`组件。让我们在项目的根目录中创建一个名为`BrowserScreen`的新文件夹，并在其中添加一个新的`index.js`文件，然后添加此组件所需的导入：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `BrowserScreen` component is fairly simple. It consists only of a render
    method that reads the `params` property from the `navigation.state` property passed
    in to call to the `this.properties.navigation.navigate` that fires when a button
    is pressed, as defined in *step 7*. All we need to do is render the `WebView`
    component and set its `source` property to an object with the `uri` property set
    to `params.url`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BrowserScreen`组件非常简单。它只包括一个渲染方法，该方法从传递给`navigation.state`属性的`params`属性中读取，以调用在*步骤7*中定义的`this.properties.navigation.navigate`，当按下按钮时触发。我们只需要渲染`WebView`组件并将其`source`属性设置为具有`uri`属性设置为`params.url`的对象：'
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, if we go back to the app running in the simulator, we can see our WebView
    in action!
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们回到模拟器中运行的应用程序，我们可以看到我们的WebView在运行！
- en: '![](assets/9fedd5d4-07d4-46c1-bfe4-2d0069f7c5e1.png)Hacker News and Smashing
    Magazine visited from our app'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9fedd5d4-07d4-46c1-bfe4-2d0069f7c5e1.png)Hacker News和Smashing Magazine从我们的应用程序中访问'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using a WebView to open external sites is a great way to allow a user to consume
    external websites while keeping them in our app. Many applications out there do
    this, allowing the user to return to the main portion of the app easily.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WebView`打开外部网站是让用户在我们的应用程序中消费外部网站的好方法。许多应用程序都这样做，允许用户轻松返回到应用程序的主要部分。
- en: In *step 6*, we used an arrow function to bind the function in the `onPress`
    property to the scope of the current class instance, since we are using this function
    when looping through the array of links.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们使用箭头函数将`onPress`属性中的函数绑定到当前类实例的范围，因为我们在循环遍历链接数组时使用了这个函数。
- en: In *step 7*, whenever a button is pressed, we use the title and URL that are
    bound to that button, passing them along as parameters as we navigate to the `Browser`
    screen. The `navigationOptions` in *step 11* use this same title value as the
    title of the screen. The `navigationOptions` take a function whose first parameter
    is an object containing `navigation`, which provides the parameters used when
    navigating. In *step 11*, we structure navigation from this object so that we
    can set the view's title to `navigation.state.params.title`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，每当按下按钮时，我们使用绑定到该按钮的标题和URL，将它们作为参数传递，当我们导航到`Browser`屏幕时。 *步骤11*中的`navigationOptions`使用相同的标题值作为屏幕的标题。`navigationOptions`接受一个函数，其第一个参数是包含`navigation`的对象，该对象在导航时使用参数。在*步骤11*中，我们从这个对象中构造导航，以便我们可以将视图的标题设置为`navigation.state.params.title`。
- en: Thanks to the `StackNavigator` component provided by `react-navigation`, we
    get a header with OS-specific animations, built in with a back button. You can
    read the `StackNavigation` documentation for more information on this component
    at [https://reactnavigation.org/docs/stack-navigator.html](https://reactnavigation.org/docs/stack-navigator.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`react-navigation`提供的`StackNavigator`组件，我们得到了一个具有特定于操作系统的动画和内置返回按钮的标题。您可以阅读`StackNavigation`文档，了解有关此组件的更多信息[https://reactnavigation.org/docs/stack-navigator.html](https://reactnavigation.org/docs/stack-navigator.html)。
- en: '*Step 13* uses the URL passed to the `BrowserScreen` component to render a
    WebView by using the URL in the WebView''s `source` property. You can find a list
    of all available WebView properties in the official documentation located at [https://facebook.github.io/react-native/docs/webview.html](https://facebook.github.io/react-native/docs/webview.html).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*第13步*使用传递给`BrowserScreen`组件的URL来使用WebView，在WebView的`source`属性中使用URL来呈现。您可以在官方文档中找到所有可用的WebView属性列表，位于[https://facebook.github.io/react-native/docs/webview.html](https://facebook.github.io/react-native/docs/webview.html)。'
- en: Linking to websites and other applications
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接到网站和其他应用程序
- en: We have learned how to use a WebView to render a third-party website as an embedded
    part of our app. However, sometimes, we might want to use the native browser to
    open a site, link to other native system applications (such as email, phone, and
    SMS), or even deep link to a completely separate app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用`WebView`将第三方网站呈现为我们应用程序的嵌入部分。然而，有时候，我们可能希望使用原生浏览器打开网站，链接到其他原生系统应用程序（如电子邮件、电话和短信），甚至深层链接到一个完全独立的应用程序。
- en: 'In this recipe, we will link to an external site via both the native browser
    and a browser modal within our app, create links to the phone and messaging applications,
    and create a deep link that will open the Slack app and automatically load the
    #general channel in the [gitconnected.com](http://gitconnected.com) Slack group.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过原生浏览器和应用程序内的浏览器模态链接到外部网站，创建到电话和消息应用程序的链接，并创建一个深层链接，将打开Slack应用程序并自动加载[gitconnected.com](http://gitconnected.com)
    Slack群中的#general频道。
- en: You will need to run this app on a real device in order to open the links in
    this app that use the device's system applications, such as email, phone, and
    SMS links. In my experience, this will not work in the simulator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在真实设备上运行此应用程序，以便在此应用程序中打开使用设备系统应用程序的链接，例如电子邮件、电话和短信链接。根据我的经验，这在模拟器中是行不通的。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a new app for this recipe. We'll call it `linking-app`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个配方创建一个新的应用程序。我们将其称为`linking-app`。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s start by opening `App.js` and adding the imports we''ll be using:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`App.js`并添加我们将要使用的导入开始：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, let''s add both an `App` component and a `state` object. In this app,
    the `state` object will house all of the links that we''ll be using in this recipe
    in an array called `links`. Notice how the `url` property in each `links` object
    has a protocol attached to it (`tel`, `mailto`, `sms`, and so on). These protocols
    are used by the device to properly handle each link:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`App`组件和一个`state`对象。在这个应用程序中，`state`对象将包含我们在这个配方中将使用的所有链接，放在一个名为`links`的数组中。请注意，每个`links`对象中的`url`属性都附有一个协议（`tel`、`mailto`、`sms`等）。设备使用这些协议来正确处理每个链接：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The phone number used in the Text Support and Call Support buttons is an unused
    number at the time of writing, as generated by [https://fakenumber.org/](https://fakenumber.org/).
    This number is likely to still be unused, but this could possibly change. Feel
    free to use a different fake number for these links, just make sure to keep the
    protocol in place.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本支持和呼叫支持按钮中使用的电话号码是在撰写时未使用的号码，由[https://fakenumber.org/](https://fakenumber.org/)生成。这个号码很可能仍然未被使用，但这可能会发生变化。请随意为这些链接使用不同的虚假号码，只需确保保持协议不变。
- en: 'Next, let''s add the `render` function for our app. The JSX here is simple:
    we map over the `state.links` array from the previous step, passing each to our
    `renderButton` function defined in the next step:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的应用程序添加`render`函数。这里的JSX很简单：我们从上一步中的`state.links`数组中映射，将每个传递给我们在下一步中定义的`renderButton`函数：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s build out the `renderButton` method used in the last step. For each
    link, we create a button with `TouchableOpacity` and set the `onPress` property
    to execute the `handleButtonPress` and pass it the `button` property:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来构建上一步中使用的`renderButton`方法。对于每个链接，我们使用`TouchableOpacity`创建一个按钮，并将`onPress`属性设置为执行`handleButtonPress`并传递`button`属性：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we can build out the `handleButtonPress` function. Here, we'll be using
    the `type` property that we've added to each object in the `links` array. If the
    type is `'internal link'`, we want to open the URL *within* our app using the
    Expo `WebBrowser` component's `openBrowserAsync` method, and for everything else,
    we'll use the React Native `Linking` component's `openURL` method.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以构建`handleButtonPress`函数。在这里，我们将使用`links`数组中每个对象中添加的`type`属性。如果类型是`'internal
    link'`，我们希望使用Expo的`WebBrowser`组件的`openBrowserAsync`方法在我们的应用程序中打开URL，并且对于其他所有情况，我们将使用React
    Native的`Linking`组件的`openURL`方法。
- en: 'If there''s a problem with the `openURL` call and the URL is using the `slack://`
    protocol, it means the device does not know how to handle the protocol, probably
    because the slack app isn''t installed. We''ll handle this problem with the `handleMissingApp`
    function, which we''ll add in the next step:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`openURL`调用出现问题，并且URL使用了`slack://`协议，这意味着设备不知道如何处理该协议，可能是因为Slack应用未安装。我们将使用`handleMissingApp`函数来处理这个问题，我们将在下一步中添加它：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now we can create our `handleMissingApp` function. Here, we use the React Native
    helper `Platform`, which provides information about the platform the app is running
    on. `Platform.OS` will always return the operating system, which, on phones, should
    always resolve to either `'ios'` or `'android'`. You can read more about the capabilities
    of `Platform` in the official documentation at [https://facebook.github.io/react-native/docs/platform-specific-code.html](https://facebook.github.io/react-native/docs/platform-specific-code.html).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`handleMissingApp`函数。在这里，我们使用React Native助手`Platform`，它提供有关应用程序运行的平台的信息。`Platform.OS`将始终返回操作系统，对于手机，应该始终解析为`'ios'`或`'android'`。您可以在官方文档中阅读有关`Platform`功能的更多信息[https://facebook.github.io/react-native/docs/platform-specific-code.html](https://facebook.github.io/react-native/docs/platform-specific-code.html)。
- en: 'If the link to the Slack app does not work as expected, we''ll use `Linking.openURL`
    again; this time, to open the app in the app store appropriate for the device:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Slack应用的链接不像预期那样工作，我们将再次使用`Linking.openURL`，这次是为了在适合设备的应用商店中打开应用程序：
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our app doesn''t have any styles yet, so let''s add some. Nothing fancy here,
    just aligning the buttons in the center of the screen, coloring and centering
    text, and providing padding on each button:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序还没有任何样式，所以让我们添加一些。这里没有什么花哨的东西，只是将按钮居中对齐在屏幕中，着色和居中文本，并在每个按钮上提供填充：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s all there is to this app. Once we load the app, there should be a column
    of buttons representing each of our links. The Call Support and Email Support buttons
    will not work on the iOS simulator. Run this recipe on a real device to see all
    of the links working properly.:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是这个应用程序的全部内容。一旦我们加载应用程序，应该会有一列按钮，代表我们的每个链接。`Call Support`和`Email Support`按钮在iOS模拟器上不起作用。在真实设备上运行此示例，以查看所有链接正常工作。
- en: '![](assets/1890e7a8-6817-493e-8dc8-4b1be726e421.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1890e7a8-6817-493e-8dc8-4b1be726e421.png)'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2*, we defined all the links that our app uses. Each link object has
    a `type` property that we use in the `handleButtonPress` method defined in *step
    5*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们定义了应用程序使用的所有链接。每个链接对象都有一个`type`属性，我们在*步骤5*中定义的`handleButtonPress`方法中使用它。
- en: This `handleButtonPress` function uses the link's type to determine which one
    of two strategies will be used. If the link's type is `'internal link'`, we want
    to open the link with the device browser as a modal that pops up within the app
    itself. For this purpose, we can use Expo's `WebBrowser` helper, passing the URL
    to its `openBrowserAsync` method. If the link's type is `'external link'`, we'll
    open the link with React Native's `Linking` helper. This lets you see the different
    ways you can open a website from your app.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `handleButtonPress` 函数使用链接的类型来确定将使用两种策略中的哪一种。如果链接的类型是 `'internal link'`，我们希望在应用程序内部弹出一个模态框，使用设备浏览器打开链接。为此，我们可以使用
    Expo 的 `WebBrowser` 助手，将 URL 传递给它的 `openBrowserAsync` 方法。如果链接的类型是 `'external link'`，我们将使用
    React Native 的 `Linking` 助手打开链接。这让您可以看到从应用程序中打开网站的不同方式。
- en: The `Linking` helper can handle protocols other than HTTP and HTTPS as well.
    By simply using the proper protocol in the link we pass to `Linking.openURL`,
    we can open the telephone (`tel:`), messaging (`sms:`), or email (`mailto:`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Linking` 助手还可以处理除了 HTTP 和 HTTPS 之外的其他协议。通过在传递给 `Linking.openURL` 的链接中简单地使用适当的协议，我们可以打开电话
    (`tel:`)、短信 (`sms:`) 或电子邮件 (`mailto:`)。'
- en: '`Linking.openURL` can also handle deep links to other applications, as long
    as the app you want to link to has a protocol for doing so, such as how we open
    Slack by using the `slack://` protocol. For more information on Slack''s deep
    linking protocol and what you can do with it, visit their documentation at [https://api.slack.com/docs/deep-linking](https://api.slack.com/docs/deep-linking).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Linking.openURL` 也可以处理到其他应用程序的深层链接，只要您要链接到的应用程序具有相应的协议，例如我们如何使用 `slack://`
    协议打开 Slack。有关 Slack 的深层链接协议以及您可以使用它做什么的更多信息，请访问他们的文档 [https://api.slack.com/docs/deep-linking](https://api.slack.com/docs/deep-linking)。'
- en: In *step 5*, we `catch` any error caused by calling `Linking.openURL`, check
    whether the error was caused by the Slack protocol using `message.includes('slack://')`,
    and if so, we know the Slack app is not installed on the device. In this case,
    we fire `handleMissingApp`, which opens the app store link for Slack using the
    appropriate link, as determined by `Platform.OS`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们通过调用 `Linking.openURL` 引起的任何错误，检查错误是否是由 Slack 协议引起的 `message.includes('slack://')`，如果是，我们知道
    Slack 应用程序未安装在设备上。在这种情况下，我们触发 `handleMissingApp`，使用由 `Platform.OS` 确定的适当链接打开 Slack
    的应用商店链接。
- en: See also
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation on the `Linking` module can be found at [https://docs.expo.io/versions/latest/guides/linking.html](https://docs.expo.io/versions/latest/guides/linking.html).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Linking` 模块的官方文档可以在 [https://docs.expo.io/versions/latest/guides/linking.html](https://docs.expo.io/versions/latest/guides/linking.html)
    找到。'
- en: Creating a form component
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个表单组件
- en: Most applications require a way to input data, whether it's a simple registration
    and login form or a more complex component with many input fields and controls.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要一种输入数据的方式，无论是一个简单的注册和登录表单，还是一个具有许多输入字段和控件的更复杂的组件。
- en: In this recipe, we will create a form component to handle text inputs. We will
    collect data using different keyboards, and show an alert message with the resulting
    information.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个表单组件来处理文本输入。我们将使用不同的键盘收集数据，并显示包含结果信息的警报消息。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create an empty app. Let's name it `user-form`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个空的应用。让我们把它命名为 `user-form`。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening `App.js` and adding our imports. The imports include
    the `UserForm` component that we''ll be building out in a later step:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先打开 `App.js` 并添加我们的导入。导入包括我们稍后将构建的 `UserForm` 组件：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Since this component is going to be very simple, we are going to create a stateless
    component for our `App`. We will only render a top toolbar inside a `ScrollView` for
    the `UserForm` component:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个组件将非常简单，我们将为我们的`App`创建一个无状态组件。我们将只在`UserForm`组件的`ScrollView`中渲染一个顶部工具栏：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need to add some styles to these components. We''ll add some colors and
    padding, as well as setting the `main` class to `flex: 1` to fill the remainder
    of the screen:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们需要为这些组件添加一些样式。我们将添加一些颜色和填充，还将把`main`类设置为`flex: 1`，以填充屏幕的其余部分：'
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We have defined the main `App` component. Now let''s get to work on the actual
    form. Let''s create a new directory called `UserForm` in the base of the project
    and add an `index.js` file. Then, we''ll import all the dependencies for this
    class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了主要的`App`组件。现在让我们开始实际的表单工作。让我们在项目的基础上创建一个名为`UserForm`的新目录，并添加一个`index.js`文件。然后，我们将为这个类导入所有的依赖项：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is the class that will render the inputs and keep track of the data. We
    are going to save the data on the `state` object, so we''ll start by initializing
    `state` as an empty object:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类将渲染输入并跟踪数据。我们将把数据保存在`state`对象上，所以我们将从初始化`state`作为空对象开始：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `render` method, we are going to define the components that we want
    to display, which in this case are three text inputs and a button. We are going
    to define a `renderTextfield` method that accepts a configuration object as a
    parameter. We''ll define the `name` of the field, the `placeholder`, and the `keyboard` type
    that should be used on the input. In addition, we''re also calling a `renderButton` method
    that will render the Save button:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们将定义我们想要显示的组件，这种情况下是三个文本输入和一个按钮。我们将定义一个`renderTextfield`方法，它接受一个配置对象作为参数。我们将定义字段的`name`、`placeholder`和应该在输入上使用的`keyboard`类型。此外，我们还调用一个`renderButton`方法，它将渲染保存按钮：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To render the text fields, we are going to use the `TextInput` component in
    our `renderTextfield` method. This `TextInput` component is provided by React
    Native and works on both iOS and Android. The `keyboardType` property allows us
    to set the keyboard that we want to use. The four available keyboards on both
    platforms are `default`, `numeric`, `email-address`, and `phone-pad`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要渲染文本字段，我们将在`renderTextfield`方法中使用`TextInput`组件。这个`TextInput`组件由React Native提供，在iOS和Android上都可以使用。`keyboardType`属性允许我们设置要使用的键盘。在两个平台上有四种可用的键盘，分别是`default`、`numeric`、`email-address`和`phone-pad`：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We already know how to render buttons and respond to the `Press` action. If
    this is unclear, I recommend reading the *Creating a reusable button with theme
    support* recipein [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经知道如何渲染按钮并响应`Press`操作。如果这不清楚，我建议阅读[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)中的*使用主题支持创建可重用按钮*配方，*实现复杂用户界面-第一部分*：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We need to define the `onPressButton` callback. For simplicity, we''ll just
    show an alert with the input data that we have on the `state` object:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义`onPressButton`回调。为简单起见，我们将只显示一个带有我们在`state`对象上的输入数据的警报：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We are almost done with this recipe! All we need to do is apply some styles
    – some colors, padding, and margins; nothing fancy really:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了这个配方！我们需要做的就是应用一些样式-一些颜色、填充和边距；真的没什么花哨的：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we run our app, we should be able to see a form that uses native controls
    on both Android and iOS, as expected:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行我们的应用程序，我们应该能够看到一个在Android和iOS上都使用本机控件的表单，这是预期的：
- en: '![](assets/d8fe94c6-7280-457d-9e40-bd332add30b9.png)You might not be able to
    see the keyboard as defined by `keyboardType` when running your app in a simulator.
    Run the app on a real device to ensure that the `keyboardType` is properly changing
    the keyboard for each `TextInput`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d8fe94c6-7280-457d-9e40-bd332add30b9.png)当在模拟器上运行应用程序时，您可能无法看到由`keyboardType`定义的键盘。在真实设备上运行应用程序，以确保`keyboardType`正确地为每个`TextInput`更改键盘。'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 8*, we defined the `TextInput` component. In React (and React Native),
    we can use two types of input: controlled and uncontrolled components. In this
    recipe, we're using controlled input components, as recommended by the React team.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8*中，我们定义了`TextInput`组件。在React（和React Native）中，我们可以使用两种类型的输入：受控和未受控组件。在这个示例中，我们正在使用受控输入组件，这是React团队推荐的。
- en: A controlled component will have a `value` property, and the component will
    always display the content of the `value` property. This means that we need a
    way to change the value when the user starts typing into the input. If we don't
    update that value, then the text in the input won't ever change, even if the user
    tries to type something.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 受控组件将有一个`value`属性，并且组件将始终显示`value`属性的内容。这意味着我们需要一种方法在用户开始输入时更改值。如果我们不更新该值，那么输入框中的文本永远不会改变，即使用户尝试输入东西。
- en: In order to update the `value`, we can use the `onChangeText` callback and set
    the new value. In this example, we are using the state to keep track of the data
    and we are setting a new key on the state with the content of the input.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新`value`，我们可以使用`onChangeText`回调并设置新值。在这个例子中，我们使用状态来跟踪数据，并在状态上设置一个新的键，其中包含输入的内容。
- en: An uncontrolled component, on the other hand, will not have a `value` property
    assigned. We can assign an initial value using the `defaultValue` property. Uncontrolled components
    have their own state, and we can get their value by using an `onChangeText` callback,
    just as we can with controlled components.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个未受控制的组件将不会有一个分配的`value`属性。我们可以使用`defaultValue`属性分配一个初始值。未受控制的组件有它们自己的状态，我们可以使用`onChangeText`回调来获取它们的值，就像我们可以使用受控组件一样。
