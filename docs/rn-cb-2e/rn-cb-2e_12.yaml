- en: Adding Native Functionality - Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加本机功能-第二部分
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Reacting to changes in application state
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应用程序状态变化做出反应
- en: Copying and pasting content
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制和粘贴内容
- en: Authenticating via touch ID or fingerprint sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过触摸ID或指纹传感器进行身份验证
- en: Hiding application content when multitasking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多任务处理时隐藏应用程序内容
- en: Background processing on iOS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上进行后台处理
- en: Background processing on Android
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上进行后台处理
- en: Playing audio files on iOS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上播放音频文件
- en: Playing audio files on Android
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上播放音频文件
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will continue with more recipes that touch on different
    aspects of writing React Native apps that interact with native iOS and Android
    code. We will cover example apps that leverage built-in and community created
    modules. The recipes cover a range of topics, from rendering a basic button to
    creating a multithreaded process that does not block the main application thread.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续介绍更多的食谱，涉及编写与本机iOS和Android代码交互的React Native应用程序的不同方面。我们将涵盖利用内置和社区创建的模块的示例应用程序。这些食谱涵盖了一系列主题，从渲染基本按钮到创建不阻塞主应用程序线程的多线程进程。
- en: Reacting to changes in application state
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对应用程序状态变化做出反应
- en: The average mobile device user has several apps that they use on a regular basis.
    Ideally, along with the other social media apps, games, media players, and more,
    users will also be using your React Native app. Any specific user may spend a
    short time in each application because he or she multitasks. What if we wanted
    to react to when the user leaves our app and re-enters? We could use this as a
    chance to sync data with the server, or to tell the user that we're happy to see
    them return, or to politely ask for a rating on the app store.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 普通移动设备用户通常会经常使用几个应用程序。理想情况下，除了其他社交媒体应用程序、游戏、媒体播放器等，用户还将使用您的React Native应用程序。任何特定的用户可能会在每个应用程序中花费很短的时间，因为他们在多任务处理。如果我们想要在用户离开我们的应用程序并重新进入时做出反应怎么办？我们可以利用这个机会与服务器同步数据，或者告诉用户我们很高兴看到他们回来，或者礼貌地要求在应用商店上对应用程序进行评分。
- en: This recipe will cover the basics of reacting to changes in the state of the
    application, which is to say reacting to when the app is in the foreground (active),
    background, or inactive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将涵盖应用程序状态变化的基础知识，也就是说，对应用程序处于前台（活动）、后台或非活动状态时做出反应。
- en: For this recipe, let's create a new pure React Native app titled `AppStateApp`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，让我们创建一个名为`AppStateApp`的新的纯React Native应用程序。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Fortunately, React Native provides support for listening to changes to the
    state of the app through the `AppState` module. Let''s begin building out the
    app by adding dependencies to the `App.js` file, as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，React Native提供了对应用程序状态变化的支持，通过`AppState`模块监听。让我们通过向`App.js`文件添加依赖项来开始构建应用程序，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the recipe, we''re going to keep track of the previous state to see where
    the user came from. If it''s their first time entering the app, we will welcome
    them, and if they''re returning, we will welcome them back instead. To do so,
    we need to keep a reference to the previous and current app states. We''ll use
    instance variables `previousAppState` and `currentAppStates` instead of using
    state for this purpose, simply to avoid potential naming confusion. We''ll use `state` to
    hold the status message to the user, as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将跟踪先前的状态，以查看用户来自何处。如果这是他们第一次进入应用程序，我们将欢迎他们，如果他们返回，我们将改为欢迎他们。为此，我们需要保留对先前和当前应用程序状态的引用。我们将使用实例变量`previousAppState`和`currentAppStates`来代替使用状态，只是为了避免潜在的命名混淆。我们将使用`state`来保存向用户的状态消息，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the component mounts, we''ll use the `AppState` component to add an event
    listener to the `change` event. Whenever the app''s state changes (for example,
    when the app is backgrounded), the `change` event will be fired, whereupon we''ll
    fire our `handleAppStateChange` handler, defined in the next step, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件挂载时，我们将使用`AppState`组件添加一个`change`事件的监听器。每当应用程序的状态发生变化（例如，当应用程序被置于后台时），将触发`change`事件，然后我们将触发下一步中定义的`handleAppStateChange`处理程序，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `handleAppStateChange` method will receive the `appState` as a parameter,
    which we can expect to be one of three strings: `inactive` if the app is unloaded
    from memory, `background` if the app is in memory and backgrounded, and `active` if
    the app is foregrounded. We''ll use a `switch` statement to update the `statusMessage` on `state` accordingly:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handleAppStateChange`方法将接收`appState`作为参数，我们可以期望它是三个字符串中的一个：如果应用程序从内存中卸载，则为`inactive`，如果应用程序在内存中并处于后台，则为`background`，如果应用程序在前台，则为`active`。我们将使用`switch`语句相应地更新`state`上的`statusMessage`：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `render` method is very basic in this recipe, since it only needs to display
    the status message to the user, as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法在这个示例中非常基础，因为它只需要向用户显示状态消息，如下所示：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The styles for this app are basic, adding font size, color, and margin, as
    follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该应用程序的样式很基础，包括字体大小、颜色和边距，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The completed app should now display the appropriate status message depending
    on the state of the app on a given device.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的应用程序现在应该根据设备上应用程序的状态显示适当的状态消息。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we made use of the built-in `AppState` module. The module listens
    to the `Activity` events on Android, and on iOS it uses `NSNotificationCenter` to
    register a listener on various `UIApplication` events. Note that both platforms
    support the `active` and `background` states; however, the `inactive` state is
    an iOS only concept. Android does not explicitly support the `inactive` state
    due to its multitasking implementation, so only toggles apps between `background` and `active` states.
    To achieve the equivalent of the iOS inactive state on Android, see the *Hiding
    application content w**hen multitasking *recipe later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们利用了内置的`AppState`模块。该模块监听Android上的`Activity`事件，在iOS上使用`NSNotificationCenter`在各种`UIApplication`事件上注册监听器。请注意，两个平台都支持`active`和`background`状态；然而，`inactive`状态是iOS独有的概念。由于Android的多任务处理实现，它不明确支持`inactive`状态，因此只在`background`和`active`状态之间切换应用程序。要在Android上实现等效于iOS不活动状态的效果，请参见本章后面的*在多任务处理时隐藏应用程序内容*示例。
- en: Copying and pasting content
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制和粘贴内容
- en: One of the most used features in both desktop and mobile operating systems is
    the clipboard for copying and pasting content. A common scenario on mobile is
    filling forms with lengthy text, such as long email addresses or passwords. Instead
    of typing it with a few typos, it would be easier to just open your contacts application
    and copy the email from there and paste it into your `TextInput` field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面和移动操作系统中最常用的功能之一是用于复制和粘贴内容的剪贴板。在移动设备上的常见情况是使用长文本填写表单，例如长电子邮件地址或密码。与其打字并出现几个拼写错误，不如直接打开您的联系人应用程序，从那里复制电子邮件并粘贴到您的`TextInput`字段中会更容易。
- en: This recipe will show a basic example on both Android and iOS of how we can
    copy and paste text inside our React Native application. In our sample app, we
    will have both a static `Text` view and a `TextInput` field that you can use to
    copy its contents to the clipboard. Also, there will be a button that outputs
    the contents of the clipboard to the view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示在Android和iOS上如何在React Native应用程序中复制和粘贴文本的基本示例。在我们的示例应用程序中，我们将有一个静态的`Text`视图和一个`TextInput`字段，您可以使用它来将其内容复制到剪贴板。此外，还将有一个按钮，用于将剪贴板的内容输出到视图中。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll create a pure React Native application titled `CopyPasteApp`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将创建一个名为 `CopyPasteApp` 的纯 React Native 应用程序。
- en: 'In this recipe, we will be using `react-native-button` again. Install it with
    `npm`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将再次使用 `react-native-button`。使用 `npm` 安装它：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, we can use `yarn`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `yarn`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start off by creating a `ClipboardText` component that both uses a `Text` component
    to display text and provides the ability to copy its contents to the clipboard
    via long press. Let''s create a `component` folder in the root of the project,
    and a `ClipboardText.js` file inside of it. We''ll start by importing dependencies,
    as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个 `ClipboardText` 组件，它既使用 `Text` 组件来显示文本，又提供了通过长按将其内容复制到剪贴板的功能。在项目的根目录下创建一个
    `component` 文件夹，并在其中创建一个 `ClipboardText.js` 文件。我们将首先导入依赖项，如下所示：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next we''ll define the `App` class and the initial `state`. We will use the `clipboardContent` property
    on `state` for storing text being pasted from the clipboard into the UI, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `App` 类和初始的 `state`。我们将使用 `state` 上的 `clipboardContent` 属性来存储从剪贴板粘贴到
    UI 中的文本，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The UI will have one `Text` component whose text will by copyable via long
    press. Let''s define the `copyToClipboard` method. We''ll grab the input via its `ref` (which
    we''ll define later), and access the component''s text via its `props.children` property.
    Once the text has been stored in a local variable, we simply pass it to the `setString` method
    of `Clipboard` to copy the text to the clipboard, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UI 将有一个 `Text` 组件，其文本可以通过长按进行复制。让我们定义 `copyToClipboard` 方法。我们将通过它的 `ref`（稍后我们将定义）获取输入，并通过其
    `props.children` 属性访问组件的文本。一旦文本被存储在一个本地变量中，我们只需将其传递给 `Clipboard` 的 `setString`
    方法，以将文本复制到剪贴板，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, we''ll also need a method that will paste text into the app''s UI
    from the clipboard. This method will use the  `getString` method of `Clipboard`,
    and save the returned string to the  `clipboardContent` property of `state`, re-rendering
    the app''s UI to reflect the pasted text, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们还需要一个方法，它将从剪贴板中粘贴文本到应用的 UI 中。这个方法将使用 `Clipboard` 的 `getString` 方法，并将返回的字符串保存到
    `state` 的 `clipboardContent` 属性中，重新渲染应用的 UI 以反映粘贴的文本，如下所示：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `render` method will be made up of two sections: the first is made of things
    to copy, and the second is a way for pasting text from the clipboard into the
    UI. Let''s start with the first section, which consists of a `Text` input whose `onLongPress` prop
    is wired to the `copyToClipboard` method we created in *step 3*, and a text input
    for normal native copy/pasting:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render` 方法将由两个部分组成：第一部分是要复制的内容，第二部分是从剪贴板粘贴文本到 UI 的方法。让我们从第一部分开始，它包括一个 `Text`
    输入，其 `onLongPress` 属性连接到我们在 *步骤 3* 中创建的 `copyToClipboard` 方法，以及一个用于正常本地复制/粘贴的文本输入：'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second portion of the UI consists of a `Text` component for displaying
    the current value saved in `clipboardContent` on `state`, and a button that will
    paste from the clipboard using the `getClipboardContent` method we defined in
    *step 4*:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UI 的第二部分包括一个 `Text` 组件，用于显示保存在 `state` 的 `clipboardContent` 中的当前值，并一个按钮，将使用我们在
    *步骤 4* 中定义的 `getClipboardContent` 方法从剪贴板中粘贴：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/77ae1f65-21d0-463c-8387-4dea842f92ce.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/77ae1f65-21d0-463c-8387-4dea842f92ce.png)'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we built a simple copy and paste application by using the `Clipboard` API
    provided by React Native. The `Clipboard` module currently only supports content
    of type `String`, even though the devices can copy more complicated data. This
    module makes using the clipboard as easy as calling the methods `setString` and `getString`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过使用React Native提供的`Clipboard`API构建了一个简单的复制粘贴应用程序。`Clipboard`模块目前仅支持`String`类型的内容，尽管设备可以复制更复杂的数据。这个模块使得使用剪贴板就像调用`setString`和`getString`方法一样简单。
- en: Authenticating via touch ID or fingerprint sensor
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过指纹识别或指纹传感器进行认证
- en: Security is a paramount concern in software, especially when there is any sort
    of authentication. Breaches and leaked passwords have become a part of the daily
    news cycle, and companies of all sizes are wising up to the need for implementing
    added security measures in their apps. One such measure in mobile devices is biometric
    authentication, which uses fingerprint scanning or face recognition technology
    to provide supplementary identification methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 安全在软件中是一个重要的问题，特别是在任何形式的认证时。数据泄露和密码泄露已经成为日常新闻的一部分，各种规模的公司都在意识到需要在他们的应用程序中实施额外的安全措施。移动设备中的一种措施是生物识别认证，它使用指纹扫描或面部识别技术提供补充的身份验证方法。
- en: This recipe covers how to add fingerprint scanning and face recognition security.
    Thanks to the `react-native-touch-id` library, this process has been simplified
    and streamlined in React Native app development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例介绍了如何添加指纹扫描和面部识别安全功能。由于`react-native-touch-id`库的存在，这个过程在React Native应用程序开发中变得简化和流畅。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe we'll need a new pure React Native app. Let's call it `BiometricAuth`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一个新的纯React Native应用。让我们称之为`BiometricAuth`。
- en: 'We''ll be using the `react-native-button` and `react-native-touch-id` libraries.
    Install them with `npm`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`react-native-button`和`react-native-touch-id`库。使用`npm`安装它们：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, we can use `yarn`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`yarn`：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once installed, `react-native-touch-id` will need to be linked, so be sure
    to follow up with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，`react-native-touch-id` 需要进行链接，所以请务必跟进：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Permissions will also need to be adjusted manually. For Android permissions,
    locate the `AndroidManifest.xml` file in the project, which should be at `BiometricAuth/android/app/src/main/AndroidManifest.xml`.
    Along with the other permissions in this file, you''ll need to add the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 权限也需要手动调整。对于Android权限，请在项目中找到`AndroidManifest.xml`文件，应该在`BiometricAuth/android/app/src/main/AndroidManifest.xml`。除了这个文件中的其他权限，你还需要添加以下内容：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For iOS permissions, you''ll need to update the `Info.plist` file in a text
    editor. The `Info.plist` can be found at `BiometricAuth/ios/BiometricAuth/Info.plist`.
    Along with all the other entries, add the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS权限，你需要在文本编辑器中更新`Info.plist`文件。`Info.plist`可以在`BiometricAuth/ios/BiometricAuth/Info.plist`找到。除了所有其他条目，添加以下内容：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by adding dependencies to the `App.js` file, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`App.js`文件中添加依赖项，如下所示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we''ll define that `App` class and the initial `state`. We''ll keep track
    of the authentication status on the `authStatus` property of `state`, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`App`类和初始`state`。我们将在`state`的`authStatus`属性上跟踪认证状态，如下所示：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s define the `authenticate` method, which will be fired on button press,
    and will initiate authentication on the device. We can initiate authentication
    by executing the `TouchID` component''s `authenticate` method. This method''s
    first parameter is an optional string explaining the reason for the request, as
    follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`authenticate`方法，它将在按钮按下时触发，并在设备上启动认证。我们可以通过执行`TouchID`组件的`authenticate`方法来启动认证。这个方法的第一个参数是一个可选的字符串，解释请求的原因，如下所示：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This method fires the `handleAuthSuccess` method on success. Let''s define
    it now. This method simply updates the `authStatus` property of `state` to the
    string `Authenticated`, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法在成功时触发`handleAuthSuccess`方法。让我们现在来定义它。这个方法简单地将`state`的`authStatus`属性更新为字符串`Authenticated`，如下所示：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, if authentication fails, the `handleAuthFailure` function will be
    called, which will update the same `state.authStatus` to the string `Not Authenticated`,
    as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，如果身份验证失败，将调用`handleAuthFailure`函数，该函数将更新相同的`state.authStatus`为字符串`Not Authenticated`，如下所示：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `render` method will need a button to initiate the authentication request,
    and two `Text` components: one for a label, and one to display the authentication
    status, as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法将需要一个按钮来发起身份验证请求，以及两个`Text`组件：一个用于标签，一个用于显示身份验证状态，如下所示：'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we''ll add styles to color, size, and layout the UI, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加样式来设置UI的颜色、大小和布局，如下所示：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe has illustrated how simple it is to incorporate native fingerprint
    and facial recognition security into a React Native app. The call to `TouchID.authenticate` also
    takes a second, optional options object parameter with three properties: `title` for
    the title of the confirmation dialog (Android only), `color` for the color of
    the dialog (Android only), and a `fallbackLabel`  for editing the default Show
    Password label (iOS only).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程演示了将原生指纹和面部识别安全性简单地整合到React Native应用程序中的方法。调用`TouchID.authenticate`还需要一个可选的选项对象参数，其中包括三个属性：`title`用于确认对话框的标题（仅限Android），`color`用于对话框的颜色（仅限Android），以及`fallbackLabel`用于编辑默认的“显示密码”标签（仅限iOS）。
- en: Hiding application content when multitasking
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多任务处理时隐藏应用程序内容
- en: Keeping the theme of application security going, we have to be wary sometimes
    of unwanted eyes and hands touching our devices and potentially getting access
    to our applications. In order to protect the user from prying eyes while looking
    at sensitive information, we can mask our application when the application is
    hidden, but still active. Once the user returns to the application, we would simply
    remove the mask and the user can continue using the app as normal. A good use
    case for this would be in a banking or password app that hides sensitive information
    when the app is not in the foreground.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 保持应用程序安全主题的进行，有时我们必须警惕不速之客触摸我们的设备，可能获取对我们应用程序的访问权限。为了保护用户在查看敏感信息时免受窥视，我们可以在应用程序隐藏但仍处于活动状态时对应用程序进行遮罩。一旦用户返回到应用程序，我们只需移除遮罩，用户就可以继续正常使用应用程序。这在银行或密码应用程序中隐藏敏感信息时是一个很好的使用案例。
- en: This recipe will show you how to render an image to mask your application and
    remove it once the application returns to the foreground or active state. We will
    cover both iOS and Android; however, the implementation varies in its entirety.
    For iOS, we employ a pure Objective-C implementation for optimal performance.
    For Android, we're going to have to make some modifications to the `MainActivity` in
    order to send an event to our JavaScript layer that the application has lost focus.
    We will handle the rendering of the image mask there.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向你展示如何渲染一个图像来遮罩你的应用程序，并在应用程序返回到前台或活动状态时将其移除。我们将涵盖iOS和Android；然而，实现方式完全不同。对于iOS，我们采用纯Objective-C实现以获得最佳性能。对于Android，我们需要对`MainActivity`进行一些修改，以便向JavaScript层发送应用程序失去焦点的事件。我们将在那里处理图像遮罩的渲染。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''re going to need an image handy to use as the mask when the app is not
    foregrounded. I chose to use an iPhone wallpaper, which you can find at:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序不在前台时，我们需要一个图像来用作遮罩。我选择使用了一张iPhone壁纸，你可以在这里找到：
- en: '[http://www.hdiphone7wallpapers.com/2016/09/white-squares-iphone-7-and-7-plus-wallpapers.html](http://www.hdiphone7wallpapers.com/2016/09/white-squares-iphone-7-and-7-plus-wallpapers.html)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.hdiphone7wallpapers.com/2016/09/white-squares-iphone-7-and-7-plus-wallpapers.html](http://www.hdiphone7wallpapers.com/2016/09/white-squares-iphone-7-and-7-plus-wallpapers.html)'
- en: 'The image is a sort of stylized mosaic pattern. It looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像是一种风格化的马赛克图案。它看起来像这样：
- en: '![](assets/a329bd35-49fe-44b3-bcc3-a6e257a9ed5a.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a329bd35-49fe-44b3-bcc3-a6e257a9ed5a.jpg)'
- en: You can of course use whatever image you'd like. In this recipe, the image file
    will be named `hidden.jpg`, so rename your image accordingly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用任何您喜欢的图像。在这个示例中，图像文件将被命名为`hidden.jpg`，因此请相应地重命名您的图像。
- en: We'll need a new pure React Native app. Let's call it `HiddenContentApp`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新的纯React Native应用程序。让我们称之为`HiddenContentApp`。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's begin by adding the mask image to the iOS portion of the app. We'll need
    to open the `ios` folder of the project in Xcode, located in the `ios/` directory
    of the new React Native app.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先将面具图像添加到应用程序的iOS部分。我们需要在新的React Native应用程序的`ios/`目录中的Xcode中打开项目的`ios`文件夹。
- en: 'We can add the `hidden.jpg` image to the project by dragging and dropping the
    image into the `Images.xcassets` folder of the project in Xcode, as shown in this
    screenshot:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将图像拖放到Xcode项目的`Images.xcassets`文件夹中来将`hidden.jpg`图像添加到项目中，如下图所示：
- en: '![](assets/7a2e117f-9a1d-4c3f-952c-282f501c07f5.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a2e117f-9a1d-4c3f-952c-282f501c07f5.png)'
- en: 'Next we''ll add a new implementation and two methods to the `AppDelegate.m` file.
    The entirety of the file can be found as follows, including generated code. The
    code we''re adding is marked in bold for clarity. We''re extending the `applicationWillResignActive` method,
    which will fire whenever a given app changes from being foregrounded, to add an `imageView` with
    the `hidden.jpg` as its image. Similarly, we also need to extend the opposite
    method, `applicationDidBecomeActive`, to remove the image when the app is re-foregrounded:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向`AppDelegate.m`文件添加一个新的实现和两种方法。可以在下面找到整个文件，包括生成的代码。为了清晰起见，我们添加的代码已用粗体标记。我们正在扩展`applicationWillResignActive`方法，每当给定应用程序从前台变为后台时，它都会触发，以添加一个带有`hidden.jpg`作为其图像的`imageView`。同样，我们还需要扩展相反的方法`applicationDidBecomeActive`，以在应用程序重新进入前台时删除图像：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the previous three steps, all of the work required for displaying the mask
    in the iOS app is complete. Let's move on to the Android portion by opening the
    Android portion of the project in Android Studio. In Android Studio, select Open
    an existing Android Studio project and open the `android` directory of the project.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过前面的三个步骤，iOS应用程序中显示面具所需的所有工作已经完成。让我们通过在Android Studio中打开项目的Android部分来继续进行。在Android
    Studio中，选择打开现有的Android Studio项目，并打开项目的`android`目录。
- en: 'The only native code we''ll need to update in the Android project lives in `MainActivity.java`,
    located here:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新Android项目中的唯一本地代码位于`MainActivity.java`中，位于此处：
- en: '![](assets/752fe834-c63d-4a90-8d38-b145c84a551a.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/752fe834-c63d-4a90-8d38-b145c84a551a.png)'
- en: 'We''ll need to add one method, as well as the three imports from React that
    the method uses. Again, the complete `MainActivity.java` file is below, with added
    code marked in bold. We''re defining an `onWindowFocusChanged` method that extends
    the base method''s functionality. The base `onWindowFocusChanged` Android method
    is fired whenever a given app''s focus has changed, passing with it a `hasFocus` Boolean
    representing whether the app has focus or not. Our extension will effectively
    pass that `hasFocus` Boolean from the parent method down to the React Native layer
    via an event we''re naming `focusChange`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个方法，以及方法使用的来自React的三个导入。下面是完整的`MainActivity.java`文件，加粗标记的是添加的代码。我们正在定义一个扩展基本方法功能的`onWindowFocusChanged`方法。基本的`onWindowFocusChanged`
    Android方法在给定应用程序的焦点发生变化时触发，传递一个表示应用程序是否具有焦点的`hasFocus`布尔值。我们的扩展将通过我们命名为`focusChange`的事件有效地将该`hasFocus`布尔值从父方法传递到React
    Native层，如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To use the  `hidden.jpg` mask image in Android, we'll need to also add it to
    the  React Native project. Let's create a new `assets` folder in the root of the
    React Native project, and add the `hidden.jpg` image file to the new folder.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Android中使用`hidden.jpg`遮罩图像，我们还需要将其添加到React Native项目中。让我们在React Native项目的根目录中创建一个新的`assets`文件夹，并将`hidden.jpg`图像文件添加到新文件夹中。
- en: 'With the native pieces in place, we''re ready to turn to the JavaScript portion
    of the app. Let''s add the imports we''ll be using to `App.js`, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了原生部分的基础，我们现在准备转向应用程序的JavaScript部分。让我们在`App.js`中添加我们将使用的导入，如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, let''s create the `App` class and the initial `state`. The `state` will
    only need a `showMask` Boolean, which will dictate if the mask should be displayed,
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`App`类和初始`state`。`state`只需要一个`showMask`布尔值，它将决定是否显示遮罩，如下所示：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the component mounts, we want to register an event listener to listen
    to events emitted from the native Android layer using the `DeviceEventEmitter`''s `addListener` method,
    passing the string `focusChange` as the name of the event to listen for as the
    first parameter, and a callback to execute as the second parameter. As you may
    recall, `focusChange` is the name we assigned the event in `MainActivity.java` in
    the `onWindowFocusChange` method in *step 5. *  Register the event listener as
    follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件挂载时，我们希望注册一个事件监听器，以便使用`DeviceEventEmitter`的`addListener`方法监听从原生Android层发出的事件，将字符串`focusChange`作为要监听的事件的名称作为第一个参数，并将要执行的回调作为第二个参数。您可能还记得，`focusChange`是我们在`MainActivity.java`中的`onWindowFocusChange`方法中分配的事件名称，在*步骤5*中注册事件监听器如下：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this step we will save the event listener to the class member `this.subscription`.
    This will allow for the event listener to be cleaned up once the component is
    unmounted. We achieve this by simply calling the `remove` method on `this.subscription`
    when the component unmounts, via the `componentWillUnmount` life cycle hook, as
    follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将把事件监听器保存到类成员`this.subscription`中。这将允许在组件卸载时清理事件监听器。我们只需在组件卸载时通过`componentWillUnmount`生命周期钩子调用`this.subscription`上的`remove`方法，如下所示：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s define the `onFocusChange` handler used in *step 9*. The method receives
    a `params` object with an `appHasFocus` Boolean that''s been passed from the native
    layer via the `onWindowFocusChanged` method defined in *step 5*. By setting the `showMask` Boolean
    on `state` to the inverse of the `appHasFocus` Boolean, we can use that in the `render` function
    to toggle displaying the `hidden.jpg` image, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义在*步骤9*中使用的`onFocusChange`处理程序。该方法接收一个`params`对象，其中包含通过*步骤5*中定义的`onWindowFocusChanged`方法从原生层传递的`appHasFocus`布尔值。通过将`state`上的`showMask`布尔值设置为`appHasFocus`布尔值的相反值，我们可以在`render`函数中使用它来切换显示`hidden.jpg`图像，如下所示：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `render` method''s main content is not important in this recipe, but we
    can use it to apply the `hidden.jpg` mask image when the `showMask` property on
    state is `true`, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法的主要内容在这个示例中并不重要，但我们可以使用它来在`state`的`showMask`属性为`true`时应用`hidden.jpg`蒙版图像，如下所示：'
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The app is complete. Once the app is loaded, you should be able to go to the
    app selection view (double pressing home on iOS, or the square button on Android)
    and see the mask image applied to the app when it is not foregrounded. Note that
    Android emulators may not properly apply the mask as expected, so this feature
    might require an Android device for testing:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经完成。一旦应用程序加载完成，您应该能够转到应用程序选择视图（在iOS上双击home，或在Android上按方形按钮），并在应用程序不在前台时看到应用的蒙版图像。请注意，Android模拟器可能无法按预期正确应用蒙版，因此这个功能可能需要使用Android设备进行测试。
- en: '![](assets/c97ae150-6166-44ee-a686-c3758bc11c7f.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c97ae150-6166-44ee-a686-c3758bc11c7f.png)'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe we've seen an example of having to use two separate approaches
    for accomplishing the same task. For iOS, we handled displaying the image mask exclusively in
    the native layer, without any need for the React Native layer. For Android, we
    used React Native to handle the image masking.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到了需要使用两种不同的方法来完成相同的任务。对于iOS，我们在本地层中独占地处理显示图像蒙版，而不需要React Native层。对于Android，我们使用React
    Native来处理图像蒙版。
- en: In *step 3* we extended two Objective-C methods: `applicationWillResignActive`,
    which fires when an app changes from being foregrounded, and `applicationDidBecomeActive`,
    which fires when the app is foregrounded. For each event, we simply toggle an `imageView` that
    displays the `hidden.jpg` image store in the `Images.xcassettes` folder in the
    Xcode project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们扩展了两个Objective-C方法：`applicationWillResignActive`，当应用程序从前台切换时触发，以及`applicationDidBecomeActive`，当应用程序进入前台时触发。对于每个事件，我们简单地切换显示在Xcode项目的`Images.xcassettes`文件夹中存储的`hidden.jpg`图像的`imageView`。
- en: 'In *step 5* we used the React class `RCTDeviceEventEmitter` from the `DeviceEventManagerModule` to
    emit an event named `focusChange`, passing along a `params` object with the `appHasFocus` boolean
    to the React Native layer, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们使用了React类`RCTDeviceEventEmitter`从`DeviceEventManagerModule`来发出一个名为`focusChange`的事件，传递一个带有`appHasFocus`布尔值的`params`对象到React
    Native层，如下所示：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In *step 9* we defined the `componentWillMount` life cycle hook, which sets
    up an event listener for this `focusChange` event that will be emitted from the
    native Android layer, firing the `onFocusChange` method, which will update the
    value of `state`'s `showMask` value based on the native `appHasFocus` value, triggering
    a rerender, displaying the mask as appropriate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们定义了`componentWillMount`生命周期钩子，为从本地Android层发出的`focusChange`事件设置了一个事件侦听器，触发`onFocusChange`方法，该方法将根据本地`appHasFocus`值更新`state`的`showMask`值，触发重新渲染，适当地显示蒙版。
- en: Background processing on iOS
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS上的后台处理
- en: Over the last several years, processing power in mobile devices has increased
    considerably. Users are demanding richer experiences and one method of achieving
    improved performance on modern mobile devices is via multithreading.  Most mobile
    devices today are powered by multicore processors, and their operating systems
    now offer developers easy abstractions for executing code in the background, without
    interfering with the performance of the app's UI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，移动设备的处理能力大大增加。用户要求更丰富的体验，实现在现代移动设备上改进性能的一种方法是通过多线程。大多数移动设备今天都由多核处理器驱动，它们的操作系统现在为开发人员提供了在后台执行代码的简单抽象，而不会干扰应用程序UI的性能。
- en: This recipe will cover both the use of iOS's **Grand Central Dispatch** (**GCD**) to
    execute asynchronous background processing on a new thread, and communicating
    back to the React Native layer when the processing is complete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将涵盖iOS的**Grand Central Dispatch**（**GCD**）的使用，以在新线程上执行异步后台处理，并在处理完成时与React
    Native层进行通信。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need a new pure React Native application. Let's name
    it `MultiThreadingApp`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一个新的纯React Native应用程序。让我们将其命名为`MultiThreadingApp`。
- en: 'We''ll also be using the `react-native-button` library. Install it with `npm`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`react-native-button`库。使用`npm`安装它：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we can use `yarn`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`yarn`：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll start by opening the iOS Project in Xcode, located in the `ios` directory
    of the new React Native app.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在新的React Native应用程序的`ios`目录中打开Xcode中的iOS项目。
- en: Let's add a new Cocoa class file named `BackgroundTaskManager` of subclass `NSObject`.
    Refer to the *Exposing Custom iOS Modules* recipe in this chapter for more details
    on doing this in Xcode.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个名为`BackgroundTaskManager`的新的Cocoa类文件，其子类为`NSObject`。有关在Xcode中执行此操作的更多详细信息，请参考本章中的*公开自定义iOS模块*示例。
- en: 'Next, lets wire the new module to the React `RCTBrideModule` in the new module''s
    header file, `BackgroundTaskManager.h`. The code to be added is marked in bold
    in the following snippet:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将新模块连接到React的`RCTBrideModule`，在新模块的头文件`BackgroundTaskManager.h`中。要添加的代码在以下片段中用粗体标记出来：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ll implement the native module in the `BackgroundTaskManager.m` file. Again,
    the new code we''re adding is marked in bold in the following snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`BackgroundTaskManager.m`文件中实现本机模块。同样，我们要添加的新代码在以下片段中用粗体标记出来：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s turn to the JavaScript layer next. We''ll start by adding dependencies
    to the `App.js` file. As part of the dependencies, we will also need to import
    the `BackgroundTaskManager` native module that we defined in *step 3* and *step
    4*, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来让我们转向JavaScript层。我们将首先在`App.js`文件中添加依赖项。作为依赖项的一部分，我们还需要导入在*步骤3*和*步骤4*中定义的`BackgroundTaskManager`本机模块，如下所示：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s define the `App` class, with an initial state of `backgroundTaskStatus`
    set to the string `Not Started`, and a `doNothingCount` property initialized to
    `0`, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`App`类，初始状态为`backgroundTaskStatus`设置为字符串`Not Started`，并且`doNothingCount`属性初始化为`0`，如下所示：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll need to listen to the `backgroundProcess` event that will be emitted
    from the native iOS layer from the custom module we created in *step 3* and *step
    4*. Let''s set up an event listener using the `NativeAppEventEmitter` React Native
    component, which sets the `backgroundTaskStatus` property of `state` to the value
    of `status` on the event object received from the native event, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要监听从我们在*步骤3*和*步骤4*中创建的自定义模块的本机iOS层发出的`backgroundProcess`事件。让我们使用`NativeAppEventEmitter`
    React Native组件设置事件监听器，将`state`的`backgroundTaskStatus`属性设置为从本机事件接收到的事件对象上的`status`值，如下所示：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When the component unmounts, we need to remove the event listener from the
    previous step, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件卸载时，我们需要从上一步中删除事件监听器，如下所示：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The UI will have two buttons that will each need a method to call when pressed.
    The `runBackgroundTask` will run the `loadInBackground` method that we defined
    and exported from the native iOS layer on the `BackgroundTaskManager` custom native
    module. The `increaseCounter` button will simply increase the `counter` property
    on `state` by `1`, serving to show how the main thread is not blocked, as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UI将有两个按钮，每个按钮在按下时都需要调用一个方法。`runBackgroundTask`将运行我们在本机iOS层上定义并导出的`loadInBackground`方法，该方法位于`BackgroundTaskManager`自定义本机模块上。`increaseCounter`按钮将简单地通过`1`增加`state`上的`counter`属性，以显示主线程未被阻塞的情况，如下所示：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The UI of the app will consist of two buttons to show the `Button` components,
    and a `Text` component for displaying the values saved on `state`. The Run Task button
    will execute the `runBackgroundTask` method to kick off a background process,
    and `this.state.backgroundTaskStatus` will update to display a new status for
    the process. For the five seconds that the background process is running, pressing
    the Increase Counter button will still increase the counter by `1`, demonstrating that
    the background process is non-blocking, as shown in the following snippet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用的UI将包括两个按钮来显示“Button”组件，以及一个“Text”组件来显示在“state”上保存的值。“Run Task”按钮将执行“runBackgroundTask”方法来启动后台进程，并且“this.state.backgroundTaskStatus”将更新以显示进程的新状态。在后台进程运行的五秒钟内，按下“Increase
    Counter”按钮仍然会增加计数器1，证明后台进程是非阻塞的，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As a final step, let''s layout and style the app with the styles block, as
    follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们使用样式块来布局和设计应用，如下所示：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we created a native module similar to the module covered in
    the *Exposing custom iOS modules* recipe from earlier in this chapter. We defined
    the native module to perform arbitrary execution in the background of the React
    Native app. In this recipe the background process is made up of the following
    three steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个类似于本章前面*暴露自定义iOS模块*示例中涵盖的模块的本地模块。我们定义了本地模块来在React Native应用的后台执行任意操作。在这个示例中，后台进程由以下三个步骤组成：
- en: Spawn a new thread.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的线程。
- en: Sleep for five seconds on the new thread.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新线程上睡眠五秒钟。
- en: After the five second sleep (simulating the end of a running background process),
    an event is dispatched from the iOS layer to the React Native layer, letting it
    know that the process has been completed. This is accomplished via the OS's GCD
    API.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在五秒的睡眠后（模拟运行后台进程的结束），从iOS层向React Native层分发一个事件，让它知道进程已经完成。这是通过操作系统的GCD API实现的。
- en: The purpose of the UI in this app is to exhibit that multithreading has been
    achieved. If the background process was executed in the React Native layer, due
    to JavaScript's single-threaded nature, the app would have locked up for five
    seconds while that process was running. When you press a button, the bridge is
    invoked, whereupon messages can be posted to the native layer. If the native thread
    is currently busy sleeping, then we cannot process this message. By offloading
    that processing to a new thread, both can be executed at the same time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的UI的目的是展示多线程已经实现。如果后台进程在React Native层执行，由于JavaScript的单线程特性，应用在后台进程运行时会被锁定五秒钟。当您按下按钮时，桥被调用，然后消息可以被发布到本地层。如果本地线程当前正在忙于睡眠，那么我们无法处理这条消息。通过将处理转移到新线程，两者可以同时执行。
- en: Background processing on Android
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上进行后台处理
- en: In this recipe we'll be building out an Android equivalent to the previous recipe.
    This recipe will also use the native Android layer to create a new process, keep
    that process running by sleeping for five seconds, and allow user interaction
    via the button to exhibit that the app's main processing thread is not blocked.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个Android版本的前一个示例的等价物。这个示例还将使用原生的Android层来创建一个新的进程，通过睡眠五秒钟来保持该进程运行，并允许用户通过按钮进行交互，以展示应用的主处理线程没有被阻塞。
- en: While the end result will be very much the same, spawning a new process in an
    Android project is handled a bit differently from iOS. This recipe will make use
    of the native `AsyncTask` function, specialized for handling short-running background
    processes, to allow execution in the React Native layer without blocking the main
    thread.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最终结果将是非常相似的，但在Android项目中生成一个新进程与iOS处理方式有些不同。这个示例将利用本地的`AsyncTask`函数，专门用于处理短期后台进程，以允许在React
    Native层执行而不阻塞主线程。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe we'll need to create a new pure React Native app. Let's name
    it `MultiThreadingApp`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要创建一个新的纯React Native应用。让我们命名它为`MultiThreadingApp`。
- en: 'We will also be using the `react-native-button` library. Install it with `npm`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`react-native-button`库。使用`npm`安装它：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, we can use `yarn`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`yarn`：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: Let's start by opening the Android project in Android Studio. In Android Studio,
    select Open an existing Android Studio project and open the `android` directory
    of the new project.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Android Studio中打开Android项目。在Android Studio中，选择打开现有的Android Studio项目，并打开新项目的`android`目录。
- en: 'We''ll need two new Java classes: `BackgroundTaskManager` and `BackgroundTaskPackage`.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个新的Java类：`BackgroundTaskManager`和`BackgroundTaskPackage`。
- en: 'Now that both classes have been created, let''s open `BackgroundTaskManager.java` and
    begin implementing the native module that will wrap an `AsyncTask` operation,
    starting with imports and defining the class. Furthermore, like any other native
    Android module, we''ll need to define the `getName` method, used to provide React
    Native with a name for the module, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这两个类都已创建，让我们打开`BackgroundTaskManager.java`并开始实现将包装`AsyncTask`操作的本地模块，从导入和定义类开始。此外，像任何其他本地Android模块一样，我们需要定义`getName`方法，用于为模块提供一个名称给React
    Native，如下所示：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to execute an `AsyncTask`, it needs to be subclassed by a private
    class. We''ll need to add a new private inner `BackgroundLoadTask` subclass for
    this. Before we define it, let''s first add a `loadInBackground` method that will
    ultimately be exported to the React Native layer. This method simply creates a
    new instance of `BackgroundLoadTask` and calls its `execute` method, as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了执行`AsyncTask`，它需要由一个私有类进行子类化。我们需要为此添加一个新的私有内部`BackgroundLoadTask`子类。在我们定义它之前，让我们首先添加一个`loadInBackground`方法，最终将被导出到React
    Native层。这个方法简单地创建一个`BackgroundLoadTask`的新实例并调用它的`execute`方法，如下所示：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `BackgroundLoadTask` subclass will also be using a helper function for
    sending events back and forth across the React Native bridge to communicate the
    status of the background process. The `sendEvent` method takes an `eventName` and `params` as
    arguments, then uses React Native''s `RCTDeviceEventEmitter` class to `emit` the
    event, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BackgroundLoadTask`子类还将使用一个辅助函数来来回发送事件，以跨越React Native桥通信后台进程的状态。`sendEvent`方法接受`eventName`和`params`作为参数，然后使用React
    Native的`RCTDeviceEventEmitter`类来`emit`事件，如下所示：'
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now let''s move on to defining the `BackgroundLoadTask` subclass, which extends `AsyncTask`.
    The subclass will be made up of three methods: `doInBackground` for spinning up
    a new thread and sleeping it for five minutes, `onProgressUpdate` for sending
    a `"Loading"` status to the React Native layer, and `onPostExecute` for sending
    a `"Done"` status when the background task has completed, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续定义`BackgroundLoadTask`子类，它继承自`AsyncTask`。子类将由三个方法组成：`doInBackground`用于启动一个新线程并让其休眠五分钟，`onProgressUpdate`用于向React
    Native层发送`"Loading"`状态，以及`onPostExecute`用于在后台任务完成时发送`"Done"`状态，如下所示：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since the only difference between the iOS implementation and the Android implementation
    lives in the native layer of the recipe, you can follow *step 5* to *step 11*
    of the previous recipe to implement the JavaScript portion of the app.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于iOS实现和Android实现之间的唯一区别存在于配方的本机层中，因此您可以按照上一个配方中的*步骤5*至*步骤11*来实现应用程序的JavaScript部分。
- en: 'The final app should behave and look (aside from differences in devices) the
    same as the app in the previous recipe:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该在行为和外观上（除了设备上的差异）与上一个配方中的应用程序相同：
- en: '![](assets/cbc6bfc5-4e0f-4d49-ae41-27748267819a.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/cbc6bfc5-4e0f-4d49-ae41-27748267819a.png)
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we mimicked the functionality we created in the *Background
    processing on iOS* recipe on Android. We created an Android native module with
    a method which, when invoked, performs arbitrary execution in the background (sleep
    for five seconds). When the process is complete, it emits an event to the React
    Native layer, whereupon we update the app UI to reflect the status of the background
    process. Android has multiple options for performing multithreaded operations
    natively. In this recipe, we used `AsyncTask`, since it is geared towards short-running
    (several seconds) processes, it is relatively simple to implement, and the operating
    system manages thread creation and resource allocation for us. You can read more
    about `AsyncTask` in the official documentation at:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们模仿了我们在Android上创建的*在iOS上进行后台处理*配方中创建的功能。我们创建了一个Android本机模块，其中一个方法在调用时在后台执行任意操作（休眠五秒）。当进程完成时，它会向React
    Native层发出事件，然后我们更新应用程序UI以反映后台进程的状态。Android有多个选项可以在本机执行多线程操作。在这个配方中，我们使用了`AsyncTask`，因为它适用于短期运行（几秒钟）的进程，相对简单实现，并且操作系统为我们管理线程创建和资源分配。您可以在官方文档中阅读更多关于`AsyncTask`的信息：
- en: '[https://developer.android.com/reference/android/os/AsyncTask](https://developer.android.com/reference/android/os/AsyncTask)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/reference/android/os/AsyncTask](https://developer.android.com/reference/android/os/AsyncTask)'
- en: Playing audio files on iOS
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在iOS上播放音频文件
- en: In the chapter *Implementing Complex User Interfaces – Part III*, we covered
    building out a relatively sophisticated little audio player in the *Creating an
    Audio Player* recipe using the `Audio` component provided by the Expo SDK. One
    of the shortcoming of Expo's `Audio` component, however, is that it cannot be
    used to play audio when the app is backgrounded. Using the native layer is currently
    the only way to achieve this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在*实现复杂用户界面-第三部分*章节中，我们使用Expo SDK提供的`Audio`组件在*创建音频播放器*配方中构建了一个相对复杂的小型音频播放器。然而，Expo的`Audio`组件的一个缺点是它无法在应用程序被置于后台时播放音频。目前使用本机层是实现这一点的唯一方法。
- en: In this recipe, we will create a native module to show the iOS MediaPicker and
    then select a music file to play. The selected file will play through the native iOS
    media player, which allows audio to be played when the app is backgrounded, and
    allows the user to control the audio via the native iOS control center.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个本机模块来显示iOS MediaPicker，然后选择要播放的音乐文件。所选文件将通过本机iOS媒体播放器播放，允许在应用程序被置于后台时播放音频，并允许用户通过本机iOS控制中心控制音频。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need to create a new pure React Native app. Let's call
    it `AudioPlayerApp`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要创建一个新的纯React Native应用。让我们称之为`AudioPlayerApp`。
- en: 'We''ll also be using the `react-native-button` library, which can be installed
    with `npm`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`react-native-button`库，可以使用`npm`安装：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Alternatively, we can use `yarn`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`yarn`：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is a recipe that should only be expected to work on a real device. You'll
    also want to make sure you have music synced to the iOS device and available in
    the media library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只能在真实设备上预期工作的示例。您还需要确保您的iOS设备上同步了音乐并且在媒体库中可用。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start by opening the iOS Project in Xcode located in the `ios` directory
    of the new React Native app.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在新的React Native应用程序的`ios`目录中打开Xcode中的iOS项目。
- en: Next, we'll create a new Objective-C Cocoa class called `MediaManager`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`MediaManager`的新的Objective-C Cocoa类。
- en: 'In the `MediaManager` header (`.h`) file, we need to import `MPMediaPickerController` and `MPMusicPlayerController`,
    along with the React Native bridge (`RCTBridgeModule`), as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MediaManager`头文件（`.h`）中，我们需要导入`MPMediaPickerController`和`MPMusicPlayerController`，以及React
    Native桥（`RCTBridgeModule`），如下所示：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'First, we are going to need to work on adding the native `MediaPicker` in the `MediaManager` implementation
    (`MediaManager.m`). The first methods will be for showing and hiding the `MediaPicker`: `showMediaPicker` and `hideMediaPicker`,
    as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要开始添加原生`MediaPicker`到`MediaManager`的实现（`MediaManager.m`）中。首先的方法将是用于显示和隐藏`MediaPicker`的：`showMediaPicker`和`hideMediaPicker`，如下所示：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we''ll implement the two actions that the `mediaPicker` needs: `didPickMediaItems` for
    picking a media item, and `mediaPickerDidCancel` for cancelling the action, as
    follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`mediaPicker`需要的两个操作：`didPickMediaItems`用于选择媒体项目，以及`mediaPickerDidCancel`用于取消操作，如下所示：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we''re going to need to expose our `MediaManager` to the React Native
    bridge and create a method that will be invoked to show the `MediaPicker`, as
    follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的`MediaManager`暴露给React Native桥，并创建一个将被调用以显示`MediaPicker`的方法，如下所示：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''re ready to move on to the JavaScript portion. Let''s start by adding dependencies
    to `App.js`. We also need to import the `MediaManager` native module we created
    in *step 3* to *step 6* using the `NativeModules` component, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备继续进行JavaScript部分。让我们首先在`App.js`中添加依赖项。我们还需要使用`NativeModules`组件导入我们在*步骤3*到*步骤6*中创建的`MediaManager`原生模块，如下所示：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s define the `App` class and the initial `state`. The `currentSong` property
    will hold the track info for the currently playing song, as passed from the native
    layer, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`App`类和初始`state`。`currentSong`属性将保存当前播放歌曲的曲目信息，如从原生层传递的那样：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When the component mounts, we''ll subscribe to the `SongPlaying` event that
    will be emitted from the native layer when a song begins playing. We''ll save
    the event listener to a local `subscription` class variable so that we can clean
    it up with the `remove` method when the component unmounts, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件挂载时，我们将订阅从原生层发出的`SongPlaying`事件，当歌曲开始播放时。我们将事件监听器保存到本地的`subscription`类变量中，以便在组件卸载时使用`remove`方法清除它，如下所示：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ll also need a method for updating the `currentSong` value on `state`,
    and a method for calling the `showSongs` method on the native `MediaManager` module
    we defined in *step 3* to *step 6,* as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来更新`state`上的`currentSong`值，并且需要一种方法来调用我们在*步骤3*到*步骤6*中定义的原生`MediaManager`模块上的`showSongs`方法，如下所示：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `render` method will be made up of a `Button` component for executing the `showSongs` method
    when pressed, and `Text` components for displaying the info for the song that''s
    currently playing, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法将由一个`Button`组件组成，用于在按下时执行`showSongs`方法，以及用于显示当前播放歌曲信息的`Text`组件，如下所示：'
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we''ll add our styles for laying out and styling the app, as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加我们的样式来布局和设计应用程序，如下所示：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we covered how to use the Media Player in iOS by wrapping its
    functionality in a native module. The media player framework allows us to access
    the native iPod library, and play audio files from the library on the device using
    the same functionality as the native iOS Music app.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们介绍了如何在iOS中使用`Media Player`，通过将其功能封装在一个本地模块中。媒体播放器框架允许我们访问本机iPod库，并使用与本机iOS音乐应用相同的功能在设备上播放库中的音频文件。
- en: Playing audio files on Android
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上播放音频文件
- en: A benefit that Google likes to claim that Android has over iOS is flexibility
    in dealing with file storage. Android devices support external SD cards that can
    be filled with media files and do not need a proprietary method of adding multimedia
    as iOS does.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌喜欢宣称Android相对于iOS具有处理文件存储的灵活性。Android设备支持外部SD卡，可以存储媒体文件，并不需要像iOS那样需要专有的方法来添加多媒体文件。
- en: In this recipe, we will use Android's native `MediaPicker`, which is started
    from an intent. We will then be able to pick a song and have it play through our
    application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用Android的本机`MediaPicker`，它是从一个意图开始的。然后我们将能够选择一首歌并通过我们的应用程序播放它。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll create a React Native application titled `AudioPlayer`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将创建一个名为`AudioPlayer`的React Native应用程序。
- en: 'In this recipe, we will use the `react-native-button` library. To install it,
    run the following command in the terminal from your project root directory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用`react-native-button`库。要安装它，请在项目根目录的终端中运行以下命令：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Make sure you have music files available in your `Music/` directory on your
    Android device or emulator.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Android设备或模拟器的`Music/`目录中有音乐文件可用。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start by opening the Android project using Android Studio. In Android
    Studio, select Open an existing Android Studio project and open the `android` directory
    of the project.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用Android Studio打开Android项目。在Android Studio中，选择“打开现有的Android Studio项目”，然后打开项目的`android`目录。
- en: We'll need two new Java classes for this recipe: `MediaManager` and `MediaPackage`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将需要两个新的Java类：`MediaManager`和`MediaPackage`。
- en: 'Our `MediaManager` will use intents to show the `mediaPicker`, `MediaPlayer` to
    play music, and `MediaMetadataRetriever` to parse metadata information from the
    audio file to send back to the JavaScript layer. Let''s start by importing all
    of the dependencies we''ll need in the `MediaManager.java` file, as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`MediaManager`将使用意图来显示`mediaPicker`，`MediaPlayer`来播放音乐，以及`MediaMetadataRetriever`来解析音频文件的元数据信息并发送回JavaScript层。让我们首先在`MediaManager.java`文件中导入我们需要的所有依赖项，如下所示：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`showSongs`, `getName`, `playSong`, `mediaPlayer`, `onActivityResult`, `mediaMetadataRetreiver`,
    and `SongPlaying` should be in code formatting. Replace with:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`showSongs`，`getName`，`playSong`，`mediaPlayer`，`onActivityResult`，`mediaMetadataRetreiver`和`SongPlaying`应该以代码格式显示。替换为：'
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The custom module will also need to be added to the `getPackages` array in
    the `MainApplication.java` file, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义模块还需要添加到`MainApplication.java`文件中的`getPackages`数组中，如下所示：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As covered in the *Exposing Custom Android Modules *recipe earlier in this
    chapter, we must add the requisite boilerplate to `MediaPackage.java` for our `MediaManager` custom
    module to be exported to the React Native layer. Refer to that recipe for a more
    thorough explanation. Add the requisite boilerplate as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如本章前面的*暴露自定义Android模块*教程中所介绍的，我们必须为我们的`MediaManager`自定义模块添加必要的样板，以便将其导出到React
    Native层。有关更详细的解释，请参考该教程。按照以下步骤添加必要的样板：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The JavaScript layer for the Android app is identical to that found in the previous
    iOS recipe. Use *step 7* to *step 12* of this recipe to complete the final portion
    of the app.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android应用程序的JavaScript层与之前的iOS教程中的相同。使用本教程的*步骤7*到*步骤12*来完成应用程序的最后部分。
