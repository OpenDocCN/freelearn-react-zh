- en: Creating a Simple React Native App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的React Native应用程序
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Adding styles to elements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向元素添加样式
- en: Using images to mimic a video player
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图像模拟视频播放器
- en: Creating a toggle button
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个切换按钮
- en: Displaying a list of items
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示项目列表
- en: Using flexbox to create a layout
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用flexbox创建布局
- en: Setting up and using navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用导航
- en: React Native is a fast-growing library. Over the last few years it has become
    very popular among the open source community. There's often a new release every
    other week that improves performance, adds new components, or provides access
    to new APIs on the device.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: React Native是一个快速增长的库。在过去的几年里，它在开源社区中变得非常受欢迎。几乎每隔一周就会有一个新版本发布，改进性能，添加新组件，或者提供对设备上新API的访问。
- en: In this chapter, we'll learn about the most common components in the library. To
    step through all of the recipes in this chapter, we'll have to create a new application,
    so make sure you have your environment up and running.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习库中最常见的组件。为了逐步完成本章中的所有配方，我们将不得不创建一个新的应用程序，所以确保您的环境已经准备就绪。
- en: Adding styles to elements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向元素添加样式
- en: We have several components at our disposal, but containers and text are the
    most common and useful components to create layouts or other components. In this
    recipe, we'll see how to use containers and text, but most importantly we'll see
    how styles work in React Native.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个组件可供使用，但容器和文本是创建布局或其他组件最常见和有用的组件。在这个配方中，我们将看到如何使用容器和文本，但更重要的是我们将看到样式在React
    Native中是如何工作的。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the instructions in the previous chapter in order to create a new application.
    We'll name this application `fake-music-player`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一章的说明创建一个新应用程序。我们将把这个应用程序命名为`fake-music-player`。
- en: When creating a new application with Expo, a small amount of boilerplate code
    will be added to the `App.js` file in the `root` folder. This will be the starting
    point of any React Native application you build. Feel free to remove all boilerplate
    at the beginning of each recipe, as all code (including what's used in the `App.js`
    boilerplate) will be discussed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Expo创建新应用程序时，`App.js`文件中的`root`文件夹将添加少量样板代码。这将是您构建的任何React Native应用程序的起点。随时在每个配方的开头删除所有样板代码，因为所有代码（包括在`App.js`样板中使用的代码）都将被讨论。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `App.js` file, we''re going to create a stateless component. This component
    will mimic a small music player. It will only display the name of the song and
    a bar to show the progress. The first step is importing our dependencies:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，我们将创建一个无状态组件。这个组件将模拟一个小型音乐播放器。它只会显示歌曲的名称和一个用来显示进度的条。第一步是导入我们的依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve imported the dependencies, we can build out the component:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们导入了依赖项，我们就可以构建组件：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have our component ready, so now we need to add some styles, to add colors
    and fonts:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的组件已经准备好了，现在我们需要添加一些样式，以添加颜色和字体：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As long as our simulator and emulator are running our application, we should
    see the changes:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要我们的模拟器和模拟器正在运行我们的应用程序，我们应该看到变化：
- en: '![](assets/b811e149-433a-4eb0-89bf-57e9676bc390.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b811e149-433a-4eb0-89bf-57e9676bc390.png)'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we included the dependencies of our component. In this case, we
    used `View`, which is a container. If you're familiar with web development, `View`
    is similar to `div`. We could add more `Views` inside other `Views`, `Texts`,
    `Lists`, and any other custom component that we create or import from a third-party
    library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们包含了我们组件的依赖项。在这种情况下，我们使用了`View`，它是一个容器。如果您熟悉Web开发，`View`类似于`div`。我们可以在其他`View`内添加更多的`View`，`Text`，`List`，以及我们创建或从第三方库导入的任何其他自定义组件。
- en: If you're familiar with React you'll notice that, this is a stateless component,
    which means it doesn't have any state; it's a pure function and doesn't support
    any of the life cycle methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉React，您会注意到，这是一个无状态组件，这意味着它没有任何状态；它是一个纯函数，不支持任何生命周期方法。
- en: We're defining a `name` constant in the component, but in real-world applications
    this data should come from the props. In the return, we're defining the **JavaScript XML **(**JSX**)
    that we're going to need to render our component, along with a reference to the
    styles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件中定义了一个`name`常量，但在实际应用中，这些数据应该来自props。在返回中，我们定义了我们需要渲染组件的**JavaScript XML **（**JSX**），以及对样式的引用。
- en: Each component has a attribute called `style`. This property receives an object
    with all of the styles that we want to apply to the given component. Styles are
    not inherited (except for the `Text` component) by the child components, which
    means we need to set individual styles for each component.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有一个名为`style`的属性。该属性接收一个包含我们想要应用于给定组件的所有样式的对象。样式不会被子组件继承（除了`Text`组件），这意味着我们需要为每个组件设置单独的样式。
- en: In *step 3*, we defined the styles for our component. We're using the `StyleSheet`
    API to create all of our styles. We could have used a plain object containing
    the styles, but by using the `StyleSheet` API instead of an object, we gain some
    performance optimizations, as the styles will be reused for every renderer, as
    opposed to creating an object every time the render method gets executed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们为我们的组件定义了样式。我们正在使用`StyleSheet` API来创建所有样式。我们本可以使用包含样式的普通对象，但是通过使用`StyleSheet`
    API而不是对象，我们可以获得一些性能优化，因为样式将被重用于每个渲染器，而不是在每次执行渲染方法时创建一个对象。
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'I''d like to call your attention to the definition of the `title` style in
    *step 3*. Here, we''ve defined a property called `backgroundColor` and set `transparent`
    as its value. As a good exercise, let''s comment this line of code and see the
    result:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要引起您对*步骤3*中`title`样式定义的注意。在这里，我们定义了一个名为`backgroundColor`的属性，并将`transparent`设置为其值。作为一个很好的练习，让我们注释掉这行代码并查看结果：
- en: '![](assets/92ede04a-de11-4f51-865a-d278c011698c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92ede04a-de11-4f51-865a-d278c011698c.png)'
- en: On iOS, the text will have an orange background color and it might not be what
    we really want to happen in our UI. In order to fix this, we need to set the background
    color of the text as transparent. But the question is, why is this happening?
    The reason is that React Native adds some optimizations to the text by setting
    the color from the parent's background color. This will improve the rendering
    performance because the rendering engine won't have to calculate the pixels around
    each letter of the text and the rendering will be executed faster.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，文本将具有橙色背景颜色，这可能不是我们真正想要在我们的UI中发生的事情。为了解决这个问题，我们需要将文本的背景颜色设置为透明。但问题是，为什么会发生这种情况？原因是React
    Native通过将颜色从父元素的背景颜色设置为文本添加了一些优化。这将提高渲染性能，因为渲染引擎不必计算文本每个字母周围的像素，渲染将更快地执行。
- en: Think carefully when setting the background color to `transparent`. If the component
    is going to be updating the content very frequently, there might be some performance
    issues with text, especially if the text is too long.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景颜色设置为`transparent`时要仔细考虑。如果组件将频繁更新内容，特别是如果文本太长，可能会出现一些性能问题。
- en: Using images to mimic a video player
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图像模仿视频播放器
- en: Images are an important part of any UI, whether we use them to display icons,
    avatars, or pictures. In this recipe, we'll use images to create a mock video
    player. We'll also display the icons from the local device and a large image from
    a remote server (hosted by Flickr).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是任何UI的重要组成部分，无论我们是用它们来显示图标、头像还是图片。在这个食谱中，我们将使用图像来创建一个模拟视频播放器。我们还将显示来自本地设备的图标和来自远程服务器（由Flickr托管）的大图像。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow the steps in this recipe, let's create a new application.
    We're going to name it `fake-video-player`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个食谱中的步骤，让我们创建一个新的应用程序。我们将把它命名为`fake-video-player`。
- en: We're going to display a few images in our application to mimic a video player,
    so you'll need corresponding images for your application. I recommend using the
    icons I used by downloading them from the repository for this recipe on GitHub
    at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/fake-video-player/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/fake-video-player/images).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中显示一些图像，以模仿视频播放器，所以您需要为您的应用程序准备相应的图像。我建议使用我在GitHub上的食谱存储库中下载的图标，网址为[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/fake-video-player/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/fake-video-player/images)。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first thing we're going to do is create a new folder called `Images` in
    the root of the project. Add the images you've downloaded to the new folder.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是在项目的根目录下创建一个名为`Images`的新文件夹。将您下载的图像添加到新文件夹中。
- en: 'In the `App.js` file, we include all of the dependencies we''ll need for this
    component:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，我们包括了这个组件所需的所有依赖项：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to `require` the images that''ll be displayed in our component. By
    defining them in constants, we can use the same image in different places:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要`require`在我们的组件中显示的图像。通过在常量中定义它们，我们可以在不同的地方使用相同的图像：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re going to use a stateless component to render the JSX. We''ll use all
    of the images we''ve declared in the previous step:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个无状态组件来渲染JSX。我们将使用在上一步中声明的所有图像。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have the elements that we''re going to render, we need to define the
    styles for each element:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了要渲染的元素，我们需要为每个元素定义样式：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''re done! Now, when you view the application, you should see something like
    the following:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们完成了！现在，当您查看应用程序时，您应该看到类似以下的内容：
- en: '![](assets/2570e533-9f2c-4a85-ae1d-6a02846bfa88.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2570e533-9f2c-4a85-ae1d-6a02846bfa88.png)'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2*, we required the `Image` component. This is the component responsible
    for rendering images from the local filesystem on the device or from a remote
    server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们需要`Image`组件。这是负责从设备的本地文件系统或远程服务器上渲染图像的组件。
- en: In *step 3*, we required all of the images. It's good practice to require the
    images outside of the component in order to only require them once. On every renderer,
    React Native will use the same image. If we were dealing with dynamic images from
    a remote server, then we'd need to require them on every renderer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们需要所有的图像。最好的做法是在组件外部需要图像，以便只需要一次。在每个渲染器上，React Native将使用相同的图像。如果我们处理来自远程服务器的动态图像，那么我们需要在每个渲染器上需要它们。
- en: The `require` function accepts the path of the image as a parameter. The path
    is relative to the folder that our class is in. For remote images, we need to
    use an object defining `uri` for where our file is.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`函数接受图像路径作为参数。路径是相对于我们类所在的文件夹的。对于远程图像，我们需要使用一个定义`uri`的对象来指定我们的文件在哪里。'
- en: In *step 4*, a stateless component was declared. We used `remoteImage` as the
    background of our application via an `ImageBackground` element, since `Image` elements
    cannot have child elements. This element acts similarly to the `background-url`
    property in CSS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，声明了一个无状态组件。我们使用 `remoteImage` 作为我们应用程序的背景，通过一个 `ImageBackground`
    元素，因为 `Image` 元素不能有子元素。这个元素类似于 CSS 中的 `background-url` 属性。
- en: 'The `source` property of `Image` accepts an object to load remote images or
    a reference to the required file. It''s very important to explicitly require every
    image that we want to use because when we prepare our application for distribution,
    images will be added to the bundle automatically. This is the reason we should
    avoid doing anything dynamic, such as the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image` 的 `source` 属性接受一个对象来加载远程图像或所需文件的引用。非常重要的是要明确地要求我们想要使用的每个图像，因为当我们准备我们的应用程序进行分发时，图像将自动添加到捆绑包中。这就是我们应该避免做任何动态操作的原因，比如以下操作：'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code won''t include the images in the final bundle. As a result,
    we''ll have errors when trying to access these images. Instead, we should refactor
    our code to something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不会将图像包含在最终的捆绑包中。因此，当尝试访问这些图像时，会出现错误。相反，我们应该将我们的代码重构为类似于这样的东西：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This way, the bundle will include both images when preparing our application
    for distribution, and we can decide which image to display dynamically at runtime.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当准备我们的应用程序进行分发时，捆绑包将包括两个图像，并且我们可以在运行时动态决定显示哪个图像。
- en: In *step 5*, we defined the styles. Most of the properties are self-explanatory.
    Even though the images we're using for icons are white, I've added the `tintColor`
    property to show how it can be used to color images. Give it a try! Change `tintColor`
    to `#f00` and watch the icons turn red.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们定义了样式。大多数属性都是不言自明的。尽管我们用于图标的图像是白色的，但我添加了 `tintColor` 属性来展示它如何用于着色图像。试一试！将
    `tintColor` 改为 `#f00`，看看图标变成红色。
- en: Flexbox is being used to align different portions of the layout. Flexbox in
    React Native behaves essentially the same as it does in web development. We'll
    discuss flexbox more in the *Using flexbox to create a layout* recipe later in
    this chapter, but the complexities of flexbox itself are outside the scope of
    this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox 被用来对齐布局的不同部分。在 React Native 中，Flexbox 的行为基本上与 web 开发中的行为相同。我们将在本章后面的
    *使用 flexbox 创建布局* 部分更多地讨论 flexbox，但是 flexbox 本身的复杂性超出了本书的范围。
- en: Creating a toggle button
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个切换按钮
- en: Buttons are an essential UI component in every application. In this recipe,
    we'll create a toggle button, which will be unselected by default. When the user
    taps on it, we'll change the styles applied to the button to make it appear selected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是每个应用程序中必不可少的 UI 组件。在这个部分中，我们将创建一个切换按钮，默认情况下将不被选中。当用户点击它时，我们将改变应用于按钮的样式，使其看起来被选中。
- en: We'll learn how to detect the tap event, use an image as the UI, keep the state
    of the button, and add styles based on the component state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何检测点击事件，使用图像作为 UI，保持按钮的状态，并根据组件状态添加样式。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a new app. We're going to name it `toggle-button`. We're going
    to use one image in this recipe. You can download the assets for this recipe from
    the corresponding repository hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/toggle-button/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/toggle-button/images).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的应用程序。我们将把它命名为 `toggle-button`。在这个部分中，我们将使用一张图片。您可以从 GitHub 上托管的相应存储库中下载这个部分的资产，网址为
    [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/toggle-button/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/toggle-button/images)。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We're going to create a new folder called `images` in the root of the project
    and add the heart image to the new folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在项目的根目录中创建一个名为`images`的新文件夹，并将心形图片添加到新文件夹中。
- en: 'Let''s import the dependencies for this class next:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入这个类的依赖项。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For this recipe, we need to keep track of whether the button has been pressed.
    We''ll use a `state` object with a `liked` Boolean property for this purpose.
    The initial class should look like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要跟踪按钮是否被按下。我们将使用一个带有`liked`布尔属性的`state`对象来实现这个目的。初始类应该是这样的：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to define the content of our new component inside the `render` method.
    Here, we''re going to define the `Image` button and a `Text` element underneath
    it:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`render`方法中定义我们新组件的内容。在这里，我们将定义`Image`按钮和其下方的`Text`元素：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s define some styles to set dimensions, position, margins, colors, and
    so on:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一些样式来设置尺寸、位置、边距、颜色等等：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the project on the simulators, we should have something similar
    to the following screenshot:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在模拟器上运行项目时，我们应该看到类似以下截图的内容：
- en: '![](assets/48d16278-db2d-4bd2-8c50-b6b59c3153f2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48d16278-db2d-4bd2-8c50-b6b59c3153f2.png)'
- en: 'In order to respond to the tap event, we need to define the content of the
    `handleButtonPress` function and assign it as a callback to the `onPress` property:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了响应触摸事件，我们需要定义`handleButtonPress`函数的内容，并将其分配为`onPress`属性的回调函数：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we test our code, we won''t see anything changing on the UI, even though
    the state on the component changes when we press the button. Let''s add a different
    color to the image when the state changes. That way, we''ll be able to see a response
    from the UI:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们测试我们的代码，我们不会看到UI上的任何变化，即使当我们按下按钮时组件上的状态发生变化。让我们在状态改变时为图片添加不同的颜色。这样，我们就能看到UI的响应：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2*, we imported the `TouchableHighlight` component. This is the component
    responsible for handling the touch event. When the user touches the active area,
    the content will be highlighted based on the `underlayColor` value we have set.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们导入了`TouchableHighlight`组件。这是负责处理触摸事件的组件。当用户触摸活动区域时，内容将根据我们设置的`underlayColor`值进行高亮显示。
- en: In *step 3*, we defined the state of `Component`. In this case, there's only
    one property on the state, but we can add as many as needed. In [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml),
    *Implementing Complex User Interfaces – Part I*, we'll see more recipes about
    handling the state in more complex scenarios.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们定义了`Component`的状态。在这种情况下，状态只有一个属性，但我们可以根据需要添加多个属性。在[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)中，*实现复杂用户界面-第一部分*，我们将看到更多关于在更复杂场景中处理状态的示例。
- en: In *step 6*, we used the `setState` method to change the value of the `liked`
    property. This method is inherited from the `Component` class that we're extending.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们使用`setState`方法来改变`liked`属性的值。这个方法是从我们正在扩展的`Component`类继承而来的。
- en: 'In *step 7*, based on the current state of the `liked` property, we used the
    styles to set the color of the image to red or we returned `undefined` to avoid
    applying any styles. When assigning the styles to the `Image` component, we used
    an array to assign many objects. This is very handy because the component will
    merge all of the styles into one single object internally. The objects with the
    highest index will overwrite the properties with the lowest object index in the
    array:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，基于`liked`属性的当前状态，我们使用样式将图片的颜色设置为红色，或者返回`undefined`以避免应用任何样式。当将样式分配给`Image`组件时，我们使用数组来分配多个对象。这非常方便，因为组件将所有样式合并为一个单一对象。具有最高索引的对象将覆盖数组中具有最低对象索引的属性：
- en: '![](assets/7af91424-5d64-4f7d-aa3e-72a9c2e7b3e1.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7af91424-5d64-4f7d-aa3e-72a9c2e7b3e1.png)'
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In a real application, we're going to use several buttons, sometimes with an
    icon aligned to the left, a label, different sizes, colors, and so on. It's highly
    recommended to create a reusable component to avoid duplicating code all over
    our app. In [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*, we'll create a button component to handle some
    of these scenarios.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们将使用多个按钮，有时带有左对齐的图标，标签，不同的大小，颜色等。强烈建议创建一个可重用的组件，以避免在整个应用程序中重复编写代码。在[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)，*实现复杂用户界面-第一部分*中，我们将创建一个按钮组件来处理其中一些情况。
- en: Displaying a list of items
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示项目列表
- en: 'Lists are everywhere: a list of orders in the user''s history, a list of available
    items in a store, a list of songs to play. Nearly any application will need to
    display some kind of information in a list.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表随处可见：用户历史记录中的订单列表，商店中可用商品的列表，要播放的歌曲列表。几乎任何应用程序都需要在列表中显示某种信息。
- en: For this recipe, we're going to display several items in a `list` component.
    We're going to define a JSON file with some data, then we're going to load this
    file using a simple `require` to finally render each item with a nice but simple
    layout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将在`list`组件中显示多个项目。我们将定义一个带有一些数据的JSON文件，然后使用简单的`require`加载此文件，最后使用漂亮但简单的布局渲染每个项目。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start by creating an empty app. We'll name this application `list-items`.
    We're going to need an icon to display on each item. The easiest way to get images
    is to download them from this recipe's repository hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/list-items/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/list-items/images).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个空应用程序开始。我们将把这个应用程序命名为`list-items`。我们需要一个图标来显示在每个项目上。获取图像的最简单方法是从托管在GitHub上的此示例的存储库中下载它们：[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/list-items/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/list-items/images)。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll start by creating an `images` folder and adding `basket.png` to it. Also,
    create an empty file in the root of the project called `sales.json`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`images`文件夹，并将`basket.png`添加到其中。还要在项目的根目录中创建一个名为`sales.json`的空文件。
- en: 'Inside the `sales.json` file, we''ll define the data that we''re going to display
    in the list. Here''s some sample data:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sales.json`文件中，我们将定义要在列表中显示的数据。以下是一些示例数据：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To avoid cluttering the pages of this book, I've only defined one record, but
    go ahead and add more content to the array. Copying and pasting the same object
    multiple times will do the trick. In addition, you could change some values on
    the data so that each item displays unique data in the UI.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免使本书的页面混乱，我只定义了一个记录，但请继续向数组中添加更多内容。多次复制和粘贴相同的对象将起作用。此外，您可以更改数据中的一些值，以便每个项目在UI中显示唯一的数据。
- en: 'In our `App.js` file, let''s import the dependencies we''ll need:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`App.js`文件中，让我们导入我们需要的依赖项：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to create the class to render the list of items. We''re going
    to keep the sales data on the state; that way, we could insert or remove elements
    easily:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建用于渲染项目列表的类。我们将在状态中保留销售数据；这样，我们可以轻松地插入或删除元素：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `render` method, we need to define the `ListView` component and we''ll
    use the `renderRow` method to render each item. The `dataSource` property defines
    the array of elements that we''re going to render on the list:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们需要定义`ListView`组件，并使用`renderRow`方法来渲染每个项目。`dataSource`属性定义了我们将在列表上渲染的元素数组：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can define the contents of `renderRow`. This method receives each object
    containing all of the information we need. We''re going to display the data in
    three columns. In the first column, we''ll show an icon; in the second column,
    we''ll show the number of items for each sale and the address where this order
    will ship; and the third column will display the date and the total:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`renderRow`的内容。这个方法接收包含我们需要的所有信息的每个对象。我们将在三列中显示数据。在第一列中，我们将显示一个图标；在第二列中，我们将显示每个销售的物品数量和订单将发货的地址；第三列将显示日期和总计：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we have the JSX defined, it''s time to add the styles. First, we''ll define
    colors, margins, paddings, and so on for the main container, title, and row container.
    In order to create the three columns for each row, we need to use the `flexDirection:
    ''row''` property. We''ll learn more about this property in the *Using flexbox
    to create a layout* recipe later in this chapter:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一旦我们定义了JSX，就该添加样式了。首先，我们将为主容器、标题和行容器定义颜色、边距、填充等样式。为了为每一行创建三列，我们需要使用`flexDirection:
    ''row''`属性。我们将在本章后面的*使用flexbox创建布局*中更多了解这个属性：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we refresh the simulators, we should see something similar to the following
    screenshot:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们刷新模拟器，应该看到类似于以下截图的东西：
- en: '![](assets/0eb4c14f-0cae-4506-b78e-c90f26015e80.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0eb4c14f-0cae-4506-b78e-c90f26015e80.png)'
- en: 'Now, inside the `StyleSheet` definition, let''s add styles for the icon. We''re
    going to add a yellow circle as the background and change the color of the icon
    to white:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`StyleSheet`定义内部，让我们为图标添加样式。我们将添加一个黄色的圆作为背景，并将图标的颜色改为白色：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After this change, we''ll see a nice icon on the left side of each row, as
    shown in the following screenshot:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个改变之后，我们将在每一行的左侧看到一个漂亮的图标，就像下面的截图所示：
- en: '![](assets/24055416-5280-4b11-b86c-16713a744c15.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/24055416-5280-4b11-b86c-16713a744c15.png)'
- en: 'Finally, we''ll add the styles for the text. We need to set `color`, `size`,
    `fontWeight`, `padding`, and a few other properties:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将为文本添加样式。我们需要设置`color`、`size`、`fontWeight`、`padding`和其他一些属性：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The end result should look similar to the following screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果应该类似于以下截图：
- en: '![](assets/3d839666-d353-4e9e-ba3a-320e4fd5f698.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d839666-d353-4e9e-ba3a-320e4fd5f698.png)'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 5*, we created the data source and added data to the state. The `ListView.DataSource`
    class implements performance data processing for the `ListView` component. The
    `rowHasChanged` property is required, and it should be a function to compare the
    next element. In our case, if the changes are different from the current data,
    which is represented as `(r1, r2) => r1 !== r2`, then React Native will know to
    respond and re-render the UI.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们创建了数据源并向状态添加了数据。`ListView.DataSource`类实现了`ListView`组件的性能数据处理。`rowHasChanged`属性是必需的，它应该是一个比较下一个元素的函数。在我们的情况下，如果变化与当前数据不同，表示为`(r1,
    r2) => r1 !== r2`，那么React Native将知道如何响应并重新渲染UI。
- en: When filling up the data source with data, we need to call the `cloneWithRows`
    method and send an array of records.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在用数据填充数据源时，我们需要调用`cloneWithRows`方法并发送一个记录数组。
- en: If we want to add more data, we should call the `cloneWithRows` method again with
    an array containing the previous and new data. The data source will make sure
    to compute the differences and re-render the list as necessary.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加更多数据，我们应该再次使用包含先前和新数据的数组调用`cloneWithRows`方法。数据源将确保计算差异并根据需要重新渲染列表。
- en: 'In *step 7*, we define the JSX to render the list. Only two properties are
    required for the list: the data source we already have from *step 6* and `renderRow`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们定义了渲染列表的JSX。列表只需要两个属性：我们已经从*步骤6*中得到的数据源和`renderRow`。
- en: The `renderRow` property accepts a function as a value. This function needs
    to return the JSX for each row.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderRow`属性接受一个函数作为值。这个函数需要返回每一行的JSX。'
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We've created a simple layout using flexbox; however, there's another recipe
    in this chapter where we'll dive into more detail about using flexbox.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用flexbox创建了一个简单的布局；但是，在本章中还有另一个教程，我们将更详细地介绍如何使用flexbox。
- en: Once we have our list, chances are that we're going to need to see the detail
    of each order. You can use the `TouchableHighlight` component as the main container
    for each row, so go ahead and give it a try. If you are not sure how to use the
    `TouchableHighlight` component, take a look at the *Creating a toggle button*
    recipe from earlier in this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的列表，很有可能我们需要查看每个订单的详细信息。您可以使用`TouchableHighlight`组件作为每行的主容器，所以继续尝试一下。如果您不确定如何使用`TouchableHighlight`组件，请参阅本章早期的*创建切换按钮*教程。
- en: Using flexbox to create a layout
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flexbox创建布局
- en: In this recipe, we'll learn about flexbox. In the previous recipes in this chapter,
    we've been using flexbox to create layouts, but in this recipe, we'll focus on
    the properties we have at our disposal by recreating the layout from a random
    name generator application on the App Store called *Nominazer* ([https://itunes.apple.com/us/app/nominazer/id765422087?mt=8](https://itunes.apple.com/us/app/nominazer/id765422087?mt=8)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习有关flexbox的知识。在本章的先前教程中，我们一直在使用flexbox来创建布局，但在这个教程中，我们将专注于我们可以使用的属性，通过重新创建App
    Store上名为*Nominazer*的随机名称生成应用程序的布局（[https://itunes.apple.com/us/app/nominazer/id765422087?mt=8](https://itunes.apple.com/us/app/nominazer/id765422087?mt=8)）。
- en: Working in flexbox in React Native is essentially the same as working with flexbox
    in CSS. This means if you're comfortable developing websites with a flexbox layout,
    then you already know how to create layouts in React Native! This exercise will
    cover the basics of working with flexbox in React Native, but for a list of all
    of the layout props you can use, refer to the documentation on Layout Props ([https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中使用flexbox基本上与在CSS中使用flexbox相同。这意味着如果您习惯于使用flexbox布局开发网站，那么您已经知道如何在React
    Native中创建布局！这个练习将涵盖在React Native中使用flexbox的基础知识，但是要查看您可以使用的所有布局属性的列表，请参考布局属性的文档（[https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html)）。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin by creating a new blank app. We'll name it `flexbox-layout`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的空白应用程序开始。我们将其命名为`flexbox-layout`。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In `App.js`, let''s import the dependencies we''ll need for our app:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`中，让我们导入我们应用程序所需的依赖项：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our application only needs a `render` method since we''re building a static
    layout.  The rendered layout consists of a container `View` element and three
    child `View` elements for each colored section of the app:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序只需要一个`render`方法，因为我们正在构建一个静态布局。渲染的布局包括一个容器`View`元素和应用程序每个彩色部分的三个子`View`元素。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we can begin adding our styles. The first style we''ll add will be applied
    to the `View` element that wraps our entire app. Setting the `flex` property to
    `1` will cause all children elements to fill all empty space:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始添加我们的样式。我们将添加的第一个样式将应用于包裹整个应用程序的`View`元素。将`flex`属性设置为`1`将导致所有子元素填充所有空白空间：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can add the styles for the three child `View` elements. Each section
    has a `flexGrow` property applied to it, which dictates how much of the available
    space each element should take up. `topSection` and `bottomSection` are both set
    to `3`, so they''ll take up the same amount of space. Since the `middleSection`
    has the `flexGrow` property set to `1`, this element will take up one third of
    the space that `topSection` and `bottomSection` take up:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为三个子`View`元素添加样式。每个部分都应用了`flexGrow`属性，这决定了每个元素应该占用多少可用空间。`topSection`和`bottomSection`都设置为`3`，所以它们将占用相同的空间。由于`middleSection`的`flexGrow`属性设置为`1`，这个元素将占用`topSection`和`bottomSection`占用空间的三分之一：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we open our application in the simulators, we should already be able to
    see the basic layout taking shape:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在模拟器中打开我们的应用程序，我们应该已经能够看到基本布局正在形成：
- en: '![](assets/f05a61bb-3f96-4511-b497-9d169b08efe0.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f05a61bb-3f96-4511-b497-9d169b08efe0.png)'
- en: 'Here, we can add a `Text` element to each of the three child `View` elements
    we created in *step 2*. Note the newly added code has been highlighted:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以在*步骤2*中创建的三个子`View`元素中的每一个添加一个`Text`元素。请注意，新增的代码已经被突出显示：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The text for each section defaults to the top-left corner of that section.
    We can use flexbox to justify and align each of these elements to the desired
    positions. All three child `View` elements have the `alignItems` flex property set
    to `''center''`, which will cause the children of each element to be centered along
    the *x* axis. `justifyContent` is used on the middle and bottom sections to define
    how child elements should be justified along the *y* axis:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个部分的文本默认显示在该部分的左上角。我们可以使用flexbox来使每个元素按照期望的位置进行对齐和排列。所有三个子`View`元素的`alignItems`
    flex属性都设置为`'center'`，这将导致每个元素的子元素沿着*x*轴居中。`justifyContent`在中间和底部部分上使用，定义了子元素沿着*y*轴应该如何对齐：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All that''s left to be done is to add basic styles to the `Text` elements to
    increase `fontSize`, `fontWeight`, and the required `margin`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一剩下的就是为`Text`元素添加基本样式，增加`fontSize`、`fontWeight`和所需的`margin`：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we open our application in simulators, we should be able to see our completed
    layout:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在模拟器中打开我们的应用程序，我们应该能够看到我们完成的布局：
- en: '![](assets/9ce98ba3-6356-4317-bd43-74a4596c41c6.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ce98ba3-6356-4317-bd43-74a4596c41c6.png)'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our application is looking really good, and it was quite easy to accomplish
    by using flexbox. We created three distinct sections by using `View` elements
    that take up different fractions of the screen by setting the `flexGrow` properties
    to `3`, `1`, and `3`, respectively. This causes the top and bottom sections to
    be of equal vertical size, and the middle section to be one third the size of
    the top and bottom.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序看起来非常不错，而且通过使用flexbox很容易实现。我们通过将`flexGrow`属性分别设置为`3`、`1`和`3`来创建了三个不同的部分，这使得顶部和底部部分的垂直大小相等，而中间部分是顶部和底部部分的三分之一。
- en: 'When using flexbox, we have two directions to lay out child content, `row`
    and `column`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用flexbox时，我们有两个方向来布置子内容，`row`和`column`：
- en: '`row`: This allows us to arrange the children of the container horizontally.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row`：这允许我们水平排列容器的子元素。'
- en: '`column`: This allows us to arrange the children of the container vertically.
    This is the default direction in React Native.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`：这允许我们垂直排列容器的子元素。这是React Native中的默认方向。'
- en: 'When setting `flex: 1` as we did with the container `View` element, we''re
    telling that element to take up all available space. If we were to remove `flex:
    1` or set `flex` to `0`, we can see the layout collapse in on itself, since the
    container is no longer flexing into all of the empty space:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们像对容器`View`元素所做的那样设置`flex: 1`时，我们告诉该元素占用所有可用空间。如果我们移除`flex: 1`或将`flex`设置为`0`，我们会看到布局在自身内部收缩，因为容器不再在所有空白空间中伸展：'
- en: '![](assets/c28d05ad-a247-4f43-9a90-77d41db556a0.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c28d05ad-a247-4f43-9a90-77d41db556a0.png)'
- en: Flexbox is great for supporting different screen resolutions as well. Even though
    different devices may have different resolutions, we can ensure consistent layouts
    that will look good on any device.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox也非常适合支持不同的屏幕分辨率。即使不同设备可能有不同的分辨率，我们可以确保一致的布局，使其在任何设备上都看起来很好。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some differences between how flexbox works in React Native and how
    it works in CSS. First, the default `flexDirection` property in CSS is `row`,
    whereas the default `flexDirection`  property in React Native is `column`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: React Native中的flexbox工作方式与CSS中的工作方式有一些不同。首先，在CSS中，默认的`flexDirection`属性是`row`，而在React
    Native中，默认的`flexDirection`属性是`column`。
- en: 'The `flex` property also behaves a bit differently in React Native. Instead
    of setting `flex` to a string value, it can be set to a positive integer, `0`,
    or `-1`. As the official React Native documentation states:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex`属性在React Native中的行为也有些不同。与将`flex`设置为字符串值不同，它可以设置为正整数、`0`或`-1`。正如官方的React
    Native文档所述：'
- en: When flex is a positive number, it makes the component flexible and it'll be
    sized proportional to its flex value. So, a component with flex set to 2 will
    take twice the space as a component with flex set to 1\. When flex is 0, the component
    is sized according to width and height and is inflexible. When flex is -1, the
    component is normally sized according width and height. However, if there's not
    enough space, the component will shrink to its minWidth and minHeight.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当flex为正数时，它使组件具有灵活性，并且其大小将与其flex值成比例。因此，将flex设置为2的组件将占据比将flex设置为1的组件多一倍的空间。当flex为0时，组件的大小根据宽度和高度确定，是不灵活的。当flex为-1时，组件通常根据宽度和高度确定大小。但是，如果空间不足，组件将收缩到其最小宽度和最小高度。
- en: There's a lot more to talk about with flexbox, but for now we've gotten our
    feet wet. In [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*, we'll learn more about layouts.  we'll learn
    more about layouts, and we'll create a complex layout that uses more of the available
    layout properties.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于flexbox还有很多要讨论的，但目前我们已经有所了解。在[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)
    *实现复杂用户界面-第一部分*中，我们将学习更多关于布局的知识。我们将学习更多关于布局，并创建一个使用更多可用布局属性的复杂布局。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: React Native Layout Props documentation ([https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html))
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native布局属性文档([https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html))
- en: React Native Text Style Props documentation ([https://facebook.github.io/react-native/docs/text-style-props.html](https://facebook.github.io/react-native/docs/text-style-props.html))
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native文本样式属性文档([https://facebook.github.io/react-native/docs/text-style-props.html](https://facebook.github.io/react-native/docs/text-style-props.html))
- en: Yoga ([https://github.com/facebook/yoga](https://github.com/facebook/yoga))—Facebook's
    Flexbox implementation utilized by React Native
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yoga ([https://github.com/facebook/yoga](https://github.com/facebook/yoga))——React
    Native使用的Facebook的Flexbox实现。
- en: An excellent Stack Overflow post that covers how React Native flex properties
    work, with examples—[https://stackoverflow.com/questions/43143258/flex-vs-flexgrow-vs-flexshrink-vs-flexbasis-in-react-native](https://stackoverflow.com/questions/43143258/flex-vs-flexgrow-vs-flexshrink-vs-flexbasis-in-react-native)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇优秀的Stack Overflow帖子介绍了React Native弹性属性的工作原理和示例-[https://stackoverflow.com/questions/43143258/flex-vs-flexgrow-vs-flexshrink-vs-flexbasis-in-react-native](https://stackoverflow.com/questions/43143258/flex-vs-flexgrow-vs-flexshrink-vs-flexbasis-in-react-native)
- en: Setting up and using navigation
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和使用导航
- en: 'For any application that has more than one view, a navigation system is of
    paramount importance. The need for navigation is so pervasive in application development
    that Expo provides two templates when you create a new application: **Blank**
    or **Tab Navigation**. This recipe is based on a very pared down version of the Tab
    Navigation app template provided by Expo. We''ll still begin the recipe with a
    Blank app and build our basic Tab Navigation app from scratch to better understand
    all of the requisite parts. After completing this recipe, I encourage you to start
    a new app with the Tab Navigation template to see some of the more advanced features
    we''ll be covering in later chapters, including push notifications and stack navigation.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何具有多个视图的应用程序，导航系统至关重要。导航在应用程序开发中是如此普遍，以至于Expo在创建新应用程序时提供了两个模板：**空白**或**标签导航**。这个教程是基于Expo提供的非常简化的标签导航应用程序模板。我们仍将从一个空白应用程序开始，并从头开始构建我们的基本标签导航应用程序，以更好地理解所有必需的部分。完成此教程后，我鼓励您使用标签导航模板开始一个新应用程序，以查看我们将在后面章节中涵盖的一些更高级的功能，包括推送通知和堆栈导航。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s go ahead and create a new blank application named `simple-navigation`.
    We''re also going to need a third-party package for handling our navigation. We''ll
    be using 1.5.9 version of the `react-navigation` package. Using a newer version
    of this package will not work properly with this code, as the package''s API has
    recently gone through breaking changes.. In the Terminal, navigate to the root
    of the new project and install this package with the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个名为`simple-navigation`的新空白应用程序。我们还需要一个第三方包来处理我们的导航。我们将使用`react-navigation`包的1.5.9版本。使用此包的更新版本将无法正确使用此代码，因为该包的API最近经历了重大变化。在终端中，转到新项目的根目录，并使用以下命令安装此包：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That's all of the setup we need. Let's build!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有设置。让我们开始构建吧！
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Inside the `App.js` file, let''s import our dependencies:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，让我们导入我们的依赖项：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `App` component for this app will be very simple. We just need an `App`
    class with a `render` function that renders our app container. We''ll also add
    styles for filling the window and adding a white background:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个应用程序的`App`组件将非常简单。我们只需要一个带有渲染我们应用程序容器的`App`类和一个`render`函数。我们还将添加填充窗口和添加白色背景的样式：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next step for `App.js` will be to import and use the `MainTabNavigator`
    component, which is a new component that we''ll create in *step 4*:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.js`的下一步是导入并使用`MainTabNavigator`组件，这是我们将在*步骤4*中创建的新组件：'
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We'll need to create a new file for our `MainTabNavigator` component. Let's
    create a new folder in the root of the project called `navigation`. In this new
    folder, we'll create `MainTabNavigator.js` for our navigation component.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的`MainTabNavigator`组件创建一个新文件。让我们在项目的根目录中创建一个名为`navigation`的新文件夹。在这个新文件夹中，我们将为我们的导航组件创建`MainTabNavigator.js`。
- en: 'In `MainTabNavigator.js`, we can import all of the dependencies we need for
    navigation. The dependencies include three screens (`HomeScreen`, `LinksScreen`,
    and `SettingsScreen`). We''ll add these screens in later steps:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainTabNavigator.js`中，我们可以导入我们需要的所有导航依赖项。这些依赖项包括三个屏幕（`HomeScreen`、`LinksScreen`和`SettingsScreen`）。我们将在后面的步骤中添加这些屏幕：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our navigation component will use the `TabNavigator` method provided by `react-navigation`
    for defining the routes and navigation for our app. `TabNavigator` takes two parameters:
    a `RouteConfig` object to define each route and a `TabNavigatorConfig` object
    to define the options for our `TabNavigator` component:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的导航组件将使用`react-navigation`提供的`TabNavigator`方法来定义应用程序的路由和导航。`TabNavigator`接受两个参数：一个`RouteConfig`对象来定义每个路由，以及一个`TabNavigatorConfig`对象来定义我们的`TabNavigator`组件的选项：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First, we''ll define the `RouteConfig` object, which will create a route map
    for our application. Each key in the `RouteConfig` object serves as the name of
    the route. We set the screen property for each route to the corresponding screen
    component we want to be displayed on that route:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义`RouteConfig`对象，它将为我们的应用程序创建一个路由映射。`RouteConfig`对象中的每个键都作为路由的名称。我们为每个路由的屏幕属性设置为我们希望在该路由上显示的相应屏幕组件：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`TabNavigatorConfig` has a little more to it. We pass the `TabBarBottom` component
    provided by `react-navigation` to the `tabBarComponent` property to declare what
    kind of tab bar we want to use (in this case, a tab bar designed for the bottom
    of the screen). `tabBarPosition` defines whether the bar is on the top or bottom
    of the screen. `animationEnabled` specifies whether transitions are animated, and `swipeEnabled`
    declares whether views can be changed via swiping:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TabNavigatorConfig`还有一些内容。我们将通过将`react-navigation`提供的`TabBarBottom`组件传递给`tabBarComponent`属性来声明我们想要使用什么样的选项卡栏（在本例中，是设计用于屏幕底部的选项卡栏）。`tabBarPosition`定义了栏是在屏幕顶部还是底部。`animationEnabled`指定了过渡是否是动画的，`swipeEnabled`声明了视图是否可以通过滑动来改变：'
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `navigationOptions` property of the `TabNavigatorConfig` object, we''ll
    define dynamic `navigationOptions` for each route by declaring a function that
    takes the navigation prop for the current route/screen. We can use this function
    to decide how the tab bar will behave per route/screen, since it''s designed to
    return an object that sets `navigationOptions` for the appropriate screen. We''ll
    use this pattern to define the appearance of the `tabBarIcon` property for each
    route:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TabNavigatorConfig`对象的`navigationOptions`属性中，我们将通过声明一个函数来为每个路由定义动态的`navigationOptions`，该函数接受当前路由/屏幕的导航prop。我们可以使用此函数来决定选项卡栏如何针对每个路由/屏幕进行操作，因为它被设计为返回一个为适当屏幕设置`navigationOptions`的对象。我们将使用此模式来定义每个路由的`tabBarIcon`属性的外观：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `tabBarIcon` property is set to a function whose parameters are the props
    for the current route. We''ll use the `focused` prop to decide whether to render
    a colored in icon or an outlined icon, depending on the current route. We get `routeName`
    from the navigation prop via `navigation.state`, define icons for each of our
    three routes, and return the rendered icon for the appropriate route. We''ll use
    the `Ionicons` component provided by Expo to create each icon and define the icon''s
    color based on whether the icon''s route is `focused`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tabBarIcon`属性设置为一个函数，其参数是当前路由的props。我们将使用`focused`属性来决定是渲染有颜色的图标还是轮廓图标，这取决于当前路由。我们通过`navigation.state`从导航prop中获取`routeName`，为我们的三条路线定义图标，并返回适当路线的渲染图标。我们将使用Expo提供的`Ionicons`组件来创建每个图标，并根据图标的路线是否`focused`来定义图标的颜色：'
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last step in setting up `MainTabNavigator` is to create the `Colors` constant
    used to color each icon:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`MainTabNavigator`的最后一步是创建用于给每个图标上色的`Colors`常量：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our routing is now complete! All that's left now is to create the three screen
    components for each of the three routes we imported and defined in `MainTabNavigator.js`.
    For simplicity's sake, each of the three screens will have identical code, except
    for background color and identifying text.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的路由现在已经完成！现在剩下的就是为我们导入和定义在`MainTabNavigator.js`中的三个路由创建三个屏幕组件。为简单起见，这三个屏幕将具有相同的代码，除了背景颜色和标识文本不同。
- en: In the root of the project, we need to create a `screens` folder to house our
    three screens. In the new folder, we'll need to make `HomeScreen.js`, `LinksScreen.js`,
    and `SettingsScreen.js`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中，我们需要创建一个`screens`文件夹来存放我们的三个屏幕。在新文件夹中，我们需要创建`HomeScreen.js`、`LinksScreen.js`和`SettingsScreen.js`。
- en: 'Let''s start by opening the newly created `HomeScreen.js` and adding the necessary
    dependencies:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开新创建的`HomeScreen.js`并添加必要的依赖项开始：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `HomeScreen` component itself is quite simple, just a full color page with
    the word `Home` in the middle of the screen to show which screen we''re currently
    on:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HomeScreen`组件本身非常简单，只是一个全彩色页面，屏幕中间有一个`Home`字样，显示我们当前所在的屏幕：'
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll also need to add the styles for our `Home` screen layout:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为我们的`Home`屏幕布局添加样式：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All that''s left now is to repeat *step 14*, *step 15*, and *step 16* for the
    remaining two screens, along with some minor changes. `LinksScreen.js` should
    look like `HomeScreen.js` with the following highlighted sections updated:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的就是重复*步骤14*、*步骤15*和*步骤16*，为剩下的两个屏幕做一些微小的更改。`LinksScreen.js`应该看起来像`HomeScreen.js`，并更新以下突出显示的部分：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Similarly, inside `SettingsScreen.js`, we can create the third screen component
    using the same structure as the previous two screens:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`SettingsScreen.js`内部，我们可以使用与前两个屏幕相同的结构创建第三个屏幕组件：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Our application is complete! When we view our application in the simulator,
    it should have a tab bar along the bottom of the screen that transitions between
    our three routes:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序已经完成！当我们在模拟器中查看我们的应用程序时，屏幕底部应该有一个选项卡栏，可以在三个路由之间切换：
- en: '![](assets/10300526-2ca1-44b3-a4d7-8c8e94c3bf5a.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/10300526-2ca1-44b3-a4d7-8c8e94c3bf5a.png)'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we covered one of the most common and fundamental navigation
    patterns in native apps, the tab bar. The React Navigation library is a very robust,
    feature rich navigation solution and will likely be able to provide your app with
    any kind of navigation needed. We'll cover more uses of React Navigation in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们介绍了原生应用中最常见和基本的导航模式之一，即选项卡栏。React Navigation库是一个非常强大、功能丰富的导航解决方案，很可能能够为您的应用程序提供任何所需的导航。我们将在[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)中介绍更多关于React
    Navigation的用法，*实现复杂的用户
- en: Interfaces - Part I.*
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 - 第一部分。*
- en: See also
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: React Navigation official documentation ([https://reactnavigation.org/](https://reactnavigation.org/))
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Navigation官方文档（[https://reactnavigation.org/](https://reactnavigation.org/)）
- en: Expo's guide on routing and navigation ([https://docs.expo.io/versions/latest/guides/routing-and-navigation.html](https://docs.expo.io/versions/latest/guides/routing-and-navigation.html))
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo的路由和导航指南（[https://docs.expo.io/versions/latest/guides/routing-and-navigation.html](https://docs.expo.io/versions/latest/guides/routing-and-navigation.html)）
