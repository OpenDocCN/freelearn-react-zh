- en: Adding Basic Animations to Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的应用程序添加基本动画
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下教程：
- en: Creating simple animations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单动画
- en: Running multiple animations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个动画
- en: Creating animated notifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画通知
- en: Expanding and collapsing containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开和折叠容器
- en: Creating a button with a loading animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有加载动画的按钮
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In order to provide a good user experience, we'll likely want to add some animations
    to direct the user's attention, to highlight specific actions, or just to add
    a distinctive touch to our app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供良好的用户体验，我们可能希望添加一些动画来引导用户的注意力，突出特定的操作，或者只是为我们的应用程序增添独特的风格。
- en: There's an initiative in progress to move all the processing from JavaScript
    to the native side. At the time of writing (React Native Version 0.58), we can
    choose to use the native driver to run all these calculations in the native world.
    Unfortunately, this cannot be used with all animations, particularly those related
    to layout, such as flexbox properties. Read more about caveats when using native
    animation in the documentation at [http://facebook.github.io/react-native/docs/animations#caveats](http://facebook.github.io/react-native/docs/animations#caveats).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行一个倡议，将所有处理从JavaScript移至本地端。在撰写本文时（React Native版本0.58），我们可以选择使用本地驱动程序在本地世界中运行所有这些计算。不幸的是，这不能用于所有动画，特别是与布局相关的动画，比如flexbox属性。在文档中阅读有关使用本地动画时的注意事项的更多信息[http://facebook.github.io/react-native/docs/animations#caveats](http://facebook.github.io/react-native/docs/animations#caveats)。
- en: All of the recipes in this chapter use the JavaScript implementation. The React
    Native team has promised to use the same API when moving all of the processing
    to the native side, so we don't need to worry about breaking changes to the existing
    API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有教程都使用JavaScript实现。React Native团队承诺在将所有处理移至本地端时使用相同的API，因此我们不需要担心现有API的变化。
- en: Creating simple animations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单动画
- en: In this recipe, we will learn the basics of animations. We will use an image
    to create a simple linear movement from the right to the left of the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习动画的基础知识。我们将使用一张图片来创建一个简单的线性移动，从屏幕的右侧移动到左侧。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to go through this recipe, we need to create an empty app. Let's call
    it `simple-animation`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个教程，我们需要创建一个空的应用程序。让我们称之为`simple-animation`。
- en: We are going to use a PNG image of a cloud for this recipe. You can find the
    image in the recipe's repository hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/simple-animation/assets/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/simple-animation/assets/images).
    Place the image in the `/assets/images` folder for use in the app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个云的PNG图像来制作这个教程。您可以在GitHub上托管的教程存储库中找到该图像[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/simple-animation/assets/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/simple-animation/assets/images)。将图像放在`/assets/images`文件夹中以供应用程序使用。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's begin by opening `App.js` and importing the dependencies for the `App`
    class. The `Animated` class will be responsible for creating the values for the
    animation. It provides a few components that are ready to be animated, and it
    also provides several methods and helpers to run smooth animations.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`App.js`并导入`App`类的依赖项开始。`Animated`类将负责创建动画的值。它提供了一些准备好可以进行动画处理的组件，还提供了几种方法和辅助程序来运行平滑的动画。
- en: 'The `Easing` class provides several helper methods for both calculating movements
    (such as `linear` and `quadratic`) and predefined animations (such as `bounce`, `ease`,
    and `elastic`).   We are going to use the `Dimensions` class to get the current
    device size so that we know where to place the element in the initialization of
    the animation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Easing`类提供了几种辅助方法，用于计算运动（如`linear`和`quadratic`）和预定义动画（如`bounce`、`ease`和`elastic`）。我们将使用`Dimensions`类来获取当前设备尺寸，以便在动画初始化时知道在哪里放置元素：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll also initialize some constants that we are going to need in our app.
    In this case, we are going to get the device dimensions, set the size of the image,
    and `require` our image that will be animated:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将初始化一些我们在应用程序中需要的常量。在这种情况下，我们将获取设备尺寸，设置图像的大小，并`require`我们将要进行动画处理的图像：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s create the `App` component. We are going to use two methods from
    the component''s life cycle system. If you are not familiar with this concept,
    please review the related React docs ([http://reactjs.cn/react/docs/component-specs.html](http://reactjs.cn/react/docs/component-specs.html)).
    This page also has a really nice tutorial on how life cycle hooks work:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`App`组件。我们将使用组件生命周期系统中的两种方法。如果您对这个概念不熟悉，请查看相关的React文档（[http://reactjs.cn/react/docs/component-specs.html](http://reactjs.cn/react/docs/component-specs.html)）。这个页面还有一个关于生命周期钩子如何工作的非常好的教程：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to create an animation, we need to define a standard value to drive
    the animation. `Animated.Value` is a class that handles the animation values for
    each frame over time. The first thing we need to do is to create an instance of
    this class when the component is created. In this case, we are using the `componentWillMount` method,
    but we can also use the `constructor` or even the default values of a property:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建动画，我们需要定义一个标准值来驱动动画。`Animated.Value`是一个处理每一帧动画值的类。我们需要在组件创建时创建这个类的实例。在这种情况下，我们使用`componentWillMount`方法，但我们也可以使用`constructor`或者属性的默认值：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have created the animated value, we can define the animation. We are
    also creating a loop by passing the `start` method of `Animated.timing` an arrow
    function that executes this `startAnimation` function again. Now, when the image
    reaches the end of the animation, we will start the same animation again to create
    an infinitely looping animation:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了动画值，我们就可以定义动画。我们还通过将`Animated.timing`的`start`方法传递给一个箭头函数来创建一个循环，该箭头函数再次执行`startAnimation`函数。现在，当图像达到动画的末尾时，我们将再次开始相同的动画，以创建一个无限循环的动画：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have our animation in place, but we are currently only calculating the values
    for each frame over time, not doing anything with those values. The next step
    is to render the image on the screen and set the property on the styles that we
    want to animate. In this case, we want to move the element on the *x*-axis; therefore,
    we should update the `left` property:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了动画，但目前只是计算了每一帧的值，没有对这些值做任何操作。下一步是在屏幕上渲染图像，并设置我们想要动画的样式属性。在这种情况下，我们想要在*x*轴上移动元素；因此，我们应该更新`left`属性：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we refresh the simulator, we will see the image on the screen, but it''s
    not being animated yet. In order to fix this, we need to call the `startAnimation`
    method. We will start the animation once the component is fully rendered, using
    the `componentDidMount` lifecycle hook:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们刷新模拟器，我们将看到图像在屏幕上，但它还没有被动画处理。为了解决这个问题，我们需要调用`startAnimation`方法。我们将在组件完全渲染后开始动画，使用`componentDidMount`生命周期钩子：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the app again, we will see how the image is moving at the top of
    the screen, just like we wanted! As a final step, let''s add some basic styles
    to the app:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次运行应用程序，我们将看到图像在屏幕顶部移动，就像我们想要的那样！作为最后一步，让我们为应用程序添加一些基本样式：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](assets/1dda7b4d-ccd4-4a02-851a-feddfc257ab0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1dda7b4d-ccd4-4a02-851a-feddfc257ab0.png)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 5*, we set the animation values. The first line resets the initial
    value every time we call this method. For this example, the initial value will
    be the `width` of the device, which will move the image to the right-hand side
    of the screen, where we want to start our animation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们设置了动画数值。第一行每次调用此方法时都会重置初始值。在本例中，初始值将是设备的`宽度`，这将把图像移动到屏幕的右侧，这是我们想要开始动画的地方。
- en: Then, we use the `Animated.timing` function to create an animation based on
    time and take two parameters. For the first parameter, we pass in `animatedValue`,
    which we created in the `componentWillMount` lifecycle hook in *step 4*. The second
    parameter is an object with configurations for the animation. In this case, we
    are going to set the end value to minus the width of the image, which will place
    the image on the left-hand side of the screen. We complete the animation there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Animated.timing`函数基于时间创建动画，并传入两个参数。对于第一个参数，我们传入了在*步骤4*中的`componentWillMount`生命周期钩子中创建的`animatedValue`。第二个参数是一个包含动画配置的对象。在这种情况下，我们将把结束值设置为图像宽度的负值，这将把图像放在屏幕的左侧。动画在那里完成。
- en: With the entire configuration in place, the `Animated` class will calculate
    all the frames required in the 6 seconds allotted to perform a linear animation
    from right to left (via the `duration` property being set to `6000` milliseconds).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完毕后，`Animated`类将计算所需的所有帧，以在分配的6秒内执行从右向左的线性动画（通过将`duration`属性设置为`6000`毫秒）。
- en: We have another helper provided by React Native that can be paired with `Animated`,
    called `Easing`. In this case, we are using the `linear` property of the `Easing`
    helper class. `Easing` provides other common easing methods, such as `elastic` and `bounce`.
    Take a look at the `Easing` class documentation and try setting different values
    for the `easing` property to see how each works. You can find the documentation
    at [https://facebook.github.io/react-native/docs/easing.html](https://facebook.github.io/react-native/docs/easing.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: React Native还提供了另一个与`Animated`配对使用的辅助工具，称为`Easing`。在这种情况下，我们使用`Easing`辅助类的`linear`属性。`Easing`提供其他常见的缓动方法，如`elastic`和`bounce`。查看`Easing`类文档，并尝试为`easing`属性设置不同的值，看看每个值的效果。您可以在[https://facebook.github.io/react-native/docs/easing.html](https://facebook.github.io/react-native/docs/easing.html)找到文档。
- en: Once the animation is configured correctly, we need to run it. We do this by
    calling the `start` method. This method receives an optional `callback` function
    parameter that will be executed when the animation is completed. In this case,
    we are running the same `startAnimation` function recursively. This will create
    an infinite loop, which is what we want to achieve.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 动画配置正确后，我们需要运行它。我们通过调用`start`方法来实现这一点。此方法接收一个可选的`callback`函数参数，当动画完成时将执行该函数。在这种情况下，我们递归运行相同的`startAnimation`函数。这将创建一个无限循环，这正是我们想要实现的。
- en: In *step 6*, we are rendering the image. If we want to animate an image, we
    should always use the `Animate.Image` component. Internally, this component will
    handle the values of the animation and will set each value for every frame on
    the native component. This avoids running the render method in the JavaScript
    layer on every frame, allowing for smoother animations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们正在渲染图像。如果要对图像进行动画处理，应始终使用`Animate.Image`组件。在内部，此组件将处理动画的值，并将为本机组件上的每个帧设置每个值。这避免了在每个帧上在JavaScript层上运行渲染方法，从而实现更流畅的动画。
- en: Along with the `Image`, we can also animate the `View`, `Text`, and `ScrollView`
    components. There's support for all four of these components out of the box, but
    we could also create a new component and add support for animations via `Animated.createAnimatedComponent()`.
    All four of these components are able to handle style changes. All we have to
    do is pass `animatedValue` to the property that we want to animate, in this case
    the `left` property, but we could use any of the available styles on each component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Image`之外，我们还可以对`View`、`Text`和`ScrollView`组件进行动画处理。这四个组件都有内置的支持，但我们也可以创建一个新组件，并通过`Animated.createAnimatedComponent()`添加动画支持。这四个组件都能处理样式更改。我们所要做的就是将`animatedValue`传递给我们想要动画的属性，这种情况下是`left`属性，但我们也可以在每个组件上使用任何可用的样式。
- en: Running multiple animations
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个动画
- en: In this recipe, we will learn how to use the same animation values in several
    elements. This way, we can reuse the same values, along with interpolation, to
    get different values for the remaining elements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在几个元素中使用相同的动画值。这样，我们可以重复使用相同的值，以及插值，为其余的元素获得不同的值。
- en: 'This animation will be similar to the previous recipe. This time, we will have
    two clouds: one will be smaller with slower movement, the other larger and faster
    moving. At the center of the screen, we will have a static airplane. We won''t
    add any animation to the airplane, but the moving clouds will make it appear as
    though the plane is moving.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画将类似于上一个配方。这次，我们将有两朵云：一朵较小，移动较慢，另一朵较大，移动较快。在屏幕中央，我们将有一架静止的飞机。我们不会给飞机添加任何动画，但移动的云会使它看起来像飞机在移动。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's start this recipe by creating an empty app called `multiple-animations`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为`multiple-animations`的空应用程序来开始这个配方。
- en: 'We are going to use three different images: two clouds and an airplane. You
    can download the images from the recipe''s repository, hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/multiple-animations/assets/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/multiple-animations/assets/images).
    Make sure to place the images in the `/assets/images` folder.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三种不同的图像：两个云和一架飞机。您可以从GitHub上的配方存储库下载图像，地址为[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/multiple-animations/assets/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/multiple-animations/assets/images)。确保将图像放在`/assets/images`文件夹中。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening `App.js` and adding our imports:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`App.js`并添加我们的导入开始：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, we need to define some constants and require the images that
    we are going to use for the animations. Note that we''re using the same cloud
    image as `cloudImage1` and `cloudImage2`, but we will treat them as separate entities
    in this recipe:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要定义一些常量，并要求我们将用于动画的图像。请注意，我们将在这个配方中将相同的云图像视为`cloudImage1`和`cloudImage2`，但我们将把它们视为单独的实体：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the next step, we are going to create the `animatedValue` instance when
    the component gets created, then we will start the animation when the component
    is fully rendered. We are creating an animation that runs in an infinite loop.
    The initial value will be `1` and the final value will be `0`. If you are not
    clear about this code, make sure to read the first recipe in this chapter:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，当组件被创建时，我们将创建`animatedValue`实例，然后在组件完全渲染时开始动画。我们正在创建一个在无限循环中运行的动画。初始值将为`1`，最终值将为`0`。如果您对这段代码不清楚，请确保阅读本章的第一个配方：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `render` method in this recipe is going to be quite different from the last.
    In this recipe, we are going to animate two images using the same `animatedValue`.
    The animated value will return values from `1` to `0`; however, we want to move
    the clouds from right to left, so we need to set the `left` value on each element.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本示例中，`render`方法将与上一个示例有很大不同。在本示例中，我们将使用相同的`animatedValue`来动画两个图像。动画值将返回从`1`到`0`的值；但是，我们希望将云从右向左移动，因此我们需要为每个元素设置`left`值。
- en: 'In order to set the correct values, we need to interpolate `animatedValue`.
    For the smaller cloud, we will set the initial `left` value to the width of the
    device, but for the bigger cloud, we will set the initial `left` value far away
    from the right-hand edge of the device. This will make the movement distance bigger,
    and therefore it will move faster:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置正确的值，我们需要对`animatedValue`进行插值。对于较小的云，我们将把初始的`left`值设为设备的宽度，但对于较大的云，我们将把初始的`left`值设得远离设备的右边缘。这将使移动距离更大，因此移动速度会更快：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have the correct `left` values, we need to define the elements we want
    to animate. Here, we will set the interpolated value to the `left` styles property:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了正确的`left`值，我们需要定义我们想要动画的元素。在这里，我们将把插值值设置为`left`样式属性：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As for the last step, we need to define some styles, just to set the `width`
    and `height` of each cloud as well as assign styles to the `top`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于最后一步，我们需要定义一些样式，只需设置每朵云的`width`和`height`以及为`top`分配样式即可。
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we refresh our app, we should see the animation:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们刷新应用，我们应该能看到动画：
- en: '![](assets/e752f224-3437-4c01-8bd1-89c74f625a1f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e752f224-3437-4c01-8bd1-89c74f625a1f.png)'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 4*, we defined the interpolations to get the `left` value for each
    cloud. The `interpolate` method receives an object with two required configurations,
    `inputRange` and `outputRange`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了插值以获取每朵云的`left`值。`interpolate`方法接收一个具有两个必需配置的对象，`inputRange`和`outputRange`。
- en: The `inputRange` configuration receives an array of values. These values should
    always be ascending values; you could use negative values too, as long as the
    values are ascending.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputRange`配置接收一个值数组。这些值应始终是升序值；您也可以使用负值，只要值是升序的。'
- en: '`outputRange` should match the number of values defined on `inputRange`. These
    are the values that we need as a result of the interpolation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputRange`应该与`inputRange`中定义的值的数量匹配。这些是我们需要作为插值结果的值。'
- en: For this recipe, `inputRange` goes from `0` to `1`, which are the values of
    our `animatedValue`. In `outputRange`, we defined the limits of the movement that
    we need.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，`inputRange`从`0`到`1`，这些是我们的`animatedValue`的值。在`outputRange`中，我们定义了我们需要的移动的限制。
- en: Creating animated notifications
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画通知
- en: In this recipe, we will create a notification component from scratch. When showing
    the notification, the component will slide in from the top of the screen. After
    a few seconds, we will automatically hide it by sliding it out.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将从头开始创建一个通知组件。在显示通知时，组件将从屏幕顶部滑入。几秒钟后，我们将自动隐藏它，将其滑出。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to create an app. Let's call it `notification-animation`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用。让我们称之为`notification-animation`。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start by working on the `App` component. First, let''s import all the
    required dependencies:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`App`组件开始工作。首先，让我们导入所有必需的依赖项：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once we have all the dependencies imported, we can define the `App` class.
    In this case, we are going to initialize the `state` with a `notify` property
    equal to `false`. We are going to use this property to show or hide the notification.
    By default, the notification will not be shown onscreen. To make things simple,
    we will define the `message` property in the `state` with the text we want to
    display:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们导入了所有依赖项，我们就可以定义`App`类。在这种情况下，我们将使用`notify`属性等于`false`来初始化`state`。我们将使用此属性来显示或隐藏通知。默认情况下，通知不会显示在屏幕上。为了简化事情，我们将在`state`中定义`message`属性，其中包含我们想要显示的文本：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `render` method, we need to show the notification only if the `notify`
    property is `true`. We can achieve this by using an `if` statement:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法内，我们需要仅在`notify`属性为`true`时显示通知。我们可以通过使用`if`语句来实现这一点：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous step, we only defined the reference to the `Notification` component,
    but we are not using it yet. Let''s define a `return` with all of the JSX needed
    for this app. To keep things simple, we are only going to define a toolbar, some
    text, and a button to toggle the state of the notification when pressed:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们只定义了对`Notification`组件的引用，但还没有使用它。让我们定义一个`return`，其中包含此应用程序所需的所有JSX。为了保持简单，我们只会定义一个工具栏、一些文本和一个按钮，以在按下时切换通知的状态：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also need to define the method that toggles the `notify` property on the
    `state`, which is very simple:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义一个方法，用于在`state`上切换`notify`属性，这非常简单：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are almost done with this class. The only things left are the styles. In
    this case, we will only add basic styles such as `color`, `padding`, `fontSize`,
    `backgroundColor`, and `margin`, nothing really special:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了这个类。剩下的只有样式。在这种情况下，我们只会添加基本样式，如`color`、`padding`、`fontSize`、`backgroundColor`和`margin`，没有什么特别的：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we try to run the app, we will see an error that the `./Notification` module
    couldn''t be resolved. Let''s fix that by defining the `Notification` component.
    Let''s create a `Notifications` folder, with an `index.js` file inside of it.
    Then, we can import our dependencies:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试运行应用程序，我们会看到一个错误，即无法解析`./Notification`模块。让我们通过定义`Notification`组件来解决这个问题。让我们创建一个`Notifications`文件夹，其中包含一个`index.js`文件。然后，我们可以导入我们的依赖项：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have the dependencies imported, let''s define the props and the initial
    state of our new component. We are going to define something very simple, just
    a property to receive the message to display, and two `callback` functions to
    allow the running of some actions when the notification appears on the screen
    and when it gets closed. We''ll also add a property to set the number of milliseconds
    to display the notification before it autohides:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们导入了依赖项，让我们定义新组件的props和初始状态。我们将定义一些非常简单的东西，只是一个用于接收要显示的消息的属性，以及两个`callback`函数，允许在通知出现在屏幕上和关闭时运行一些操作。我们还将添加一个属性来设置在自动隐藏通知之前显示通知的毫秒数：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s finally time to work on the animation! We need to start the animation
    as soon as the component gets rendered. If there''s something not clear in the
    following code, I recommend you take a look at the first and second recipes in
    this chapter:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终于是时候开始处理动画了！我们需要在组件被渲染时立即开始动画。如果以下代码中有什么不清楚的地方，我建议你看一下本章的第一和第二个示例：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So far, we''ve defined a method to get the animation. For the slide-in movement,
    we need to calculate the values from `0` to `1`. Once the animation is complete,
    we need to run the `onOpen` callback. If the `autoHide` property is set to `true` when
    the `onOpen` method is called, we will automatically run the slide-out animation
    to remove the component:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个获取动画的方法。对于滑入运动，我们需要计算从`0`到`1`的值。动画完成后，我们需要运行`onOpen`回调。如果`autoHide`属性在调用`onOpen`方法时设置为`true`，我们将自动运行滑出动画以删除组件：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similar to the preceding step, we need a method for the slide-out movement.
    Here, we need to calculate the values from `1` to `0`. We are sending the `autoHide` value
    as a parameter to the `getAnimation` method. This will automatically delay the
    animation by the amount of milliseconds defined by the `delay` property (in our
    case, 5 seconds). After the animation has completed, we need to run the `onClose`
    callback function, which will remove the component from the `App` class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前面的步骤类似，我们需要一个用于滑出运动的方法。在这里，我们需要计算从`1`到`0`的值。我们将`autoHide`值作为参数发送到`getAnimation`方法。这将自动延迟动画，延迟时间由`delay`属性定义（在我们的例子中为5秒）。动画完成后，我们需要运行`onClose`回调函数，这将从`App`类中删除组件：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s add the `render` method. Here, we will get the `message` value
    provided by `props`. We also need the `height` of the component to move the component
    to the initial position of the animation; by default, it''s `-1000` but we will
    set the correct value at runtime in the next steps. The `animatedValue` goes from
    `0` to `1` or `1` to `0`, depending on whether the notification is opening or
    closing; therefore, we need to interpolate it to get the actual values. The animation
    will go from minus the height of the component to `0`; this will result in a nice
    slide in/out animation:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加`render`方法。在这里，我们将获取`props`提供的`message`值。我们还需要组件的`height`来将组件移动到动画的初始位置；默认情况下是`-1000`，但我们将在下一步在运行时设置正确的值。`animatedValue`从`0`到`1`或从`1`到`0`，取决于通知是打开还是关闭；因此，我们需要对其进行插值以获得实际值。动画将从组件的负高度到`0`；这将导致一个漂亮的滑入/滑出动画：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To keep things as simple as possible, we will return an `Animated.View` with
    some text. Here, we are setting the `top` style with the interpolation result,
    meaning we will animate the top style. As mentioned before, we need to calculate
    the height of the component at runtime. In order to achieve that, we need to use
    the `onLayout` property of the view. This function will be called every time the
    layout updates and will send the new dimensions of this component as a parameter:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了尽可能简单，我们将返回一个带有一些文本的`Animated.View`。在这里，我们正在使用插值结果设置`top`样式，这意味着我们将对顶部样式进行动画处理。如前所述，我们需要在运行时计算组件的高度。为了实现这一点，我们需要使用视图的`onLayout`属性。此函数将在每次布局更新时调用，并将新的组件尺寸作为参数发送：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `onLayoutChange` method will be very simple. We just need to get the new
    `height` and update the `state`. This method receives an `event`. From this object,
    we can grab useful information. For our purposes, we will access the data at `nativeEvent.layout` in
    the `event` object. The `layout` object contains the screen''s `width` and `height`,
    and the *x* and *y* positions on the screen where the `Animated.View` called this
    function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onLayoutChange`方法将非常简单。我们只需要获取新的`height`并更新`state`。此方法接收一个`event`。从这个对象中，我们可以获取有用的信息。对于我们的目的，我们将在`event`对象的`nativeEvent.layout`中访问数据。`layout`对象包含屏幕的`width`和`height`，以及`Animated.View`调用此函数时屏幕上的*x*和*y*位置：'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the last step, we will add some styles to the notification component. Since
    we want this component to animate on top of anything else, we need to set the
    `position` to `absolute`, and set the `left` and `right` properties to `0`. We''ll
    also add some color and padding:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们将为通知组件添加一些样式。由于我们希望该组件在任何其他内容之上进行动画，我们需要将`position`设置为`absolute`，并将`left`和`right`属性设置为`0`。我们还将添加一些颜色和填充：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final app should look something like the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终应用程序应该看起来像以下截图：
- en: '![](assets/425fcaa8-645a-4ae2-8d6d-8a97778cdde7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/425fcaa8-645a-4ae2-8d6d-8a97778cdde7.png)'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *step 3*, we defined the `Notification` component. This component receives
    three parameters: a flag to automatically hide the component after a few seconds,
    the message that we want to display, and a `callback` function that will be executed
    when the notification gets closed.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们定义了`Notification`组件。该组件接收三个参数：一个标志，用于在几秒后自动隐藏组件，我们要显示的消息，以及在通知关闭时将执行的`callback`函数。
- en: When the `onClose` callback gets executed, we will toggle the `notify` property
    to remove the `Notification` instance and clear the memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当`onClose`回调被执行时，我们将切换`notify`属性以移除`Notification`实例并清除内存。
- en: In *step 4*, we defined the JSX to render the components of our app. It's important
    to render the `Notification` component after the others so that the component
    will appear on top of all other components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了用于渲染应用程序组件的JSX。重要的是要在其他组件之后渲染`Notification`组件，以便该组件显示在所有其他组件之上。
- en: In *step 6*, we defined the `state` of our component. The `defaultProps` object
    sets the default values for each property. These values will be applied if no
    value is assigned to the given property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们定义了组件的`state`。`defaultProps`对象为每个属性设置了默认值。如果给定属性没有赋值，这些值将被应用。
- en: We defined the default for each `callback` as an empty function. This way, we
    don't have to check whether those props have a value before trying to execute
    them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个`callback`的默认值定义为空函数。这样，我们在尝试执行它们之前不必检查这些props是否有值。
- en: For the initial `state`, we defined the `height` property. The actual `height`
    value will be calculated at runtime based on the content received in the `message`
    property. This means we need to initially render the component far away from the
    original position. Since there's a short delay when the layout is calculated,
    we don't want to display the notification at all before it moves to the correct
    position.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初始的`state`，我们定义了`height`属性。实际的`height`值将根据`message`属性中接收的内容在运行时计算。这意味着我们需要最初将组件远离原始位置进行渲染。由于在计算布局时存在短暂延迟，我们不希望在移动到正确位置之前显示通知。
- en: 'In *step 9*, we created the animation. The `getAnimation` method receives two
    parameters: the `delay` to be applied and the `autoHide` Boolean, which determines
    whether the notification automatically closes. We used this method in *step 10*
    and *step 11*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们创建了动画。`getAnimation`方法接收两个参数：要应用的`delay`和`autoHide`布尔值，用于确定通知是否自动关闭。我们在*步骤10*和*步骤11*中使用了这个方法。
- en: In *step 13*, we defined the JSX for this component. The `onLayout` function
    is very useful for getting the dimensions of the component when there are updates
    to the layout. For example, if the device orientation changes, the dimensions
    will change, in which case we would like to update the initial and final coordinates
    for the animation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们为该组件定义了JSX。`onLayout`函数在更新布局时非常有用，可以获取组件的尺寸。例如，如果设备方向发生变化，尺寸将发生变化，这种情况下，我们希望更新动画的初始和最终坐标。
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The current implementation works pretty well, but there's a performance problem
    we should address. Currently, the `onLayout` method gets executed on every frame
    of the animation, which means we are updating the state on every frame, which
    leads to the component re-rendering on every frame! We should avoid this, and
    only update it once to get the actual height.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的实现效果相当不错，但是我们应该解决一个性能问题。目前，`onLayout`方法在每一帧动画上都会被执行，这意味着我们在每一帧上都在更新`state`，这导致组件在每一帧上重新渲染！我们应该避免这种情况，只更新一次以获得实际的高度。
- en: 'To fix this, we could add a simple validation just to update the state if the
    current value is different than the initial value. This will avoid updating the
    `state` on every frame and we won''t force the render over and over again:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以添加一个简单的验证，只有在当前值与初始值不同时才更新状态。这将避免在每一帧上更新`state`，我们也不会一遍又一遍地强制渲染：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While this works for our purposes, we could also go further and make sure the
    `height` also gets updated when the orientation changes. However, we'll stop here,
    as this recipe is quite long already.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对我们的目的有效，但我们也可以进一步确保在方向改变时`height`也会更新。然而，我们会在这里停下，因为这个方法已经相当长了。
- en: Expanding and collapsing containers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开和折叠容器
- en: In this recipe, we will create a custom container element with a `title` and
    `content`. When a user presses the title, the content will collapse or expand.
    This recipe will allow us to explore the `LayoutAnimation` API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将创建一个带有`title`和`content`的自定义容器元素。当用户按下标题时，内容将折叠或展开。这个方法将允许我们探索`LayoutAnimation`
    API。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Let's start by creating a new app. We'll call it `collapsable-containers`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的应用程序开始。我们将其称为`collapsable-containers`。
- en: Once we have created the app, let's also create a `Panel` folder with an `index.js`
    file in it for housing our `Panel` component.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了应用程序，让我们还创建一个`Panel`文件夹，里面有一个`index.js`文件，用于存放我们的`Panel`组件。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by focusing on the `Panel` component. First, we need to import
    all the dependencies that we are going to use for this class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先专注于`Panel`组件。首先，我们需要导入我们将在这个类中使用的所有依赖项：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once we have the dependencies, let''s declare the `defaultProps` for initializing
    this component. In this recipe, we only need to initialize the `expanded` property
    to `false`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了依赖项，让我们声明`defaultProps`来初始化这个组件。在这个方法中，我们只需要将`expanded`属性初始化为`false`：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are going to use the `height` property on the `state` object to expand or
    collapse the container. The first time this component gets created, we need to
    check the `expanded` property in order to set the correct initial `height`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`state`对象上的`height`属性来展开或折叠容器。这个组件第一次被创建时，我们需要检查`expanded`属性，以设置正确的初始`height`：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s render the required JSX elements for this component. We need to get
    the `height` value from `state` and set it to the content''s style view. When
    pressing the `title` element, we will execute the `toggle` method (defined later)
    to change the `height` value of the state:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个组件渲染所需的JSX元素。我们需要从`state`中获取`height`的值，并将其设置为内容的样式视图。当按下`title`元素时，我们将执行`toggle`方法（稍后定义）来改变`state`的`height`值：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As mentioned before, the `toggle` method will be executed when the `title`
    element is pressed. Here, we will toggle the `height` on the `state` and call
    the animation we want to use when updating the styles on the next render cycle:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，当按下`title`元素时，`toggle`方法将被执行。在这里，我们将在`state`上切换`height`并在下一个渲染周期更新样式时调用我们想要使用的动画：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To complete this component, let''s add some simple styles. We need to set the
    `overflow` to `hidden`, otherwise the content will be shown when the component
    is collapsed:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个组件，让我们添加一些简单的样式。我们需要将`overflow`设置为`hidden`，否则在组件折叠时内容将被显示出来。
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once we have our `Panel` component defined, let''s use it on the `App` class.
    First, we need to require all the dependencies in `App.js`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们定义了`Panel`组件，让我们在`App`类中使用它。首先，我们需要在`App.js`中要求所有的依赖项：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the previous step, we imported the `Panel` component. We are going to declare
    three instances of this class in the JSX:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们导入了`Panel`组件。我们将在JSX中声明这个类的三个实例：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are using the React Native `LayoutAnimation` API in this recipe. This API
    is disabled on Android by default in the current version of React Native. Before
    the `App` component mounts, we''ll use the `Platform` helper with the `UIManager`
    to enable this feature on Android devices:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在React Native中使用了`LayoutAnimation` API。在当前版本的React Native中，这个API在Android上默认是禁用的。在`App`组件挂载之前，我们将使用`Platform`助手和`UIManager`在Android设备上启用这个功能：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, let''s add some styles to the toolbar and the main container. We just
    need some simple styles you''re likely used to by now: `padding`, `margin`, and
    `color`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们为工具栏和主容器添加一些样式。我们只需要一些你现在可能已经习惯的简单样式：`padding`，`margin`和`color`。
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final app should look similar to the following screenshots:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/6896c6bd-b770-4a25-8423-6aad90ac4964.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6896c6bd-b770-4a25-8423-6aad90ac4964.png)'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 3*, we set the initial `height` of the content. If the `expanded` property
    was set to `true`, then we should show the content. By setting the `height` value
    to `null`, the layout system will calculate the `height` based on the content;
    otherwise, we need to set the value to `0`, which will hide the content when the
    component is collapsed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们设置了内容的初始`height`。如果`expanded`属性设置为`true`，那么我们应该显示内容。通过将`height`值设置为`null`，布局系统将根据内容计算`height`；否则，我们需要将值设置为`0`，这将在组件折叠时隐藏内容。
- en: In *step 4*, we defined all the JSX for the `Panel` component. There are a few
    concepts in this step worth covering. First, the `children` property is passed
    in from the `props` object, which will contain any elements defined between `<Panel>`
    and `</Panel>` when this component is used in the `App` class. This is very helpful
    because, by using this property, we are allowing this component to receive any
    other components as children.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们为`Panel`组件定义了所有JSX。这一步中有一些值得介绍的概念。首先，`children`属性是从`props`对象中传入的，当这个组件在`App`类中使用时，它将包含在`<Panel>`和`</Panel>`之间定义的任何元素。这非常有帮助，因为通过使用这个属性，我们允许这个组件接收任何其他组件作为子组件。
- en: In this same step, we're also getting the `height` from the `state` object and
    setting it as the `style` applied to the `View` with the collapsible content.
    This will update the `height`, causing the component to correspondingly expand
    or collapse. We also declared the `onPress` callback, which toggles the `height`
    on the `state` when the title element is pressed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一步骤中，我们还从`state`对象中获取`height`并将其设置为应用于可折叠内容的`View`的`style`。这将更新`height`，导致组件相应地展开或折叠。我们还声明了`onPress`回调，当按下`title`元素时，它会切换`state`上的`height`。
- en: In *step 7,* we defined the `toggle` method, which toggles the `height` value.
    Here, we used the `LayoutAnimation` class. By calling the `spring` method, the
    layout system will animate every change that happens to the layout on the next
    render. In this case, we are only changing `height`, but we can change any other
    property we want, such as `opacity`, `position`, or `color`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们定义了`toggle`方法，它可以切换`height`值。在这里，我们使用了`LayoutAnimation`类。通过调用`spring`方法，布局系统将在下一次渲染时对布局发生的每一次变化进行动画处理。在这种情况下，我们只改变了`height`，但我们也可以改变任何其他属性，比如`opacity`，`position`或`color`。
- en: The `LayoutAnimation` class contains a couple of predefined animations. In this
    recipe, we used `spring`, but we could also use `linear` or `easeInEaseOut`, or
    you could create your own using the `configureNext` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutAnimation`类包含一些预定义的动画。在这个示例中，我们使用了`spring`，但我们也可以使用`linear`或`easeInEaseOut`，或者使用`configureNext`方法创建自己的动画。'
- en: If we remove the `LayoutAnimation`, we won't see an animation; the component
    will expand and collapse by jumping from `0` to total height. But by adding that
    single line, we're able to easily add a nice, smooth animation. If you need more
    control over the animation, you'll probably want to use the Animation API instead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除`LayoutAnimation`，我们将看不到动画；组件将通过从`0`到总高度跳跃来展开和折叠。但通过添加那一行代码，我们可以轻松地添加一个漂亮、平滑的动画。如果您需要更多对动画的控制，您可能会想使用动画API。
- en: In *step 9*, we checked the OS property on the `Platform` helper, which returned
    the `'android'` or `'ios'` strings, depending on which device the app is running
    on. If the app is running on Andriod, we use the `UIManager` helper's `setLayoutAnimationEnabledExperimental` method
    to enable the `LayoutAnimation` API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们在`Platform`助手上检查了OS属性，它返回了`'android'`或`'ios'`字符串，取决于应用程序运行在哪个设备上。如果应用程序在Andriod上运行，我们使用`UIManager`助手的`setLayoutAnimationEnabledExperimental`方法来启用`LayoutAnimation`
    API。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`LayoutAnimation` API documentation at [https://facebook.github.io/react-native/docs/layoutanimation.html](https://facebook.github.io/react-native/docs/layoutanimation.html)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LayoutAnimation` API文档在[https://facebook.github.io/react-native/docs/layoutanimation.html](https://facebook.github.io/react-native/docs/layoutanimation.html)'
- en: A quick intro to React's `props.children` at [https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891](https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891)[ ](https://facebook.github.io/react-native/docs/layoutanimation.html)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891](https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891)快速介绍React的`props.children`。
- en: Creating a button with a loading animation
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有加载动画的按钮
- en: In this recipe, we'll continue working with the `LayoutAnimation` class. Here,
    we will create a button, and when the user presses the button, we will show a
    loading indicator and animate the styles.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将继续使用`LayoutAnimation`类。在这里，我们将创建一个按钮，当用户按下按钮时，我们将显示一个加载指示器并动画化样式。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, we'll need to create an empty app. Let's call it `button-loading-animation`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建一个空的应用程序。让我们称之为`button-loading-animation`。
- en: Let's also create a `Button` folder with an `index.js` file in it for our `Button`
    component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还创建一个`Button`文件夹，里面有一个`index.js`文件，用于我们的`Button`组件。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start with the `Button/index.js` file. First, we''ll import all the
    dependencies for this component:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`Button/index.js`文件开始。首先，我们将导入这个组件所需的所有依赖项：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re going to use only four props for this component: a `label`, a `loading`
    Boolean to toggle displaying either the loading indicator or the label inside
    the button, a callback function to be executed when the button is pressed, and
    custom styles. Here, we''ll `init` the `defaultProps` for loading to `false`,
    and the `handleButtonPress` to an empty function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个组件，我们将只使用四个props：一个`label`，一个`loading`布尔值，用于切换显示加载指示器或按钮内的标签，一个在按钮被按下时执行的回调函数，以及自定义样式。在这里，我们将`init`默认的`loading`为`false`，并将`handleButtonPress`设置为空函数：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll keep the `render` method of this component as simple as possible. We''ll
    render the label and the activity indicator based on the value of the `loading`
    property:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尽可能简化这个组件的`render`方法。我们将根据`loading`属性的值来渲染标签和活动指示器：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to render the `label`, we need to check whether the `loading` property
    is `false`. If it is, then we return only a `Text` element with the `label` we
    received from `props`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了渲染`label`，我们需要检查`loading`属性是否为`false`。如果是，那么我们只返回一个带有从`props`接收到的`label`的`Text`元素：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Likewise, the `renderActivityIndicator` indicator should only apply if the
    value of the `loading` property is `true`. If so, we will return the `ActivityIndicator`
    component. We''ll use the props of `ActivityIndicator` to define a `size` of small
    and a `color` of white (`#fff`):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`renderActivityIndicator`指示器应该只在`loading`属性的值为`true`时应用。如果是这样，我们将返回`ActivityIndicator`组件。我们将使用`ActivityIndicator`的props来定义一个小的`size`和白色的`color`(`#fff`)：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'One method is still missing from our class: `handleButtonPress`. We need to
    inform the parent of this component when the button has been pressed, which can
    be done by calling the `onPress` callback passed to this component via `props`.
    We''ll also use the `LayoutAnimation` to queue an animation on the next render:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的类中还缺少一个方法：`handleButtonPress`。当按钮被按下时，我们需要通知这个组件的父组件，这可以通过调用通过`props`传递给这个组件的`onPress`回调来实现。我们还将使用`LayoutAnimation`在下一次渲染时排队一个动画：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To complete this component, we need to add some styles. We''ll define some
    colors, rounded corners, alignment, padding, and so on. For the `loading` styles,
    which will be applied when the loading indicator is displayed, we''ll update the
    padding to create a circle around the loading indicator:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个组件，我们需要添加一些样式。我们将定义一些颜色，圆角，对齐，填充等。对于显示加载指示器时将应用的`loading`样式，我们将更新填充以创建一个围绕加载指示器的圆形：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are done with the `Button` component. Now, lets''s work on the `App` class.
    Let''s start by importing all the dependencies:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了`Button`组件。现在，让我们来处理`App`类。让我们首先导入所有的依赖项：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `App` class is relatively simple. We will only need to define a `loading`
    property on the `state` object, which will toggle the `Button`''s animation. We''ll
    also render a `toolbar` and a `Button`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App`类相对简单。我们只需要在`state`对象上定义一个`loading`属性，它将切换`Button`的动画。我们还将渲染一个`toolbar`和一个`Button`：'
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As in the last recipe, we''ll need to manually enable the `LayoutAnimation`
    API on Android devices:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个示例一样，我们需要在Android设备上手动启用`LayoutAnimation`API：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we''ll add some `styles`, just some colors, padding, and alignment
    for centering the button on the screen:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一些`styles`，只是一些颜色，填充和居中对齐按钮在屏幕上：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/4be877c5-963e-4b57-9685-a03b35244a4c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4be877c5-963e-4b57-9685-a03b35244a4c.png)'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *step 3*, we added the `render` method for the `Button` component. Here,
    we received the `loading` property and, based on that value, we applied the corresponding
    styles to the `TouchableOpacity` button element. We also used two methods: one
    for rendering the label and the other for rendering the activity indicator.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们为`Button`组件添加了`render`方法。在这里，我们接收了`loading`属性，并根据该值将相应的样式应用于`TouchableOpacity`按钮元素。我们还使用了两种方法：一种用于渲染标签，另一种用于渲染活动指示器。
- en: In *step 6*, we executed the `onPress` callback. By default, we declared an
    empty function, so we don't have to check whether the value is present or not.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们执行了`onPress`回调。默认情况下，我们声明了一个空函数，因此我们不必检查值是否存在。
- en: The parent of this button should be responsible for updating the loading property
    when the `onPress` callback is called. From this component, we are only responsible
    for informing the parent when this button has been pressed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个按钮的父组件应该负责在调用`onPress`回调时更新`loading`属性。从这个组件中，我们只负责在按下此按钮时通知父组件。
- en: The `LayoutAnimation.eadeInEaseOut` method only queues an animation for the
    next render phase, which means the animation isn't executed right away. We are
    responsible for changing the styles that we want to animate. If we don't change
    any styles, then we won't see any animations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutAnimation.eadeInEaseOut`方法只是将动画排队到下一个渲染阶段，这意味着动画不会立即执行。我们负责更改我们想要动画的样式。如果我们不改变任何样式，那么我们就看不到任何动画。'
- en: The `Button` component doesn't know how the `loading` property gets updated.
    It might be because of a fetch request, a timeout, or any other action. The parent
    component is responsible for updating the `loading` property. Whenever any changes
    happen, we apply the new styles to the button and a smooth animation will occur.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`组件不知道`loading`属性是如何更新的。这可能是因为获取请求、超时或任何其他操作。父组件负责更新`loading`属性。无论发生任何变化，我们都会将新样式应用于按钮，并进行平滑的动画。'
- en: In *step 9*, we defined the content of the `App` class. Here, we make use of
    our `Button` component. When the button is pressed, the `state` of the `loading`
    property is updated, which will cause the animation to run every time the button
    is pressed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们定义了`App`类的内容。在这里，我们使用了我们的`Button`组件。当按下按钮时，`loading`属性的`state`将被更新，这将导致每次按下按钮时动画运行。
- en: Conclusion
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we've covered the fundamentals of animating your React Native
    app. These recipes have been aimed at both providing useful practical code solutions,
    and also establishing how to use the basic building blocks so that you are better
    equipped to create animations that fit your app. Hopefully, by now, you should
    be getting comfortable with the `Animated` and `LayoutAnimation` animation helpers.
    In [Chapter 7](84fe882a-ef68-470e-8c13-d220b128d4e0.xhtml), *Adding Advanced Animations
    to Your App*, we will combine the things we've learned here to build out more
    complex and interesting app-centric UI animations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了如何为您的React Native应用程序添加动画的基础知识。这些示例旨在提供有用的实际代码解决方案，并建立如何使用基本构建块，以便您更好地创建适合您的应用程序的动画。希望到目前为止，您应该已经开始熟悉`Animated`和`LayoutAnimation`动画助手。在[第7章](84fe882a-ef68-470e-8c13-d220b128d4e0.xhtml)中，*为您的应用程序添加高级动画*，我们将结合我们在这里学到的东西来构建更复杂和有趣的应用程序UI动画。
