- en: Adding Advanced Animations to Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的应用程序添加高级动画
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Removing items from a list component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表组件中删除项目
- en: Creating a Facebook reactions widget
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Facebook反应小部件
- en: Displaying images in fullscreen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全屏显示图像
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous chapter, we covered the basics of using the two main animation
    helpers in React Native: `Animated` and `LayoutAnimation`. In this chapter, we''ll
    take these concepts further by building out more complicated recipes that exhibit
    common native UX patterns.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了在React Native中使用两个主要动画助手`Animated`和`LayoutAnimation`的基础知识。在本章中，我们将通过构建更复杂的配方来进一步了解这些概念，展示常见的本地UX模式。
- en: Removing items from a list component
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表组件中删除项目
- en: In this recipe, we'll learn how to create list items in a `ListView` with an
    animated sideways slide. If the user slides the item past a threshold, the item
    is removed. This is a common pattern in many mobile apps with editable lists.
    We are also going to see how to use `PanResponder` to handle drag events.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在`ListView`中创建带有动画侧向滑动的列表项。如果用户将项目滑动超过阈值，项目将被移除。这是许多具有可编辑列表的移动应用程序中的常见模式。我们还将看到如何使用`PanResponder`来处理拖动事件。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to create an empty app. For this recipe, we'll name it `removing-list-items`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个空的应用程序。对于这个配方，我们将其命名为`removing-list-items`。
- en: We also need to create a new `ContactList` folder and two files inside it: `index.js` and `ContactItem.js`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个新的`ContactList`文件夹，并在其中创建两个文件：`index.js`和`ContactItem.js`。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by importing the dependencies for the main `App` class, as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从导入主`App`类的依赖项开始，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This component will be simple. All we need to render is a `toolbar` and the `ContactList` component
    that we imported in the previous step, as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件将很简单。我们只需要渲染一个`toolbar`和我们在上一步中导入的`ContactList`组件，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is all we need in order to start working on the actual list. Let''s open
    the file at `ContactList/index.js` and import all of the dependencies, as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们开始实际工作的全部内容。让我们打开`ContactList/index.js`文件，并导入所有依赖项，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then need to define some data. In a real-world app, we would fetch the data
    from an API, but to keep things simple and focused only on the drag functionality,
    let''s just define the data in this same file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要定义一些数据。在真实的应用程序中，我们会从API中获取数据，但为了保持简单并且只关注拖动功能，让我们在这个相同的文件中定义数据：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `state` for this component will only contain two properties: the data for
    the list and a Boolean value that will be updated when the dragging starts or
    ends. If you are not familiar with how `ListView` works, checkout the *Displaying
    a list of items* recipe in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml),
    *Creating a Simple React Native App*. Let''s define the data as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件的`state`只包含两个属性：列表的数据和一个布尔值，在拖动开始或结束时将更新。如果您不熟悉`ListView`的工作原理，请查看[第2章](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml)中的*显示项目列表*配方，*创建一个简单的React
    Native应用程序*。让我们定义数据如下：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `render` method only needs to display the list. In the `renderScrollComponent` property,
    we''ll enable scrolling only when the user is not swiping an item on the list.
    If the user is swiping, we want to disable vertical scrolling, as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法只需要显示列表。在`renderScrollComponent`属性中，我们将仅在用户不在列表上滑动项目时启用滚动。如果用户在滑动，我们希望禁用垂直滚动，如下所示：'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `renderItem` method will return each item in the list. Here, we need to
    send the contact information as a property, along with three callbacks:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`renderItem`方法将返回列表中的每个项目。在这里，我们需要将联系信息作为属性发送，以及三个回调函数：'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need to toggle the value of the swiping property on the `state` object,
    which will toggle whether vertical scroll on the list is locked or not:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要切换`state`对象上的swiping属性的值，这将切换列表上的垂直滚动是否被锁定：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When removing an item, we need to find the `index` of the given `contact` and
    then remove it from the original list. After that, we need to update `dataSource` on
    the state to re-render the list with the resulting data:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移除项目时，我们需要找到给定`contact`的`index`，然后从原始列表中将其移除。之后，我们需要更新`state`上的`dataSource`，以使用生成的数据重新渲染列表：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are done with the list, so now let''s focus on the list items. Let''s open
    the `ContactList/ContactItem.js` file and import the dependencies we''ll need:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表已经完成，现在让我们专注于列表项。让我们打开`ContactList/ContactItem.js`文件，并导入我们需要的依赖项：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We need to define `defaultProps` for this component. The `defaultProps` object
    will need an empty function for each of the four props being passed into it from
    the parent `ListView` element. The `onPress` function will execute when the item
    is pressed, the `onRemove` function will execute when the contact gets removed,
    and two drag functions will listen for drag events. On `state` , we only need
    to define an animated value to hold the *x*  and *y* coordinates of the dragging,
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为这个组件定义`defaultProps`。`defaultProps`对象将需要为从父级`ListView`元素传递给它的四个props中的每一个都提供一个空函数。当项目被按下时，`onPress`函数将被执行，当联系人被移除时，`onRemove`函数将被执行，而两个拖动函数将监听拖动事件。在`state`上，我们只需要定义一个动画值来保存拖动的x和y坐标，如下所示：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the component is created, we need to configure `PanResponder`. We will
    do this in the `componentWillMount` life cycle hook. `PanResponder` is responsible
    for handling gestures. It provides a simple API to capture the events generated
    by the user''s finger, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件被创建时，我们需要配置`PanResponder`。我们将在`componentWillMount`生命周期钩子中进行这个操作。`PanResponder`负责处理手势。它提供了一个简单的API来捕获用户手指生成的事件，如下所示：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s define the actual functions that will get executed for each callback
    defined in the previous step. We can start with the `handleShouldDrag` method,
    as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义实际的函数，这些函数将在前一步中定义的每个回调中执行。我们可以从`handleShouldDrag`方法开始，如下所示：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`handleReleaseItem` is a little bit more complicated. We are going to split
    this method into two steps. First, we need to figure out whether the current item
    needs to be removed or not. In order to do that, we need to set a threshold. If
    the user slides the element beyond our threshold, we''ll remove the item, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handleReleaseItem`有点复杂。我们将把这个方法分成两步。首先，我们需要弄清楚当前项目是否需要被移除。为了做到这一点，我们需要设置一个阈值。如果用户将元素滑动超出我们的阈值，我们将移除该项目，如下所示：'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have the configurations for the animation, we are ready to move the
    item! First, we''ll execute the `onDragEnd` callback and, if the item should be
    removed, we''ll  run the `onRemove` function, as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们对动画进行了配置，我们就准备好移动项目了！首先，我们将执行`onDragEnd`回调，如果项目应该被移除，我们将运行`onRemove`函数，如下所示：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have the full dragging system in place. Now we need to define the `render` method.
    We just need to display the contact name within the `TouchableHighlight` element,
    wrapped inside an `Animated.View`, as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动系统已经完全就绪。现在我们需要定义`render`方法。我们只需要在`TouchableHighlight`元素内显示联系人姓名，包裹在`Animated.View`中，如下所示：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need one more method on this class, which is fired on layout change via
    the `View` element''s `onLayout` prop. `setThreshold` will get the current `width` of `row` and
    set `threshold`. In this case, we''re setting it to be a third of the width of
    the screen. These values are required to decide whether to remove the item or
    not, as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在这个类上再添加一个方法，这个方法是通过`View`元素的`onLayout`属性在布局改变时触发的。`setThreshold`将获取`row`的当前`width`并设置`threshold`。在这种情况下，我们将其设置为屏幕宽度的三分之一。这些值是必需的，以决定是否移除该项，如下所示：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we''ll add some styles to the rows, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将为行添加一些样式，如下所示：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final app should look something like this screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该看起来像这个屏幕截图：
- en: '![](assets/55bfe95b-94b3-4398-8c7e-660e00cd7dad.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55bfe95b-94b3-4398-8c7e-660e00cd7dad.png)'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 5*, we defined the `swiping` property on the `state`. This property
    is just a Boolean that will be set to `true` when the dragging starts and to `false` when
    it has completed. We need this information in order to lock the vertical scrolling
    on the list while dragging around the item.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们在`state`上定义了`swiping`属性。这个属性只是一个布尔值，当拖动开始时设置为`true`，当完成时设置为`false`。我们需要这个信息来锁定列表在拖动项目时的垂直滚动。
- en: In *step 7*, we defined the content of each row in the list. The `onDragStart` property
    receives the `handleToggleSwipe` method, which will be executed when the dragging
    starts. We are also going to execute the same method when the dragging is completed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们定义了列表中每行的内容。`onDragStart`属性接收`handleToggleSwipe`方法，当拖动开始时将执行该方法。当拖动完成时，我们也将执行相同的方法。
- en: In the same step, we also send the `handleRemoveContact` method to each item.
    As the name suggests, we are going to remove the current item from the list when
    the user swipes it out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一步骤中，我们还将`handleRemoveContact`方法发送给每个项目。顾名思义，当用户将其滑出时，我们将从列表中移除当前项目。
- en: In *step 11*, we defined `defaultProps` and `state` for the item component.
    In past recipes, we have been creating animations using a single value, but for
    this case we need to handle the *x* and *y* coordinates, so we'll need an instance
    of `Animated.ValueXY`. Internally, this class handles two `Animated.Value` instances,
    and therefore the API is almost identical to those we've seen before.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们为项目组件定义了`defaultProps`和`state`。在过去的示例中，我们一直使用单个值来创建动画，但是在这种情况下，我们需要处理*x*和*y*坐标，所以我们需要一个`Animated.ValueXY`的实例。在内部，这个类处理两个`Animated.Value`实例，因此API几乎与我们之前看到的那些相同。
- en: 'In *step 12*, `PanResponder` gets created. The gesture system in React Native,
    like the event system in the browser, handles gestures in two phases when there''s
    a touch event: the capture and the bubble. In our case, we need to use the capture
    phase to figure out whether the current event is pressing the item or whether
    it''s trying to drag it. `onMoveShouldSetPanResponderCapture` will capture the
    event. Then, we need to decide whether we''ll drag the item or not by returning `true` or `false`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤12*中，创建了`PanResponder`。React Native中的手势系统，就像浏览器中的事件系统一样，在触摸事件时处理手势分为两个阶段：捕获和冒泡。在我们的情况下，我们需要使用捕获阶段来确定当前事件是按压项目还是尝试拖动它。`onMoveShouldSetPanResponderCapture`将捕获事件。然后，我们需要通过返回`true`或`false`来决定是否拖动该项。
- en: The `onPanResponderMove` prop will get the values from the animation on each
    frame, which will be applied to the `pan` object in the `state`. We need to use `Animated.event` to
    access the animation values for each frame. In this case, we only need the `x` value.
    Later, we'll use this value to run a different animation while returning the element
    to its original place or removing it from the screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`onPanResponderMove`属性将在每一帧从动画中获取值，这些值将被应用于`state`中的`pan`对象。我们需要使用`Animated.event`来访问每一帧的动画值。在这种情况下，我们只需要`x`值。稍后，我们将使用这个值来运行不同的动画，将元素返回到其原始位置或将其从屏幕上移除。'
- en: The `onPanResponderRelease` function will be executed when the user releases
    the item. If, for any other reason, the dragging gets interrupted, `onPanResponderTerminate` will
    get executed instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放物品时，`onPanResponderRelease`函数将被执行。如果由于任何其他原因，拖动被中断，将执行`onPanResponderTerminate`。
- en: In *step 13*, we need to check whether the current event is a simple press or
    a drag. We can do this by checking the delta on the *x*-axis. If the touch event
    has been moved more than two pixels, then the user is trying to drag the item,
    otherwise, they're trying to press the button. We evaluate the difference as an
    absolute number because the movement could be from left to right or right to left,
    and we want to accommodate both movements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们需要检查当前事件是简单的按压还是拖动。我们可以通过检查*x*轴上的增量来做到这一点。如果触摸事件移动了超过两个像素，那么用户正在尝试拖动物品，否则，他们正在尝试按下按钮。我们将差异评估为绝对数，因为移动可能是从左到右或从右到左，我们希望适应这两种移动。
- en: In *step 14*, we need to get the distance the item has moved with respect to
    the width of the device. If this distance is below our threshold we defined in `setThreshold`,
    then we need to remove these items. We are defining the `config` object for each
    animation, which will otherwise return the item to the original position. But
    if we need to remove the item, we check the direction and set the configuration
    accordingly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤14*中，我们需要获取物品相对于设备宽度移动的距离。如果这个距离低于我们在`setThreshold`中定义的阈值，那么我们需要移除这些物品。我们为每个动画定义了`config`对象，否则将返回物品到原始位置。但是，如果我们需要移除物品，我们会检查方向并相应地设置配置。
- en: In *step 16*, we defined the JSX. We set the styles that we want to animate
    on `Animated.View`. In this case, it's the `left` property, but instead of manually
    creating an object, we can call the `getLayout` method from our instance of `Animated.ValueXY` that
    we stored in `state.pan`, which returns the top and left properties with their
    existing values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤16*中，我们定义了JSX。我们在`Animated.View`上设置我们想要动画的样式。在这种情况下，它是`left`属性，但是我们可以从我们在`state.pan`中存储的`Animated.ValueXY`实例中调用`getLayout`方法，而不是手动创建对象，该方法返回具有其现有值的top和left属性。
- en: In the same step, we also set the event handlers for `Animated.View` by spreading
    out `this.panResponder.panHandlers` with a spread operator, which binds the dragging
    configuration we defined in the previous steps to `Animated.View`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一步骤中，我们还通过展开`this.panResponder.panHandlers`来为`Animated.View`设置事件处理程序，使用展开运算符将我们在前面步骤中定义的拖动配置绑定到`Animated.View`。
- en: We also defined a call to the `onPress` callback from `props`, passing in the
    current `contact` information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了对`props`中的`onPress`回调的调用，传入当前的`contact`信息。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find the `PanResponder` API documentation at:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到`PanResponder` API文档：
- en: '[https://facebook.github.io/react-native/docs/panresponder.html](https://facebook.github.io/react-native/docs/panresponder.html)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/panresponder.html](https://facebook.github.io/react-native/docs/panresponder.html)'
- en: Creating a Facebook reactions widget
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Facebook反应小部件
- en: In this recipe, we'll be creating a component that emulates the Facebook reaction
    widget. We will have a like button image which, when pressed, will show five icons.
    The row of icons will use a staggered slide-in animation while increasing opacity
    from `0` to `1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个模拟Facebook反应小部件的组件。我们将有一个喜欢按钮图像，当按下时，将显示五个图标。图标行将使用交错的滑入动画，同时从`0`增加到`1`的不透明度。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create an empty app called `facebook-widget`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`facebook-widget`的空应用程序。
- en: We are going to need some images to display a fake timeline. A few pictures
    of your cat will work, or you can use the cat pictures included in the corresponding
    repository on GitHub ([https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/facebook-widget](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/facebook-widget)).
    We'll also need five icons to display the five reactions, such as, angry, laughing,
    heart, and surprised, which can also be found in the corresponding repository.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些图片来显示一个假时间线。一些你的猫的照片就可以了，或者你可以使用GitHub上相应存储库中包含的猫的图片（[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/facebook-widget](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/facebook-widget)）。我们还需要五个图标来显示五种反应，比如，生气、笑、心、惊讶，这些也可以在相应的存储库中找到。
- en: To start we'll create two JavaScript files in our empty app: `Reactions/index.js` and `Reactions/Icon.js`.
    We need to copy our cat pictures to an `images/` folder in the root of the app,
    and the reaction icons should be placed in `Reactions/images`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在空应用程序中创建两个JavaScript文件：`Reactions/index.js`和`Reactions/Icon.js`。我们需要将猫的图片复制到应用程序根目录下的`images/`文件夹中，反应图标应放置在`Reactions/images`中。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to be creating a fake Facebook timeline on the `App` class. Let''s
    start by importing the dependencies, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`App`类上创建一个假的Facebook时间线。让我们首先导入依赖项，如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll need to import some images to render in our timeline. The JSX in this
    step is very simple: it''s just a `toolbar`, a `ScrollView` with two `Image`,
    and two `Reaction` components, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入一些图片来在我们的时间线中渲染。这一步中的JSX非常简单：只是一个`toolbar`，一个带有两个`Image`和两个`Reaction`组件的`ScrollView`，如下所示：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to add some basic `styles` for this component, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为这个组件添加一些基本的样式，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are ready to start working on the `Reactions` component of this recipe.
    Let''s start by importing dependencies, as follows. We will build out the imported `Icon` component
    in later steps:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备开始工作在这个食谱的`Reactions`组件。让我们首先导入依赖项，如下所示。我们将在后续步骤中构建导入的`Icon`组件：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s define `defaultProps` and the initial `state` next. We''ll also need
    to require the `like` icon image to display it on screen, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`defaultProps`和初始`state`。我们还需要要求`like`图标图片以在屏幕上显示它，如下所示：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s define two methods: one that sets the selected value of `state` to the
    selected `reaction`, and another that toggles the `show` value of `state` to show
    or hide the row of reactions accordingly, as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义两种方法：一种是将`state`的选定值设置为选定的`reaction`，另一种是切换`state`的`show`值以相应地显示或隐藏反应行，如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll define the `render` method for this component. We are going to display
    an image, which when pressed, will call the `toggleReactions` method that we defined
    previously, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为此组件定义`render`方法。我们将显示一张图片，当按下时，将调用我们之前定义的`toggleReactions`方法，如下所示：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You''ll notice in this step that we''re calling the `renderReactions` method.
    Next, we''ll render all of the icons that we want to display when the user presses
    the main reaction button, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，您会注意到我们正在调用`renderReactions`方法。接下来，我们将渲染用户按下主反应按钮时要显示的所有图标，如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to set `styles` for this component. We''ll set sizes for the reaction
    icon images and define some padding. The `reactions` container will have a height
    of `0`, since the icons will be floating, and we don''t want any extra space added:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为这个组件设置 `styles`。我们将为反应图标图像设置大小并定义一些填充。`reactions` 容器的高度将为 `0`，因为图标将浮动，我们不希望添加任何额外的空间：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Icon` component is currently missing, so if we try to run our app at this
    point, it will fail. Let''s build out this component by opening the `Reactions/Icon.js` file
    and adding the imports for the component, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Icon` 组件目前缺失，所以如果我们尝试在这一点上运行我们的应用程序，它将失败。让我们通过打开 `Reactions/Icon.js` 文件并添加组件的导入来构建这个组件，如下所示：'
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s define the icons we''ll be using. We are going to use an object for
    the icons so that we can easily retrieve each image by its key name, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义我们将要使用的图标。我们将使用一个对象来存储图标，这样我们可以通过键名轻松检索到每个图像，如下所示：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we should define `defaultProps` for this component. We don''t need to define
    an initial state:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该为这个组件定义 `defaultProps`。我们不需要定义初始状态：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The icons should appear on screen via an animation, so we''ll need to create
    and run the animation when the component is mounted, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图标应该通过动画出现在屏幕上，所以当组件挂载时，我们需要创建并运行动画，如下所示：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the icon is pressed, we need to execute the `onPress` callback to inform
    the parent that a reaction was selected. We will send the name of the reaction
    as a parameter, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图标被按下时，我们需要执行 `onPress` 回调来通知父组件已选择了一个反应。我们将反应的名称作为参数发送，如下所示：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last piece of the puzzle is the `render` method, where we''ll define the
    JSX for this component, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拼图的最后一块是 `render` 方法，我们将在这个组件中定义 JSX，如下所示：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the final step, we''ll add styles for each `icon`. We need the icons to
    float, so we''ll set `position` to `absolute` and `width` and `height` to `40` pixels.
    After this change, we should be able to run our app:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将为每个 `icon` 添加样式。我们需要图标浮动，所以我们将 `position` 设置为 `absolute`，`width` 和
    `height` 设置为 `40` 像素。在这个改变之后，我们应该能够运行我们的应用程序：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final app should look something like this screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该看起来像这个屏幕截图：
- en: '![](assets/6667bd05-b197-4847-85db-88e66021c454.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6667bd05-b197-4847-85db-88e66021c454.png)'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2*, we defined the `Reactions` component in the timeline. For now,
    we are not focusing on handling data, but rather on displaying the UI. Therefore,
    we are not sending any callback via `Reactions` props to get the selected value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们在时间线中定义了 `Reactions` 组件。现在，我们不专注于处理数据，而是专注于显示用户界面。因此，我们不会通过 `Reactions`
    属性发送任何回调来获取所选值。
- en: In *step 5*, we defined `defaultProps` and the initial `state`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们定义了 `defaultProps` 和初始 `state`。
- en: 'We have two properties in the state:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态中有两个属性：
- en: The `show` prop is a Boolean. We use it to toggle the reactions icons when the
    user presses the main button. When `false`, we hide the reactions, and when `true`,
    we run the animation to show each icon.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show` 属性是一个布尔值。我们用它来在用户按下主按钮时切换反应图标。当为 `false` 时，我们隐藏反应，当为 `true` 时，我们运行动画来显示每个图标。'
- en: '`selected` contains the current selection. Every time a new reaction gets selected,
    we are going to update this prop.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected` 包含当前的选择。每当选择新的反应时，我们将更新这个属性。'
- en: In *step 8*, we render the icons. Here, we need to send the name of the icon
    to every instance created. We also send a `delay` of 100 milliseconds for each
    icon, which will create a nice stagger animation. The `onPress` prop receives
    the `onSelectReaction` method defined in *step 6*, which sets the selected reaction
    on `state`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 8* 中，我们渲染图标。在这里，我们需要将图标的名称发送到每个创建的实例。我们还为每个图标发送了 100 毫秒的 `delay`，这将创建一个漂亮的交错动画。`onPress`
    属性接收了 *步骤 6* 中定义的 `onSelectReaction` 方法，该方法在 `state` 上设置了所选的反应。
- en: In *step 13*, we create the animation. First, we define the `animatedValue` variable
    using the `Animated.Value` helper, which, as mentioned in previous recipes, is
    the class responsible for holding the value for each frame in the animation. As
    soon as the component is mounted, we run the animation. The animations progress
    from `0` to `1`, with a duration of 200 milliseconds and using an elastic easing
    function, and we delay the animation based on the received `delay` prop.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们创建了动画。首先，我们使用`Animated.Value`助手定义了`animatedValue`变量，正如在之前的配方中提到的那样，这是负责在动画中每一帧中保存值的类。组件一旦挂载，我们就运行动画。动画的进度从`0`到`1`，持续时间为200毫秒，使用弹性缓动函数，并根据接收到的`delay`属性延迟动画。
- en: In *step 15*, we defined the JSX for the `Icon` component. Here we animate the `top` and `opacity` properties.
    For the `top` property, we need to interpolate the values from `animatedValue`,
    so that the icon moves 95 pixels up from its original position. The required values
    for the `opacity` property are from `0` to `1`, and since we don't need to interpolate
    anything to accomplish this, we can use `animatedValue` directly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤15*中，我们为`Icon`组件定义了JSX。在这里，我们对`top`和`opacity`属性进行动画处理。对于`top`属性，我们需要从`animatedValue`中插值出值，以便图标从其原始位置向上移动95像素。`opacity`属性所需的值从`0`到`1`，由于我们不需要插值任何内容来完成这一点，因此我们可以直接使用`animatedValue`。
- en: 'The `left` value is calculated based on the `index`: we just move the icon
    50 pixels to the left of the previous icon, which will avoid rendering the icons
    all in the sample place.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`left`值是根据`index`计算的：我们只是将图标向前一个图标的左侧移动50像素，这样可以避免将图标全部渲染在同一个位置。'
- en: Displaying images in fullscreen
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在全屏显示图像
- en: In this recipe, we'll create a timeline of images. When the user presses any
    of the images, it will fullscreen the image with a black background.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个图像时间轴。当用户按下任何图像时，它将在黑色背景下全屏显示图像。
- en: We will use an opacity animation for the background, and we'll slide the image
    in from its original position.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为背景使用不透明度动画，并将图像从其原始位置滑入。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create an empty app called `photo-viewer`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`photo-viewer`的空白应用程序。
- en: In addition, we'll also create `PostContainer/index.js` for showing each image
    in the timeline, and `PhotoViewer/index.js` for showing the selected image in
    fullscreen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将创建`PostContainer/index.js`来显示时间轴中的每个图像，以及`PhotoViewer/index.js`来在全屏显示所选图像。
- en: You can either use the images included in this recipe's repository hosted on
    GitHub ([https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/photo-viewer](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/photo-viewer)),
    or use a few photos of your own. Place them in an `images` folder in the root
    of the project.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此处配方存储库中托管在GitHub上的图像（[https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/photo-viewer](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/photo-viewer)）中包含的图像，也可以使用自己的一些照片。将它们放在项目根目录中的`images`文件夹中。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to display a timeline with images in the `App` class. Let''s import
    all of the dependencies, including the two other components we''ll build out in
    later steps, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`App`类中显示一个带有图像的时间轴。让我们导入所有依赖项，包括我们稍后将构建的另外两个组件，如下所示：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this step, we''ll define the data that we are going to render. It''s just
    a simple array of objects containing `title` and `image`, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将定义要渲染的数据。这只是一个包含`title`和`image`的对象数组。
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we need to declare the initial `state` of this component. We will update
    the `selected` and `position` properties when any of the images gets pressed,
    as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要声明此组件的初始`state`。当按下任何图像时，我们将更新`selected`和`position`属性，如下所示：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In order to update `state`, we are going to declare two methods: one to set
    the value of the image that has been pressed and another to remove those values
    when the viewer gets closed:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更新`state`，我们将声明两个方法：一个用于设置被按下的图像的值，另一个用于在查看器关闭时删除这些值：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we are ready to work on the `render` method. Here we''ll need to render
    each image inside `ScrollView` so the list will be scrollable, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备开始处理`render`方法。在这里，我们需要在`ScrollView`中渲染每个图像，以便列表可以滚动，如下所示：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the previous step, we are calling the `renderViewer` method. Here we''ll
    show the viewer component only if there''s a post `selected` in the state. We
    are also sending the initial position to start the animation and a callback to
    close the viewer, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们调用了`renderViewer`方法。在这里，我们只会在状态中有一个帖子`selected`时显示查看器组件。我们还会发送初始位置以开始动画和一个关闭查看器的回调，如下所示：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The styles for this component are very simple, only some colors and padding,
    as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件的样式非常简单，只有一些颜色和填充，如下所示：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The timeline is complete, but if we try to run our app, it will fail. Let''s
    work on the `PostContainer` component. We''ll start by importing the dependencies,
    as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时间轴已经完成，但是如果我们尝试运行我们的应用程序，它将失败。让我们开始处理`PostContainer`组件。我们将首先导入依赖项，如下所示：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We only need two `props` for this component. The `post` prop will receive the
    image data, `title` and `image`, and the `onPress` prop is a callback that we''ll
    execute when the image gets pressed, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要两个`props`来定义这个组件。`post`属性将接收图像数据，`title`和`image`，`onPress`属性是一个回调，当图像被按下时我们将执行它，如下所示：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This component will be inside of `ScrollView`. This means its position will
    be changing when the user starts scrolling the content. When pressing the image,
    we need to get the current position on the screen and send this information to
    the parent component, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件将在`ScrollView`中。这意味着当用户开始滚动内容时，它的位置将会改变。当按下图像时，我们需要获取屏幕上的当前位置并将这些信息发送给父组件，如下所示：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It''s time to define the JSX for this component. To keep things simple, we
    are only going to render `image` and `title`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候为这个组件定义JSX了。为了保持简单，我们只会渲染`image`和`title`：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As always, we need to define some styles for this component. We are going to
    add some colors and padding, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要为这个组件定义一些样式。我们将添加一些颜色和填充，如下所示：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we run the app now, we should be able to see the timeline, however if we
    press any of the images, an error will be thrown. We need to define the viewer,
    so let''s open the `PhotoViewer/index.js` file and import the dependencies:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，我们应该能够看到时间轴，但是如果我们按下任何图像，将会抛出错误。我们需要定义查看器，所以让我们打开`PhotoViewer/index.js`文件并导入依赖项：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s define `props` for this component. In order to center the image on the
    screen, we need to know the `height` of the current device:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个组件定义`props`。为了将图像居中显示在屏幕上，我们需要知道当前设备的`height`：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We want to run two animations when showing this component, so we''ll need to
    initialize and run the animation after the component is mounted. The animation
    is simple: it just goes from `0` to `1` in `400` milliseconds with some easing
    applied, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当显示这个组件时，我们希望运行两个动画，因此我们需要在组件挂载后初始化并运行动画。动画很简单：它只是在`400`毫秒内从`0`到`1`进行一些缓动，如下所示：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When the user presses the close button, we need to execute the `onClose` callback
    to inform the parent that this component needs to be removed, as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户按下关闭按钮时，我们需要执行`onClose`回调来通知父组件需要移除这个组件，如下所示：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are going to split the `render` method into two steps. First, we need to
    interpolate the values for the animations, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把`render`方法分为两步。首先，我们需要插入动画的值，如下所示：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We only need to define three elements: `Animated.View` to animate the background,
    `Animated.Image` to display the image, and a close button. We are setting the `opacity` style
    to the main view, which will animate the image background from transparent to
    black. The image will slide in at the same time, creating a nice effect:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要定义三个元素：`Animated.View`来动画显示背景，`Animated.Image`来显示图像，以及一个关闭按钮。我们将`opacity`样式设置为主视图，这将使图像背景从透明变为黑色。图像将同时滑入，产生一个很好的效果：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We are almost done! The last step in this recipe is to define the styles. We
    need to set the position of the main container to absolute so that the image is
    on top of everything else. We''ll also move the close button to the top-right
    of the screen, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了！这个食谱中的最后一步是定义样式。我们需要将主容器的位置设置为绝对位置，以便图像位于其他所有内容的顶部。我们还将关闭按钮移动到屏幕的右上角，如下所示：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The final app should look similar to the following screenshot:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的应用程序应该类似于以下截图：
- en: '![](assets/83d6acab-c119-4b20-88a1-d986453c805f.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83d6acab-c119-4b20-88a1-d986453c805f.png)'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 4*, we defined two properties on `state`: `selected` and `position`.
    The `selected` property holds the image data for the pressed image, which can
    be any of the `timeline` objects defined in *step 3*. The `position` property
    will hold the current *y-*coordinate on the screen, which is used later to animate
    the image from its original position to the center of the screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们在`state`中定义了两个属性：`selected`和`position`。`selected`属性保存了按下图像的图像数据，可以是*步骤3*中定义的`timeline`对象中的任何一个。`position`属性将保存屏幕上的当前*y*坐标，稍后用于将图像从其原始位置动画到屏幕中心。
- en: In *step 5*, we `map` over the `timeline` array to render each `post`. We used
    the `PostContainer` element for each post, sending the `post` information and
    using the `onPress` callback to set the pressed image.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们对`timeline`数组进行`map`操作，以渲染每个`post`。我们为每个post使用`PostContainer`元素，发送`post`信息，并使用`onPress`回调来设置按下的图像。
- en: In *step 10*, we need the current position of the image. To achieve this, we
    use the `measure` method from the component we want to get the information from.
    This method receives a callback function and retrieves, among other properties, `width`, `height`,
    and the current position on the screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤10*中，我们需要图像的当前位置。为了实现这一点，我们使用所需信息的组件的`measure`方法。该方法接收一个回调函数，并检索，除其他属性外，`width`、`height`和屏幕上的当前位置。
- en: We are using a reference to access the component, declared in the JSX on the
    next step.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用引用来访问在下一步的JSX中声明的组件。
- en: In *step 11*, we declared the JSX for the component. In the main wrapper container,
    we set the `ref` property, which is used to get the current position of the image.
    Whenever we want to access a component on any of the methods of the current class,
    we use a reference. We can create references by simply setting the `ref` property
    and assigning a name to any component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们声明了组件的JSX。在主包装容器中，我们设置了`ref`属性，用于获取图像的当前位置。每当我们想要在当前类的任何方法中访问组件时，我们都使用引用。我们可以通过简单地设置`ref`属性并为任何组件分配一个名称来创建引用。
- en: In *step 18*, we interpolate the animation values to get the correct top value
    for each frame. The output of that interpolation will start from the current position
    of the image and progress to the middle of the screen. This way, depending on
    whether the values are negative or positive, the animation will run from bottom
    to top, or the other way around.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤18*中，我们插值动画值以获得每一帧的正确顶部值。插值的输出将从图像的当前位置开始，并向屏幕中间进展。这样，根据值是负数还是正数，动画将从底部向顶部运行，或者反之。
- en: We don't need to interpolate `opacity`, since the current animated value already
    goes from `0` to `1`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要插值 `opacity`，因为当前的动画值已经从 `0` 到 `1`。
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'An in depth explanation of Refs and the DOM can be found at the following link:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 和 DOM 的深入解释可以在以下链接找到：
- en: '[https://reactjs.org/docs/refs-and-the-dom.html](https://reactjs.org/docs/refs-and-the-dom.html).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/refs-and-the-dom.html](https://reactjs.org/docs/refs-and-the-dom.html)。'
