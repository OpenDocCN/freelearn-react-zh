- en: App Workflow and Third-Party Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序工作流和第三方插件
- en: 'This chapter works a bit differently, so we will first look into it before
    we go ahead and cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的工作方式有些不同，因此我们将首先了解它，然后再继续覆盖以下示例：
- en: React Native development tools
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native开发工具
- en: Planning your app and choosing your workflow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划您的应用程序并选择您的工作流程
- en: Using NativeBase for cross-platform UI components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NativeBase来实现跨平台UI组件
- en: Using glamorous-native for styling UI components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用glamorous-native来为UI组件添加样式
- en: Using react-native-spinkit for adding animated loading indicators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用react-native-spinkit添加动画加载指示器
- en: Using react-native-side-menu for adding side navigation menus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用react-native-side-menu添加侧边导航菜单
- en: Using react-native-modalbox for adding modals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用react-native-modalbox添加模态框
- en: How this chapter works
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的工作方式
- en: In this chapter, we'll be taking a closer look at how each method of bootstrapping
    a new React Native app works, and how we can integrate third-party packages that
    may or may not be Expo friendly. In previous chapters, the focus has been entirely
    on building functional pieces of a React Native app. In this chapter, many of
    these recipes will therefore also serve a secondary purpose of illustrating how
    different packages can be implemented using different workflows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更仔细地了解初始化新的React Native应用程序的每种方法的工作原理，以及如何集成可能与Expo兼容或不兼容的第三方包。在之前的章节中，重点完全放在构建React
    Native应用程序的功能部分上。因此，在本章中，许多这些示例也将用于说明如何使用不同的工作流程来实现不同的包。
- en: 'In most of the recipes in this chapter, we will begin with a pure React Native
    project initialized with the React Native CLI command, which is done as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的大多数示例中，我们将从使用React Native CLI命令初始化的纯React Native项目开始，方法如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When creating a new React Native app, you'll need to choose the right tooling
    for initializing your app. Generally speaking, the tools you use for bootstrapping
    and developing your React Native app will either focus on streamlining the development
    process and purposefully obfuscating native code from you for the sake of ease
    and mental overhead, or keep your development process flexible by providing access
    to all native code and allowing the use of more third-party plugins.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的React Native应用程序时，您需要选择适合初始化应用程序的正确工具。一般来说，您用于引导和开发React Native应用程序的工具将专注于简化开发过程，并故意为了方便和心理负担而模糊化本地代码，或者通过提供对所有本地代码的访问以及允许使用更多第三方插件来保持开发过程的灵活性。
- en: 'There are two methods for initializing and developing your app: Expo and the
    React Native CLI. Until recently, there was a distinct third method, using **Create
    React Native App** (**CRNA**). CRNA has since been merged with the Expo project,
    and only continues to exist as a separate entity to provide backwards compatibility.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和开发应用有两种方法：Expo和React Native CLI。直到最近，还有第三种方法，使用Create React Native App（CRNA）。CRNA已经与Expo项目合并，只作为一个独立实体继续存在，以提供向后兼容性。
- en: Expo falls into the first category of tools, providing a more robust and developer-friendly
    development workflow at the cost of some flexibility. Apps bootstrapped with Expo
    also have access to a multitude of useful features provided by the Expo SDK, such
    as  `BarcodeScanner`, `MapView`, `ImagePicker`, and so many more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Expo属于工具的第一类，提供了更强大和开发者友好的开发工作流程，但牺牲了一些灵活性。使用Expo引导的应用程序还可以访问由Expo SDK提供的大量有用功能，例如`BarcodeScanner`、`MapView`、`ImagePicker`等等。
- en: 'Initialize an app with the React Native CLI, via the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native CLI通过以下命令初始化应用程序：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This provides flexibility at the cost of ease of development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了灵活性，但开发的难度也相应增加。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is said to be a pure React Native app, since none of the native code is hidden
    away from the developer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 据说这是一个纯React Native应用程序，因为没有任何原生代码对开发人员隐藏。
- en: 'As a rule of thumb, a pure React Native app will be required if using third-party
    packages whose setup requires running the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果使用第三方包的设置需要运行以下命令，则需要一个纯React Native应用程序：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So what do you do when you are halfway through building an app with Expo, only
    to find out that a package integral to your app''s requirements is not supported
    by an Expo development workflow? Luckily, Expo has a method for turning an Expo
    project into a pure React Native app, just as if it had been created with the
    following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当您在使用Expo构建应用程序时，却发现一个对应用程序要求至关重要的包不受Expo开发工作流支持时，该怎么办？幸运的是，Expo有一种方法可以将Expo项目转换为纯React
    Native应用程序，就好像是用以下命令创建的一样：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a project is ejected, all of the Native code is unpacked into `ios` and
    `android` folders, and the `App.js` file is split into `App.js` and `index.js`,
    exposing the code that mounts the root React Native component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目被弹出时，所有的原生代码都被解压到`ios`和`android`文件夹中，`App.js`文件被拆分为`App.js`和`index.js`，暴露出挂载根React
    Native组件的代码。
- en: But what if your Expo app depends on features provided by the Expo SDK? After
    all, much of the value of developing with Expo comes from the excellent features
    the SDK provides, including `AuthSession`, `Permissions`, `WebBrowser`, and others.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您的Expo应用依赖于Expo SDK提供的功能呢？毕竟，使用Expo开发的价值很大程度上来自于Expo提供的出色功能，包括`AuthSession`、`Permissions`、`WebBrowser`等。
- en: That’s where ExpoKit comes into play. When you choose to eject from a project,
    you’re given the option of including ExpoKit as part of the ejected project. Including
    ExpoKit will ensure that all of the Expo dependencies being used in your app will
    continue to work, and also give you the ability to continue using all the features
    of the Expo SDK, even after the app has been ejected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是ExpoKit发挥作用的地方。当您选择从项目中弹出时，您可以选择将ExpoKit包含在弹出的项目中。包含ExpoKit将确保您应用中使用的所有Expo依赖项将继续工作，并且还可以让您在应用被弹出后继续使用Expo
    SDK的所有功能。
- en: For a deeper understanding of the eject processes, you can read the Expo documentation
    at [https://docs.expo.io/versions/latest/expokit/eject](https://docs.expo.io/versions/latest/expokit/eject).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解弹出过程，您可以阅读Expo文档，链接为[https://docs.expo.io/versions/latest/expokit/eject](https://docs.expo.io/versions/latest/expokit/eject)。
- en: React Native development tools
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native开发工具
- en: As with any development tools, there is going to be a trade-off between flexibility
    and ease of use. I encourage you start by using Expo for your React Native development
    workflow, unless you’re sure you’ll need access to the native code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何开发工具一样，灵活性和易用性之间存在权衡。我鼓励您在进行React Native开发工作流时首先使用Expo，除非您确定需要访问原生代码。
- en: Expo
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Expo
- en: 'This was taken from the [expo.io](http://expo.io) site:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从[expo.io](http://expo.io)网站上获取的：
- en: '"Expo is a free and open source toolchain built around React Native to help
    you build native iOS and Android projects using JavaScript and React."'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"Expo是围绕React Native构建的免费开源工具链，帮助您使用JavaScript和React构建原生iOS和Android项目。"'
- en: 'Expo is becoming an ecosystem of its own, and is made up of five interconnected
    tools:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Expo正在成为一个自己的生态系统，由五个相互连接的工具组成：
- en: '**Expo CLI**: The command-line interface for Expo.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expo CLI**：Expo的命令行界面。'
- en: 'We''ve been using the Expo CLI to create, build, and serve apps. A list of
    all the commands supported by the CLI can be found in the official documentation
    at the following link:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用Expo CLI来创建、构建和提供应用程序。CLI支持的所有命令列表可以在官方文档中找到，链接如下：
- en: '[  https://docs.expo.io/versions/latest/workflow/expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.expo.io/versions/latest/workflow/expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli)'
- en: '**Expo developer tools**: This is a browser-based tool that automatically runs
    whenever an Expo app is started from the Terminal via the `expo start` command.
    It provides active logs for your in-development app, and quick access to running
    the app locally and sharing the app with other developers.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expo开发者工具**：这是一个基于浏览器的工具，每当通过`expo start`命令从终端启动Expo应用程序时，它会自动运行。它为您的开发中应用程序提供活动日志，并快速访问本地运行应用程序并与其他开发人员共享应用程序。'
- en: '**Expo Client**: An app for Android and iOS. This app allows you to run your
    React Native project within the Expo app on the device, without the need for installing
    it. This allows developers to hot reload on a real device, or share development
    code with anyone else without the need for installing it.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expo客户端**：适用于Android和iOS的应用程序。这个应用程序允许您在设备上的Expo应用程序中运行您的React Native项目，而无需安装它。这使开发人员可以在真实设备上进行热重载，或者与其他人共享开发代码，而无需安装它。'
- en: '**Expo Snack**: Hosted at [https://snack.expo.io](https://snack.expo.io/),
    this web app allows you to work on a React Native app in the browser, with a live
    preview of the code you’re working on. If you''ve ever used CodePen or JSFiddle,
    Snack is the same concept applied to React Native applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expo Snack**：托管在[https://snack.expo.io](https://snack.expo.io)，这个网络应用程序允许您在浏览器中使用React
    Native应用程序，并实时预览您正在工作的代码。如果您曾经使用过CodePen或JSFiddle，Snack是将相同的概念应用于React Native应用程序。'
- en: '**Expo SDK**: This is the SDK that houses a wonderful collection of JavaScript
    APIs that provide Native functionality not found in the base React Native package,
    including working with the device''s accelerometer, camera, notifications, geolocation,
    and many others. This SDK comes baked in with every new project created with Expo.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expo SDK**：这是一个SDK，其中包含了一组精彩的JavaScript API，提供了在基本React Native软件包中找不到的本机功能，包括使用设备的加速计、相机、通知、地理位置等。这个SDK已经与使用Expo创建的每个新项目一起提供。'
- en: These tools together make up the Expo workflow. With the Expo CLI, you can create
    and build new applications with Expo SDK support baked in. The CLI also provides
    a simple way to serve your in-development app by automatically pushing your code
    to Amazon S3 and generating a URL for the project. From there, the CLI generates
    a QR code linked to the hosted code. Open the Expo Client app on your iPhone or
    Android device, scan the QR code, and BOOM there’s your app, equipped with hot
    reload! And since the app is hosted on Amazon S3, you can even share the in-development
    app with other developers in real time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具共同组成了Expo工作流程。使用Expo CLI，您可以创建并构建具有Expo SDK支持的新应用程序。CLI还提供了一种简单的方式，通过自动将您的代码推送到Amazon
    S3并为项目生成URL来为您的开发中应用程序提供服务。然后，CLI生成一个与托管代码链接的QR码。在您的iPhone或Android设备上打开Expo Client应用程序，扫描QR码，BOOM，您的应用程序就在那里，配备了热重载！由于应用程序托管在Amazon
    S3上，您甚至可以实时与其他开发人员共享开发中的应用程序。
- en: React Native CLI
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native CLI
- en: 'The original bootstrapping method for creating a new React Native app using
    the command is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令创建新的React Native应用程序的原始引导方法如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is provided by the React Native CLI. You'll likely only be using this method
    of bootstrapping a new app if you're sure you'll need access to the native layer
    of the app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由React Native CLI提供的。如果您确定需要访问应用程序的本机层，则可能只会使用这种引导新应用程序的方法。
- en: In the React Native community, an app created with this method is said to be
    a pure React Native app, since all of the development and Native code files are
    exposed to the developer. While this provides the most freedom, it also forces
    the developer to maintain the native code. If you’re a JavaScript developer that’s
    jumped onto the React Native bandwagon because you intend on writing native applications
    solely with JavaScript, having to maintain the native code in a React Native project
    is probably the biggest disadvantage of this method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native社区中，使用这种方法创建的应用程序被称为纯React Native应用程序，因为所有的开发和本地代码文件都暴露给开发人员。虽然这提供了最大的自由，但也迫使开发人员维护本地代码。如果你是一个JavaScript开发人员，因为你打算仅使用JavaScript编写本地应用程序而跳上React
    Native的车，那么在React Native项目中维护本地代码可能是这种方法最大的缺点。
- en: On the other hand, you'll have access to more third-party plugins when working
    on an app that's been bootstrapped this process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在使用已经引导的应用程序时，您将可以访问更多的第三方插件。
- en: Get direct access to the native portion of the code base. You'll also be able
    to sidestep a few of the limitations in Expo currently, particularly the inability
    to use background audio or background GPS services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问代码库的本地部分。您还将能够绕过Expo目前的一些限制，特别是无法使用后台音频或后台GPS服务。
- en: CocoaPods
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CocoaPods
- en: Once you begin working with apps that have components that use native code,
    you're going to be using CocoaPods in your development as well. CocoaPods is a
    dependency manager for Swift and Objective-C Cocoa projects. It works nearly the
    same as npm, but manages open source dependencies for native iOS code instead
    of JavaScript code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始使用具有使用本地代码的组件的应用程序，你也将在开发中使用CocoaPods。CocoaPods是Swift和Objective-C Cocoa项目的依赖管理器。它几乎与npm相同，但是管理的是本地iOS代码的开源依赖，而不是JavaScript代码。
- en: 'We won''t be using CocoaPods much in this book, but React Native makes use
    of CocoaPods for some of its iOS integration, so having a basic understanding
    of the manager can be helpful. Just as the `package.json` file houses all of the
    packages for a JavaScript project managed with npm, CocoaPods uses a `Podfile`
    for listing a project''s iOS dependencies. Likewise, these dependencies can be
    installed using the command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们不会经常使用CocoaPods，但React Native在其iOS集成中使用CocoaPods，因此对管理器的基本了解可能会有所帮助。就像`package.json`文件包含了使用npm管理的JavaScript项目的所有包一样，CocoaPods使用`Podfile`列出项目的iOS依赖关系。同样，这些依赖项可以使用以下命令安装：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Ruby is required for CocoaPods to run. Run the command at the command line
    to verify Ruby is already installed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CocoaPods需要Ruby才能运行。在命令行上运行以下命令来验证Ruby是否已安装：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If not, it can be installed with Homebrew with the command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，可以使用Homebrew命令安装：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once Ruby has been installed, CocoaPods can be installed via the command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Ruby被安装，CocoaPods可以通过命令安装：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you encounter any issues while installing, you can read the official CocoaPods
    *Getting Started* guide at [https://guides.cocoapods.org/using/getting-started.html](https://guides.cocoapods.org/using/getting-started.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装过程中遇到任何问题，可以阅读官方CocoaPods *入门*指南[https://guides.cocoapods.org/using/getting-started.html](https://guides.cocoapods.org/using/getting-started.html)。
- en: Planning your app and choosing your workflow
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划您的应用程序并选择您的工作流程
- en: 'When trying to choose which development workflow best fits your app''s needs,
    here are a few things you should consider:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试选择最适合您的应用程序需求的开发工作流程时，有一些事情您应该考虑：
- en: Will I need access to the native portion of the code base?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要访问代码库的本地部分？
- en: Will I need any third-party packages in my app that are not supported by Expo,
    that is require running the command react-native link?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要任何Expo不支持的第三方包，需要运行react-native link命令？
- en: Will my app need to play audio while it is not in the foreground?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序不在前台时，是否需要播放音频？
- en: Will my app need location services while it is not in the foreground?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序不在前台时，是否需要位置服务？
- en: Am I comfortable working, at least nominally, in Xcode and Android Studio?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否愿意至少在Xcode和Android Studio中进行工作？
- en: In my experience, Expo usually serves as the best starting place. It provides
    a lot of benefits to the development process, and gives you an escape hatch in
    the eject process if your app grows beyond the original requirements. I would
    recommend only starting development with the React Native CLI if you're sure your
    app needs something that cannot be provided by an Expo app, or if you're sure
    you will need to work on the native code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，Expo通常是最好的起点。它为开发过程提供了许多好处，并且在应用程序超出原始要求时，可以通过退出过程来获得逃生舱。我建议只有在确定您的应用程序需要Expo应用程序无法提供的内容，或者确定您将需要处理本机代码时，才使用React
    Native CLI开始开发。
- en: I also recommend browsing the Native Directory hosted at [http://native.directory](http://native.directory).
    This site has a very large catalog of the third-party packages available for React
    Native development. Each package listed on the site has an estimated stability,
    popularity, and links to documentation. Arguably the best feature of the Native
    Directory, however, is the ability to filter packages by what kind of device/development
    they support, including iOS, Android, Expo, and web. This will help you narrow
    down your package choices and better indicate which workflow should be adopted
    for a given app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议浏览托管在[http://native.directory](http://native.directory)的Native Directory。该网站拥有大量用于React
    Native开发的第三方软件包目录。该网站上列出的每个软件包都有估计的稳定性、流行度和链接到文档。然而，Native Directory最好的功能可能是能够按照它们支持的设备/开发类型（包括iOS、Android、Expo和Web）来过滤软件包。这将帮助您缩小软件包选择范围，并更好地指示应采用哪种工作流程。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll begin with the React Native CLI setup of our app, which will create a
    new pure React Native app, giving us access to all of the Native code, but also
    requiring that Xcode and Android Studio are installed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从React Native CLI设置我们的应用程序开始，这将创建一个新的纯React Native应用程序，使我们可以访问所有本机代码，但也需要安装Xcode和Android
    Studio。
- en: You may recall from [Chapter 1](2cdfc766-d9d3-4f8f-ba71-521e82b8fed5.xhtml),  *Setting
    Up Your Environment*, that some of these steps have already been covered in detail.
    There is no need to reinstall anything listed here that was described there as
    well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得[第1章](2cdfc766-d9d3-4f8f-ba71-521e82b8fed5.xhtml)中*设置您的环境*，其中一些步骤已经详细介绍了。无需重新安装已在那里描述的任何列在此处的内容。
- en: 'First, we''ll install all the dependencies needed for working with a pure React
    Native app, starting with the Homebrew ([https://brew.sh/](https://brew.sh/))
    package manager for macOS. As stated on the project''s home page, Homebrew can
    be easily installed from the Terminal via the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将安装所有与纯React Native应用程序一起工作所需的依赖项，从macOS的Homebrew（[https://brew.sh/](https://brew.sh/)）软件包管理器开始。如项目主页上所述，Homebrew可以通过以下命令轻松从终端安装：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once Homebrew is installed, it can be used to install the dependencies needed
    for React Native development: Node.js and `nodemon`. If you''re a JavaScript developer,
    you''ve likely already got Node.js installed. You can check it''s installed via
    the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Homebrew后，可以使用它来安装React Native开发所需的依赖项：Node.js和`nodemon`。如果您是JavaScript开发人员，您可能已经安装了Node.js。您可以通过以下命令检查它是否已安装：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will list the version of Node.js that''s installed, if any. Note
    that you will need Node.js version 8 or higher for React Native development. If
    Node.js is not already installed, you can install it with Hombrew via the following
    command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将列出已安装的Node.js的版本。请注意，您需要Node.js的8版本或更高版本来进行React Native开发。如果Node.js尚未安装，您可以通过以下命令使用Homebrew安装它：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need the `nodemon` package, which React Native uses behind the scenes
    to enable things like live reload during development. Install `nodemon` with Homebrew
    via the following command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`nodemon`包，React Native在幕后使用它来启用开发过程中的实时重新加载等功能。通过以下命令使用Homebrew安装`nodemon`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll also of course need the React Native CLI for running the commands that
    bootstrap the React Native app. This can be installed globally with `npm` via
    the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们还需要React Native CLI来运行引导React Native应用程序的命令。可以通过以下命令全局安装它：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the CLI installed, all it takes to create a new pure React Native app
    is the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了CLI之后，创建一个新的纯React Native应用程序只需要以下命令：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will create a new project in a new `name-of-project` directory. This project
    has all Native code exposed, and requires Xcode for running the iOS app and Android
    Studio for running the Android app. Luckily, installing Xcode for supporting iOS
    React Native development is a simple process. The first step is to download Xcode
    from the App Store and install it. The second step is to install the Xcode command-line
    tools. To do this, open Xcode, choose Preferences... from the Xcode menu, open
    the Locations panel, and install the most recent version from the Command Line
    Tools dropdown:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在一个新的`name-of-project`目录中创建一个新的项目。这个项目暴露了所有的原生代码，并且需要Xcode来运行iOS应用程序和Android
    Studio来运行Android应用程序。幸运的是，为了支持iOS React Native开发安装Xcode是一个简单的过程。第一步是从App Store下载Xcode并安装它。第二步是安装Xcode命令行工具。要做到这一点，打开Xcode，从Xcode菜单中选择“首选项”，打开位置面板，并从命令行工具下拉菜单中安装最新版本：
- en: '![](assets/d954acd0-be2c-4e74-aebc-e06fa08acb92.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d954acd0-be2c-4e74-aebc-e06fa08acb92.png)'
- en: 'Unfortunately, setting up Android Studio for supporting Android React Native
    development is not as cut and dry, and requires some very specific steps for installing
    it. Since this process is particularly involved, and since there is some likelihood
    that the process will have changed by the time you read this chapter, I recommend
    referring to the official documentation for in-depth, up-to-date instructions
    on installing all Android development dependencies. These instructions are hosted
    at the following URL:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很遗憾，为了支持Android React Native开发设置Android Studio并不是一件轻而易举的事情，需要一些非常具体的步骤来安装它。由于这个过程特别复杂，并且有可能在你阅读本章时已经发生了变化，我建议参考官方文档，获取安装所有Android开发依赖的深入和最新的说明。这些说明托管在以下URL：
- en: '[  https://facebook.github.io/react-native/docs/getting-started.html#java-development-kit](https://facebook.github.io/react-native/docs/getting-started.html#java-development-kit)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/getting-started.html#java-development-kit](https://facebook.github.io/react-native/docs/getting-started.html#java-development-kit)'
- en: 'Now that all dependencies have been installed, we''re able to run our pure
    React Native project via the command line. The iOS app can be executed via the
    following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有的依赖都已经安装好了，我们可以通过命令行运行我们的纯React Native项目。iOS应用程序可以通过以下方式执行：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And the Andriod app can be started with this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序可以通过以下方式启动：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Be sure you are already running the Android emulator before trying to open
    your Android app. These commands should start up your app on the associated emulator
    for the correct platform, install the new app, and run the app within the emulator.
    If you have any trouble with either of these commands not behaving as expected,
    you might be able to find an answer in the React Native troubleshooting docs,
    hosted here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试打开Android应用程序之前，请确保您已经运行Android模拟器。这些命令应该在关联的模拟器上启动您的应用程序，安装新应用程序，并在模拟器中运行应用程序。如果您对这些命令的任何一个行为不符合预期遇到任何问题，您可能可以在此处找到答案：React
    Native故障排除文档，托管在此处：
- en: '[https://facebook.github.io/react-native/docs/troubleshooting.html#content](https://facebook.github.io/react-native/docs/troubleshooting.html#content)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/troubleshooting.html#content](https://facebook.github.io/react-native/docs/troubleshooting.html#content)'
- en: Expo CLI setup
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Expo CLI设置
- en: 'The Expo CLI can be installed using the Terminal with `npm` via the following
    command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用终端通过以下命令使用npm安装Expo CLI：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Expo CLI can be used to do all the great things the Expo GUI client can
    do. For all the commands that can be run with the CLI, check out the docs here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Expo CLI可用于执行Expo GUI客户端可以执行的所有操作。有关可以使用CLI运行的所有命令，请查看此处的文档：
- en: '[https://docs.expo.io/versions/latest/workflow/expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.expo.io/versions/latest/workflow/expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli)'
- en: Using NativeBase for cross-platform UI components
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NativeBase进行跨平台UI组件
- en: Similar to Bootstrap on the web, NativeBase is a collection of React Native
    components for improving the efficiency of React Native app development. The components
    cover a wide range of use cases for building out UI in Native applications, including ActionSheets, Badges, Cards,
    Drawers, and grid layouts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web上的Bootstrap类似，NativeBase是一组React Native组件，用于提高React Native应用程序开发的效率。这些组件涵盖了在原生应用程序中构建UI的各种用例，包括操作表、徽章、卡片、抽屉和网格布局。
- en: 'NativeBase is a library that supports both pure React Native applications (those
    created with the React Native CLI via `react-native init`) and Expo powered applications.
    Instructions for installing NativeBase into one type of project or another is
    outlined in the *Getting Started* section of the NativeBase documentation, hosted
    here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: NativeBase是一个支持纯React Native应用程序（使用React Native CLI通过`react-native init`创建的应用程序）和Expo应用程序的库。有关将NativeBase安装到一种项目或另一种项目中的说明在NativeBase文档的“入门”部分中概述，托管在此处：
- en: '[https://github.com/GeekyAnts/NativeBase#4-getting-started](https://github.com/GeekyAnts/NativeBase#4-getting-started)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/GeekyAnts/NativeBase#4-getting-started](https://github.com/GeekyAnts/NativeBase#4-getting-started)'
- en: Since this is the case, we'll take this opportunity to outline both scenarios
    in the *Getting ready* section of this recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种情况，我们将在本教程的“准备就绪”部分中概述这两种情况。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Whichever method of bootstrapping you use for this recipe, we'll be keeping
    the *How to do it...* section of the recipe as consistent as possible. One difference
    that we'll need to take into account is the project naming convention of each
    app creation method. Pure React Native applications are named in Pascal case (MyCoolApp)
    and Expo applications are named in kebab case (my-cool-app). If you're creating
    a pure React Native app, you can use the app name `NativeBase`, and if you're
    using Expo you can name it `native-base`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种引导方法来完成此教程，我们都将尽可能保持教程的“如何做…”部分一致。我们需要考虑的一个区别是每种应用程序创建方法的项目命名约定。纯React
    Native应用程序以Pascal大小写（MyCoolApp）命名，而Expo应用程序以kebab大小写（my-cool-app）命名。如果您正在创建纯React
    Native应用程序，可以使用应用程序名称`NativeBase`，如果您正在使用Expo，可以将其命名为`native-base`。
- en: Using a pure React Native app (React Native CLI)
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯React Native应用程序（React Native CLI）
- en: 'Assuming you''ve followed the introduction to this chapter, you should already
    have the React Native CLI installed globally. If not, go ahead and do so now with
    `npm`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经按照本章的介绍安装了React Native CLI。如果没有，请立即使用`npm`安装：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create a new pure React app with the CLI, we''ll use the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CLI创建一个新的纯React应用程序，我们将使用以下命令：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This creates a new pure React Native app in a folder called `NativeBase` in
    the current directory. The next step is to install the required peer dependencies.
    Let''s `cd` into the new `NativeBase` directory and install the `native-base`
    package using `npm`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中的名为`NativeBase`的文件夹中创建一个新的纯React Native应用程序。下一步是安装所需的对等依赖项。让我们`cd`进入新的`NativeBase`目录，并使用`npm`安装`native-base`包：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, you can use `yarn`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`yarn`：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we will install the Native dependencies with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下命令安装本机依赖项：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we open up the project in an IDE and look at the folder structure of this
    pure React Native app, we''ll see a few slight differences from the Expo applications
    we''ve become accustomed to at this point. First, the repository has an `ios`
    and an `android` folder, each containing Native code for the respective platform.
    There''s also an `index.js` file at the root of the project that is not included
    in an app bootstrapped with Expo. In an app made with Expo, this file would be
    obscured away, just like the `ios` and `android` folders, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在IDE中打开项目并查看这个纯React Native应用程序的文件夹结构，我们会看到与此时习惯的Expo应用程序有一些细微的差异。首先，存储库有一个`ios`和一个`android`文件夹，分别包含各自平台的本机代码。项目的根目录还有一个`index.js`文件，这个文件在使用Expo引导的应用程序中不包括。在使用Expo制作的应用程序中，这个文件会被隐藏起来，就像`ios`和`android`文件夹一样，如下所示：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This simply serves as the bootstrapping process of your React Native app at
    runtime. `AppRegistry` is imported from the `react-native` packages, the main
    `App` component is imported from the `App.js` file at the root of the directory,
    and the `AppRegistry` method `registerComponent` is called with two parameters:
    the name of our app (`NativeBase`), and an anonymous function that returns the `App`
    component. For more information on `AppRegistry`, you can find the documentation
    here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在运行时为您的React Native应用程序提供引导过程。`AppRegistry`从`react-native`包中导入，主要的`App`组件从目录根目录的`App.js`文件中导入，并且使用两个参数调用`AppRegistry`方法`registerComponent`：我们应用的名称（`NativeBase`）和一个返回`App`组件的匿名函数。有关`AppRegistry`的更多信息，您可以在这里找到文档：
- en: '[https://facebook.github.io/react-native/docs/appregistry.html](https://facebook.github.io/react-native/docs/appregistry.html)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react-native/docs/appregistry.html](https://facebook.github.io/react-native/docs/appregistry.html)'
- en: One other minor difference is the existence of two sets of development instructions
    in the `App.js` boilerplate code, displaying the appropriate dev instructions
    through the use of the `Platform` component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个小的区别是在`App.js`样板代码中存在两套开发说明，通过使用`Platform`组件显示适当的开发说明。
- en: 'Remember to stop and think whenever you see a third-party React Native package
    whose installation instructions include running the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每当看到第三方React Native包的安装说明包括运行以下命令时，请记住停下来思考：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is usually safe to assume it is not compatible with an Expo app unless explicitly
    stated otherwise. In the case of NativeBase, we have an option to use either setup,
    so let's cover getting started with our other option next, bootstrapping with
    Expo.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以安全地假定它与Expo应用程序不兼容，除非另有明确说明。在NativeBase的情况下，我们有选择使用任一设置，因此让我们接下来介绍使用Expo进行引导的其他选项。
- en: Using an Expo app
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Expo应用
- en: 'Setting up Native Base in an app created with Expo is as simple as installing
    the required dependencies with `npm` or `yarn`. First, we can create the app using
    the Expo CLI on the command line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Expo创建的应用程序中设置Native Base就像使用`npm`或`yarn`安装所需的依赖项一样简单。首先，我们可以在命令行上使用Expo
    CLI创建应用程序：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the app is created, we can `cd` into it and install the dependencies for
    NativeBase with `npm`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序后，我们可以`cd`进入它，并使用`npm`安装NativeBase的依赖项：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can use `yarn`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`yarn`：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When using NativeBase with Expo, the NativeBase documentation recommends loading
    fonts asynchronously with the `Expo.Font.loadAsync` method in the `componentWillMount`
    method in the `App.js` component. We''ll cover how to do this in the appropriate
    step in the *How to do it...* section of this recipe. You can start up the app from
    the CLI with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Expo时，NativeBase文档建议在`App.js`组件的`componentWillMount`方法中使用`Expo.Font.loadAsync`方法异步加载字体。我们将在本示例的*如何做*部分的适当步骤中介绍如何做到这一点。您可以使用以下命令从CLI启动应用程序：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll start by adding the imports we''ll be using in the `App` component in
    `App.js`. While this app won''t have much functionality, we will be using a number
    of components from NativeBase to see how they can help improve your workflow,
    as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`App.js`中的`App`组件中添加我们将使用的导入。虽然这个应用程序不会有太多的功能，但我们将使用许多来自NativeBase的组件，以了解它们如何帮助改进您的工作流程，如下所示：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let''s declare the `App` class and define a starting `state` object.
    We''ll be adding a FAB section to show how NativeBase lets you easily add fly-out
    menu buttons to your app. We will track whether this menu should be displayed
    or not with the `fabActive` Boolean. We''ll also use the `loading` Boolean later
    in the `render` method, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们声明`App`类并定义一个起始的`state`对象。我们将添加一个FAB部分，以展示NativeBase如何让您轻松地向应用程序添加弹出菜单按钮。我们将使用`fabActive`布尔值来跟踪是否应该显示此菜单。稍后在`render`方法中，我们还将使用`loading`布尔值，如下所示：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You may recall from the *Getting ready* section of the recipe, if you''re developing
    an app with Expo, NativeBase suggests loading the fonts used by NativeBase via
    the `Expo.Font.loadAsync` function. In the `componentWillMount` method, we''ll
    initialize and await the loading of `require` fonts, then set the `loading` property
    on `state` to `false`. The `loading` property will be referenced in the `render`
    method to determine whether the app has finished loading, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还记得在本示例的*准备工作*部分中，如果您正在使用Expo开发应用程序，NativeBase建议通过`Expo.Font.loadAsync`函数加载NativeBase使用的字体。在`componentWillMount`方法中，我们将初始化并等待`require`字体的加载，然后将`state`上的`loading`属性设置为`false`。`loading`属性将在`render`方法中被引用，以确定应用程序是否已经完成加载，如下所示：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since this app is mostly UI, we're ready to start building the `render` function.
    To make sure fonts are loaded before we use them, we return the App placeholder
    Expo component, `AppLoading`, if the `loading` property of `state` is true, otherwise
    we'll render the App UI. `AppLoading` will instruct the app to continue displaying
    the app's splash screen until the component is removed.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个应用程序主要是UI，我们准备开始构建`render`函数。为了确保在使用字体之前加载它们，如果`state`的`loading`属性为true，我们将返回App占位符Expo组件`AppLoading`，否则我们将渲染App
    UI。`AppLoading`将指示应用程序继续显示应用程序的启动画面，直到组件被移除。
- en: If you chose to start this recipe with a pure React Native project, you won't
    have access to Expo components. You can simply return an empty `View` instead
    of `AppLoading` in this case.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择使用纯React Native项目开始此示例，您将无法访问Expo组件。在这种情况下，您可以简单地返回一个空的`View`而不是`AppLoading`。
- en: We'll start with the `Container` component, along with the `Header`, `Body`,
    and `Title` helper components. This will act as the container for the page, displaying
    a header at the top of the page with the title Header Title!
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从“Container”组件开始，以及“Header”、“Body”和“Title”辅助组件。这将作为页面的容器，显示页面顶部带有标题“Header
    Title”的标题！
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this point, the app should look similar to the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应用程序应该类似于以下屏幕截图：
- en: '![](assets/0de58427-fa11-43e7-8b9f-33ad9287a412.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/0de58427-fa11-43e7-8b9f-33ad9287a412.png)
- en: 'In the following code, the `Header` will have a few more UI elements from NativeBase.
    The `Spinner` component allows for easily displaying a loading spinner with the
    desired color passed in as a prop. The `Button` component provides buttons with
    more built-in customizability when compared with the vanilla `TouchableOpacity`
    component. Here, we''re using the `block` prop to spread the buttons across their
    container, and an `info` and `success` prop on each to apply their respective
    default blue and green background colors:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，“Header”将具有来自NativeBase的一些其他UI元素。 “Spinner”组件允许轻松显示带有传递的所需颜色的加载旋转器。与原始的“TouchableOpacity”组件相比，“Button”组件提供了更多的内置可定制性。在这里，我们使用“block”属性将按钮扩展到其容器，并在每个按钮上使用“info”和“success”属性来应用它们各自的默认蓝色和绿色背景颜色：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding render function also refers to a `renderFab` method we have not
    yet defined. This makes use of the `Icon` and `Fab` components. NativeBase uses
    the same `vector-icons` package as Expo under the hood (defaulting to Ionicon
    fonts if no `type` prop is provided), which was covered in the *Using Font icons*
    recipe in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*, so please refer to that recipe for more information:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的渲染函数还引用了我们尚未定义的“renderFab”方法。这利用了“Icon”和“Fab”组件。 NativeBase在内部使用与Expo相同的“vector-icons”包（如果未提供“type”属性，则默认为Ionicon字体），这在[第3章](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml)的“使用字体图标”配方中有介绍，请参考该配方获取更多信息：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s round this recipe out with a few styles to align things within the `View`
    and apply colors to our layout, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一些样式来完善这个配方，以便在“View”中对齐事物并将颜色应用到我们的布局中，如下所示：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Looking back at the completed app, there''s now a nice spread of UI that is
    cross-platform and easy to use:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾已完成的应用程序，现在有一个漂亮的跨平台UI分布，易于使用：
- en: '![](assets/d5fc973a-9043-4415-a3f9-3c9ad419b6ac.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/d5fc973a-9043-4415-a3f9-3c9ad419b6ac.png)
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: While the more complicated portion of this recipe was the set-up of the app
    itself, we had a quick review of a few of the components provided by NativeBase
    that might be able to help you develop your next app more efficiently. If you
    prefer to work in a widget-based system similar to what Bootstrap ([https://getbootstrap.com/](https://getbootstrap.com/))
    or Semantic-UI ([https://semantic-ui.com/](https://semantic-ui.com/)) provide
    on the web platform, be sure to give NativeBase a spin. For more information on
    all of the components that NativeBase offers and how to use them, you can find
    the official documentation at [http://docs.nativebase.io/Components.html](http://docs.nativebase.io/Components.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个配方更复杂的部分是设置应用程序本身，但我们快速回顾了NativeBase提供的一些组件，这些组件可能有助于您更有效地开发下一个应用程序。如果您喜欢在类似于Bootstrap（[https://getbootstrap.com/](https://getbootstrap.com/)）或Semantic-UI（[https://semantic-ui.com/](https://semantic-ui.com/)）在Web平台上提供的基于小部件的系统中工作，请务必尝试NativeBase。有关NativeBase提供的所有组件及其使用方法的更多信息，您可以在[http://docs.nativebase.io/Components.html](http://docs.nativebase.io/Components.html)找到官方文档。
- en: Using glamorous-native for styling UI components
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用glamorous-native来为UI组件设置样式
- en: 'As a JavaScript developer, you''re likely familiar with CSS on the web and
    how it''s used to style web pages and web applications. More recently, a technique
    called CSS-in-JS has came along in web development, which uses the power of JavaScript
    to adapt CSS for a more modular, component-based styling approach. One of the
    main benefits of CSS-in-JS tools is their ability to produce styles that are scoped
    to a given element, instead of the default cascading behavior of vanilla JavaScript.
    Scoped CSS allows a developer to apply styles in a more predictable and modular
    way. This in turn increases usability in larger organizations and makes packaging
    and publishing styled components easier. If you''d like to learn more about how
    CSS-in-JS works or where CSS-in-JS comes from conceptually, I''ve written an article
    on the topic on the gitconnected Medium blog called *A Brief History of CSS-in-JS:
    How We Got Here and Where We''re Going*, hosted at:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JavaScript开发人员，您可能熟悉Web上的CSS以及它如何用于样式化网页和Web应用程序。最近，一种称为CSS-in-JS的技术出现在Web开发中，它利用JavaScript的力量来调整CSS，以实现更模块化、基于组件的样式化方法。CSS-in-JS工具的主要好处之一是它们能够生成针对给定元素范围的样式，而不是默认的JavaScript级联行为。范围CSS允许开发人员以更可预测和模块化的方式应用样式。这反过来增加了在较大组织中的可用性，并使打包和发布样式化组件变得更容易。如果您想了解CSS-in-JS的工作原理或CSS-in-JS的概念来源，我在gitconnected
    Medium博客上写了一篇名为《CSS-in-JS简史：我们是如何到达这里以及我们将去哪里》的文章，托管在：
- en: '[https://levelup.gitconnected.com/a-brief-history-of-css-in-js-how-we-got-here-and-where-were-going-ea6261c19f04](https://levelup.gitconnected.com/a-brief-history-of-css-in-js-how-we-got-here-and-where-were-going-ea6261c19f04).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://levelup.gitconnected.com/a-brief-history-of-css-in-js-how-we-got-here-and-where-were-going-ea6261c19f04](https://levelup.gitconnected.com/a-brief-history-of-css-in-js-how-we-got-here-and-where-were-going-ea6261c19f04)。'
- en: The `StyleSheet` component that comes packaged with React Native is an implementation
    of CSS-in-JS. One of the most popular implementations of CSS-in-JS on the web
    is `glamorous`, a library created by the venerable Kent C. Dodds. This library
    inspired the excellent React Native styling library `glamorous-native`, which
    we will be using in this recipe.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: React Native捆绑的`StyleSheet`组件是CSS-in-JS的实现。在Web上最受欢迎的CSS-in-JS实现之一是`glamorous`，这是由备受尊敬的Kent
    C. Dodds创建的库。这个库启发了出色的React Native样式库`glamorous-native`，我们将在这个示例中使用它。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll need to create a new app for this recipe. This package does not require
    running the following command during setup:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个示例创建一个新的应用程序。在设置期间，此软件包不需要运行以下命令：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, should work just fine with an Expo app. Let's name the recipe `glamorous-app`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应该可以在Expo应用程序中正常工作。让我们将示例命名为`glamorous-app`。
- en: 'We will also need to install the glamorous-app package. This can be installed
    with `npm`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装glamorous-app包。这可以通过`npm`安装：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or, we can use `yarn`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`yarn`：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by importing all the dependencies we''ll need in `App.js`, as
    follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`App.js`中导入我们需要的所有依赖项，如下所示：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our app will need a containing `View` element to hold all of the other components
    displayed in the app. Instead of styling this element with an object passed to
    the `StyleSheet` component, like we''ve been doing in all previous recipes, we''ll
    use `glamorous` by passing a style object to the `view` method, which returns
    a styled  `View` component that we store in a `const` called `Container` for later
    use,  as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序将需要一个包含`View`元素，以容纳应用程序中显示的所有其他组件。我们将使用`glamorous`来为此元素传递样式对象，而不是像我们在所有先前的示例中所做的那样，通过传递给`StyleSheet`组件的对象来对此元素进行样式化。我们将使用`view`方法，它返回一个样式化的`View`组件，我们将其存储在一个名为`Container`的`const`中，以便以后使用，如下所示：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, we''ll add three styled `Text` components using `glamorous.text`.
    By doing this, we have three more styled and explicitly named components ready
    to be used in `render`, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们将使用`glamorous.text`添加三个样式化的`Text`组件。通过这样做，我们有了另外三个样式化和明确定义名称的组件，可以在`render`中使用，如下所示：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll also make a reusable `Button` component with the `glamorous.touchableHighlight`
    method. This method shows how `glamorous` components can also be created with
    multiple style declarations of different types. The second parameter passed to `touchableHighlight`
    in this case is a function that updates the `backgroundColor` style depending
    on the `props` defined on the element, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将使用`glamorous.touchableHighlight`方法制作一个可重用的`Button`组件。这种方法展示了`glamorous`组件也可以用不同类型的多个样式声明来创建。在这种情况下，传递给`touchableHighlight`的第二个参数是一个函数，根据元素上定义的`props`来更新`backgroundColor`样式，如下所示：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also create components styled inline, thanks to the special versions
    of React Native components `glamorous` ships with. We will use an `Image` component,
    but instead of importing it from `react-native`, we use the `Image` component
    from the imported `glamorous` package, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以创建内联样式的组件，这要归功于`glamorous`提供的特殊版本的React Native组件。我们将使用一个`Image`组件，但是不是从`react-native`中导入，而是从导入的`glamorous`包中使用`Image`组件，如下所示：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we are ready to declare the `App` component. `App` will only need a `render`
    function for rendering all our newly styled components, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备声明`App`组件。`App`只需要一个`render`函数来渲染我们所有新样式化的组件，如下所示：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s begin building out the render function by adding the `Container` component
    we created in *step 2*. The improvement in code readability is already apparent.
    The `Container` is explicitly named and needs no other attributes or properties
    to declare styles, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始构建`render`函数，通过添加在*步骤2*中创建的`Container`组件。代码可读性的改进已经显而易见。`Container`被明确定义，并且不需要其他属性或属性来声明样式，如下所示：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s add the `Image` component that we pulled from the imported `glamorous`
    library in *step 5*. Notice how we are able to declare style properties such as `height`, `width`,
    and `borderRadius` as props directly on the component, unlike the vanilla `Image`
    component:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加从导入的`glamorous`库中提取的`Image`组件，这是在*步骤5*中完成的。请注意，我们能够直接在组件上声明样式属性，如`height`、`width`和`borderRadius`，而不是像普通的`Image`组件那样：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we''ll add the `Headline` and `Subheading` components we created in *step
    3*. Just like the `Container` component, these two components read much more clearly
    than one `View` and two `Text` elements ever could:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加在*步骤3*中创建的`Headline`和`Subheading`组件。就像`Container`组件一样，这两个组件的可读性要比一个`View`和两个`Text`元素好得多：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we''ll add the `Button` component we created in *step 4*, and the
    `ButtonText` component we created in *step 3*. Both buttons have an `onPress`
    method like any `TouchableOpacity` or `TouchableHighlight` component would, but
    the second `Button` also has a `warning` prop, causing it to have a red background
    instead of blue:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加在*步骤4*中创建的`Button`组件，以及在*步骤3*中创建的`ButtonText`组件。两个按钮都有一个`onPress`方法，就像任何`TouchableOpacity`或`TouchableHighlight`组件一样，但第二个`Button`还有一个`warning`属性，导致它具有红色背景而不是蓝色：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All of our `glamorous` components have been added to the `render` method. If
    you run the app, you should be greeted by a fully styled UI.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有我们的`glamorous`组件都已添加到`render`方法中。如果你运行这个应用程序，你应该会看到一个完全样式化的用户界面。
- en: '![](assets/acf7555d-906d-4fc6-be06-c266bedcdddb.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/acf7555d-906d-4fc6-be06-c266bedcdddb.png)'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2* and *step 3*, we created styled `View` and `Text` components by
    using the corresponding `glamorous` method and passing in an object containing
    all the styles that should be applied to that particular component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*和*步骤3*中，我们使用相应的`glamorous`方法创建了带有样式的`View`和`Text`组件，并传入了一个包含应该应用于该特定组件的所有样式的对象。
- en: In *step 4*, we created a reusable `Button` styled component by applying the
    same method used for creating the `View` and `Text` components in previous steps.
    The way styles are declared in this component is different, however, and shows
    off the versatility `glamorous-native` has when processing styles. You can pass
    any number of style collections as parameters to a `glamorous` component constructor
    and they will all be applied. This includes dynamic styles, which usually take
    the form of using props defined on the component to apply different styles. In
    *step 10*, we used our `Button` element. If the prop `warning` is present, as
    it is on the first `Button` in `render`, the `backgroundColor` will be `red`.
    Otherwise, it will be `blue`. This provides a very nice system for applying simple
    and reusable theming across multiple types of components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们通过应用与前几步创建`View`和`Text`组件相同的方法，创建了一个可重用的`Button`样式组件。然而，这个组件中声明样式的方式是不同的，并展示了`glamorous-native`在处理样式时的多功能性。您可以将任意数量的样式集合作为参数传递给`glamorous`组件构造函数，它们都将被应用。这包括动态样式，通常采用在组件上定义的props来应用不同的样式。在*步骤10*中，我们使用了我们的`Button`元素。如果存在`warning`属性，就像在`render`中的第一个`Button`上一样，`backgroundColor`将是`red`。否则，它将是`blue`。这为在多种类型的组件上应用简单和可重用的主题提供了一个非常好的系统。
- en: In *step 5*, we pulled the `Image` component from the `glamorous` library to
    use in place of the React Native `Image` component. This special version of the
    component behaves the same as its React Native counterpart, along with the benefit
    of being able to apply styles directly to the element itself. In *step 8*, where
    we used that component, we were able to apply `height`, `width`, and `borderRadius`
    styles without ever having to use the `style` prop.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们从`glamorous`库中提取了`Image`组件，以替代React Native的`Image`组件。这个特殊版本的组件与其React
    Native对应组件的行为相同，同时还能够直接对元素本身应用样式。在*步骤8*中，我们使用了该组件，我们能够应用`height`、`width`和`borderRadius`样式，而无需使用`style`属性。
- en: Using react-native-spinkit for adding animated loading indicators
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-native-spinkit添加动画加载指示器
- en: No matter what kind of app you are building, there's a very good chance your
    app will need to wait on data of one kind or another, whether it be loading assets
    or waiting on a response from an AJAX request. When this situation arises, you'll
    probably also want a way for your app to indicate to the user that some required
    piece of data is still loading. One easy-to-use solution to this problem is using
    `react-native-spinkit`. This package provides 15 (four of which are iOS-only)
    professional looking, easy-to-use loading indicators for displaying while data
    is loading in your app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您正在构建什么样的应用程序，您的应用程序很有可能需要等待某种数据，无论是加载资产还是等待来自AJAX请求的响应。当出现这种情况时，您可能还希望您的应用程序能够向用户指示某个必需的数据仍在加载中。解决这个问题的一个易于使用的解决方案是使用`react-native-spinkit`。这个包提供了15个（其中四个仅适用于iOS）专业外观、易于使用的加载指示器，用于在您的应用程序中显示数据加载时。
- en: 'This package requires the following command to be run:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包需要运行以下命令：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, it is probably safe to assume that it will not work with an Expo app (unless
    that app is subsequently ejected). This will provide us with another recipe that
    depends on a pure React Native workflow.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以安全地假设它不会与Expo应用程序一起工作（除非随后将该应用程序弹出）。这将为我们提供另一个依赖于纯React Native工作流程的配方。
- en: Getting started
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Now that we''ve established that this recipe will be built in pure React Native,
    we can begin by initializing a new app from the command line named `SpinKitApp` as
    follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了这个配方将在纯React Native中构建，我们可以通过以下方式从命令行初始化一个名为`SpinKitApp`的新应用程序：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This command will begin the scaffolding process. Once it has completed, `cd`
    into the new `SpinKitApp` directory and add `react-native spinkit` with `npm`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将开始搭建过程。完成后，`cd`进入新的`SpinKitApp`目录，并使用`npm`添加`react-native spinkit`：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Or use `yarn`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`yarn`：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With the library installed, we must link it before it can be used with the
    command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了库之后，我们必须使用以下命令将其链接起来才能使用：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, the app is bootstrapped and the dependencies have been installed.
    The app can then be run in the iOS or Android simulators via this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应用程序已经启动，并且已安装了依赖项。然后可以通过以下方式在iOS或Android模拟器中运行应用程序：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, use this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用这个：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When launching a pure React Native project in the iOS simulator, if you wish
    to specify a device, you can pass the `simulator` argument set to a string value
    for the desired device. For example, `react-native run-ios --simulator="iPhone
    X"` will launch the app in a simulated iPhone X.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS模拟器中启动纯React Native项目时，如果希望指定设备，可以传递`simulator`参数设置为所需设备的字符串值。例如，`react-native
    run-ios --simulator="iPhone X"`将在模拟的iPhone X中启动应用程序。
- en: When launching a pure React Native project in an Android emulator via the command
    line, you must open the Android emulator you intend to use before running this
    command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过命令行启动纯React Native项目的Android模拟器时，必须在运行此命令之前打开您打算使用的Android模拟器。
- en: 'We''ll also be making use of the `randomcolor` library again in this recipe.
    Install it with `npm`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们还将再次使用`randomcolor`库。使用`npm`安装它：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Or use `yarn`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`yarn`：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll start by adding the dependencies to the `App.js` file in the root of
    the project, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在项目的根目录的`App.js`文件中添加依赖项，如下所示：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''re going to be setting up the app in this recipe to cycle through all of
    the loading spinner types provided by `react-native-spinkit`. To do this, let''s
    create an array with strings for each possible type of spinner. Since the last
    four types are not fully supported in Android, they will all appear as the same
    `Plane` spinner on Android, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将设置应用程序循环显示`react-native-spinkit`提供的所有加载旋转器类型。为此，让我们创建一个包含每种可能的旋转器类型的字符串数组。由于最后四种类型在Android中不完全受支持，它们在Android上都将显示为相同的`Plane`旋转器，如下所示：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we can begin building the `App` component. We will need a `state` object
    with four properties: an `isVisible` property to track whether the spinner should
    be displayed, a `type` property for holding the current spinner type, a `typeIndex`
    for keeping our place in the `types` array, and a color. We''ll initialize color
    to a random hex code by simply calling `randomColor()`, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建`App`组件。我们将需要一个具有四个属性的`state`对象：一个`isVisible`属性来跟踪是否应该显示旋转器，一个用于保存当前旋转器类型的`type`属性，一个用于保持在`types`数组中的位置的`typeIndex`，以及一个颜色。我们将通过简单调用`randomColor()`来将颜色初始化为随机十六进制代码，如下所示：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We''ll need a function for changing the properties of the `Spinner` component,
    which we will define later in the `render` method. This function simply increases
    the `typeIndex` by one, or sets it back to `0` if the end of the array has been
    reached, then updates `state` accordingly, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要一个函数来改变`Spinner`组件的属性，我们将在`render`方法中稍后定义。这个函数简单地将`typeIndex`增加一，或者如果已经到达数组的末尾，则将其设置回`0`，然后相应地更新`state`，如下所示：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `render` method will be made up of the `Spinner` component, wrapped in
    a `TouchableOpacity` component for changing the type and color of `Spinner`. We
    will also add a `Text` component for displaying the current `Spinner` type, as
    follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法将由`Spinner`组件组成，包裹在`TouchableOpacity`组件中，用于改变`Spinner`的类型和颜色。我们还将添加一个`Text`组件来显示当前`Spinner`的类型，如下所示：'
- en: '[PRE63]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, let''s add a few styles to the center content and increase the font
    size of the `Text` element via the `text` class, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们为中心内容添加一些样式，并通过`text`类增加`Text`元素的字体大小，如下所示：
- en: '[PRE64]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With the recipe complete, we should see a loader that changes on press. Thanks
    to `react-native-spinkit`, this is all it takes to add slick loading indicators
    to our React Native applications!
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个示例后，我们应该看到一个在按下时改变的加载器。感谢`react-native-spinkit`，这就是向我们的React Native应用程序添加时髦的加载指示器所需的一切！
- en: '![](assets/f21b3fc5-4779-4778-923e-f4d33138cfe2.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f21b3fc5-4779-4778-923e-f4d33138cfe2.png)'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *step 5*, we defined the app''s `render` method, where we made use of the `Spinner`
    component. The `Spinner` component has four optional props:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了应用程序的`render`方法，其中我们使用了`Spinner`组件。`Spinner`组件有四个可选的属性：
- en: '`isVisible`: A Boolean that determines whether the component should be displayed.
    Default: `true`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isVisible`：一个布尔值，用于确定是否应该显示组件。默认值：`true`'
- en: '`color`: A hex code to determine the spinner''s color. Default: `#000000`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：一个十六进制代码，用于确定旋转器的颜色。默认值：`#000000`'
- en: '`size`: Determines what size the spinner should be, in pixels. Default: `37`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：以像素为单位确定旋转器的大小。默认值：`37`'
- en: '`type`: A string that determines the type of spinner to use. Default: `Plane`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：一个字符串，确定要使用的旋转器类型。默认值：`Plane`'
- en: Since the `isVisible` prop on the `Spinner` component is set to the value of `isVisible`
    on the `state` object, we can simply toggle this property to `true` whenever a
    long running process begins (such as waiting on the response from an AJAX request),
    and set it back to `false` when the operation completes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Spinner`组件上的`isVisible`属性设置为`state`对象上的`isVisible`的值，所以我们可以简单地在长时间运行的过程开始时（例如等待来自AJAX请求的响应），将此属性切换为`true`，并在操作完成时将其设置回`false`。
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Even though the app we've created in this recipe is fairly simple, it has illustrated
    both how `react-native-spinkit` can be implemented, and how using third-party
    packages that require the `react-native link` command works in practice. There
    are all kinds of third-party packages available to use in your next React Native
    app, thanks to the hard work of countless open source contributors. Being equipped
    to utilize any third-party package that suits your app's needs, no matter what
    requirements those package have, will be a vital tool in planning and developing
    React Native projects.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这个示例中创建的应用程序相当简单，但它展示了`react-native-spinkit`如何实现，以及如何实际使用需要`react-native
    link`命令的第三方包。由于无数的开源贡献者的辛勤工作，有各种各样的第三方包可供在下一个React Native应用程序中使用。能够利用任何符合应用程序需求的第三方包，无论这些包有什么要求，都将是规划和开发React
    Native项目的重要工具。
- en: Using react-native-side-menu for adding side navigation menus
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-native-side-menu添加侧边导航菜单
- en: Side menus are a common UX pattern for displaying options, controls, app settings,
    navigation, and other secondary information in mobile applications. The `react-native-side-menu`
    third-party package provides an excellent, straightforward way to implement side
    menus in a React Native app. In this recipe, we will be building an app that has
    a side menu housing buttons that change the background.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边菜单是一种常见的UX模式，用于在移动应用程序中显示选项、控件、应用程序设置、导航和其他次要信息。第三方包`react-native-side-menu`提供了一种在React
    Native应用程序中实现侧边菜单的出色且简单的方法。在这个示例中，我们将构建一个具有侧边菜单的应用程序，其中包含可以改变背景的按钮。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Setting up the `react-native-side-menu` package does not require the command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`react-native-side-menu`包不需要命令：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So feel free to create this app with Expo or as a pure React Native app. We
    need to create a new app for this recipe, and for project naming purposes we'll
    assume this app is being built with Expo and name it `side-menu-app`. If you're
    using pure React Native, you can name it `SideMenuApp`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请随意使用Expo或纯React Native应用程序创建此应用。我们需要为这个示例创建一个新的应用程序，并且出于项目命名的目的，我们将假设这个应用程序是使用Expo构建的，并将其命名为`side-menu-app`。如果您使用纯React
    Native，可以将其命名为`SideMenuApp`。
- en: 'We will also need to install `react-native-side-menu` into our project with `npm`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用`npm`将`react-native-side-menu`安装到我们的项目中。
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Or, use `yarn`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`yarn`：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start this recipe by adding all the imports we''ll need in the `App.js`
    file in the root of the project. One of these imports is a `Menu` component, which
    we''ll create in a later step:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在项目根目录的`App.js`文件中添加我们需要的所有导入开始这个示例。其中一个导入是`Menu`组件，我们将在后面的步骤中创建它：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, let''s define the `App` class and the initial `state`. `state` only needs
    two properties in this app: an `isOpen` Boolean to keep track of when the side
    menu should be open, and a `selectedBackgroundColor` property whose value is a
    string representing the currently selected background color, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义`App`类和初始的`state`。在这个应用程序中，`state`只需要两个属性：一个`isOpen`布尔值，用于跟踪侧边菜单何时应该打开，以及一个`selectedBackgroundColor`属性，其值是表示当前选定的背景颜色的字符串，如下所示：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Our app will need a method for changing the `selectedBackgroundColor` property
    on `state`. This method takes a `color` string as a parameter, and sets that color
    to `selectedBackgroundColor`. It will also set `state.isOpen` to `false` so that
    the side menu closes when a color is selected from the menu, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序将需要一个方法来改变`state`上的`selectedBackgroundColor`属性。这个方法以一个`color`字符串作为参数，并将该颜色设置为`selectedBackgroundColor`。它还会将`state.isOpen`设置为`false`，以便在从菜单中选择颜色时关闭侧边菜单，如下所示：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''re ready to define the `render` method `App`. First, let''s set up the `Menu`
    component so it can be used by `SideMenu` in the next step. We still haven''t
    created the  `Menu` component, but we''ll be using an `onColorSelected` property
    to pass along the `changeBackgroundColor` method, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好定义`App`的`render`方法。首先，让我们设置`Menu`组件，以便在下一步中可以被`SideMenu`使用。我们还没有创建`Menu`组件，但我们将使用`onColorSelected`属性来传递`changeBackgroundColor`方法，如下所示：
- en: '[PRE71]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The rendered UI consists of four pieces. The first is a `View` component, which
    has a `style` property tied to `state.selectedBackgroundColor`. This `View` component holds a
    single `TouchableOpacity` button component, which opens the side menu whenever
    it''s pressed. The `SideMenu` component has a required `menu` prop, which takes
    the component that will act as the side menu itself, and so we''ll pass the `Menu`
    component to this property, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染的UI由四个部分组成。第一个是一个`View`组件，它有一个与`state.selectedBackgroundColor`绑定的`style`属性。这个`View`组件包含一个单独的`TouchableOpacity`按钮组件，每当按下它时就会打开侧边菜单。`SideMenu`组件有一个必需的`menu`属性，它接受将充当侧边菜单本身的组件，因此我们将`Menu`组件传递给这个属性，如下所示：
- en: '[PRE72]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As the final touch for this component, let''s add basic styles to center the
    layout, and apply colors and font sizes, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为这个组件的最后一步，让我们添加基本样式来居中布局，并应用颜色和字体大小，如下所示：
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'It''s time to create the `Menu` component. Let''s create a `component` folder
    with a `Menu.js` file inside. We''ll start with the component imports. As we''ve
    done in previous recipes, we''ll also use `Dimensions` to store the dimensions
    of the app window in a variable for applying styles, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建`Menu`组件了。让我们在`component`文件夹中创建一个`Menu.js`文件。我们将从组件导入开始。就像我们在之前的示例中所做的那样，我们还将使用`Dimensions`将应用程序窗口的尺寸存储在一个变量中，以便应用样式，如下所示：
- en: '[PRE74]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `Menu` component needs only to be a presentational component, since it
    has no state or need for life cycle hooks. The component will receive `onColorSelected` as
    a property, which we''ll make use of in the next step, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Menu`组件只需要是一个展示性组件，因为它没有状态或生命周期钩子的需求。该组件将接收`onColorSelected`作为属性，我们将在下一步中使用它，如下所示：'
- en: '[PRE75]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The body of the `Menu` component is simply a list of `TouchableOpacity` buttons
    that, when pressed, call `onColorSelected`, passing in the corresponding color,
    as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Menu`组件的主体只是一系列`TouchableOpacity`按钮，当按下时，会调用`onColorSelected`，传入相应的颜色，如下所示：'
- en: '[PRE76]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s add a few styles to layout the `Menu` component, apply colors, and apply
    font sizes. Note that we''re also using the `window` variable we defined in *step
    7* to set the `height` and `width` of the component equal to that of the screen, as
    follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`Menu`组件添加一些样式，应用颜色和字体大小。请注意，我们还在*步骤7*中定义的`window`变量来设置组件的`height`和`width`，使其等于屏幕的大小，如下所示：
- en: '[PRE77]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Our app is complete! When the Open Menu button is pressed, a smoothly animated
    side menu will slide out from the left, displaying a list of colors for the user
    to choose from. When a color is selected from the list, the background color of
    the app changes and the menu slides back to closed:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序已经完成！当按下“打开菜单”按钮时，一个平滑动画的侧边菜单将从左侧滑出，显示一个供用户选择的颜色列表。当从列表中选择颜色时，应用程序的背景颜色会更改，并且菜单会滑动回关闭状态：
- en: '![](assets/73ecede4-e54a-465c-af8c-e4e19f2dbe0e.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/73ecede4-e54a-465c-af8c-e4e19f2dbe0e.png)'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 4*, we created the `render` function for the main `App` component.
    We stored the `Menu` component in a `menu` variable so that it can be legibly
    passed to the `menu` property of `SideMenu`, as we did in *step 5*. We pass the `changeBackgroundColor`
    class method via the `onColorSelected` prop on our `Menu` component so that we
    can use it to properly update `state` in the `App` component.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们为主`App`组件创建了`render`函数。我们将`Menu`组件存储在`menu`变量中，以便可以清晰地将其传递给`SideMenu`的`menu`属性，就像我们在*步骤5*中所做的那样。我们通过`onColorSelected`属性将`changeBackgroundColor`类方法传递给我们的`Menu`组件，以便我们可以使用它来正确更新`App`组件中的`state`。
- en: We then pass the `Menu` component to `SideMenu` as the `menu` prop, which wires
    the two components together. The second props is `isOpen`, which dictates whether
    the side menu should be open. The third prop, `onChange`, takes a callback function
    that's executed every time the menu is opened or closed. The `onChange` callback
    is provided an `isOpen` parameter that we used to update the value of `isOpen`
    on `state` so that it stays in sync.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`Menu`组件作为`menu`属性传递给`SideMenu`，将这两个组件连接在一起。第二个属性是`isOpen`，它决定侧边菜单是否应该打开。第三个属性`onChange`接受一个回调函数，每次菜单打开或关闭时都会执行。`onChange`回调提供了一个`isOpen`参数，我们用它来更新`state`中`isOpen`的值，以便保持同步。
- en: The containing `View` element has a `style` prop set to an array with both the `container`
    styles defined in *step 6* and an object with the `backgroundColor`  key set to `selectedBackgroundColor`
    on `state`. This will cause the background color of the `View` component to change
    to this value whenever it updates.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的`View`元素具有一个`style`属性，设置为一个数组，其中包含*步骤6*中定义的`container`样式和一个具有`backgroundColor`键设置为`state`中的`selectedBackgroundColor`的对象。这将导致`View`组件的背景颜色在更新时更改为此值。
- en: In *step 8* and *step 9*, we built out the `render` method of the `Menu` component.
    Each `TouchableOpacity` button is wired to call `onColorSelected`, passing in
    the color associated with the pressed button. This in turn runs `changeBackgroundColor`
    in the parent `App` class, which updates `state.selectedBackgroundColor` on setting `state.isOpen`
    to `false`, causing the background color to change and the side menu to close.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8*和*步骤9*中，我们构建了`Menu`组件的`render`方法。每个`TouchableOpacity`按钮都连接到`onColorSelected`，传入与按下按钮相关联的颜色。这反过来在父`App`类中运行`changeBackgroundColor`，在设置`state.isOpen`为`false`时更新`state.selectedBackgroundColor`，导致背景颜色改变并关闭侧边菜单。
- en: Using react-native-modalbox for adding modals
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-native-modalbox添加模态框
- en: Another common piece of many mobile UIs is the modal. Modals are the perfect
    solution for isolating data in a meaningful way, alerting a user of updated info,
    displaying a required action that blocks other user interactions (like a login
    screen), and so much more.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 许多移动UI的常见部分是模态框。模态框是隔离数据的理想解决方案，以有意义的方式提醒用户更新的信息，显示阻止其他用户交互的必需操作（如登录屏幕）等等。
- en: 'We will be making use of the third-party package `react-native-modalbox`. This
    package provides an easy-to-understand and versatile API for creating modals,
    with options including the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第三方包`react-native-modalbox`。该软件包提供了一个易于理解和多功能的API，用于创建模态框，选项包括以下内容：
- en: '`position`: Top, bottom, center'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`：顶部、底部、中心'
- en: '`entry`: Direction modal enters from—top or bottom?'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`：模态框进入的方向-顶部或底部？'
- en: '`backdropColor`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backdropColor`'
- en: '`backdropOpacity`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backdropOpacity`'
- en: 'For all of the available options, refer to the documentation at:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可用选项，请参阅文档：
- en: '[https://github.com/maxs15/react-native-modalbox](https://github.com/maxs15/react-native-modalbox)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/maxs15/react-native-modalbox](https://github.com/maxs15/react-native-modalbox)'
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will need a new app for this recipe. The `react-native-modalbox` package
    is Expo friendly, so we can create this app with Expo. We'll name this app `modal-app`.
    If using a pure React Native project, a name such as `ModalApp` will work, to
    match naming conventions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个新的应用程序来完成这个示例。`react-native-modalbox`软件包对Expo友好，因此我们可以使用Expo创建此应用程序。我们将为这个应用程序命名为`modal-app`。如果使用纯React
    Native项目，可以使用`ModalApp`这样的名称，以匹配命名约定。
- en: 'We will also need the third-party package. It can be installed with `npm`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要第三方软件包。可以使用`npm`进行安装：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Or, use `yarn`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`yarn`：
- en: '[PRE79]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it...
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening the `App.js` file in the root of the project and add
    the imports, as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在项目的根目录中打开`App.js`文件并添加导入开始，如下所示：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, we will define and export the `App` component, as well as the initial
    `state` object, as follows. For this app, we''ll only need an `isOpen` Boolean
    for keeping track of whether one of our modals should be opened or closed:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义和导出`App`组件，以及初始的`state`对象，如下所示。对于这个应用程序，我们只需要一个`isOpen`布尔值来跟踪我们的模态框是否应该打开或关闭：
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s skip ahead to building out the `render` method next. The template is
    made up of two `TouchableOpacity` button components that when pressed, open their
    respective modal. We''ll be defining those two modals in the following steps.
    These buttons will call two methods for rendering each `Modal`  of the two modal
    components, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们跳到下一个构建`render`方法。该模板由两个`TouchableOpacity`按钮组件组成，当按下时，打开它们各自的模态框。我们将在接下来的步骤中定义这两个模态框。这些按钮将调用两种方法来渲染每个模态框的两个模态框组件，如下所示：
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we''re ready to define the `renderModal1` method. The `Modal` component
    needs a `ref` prop to be assigned a string, which will be used to refer to the
    `Modal` when we want to open or close it, as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备定义`renderModal1`方法。`Modal`组件需要一个`ref`属性来分配一个字符串，这将用于在我们想要打开或关闭它时引用`Modal`，如下所示：
- en: '[PRE83]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s add the `openModal1` method next. This is the method that is called
    by `onPress` on the first `TouchableOpacity` component we added in the `render`
    method in *step 3*. By passing the `modal1` string to the `ref` prop on the `Modal`
    component we defined in *step 4*, we''re able to access the modal as `this.refs.modal1`.
    Calling the `open` method on this ref opens the modal. More on this in the *How
    it works... *section at the end of this recipe. Add the `openModal1` method as
    follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们接下来添加`openModal1`方法。这个方法是在*步骤3*中我们在`render`方法中添加的第一个`TouchableOpacity`组件上通过`onPress`调用的。通过将`modal1`字符串传递给我们在*步骤4*中定义的`Modal`组件上的`ref`属性，我们能够将模态框访问为`this.refs.modal1`。在这个引用上调用`open`方法将打开模态框。关于这一点，我们将在本教程末尾的*它是如何工作的...*部分详细介绍。添加`openModal1`方法如下：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `Modal` we defined in *step 4* also has `onClosed` and `onOpened` props,
    which each take a callback that''s executed when the modal is closed or opened,
    respectively. Let''s define the callbacks for these props next. In this recipe,
    we''ll just be firing a `console.log` as a proof of concept, as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在*步骤4*中定义的`Modal`还有`onClosed`和`onOpened`属性，它们分别接受一个在模态框关闭或打开时执行的回调函数。让我们接下来为这些属性定义回调函数。在本教程中，我们将只是简单地使用`console.log`作为概念验证，如下所示：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We''re ready to define the second modal. This `Modal` component''s `ref` prop
    will be set to the string `modal2`, and we''ll add two other optional props we
    didn''t use on the other modal. The first is `position`, which can be set to `top`, `bottom`,
    or `center` (default). The `isOpen` prop provides a secondary way of opening and
    closing a modal via a Boolean. The content of the modal has a `TouchableOpacity`
    with an OK button that, when pressed, will set the `isOpen` Boolean on the `state`
    object to `false`, closing the modal, as follows:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好定义第二个模态框了。这个`Modal`组件的`ref`属性将设置为字符串`modal2`，我们将添加两个其他可选的属性，这些属性在另一个模态框上没有使用。第一个是`position`，可以设置为`top`、`bottom`或`center`（默认）。`isOpen`属性提供了通过布尔值打开和关闭模态框的第二种方法。模态框的内容有一个带有OK按钮的`TouchableOpacity`，当按下时，将会将`state`对象上的`isOpen`布尔值设置为`false`，关闭模态框，如下所示：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Since we''re using the `state` Boolean `isOpen` to manipulate the state of
    the modal, the `openModal2` method will illustrate an alternative method for opening
    and closing the modal. By setting `isOpen` on `state` to `true`, the second modal
    will open, as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用`state`布尔值`isOpen`来操纵模态框的状态，`openModal2`方法将演示另一种打开和关闭模态框的方法。通过将`state`上的`isOpen`设置为`true`，第二个模态框将打开，如下所示：
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You might have also noticed that the second modal, defined in *step 7*, has
    a different `onClosed` callback. If the user presses the OK button, the `isOpen`
    value on `state` will be successfully updated to `false`, but if they dismiss
    the modal by touching the backdrop, it will not. Adding the `onCloseModal2` method
    guarantees that the `isOpen` value of the `state` is properly kept in sync no
    matter how the user dismisses the modal, as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还注意到，在*步骤7*中定义的第二个模态框有一个不同的`onClosed`回调。如果用户按下OK按钮，`state`上的`isOpen`值将成功更新为`false`，但如果他们通过触摸背景来关闭模态框，它将不会。添加`onCloseModal2`方法可以确保`state`的`isOpen`值无论用户如何关闭模态框都能正确保持同步，如下所示：
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The last step in this recipe is applying styles. We''ll have a `modal` class
    for shared modal styles, `modal1` and `modal2` classes for styles unique to each
    modal, and classes for applying colors, padding, and margin to buttons and text,
    as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个教程的最后一步是应用样式。我们将有一个用于共享模态框样式的`modal`类，用于每个模态框独特样式的`modal1`和`modal2`类，以及用于将颜色、填充和边距应用于按钮和文本的类，如下所示：
- en: '[PRE89]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This recipe is complete, and we now have an app with two basic modals, displayed
    on button press, and living in harmony in the same component:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个教程已经完成，我们现在有一个应用程序，其中有两个基本的模态框，通过按钮按下显示，并在同一个组件中和谐共存：
- en: '![](assets/14001108-37b7-461a-9205-f5b17bf10e78.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14001108-37b7-461a-9205-f5b17bf10e78.png)'
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 4*, we defined the first `Modal` component. We defined the `onClosed`
    and `onOpened` props, passing the `onClose` and `onOpen` class methods to these
    props. Whenever this `Modal` component is opened, `this.onOpen` will fire, and `this.onClose`
    will execute when the `Modal` is closed. While we didn't do anything exciting
    with these methods in this recipe, these hooks could serve as the perfect opportunity
    for logging user actions related to the modal. Or if the modal houses a form,
    `onOpen` could be used to pre-populate some form inputs with data, and `onClose`
    could save the form data to the `state` object for use as the modal is closed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们定义了第一个`Modal`组件。我们定义了`onClosed`和`onOpened`属性，将`onClose`和`onOpen`类方法传递给这些属性。每当打开这个`Modal`组件时，`this.onOpen`都会触发，当`Modal`关闭时，`this.onClose`会执行。虽然在这个示例中我们没有对这些方法做任何激动人心的事情，但这些钩子可以作为记录与模态框相关的用户操作的绝佳机会。或者，如果模态框包含一个表单，`onOpen`可以用来预先填充一些表单输入数据，而`onClose`可以将表单数据保存到`state`对象中，以便在关闭模态框时使用。
- en: 'In *step 5*, we defined the method that the first `TouchableOpacity` button
    component executes when pressed: `openModal1`. In this method, we made use of
    the `Modal` component''s ref. Refs are a core feature of React itself, and provide
    a place on the component instance for storing DOM nodes and/or React elements
    that are created in the component''s render method. Just as React (and React Native)
    components have both state and props (`this.state`, and `this.props` in a class
    component), they can also have refs (which live on `this.ref`). For more on how
    refs in React work, check the documentation at:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们定义了第一个`TouchableOpacity`按钮组件在按下时执行的方法：`openModal1`。在这个方法中，我们利用了`Modal`组件的引用。引用是React本身的一个核心特性，它为组件实例提供了一个存储在组件渲染方法中创建的DOM节点和/或React元素的位置。就像React（和React
    Native）组件有状态和属性（在类组件中为`this.state`和`this.props`）一样，它们也可以有引用（存储在`this.ref`上）。有关React中引用的工作原理，请查看文档：
- en: '[https://reactjs.org/docs/refs-and-the-dom.html](https://reactjs.org/docs/refs-and-the-dom.html)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/refs-and-the-dom.html](https://reactjs.org/docs/refs-and-the-dom.html)'
- en: Since we set the `ref` prop on the first `Modal` to the string `modal1`, we're
    able to access this same component in the `openModal1` method with the reference `this.ref.modal1`.
    Since `Modal` has an `open` and a `close` method, calling `this.ref.modal1.open()`
    opens the `Modal` with a `ref` of `modal1`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将第一个`Modal`上的`ref`属性设置为字符串`modal1`，因此我们可以在`openModal1`方法中使用引用`this.ref.modal1`访问同一个组件。由于`Modal`有一个`open`和一个`close`方法，调用`this.ref.modal1.open()`会打开具有`modal1`引用的`Modal`。
- en: This is not the only way to open and close a `Modal` component, as illustrated
    with the second modal we defined in *step 7*. Since this component has an `isOpen`
    prop, the modal can be opened or closed by changing the Boolean value being passed
    to the prop. By setting `isOpen` to be the `isOpen` value of the state, we can
    use the OK button in this modal to close the modal from within, by setting `isOpen`
    to false on `state`. In *step 8*, we defined the `openModal2` method, which also
    illustrates opening the second modal by changing the value of `isOpen` on `state`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是打开和关闭`Modal`组件的唯一方法，就像我们在*步骤7*中定义的第二个模态框所示。由于这个组件有一个`isOpen`属性，可以通过改变传递给该属性的布尔值来打开或关闭模态框。通过将`isOpen`设置为状态的`isOpen`值，我们可以使用此模态框中的确定按钮来从内部关闭模态框，通过在`state`上将`isOpen`设置为false。在*步骤8*中，我们定义了`openModal2`方法，也说明了通过改变`state`上的`isOpen`值来打开第二个模态框。
- en: In *step 9*, we defined a separate `isClosed` callback for keeping the `isOpen`
    value of `state` in sync in case the user dismisses the modal by pressing the
    backdrop instead of the modal's OK button. An alternative strategy would have
    been to disable the user's ability to dismiss the modal via pressing the backdrop,
    by adding the `backdropPressToClose` property to the `Modal` component and setting
    it to `false`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们为保持`state`的`isOpen`值同步定义了一个单独的`isClosed`回调，以防用户通过按下背景而不是模态框的确定按钮来关闭模态框。另一种策略是通过向`Modal`组件添加`backdropPressToClose`属性并将其设置为`false`来禁用用户通过按下背景来关闭模态框。
- en: 'There are a number of other optional props provided by the `react-native-modalbox`
    package that can make modal creation easier. We used `position` in this recipe
    to declare that the second modal be placed at the bottom of the screen, and you
    can view all other available props for `Modal` in the documentation at:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native-modalbox`包提供了许多其他可选的属性，可以使模态框的创建更加容易。在这个示例中，我们使用了`position`来声明第二个模态框应该放在屏幕底部，您可以在文档中查看`Modal`的所有其他可用属性：'
- en: '[https://github.com/maxs15/react-native-modalbox](https://github.com/maxs15/react-native-modalbox)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/maxs15/react-native-modalbox](https://github.com/maxs15/react-native-modalbox)'
- en: The `react-native-modalbox` library supports multiple modals in a single component;
    however, attempting to use the `isOpen` prop on more than one of these modals
    will cause all of those modals to open at once, which is unlikely to be the desired
    behavior.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native-modalbox`库支持在单个组件中使用多个模态框；但是，尝试在这些模态框中的多个上使用`isOpen`属性将导致所有这些模态框同时打开，这不太可能是期望的行为。'
