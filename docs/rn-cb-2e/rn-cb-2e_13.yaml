- en: Integration with Native Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与原生应用集成
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下的配方：
- en: Combining a React Native app and a Native iOS app
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将React Native应用和原生iOS应用结合
- en: Communicating from an iOS app to React Native
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从iOS应用到React Native的通信
- en: Communicating from React Native to an iOS app container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从React Native到iOS应用容器的通信
- en: Handle being invoked by an external iOS app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理外部iOS应用的调用
- en: Combining a React Native app and a native Android app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将React Native应用和原生Android应用结合
- en: Communicating from an Android app to React Native
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Android应用到React Native的通信
- en: Communicating from React Native to an Android app container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从React Native到Android应用容器的通信
- en: Handle being invoked by an external Android app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理外部Android应用的调用
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: React Native was introduced as a solution to build native applications using
    JavaScript, with the goal of granting more developers the ability to build truly
    native applications for multiple platforms. As a consequence of building a React
    Native application with a team, it can be common for JavaScript developers and
    native developers to work closely together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React Native被引入作为使用JavaScript构建原生应用的解决方案，目标是让更多的开发人员能够为多个平台构建真正的原生应用。作为一个团队构建React
    Native应用的结果，JavaScript开发人员和原生开发人员密切合作是很常见的。
- en: One of the advantages of React Native's ability to render native UI views is
    that they can be easily embedded inside existing native apps. It is not uncommon
    for companies to already have sophisticated native apps that are critical to their
    line of business. There may be no immediate need to rewrite their entire codebase
    in React Native if the app is not broken. In such a case, React Native can be
    leveraged by both JavaScript and native developers to write React Native code
    that can be integrated into an existing app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React Native能够渲染原生UI视图的一个优势是它们可以轻松地嵌入到现有的原生应用中。公司已经拥有关键的原生应用对于他们的业务至关重要并不罕见。如果应用程序没有出现问题，可能没有立即需要将整个代码库重写为React
    Native。在这种情况下，JavaScript和原生开发人员都可以利用React Native编写的代码，将其集成到现有应用中。
- en: This chapter will focus exclusively on using React Native inside existing native
    iOS and Android applications. We will cover rendering a React Native app within
    a native app, how to communicate between the React Native app and its native parent
    app, and how our React Native app can be invoked with other apps on a user's device.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于在现有的原生iOS和Android应用中使用React Native。我们将涵盖在原生应用中渲染React Native应用，如何在React
    Native应用和其原生父应用之间进行通信，以及我们的React Native应用如何在用户设备上与其他应用一起调用。
- en: When working on the Android recipes, it is recommended that you enable the auto-import
    settings in Android Studio or use *Alt*+*Enter* to perform a quick fix code completion
    for the class import.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Android配方时，建议您在Android Studio中启用自动导入设置，或使用*Alt*+*Enter*执行快速修复代码完成类导入。
- en: Combining a React Native app and a Native iOS app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将React Native应用和原生iOS应用结合
- en: In the event that you work for a company or have a client that has an active
    iOS app out in the world, it may not be advantageous to rewrite it from scratch,
    especially if it is well-built, used frequently, and praised by its users. If
    you just want to build new functionality using React Native, the React Native
    app can be embedded and rendered inside an existing native iOS app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一家公司工作，或者有一个客户在世界上使用着一个活跃的iOS应用，重写它可能并不明智，特别是如果它构建良好，经常被使用，并受到用户的赞扬。如果您只想使用React
    Native构建新功能，React Native应用可以嵌入并在现有的原生iOS应用中渲染。
- en: 'This recipe will walk through creating a blank iOS app and adding it to a React
    Native app so that the two layers can communicate with each other. We will cover
    two ways of rendering the React Native app: embedded inside the application as
    a nested view, and another as a full-screen implementation. The steps that are
    discussed in this recipe serve as a baseline for rendering React Native apps,
    along with native iOS apps.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将介绍如何创建一个空白的iOS应用程序，并将其添加到React Native应用程序中，以便这两个层可以相互通信。我们将介绍两种呈现React Native应用程序的方法：嵌入在应用程序中作为嵌套视图，以及作为全屏实现的另一种方法。本教程讨论的步骤将作为呈现React
    Native应用程序以及原生iOS应用程序的基线。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will be referencing a native iOS application named `EmbeddedApp`.
    We will walk through creating the sample iOS application in this section. If you already
    have an iOS app you intend on integrating with React Native, you can skip ahead
    to the recipe instructions. You will, however, need to be sure that you have `cocoapods`
    installed. This library is a package manager for Xcode projects. It can be installed
    via Homebrew using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将引用一个名为`EmbeddedApp`的原生iOS应用程序。我们将在本节中介绍如何创建示例iOS应用程序。如果您已经有一个打算与React Native集成的iOS应用程序，可以直接跳转到教程说明。但是，您需要确保已安装`cocoapods`。这个库是Xcode项目的包管理器。可以使用以下命令通过Homebrew安装它：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With `cocoapods` installed, the next step is creating a new native iOS project
    in Xcode. This can be done by opening Xcode and choosing File | New | Project.
    In the window that follows, choose the default Single View Application iOS template
    to get started, and hit Next.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`cocoapods`后，下一步是在Xcode中创建一个新的原生iOS项目。可以通过打开Xcode并选择文件|新建|项目来完成。在随后的窗口中，选择默认的单视图应用程序iOS模板开始，并点击下一步。
- en: 'In the options screen for the new project, be sure to set the Product Name
    field to `EmbeddedApp`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目的选项屏幕中，确保将产品名称字段设置为`EmbeddedApp`：
- en: '![](assets/86748b32-0ee0-44e1-82c2-bfb91772e34f.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86748b32-0ee0-44e1-82c2-bfb91772e34f.png)'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll begin by creating a new vanilla React Native app that will serve as
    the root of our project. Let''s name the new project `EmbedApp`. You can create
    the new React Native app with the CLI using the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的原始React Native应用程序，作为我们项目的根。让我们将新项目命名为`EmbedApp`。您可以使用以下命令使用CLI创建新的React
    Native应用程序：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By creating the new app with the CLI, the `ios` and `android` subfolders will
    be automatically created for us, holding the native code for each platform. Let's
    move the native app we created in the *Getting ready* section to the `ios` folder
    so that it lives at `/EmbedApp/ios/EmbeddedApp`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用CLI创建新应用程序，`ios`和`android`子文件夹将自动为我们创建，其中包含每个平台的原生代码。让我们将我们在“准备工作”部分中创建的原生应用程序移动到`ios`文件夹中，以便它位于`/EmbedApp/ios/EmbeddedApp`。
- en: Now that we have the basic structure we need for the app, we'll need to add
    a Podfile. This is a file, similar to `package.json` in web development, that
    keeps track of all of the cocoapod dependencies (called pods) that are used in
    a project. The Podfile should always live in the root of the vanilla iOS project,
    which in our case is `/EmbedApp/ios/EmbeddedApp`. In a Terminal, `cd` into this
    directory and run the `pod init` command. This generates a base Podfile for you.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为应用程序准备好了基本结构，我们需要添加一个Podfile。这是一个文件，类似于Web开发中的`package.json`，用于跟踪项目中使用的所有cocoapod依赖项（称为pods）。Podfile应始终位于原始iOS项目的根目录中，在我们的情况下是`/EmbedApp/ios/EmbeddedApp`。在终端中，`cd`进入此目录并运行`pod
    init`命令。这将为您生成一个基本的Podfile。
- en: 'Next, open the Podfile in your favorite IDE. We''ll be adding the pods that
    are needed for the app to this file. The following is the contents of the final
    Podfile, with the newly added React Native dependencies in bold:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您喜欢的IDE中打开Podfile。我们将向该文件添加应用程序所需的pods。以下是最终Podfile的内容，其中新增的React Native依赖项已用粗体标出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how each of the paths listed in the React Native dependencies that we're
    adding point to the `/node_modules` folder of the React Native project. If your
    native project (in our case, `EmbeddedApp`) was at a different location, these
    references to `/node_modules` would have to be updated accordingly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们正在添加的React Native依赖项中列出的每个路径都指向React Native项目的`/node_modules`文件夹。如果您的本地项目（在我们的情况下是`EmbeddedApp`）位于不同的位置，则必须相应地更新对`/node_modules`的引用。 '
- en: With the Podfile in place, installing the pods themselves is as easy as running
    the `pod install` command from the Terminal in the same directory we created the
    Podfile.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了Podfile，安装pod本身就像在终端中运行`pod install`命令一样容易，我们在创建Podfile的同一目录中运行。
- en: 'Next, let''s return to the React Native app at the root directory of the project, `/EmbedApp`.
    We''ll start by removing the generated code in `index.js`, and replacing it with
    our own simple React Native app.At the bottom of the file, we''ll use the `registerComponent` method
    on the `AppRegistry` component to register `EmbedApp` as the root component of
    the React Native app. This will be a very simple app that just renders the text
    `Hello in React Native` so that it can be distinguished from the native layer
    in later steps:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们回到项目的根目录`/EmbedApp`中的React Native应用程序。我们将首先删除`index.js`中生成的代码，并用我们自己的简单的React
    Native应用程序替换它。在文件底部，我们将在`AppRegistry`组件上使用`registerComponent`方法将`EmbedApp`注册为React
    Native应用程序的根组件。这将是一个非常简单的应用程序，只是渲染文本`Hello in React Native`，以便在后续步骤中可以与本地层区分开来：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have a React Native app, we can move to the native code. When we
    initialized cocoapods in *step 3*, it also generated a new `.xcworkspace` file. Be
    sure to close the `EmbeddedApp` project in Xcode, then re-open it in Xcode using
    the `EmbeddedApp.xcworkspace` file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个React Native应用程序，我们可以转到本地代码。当我们在*步骤3*中初始化cocoapods时，它还生成了一个新的`.xcworkspace`文件。确保在Xcode中关闭`EmbeddedApp`项目，然后使用`EmbeddedApp.xcworkspace`文件重新在Xcode中打开它。
- en: 'In Xcode, let''s open `Main.storyboard`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中，让我们打开`Main.storyboard`：
- en: '![](assets/8137ae79-365d-4021-92fb-a3bbea5710bb.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8137ae79-365d-4021-92fb-a3bbea5710bb.png)'
- en: 'In the storyboard, we''ll need to add two buttons: one labeled Open React Native
    App and one labeled Open React Native App (Embedded). We''ll also need a new container
    view below the two buttons. The resulting storyboard should look something like
    this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Storyboard中，我们需要添加两个按钮：一个标记为Open React Native App，另一个标记为Open React Native App（Embedded）。我们还需要在两个按钮下方添加一个新的容器视图。最终的Storyboard应该看起来像这样：
- en: '![](assets/a5422254-5435-4d34-b043-6a2d199e9c7b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5422254-5435-4d34-b043-6a2d199e9c7b.png)'
- en: 'Next, we''ll need a new a new Cocoa Touch Class. This can be created from the
    menus by choosing File | New | File. We''ll name the class `EmbeddedViewController` and assign
    it a subclass of `UIViewController`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个新的Cocoa Touch类。这可以通过菜单选择`File | New | File`来创建。我们将类命名为`EmbeddedViewController`，并将其分配为`UIViewController`的子类：
- en: '![](assets/0a544b69-116a-491e-baa8-7f3c3e89db2c.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a544b69-116a-491e-baa8-7f3c3e89db2c.png)'
- en: 'Let''s return to `Main.storyboard`. In the new scene that''s created by adding
    the class in the previous step (second View Controller Scene), select the View
    Controller child. Make sure that the Identity inspector is open in the right-hand
    panel:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`Main.storyboard`。在通过上一步添加类创建的新场景（第二个View Controller场景）中，选择View Controller子项。确保身份检查器在右侧面板中是打开的：
- en: '![](assets/25acdbd3-b7a1-4297-8988-fdcfb99b9742.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/25acdbd3-b7a1-4297-8988-fdcfb99b9742.png)'
- en: 'With the View Controller selected, change the Class value to our newly created
    class, `EmbeddedViewController`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择View Controller后，将`Class`值更改为我们新创建的类`EmbeddedViewController`：
- en: '![](assets/b1431a9d-3d22-43cb-90ac-a676db65613a.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b1431a9d-3d22-43cb-90ac-a676db65613a.png)'
- en: 'Next, in the top View Controller Scene, select the Embed segue object:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在顶部View Controller Scene中，选择Embed segue对象：
- en: '![](assets/83a215de-c779-4dc6-892d-c75beede2ef1.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83a215de-c779-4dc6-892d-c75beede2ef1.png)'
- en: 'With the segue selected, select the Attributes inspector from the right-hand
    panel, and update the Identifier field to the embed value. We will use this identifier
    to embed the React Native layer within the native app:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择segue后，从右侧面板中选择属性检查器，并将标识符字段更新为embed值。我们将使用此标识符将React Native层嵌入到原生应用程序中：
- en: '![](assets/00ca967c-3df7-4d4c-8e6b-45e58d03b7ab.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00ca967c-3df7-4d4c-8e6b-45e58d03b7ab.png)'
- en: 'We''re ready to build out the `ViewController` implementation. Open the `ViewController.m` file.
    We''ll start with the imports:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备构建`ViewController`的实现。打开`ViewController.m`文件。我们将从导入开始：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Just beneath the imports, we can add an interface definition to point to the
    `EmbeddedViewController` we created in *step 10*:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入下面，我们可以添加一个接口定义，指向我们在*步骤10*中创建的`EmbeddedViewController`：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Following is the `@interface`, we'll add the methods we need to the `@implementation`.
    The first method, `openRNAppButtonPressed`, will be wired to the first button
    we created in the storyboard, labeled Open React Native App. Likewise, the `openRNAppEmbeddedButtonPressed`
    method will be wired to the second button, Open React Native App (Embedded).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`@interface`，我们将向`@implementation`添加我们需要的方法。第一个方法`openRNAppButtonPressed`将连接到我们在故事板中创建的第一个按钮，标有“打开React
    Native应用程序”。同样，`openRNAppEmbeddedButtonPressed`方法将连接到第二个按钮“打开React Native应用程序（嵌入式）”。
- en: 'You''ll likely notice that the methods are almost identical, with the second
    method referencing `embeddedViewController`, the same `EmbeddedViewController`
    class we created in step 10 (`[embeddedViewController setView:rootView];`). Both
    methods define `jsCodeLocation` with the value of `http://localhost:8081/index.bundle?platform=ios`,
    which is the URL that the React Native app will be served from. Also, take note
    that the `moduleName` property in both methods is set to `EmbedApp`, which is
    the name that the React Native app is exported as, which we defined in *step 6*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这两种方法几乎是相同的，第二种方法引用了`embeddedViewController`，与我们在第10步中创建的`EmbeddedViewController`类相同（`[embeddedViewController
    setView:rootView];`）。这两种方法都使用`jsCodeLocation`定义了值为`http://localhost:8081/index.bundle?platform=ios`的URL，这是React
    Native应用程序将被提供的URL。另外，请注意，这两种方法中的`moduleName`属性都设置为`EmbedApp`，这是React Native应用程序的导出名称，我们在*步骤6*中定义了它：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll also need to define the `prepareForSegue` method. Here, you can see `segue.identifier
    isEqualToString:@"embed"`, which refers to the embed identifier we gave the segue
    in *step 13*:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义`prepareForSegue`方法。在这里，您可以看到`segue.identifier isEqualToString:@"embed"`，这是指我们在*步骤13*中给segue的嵌入标识符：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With our implementation of `ViewController` in place, we now we need to wire
    up our button actions to the buttons themselves. Let''s return to `Main.storyboard`. *Ctrl +*
    click on the first button to get a menu of actions that are assignable to the
    button, select the Touch Up Inside action by clicking and dragging from Touch
    Up Inside back to the storyboard, and map the button to the `openRNAppButtonPressed` method
    we defined in *step 15*. Repeat these steps for the second button, linking it
    instead to the `openRNAppEmbeddedButtonPressed` method:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`ViewController`实现就位后，现在我们需要将按钮操作连接到按钮本身。让我们返回到`Main.storyboard`。*Ctrl +*单击第一个按钮以获取可分配给按钮的操作菜单，通过从Touch
    Up Inside返回到故事板，将按钮映射到我们在*步骤15*中定义的`openRNAppButtonPressed`方法。对于第二个按钮，重复这些步骤，将其链接到`openRNAppEmbeddedButtonPressed`方法：
- en: '![](assets/7d82272a-9878-4c24-900c-86db62b70e71.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7d82272a-9878-4c24-900c-86db62b70e71.png)'
- en: 'For the React Native layer to be able to communicate with the native layer,
    we also need to add a security exception, which will allow our code to communicate
    with `localhost`. Right-click on the `Info.plist` file and select Open As | Source
    Code. Within the base `<dict>` tag, add the following entry:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使React Native层能够与原生层通信，我们还需要添加一个安全异常，这将允许我们的代码与`localhost`通信。右键单击`Info.plist`文件，然后选择打开为|源代码。在基本`<dict>`标签内，添加以下条目：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our app is complete! From the `/EmbedApp` root directory, start up the React
    Native app using the CLI with the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序完成了！从`/EmbedApp`根目录，使用以下命令通过CLI启动React Native应用程序：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the React Native app running, let's also run the native app `EmbeddedApp`
    from Xcode. Now, pressing the Open React Native App button should open the React
    Native app we created in *step 6* in full screen, and the same React Native app
    should open within the container view we created in *step 9* when pressing the
    Open React Native App (Embedded) button.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着React Native应用程序的运行，让我们也从Xcode运行原生应用程序`EmbeddedApp`。现在，按下打开React Native应用程序按钮应该会全屏打开我们在*步骤6*中创建的React
    Native应用程序，并且在按下打开React Native应用程序（嵌入式）按钮时，相同的React Native应用程序应该在我们在*步骤9*中创建的容器视图中打开。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we covered rendering a React Native app within a native iOS
    app via two different methods. The first method replaces the application's main
    `UIViewController` instance with the React Native app, referred to in the native
    code as `RCTRootView`. This was accomplished in the `openRNAppButtonPressed` method.
    The second and slightly more involved method is rendering the React Native app
    inline with the native app. This was accomplish by creating a container view that links
    to a different `UIViewController` instance. In this case, we replaced the contents
    of `embedViewController` with our `RCTRootView` instance. This is what happens
    when the `openRNAppEmbeddedButtonPressed` method is fired.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们介绍了通过两种不同的方法在原生iOS应用程序中渲染React Native应用程序。第一种方法是用React Native应用程序替换应用程序的主`UIViewController`实例，在原生代码中称为`RCTRootView`。这是在`openRNAppButtonPressed`方法中完成的。第二种方法稍微复杂一些，是将React
    Native应用程序与原生应用程序内联渲染。这是通过创建一个容器视图来实现的，该容器视图链接到不同的`UIViewController`实例。在这种情况下，我们用我们的`RCTRootView`实例替换了`embedViewController`的内容。这就是`openRNAppEmbeddedButtonPressed`方法触发时发生的事情。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: For a better understanding of the role cocoapods plays in Xcode/React Native
    development, I recommend Google's *Route 85 Show* episode covering the subject
    on YouTube. The video can be found at [https://www.youtube.com/watch?v=iEAjvNRdZa0](https://www.youtube.com/watch?v=iEAjvNRdZa0).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解cocoapods在Xcode/React Native开发中的作用，我建议观看Google的*Route 85 Show*在YouTube上涵盖该主题的视频。视频可以在[https://www.youtube.com/watch?v=iEAjvNRdZa0](https://www.youtube.com/watch?v=iEAjvNRdZa0)找到。
- en: Communicating from an iOS app to React Native
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从iOS应用程序到React Native的通信
- en: In the previous recipe, we learned how to render a React Native app as part
    of a larger native iOS app. Unless you're building a glorified app container or
    portal, you'll likely need to communicate between the native layer and the React
    Native layer. This will be the subject matter of the next two recipes, one recipe
    for each direction of communication.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们学习了如何将React Native应用程序渲染为较大的原生iOS应用程序的一部分。除非您正在构建一个华丽的应用程序容器或门户，否则您可能需要在原生层和React
    Native层之间进行通信。这将是接下来两个教程的主题，每个教程都涉及通信的一个方向。
- en: In this recipe, we will cover communicating from the native layer to the React
    Native layer, sending data from the parent iOS app to our embedded React Native
    app, by using a `UITextField` in the iOS app that sends its data to the React
    Native app.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍从本地层到React Native层的通信，通过在iOS应用程序中使用`UITextField`将数据发送到我们嵌入的React
    Native应用程序。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since this recipe requires a native app with a nested React Native app within
    it, we'll be beginning at the end of the previous recipe, effectively picking
    up where we left off. This will help you understand how basic cross-layer communication
    works so that you can use the same principles in your own native app, which may
    already exist and have complex features. Therefore, the easiest way to follow
    along with this recipe is to use the endpoint of the previous recipe as a starting
    place.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个示例需要一个嵌套的React Native应用程序的本地应用程序，我们将从上一个示例的结尾开始，有效地接着上次离开的地方。这将帮助您了解基本的跨层通信如何工作，以便您可以在自己的本地应用程序中使用相同的原则，这可能已经存在并具有复杂的功能。因此，跟随这个示例的最简单方法是使用上一个示例的终点作为起点。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by updating the `ViewController.m` implementation file in the
    native layer. Be sure to open the project in Xcode via the `.xcworkspace` file
    in the `EmbeddedApp`, which we placed in the `/ios/EmbeddApp` directory of the
    project in the previous recipe. We''ll start with the imports:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从更新本地层的`ViewController.m`实现文件开始。确保通过上一个示例中项目中`/ios/EmbeddApp`目录中放置的`EmbeddedApp`的`.xcworkspace`文件在Xcode中打开项目。我们将从导入开始：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to add a reference to the React Native bridge via the `ViewController`
    interface, effectively linking the native controller with the React Native code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是通过`ViewController`接口添加对React Native桥的引用，有效地将本地控制器与React Native代码链接起来：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also need an `@property` reference of `userNameField` that we will
    use in a later step to wire to the `UITextField`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`@property`引用`userNameField`，我们将在后面的步骤中将其连接到`UITextField`：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Directly below this reference, we''ll begin defining the class methods. We''ll
    begin with the `sourceURLForBridge` method, which defines where the React Native
    app will be served from. In our case, the app URL should be `http://localhost:8081/index.bundle?platform=ios`, which
    points at the `index.js` file of the React Native app once it is run with the `react-native
    start` command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个参考下面，我们将开始定义类方法。我们将从`sourceURLForBridge`方法开始，该方法定义了React Native应用程序的服务位置。在我们的情况下，应用程序的URL应该是`http://localhost:8081/index.bundle?platform=ios`，这指向了React
    Native应用程序的`index.js`文件，一旦它使用`react-native start`命令运行：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll leave the `viewDidLoad` and `didReveiveMemoryWarning` methods as is:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保留`viewDidLoad`和`didReveiveMemoryWarning`方法不变：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we''ll need to update the `openRNAppEmbeddedButtonPressed` method. Notice
    how the `moduleName` property is set to `FromNativeToRN`. This is a reference
    to the name that we give the React Native app when it is exported, which we''ll
    define in a later step. This time, we are also defining a property of `userName`
    for passing data to the React Native layer:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`openRNAppEmbeddedButtonPressed`方法。注意`moduleName`属性设置为`FromNativeToRN`。这是我们导出React
    Native应用程序时给出的名称的引用，我们将在后面的步骤中定义。这次，我们还定义了一个`userName`属性，用于向React Native层传递数据：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll also need an `onUserNameChanged` method. This is the method that will
    do the actual sending of data across the bridge to the React Native layer. The
    event name we''re defining here is `UserNameChanged`, which we''ll reference in
    the React Native layer in a later step. This will also pass along the text that''s
    currently in the text input, which will be named `userNameField`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`onUserNameChanged`方法。这是将数据实际发送到React Native层的方法。我们在这里定义的事件名称是`UserNameChanged`，我们将在后面的步骤中在React
    Native层中引用它。这也将传递当前文本输入中的文本，该文本将被命名为`userNameField`：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll also need `prepareForSegue` for configuring `embeddedViewController`
    just before it is displayed:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`prepareForSegue`来配置`embeddedViewController`，就在它显示之前：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Back in the `Main.storyboard`, let''s add that Text Field, along with a Label
    that defines what the input is for. You can also name the input User Name Field so
    that everything is easier to recognize in the View Controller Scene:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`Main.storyboard`，让我们添加一个文本字段，以及一个定义输入用途的标签。您还可以将输入命名为User Name Field，以便在视图控制器场景中更容易识别：
- en: '![](assets/c44f2cfe-f832-489c-8dcf-543f805b85c6.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c44f2cfe-f832-489c-8dcf-543f805b85c6.png)'
- en: 'Next, we''ll need to wire an event for when the text changes in the User Name
    Field text input, and a referencing outlet so that the View Controller knows how
    to reference it. These can both be done via the Connections Inspector, which is
    accessible via the last button along the top of the right-hand side panel (the
    icon is a right pointing arrow in a circle).  With the text input selected, click
    and drag from Editing Changed to the View Controller (represented via the main
    storyboard), and choose the `onUserNameChange` method we defined in *step 7*.
    Then, create the following wirings by dragging the item to the `ViewController`.
    Similarly, add a new Referencing Outlet by clicking and dragging from the New
    Referencing Outlet back to the View Controller, this time choosing the userNameField
    value we targeted in *step 7*. Your Connections Inspector settings should now
    look like this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`User Name Field`文本输入的文本更改事件和引用出口进行连接，以便视图控制器知道如何引用它。这两者都可以通过连接检查器完成，连接检查器可以通过右侧面板顶部的最后一个按钮（图标是一个右指向箭头在一个圆圈中）访问。选择文本输入后，从`Editing
    Changed`拖动到视图控制器（通过主故事板表示），并选择我们在*步骤7*中定义的`onUserNameChange`方法。然后，通过将项目拖动到`ViewController`来创建以下连接。类似地，通过从新引用出口拖动到视图控制器，这次选择我们在*步骤7*中定位的userNameField值，添加一个新的引用出口。您的连接检查器设置现在应该如下所示：
- en: '![](assets/e423f6dc-291d-448b-aef0-95862640aa3a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e423f6dc-291d-448b-aef0-95862640aa3a.png)'
- en: We've now completed the steps needed in the native app. Let's move on to the
    React Native layer. Back in the `index.js` file, we'll start with imports. Notice
    how we're now including the `NativeAppEventEmitter`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了原生应用程序中所需的步骤。让我们继续进行React Native层。回到`index.js`文件，我们将从导入开始。请注意，我们现在包括了`NativeAppEventEmitter`。
- en: 'Put the following functions inside the class definition:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数放在类定义内部：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll name the app `FromNativeToRN` to match the module name we defined in
    the native layer in *step 6*, using `AppRegistry.registerComponent` to register
    the app with the same name. We''ll also leave the basic styles in place:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将应用程序命名为`FromNativeToRN`，以匹配我们在*步骤6*中定义的原生层中的模块名称，使用`AppRegistry.registerComponent`来注册具有相同名称的应用程序。我们还将保留基本样式。
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll set an initial `state` object with a `userName` string property for
    storing and displaying the text that''s received from the native layer:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置一个初始的`state`对象，其中包含一个`userName`字符串属性，用于存储和显示从原生层接收到的文本：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `userName` value passed into the React Native layer will be received as
    a property. When the component mounts, we want to do two things: set the `userName` state
    property if it''s already defined by the native layer, and wire an event listener
    to update `userName` when the text field in the native layer is updated. Recall
    in *step 7* that we defined the event''s name to be `UserNameChanged`, so that''s
    the event we''ll listen for. When the event is received, we update the `state.userName`
    to the text that''s passed along with the event:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递到React Native层的`userName`值将作为属性接收。当组件挂载时，我们希望做两件事：如果原生层已经定义了`userName`状态属性，则设置`userName`状态属性，并将事件监听器连接到在原生层中更新`userName`时更新`userName`。回想一下，在*步骤7*中，我们定义了事件的名称为`UserNameChanged`，这就是我们要监听的事件。当接收到事件时，我们将更新`state.userName`为事件传递的文本：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we can add the `render` function, which simply renders the value stored
    in `state.userName`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加`render`函数，它简单地渲染`state.userName`中存储的值：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It''s time to run our app! First, in the root of the project, we can start
    up the React Native app with the React Native CLI with the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候运行我们的应用程序了！首先，在项目的根目录中，我们可以使用以下命令通过React Native CLI启动React Native应用程序：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We follow this by running the native app in the simulator via Xcode:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们通过Xcode在模拟器中运行原生应用程序：
- en: '![](assets/f917a790-b142-4636-b6e0-b547fae1b21f.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f917a790-b142-4636-b6e0-b547fae1b21f.png)'
- en: Communicating from React Native to an iOS app container
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从React Native通信到iOS应用程序容器
- en: 'The last recipe covered communication between layers in the direction of native
    to React Native. In this recipe, we will cover communicating in the opposite direction:
    from React Native to native. This time, we will render a user input element inside
    our React Native app and set up a one-way binding from React Native to a UI component
    rendered in the native app.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例涵盖了在原生到React Native方向上的层间通信。在这个示例中，我们将涵盖在相反方向上的通信：从React Native到原生。这次，我们将在React
    Native应用程序中渲染一个用户输入元素，并设置从React Native到在原生应用程序中渲染的UI组件的单向绑定。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just like the last recipe, this recipe depends on the final product of the first
    app in this chapter, in the *Combining a React Native app and a Native iOS app* recipe.
    To follow along, be sure you've finished that recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个示例一样，这个示例取决于本章第一个应用程序的最终产品，在*将React Native应用程序和原生iOS应用程序组合*示例中。要跟着做，请确保你已经完成了那个示例。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s begin in the native layer. Open the `EmbeddedApp` native app in Xcode
    via the `.xcworkspace` file. We''ll first add imports to `ViewController.m`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从原生层开始。通过`.xcworkspace`文件在Xcode中打开`EmbeddedApp`原生应用程序。我们首先要在`ViewController.m`中添加导入：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we did in the last recipe, we need to add a reference to the React Native
    bridge via the `ViewController` interface, providing a bridge between the native
    controller and the React Native code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个示例一样，我们需要通过`ViewController`接口添加对React Native桥的引用，提供原生控制器和React Native代码之间的桥接：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will also need a `@property` reference of `userNameField` that we will use
    in a later step to wire to the `UITextField`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`@property`引用`userNameField`，我们将在后面的步骤中将其连接到`UITextField`：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s move on to defining the `@implementation`. Again, we must provide the
    source of the React Native app, which will be served from `localhost`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续定义`@implementation`。同样，我们必须提供React Native应用程序的源，它将从`localhost`提供：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the `viewDidLoad` method, we can also connect the controller to the method
    that opens the React Native app in our container view (`openRNAppEmbeddedButtonPressed`).
    We''ll leave the `didReveiveMemoryWarning` method as is:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`viewDidLoad`方法，我们还可以将控制器连接到在容器视图中打开React Native应用程序的方法(`openRNAppEmbeddedButtonPressed`)。我们将保持`didReveiveMemoryWarning`方法不变：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Like the last recipe, we''ll need to update the `openRNAppEmbeddedButtonPressed`
    method. This time, the `moduleName` property is set to `FromRNToNative` to reflect
    the name that we will give the React Native app when it is exported, as defined
    in a later step. We also define a property of `userName` for passing data to the
    React Native layer:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个配方一样，我们需要更新`openRNAppEmbeddedButtonPressed`方法。这次，`moduleName`属性设置为`FromRNToNative`，以反映我们在导出时将给React
    Native应用程序的名称，如后面的步骤中定义的。我们还定义了一个`userName`属性，用于向React Native层传递数据：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last two methods we''ll need in this file are `prepareForSegue` for configuring
    the `embeddedViewController` just before it is displayed, and an `updateUserNameField` method
    that will be fired when our text input in the native layer is updated with new
    text from the user:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个文件中还需要的最后两个方法是`prepareForSegue`，用于在显示之前配置`embeddedViewController`，以及一个`updateUserNameField`方法，当我们在本地层的文本输入中使用用户的新文本更新时将被触发：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Unlike the previous recipe, we''ll need to also update the `ViewController` header
    file (`ViewController.h`). The method referenced here, `updateUserNameField`,
    will be used when we define the `ViewController` implementation:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个配方不同，我们还需要更新`ViewController`头文件（`ViewController.h`）。在这里引用的方法`updateUserNameField`将在我们定义`ViewController`实现时使用：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we''re going to need to create a new `UserNameManager` native module.
    First, create a Cocoa Touch class named `UserNameManager`. Once created, let''s
    open the implementation file (`UserNameManger.m`) and add our imports:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的`UserNameManager`本地模块。首先，创建一个名为`UserNameManager`的Cocoa Touch类。创建后，让我们打开实现文件（`UserNameManger.m`）并添加我们的导入：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For a more in-depth look at creating native modules, refer to the *Exposing
    Custom iOS Modules *recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality**.*
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解创建本地模块，请参阅[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中的*公开自定义iOS模块*配方。
- en: 'Next, we''ll define the class implementation. The main takeaway here is the `setUserName`
    method, which is the method that we''re exporting from the native layer for use
    in the React Native app. We''ll use this method in the React Native app to update
    the value in the native Text Field. However, since we are updating a native UI
    component, the operation must be performed on the main thread. This is the purpose
    of the `methodQueue` function, which instructs the module to execute on the main
    thread:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义类实现。这里的主要要点是`setUserName`方法，这是我们从本地层导出供React Native应用程序使用的方法。我们将在React
    Native应用程序中使用此方法来更新本地文本字段中的值。然而，由于我们正在更新本地UI组件，操作必须在主线程上执行。这就是`methodQueue`函数的目的，它指示模块在主线程上执行：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll also need to update the `UserNameMangager.h` header file to use the
    React Native bridge module:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新`UserNameMangager.h`头文件以使用React Native桥接模块：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Like the last recipe, we''ll need to add a Text Field and Label for the User
    Name input:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个配方一样，我们需要为用户名输入添加一个文本字段和标签：
- en: '![](assets/5e24e43a-1913-49b0-b7c5-0c78dceebc4e.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5e24e43a-1913-49b0-b7c5-0c78dceebc4e.png)'
- en: 'We''ll also need to add a Referencing Outlet from the Text Field we created
    in the last set to our `userNameField` property:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从上一组中创建的文本字段到我们的`userNameField`属性添加一个引用输出：
- en: '![](assets/0d70c124-06e7-4132-b78a-985abbe8592c.png)If you need more information
    on how to create a Referencing Outlet, view *step 10* of the previous recipe.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0d70c124-06e7-4132-b78a-985abbe8592c.png)如果您需要更多关于如何创建引用输出的信息，请查看上一个配方的*步骤10*。'
- en: 'We''re finished with the native portion of this project, so let''s turn to
    our React Native code. Let''s open the `index.js` file at the root of the project.
    We''ll start with our imports:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了这个项目的本地部分，现在让我们转向我们的React Native代码。让我们打开项目根目录下的`index.js`文件。我们将从导入开始：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s define the app with the name `FromRNToNative` to line up with the `moduleName`
    we declared in the native code in *step 6*, and register the component with the
    same name. The `state` object only needs a `userName` string property for hold
    the value that''s saved to the `TextInput` component, which we''ll add in the
    component''s `render` function:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用名称`FromRNToNative`来定义应用程序，以便与我们在原生代码中*步骤6*中声明的`moduleName`对齐，并使用相同名称注册组件。`state`对象只需要一个`userName`字符串属性来保存保存到`TextInput`组件的值，我们将在组件的`render`函数中添加它：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The app''s `render` function uses a `TextInput` component to take input from
    the user, which it will then send to the native app via the React Native bridge.
    It does this by calling the `onUserNameChange` method when the value of the `TextInput`
    changes:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的`render`函数使用`TextInput`组件从用户那里获取输入，然后通过React Native桥将其发送到原生应用程序。它通过在`TextInput`的值改变时调用`onUserNameChange`方法来实现这一点：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last thing we need to do is define the `onUserNameChange` method that''s
    used by the `onChangeText` property of the `TextInput` component we defined in
    the previous step. This method updates `state.userName` to the value in the text
    input, and also sends the value along to the native code by using the `NativeModules`
    component in React Native. `NativeModules` has the `UserNameManager` class we
    defined as a Cocoa Touch class in the native layer in *step 9*. We call the `setUserName`
    method that we defined on the class in *step 10* to pass the value along to the
    native layer, where it will be displayed in the Text Field we created in *step
    12*:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是定义`onUserNameChange`方法，该方法由我们在上一步中定义的`TextInput`组件的`onChangeText`属性使用。此方法将`state.userName`更新为文本输入中的值，并通过React
    Native中的`NativeModules`组件将该值发送到原生代码。`NativeModules`具有我们在原生层*步骤9*中定义为Cocoa Touch类的`UserNameManager`类。我们在*步骤10*中调用了我们在类中定义的`setUserName`方法，将该值传递到原生层，在那里它将显示在我们在*步骤12*中创建的文本字段中：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The app is done! Return to the root of the project to start up the React Native
    app with the following command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序完成了！返回到项目的根目录，使用以下命令启动React Native应用程序：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, with the React Native app started, run the native `EmbeddedApp` project
    from Xcode. Now, the input in the React Native app should communicate its value
    to the input in the parent native app:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动React Native应用程序后，从Xcode运行原生`EmbeddedApp`项目。现在，React Native应用程序中的输入应该将其值传递给父原生应用程序中的输入：
- en: '![](assets/02a70ade-cb5a-4dd8-bd2e-13ea02e8a899.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02a70ade-cb5a-4dd8-bd2e-13ea02e8a899.png)'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To communicate from our React Native app to the parent native app, we created
    a native module named `UserNameManager` with a `setUserName` method, which we
    exported from the native layer, and used in the React Native app, in its `onUserNameChange`
    method. This is the recommended way of communicating from React Native to native.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的React Native应用程序通信到父原生应用程序，我们创建了一个名为`UserNameManager`的原生模块，其中包含一个`setUserName`方法，我们从原生层导出，并在React
    Native应用程序中使用，在其`onUserNameChange`方法中。这是从React Native到原生通信的推荐方式。
- en: Handle being invoked by an external iOS app
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理被外部iOS应用程序调用
- en: It is also a common behavior for native apps to communicate between one another
    via linking, and are usually prompted to the user with the phrase Open in...,
    along with the name of an app that can better handle an action. This is done by
    using a protocol that is specific to your app. Just like any website link has
    a protocol of either `http://` or `https://`, we can also create a custom protocol
    that will allow any other app to open and send data to our app.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 原生应用程序之间通过链接进行通信也是一种常见行为，并且通常提示用户使用短语“在...中打开”，以及更好地处理操作的应用程序的名称。这是通过使用特定于您的应用程序的协议来完成的。就像任何网站链接都有`http://`或`https://`的协议一样，我们也可以创建一个自定义协议，允许任何其他应用程序打开并向我们的应用程序发送数据。
- en: In this recipe, we will be creating a custom protocol called `invoked://`. By
    using the `invoked://` protocol, any other app can use it to run our app and pass
    data to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个名为`invoked://`的自定义协议。通过使用`invoked://`协议，任何其他应用程序都可以使用它来运行我们的应用程序并向其传递数据。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll be starting from a new vanilla React Native app. Let's
    name it `InvokeFromNative`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将从一个新的原生React Native应用程序开始。让我们将其命名为`InvokeFromNative`。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start by opening the native layer of the new project in Xcode. The first
    thing we need to do is adjust the project''s Build Settings. This can be done
    by selecting the root project in the left panel, then choosing the Build Settings
    tab along the top of the middle panel:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在Xcode中打开新项目的本地层。我们需要做的第一件事是调整项目的构建设置。这可以通过在左侧面板中选择根项目，然后选择中间面板顶部的构建设置选项卡来完成：
- en: '![](assets/d0e90cd7-0f3c-4270-85a1-05792d34f948.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0e90cd7-0f3c-4270-85a1-05792d34f948.png)'
- en: 'We''ll need to add a new entry to the Header Search Paths field:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向`Header Search Paths`字段添加一个新条目：
- en: '![](assets/3e1e1fb4-601b-4bbf-94f1-554e18e332da.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e1e1fb4-601b-4bbf-94f1-554e18e332da.png)'
- en: 'For the project to know the location of the React Native JavaScript, it needs
    the `$(SRCROOT)/../node_modules/react-native/Libraries` value. Let''s add it as
    a recursive entry:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目知道React Native JavaScript的位置，它需要`$(SRCROOT)/../node_modules/react-native/Libraries`的值。让我们将其添加为递归条目：
- en: '![](assets/068fa616-dda9-4c8c-b4ce-d540f1217b06.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/068fa616-dda9-4c8c-b4ce-d540f1217b06.png)'
- en: 'We also need to register our custom protocol, which will be used by other apps.
    Open the `Info.plist` file as source code (right-click then Open As | Source Code).
    Let''s add an entry to the file that will register our application under the `invoked://`
    protocol:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要注册我们的自定义协议，这将被其他应用程序使用。打开`Info.plist`文件作为源代码（右键单击然后选择`Open As | Source
    Code`）。让我们向文件添加一个条目，以注册我们的应用程序在`invoked://`协议下：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we need to add the `RCTLinkingManager` to the `AppDelegate` implementation,
    which lives in `AppDelegate.m`, and wire it to our app:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`RCTLinkingManager`添加到`AppDelegate`实现中，它位于`AppDelegate.m`中，并将其连接到我们的应用程序：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s move on to the React Native layer. Inside `index.js`, we''ll add
    our imports, which includes the `Linking` component:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行React Native层。在`index.js`中，我们将添加我们的导入，其中包括`Linking`组件：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we''ll create the class definition and register the component as `InvokeFromNative`.
    We''ll also define an initial `state` object with a `status` string property set
    to the value `''App Running''`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建类定义并将组件注册为`InvokeFromNative`。我们还将定义一个初始的`state`对象，其中包含一个`status`字符串属性，其值为`'App
    Running'`：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we''ll use the mount and unmount life cycle hooks to `add`/`remove` the
    event listener for the `invoked://` protocol. When the event is heard, the `onAppInvoked`
    method, which is defined in the next step, will be fired:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用挂载和卸载生命周期钩子来`add`/`remove`对`invoked://`协议的事件监听器。当事件被听到时，将触发下一步中定义的`onAppInvoked`方法：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `onAppInvoked` function simply takes the event from the event listener
    and updates `state.status` to reflect that invocation has happened, displaying
    the protocol via `event.url`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onAppInvoked`函数简单地接受事件监听器的事件并更新`state.status`以反映发生了调用，通过`event.url`显示协议：'
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `render` method''s only real purpose in this recipe is to render the `status`
    property on state:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个教程中，`render`方法的唯一真正目的是在状态上呈现`status`属性：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll also add a few basic styles to center and size the text:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一些基本样式来居中和调整文本的大小：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our app is finished. Once you''ve started running the app, you should see something
    like this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序已经完成。一旦您开始运行应用程序，您应该会看到类似于这样的东西：
- en: '![](assets/d62bd623-bd8b-495d-a7c1-39a95eedbec4.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d62bd623-bd8b-495d-a7c1-39a95eedbec4.png)'
- en: 'With the app running, we can simulate the action of another app opening our
    React Native app using the `invoked://` protocol. This can be done with the following
    Terminal command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序运行时，我们可以模拟另一个应用程序打开我们的React Native应用程序的操作，使用“invoked://”协议可以通过以下终端命令完成：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once invoked, the app should update to reflect the invocation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用，应用程序应更新以反映调用：
- en: '![](assets/c8a2362a-570a-4888-a103-c418c6f76378.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8a2362a-570a-4888-a103-c418c6f76378.png)'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we covered how to register a custom protocol (or URL schema)
    for allowing our app to be invoked by other apps. The aim of this recipe was to
    keep our example as simple as possible, so we did not build out the handling data
    we passed to an app via the linking mechanism. However, it is entirely possible
    to do so if the needs of your app require it. For a deeper dive on the `Linking`
    component, check out the official documents at [https://facebook.github.io/react-native/docs/linking](https://facebook.github.io/react-native/docs/linking).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们介绍了如何注册自定义协议（或URL模式），以允许我们的应用程序被其他应用程序调用。这个配方的目的是尽可能简单地保持我们的示例，因此我们没有构建通过链接机制传递给应用程序的数据处理。但是，如果您的应用程序需要，完全可以这样做。要深入了解“Linking”组件，请查看官方文档[https://facebook.github.io/react-native/docs/linking](https://facebook.github.io/react-native/docs/linking)。
- en: Combining a React Native app and a native Android app
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合React Native应用程序和本机Android应用程序
- en: Since the Android platform still holds the majority stake in the smartphone
    market space, it's likely that you'll want to build the app for both Android as
    well as iOS. A large advantage of React Native development is making this process
    easier. But what happens when you want to write a new feature using React Native
    for a working Android app that's already been published? Fortunately, React Native makes
    this possible as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android平台仍然在智能手机市场占据主导地位，您可能希望为Android和iOS构建应用程序。React Native开发的一个重大优势是使这一过程更加容易。但是，当您想要使用React
    Native为已经发布的Android应用程序编写新功能时会发生什么？幸运的是，React Native也可以实现这一点。
- en: This recipe will cover the process of embedding a React Native app inside an
    existing Android app by displaying the React Native app inside a container view.
    The steps here are used as a baseline for the recipes that follow, which involve
    communication with a React Native app.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本文将介绍在现有Android应用程序中嵌入React Native应用程序的过程，方法是在容器视图中显示React Native应用程序。这些步骤将作为后续配方的基线，这些配方涉及与React
    Native应用程序的通信。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this section, we will create a sample Android application using Android
    Studio called `EmbedApp`. If you have a base Android application you would like
    to work with, you can skip these steps and proceed to the actual implementation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Android Studio创建一个名为“EmbedApp”的示例Android应用程序。如果您有一个基本的Android应用程序要使用，可以跳过这些步骤并继续进行实际实现：
- en: Open Android Studio and create a new project (File|New Project)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio并创建一个新项目（文件|新项目）
- en: Set the application name to `EmbeddedApp` and fill out your company domain.
    Press Next
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序名称设置为“EmbeddedApp”并填写您的公司域。按“下一步”
- en: Leave Empty Activity selected as the default and press Next
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留“空活动”作为默认选择，然后按“下一步”
- en: Leave the Activity properties as they are by default and press Finish
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Activity属性保留为默认值，然后按“完成”
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'At this point, our app has no references to React Native, so we''ll start by
    installing it. In the app''s root folder, in the Terminal, install React Native
    from the command line using `yarn`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们的应用程序没有与React Native相关的引用，因此我们将从安装它开始。在应用程序的根文件夹中，在终端中使用“yarn”命令安装React
    Native：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Alternatively, you can use `npm`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用“npm”：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ll also need a Node.js script for starting the React Native app. Let''s
    open `package.json` and add the following property as a member of the scripts object:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个用于启动React Native应用程序的Node.js脚本。让我们打开`package.json`并将以下属性添加为`scripts`对象的成员：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We only need a very simple React Native app for this recipe. Let''s create
    an `index.android.js` file with the following boilerplate app:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们只需要一个非常简单的React Native应用程序。让我们创建一个带有以下样板应用程序的`index.android.js`文件：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Naming this file `index.android.js` indicates to React Native that this code
    only applies to the Android version of this app. This is recommended by the official
    docs when platform-specific code is more complex. You can read more about it at [https://facebook.github.io/react-native/docs/platform-specific-code#platform-specific-extensions](https://facebook.github.io/react-native/docs/platform-specific-code#platform-specific-extensions).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件命名为`index.android.js`表示对React Native来说，此代码仅适用于此应用程序的Android版本。这是官方文档推荐的做法，当平台特定的代码更复杂时。您可以在[https://facebook.github.io/react-native/docs/platform-specific-code#platform-specific-extensions](https://facebook.github.io/react-native/docs/platform-specific-code#platform-specific-extensions)了解更多信息。
- en: 'Let''s return to Android Studio and open the `build.gradle` file (from the app module)
    and add the following to the dependencies:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们返回到Android Studio并打开`build.gradle`文件（来自`app`模块），并将以下内容添加到`dependencies`中：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll also need a reference to the local React Native maven directory. Open
    the other `build.gradle` and add the following line to the `allprojects.repositories`
    object:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个对本地React Native maven目录的引用。打开另一个`build.gradle`文件，并将以下行添加到`allprojects.repositories`对象中：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, let''s update the app''s permissions to use the internet, and the system
    alert window. We''ll open `AndroidManifest.xml` and add the following permissions
    to the `<manifest>` node:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们更新应用程序的权限以使用互联网和系统警报窗口。我们将打开`AndroidManifest.xml`并将以下权限添加到`<manifest>`节点：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''re ready to update the `MainApplication` Java class. The `getUseDeveloperSupport`
    method here will enable the development menu. The `getPackages` method is a list
    of packages used by the app, and only includes `MainReactPackage()` since we are
    only using the main React package. The `getJSMainModuleName` method returns the `index.android` string,
    which refers to the `index.android.js` file in the React Native layer:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备更新`MainApplication` Java类。这里的`getUseDeveloperSupport`方法将启用开发菜单。`getPackages`方法是应用程序使用的包的列表，只包括`MainReactPackage()`，因为我们只使用主要的React包。`getJSMainModuleName`方法返回`index.android`字符串，它指的是React
    Native层中的`index.android.js`文件：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, let''s create another new Java class with the name `ReactFragment`. This
    class needs three methods: `OnAttach` is called when the fragment is attached
    to the main activity, `OnCreateView` instantiates the view for the fragment, and
    `OnActivityCreated` is called when the activity is being created:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个名为`ReactFragment`的新Java类。这个类需要三个方法：`OnAttach`在片段附加到主活动时调用，`OnCreateView`实例化片段的视图，`OnActivityCreated`在活动被创建时调用：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, create a Java class called `EmbedFragment` that will extend `ReactFragment`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`EmbedFragment`的Java类，它将扩展`ReactFragment`：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let's open `MainActivity.java` and add `implements DefaultHardwareBackBtnHandler` to
    the class definition for handling hardware back button events. You can view the
    annotated source code for this React Native class here: [https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/DefaultHardwareBackBtnHandler.java](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/DefaultHardwareBackBtnHandler.java).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`MainActivity.java`并在类定义中添加`implements DefaultHardwareBackBtnHandler`以处理硬件返回按钮事件。您可以在此处查看此React
    Native类的带注释源代码：[https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/DefaultHardwareBackBtnHandler.java](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/modules/core/DefaultHardwareBackBtnHandler.java)。
- en: 'We''ll also be adding a few methods to the class. The `onCreate` method will
    set the content view to the Main Activity and add a FAB button that, when clicked,
    will instantiate a new instance of the `EmbedFragment` we defined in *step 10*.
    That instance of `EmbedFragment` is used by the fragment manager to add the React
    Native app to the view. The remaining methods handle the events that occur when
    the device''s system buttons are pressed (such as the back, pause, and resume
    buttons):'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将向类中添加一些方法。`onCreate`方法将把内容视图设置为主活动，并添加一个FAB按钮，当点击时，将实例化我们在*步骤10*中定义的`EmbedFragment`的新实例。`EmbedFragment`的这个实例由片段管理器用于将React
    Native应用添加到视图中。其余方法处理设备系统按钮被按下时发生的事件（如返回、暂停和恢复按钮）：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last step is to add some settings for the layout when the fragment is loaded.
    We''ll need to edit the `content_main.xml` file, which is located in the `/res`
    folder. This is the main content of the view. It holds the container view (`FrameLayout`)
    that we will attach the fragment to, and the other native elements should be displayed:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在片段加载时添加一些布局设置。我们需要编辑位于`/res`文件夹中的`content_main.xml`文件。这是视图的主要内容。它包含我们将附加片段的容器视图（`FrameLayout`），以及其他本机元素应该显示的内容：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the Terminal, run the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This builds and hosts the React Native app. Now, we can open the app in the Android
    emulator. You will see the following after pressing the FAB button:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建和托管React Native应用。现在，我们可以在Android模拟器中打开应用。按下FAB按钮后，您将看到以下内容：
- en: '![](assets/6f5ee6bb-0ec1-4474-9748-606437b3d2c8.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6f5ee6bb-0ec1-4474-9748-606437b3d2c8.png)'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To accomplish rendering React Native inside of our Android application, we had
    to perform a few steps. First, we had to define an `Application` class that implements
    the `ReactApplication` interface. Then, we had to create a `Fragment` that would
    be responsible for instantiating and rendering the `ReactRootView`. With a fragment,
    we are able to render the React Native view in our `MainActivity`. In this recipe,
    we added the fragment to our fragment container view. This essentially replaces
    all of the application content with the React Native application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的Android应用程序中呈现React Native，我们需要执行一些步骤。首先，我们需要定义一个实现`ReactApplication`接口的`Application`类。然后，我们需要创建一个负责实例化和呈现`ReactRootView`的`Fragment`。通过片段，我们能够在我们的`MainActivity`中呈现React
    Native视图。在这个教程中，我们将片段添加到我们的片段容器视图中。这实质上用React Native应用程序替换了所有应用程序内容。
- en: We covered a lot of integration code in this recipe. For a more in-depth look
    at how each of these pieces work, you can read the official documentation at [https://facebook.github.io/react-native/docs/integration-with-existing-apps.html](https://facebook.github.io/react-native/docs/integration-with-existing-apps.html).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们涵盖了大量的集成代码。要更深入地了解每个部分的工作原理，您可以阅读官方文档[https://facebook.github.io/react-native/docs/integration-with-existing-apps.html](https://facebook.github.io/react-native/docs/integration-with-existing-apps.html)。
- en: Communicating from an Android app to React Native
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Android应用程序到React Native的通信
- en: Now that we have covered how to render our React Native app inside an Android
    app in the *Combining a React Native app and a native Android app* recipe, we're
    ready to take the next step. Our React Native application should be more than
    a dummy UI. It should be able to react to actions that are going on in its parent
    application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何在*将React Native应用程序和本机Android应用程序结合*的教程中渲染我们的React Native应用程序，我们准备迈出下一步。我们的React
    Native应用程序应该不仅仅是一个虚拟UI。它应该能够对其父应用程序中正在进行的操作做出反应。
- en: In this recipe, we will accomplish sending data from our Android application
    to our embedded React Native app. The React Native application can accept data
    when it is first instantiated, and then at runtime. We will be covering how to
    accomplish both methods. This recipe will use `EditText` in the Android app and
    set up one-way binding to the React Native app.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将完成从我们的Android应用程序发送数据到我们嵌入的React Native应用程序。当React Native应用程序首次实例化时，它可以接受数据，然后在运行时。我们将介绍如何完成这两种方法。这个教程将在Android应用程序中使用“EditText”，并设置单向绑定到React
    Native应用程序。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, please ensure that you have an Android app with a React Native
    app embedded. If you need guidance to accomplish this, please complete the *Combining
    a React Native app and a native Android app* recipe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，请确保您有一个嵌入了React Native应用程序的Android应用程序。如果您需要指导来完成这一点，请完成*将React Native应用程序和本机Android应用程序结合*的教程。
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In Android Studio, open the Android portion of the React Native app. First,
    we'll need to edit `content_main.xml`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，打开React Native应用程序的Android部分。首先，我们需要编辑“content_main.xml”。
- en: 'We''ll only need a very simple layout for this app. You can edit the file by
    pressing the Text tab on the bottom to open the source editor and add/replace
    the following nodes:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们只需要一个非常简单的布局。您可以通过按下底部的“文本”选项卡来编辑文件，打开源编辑器并添加/替换以下节点：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Open `MainActivity.java` and add the following class fields:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainActivity.java”并添加以下类字段：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inside the `onCreatemethod`, set the `userNameField` property with the following
    code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“onCreate”方法中，使用以下代码设置“userNameField”属性：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We''ll be using a FAB button to update the content of the Android app to be
    our React Native app. We will need to replace `FloatingActionButtononClickListener` with
    the following:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用FAB按钮来更新Android应用程序的内容为我们的React Native应用程序。我们需要用以下内容替换“FloatingActionButtononClickListener”：
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we need to add a `TextChangedListener` to our `userNameField` in the `onCreate` method:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在“onCreate”方法中为我们的“userNameField”添加一个“TextChangedListener”：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The last change we need to make for our `Activity` is to add methods that will
    send the event across the React Native bridge:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的“Activity”做的最后一项更改是添加方法，将事件发送到React Native桥接中：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s return to the JavaScript layer. We''ll use the `addListener` method
    of the `NativeAppEventEmitter` component to listen to the `UserNameChanged` event
    that was sent from the native Android code, and update `state.userName` with the
    data from the event:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到JavaScript层。我们将使用“NativeAppEventEmitter”组件的“addListener”方法来监听从本机Android代码发送的“UserNameChanged”事件，并使用事件中的数据更新“state.userName”：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, if you run the application, you can enter text in the User Name field
    and start the React Native application:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您运行应用程序，您可以在“用户名”字段中输入文本，并启动React Native应用程序：
- en: '![](assets/8eed73c3-6777-48bd-81f6-965e890169aa.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8eed73c3-6777-48bd-81f6-965e890169aa.png)'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we rendered the fragment as an inline view. In *step 2*, we
    added an empty `FrameLayout` that we targeted in *step 5* to render the fragment.
    The binding functionality was accomplished by using the React Native bridge via
    `RCTDeviceEventEmitter`. This was originally designed to be used with native modules,
    but as long as you have access to the `ReactContext` instance, you can use it
    for any communication with the React Native JavaScript layer.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将片段呈现为内联视图。在*步骤2*中，我们添加了一个空的`FrameLayout`，我们在*步骤5*中将其定位为呈现片段。通过使用React
    Native桥接器`RCTDeviceEventEmitter`来实现绑定功能。这最初是设计用于与本地模块一起使用的，但只要您可以访问`ReactContext`实例，就可以将其用于与React
    Native JavaScript层的任何通信。
- en: Communicating from React Native to an Android app container
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从React Native通信到Android应用程序容器
- en: As we discussed in the previous recipe, it is extremely beneficial for our embedded application to
    be aware of what's going on around it. We should also make an effort so that our
    Android parent application can be informed about what goes on inside the React
    Native application. The application should not only be able to perform business
    logic – it should be able to update its UI to reflect changes in the embedded
    app.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个示例中讨论的那样，让我们的嵌入式应用程序了解其周围发生的事情是非常有益的。我们还应该努力让我们的Android父应用程序了解React
    Native应用程序内部发生的事情。应用程序不仅应能执行业务逻辑-还应能更新其UI以反映嵌入应用程序中的更改。
- en: This recipe shows us how to leverage native modules to update the native UI
    that's created inside the Android application. We will have a text field in our
    React Native app that updates a text field that is rendered in the host Android
    application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向我们展示了如何利用本地模块来更新在Android应用程序内部创建的本地UI。我们的React Native应用程序中将有一个文本字段，用于更新在主机Android应用程序中呈现的文本字段。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, please ensure that  you have an Android application with a
    React Native app embedded. If you need guidance to accomplish this, please complete
    the *Combining a React Native app and a native Android app* recipe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，请确保您有一个嵌入了React Native应用程序的Android应用程序。如果您需要指导来完成这个任务，请完成*组合React Native应用程序和本地Android应用程序*示例。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open Android Studioto your Project and open `content_main.xml`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio到您的项目并打开`content_main.xml`。
- en: 'Press the Texttab on the bottom to open the source editor and add/replace the
    following nodes:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按底部的Text标签打开源编辑器，并添加/替换以下节点：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Create a Java class named `UserNameManager`. This will be a native module that
    will serve the purpose of updating the `EditTextfield` we added to the layout.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UserNameManager`的Java类。这将是一个本地模块，用于更新我们添加到布局中的`EditTextfield`的目的。
- en: If you are not familiar with creating a native module for React Native, please
    refer to the *Exposing custom Android modules* recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉为React Native创建本地模块，请参阅[第11章](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml)中的*公开自定义Android模块*示例，*添加本地功能*。
- en: 'Most of the work in `UserNameManager.java` is being done in the `setUserName`
    method. Here, the Android layer updates the text contents of the view based on
    what it''s sent from the React Native layer. The React method isn''t necessarily
    going to run on the main UI thread, so we use `mainActivity.runOnUiThread` to
    update the view when the main UI thread is ready:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserNameManager.java`中的大部分工作都是在`setUserName`方法中完成的。在这里，Android层根据从React Native层发送的内容更新视图的文本内容。React方法不一定会在主UI线程上运行，因此我们使用`mainActivity.runOnUiThread`在主UI线程准备好时更新视图：'
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To export the `UserNameManager` module, we''ll need to edit the `UserNamePackage`
    Java class. We can export it to the React Native layer by calling `modules.add`,
    passing in a new `UserNameManager` that takes the `reactContext` as a parameter:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导出`UserNameManager`模块，我们需要编辑`UserNamePackage` Java类。我们可以通过调用`modules.add`将其导出到React
    Native层，传入一个以`reactContext`为参数的新`UserNameManager`：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add the `UserNamePackage` in the `getPackages` method in `MainApplication`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainApplication`的`getPackages`方法中添加`UserNamePackage`：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, we need to have our React Native UI render a `TextField` and call our `UserNameManager` native
    module. Open `index.android.js` and import the `TextInput` and `NativeModules` modules
    from `'react-native'`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要让我们的React Native UI渲染一个`TextField`并调用我们的`UserNameManager`本地模块。打开`index.android.js`并从`'react-native'`导入`TextInput`和`NativeModules`模块。
- en: 'Create a variable reference for the `UserNameManager`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UserNameManager`创建一个变量引用：
- en: '[PRE73]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The React Native app will simply need a `TextInput` for manipulating a `userName`
    property on the `state` object:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Native应用程序只需要一个`TextInput`来操作`state`对象上的`userName`属性：
- en: '[PRE74]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After running the application, starting the React Native embedded app, and
    adding text to the text field, you should see something similar to what''s shown
    in the following screenshot:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，启动React Native嵌入式应用程序，并向文本字段添加文本，您应该看到类似于以下截图所示的内容：
- en: '![](assets/c3c111f9-4a0b-455c-8784-1e859f69db12.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c3c111f9-4a0b-455c-8784-1e859f69db12.png)'
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To get our React Native app to update the native app containers, we created
    a native module. This is the recommended way of communicating from JavaScript
    to the native layer. However, since we had to update a native UI component, the
    operation had to be performed on the main thread. This is achieved by getting
    a reference to `MainActivity` and calling the `runOnUiThread` method. This is
    done in the `setUserName` method of *step 4*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的React Native应用程序更新本机应用程序容器，我们创建了一个本机模块。这是从JavaScript通信到本机层的推荐方式。但是，由于我们必须更新本机UI组件，因此操作必须在主线程上执行。这是通过获取对`MainActivity`的引用并调用`runOnUiThread`方法来实现的。这是在*步骤4*的`setUserName`方法中完成的。
- en: Handle being invoked by an external Android app
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理外部Android应用程序调用
- en: Earlier in this chapter, we covered how to handle invocation from an external
    app in iOS in the *Handle being invoked by an external Android app* recipe. In
    this recipe, we'll cover the same concept of deep linking in Android.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们介绍了如何在iOS中处理外部应用程序的调用，在*处理外部Android应用程序调用*中。在这个配方中，我们将介绍Android中深度链接的相同概念。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's begin by opening the React Native Android project in Android Studio and
    navigating to `AndroidManifest.xml`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在Android Studio中打开React Native Android项目，并导航到`AndroidManifest.xml`。
- en: 'For our example, we will register our application under `invoked://scheme`.
    We''ll update the `<activity>` node to the following:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将在`invoked://scheme`下注册我们的应用程序。我们将更新`<activity>`节点如下：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For more information on how this `intent-filter` works, refer to the official
    Android documentation at [https://developer.android.com/training/app-links/deep-linking](https://developer.android.com/training/app-links/deep-linking).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此`intent-filter`的工作原理的更多信息，请参阅官方Android文档[https://developer.android.com/training/app-links/deep-linking](https://developer.android.com/training/app-links/deep-linking)。
- en: 'Next, we''ll need to create a simple React Native app whose UI reacts to being
    invoked. Let''s open the `index.android.js` file. We''ll start by importing the `Linking`
    module in the `import` block from `''react-native''`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个简单的React Native应用程序，其UI对被调用做出反应。让我们打开`index.android.js`文件。我们将从`'react-native'`的`import`块中导入`Linking`模块：
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s build out the `App` class for the React Native app. When the component
    mounts, we''ll register a `Linking` event listener with an event we''ll name `url`.
    When this event occurs, `onAppInvoked` will be fired, updating the `status` property
    of state, along with the event that''s passed to the callback:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为React Native应用构建`App`类。当组件挂载时，我们将使用一个名为`url`的事件注册一个`Linking`事件监听器。当这个事件发生时，`onAppInvoked`将被触发，更新状态的`status`属性，以及传递给回调函数的事件：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Running the application and invoking it from another app will look something
    like this:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '运行应用程序并从另一个应用程序调用它将看起来像这样： '
- en: '![](assets/3c740e41-fd02-4b2a-8be2-32e7a7935dfc.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c740e41-fd02-4b2a-8be2-32e7a7935dfc.png)'
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we registered our URL schema for linking by editing the `AndroidManifest.xml` file
    in *step 2*. An important thing to note is the change of the `launchMode` to `singleTask`.
    This prevents the operating system from creating multiple instances of our React
    activity. This is important if you want to be able to properly capture the data
    that's passed along with the intent.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们通过编辑*步骤2*中的`AndroidManifest.xml`文件来注册我们的URL模式以进行链接。需要注意的一点是将`launchMode`更改为`singleTask`。这可以防止操作系统创建我们的React活动的多个实例。如果你想要能够正确捕获随意图传递的数据，这一点非常重要。
