- en: Chapter 10. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。最佳实践
- en: Before delving into the best practices to be followed while dealing with React,
    let's recap on what we have seen so far in the earlier chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨处理React时应遵循的最佳实践之前，让我们回顾一下我们在之前章节中所看到的内容。
- en: 'We have covered the following key points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了以下关键点：
- en: What is ReactJS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是ReactJS
- en: How we can build a responsive theme with React-Bootstrap and ReactJS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用React-Bootstrap和ReactJS构建响应式主题
- en: DOM interaction with React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与React的DOM交互
- en: ReactJS-JSX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactJS-JSX
- en: React-Bootstrap component integration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React-Bootstrap组件集成
- en: Redux architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux架构
- en: Routing with React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React进行路由
- en: React API integration with other APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React API与其他API集成
- en: React with Node.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Node.js一起使用React
- en: With the preceding topics, you should have a much clearer understanding about
    ReactJS, responsive themes, custom components, JSX, Redux, Flux, and integration
    with other APIs. I hope you have enjoyed this journey. Now we know where to start
    and how to write code, but it is also important to know how to write standard
    coding by following best practices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的主题，你应该对ReactJS、响应式主题、自定义组件、JSX、Redux、Flux以及与其他API的集成有了更清晰的理解。希望你喜欢这个旅程。现在我们知道从哪里开始以及如何编写代码，但了解如何遵循最佳实践编写标准代码也很重要。
- en: In 2015, there were many new releases and conferences conducted for React across
    the world and now I have seen many people asking how can we write standard code
    in React?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，全球范围内有许多关于React的新发布和会议，现在我看到很多人在问我们如何在React中编写标准代码？
- en: Each individual will have their opinion about following best practices. I have
    shared some of my observations and experiences with you so far, but you might
    have different opinions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人对遵循最佳实践都有自己的看法。到目前为止，我已经与你分享了一些观察和经验，但你可能有不同的看法。
- en: If you want more detailed stuff, you can always visit React's official sites
    and tutorials.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更详细的内容，你可以随时访问React的官方网站和教程。
- en: Handling data in React
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中处理数据
- en: Whenever we have components with dynamic functionality, data comes into the
    picture. The same applies with React; we have to deal with dynamic data, which
    seems easy but it is not every time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有具有动态功能的组件时，数据就会出现。同样适用于React；我们必须处理动态数据，这似乎很容易，但并非总是如此。
- en: Sounds confusing!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点混乱！
- en: Why is it easy and tough at the same time? Because, in React components, it's
    easy to pass properties and there are many ways to build rendering trees, but
    there is not much clarity about updating the views.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它既容易又困难？因为在React组件中，传递属性很容易，构建渲染树的方式有很多，但关于更新视图的清晰度并不多。
- en: In 2015, we have seen many Flux libraries and with them there have been many
    functional and reactive solutions released.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，我们看到了许多Flux库，随之而来的是许多功能性和反应性解决方案的发布。
- en: Using Flux
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Flux
- en: In my experience, many people have misconceptions regarding Flux as to where
    it's not needed. They are using it because they have a good grip on that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，许多人对Flux存在误解，认为它是不必要的。他们使用它是因为他们对它有很好的掌握。
- en: In our example, we have seen that Flux has a clear way to store and update the
    state of your application and when it is needed, it will trigger rendering.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们已经看到Flux有一种清晰的方式来存储和更新应用程序的状态，当需要时，它会触发渲染。
- en: 'Many times we have heard this: "*There are two sides to every coin"*. Likewise,
    Flux is also beneficial as well as harmful for your code. For example, it''s beneficial
    to declare global states for your application. Suppose that you have to manage
    logged in users and you are defining the state of router and active accounts;
    it will be painful when you start using Flux while managing temporary or local
    data.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听到这句话：“*每个硬币都有两面*”。同样，Flux也有利有弊。例如，为应用程序声明全局状态是有益的。假设你必须管理已登录的用户，并且正在定义路由器的状态和活动帐户的状态；当你开始使用Flux来管理临时或本地数据时，这将是痛苦的。
- en: From my perspective, I would not advise using Flux just in order to manage `/items/:itemIdroute`
    related data. Instead, you can just declare it within your component and you can
    store it there. How is it beneficial? The answer is, it will have a dependency
    on your component, so when your component does not exist, it will also not exist.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，我不建议仅仅为了管理`/items/:itemIdroute`相关数据而使用Flux。相反，你可以在你的组件中声明它并将其存储在那里。这有什么好处？答案是，它将依赖于你的组件，所以当你的组件不存在时，它也将不存在。
- en: 'For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding Redux-based reducer code, we are managing the `state` of the
    application as part of the reducers. It stores the previous `state` and `action`
    and returns the next state.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面基于Redux的reducer代码中，我们正在管理reducers的一部分作为应用程序的“state”。它存储先前的“state”和“action”，并返回下一个状态。
- en: Using Redux
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Redux
- en: 'As we know, in SPAs, when we have to contract with state and time, it would
    be difficult to handgrip state over time. Here, Redux helps a lot. How? Because,
    in a JavaScript application, Redux handles two states: one is the data state and
    another is the UI state and this is a standard option for SPAs. Moreover, bear
    in mind that Redux can be used with AngularJS, jQuery, or React JavaScript libraries
    or frameworks.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在单页应用程序中，当我们必须处理状态和时间时，难以掌握随时间变化的状态。在这里，Redux非常有帮助。为什么？因为在JavaScript应用程序中，Redux处理两种状态：一种是数据状态，另一种是UI状态，这是单页应用程序的标准选项。此外，请记住，Redux可以与AngularJS、jQuery或React
    JavaScript库或框架一起使用。
- en: Redux is equal to Flux, really?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux等于Flux，真的吗？
- en: Redux is a tool whereas Flux is just a pattern which you can't use via plug
    and play or download it. I'm not denying that Redux derives some influence from
    the Flux pattern but we can't say it's 100% similar to Flux.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个工具，而Flux只是一个模式，你不能通过即插即用或下载来使用它。我不否认Redux从Flux模式中获得了一些影响，但我们不能说它与Flux完全相似。
- en: Let's go ahead to and look at a few differences.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一些区别。
- en: Redux follows three guiding principles, as follows. We will also cover some
    differences between Redux and Flux.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Redux遵循三个指导原则，如下所示。我们还将介绍一些Redux和Flux之间的区别。
- en: Single-store approach
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单存储方法
- en: We have seen in earlier diagrams that the store is pretending to be an *intermediary*
    for all kinds of state modifications within applications and Redux is controlling
    the direct communication between two components through the store with a single
    point of communication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的图表中看到，存储假装是应用程序中所有种类状态修改的*中间人*，而Redux通过存储控制两个组件之间的直接通信，具有单一通信点。
- en: 'Here the difference between Redux and Flux is: Flux has multiple store approaches
    and Redux has a single-store approach.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Redux和Flux之间的区别在于：Flux有多个存储方法，而Redux有单一存储方法。
- en: Read-only state
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读状态
- en: In React applications, components cannot change state directly but have to dispatch
    changes to the store through `actions`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用中，组件不能直接改变状态，而必须通过“actions”将更改分派到存储中。
- en: 'Here, the `store` is an object and it has four methods, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`store`是一个对象，它有四种方法，如下所示：
- en: '`store.dispatch(action)`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.dispatch(action)`'
- en: '`store.subscribe(listener)`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.subscribe(listener)`'
- en: '`store.getState()`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.getState()`'
- en: '`replaceReducer(nextReducer)`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceReducer(nextReducer)`'
- en: Reducer functions to change the state
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer函数用于改变状态
- en: Reducer functions will handle `dispatch` actions to change the `state` as the
    Redux tool doesn't allow direct communication between two components; thus it
    will also not change the `state` but the `dispatch` action will be described for
    the `state` change.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer函数将处理`dispatch`动作以改变`state`，因为Redux工具不允许两个组件直接通信；因此它也不会改变`state`，而是会描述`state`的改变。
- en: 'Reducers here can be considered pure functions and the following are a few
    characteristics for writing reducer functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的Reducer可以被视为纯函数，编写Reducer函数的一些特点如下：
- en: No outside database or network calls
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有外部数据库或网络调用
- en: Returns values based on its parameters
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据其参数返回值
- en: Arguments are *immutable*
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数是*不可变的*
- en: The same argument returns the same value
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的参数返回相同的值
- en: Reducer functions are called pure-functions as they are doing nothing except
    returning a value based on their set parameters; they don't have any other consequences.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer函数被称为纯函数，因为它们除了根据其设置的参数返回值之外什么都不做；它们没有任何其他后果。
- en: In Flux or Redux architecture, it's always tough to deal with nested resources
    from an API's return, so it's recommended to have a flat state in your component
    such as `normalize`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux或Redux架构中，总是很难处理API返回的嵌套资源，因此建议在组件中使用`normalize`等平面状态。
- en: 'A hint for pros:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 专业提示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Immutable React state
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变的React状态
- en: In a flat state, we have the benefit of dealing with nested resources and `immutable`
    objects, along with the benefit, that a declared state cannot be modified.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在平面状态下，我们可以处理嵌套资源和`不可变`对象的好处，以及声明状态不可修改的好处。
- en: 'The other benefit of `immutable` objects is that, with their reference level
    equality checks, we can have fabulously improved rendering performance. For example,
    with `immutable` objects there is `shouldComponentUpdate`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`不可变`对象的另一个好处是，通过它们的引用级别相等检查，我们可以大大改善渲染性能。例如，使用`不可变`对象有`shouldComponentUpdate`：'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In JavaScript, the use of the **immutability deep freeze** node will help you
    to freeze nodes before mutation and then it will verify the results. The following
    code example shows the same logic:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，使用**不可变深冻结**节点将帮助您在变异之前冻结节点，然后验证结果。以下代码示例显示了相同的逻辑：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I hope that the preceding examples have clarified Immutable.js and its benefits.
    It also has uncomplicated methods but it isn''t much used:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望前面的例子已经阐明了Immutable.js及其好处。它也有简单的方法，但并没有被广泛使用：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From my point of view, it's a very fast and beautiful feature to use.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这是一个非常快速和美丽的功能。
- en: Observables and reactive solutions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察和响应式解决方案
- en: 'Quite often, I have heard people asking about the alternatives to Flux and
    Redux, as they want more reactive solutions. You can find some alternatives in
    the following list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常听到人们询问Flux和Redux的替代方案，因为他们想要更多的响应式解决方案。您可以在以下列表中找到一些替代方案：
- en: '**Cycle.js**: This is a functional and reactive JavaScript framework for cleaner
    code.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cycle.js**：这是一个功能性和响应式的JavaScript框架，用于编写更干净的代码。'
- en: '**.rx-flux**: This is the flux architecture with an add on, RxJS.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.rx-flux**：这是带有附加功能RxJS的flux架构。'
- en: '**redux-rx**: This is the utilities of RxJS, used for Redux.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**redux-rx**：这是用于Redux的RxJS实用程序。'
- en: '**Mobservable**: This comes with three different flavors--observable data,
    reactive functions, and simple code.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mobservable**：这带有三种不同的风味--可观察数据，响应式函数和简单代码。'
- en: React routing
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React路由
- en: We have to use routing in client-side applications. For ReactJS we also need
    another routing library, so I recommend you use `react-router`, which is provided
    by the React community.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在客户端应用程序中使用路由。对于ReactJS，我们还需要另一个路由库，因此我建议您使用由React社区提供的`react-router`。
- en: 'The advantages of React routing are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: React路由的优势包括：
- en: Viewing declarations in a standardized structure helps us to instantly identify
    our app views
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准化结构中查看声明有助于我们立即识别我们的应用程序视图
- en: Lazy code loading
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟加载代码
- en: Using `react-router`, we can easily handle the nested views and their progressive
    resolution of views
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`react-router`，我们可以轻松处理嵌套视图及其渐进式视图分辨率
- en: Using the browsing history feature, a user can navigate backwards/forwards and
    restore the state of the view
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览历史功能，用户可以向后/向前导航并恢复视图的状态
- en: Dynamic route matching
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由匹配
- en: CSS transitions on views when navigating
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航时的CSS过渡
- en: Standardized app structure and behavior, useful when working in a team
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化的应用程序结构和行为，在团队合作时非常有用
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The React router doesn't provide any way to handle data fetching. We need to
    use `async-props` or other React data fetching mechanisms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: React路由器不提供处理数据获取的任何方法。我们需要使用`async-props`或其他React数据获取机制。
- en: How React will help to split your code in lazy loading
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React如何帮助将您的代码拆分成延迟加载
- en: 'Very few developers who are dealing with **webpack module bundler** know about
    splitting your application code into several files of JavaScript:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有处理**webpack模块打包程序**的开发人员知道如何将应用程序代码拆分为多个JavaScript文件：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why this splitting of code is necessary is because each chunk of code is not
    always useful to each user and it's not necessary to load it on each page; it
    will overburden the browser. Therefore, to avoid such a situation, we should split
    our application into several chunks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要拆分代码是因为每个代码块并不总是对每个用户有用，并且不需要在每个页面上加载它；这会使浏览器过载。因此，为了避免这种情况，我们应该将应用程序拆分为多个代码块。
- en: 'Now, you may have the following question: If we have more chunks of code then
    will we have to have more HTTP requests, which will also affect performance? With
    the help of HTTP/2 multiplexed  ([https://http2.github.io/faq/#why-is-http2-multiplexed](https://http2.github.io/faq/#why-is-http2-multiplexed)),
    your problem will be resolved. Observe the following diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会有以下问题：如果我们有更多的代码块，那么我们是否需要更多的HTTP请求，这也会影响性能？借助HTTP/2多路复用（[https://http2.github.io/faq/#why-is-http2-multiplexed](https://http2.github.io/faq/#why-is-http2-multiplexed)），您的问题将得到解决。观察以下图表：
- en: '![How React will help to split your code in lazy loading](graphics/B05743_10_07-1.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![React如何帮助将您的代码拆分成延迟加载](graphics/B05743_10_07-1.jpg)'
- en: Visit [http://stackoverflow.com/questions/10480122/difference-between-http-pipeling-and-http-multiplexing-with-spdy](http://stackoverflow.com/questions/10480122/difference-between-http-pipeling-and-http-multiplexing-with-spdy) 
    for more information.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://stackoverflow.com/questions/10480122/difference-between-http-pipeling-and-http-multiplexing-with-spdy](http://stackoverflow.com/questions/10480122/difference-between-http-pipeling-and-http-multiplexing-with-spdy) 获取更多信息。
- en: You can also combine your chunked code with chunk hashing, which will also optimize
    your browser cache ratio whenever you change your code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将您的代码块与代码块哈希组合，这也将在您更改代码时优化您的浏览器缓存比率。
- en: JSX components
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX组件
- en: JSX is, in simple words, just an extension of JavaScript syntax. And if you
    observe the syntax or structure of JSX, you will find it to be similar to XML
    coding.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JSX就是简单地说，只是JavaScript语法的扩展。如果您观察JSX的语法或结构，您会发现它与XML编码类似。
- en: JSX performs preprocessor footsteps that add XML syntax to JavaScript. You can
    certainly use React without JSX but JSX makes React a lot more neat and elegant.
    Similar to XML, JSX tags have tag names, attributes, and children. JSX is also
    similar to XML in that, if an attribute value is enclosed in quotes, that value
    becomes a string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JSX执行预处理步骤，将XML语法添加到JavaScript中。您当然可以在没有JSX的情况下使用React，但JSX使React更加整洁和优雅。与XML类似，JSX标签具有标签名称、属性和子元素。JSX也类似于XML，如果属性值被引号括起来，那个值就成为字符串。
- en: XML works with balanced opening and closing tags; JSX works similarly and it
    helps make large trees which are easier to read than *function calls* or *object
    literals*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: XML使用平衡的开放和关闭标记；JSX类似地工作，并且有助于创建更易于阅读的大型树，而不是*函数调用*或*对象文字*。
- en: 'The advantages of using JSX in React are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中使用JSX的优势包括：
- en: JSX is much simpler to understand than JavaScript functions
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX比JavaScript函数更容易理解
- en: Mark-up in JSX is more familiar to the designer and the rest of your team
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX中的标记对设计师和团队的其他成员更加熟悉
- en: Your mark-up becomes more semantic, structured, and meaningful
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的标记变得更有语义，结构化和有意义
- en: How easy is it to visualize?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有多容易可视化？
- en: As I said, the structure and syntax are so easy to visualize and notice in JSX.
    They are intended to be more clear and readable in JSX format compared to JavaScript.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，结构和语法在JSX中非常容易可视化和注意到。与JavaScript相比，它们旨在在JSX格式中更清晰和可读。
- en: 'The following simple code snippets will give you a clearer idea. Let''s see
    a plain JavaScript `render` syntax:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的代码片段将给您一个更清晰的想法。让我们看一个简单的JavaScript `render` 语法：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lets look at the following JSX syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下JSX语法：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hopefully, it's very clear to you that it is much easier for non-programmers
    already familiar with HTML to work with JSX than with JavaScript.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您非常清楚，对于已经熟悉HTML的非程序员来说，使用JSX比使用JavaScript要容易得多。
- en: Acquaintance or understanding
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟人或理解
- en: In the development region, there are many teams such as non-developers, UI developers,
    and UX designers who are acquainted with HTML, and quality assurance teams who
    are responsible for thoroughly testing the product.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发领域，有许多团队，如非开发人员，UI开发人员和UX设计师熟悉HTML，以及质量保证团队负责彻底测试产品。
- en: JSX is a great way to clearly comprehend this structure in a solid and concise
    way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是一种清晰而简洁地理解这种结构的好方法。
- en: Semantics/structured syntax
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义/结构化语法
- en: Until now, we have seen how JSX syntax is easy to understand and visualize.
    Behind this there is a big reason for having a semantic syntax structure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到JSX语法易于理解和可视化。背后有一个具有语义语法结构的重要原因。
- en: JSX easily converts your JavaScript code into a more semantic, meaningful, and
    structured mark-up. This gives you the benefit of declaring your component structure
    and information using an HTML-like syntax, knowing it will transform into simple
    JavaScript functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JSX很容易将您的JavaScript代码转换为更有语义，有意义和结构化的标记。这使您能够使用类似HTML的语法声明组件结构和信息，知道它将转换为简单的JavaScript函数。
- en: React outlines all the HTML elements you would expect in the `React.DOM` namespace.
    The good part is that it also allows you to use your own written, custom components
    within the mark-up.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: React概述了您在`React.DOM`命名空间中期望的所有HTML元素。好处是它还允许您在标记中使用自己编写的自定义组件。
- en: 'Please check out the following HTML simple mark-up and see how the JSX component
    helps you have a semantic mark-up:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下HTML简单标记，并查看JSX组件如何帮助您拥有语义标记：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After wrapping this in a `divider` React composite component, you can use it
    like you would use any other HTML element with ease, and with the added benefit
    of a mark-up with better semantics:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将此包装在`divider` React复合组件中后，您可以轻松地像使用任何其他HTML元素一样使用它，并且具有更好语义标记的附加好处：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using classes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类
- en: 'Observe the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码片段：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may have observed that in the preceding code, the `React.Component` is being
    used in place of `creatClass`. There is nothing problematic if you use either
    of these, but many developers do not have a clear understanding about this and
    they mistakenly use both.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在前面的代码中，`React.Component`被用来代替`creatClass`。如果您使用其中任何一个都没有问题，但许多开发人员对此并不清楚，他们错误地同时使用两者。
- en: Using PropType
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PropType
- en: 'Knowledge of properties is a must; it will give you more flexibility to extend
    your component and save you time. Please refer to the following code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 了解属性是必须的；它将使您能够更灵活地扩展组件并节省时间。请参考以下代码片段：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can also validate your properties, the way we can validate properties for
    Immutable.js with React `ImmutablePropTypes`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以验证您的属性，就像我们可以使用React `ImmutablePropTypes`验证Immutable.js的属性一样。
- en: Benefits of higher-order components
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶组件的好处
- en: 'Observe the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码片段：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Higher-order components are just extended versions of your original component.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件只是原始组件的扩展版本。
- en: 'The main benefit of using them is that we can use them in multiple situations,
    for example in authentication or login validation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的主要好处是我们可以在多种情况下使用它们，例如在身份验证或登录验证中：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The other benefit is that, with higher-order components, you can fetch data
    separately and set your logic to have your views in a simple way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，通过高阶组件，您可以单独获取数据并设置逻辑，以简单的方式呈现视图。
- en: Redux architectural benefits
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux架构的好处
- en: 'Compared to other frameworks, the Redux architecture has more plus points:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他框架相比，Redux架构有更多的优点：
- en: It might not have any other side-effects
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能没有其他副作用
- en: As we know, binding is not needed because components can't interact directly
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们所知，不需要绑定，因为组件不能直接交互
- en: States are managed globally so there is less possibility of mismanagement
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是全局管理的，因此出现管理不善的可能性较小
- en: Sometimes, for middleware, it would be difficult to manage other side effects
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，对于中间件，管理其他副作用可能会很困难
- en: From the aforementioned points, it's very clear that the Redux architecture
    is very powerful and it has reusability as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述观点来看，Redux架构非常强大，并且具有可重用性。
- en: Customizing Bootstrap for your app
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的应用程序定制Bootstrap
- en: 'While reviewing best practices in React, how can we forget about the look and
    feel of our app? When we talk about responsiveness and wonderful components only
    one name comes to mind: Bootstrap. Bootstrap gives us a magic wand to achieve
    the best with less effort and also saves the money.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查React的最佳实践时，我们怎么能忘记我们应用程序的外观和感觉呢？当我们谈论响应性和精美的组件时，只有一个名字会浮现在脑海中：Bootstrap。Bootstrap为我们提供了一个魔法棒，可以在较少的努力下实现最佳效果，并节省金钱。
- en: These days, responsiveness is very important, or should I say, it's mandatory.
    While making your application, you should include Bootstrap in your package and
    you can leverage Bootstrap classes, Bootstrap grids, and Bootstrap-ready components.
    Moreover, Bootstrap's responsive themes are also available; some are free and
    some need to be paid for, but they are very useful. Earlier, we were writing media
    queries in CSS to achieve responsiveness but Bootstrap has really helped us by
    saving our time, efforts, and the client's money by providing wonderful ready-made
    features.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，响应性非常重要，或者我应该说，它是强制性的。在制作应用程序时，您应该在包中包含Bootstrap，并且可以利用Bootstrap类、Bootstrap网格和Bootstrap准备好的组件。此外，Bootstrap的响应式主题也可用；有些是免费的，有些需要付费，但它们非常有用。以前，我们在CSS中编写媒体查询以实现响应性，但Bootstrap通过提供精美的现成功能，真正帮助我们节省了时间、精力和客户的金钱。
- en: Bootstrap content - typography
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap内容 - 排版
- en: 'You might have observed that in the Bootstrap package, Bootstrap is using Helvetica
    font type, which is commonly used worldwide. So you only have the choice of using
    Helvetica, but you can also have some custom fonts, which you can find at [https://www.google.com/fonts](https://www.google.com/fonts).
    For example, if I wanted the **Lato** font from the Google library then I can
    select the font from there and choose the required font in the package, as shown
    in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在Bootstrap包中，Bootstrap使用的是全球通用的Helvetica字体类型。因此，您不仅可以选择使用Helvetica，还可以使用一些自定义字体，您可以在[https://www.google.com/fonts](https://www.google.com/fonts)找到。例如，如果我想要从Google库中选择**Lato**字体，那么我可以从那里选择字体，并在包中选择所需的字体，如下面的截图所示：
- en: '![Bootstrap content - typography](graphics/image_10_002.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap内容-排版](graphics/image_10_002.jpg)'
- en: 'Now the questions are: How can I use this font in my system? Should I download
    it? Or what is the way out? There is a very simple way, as we have seen in the
    preceding screenshot; the same dialog box has a tab called **EMBED**.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：我如何在我的系统中使用这个字体？我应该下载它吗？或者有什么办法？有一个非常简单的方法，正如我们在前面的截图中看到的那样；同一个对话框框有一个名为**EMBED**的选项卡。
- en: '![Bootstrap content - typography](graphics/image_10_003.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap内容-排版](graphics/image_10_003.jpg)'
- en: 'When you click on that, it will show you the following screen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击它时，它会显示以下屏幕：
- en: '![Bootstrap content - typography](graphics/image_10_004.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap内容-排版](graphics/image_10_004.jpg)'
- en: As shown in the **@IMPORT** tab, you can copy that line from `@import url()`
    and add it to your `bootstrap.less` file or `bootstrap.scss` file at the top of
    all the CSS. Then you can us the Lato font family in your application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如**@IMPORT**选项卡中所示，您可以从`@import url()`复制该行，并将其添加到您的`bootstrap.less`文件或`bootstrap.scss`文件的所有CSS顶部。然后您可以在应用程序中使用Lato字体系列。
- en: Moreover, you can also customize other font properties, such as font size, font
    color, and font style, if required.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要，您还可以自定义其他字体属性，例如字体大小、字体颜色和字体样式。
- en: Bootstrap component - navbar
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap组件-导航栏
- en: 'In any application, the navigation flow is very important and the Bootstrap
    `navbar` gives you a way to build responsive navigation with several options.
    You can even customize it by defining its size, color, and type, as shown in the
    following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，导航流非常重要，Bootstrap的`导航栏`为您提供了一种通过多种选项构建响应式导航的方式。您甚至可以通过定义其大小、颜色和类型来自定义它，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As seen in the preceding code, we can define whatever color we want in line
    with the expected look and feel of our `navbar` and its links:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们可以根据期望的外观定义任何颜色，以符合我们的`导航栏`及其链接：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Not only for desktops but also for mobile navigation, you can customize the
    `navbar default` color settings as per your requirements:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅适用于桌面，也适用于移动导航，您可以根据自己的需求自定义“导航栏默认”颜色设置：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can even set the `height` and `border` settings of `navbar`, as shown in
    the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以设置`导航栏`的`高度`和`边框`设置，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Bootstrap component - forms
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap组件-表单
- en: Forms are very commonly used to get data from the user, where you can use form
    elements and create components such as inquiry form, registration form, login
    form, contact us form, and so on. Bootstrap also provides the `form` component
    and its benefit lies in its responsive behavior. It is also customizable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表单非常常用于从用户那里获取数据，您可以使用表单元素并创建诸如查询表单、注册表单、登录表单、联系我们表单等组件。Bootstrap还提供了`form`组件，其好处在于其响应式行为。它也是可定制的。
- en: There are a couple of files in the Bootstrap package where you can change form-related
    CSS and get the expected output.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bootstrap包中有一些文件，您可以更改与表单相关的CSS并获得预期的输出。
- en: 'For example, changing the `input` field `border-radius` CSS property:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，更改`input`字段的`border-radius` CSS属性：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Changing the `border-focus` color for the `input` field:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`input`字段的`border-focus`颜色：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What I very much like in Bootstrap's latest version is that it has separate
    sections for each component/element like React does. For example, in mixins, you
    can see separate files, which have the respective CSS properties only, so they
    are be easy to understand, debug, and change.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢Bootstrap最新版本的一个特点，它为每个组件/元素都有单独的部分，就像React一样。例如，在混合中，您可以看到单独的文件，其中只有各自的CSS属性，因此它们易于理解、调试和更改。
- en: 'Form control (`.form-control`) is one of the beautiful features of the Bootstrap
    `form` component and you can see in the following code how easy it is to make
    custom changes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表单控件（`.form-control`）是Bootstrap`form`组件的一个美丽特性，您可以在以下代码中看到自定义更改是多么容易：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding example, we have seen how we can customize border colors,
    outlines, and box shadows; if you don''t want a box shadow then you can comment
    out that particular line and see the output without the box shadow, as shown in
    the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经看到了如何自定义边框颜色、轮廓和框阴影；如果您不想要框阴影，那么可以注释掉那一行代码，看看没有框阴影的输出，如以下代码所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You might have observed that I have commented code with `//`, which we generally
    do in JavaScript but it is also valid here and we can also use the CSS standard
    comment `/* */` to comment one line of code or multiple lines of code in CSS.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我用`//`对代码进行了注释，这是我们通常在JavaScript中做的，但在这里也是有效的，我们还可以使用CSS标准注释`/* */`来注释一行代码或多行代码。
- en: Bootstrap component - button
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap组件 - 按钮
- en: 'The Bootstrap component also has a ready-made component called `button`, so
    whatever button we are composing in our application, we can use Bootstrap classes
    to enhance it. The Bootstrap `button` component has different sizes, colors, and
    states, which can be customized as per your requirements:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap组件还有一个名为`button`的现成组件，因此无论我们在应用程序中组合什么按钮，都可以使用Bootstrap类来增强它。Bootstrap的`button`组件具有不同的大小、颜色和状态，可以根据您的要求进行自定义：
- en: '![Bootstrap component - button](graphics/image_10_005.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件 - 按钮](graphics/image_10_005.jpg)'
- en: 'We can also achieve a similar look and feel for states by using Bootstrap''s
    button classes as defined here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用Bootstrap的按钮类来实现类似的外观和感觉，如下所定义：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While writing HTML code for a button, you can define the Bootstrap class in
    the `button` tag of your application:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写按钮的HTML代码时，您可以在应用程序的`button`标签中定义Bootstrap类：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In previous chapters, we have also used Bootstrap classes to achieve responsiveness
    and the default components of Bootstrap. You can see one example of a `button`
    in the following screenshot, where I have defined the following code. We can also
    change the color of all the defined `button` states:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们还使用了Bootstrap类来实现响应性和Bootstrap的默认组件。您可以在以下截图中看到`button`的一个示例，我在其中定义了以下代码。我们还可以更改所有已定义的`button`状态的颜色：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Refer to the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图：
- en: '![Bootstrap component - button](graphics/B05743_10_05-2.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件 - 按钮](graphics/B05743_10_05-2.jpg)'
- en: Bootstrap themes
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap主题
- en: As I said earlier, Bootstrap also provides ready-made responsive themes, which
    we should use if required. For more details, you can check out [http://getbootstrap.com/examples/theme/](http://getbootstrap.com/examples/theme/).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，Bootstrap还提供了现成的响应式主题，如果需要的话，我们应该使用。有关更多详细信息，您可以查看[http://getbootstrap.com/examples/theme/](http://getbootstrap.com/examples/theme/)。
- en: 'You can also visit the following references to learn about more options for
    Bootstrap themes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以访问以下参考资料，了解更多有关Bootstrap主题的选项：
- en: '[http://www.blacktie.co/](http://www.blacktie.co/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.blacktie.co/](http://www.blacktie.co/)'
- en: '[https://wrapbootstrap.com/](https://wrapbootstrap.com/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wrapbootstrap.com/](https://wrapbootstrap.com/)'
- en: '[http://startbootstrap.com/](http://startbootstrap.com/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://startbootstrap.com/](http://startbootstrap.com/)'
- en: '[http://bootswatch.com/](http://bootswatch.com/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://bootswatch.com/](http://bootswatch.com/)'
- en: Bootstrap responsive grid system
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap响应式网格系统
- en: The Bootstrap grid system has some predefined classes and behaviors, so it would
    be very helpful to set your page layout and set different behaviors for the same
    layout in different devices and resolutions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap网格系统有一些预定义的类和行为，因此设置页面布局并为不同的设备和分辨率设置相同布局的不同行为将非常有帮助。
- en: 'The following screenshot shows you the setup of the mobile and desktop columns:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了移动设备和桌面列的设置：
- en: '![Bootstrap responsive grid system](graphics/image_10_007.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap响应式网格系统](graphics/image_10_007.jpg)'
- en: 'The following screenshot shows you the setup of the mobile, tablet, and desktop
    columns:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了移动设备、平板和桌面列的设置：
- en: '![Bootstrap responsive grid system](graphics/image_10_008.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap响应式网格系统](graphics/image_10_008.jpg)'
- en: This is how you can use predefined classes to set your columns. In small and
    medium-sized devices, they will automatically adjust your data to fit the resolution
    without breaking your user interface.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用预定义类来设置您的列。在小型和中型设备上，它们将自动调整您的数据以适应分辨率，而不会破坏用户界面。
- en: Lastly, I would like to inform you about some *Things to remember* while dealing
    with ReactJS.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想告诉你一些在处理ReactJS时需要记住的事情。
- en: Interesting information about ReactJS and Bootstrap projects
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于ReactJS和Bootstrap项目的有趣信息
- en: ReactJS and Bootstrap are both massively used and followed by communities in
    the developer world. There are millions of projects running on these two frameworks,
    so obviously there is a dedicated team behind these two successful frameworks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS和Bootstrap都被开发者社区广泛使用和关注。有数百万的项目在这两个框架上运行，显然这两个成功框架背后有一个专门的团队。
- en: 'Bootstrap is always launching something new and useful with their latest versions,
    or extensions, to their core area. We all know that Bootstrap is owned by Twitter
    Bootstrap and two developers should get the credit for its success: Mark Otto
    (`@mdo`) and Jacob Thornton (`@fat`)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap总是在他们的最新版本或扩展中推出一些新的有用的东西。我们都知道Bootstrap是由Twitter Bootstrap拥有的，两位开发者应该得到成功的功劳：Mark
    Otto (`@mdo`) 和 Jacob Thornton (`@fat`)
- en: 'There are many useful websites on Bootstrap, worth visiting in the searc for
    increased knowledge:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多关于Bootstrap的有用网站，值得在寻找增加知识的过程中访问：
- en: '[http://www.getbootstrap.com](http://www.getbootstrap.com) | Twitter: `@twbootstrap`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.getbootstrap.com](http://www.getbootstrap.com) | Twitter: `@twbootstrap`'
- en: '[http://expo.getbootstrap.com](http://expo.getbootstrap.com) | Twitter: Mark
    Otto (`@mdo`)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://expo.getbootstrap.com](http://expo.getbootstrap.com) | Twitter: Mark
    Otto (`@mdo`)'
- en: '[http://www.bootsnipp.com](http://www.bootsnipp.com) | Twitter: `@BootSnipp`
    and Maksim Surguy (`@msurguy`)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.bootsnipp.com](http://www.bootsnipp.com) | Twitter: `@BootSnipp`
    和 Maksim Surguy (`@msurguy`)'
- en: '[http://codeguide.co/](http://codeguide.co/)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://codeguide.co/](http://codeguide.co/)'
- en: '[http://roots.io/](http://roots.io/) | Twitter: Ben Word (`@retlehs`)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://roots.io/](http://roots.io/) | Twitter: Ben Word (`@retlehs`)'
- en: '[http://www.shoelace.io](http://www.shoelace.io) | Twitter: Erik Flowers (`@Erik_UX`)
    and Shaun Gilchrist'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.shoelace.io](http://www.shoelace.io) | Twitter: Erik Flowers (`@Erik_UX`)
    和 Shaun Gilchrist'
- en: '[https://github.com/JasonMortonNZ/bs3-sublime-plugin](https://github.com/JasonMortonNZ/bs3-sublime-plugin) |
    Twitter: Jason Morton (`@JasonMortonNZ`)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/JasonMortonNZ/bs3-sublime-plugin](https://github.com/JasonMortonNZ/bs3-sublime-plugin)
    | Twitter: Jason Morton (`@JasonMortonNZ`)'
- en: '[http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/) |
    Twitter: Dave Gandy (`@davegandy`)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)
    | Twitter: Dave Gandy (`@davegandy`)'
- en: '[http://bootstrapicons.com/](http://bootstrapicons.com/) | Twitter: Brent Swisher
    (`@BrentSwisher`)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://bootstrapicons.com/](http://bootstrapicons.com/) | Twitter: Brent Swisher
    (`@BrentSwisher`)'
- en: Helpful React projects
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的React项目
- en: 'At the beginner level, many developers find React very confusing but if you
    learn it by heart, interest, and know it in and out, you will love it. There are
    many open source projects that have been done on ReactJS, and which I have shared
    in the following list; I hope that it will definitely help you to understand React
    well:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在初学者级别，许多开发者发现React非常令人困惑，但如果你能够熟练掌握并深入了解它，你会喜欢它。有许多基于ReactJS完成的开源项目，我在下面的列表中分享了其中一些；我希望这肯定会帮助你更好地理解React：
- en: '**Calypso**:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Calypso**：'
- en: 'URL: [developer.wordpress.com/calypso](http://developer.wordpress.com/calypso)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[developer.wordpress.com/calypso](http://developer.wordpress.com/calypso)
- en: 'GitHub: Automattic/wp-calypso'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：Automattic/wp-calypso
- en: 'Developers: Automattic'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Automattic
- en: 'Front-end level technologies: React Redux wpcomjs'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React Redux wpcomjs
- en: 'Back-end level technologies: Node.js ExpressJS'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端级别技术：Node.js ExpressJS
- en: '**Sentry**:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sentry**：'
- en: 'URL: [getsentry.com/welcome](http://getsentry.com/welcome)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[getsentry.com/welcome](http://getsentry.com/welcome)
- en: 'GitHub: getsentry/sentry'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：getsentry/sentry
- en: 'Front-end level technologies: React'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React
- en: 'Back-end level technologies: Python'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端级别技术：Python
- en: '**SoundRedux**:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SoundRedux**：'
- en: 'URL: [soundredux.io/](https://soundredux.io/)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[soundredux.io/](https://soundredux.io/)
- en: 'GitHub: andrewngu/sound-redux'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：andrewngu/sound-redux
- en: 'Developer: Andrew Nguyen'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Andrew Nguyen
- en: 'Front-end level technologies: React Redux'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React Redux
- en: 'Back-end level technologies: Node.js'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端级别技术：Node.js
- en: '**Phoenix Trello**:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Phoenix Trello**：'
- en: 'URL: [phoenix-trello.herokuapp.com/](https://phoenix-trello.herokuapp.com/sign_in)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[phoenix-trello.herokuapp.com/](https://phoenix-trello.herokuapp.com/sign_in)
- en: 'GitHub: bigardone/phoenix-trello'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：bigardone/phoenix-trello
- en: 'Developer: Ricardo García'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Ricardo García
- en: 'Front-end level technologies: React Webpack Sass for the stylesheets React
    router Redux ES6/ES7 JavaScript'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React Webpack 用于样式表的Sass React路由器 Redux ES6/ES7 JavaScript
- en: 'Back-end level technologies: Elixir Phoenix framework Ecto PostgreSQL'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端级别技术：Elixir Phoenix 框架 Ecto PostgreSQL
- en: '**Kitematic**:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kitematic**：'
- en: 'URL: [kitematic.com](https://kitematic.com/)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[kitematic.com](https://kitematic.com/)
- en: 'GitHub: docker/kitematic'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：docker/kitematic
- en: 'Developers: Docker'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Docker
- en: 'Front-end level technologies: React'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React
- en: '**Google map clustering example**:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google 地图聚类示例**：'
- en: 'URL: [istarkov.github.io/google-map-clustering-example](http://istarkov.github.io/google-map-clustering-example/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[istarkov.github.io/google-map-clustering-example](http://istarkov.github.io/google-map-clustering-example/)
- en: 'GitHub: istarkov/google-map-clustering-example'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：istarkov/google-map-clustering-example
- en: 'Developer: Ivan Starkov'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Ivan Starkov
- en: 'Front-end level technologies: React'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React
- en: '**Fil**:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fil**：'
- en: 'URL: [fatiherikli.github.io/fil](http://fatiherikli.github.io/fil/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[fatiherikli.github.io/fil](http://fatiherikli.github.io/fil/)
- en: 'GitHub: fatiherikli/fil'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：fatiherikli/fil
- en: 'Developer: FatihErikli'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：FatihErikli
- en: 'Front-end level technologies: React Redux'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React Redux
- en: '**React iTunes Search**:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React iTunes 搜索**：'
- en: 'URL: [leoj.js.org/react-iTunes-search](http://leoj.js.org/react-iTunes-search/)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[leoj.js.org/react-iTunes-search](http://leoj.js.org/react-iTunes-search/)
- en: 'GitHub: LeoAJ/react-iTunes-search'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：LeoAJ/react-iTunes-search
- en: 'Developer: Leo Hsieh'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Leo Hsieh
- en: 'Front-end level technologies: React Packaging components: Webpack'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React 打包组件：Webpack
- en: '**Sprintly**:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sprintly**：'
- en: 'URL: [sprintly.ly](https://sprint.ly/)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[sprintly.ly](https://sprint.ly/)
- en: 'GitHub: sprintly/sprintly-ui'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：sprintly/sprintly-ui
- en: 'Developers: Quick Left'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Quick Left
- en: 'Front-end level technologies: React Flux React Router'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React Flux React Router
- en: 'Back-end technologies: Node.js'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端技术：Node.js
- en: '**Glimpse**:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glimpse**：'
- en: 'URL: [getglimpse.com/](http://getglimpse.com/)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：[getglimpse.com/](http://getglimpse.com/)
- en: 'GitHub: Glimpse/Glimpse'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：Glimpse/Glimpse
- en: 'Developers: Glimpse'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：Glimpse
- en: 'Front-end level technologies: React Packaging components: Webpack'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端级别技术：React 打包组件：Webpack
- en: 'Back-end level technologies: Node.js'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端级别技术：Node.js
- en: 'When you need support for ReactJS and Bootstrap, please refer to the following
    sites:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要对ReactJS和Bootstrap进行支持时，请参考以下网站：
- en: 'For React:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于React：
- en: '[https://facebook.github.io/react/community/support.html](https://facebook.github.io/react/community/support.html)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react/community/support.html](https://facebook.github.io/react/community/support.html)'
- en: 'For Bootstrap:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Bootstrap：
- en: '[http://getbootstrap.com/](http://getbootstrap.com/)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://getbootstrap.com/](http://getbootstrap.com/)'
- en: '[https://github.com/twbs/bootstrap/issues](https://github.com/twbs/bootstrap/issues)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/twbs/bootstrap/issues](https://github.com/twbs/bootstrap/issues)'
- en: Things to remember
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要记住的事情
- en: 'Observe the following list of points to remember:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下要记住的要点：
- en: Before you start working on React, always remember that it is just a view library,
    not an MVC framework.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始使用React之前，请始终记住它只是一个视图库，而不是MVC框架。
- en: It is advisable to have a small length of the component to deal with classes
    and modules; it also makes life easy when it comes to code understanding, unit
    testing, and long-running maintenance of a component.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议组件长度较小，以处理类和模块；这也使得在理解代码、单元测试和长期维护组件时更加轻松。
- en: React has introduced functions of props in its 0.14 version which is recommended
    to use. It is also known as a functional component that helps to split your component.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React在其0.14版本中引入了props函数，建议使用。它也被称为功能组件，有助于拆分您的组件。
- en: To avoid a painful journey while dealing with a React-based app, please don't
    use too many states.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理基于React的应用程序时，为了避免痛苦的旅程，请不要使用太多状态。
- en: As I said earlier, React is only a view library, so to deal with the rendering
    part I recommend using Redux rather than Flux.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我之前所说，React只是一个视图库，因此在处理渲染部分时，我建议使用Redux而不是Flux。
- en: If you want to have more type safety then always use `PropTypes`, which also
    helps to catch bugs early and acts as a document.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要更多的类型安全性，那么始终使用`PropTypes`，这也有助于早期发现错误并起到文档的作用。
- en: I recommend the use of the shallow rendering method to test React components,
    which allows rendering single components without touching their child components.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我建议使用浅渲染方法来测试React组件，这允许渲染单个组件而不触及其子组件。
- en: While dealing with large React applications, always use webpack, NPM, ES6, JSX,
    and Babel to complete your application.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理大型React应用程序时，始终使用webpack、NPM、ES6、JSX和Babel来完成您的应用程序。
- en: If you want to delve into React's applications and its elements, you can use
    the Redux-dev tools.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想深入了解React的应用程序及其元素，可以使用Redux-dev工具。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot in this chapter, so before concluding let's recap it all.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了很多内容，因此在结束之前让我们回顾一下。
- en: When we handle data in React, whenever we have components with dynamic functionality,
    data comes into the picture. With React, we have to deal with dynamic data, which
    seems easy but is'nt always.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在React中处理数据时，每当我们有具有动态功能的组件时，数据就会出现。在React中，我们必须处理动态数据，这似乎很容易，但并非总是如此。
- en: 'From my personal view, I do not advise using Flux just to manage `/items/:itemIdroute`-related
    data. Instead, you can just declare it within your component and you can store
    it there. How is it beneficial? The answer is: it will have a dependency on your
    component, so when your component does not exist, it will also not exist.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的个人观点来看，我不建议仅仅为了管理与`/items/:itemIdroute`相关的数据而使用Flux。相反，您可以在组件内部声明它并将其存储在那里。这有什么好处？答案是：它将依赖于您的组件，因此当您的组件不存在时，它也将不存在。
- en: Regarding the use of Redux, as we know, in single page applications, when we
    have to contract with state and time, it would be difficult to handgrip state
    over time. Here, Redux helps a lot.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用Redux，正如我们所知，在单页应用程序中，当我们必须处理状态和时间时，难以掌握随时间变化的状态。在这里，Redux非常有帮助。
- en: We also looked at other key factors such as JSX, flat states, immutable state,
    observables, reactive solutions, React routing, React classes, `ReactPropTypes`,
    and so on, which are the most usable elements in the React app.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了其他关键因素，如JSX、平面状态、不可变状态、可观察对象、响应式解决方案、React路由、React类、`ReactPropTypes`等等，这些都是React应用中最常用的元素。
- en: We have also covered the usefulness of Bootstrap and its components, which will
    give you more flexibility in dealing with different browsers and devices.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了Bootstrap及其组件的实用性，这将使您在处理不同的浏览器和设备时更加灵活。
- en: Finaly, we gave you, things to remember while dealing with any React application,
    whether it be a new application or just integration; these points will definitely
    help you a lot.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为您提供了在处理任何React应用程序时需要记住的事项，无论是新应用程序还是集成应用程序；这些要点肯定会对您有很大帮助。
