["```jsx\nrouter.route('/api/media/related/:mediaId')\n        .get(mediaCtrl.listRelated)\n```", "```jsx\nconst listRelated = (req, res) => {\n  Media.find({ \"_id\": { \"$ne\": req.media },\n  \"genre\": req.media.genre}).limit(4)\n  .sort('-views')\n  .populate('postedBy', '_id name')\n  .exec((err, posts) => {\n    if (err) {\n      return res.status(400).json({\n        error: errorHandler.getErrorMessage(err)\n      })\n    }\n    res.json(posts)\n  })\n}\n```", "```jsx\nconst listRelated = (params) => {\n  return fetch('/api/media/related/'+ params.mediaId, {\n    method: 'GET',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    }\n  }).then(response => {\n    return response.json() \n  }).catch((err) => console.log(err)) \n}\n```", "```jsx\n{this.props.media.map((item, i) => { \n    return \n      <span key={i}>... video snapshot ... | ... media details ...</span> \n  })\n}\n```", "```jsx\n\n<Link to={\"/media/\"+item._id}>\n  <ReactPlayer url={'/api/media/video/'+item._id} width='160px'    \n  height='140px'/>\n</Link>\n```", "```jsx\n<Typography type=\"title\" color=\"primary\">{item.title}</Typography>\n<Typography type=\"subheading\"> {item.genre} </Typography>\n<Typography component=\"p\">\n        {(new Date(item.created)).toDateString()}\n</Typography>\n<Typography type=\"subheading\">{item.views} views</Typography>\n```", "```jsx\n<Route path=\"/media/:mediaId\" component={PlayMedia}/>\n```", "```jsx\nloadMedia = (mediaId) => {\n    read({mediaId: mediaId}).then((data) => {\n      if (data.error) {\n        this.setState({error: data.error})\n      } else {\n        this.setState({media: data})\n          listRelated({\n            mediaId: data._id}).then((data) => {\n            if (data.error) {\n              console.log(data.error)\n            } else {\n              this.setState({relatedMedia: data})\n            }\n          })\n      }\n    })\n  }\n```", "```jsx\ncomponentDidMount = () => {\n    this.loadMedia(this.match.params.mediaId)\n}\ncomponentWillReceiveProps = (props) => {\n    this.loadMedia(props.match.params.mediaId)\n}\n```", "```jsx\nconstructor({match}) {\n    super() \n    this.state = {\n      media: {postedBy: {}},\n      relatedMedia: [],\n      autoPlay: false,\n    } \n    this.match = match \n}\n```", "```jsx\n{this.state.relatedMedia.length > 0 && \n      (<RelatedMedia media={this.state.relatedMedia}/>)}\n```", "```jsx\nconst nextUrl = this.state.relatedMedia.length > 0\n          ? `/media/${this.state.relatedMedia[0]._id}` : ''\n<Media media={this.state.media} \n       nextUrl={nextUrl} \n       handleAutoplay={this.handleAutoplay}/>\n```", "```jsx\nconst mediaUrl = this.props.media._id\n          ? `/api/media/video/${this.props.media._id}`\n          : null\n...\n<MediaPlayer srcUrl={mediaUrl} \n             nextUrl={this.props.nextUrl} \n             handleAutoplay={this.props.handleAutoplay}/>\n```", "```jsx\nstate = {\n      playing: true,\n      volume: 0.8,\n      muted: false,\n      played: 0,\n      loaded: 0,\n      duration: 0,\n      ended:false,\n      playbackRate: 1.0,\n      loop: false,\n      fullscreen: false,\n      videoError: false\n} \n```", "```jsx\nconst { playing, ended, volume, muted, loop, played, loaded, duration, playbackRate, fullscreen, videoError } = this.state\n...\n  <ReactPlayer\n     ref={this.ref}\n     width={fullscreen ? '100%':'inherit'}\n     height={fullscreen ? '100%':'inherit'}\n     style={fullscreen ? {position:'relative'} : {maxHeight: '500px'}}\n     config={{ attributes: { style: { height: '100%', width: '100%'} } }}\n     url={this.props.srcUrl}\n     playing={playing}\n     loop={loop}\n     playbackRate={playbackRate}\n     volume={volume}\n     muted={muted}\n     onEnded={this.onEnded}\n     onError={this.videoError}\n     onProgress={this.onProgress}\n     onDuration={this.onDuration}/>\n```", "```jsx\nref = player => {\n      this.player = player\n}\n```", "```jsx\nvideoError = e => {\n  this.setState({videoError: true}) \n}\n```", "```jsx\n{videoError && <p className={classes.videoError}>Video Error. Try again later.</p>}\n```", "```jsx\n<IconButton color=\"primary\" onClick={this.playPause}>\n    <Icon>{playing ? 'pause': (ended ? 'replay' : 'play_arrow')}</Icon>\n</IconButton>\n```", "```jsx\nplayPause = () => {\n     this.setState({ playing: !this.state.playing })\n}\n```", "```jsx\n<IconButton disabled={!this.props.nextUrl} color=\"primary\">\n    <Link to={this.props.nextUrl}>\n       <Icon>skip_next</Icon>\n    </Link>\n</IconButton>\n```", "```jsx\n<IconButton color={loop? 'primary' : 'default'} \n            onClick={this.onLoop}>\n    <Icon>loop</Icon>\n</IconButton>\n```", "```jsx\nonLoop = () => {\n   this.setState({ loop: !this.state.loop })\n}\n```", "```jsx\nonEnded = () => {\n    if(this.state.loop){\n      this.setState({ playing: true})\n    }else{\n      this.setState({ ended: true, playing: false })\n    }\n}\n```", "```jsx\n<IconButton color=\"primary\" onClick={this.toggleMuted}>\n    <Icon> {volume > 0 && !muted && 'volume_up' || \n            muted && 'volume_off' || \n               volume==0 && 'volume_mute'} </Icon>\n</IconButton>\n```", "```jsx\ntoggleMuted = () => {\n    this.setState({ muted: !this.state.muted })\n}\n```", "```jsx\n<input type=\"range\" \n       min={0} \n       max={1} \n       step='any' \n       value={muted? 0 : volume} \n       onChange={this.setVolume}/>\n```", "```jsx\n  setVolume = e => {\n    this.setState({ volume: parseFloat(e.target.value) })\n  }\n```", "```jsx\n<LinearProgress color=\"primary\" variant=\"buffer\" \n                value={played*100} valueBuffer={loaded*100} \n                style={{width: '100%'}} \n                classes={{ colorPrimary: classes.primaryColor,\n                           dashedColorPrimary: classes.primaryDashed,\n                           dashed: {animation: 'none'} }}\n/>\n```", "```jsx\nonProgress = progress => {\n    if (!this.state.seeking) {\n      this.setState({played: progress.played, loaded: progress.loaded})\n    }\n}\n```", "```jsx\n<input type=\"range\" min={0} max={1}\n       value={played} step='any'\n       onMouseDown={this.onSeekMouseDown}\n       onChange={this.onSeekChange}\n       onMouseUp={this.onSeekMouseUp}\n       style={{ position: 'absolute',\n                width: '100%',\n                top: '-7px',\n                zIndex: '999',\n                '-webkit-appearance': 'none',\n                backgroundColor: 'rgba(0,0,0,0)' }}\n/>\n```", "```jsx\nonSeekMouseDown = e => {\n    this.setState({ seeking: true })\n}\n```", "```jsx\nonSeekChange = e => {\n  this.setState({ played: parseFloat(e.target.value), \n                    ended: parseFloat(e.target.value) >= 1 })\n}\n```", "```jsx\nonSeekMouseUp = e => {\n  this.setState({ seeking: false })\n  this.player.seekTo(parseFloat(e.target.value))\n}\n```", "```jsx\nnpm install screenfull --save\n```", "```jsx\nimport screenfull from 'screenfull'\nimport { findDOMNode } from 'react-dom'\n```", "```jsx\ncomponentDidMount = () => {\n  if (screenfull.enabled) {\n     screenfull.on('change', () => {\n         let fullscreen = screenfull.isFullscreen ? true : false \n         this.setState({fullscreen: fullscreen}) \n     }) \n  }\n}\n```", "```jsx\n<IconButton color=\"primary\" onClick={this.onClickFullscreen}>\n  <Icon>fullscreen</Icon>\n</IconButton>\n```", "```jsx\nonClickFullscreen = () => {\n   screenfull.request(findDOMNode(this.player))\n}\n```", "```jsx\n<time dateTime={`P${Math.round(duration * played)}S`}>\n      {this.format(duration * played)}\n</time> / \n<time dateTime={`P${Math.round(duration)}S`}>\n    {this.format(duration)}\n</time>\n```", "```jsx\nonDuration = (duration) => {\n    this.setState({ duration })\n}\n```", "```jsx\nformat = (seconds) => {\n  const date = new Date(seconds * 1000)\n  const hh = date.getUTCHours()\n  let mm = date.getUTCMinutes()\n  const ss = ('0' + date.getUTCSeconds()).slice(-2)\n  if (hh) {\n    mm = ('0' + date.getUTCMinutes()).slice(-2) \n    return `${hh}:${mm}:${ss}`\n  }\n  return `${mm}:${ss}`\n}\n```", "```jsx\n<FormControlLabel \n    control={\n            <Switch\n              checked={this.state.autoPlay}\n              onChange={this.handleChange}\n              color=\"primary\"\n            />\n          }\n    label={this.state.autoPlay? 'Autoplay ON':'Autoplay OFF'}\n/>\n```", "```jsx\nhandleChange = (event) => {\n   this.setState({ autoPlay: event.target.checked }) \n} \n```", "```jsx\nhandleAutoplay = (updateMediaControls) => {\n    let playList = this.state.relatedMedia\n    let playMedia = playList[0]\n\n    if(!this.state.autoPlay || playList.length == 0 )\n      return updateMediaControls()\n\n    if(playList.length > 1){\n      playList.shift()\n      this.setState({media: playMedia, relatedMedia:playList})\n    }else{\n      listRelated({\n          mediaId: playMedia._id}).then((data) => {\n            if (data.error) {\n             console.log(data.error)\n            } else {\n             this.setState({media: playMedia, relatedMedia: data})\n            }\n         })\n    }\n  }\n```", "```jsx\nonEnded = () => {\n  if(this.state.loop){\n    this.setState({ playing: true})\n  }else{\n    this.props.handleAutoplay(() => {\n                              this.setState({ ended: true, \n                                                playing: false })\n                            }) \n    }\n}\n```", "```jsx\nnpm install react-router-config --save\n```", "```jsx\nimport PlayMedia from './media/PlayMedia' \nimport { read } from './media/api-media.js' \nconst routes = [\n  {\n    path: '/media/:mediaId',\n    component: PlayMedia,\n    loadData: (params) => read(params)\n  }\n]\nexport default routes \n```", "```jsx\nimport { matchRoutes } from 'react-router-config' \nimport routes from './../client/routeConfig' \nconst loadBranchData = (location) => {\n  const branch = matchRoutes(routes, location) \n  const promises = branch.map(({ route, match }) => {\n    return route.loadData\n      ? route.loadData(branch[0].match.params)\n      : Promise.resolve(null)\n  })\n  return Promise.all(promises)\n}\n```", "```jsx\nimport 'isomorphic-fetch'\n```", "```jsx\nserverUrl: process.env.serverUrl || 'http://localhost:3000'\n```", "```jsx\nimport config from '../../config/config'\nconst read = (params) => {\n  return fetch(config.serverUrl +'/api/media/' + params.mediaId, {\n    method: 'GET'\n  }).then((response) => { ... })\n```", "```jsx\n...\nloadBranchData(req.url).then(data => {\n    const markup = ReactDOMServer.renderToString(\n      <StaticRouter location={req.url} context={context}>\n        <JssProvider registry={sheetsRegistry}\n      generateClassName={generateClassName}>\n      <MuiThemeProvider theme={theme} sheetsManager={new Map()}>\n        < MainRouter data={data}/>\n      </MuiThemeProvider>\n    </JssProvider>\n      </StaticRouter>\n    ) \n...\n}).catch(err => {\n res.status(500).send(\"Data could not load\") \n }) \n...\n\n```", "```jsx\n  constructor({data}) {\n    super() \n      this.data = data \n  }\n```", "```jsx\n<Route path=\"/media/:mediaId\" \n       render={(props) => (\n          <PlayMedia {...props} data={this.data} />\n        )} />\n```", "```jsx\n...\nrender() {\n    if (this.props.data && this.props.data[0] != null) {\n      this.state.media = this.props.data[0] \n      this.state.relatedMedia = [] \n    }\n...\n}\n```"]